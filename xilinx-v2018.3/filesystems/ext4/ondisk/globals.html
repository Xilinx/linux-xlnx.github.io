

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Global Structures &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
      <li>Global Structures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/filesystems/ext4/ondisk/globals.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="global-structures">
<h1>Global Structures<a class="headerlink" href="#global-structures" title="Permalink to this headline">¶</a></h1>
<p>The filesystem is sharded into a number of block groups, each of which
have static metadata at fixed locations.</p>
<div class="section" id="super-block">
<h2>Super Block<a class="headerlink" href="#super-block" title="Permalink to this headline">¶</a></h2>
<p>The superblock records various information about the enclosing
filesystem, such as block counts, inode counts, supported features,
maintenance information, and more.</p>
<p>If the sparse_super feature flag is set, redundant copies of the
superblock and group descriptors are kept only in the groups whose group
number is either 0 or a power of 3, 5, or 7. If the flag is not set,
redundant copies are kept in all groups.</p>
<p>The superblock checksum is calculated against the superblock structure,
which includes the FS UUID.</p>
<p>The ext4 superblock is laid out as follows in
<code class="docutils literal"><span class="pre">struct</span> <span class="pre">ext4_super_block</span></code>:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Size</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>__le32</td>
<td>s_inodes_count</td>
<td>Total inode count.</td>
</tr>
<tr class="row-odd"><td>0x4</td>
<td>__le32</td>
<td>s_blocks_count_lo</td>
<td>Total block count.</td>
</tr>
<tr class="row-even"><td>0x8</td>
<td>__le32</td>
<td>s_r_blocks_count_lo</td>
<td>This number of blocks can only be allocated by the super-user.</td>
</tr>
<tr class="row-odd"><td>0xC</td>
<td>__le32</td>
<td>s_free_blocks_count_lo</td>
<td>Free block count.</td>
</tr>
<tr class="row-even"><td>0x10</td>
<td>__le32</td>
<td>s_free_inodes_count</td>
<td>Free inode count.</td>
</tr>
<tr class="row-odd"><td>0x14</td>
<td>__le32</td>
<td>s_first_data_block</td>
<td>First data block. This must be at least 1 for 1k-block filesystems and
is typically 0 for all other block sizes.</td>
</tr>
<tr class="row-even"><td>0x18</td>
<td>__le32</td>
<td>s_log_block_size</td>
<td>Block size is 2 ^ (10 + s_log_block_size).</td>
</tr>
<tr class="row-odd"><td>0x1C</td>
<td>__le32</td>
<td>s_log_cluster_size</td>
<td>Cluster size is (2 ^ s_log_cluster_size) blocks if bigalloc is
enabled. Otherwise s_log_cluster_size must equal s_log_block_size.</td>
</tr>
<tr class="row-even"><td>0x20</td>
<td>__le32</td>
<td>s_blocks_per_group</td>
<td>Blocks per group.</td>
</tr>
<tr class="row-odd"><td>0x24</td>
<td>__le32</td>
<td>s_clusters_per_group</td>
<td>Clusters per group, if bigalloc is enabled. Otherwise
s_clusters_per_group must equal s_blocks_per_group.</td>
</tr>
<tr class="row-even"><td>0x28</td>
<td>__le32</td>
<td>s_inodes_per_group</td>
<td>Inodes per group.</td>
</tr>
<tr class="row-odd"><td>0x2C</td>
<td>__le32</td>
<td>s_mtime</td>
<td>Mount time, in seconds since the epoch.</td>
</tr>
<tr class="row-even"><td>0x30</td>
<td>__le32</td>
<td>s_wtime</td>
<td>Write time, in seconds since the epoch.</td>
</tr>
<tr class="row-odd"><td>0x34</td>
<td>__le16</td>
<td>s_mnt_count</td>
<td>Number of mounts since the last fsck.</td>
</tr>
<tr class="row-even"><td>0x36</td>
<td>__le16</td>
<td>s_max_mnt_count</td>
<td>Number of mounts beyond which a fsck is needed.</td>
</tr>
<tr class="row-odd"><td>0x38</td>
<td>__le16</td>
<td>s_magic</td>
<td>Magic signature, 0xEF53</td>
</tr>
<tr class="row-even"><td>0x3A</td>
<td>__le16</td>
<td>s_state</td>
<td>File system state. See <a class="reference internal" href="#super-state">super_state</a> for more info.</td>
</tr>
<tr class="row-odd"><td>0x3C</td>
<td>__le16</td>
<td>s_errors</td>
<td>Behaviour when detecting errors. See <a class="reference internal" href="#super-errors">super_errors</a> for more info.</td>
</tr>
<tr class="row-even"><td>0x3E</td>
<td>__le16</td>
<td>s_minor_rev_level</td>
<td>Minor revision level.</td>
</tr>
<tr class="row-odd"><td>0x40</td>
<td>__le32</td>
<td>s_lastcheck</td>
<td>Time of last check, in seconds since the epoch.</td>
</tr>
<tr class="row-even"><td>0x44</td>
<td>__le32</td>
<td>s_checkinterval</td>
<td>Maximum time between checks, in seconds.</td>
</tr>
<tr class="row-odd"><td>0x48</td>
<td>__le32</td>
<td>s_creator_os</td>
<td>Creator OS. See the table <a class="reference internal" href="#super-creator">super_creator</a> for more info.</td>
</tr>
<tr class="row-even"><td>0x4C</td>
<td>__le32</td>
<td>s_rev_level</td>
<td>Revision level. See the table <a class="reference internal" href="#super-revision">super_revision</a> for more info.</td>
</tr>
<tr class="row-odd"><td>0x50</td>
<td>__le16</td>
<td>s_def_resuid</td>
<td>Default uid for reserved blocks.</td>
</tr>
<tr class="row-even"><td>0x52</td>
<td>__le16</td>
<td>s_def_resgid</td>
<td>Default gid for reserved blocks.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td><p class="first">These fields are for EXT4_DYNAMIC_REV superblocks only.</p>
<p>Note: the difference between the compatible feature set and the
incompatible feature set is that if there is a bit set in the
incompatible feature set that the kernel doesn’t know about, it should
refuse to mount the filesystem.</p>
<p class="last">e2fsck’s requirements are more strict; if it doesn’t know
about a feature in either the compatible or incompatible feature set, it
must abort and not try to meddle with things it doesn’t understand…</p>
</td>
</tr>
<tr class="row-even"><td>0x54</td>
<td>__le32</td>
<td>s_first_ino</td>
<td>First non-reserved inode.</td>
</tr>
<tr class="row-odd"><td>0x58</td>
<td>__le16</td>
<td>s_inode_size</td>
<td>Size of inode structure, in bytes.</td>
</tr>
<tr class="row-even"><td>0x5A</td>
<td>__le16</td>
<td>s_block_group_nr</td>
<td>Block group # of this superblock.</td>
</tr>
<tr class="row-odd"><td>0x5C</td>
<td>__le32</td>
<td>s_feature_compat</td>
<td>Compatible feature set flags. Kernel can still read/write this fs even
if it doesn’t understand a flag; fsck should not do that. See the
<a class="reference internal" href="#super-compat">super_compat</a> table for more info.</td>
</tr>
<tr class="row-even"><td>0x60</td>
<td>__le32</td>
<td>s_feature_incompat</td>
<td>Incompatible feature set. If the kernel or fsck doesn’t understand one
of these bits, it should stop. See the <a class="reference internal" href="#super-incompat">super_incompat</a> table for more
info.</td>
</tr>
<tr class="row-odd"><td>0x64</td>
<td>__le32</td>
<td>s_feature_ro_compat</td>
<td>Readonly-compatible feature set. If the kernel doesn’t understand one of
these bits, it can still mount read-only. See the <a class="reference internal" href="#super-rocompat">super_rocompat</a> table
for more info.</td>
</tr>
<tr class="row-even"><td>0x68</td>
<td>__u8</td>
<td>s_uuid[16]</td>
<td>128-bit UUID for volume.</td>
</tr>
<tr class="row-odd"><td>0x78</td>
<td>char</td>
<td>s_volume_name[16]</td>
<td>Volume label.</td>
</tr>
<tr class="row-even"><td>0x88</td>
<td>char</td>
<td>s_last_mounted[64]</td>
<td>Directory where filesystem was last mounted.</td>
</tr>
<tr class="row-odd"><td>0xC8</td>
<td>__le32</td>
<td>s_algorithm_usage_bitmap</td>
<td>For compression (Not used in e2fsprogs/Linux)</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Performance hints.  Directory preallocation should only happen if the
EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.</td>
</tr>
<tr class="row-odd"><td>0xCC</td>
<td>__u8</td>
<td>s_prealloc_blocks</td>
<td>#. of blocks to try to preallocate for … files? (Not used in
e2fsprogs/Linux)</td>
</tr>
<tr class="row-even"><td>0xCD</td>
<td>__u8</td>
<td>s_prealloc_dir_blocks</td>
<td>#. of blocks to preallocate for directories. (Not used in
e2fsprogs/Linux)</td>
</tr>
<tr class="row-odd"><td>0xCE</td>
<td>__le16</td>
<td>s_reserved_gdt_blocks</td>
<td>Number of reserved GDT entries for future filesystem expansion.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Journalling support is valid only if EXT4_FEATURE_COMPAT_HAS_JOURNAL is
set.</td>
</tr>
<tr class="row-odd"><td>0xD0</td>
<td>__u8</td>
<td>s_journal_uuid[16]</td>
<td>UUID of journal superblock</td>
</tr>
<tr class="row-even"><td>0xE0</td>
<td>__le32</td>
<td>s_journal_inum</td>
<td>inode number of journal file.</td>
</tr>
<tr class="row-odd"><td>0xE4</td>
<td>__le32</td>
<td>s_journal_dev</td>
<td>Device number of journal file, if the external journal feature flag is
set.</td>
</tr>
<tr class="row-even"><td>0xE8</td>
<td>__le32</td>
<td>s_last_orphan</td>
<td>Start of list of orphaned inodes to delete.</td>
</tr>
<tr class="row-odd"><td>0xEC</td>
<td>__le32</td>
<td>s_hash_seed[4]</td>
<td>HTREE hash seed.</td>
</tr>
<tr class="row-even"><td>0xFC</td>
<td>__u8</td>
<td>s_def_hash_version</td>
<td>Default hash algorithm to use for directory hashes. See <a class="reference internal" href="#super-def-hash">super_def_hash</a>
for more info.</td>
</tr>
<tr class="row-odd"><td>0xFD</td>
<td>__u8</td>
<td>s_jnl_backup_type</td>
<td>If this value is 0 or EXT3_JNL_BACKUP_BLOCKS (1), then the
<code class="docutils literal"><span class="pre">s_jnl_blocks</span></code> field contains a duplicate copy of the inode’s
<code class="docutils literal"><span class="pre">i_block[]</span></code> array and <code class="docutils literal"><span class="pre">i_size</span></code>.</td>
</tr>
<tr class="row-even"><td>0xFE</td>
<td>__le16</td>
<td>s_desc_size</td>
<td>Size of group descriptors, in bytes, if the 64bit incompat feature flag
is set.</td>
</tr>
<tr class="row-odd"><td>0x100</td>
<td>__le32</td>
<td>s_default_mount_opts</td>
<td>Default mount options. See the <a class="reference internal" href="#super-mountopts">super_mountopts</a> table for more info.</td>
</tr>
<tr class="row-even"><td>0x104</td>
<td>__le32</td>
<td>s_first_meta_bg</td>
<td>First metablock block group, if the meta_bg feature is enabled.</td>
</tr>
<tr class="row-odd"><td>0x108</td>
<td>__le32</td>
<td>s_mkfs_time</td>
<td>When the filesystem was created, in seconds since the epoch.</td>
</tr>
<tr class="row-even"><td>0x10C</td>
<td>__le32</td>
<td>s_jnl_blocks[17]</td>
<td>Backup copy of the journal inode’s <code class="docutils literal"><span class="pre">i_block[]</span></code> array in the first 15
elements and i_size_high and i_size in the 16th and 17th elements,
respectively.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>64bit support is valid only if EXT4_FEATURE_COMPAT_64BIT is set.</td>
</tr>
<tr class="row-even"><td>0x150</td>
<td>__le32</td>
<td>s_blocks_count_hi</td>
<td>High 32-bits of the block count.</td>
</tr>
<tr class="row-odd"><td>0x154</td>
<td>__le32</td>
<td>s_r_blocks_count_hi</td>
<td>High 32-bits of the reserved block count.</td>
</tr>
<tr class="row-even"><td>0x158</td>
<td>__le32</td>
<td>s_free_blocks_count_hi</td>
<td>High 32-bits of the free block count.</td>
</tr>
<tr class="row-odd"><td>0x15C</td>
<td>__le16</td>
<td>s_min_extra_isize</td>
<td>All inodes have at least # bytes.</td>
</tr>
<tr class="row-even"><td>0x15E</td>
<td>__le16</td>
<td>s_want_extra_isize</td>
<td>New inodes should reserve # bytes.</td>
</tr>
<tr class="row-odd"><td>0x160</td>
<td>__le32</td>
<td>s_flags</td>
<td>Miscellaneous flags. See the <a class="reference internal" href="#super-flags">super_flags</a> table for more info.</td>
</tr>
<tr class="row-even"><td>0x164</td>
<td>__le16</td>
<td>s_raid_stride</td>
<td>RAID stride. This is the number of logical blocks read from or written
to the disk before moving to the next disk. This affects the placement
of filesystem metadata, which will hopefully make RAID storage faster.</td>
</tr>
<tr class="row-odd"><td>0x166</td>
<td>__le16</td>
<td>s_mmp_interval</td>
<td>#. seconds to wait in multi-mount prevention (MMP) checking. In theory,
MMP is a mechanism to record in the superblock which host and device
have mounted the filesystem, in order to prevent multiple mounts. This
feature does not seem to be implemented…</td>
</tr>
<tr class="row-even"><td>0x168</td>
<td>__le64</td>
<td>s_mmp_block</td>
<td>Block # for multi-mount protection data.</td>
</tr>
<tr class="row-odd"><td>0x170</td>
<td>__le32</td>
<td>s_raid_stripe_width</td>
<td>RAID stripe width. This is the number of logical blocks read from or
written to the disk before coming back to the current disk. This is used
by the block allocator to try to reduce the number of read-modify-write
operations in a RAID5/6.</td>
</tr>
<tr class="row-even"><td>0x174</td>
<td>__u8</td>
<td>s_log_groups_per_flex</td>
<td>Size of a flexible block group is 2 ^ <code class="docutils literal"><span class="pre">s_log_groups_per_flex</span></code>.</td>
</tr>
<tr class="row-odd"><td>0x175</td>
<td>__u8</td>
<td>s_checksum_type</td>
<td>Metadata checksum algorithm type. The only valid value is 1 (crc32c).</td>
</tr>
<tr class="row-even"><td>0x176</td>
<td>__le16</td>
<td>s_reserved_pad</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>0x178</td>
<td>__le64</td>
<td>s_kbytes_written</td>
<td>Number of KiB written to this filesystem over its lifetime.</td>
</tr>
<tr class="row-even"><td>0x180</td>
<td>__le32</td>
<td>s_snapshot_inum</td>
<td>inode number of active snapshot. (Not used in e2fsprogs/Linux.)</td>
</tr>
<tr class="row-odd"><td>0x184</td>
<td>__le32</td>
<td>s_snapshot_id</td>
<td>Sequential ID of active snapshot. (Not used in e2fsprogs/Linux.)</td>
</tr>
<tr class="row-even"><td>0x188</td>
<td>__le64</td>
<td>s_snapshot_r_blocks_count</td>
<td>Number of blocks reserved for active snapshot’s future use. (Not used in
e2fsprogs/Linux.)</td>
</tr>
<tr class="row-odd"><td>0x190</td>
<td>__le32</td>
<td>s_snapshot_list</td>
<td>inode number of the head of the on-disk snapshot list. (Not used in
e2fsprogs/Linux.)</td>
</tr>
<tr class="row-even"><td>0x194</td>
<td>__le32</td>
<td>s_error_count</td>
<td>Number of errors seen.</td>
</tr>
<tr class="row-odd"><td>0x198</td>
<td>__le32</td>
<td>s_first_error_time</td>
<td>First time an error happened, in seconds since the epoch.</td>
</tr>
<tr class="row-even"><td>0x19C</td>
<td>__le32</td>
<td>s_first_error_ino</td>
<td>inode involved in first error.</td>
</tr>
<tr class="row-odd"><td>0x1A0</td>
<td>__le64</td>
<td>s_first_error_block</td>
<td>Number of block involved of first error.</td>
</tr>
<tr class="row-even"><td>0x1A8</td>
<td>__u8</td>
<td>s_first_error_func[32]</td>
<td>Name of function where the error happened.</td>
</tr>
<tr class="row-odd"><td>0x1C8</td>
<td>__le32</td>
<td>s_first_error_line</td>
<td>Line number where error happened.</td>
</tr>
<tr class="row-even"><td>0x1CC</td>
<td>__le32</td>
<td>s_last_error_time</td>
<td>Time of most recent error, in seconds since the epoch.</td>
</tr>
<tr class="row-odd"><td>0x1D0</td>
<td>__le32</td>
<td>s_last_error_ino</td>
<td>inode involved in most recent error.</td>
</tr>
<tr class="row-even"><td>0x1D4</td>
<td>__le32</td>
<td>s_last_error_line</td>
<td>Line number where most recent error happened.</td>
</tr>
<tr class="row-odd"><td>0x1D8</td>
<td>__le64</td>
<td>s_last_error_block</td>
<td>Number of block involved in most recent error.</td>
</tr>
<tr class="row-even"><td>0x1E0</td>
<td>__u8</td>
<td>s_last_error_func[32]</td>
<td>Name of function where the most recent error happened.</td>
</tr>
<tr class="row-odd"><td>0x200</td>
<td>__u8</td>
<td>s_mount_opts[64]</td>
<td>ASCIIZ string of mount options.</td>
</tr>
<tr class="row-even"><td>0x240</td>
<td>__le32</td>
<td>s_usr_quota_inum</td>
<td>Inode number of user <a class="reference external" href="quota">quota</a> file.</td>
</tr>
<tr class="row-odd"><td>0x244</td>
<td>__le32</td>
<td>s_grp_quota_inum</td>
<td>Inode number of group <a class="reference external" href="quota">quota</a> file.</td>
</tr>
<tr class="row-even"><td>0x248</td>
<td>__le32</td>
<td>s_overhead_blocks</td>
<td>Overhead blocks/clusters in fs. (Huh? This field is always zero, which
means that the kernel calculates it dynamically.)</td>
</tr>
<tr class="row-odd"><td>0x24C</td>
<td>__le32</td>
<td>s_backup_bgs[2]</td>
<td>Block groups containing superblock backups (if sparse_super2)</td>
</tr>
<tr class="row-even"><td>0x254</td>
<td>__u8</td>
<td>s_encrypt_algos[4]</td>
<td>Encryption algorithms in use. There can be up to four algorithms in use
at any time; valid algorithm codes are given in the <a class="reference internal" href="#super-encrypt">super_encrypt</a> table
below.</td>
</tr>
<tr class="row-odd"><td>0x258</td>
<td>__u8</td>
<td>s_encrypt_pw_salt[16]</td>
<td>Salt for the string2key algorithm for encryption.</td>
</tr>
<tr class="row-even"><td>0x268</td>
<td>__le32</td>
<td>s_lpf_ino</td>
<td>Inode number of lost+found</td>
</tr>
<tr class="row-odd"><td>0x26C</td>
<td>__le32</td>
<td>s_prj_quota_inum</td>
<td>Inode that tracks project quotas.</td>
</tr>
<tr class="row-even"><td>0x270</td>
<td>__le32</td>
<td>s_checksum_seed</td>
<td>Checksum seed used for metadata_csum calculations. This value is
crc32c(~0, $orig_fs_uuid).</td>
</tr>
<tr class="row-odd"><td>0x274</td>
<td>__u8</td>
<td>s_wtime_hi</td>
<td>Upper 8 bits of the s_wtime field.</td>
</tr>
<tr class="row-even"><td>0x275</td>
<td>__u8</td>
<td>s_wtime_hi</td>
<td>Upper 8 bits of the s_mtime field.</td>
</tr>
<tr class="row-odd"><td>0x276</td>
<td>__u8</td>
<td>s_mkfs_time_hi</td>
<td>Upper 8 bits of the s_mkfs_time field.</td>
</tr>
<tr class="row-even"><td>0x277</td>
<td>__u8</td>
<td>s_lastcheck_hi</td>
<td>Upper 8 bits of the s_lastcheck_hi field.</td>
</tr>
<tr class="row-odd"><td>0x278</td>
<td>__u8</td>
<td>s_first_error_time_hi</td>
<td>Upper 8 bits of the s_first_error_time_hi field.</td>
</tr>
<tr class="row-even"><td>0x279</td>
<td>__u8</td>
<td>s_last_error_time_hi</td>
<td>Upper 8 bits of the s_last_error_time_hi field.</td>
</tr>
<tr class="row-odd"><td>0x27A</td>
<td>__u8[2]</td>
<td>s_pad</td>
<td>Zero padding.</td>
</tr>
<tr class="row-even"><td>0x27C</td>
<td>__le32</td>
<td>s_reserved[96]</td>
<td>Padding to the end of the block.</td>
</tr>
<tr class="row-odd"><td>0x3FC</td>
<td>__le32</td>
<td>s_checksum</td>
<td>Superblock checksum.</td>
</tr>
</tbody>
</table>
<p id="super-state">The superblock state is some combination of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0001</td>
<td>Cleanly umounted</td>
</tr>
<tr class="row-odd"><td>0x0002</td>
<td>Errors detected</td>
</tr>
<tr class="row-even"><td>0x0004</td>
<td>Orphans being recovered</td>
</tr>
</tbody>
</table>
<p id="super-errors">The superblock error policy is one of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Continue</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Remount read-only</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Panic</td>
</tr>
</tbody>
</table>
<p id="super-creator">The filesystem creator is one of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>Linux</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>Hurd</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Masix</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>FreeBSD</td>
</tr>
<tr class="row-even"><td>4</td>
<td>Lites</td>
</tr>
</tbody>
</table>
<p id="super-revision">The superblock revision is one of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>Original format</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>v2 format w/ dynamic inode sizes</td>
</tr>
</tbody>
</table>
<p>Note that <code class="docutils literal"><span class="pre">EXT4_DYNAMIC_REV</span></code> refers to a revision 1 or newer filesystem.</p>
<p id="super-compat">The superblock compatible features field is a combination of any of the
following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x1</td>
<td>Directory preallocation (COMPAT_DIR_PREALLOC).</td>
</tr>
<tr class="row-odd"><td>0x2</td>
<td>“imagic inodes”. Not clear from the code what this does
(COMPAT_IMAGIC_INODES).</td>
</tr>
<tr class="row-even"><td>0x4</td>
<td>Has a journal (COMPAT_HAS_JOURNAL).</td>
</tr>
<tr class="row-odd"><td>0x8</td>
<td>Supports extended attributes (COMPAT_EXT_ATTR).</td>
</tr>
<tr class="row-even"><td>0x10</td>
<td>Has reserved GDT blocks for filesystem expansion
(COMPAT_RESIZE_INODE). Requires RO_COMPAT_SPARSE_SUPER.</td>
</tr>
<tr class="row-odd"><td>0x20</td>
<td>Has directory indices (COMPAT_DIR_INDEX).</td>
</tr>
<tr class="row-even"><td>0x40</td>
<td>“Lazy BG”. Not in Linux kernel, seems to have been for uninitialized
block groups? (COMPAT_LAZY_BG)</td>
</tr>
<tr class="row-odd"><td>0x80</td>
<td>“Exclude inode”. Not used. (COMPAT_EXCLUDE_INODE).</td>
</tr>
<tr class="row-even"><td>0x100</td>
<td>“Exclude bitmap”. Seems to be used to indicate the presence of
snapshot-related exclude bitmaps? Not defined in kernel or used in
e2fsprogs (COMPAT_EXCLUDE_BITMAP).</td>
</tr>
<tr class="row-odd"><td>0x200</td>
<td>Sparse Super Block, v2. If this flag is set, the SB field s_backup_bgs
points to the two block groups that contain backup superblocks
(COMPAT_SPARSE_SUPER2).</td>
</tr>
</tbody>
</table>
<p id="super-incompat">The superblock incompatible features field is a combination of any of the
following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x1</td>
<td>Compression (INCOMPAT_COMPRESSION).</td>
</tr>
<tr class="row-odd"><td>0x2</td>
<td>Directory entries record the file type. See ext4_dir_entry_2 below
(INCOMPAT_FILETYPE).</td>
</tr>
<tr class="row-even"><td>0x4</td>
<td>Filesystem needs recovery (INCOMPAT_RECOVER).</td>
</tr>
<tr class="row-odd"><td>0x8</td>
<td>Filesystem has a separate journal device (INCOMPAT_JOURNAL_DEV).</td>
</tr>
<tr class="row-even"><td>0x10</td>
<td>Meta block groups. See the earlier discussion of this feature
(INCOMPAT_META_BG).</td>
</tr>
<tr class="row-odd"><td>0x40</td>
<td>Files in this filesystem use extents (INCOMPAT_EXTENTS).</td>
</tr>
<tr class="row-even"><td>0x80</td>
<td>Enable a filesystem size of 2^64 blocks (INCOMPAT_64BIT).</td>
</tr>
<tr class="row-odd"><td>0x100</td>
<td>Multiple mount protection. Not implemented (INCOMPAT_MMP).</td>
</tr>
<tr class="row-even"><td>0x200</td>
<td>Flexible block groups. See the earlier discussion of this feature
(INCOMPAT_FLEX_BG).</td>
</tr>
<tr class="row-odd"><td>0x400</td>
<td>Inodes can be used to store large extended attribute values
(INCOMPAT_EA_INODE).</td>
</tr>
<tr class="row-even"><td>0x1000</td>
<td>Data in directory entry (INCOMPAT_DIRDATA). (Not implemented?)</td>
</tr>
<tr class="row-odd"><td>0x2000</td>
<td>Metadata checksum seed is stored in the superblock. This feature enables
the administrator to change the UUID of a metadata_csum filesystem
while the filesystem is mounted; without it, the checksum definition
requires all metadata blocks to be rewritten (INCOMPAT_CSUM_SEED).</td>
</tr>
<tr class="row-even"><td>0x4000</td>
<td>Large directory &gt;2GB or 3-level htree (INCOMPAT_LARGEDIR). Prior to
this feature, directories could not be larger than 4GiB and could not
have an htree more than 2 levels deep. If this feature is enabled,
directories can be larger than 4GiB and have a maximum htree depth of 3.</td>
</tr>
<tr class="row-odd"><td>0x8000</td>
<td>Data in inode (INCOMPAT_INLINE_DATA).</td>
</tr>
<tr class="row-even"><td>0x10000</td>
<td>Encrypted inodes are present on the filesystem. (INCOMPAT_ENCRYPT).</td>
</tr>
</tbody>
</table>
<p id="super-rocompat">The superblock read-only compatible features field is a combination of any of
the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x1</td>
<td>Sparse superblocks. See the earlier discussion of this feature
(RO_COMPAT_SPARSE_SUPER).</td>
</tr>
<tr class="row-odd"><td>0x2</td>
<td>This filesystem has been used to store a file greater than 2GiB
(RO_COMPAT_LARGE_FILE).</td>
</tr>
<tr class="row-even"><td>0x4</td>
<td>Not used in kernel or e2fsprogs (RO_COMPAT_BTREE_DIR).</td>
</tr>
<tr class="row-odd"><td>0x8</td>
<td>This filesystem has files whose sizes are represented in units of
logical blocks, not 512-byte sectors. This implies a very large file
indeed! (RO_COMPAT_HUGE_FILE)</td>
</tr>
<tr class="row-even"><td>0x10</td>
<td>Group descriptors have checksums. In addition to detecting corruption,
this is useful for lazy formatting with uninitialized groups
(RO_COMPAT_GDT_CSUM).</td>
</tr>
<tr class="row-odd"><td>0x20</td>
<td>Indicates that the old ext3 32,000 subdirectory limit no longer applies
(RO_COMPAT_DIR_NLINK). A directory’s i_links_count will be set to 1
if it is incremented past 64,999.</td>
</tr>
<tr class="row-even"><td>0x40</td>
<td>Indicates that large inodes exist on this filesystem
(RO_COMPAT_EXTRA_ISIZE).</td>
</tr>
<tr class="row-odd"><td>0x80</td>
<td>This filesystem has a snapshot (RO_COMPAT_HAS_SNAPSHOT).</td>
</tr>
<tr class="row-even"><td>0x100</td>
<td><a class="reference external" href="Quota">Quota</a> (RO_COMPAT_QUOTA).</td>
</tr>
<tr class="row-odd"><td>0x200</td>
<td>This filesystem supports “bigalloc”, which means that file extents are
tracked in units of clusters (of blocks) instead of blocks
(RO_COMPAT_BIGALLOC).</td>
</tr>
<tr class="row-even"><td>0x400</td>
<td>This filesystem supports metadata checksumming.
(RO_COMPAT_METADATA_CSUM; implies RO_COMPAT_GDT_CSUM, though
GDT_CSUM must not be set)</td>
</tr>
<tr class="row-odd"><td>0x800</td>
<td>Filesystem supports replicas. This feature is neither in the kernel nor
e2fsprogs. (RO_COMPAT_REPLICA)</td>
</tr>
<tr class="row-even"><td>0x1000</td>
<td>Read-only filesystem image; the kernel will not mount this image
read-write and most tools will refuse to write to the image.
(RO_COMPAT_READONLY)</td>
</tr>
<tr class="row-odd"><td>0x2000</td>
<td>Filesystem tracks project quotas. (RO_COMPAT_PROJECT)</td>
</tr>
</tbody>
</table>
<p id="super-def-hash">The <code class="docutils literal"><span class="pre">s_def_hash_version</span></code> field is one of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>Legacy.</td>
</tr>
<tr class="row-odd"><td>0x1</td>
<td>Half MD4.</td>
</tr>
<tr class="row-even"><td>0x2</td>
<td>Tea.</td>
</tr>
<tr class="row-odd"><td>0x3</td>
<td>Legacy, unsigned.</td>
</tr>
<tr class="row-even"><td>0x4</td>
<td>Half MD4, unsigned.</td>
</tr>
<tr class="row-odd"><td>0x5</td>
<td>Tea, unsigned.</td>
</tr>
</tbody>
</table>
<p id="super-mountopts">The <code class="docutils literal"><span class="pre">s_default_mount_opts</span></code> field is any combination of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0001</td>
<td>Print debugging info upon (re)mount. (EXT4_DEFM_DEBUG)</td>
</tr>
<tr class="row-odd"><td>0x0002</td>
<td>New files take the gid of the containing directory (instead of the fsgid
of the current process). (EXT4_DEFM_BSDGROUPS)</td>
</tr>
<tr class="row-even"><td>0x0004</td>
<td>Support userspace-provided extended attributes. (EXT4_DEFM_XATTR_USER)</td>
</tr>
<tr class="row-odd"><td>0x0008</td>
<td>Support POSIX access control lists (ACLs). (EXT4_DEFM_ACL)</td>
</tr>
<tr class="row-even"><td>0x0010</td>
<td>Do not support 32-bit UIDs. (EXT4_DEFM_UID16)</td>
</tr>
<tr class="row-odd"><td>0x0020</td>
<td>All data and metadata are commited to the journal.
(EXT4_DEFM_JMODE_DATA)</td>
</tr>
<tr class="row-even"><td>0x0040</td>
<td>All data are flushed to the disk before metadata are committed to the
journal. (EXT4_DEFM_JMODE_ORDERED)</td>
</tr>
<tr class="row-odd"><td>0x0060</td>
<td>Data ordering is not preserved; data may be written after the metadata
has been written. (EXT4_DEFM_JMODE_WBACK)</td>
</tr>
<tr class="row-even"><td>0x0100</td>
<td>Disable write flushes. (EXT4_DEFM_NOBARRIER)</td>
</tr>
<tr class="row-odd"><td>0x0200</td>
<td>Track which blocks in a filesystem are metadata and therefore should not
be used as data blocks. This option will be enabled by default on 3.18,
hopefully. (EXT4_DEFM_BLOCK_VALIDITY)</td>
</tr>
<tr class="row-even"><td>0x0400</td>
<td>Enable DISCARD support, where the storage device is told about blocks
becoming unused. (EXT4_DEFM_DISCARD)</td>
</tr>
<tr class="row-odd"><td>0x0800</td>
<td>Disable delayed allocation. (EXT4_DEFM_NODELALLOC)</td>
</tr>
</tbody>
</table>
<p id="super-flags">The <code class="docutils literal"><span class="pre">s_flags</span></code> field is any combination of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0001</td>
<td>Signed directory hash in use.</td>
</tr>
<tr class="row-odd"><td>0x0002</td>
<td>Unsigned directory hash in use.</td>
</tr>
<tr class="row-even"><td>0x0004</td>
<td>To test development code.</td>
</tr>
</tbody>
</table>
<p id="super-encrypt">The <code class="docutils literal"><span class="pre">s_encrypt_algos</span></code> list can contain any of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>Invalid algorithm (ENCRYPTION_MODE_INVALID).</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>256-bit AES in XTS mode (ENCRYPTION_MODE_AES_256_XTS).</td>
</tr>
<tr class="row-even"><td>2</td>
<td>256-bit AES in GCM mode (ENCRYPTION_MODE_AES_256_GCM).</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>256-bit AES in CBC mode (ENCRYPTION_MODE_AES_256_CBC).</td>
</tr>
</tbody>
</table>
<p>Total size of the superblock is 1024 bytes.</p>
</div>
<div class="section" id="block-group-descriptors">
<h2>Block Group Descriptors<a class="headerlink" href="#block-group-descriptors" title="Permalink to this headline">¶</a></h2>
<p>Each block group on the filesystem has one of these descriptors
associated with it. As noted in the Layout section above, the group
descriptors (if present) are the second item in the block group. The
standard configuration is for each block group to contain a full copy of
the block group descriptor table unless the sparse_super feature flag
is set.</p>
<p>Notice how the group descriptor records the location of both bitmaps and
the inode table (i.e. they can float). This means that within a block
group, the only data structures with fixed locations are the superblock
and the group descriptor table. The flex_bg mechanism uses this
property to group several block groups into a flex group and lay out all
of the groups’ bitmaps and inode tables into one long run in the first
group of the flex group.</p>
<p>If the meta_bg feature flag is set, then several block groups are
grouped together into a meta group. Note that in the meta_bg case,
however, the first and last two block groups within the larger meta
group contain only group descriptors for the groups inside the meta
group.</p>
<p>flex_bg and meta_bg do not appear to be mutually exclusive features.</p>
<p>In ext2, ext3, and ext4 (when the 64bit feature is not enabled), the
block group descriptor was only 32 bytes long and therefore ends at
bg_checksum. On an ext4 filesystem with the 64bit feature enabled, the
block group descriptor expands to at least the 64 bytes described below;
the size is stored in the superblock.</p>
<p>If gdt_csum is set and metadata_csum is not set, the block group
checksum is the crc16 of the FS UUID, the group number, and the group
descriptor structure. If metadata_csum is set, then the block group
checksum is the lower 16 bits of the checksum of the FS UUID, the group
number, and the group descriptor structure. Both block and inode bitmap
checksums are calculated against the FS UUID, the group number, and the
entire bitmap.</p>
<p>The block group descriptor is laid out in <code class="docutils literal"><span class="pre">struct</span> <span class="pre">ext4_group_desc</span></code>.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Size</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>__le32</td>
<td>bg_block_bitmap_lo</td>
<td>Lower 32-bits of location of block bitmap.</td>
</tr>
<tr class="row-odd"><td>0x4</td>
<td>__le32</td>
<td>bg_inode_bitmap_lo</td>
<td>Lower 32-bits of location of inode bitmap.</td>
</tr>
<tr class="row-even"><td>0x8</td>
<td>__le32</td>
<td>bg_inode_table_lo</td>
<td>Lower 32-bits of location of inode table.</td>
</tr>
<tr class="row-odd"><td>0xC</td>
<td>__le16</td>
<td>bg_free_blocks_count_lo</td>
<td>Lower 16-bits of free block count.</td>
</tr>
<tr class="row-even"><td>0xE</td>
<td>__le16</td>
<td>bg_free_inodes_count_lo</td>
<td>Lower 16-bits of free inode count.</td>
</tr>
<tr class="row-odd"><td>0x10</td>
<td>__le16</td>
<td>bg_used_dirs_count_lo</td>
<td>Lower 16-bits of directory count.</td>
</tr>
<tr class="row-even"><td>0x12</td>
<td>__le16</td>
<td>bg_flags</td>
<td>Block group flags. See the <a class="reference internal" href="#bgflags">bgflags</a> table below.</td>
</tr>
<tr class="row-odd"><td>0x14</td>
<td>__le32</td>
<td>bg_exclude_bitmap_lo</td>
<td>Lower 32-bits of location of snapshot exclusion bitmap.</td>
</tr>
<tr class="row-even"><td>0x18</td>
<td>__le16</td>
<td>bg_block_bitmap_csum_lo</td>
<td>Lower 16-bits of the block bitmap checksum.</td>
</tr>
<tr class="row-odd"><td>0x1A</td>
<td>__le16</td>
<td>bg_inode_bitmap_csum_lo</td>
<td>Lower 16-bits of the inode bitmap checksum.</td>
</tr>
<tr class="row-even"><td>0x1C</td>
<td>__le16</td>
<td>bg_itable_unused_lo</td>
<td>Lower 16-bits of unused inode count. If set, we needn’t scan past the
<code class="docutils literal"><span class="pre">(sb.s_inodes_per_group</span> <span class="pre">-</span> <span class="pre">gdt.bg_itable_unused)</span></code>th entry in the
inode table for this group.</td>
</tr>
<tr class="row-odd"><td>0x1E</td>
<td>__le16</td>
<td>bg_checksum</td>
<td>Group descriptor checksum; crc16(sb_uuid+group+desc) if the
RO_COMPAT_GDT_CSUM feature is set, or crc32c(sb_uuid+group_desc) &amp;
0xFFFF if the RO_COMPAT_METADATA_CSUM feature is set.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>These fields only exist if the 64bit feature is enabled and s_desc_size
&gt; 32.</td>
</tr>
<tr class="row-odd"><td>0x20</td>
<td>__le32</td>
<td>bg_block_bitmap_hi</td>
<td>Upper 32-bits of location of block bitmap.</td>
</tr>
<tr class="row-even"><td>0x24</td>
<td>__le32</td>
<td>bg_inode_bitmap_hi</td>
<td>Upper 32-bits of location of inodes bitmap.</td>
</tr>
<tr class="row-odd"><td>0x28</td>
<td>__le32</td>
<td>bg_inode_table_hi</td>
<td>Upper 32-bits of location of inodes table.</td>
</tr>
<tr class="row-even"><td>0x2C</td>
<td>__le16</td>
<td>bg_free_blocks_count_hi</td>
<td>Upper 16-bits of free block count.</td>
</tr>
<tr class="row-odd"><td>0x2E</td>
<td>__le16</td>
<td>bg_free_inodes_count_hi</td>
<td>Upper 16-bits of free inode count.</td>
</tr>
<tr class="row-even"><td>0x30</td>
<td>__le16</td>
<td>bg_used_dirs_count_hi</td>
<td>Upper 16-bits of directory count.</td>
</tr>
<tr class="row-odd"><td>0x32</td>
<td>__le16</td>
<td>bg_itable_unused_hi</td>
<td>Upper 16-bits of unused inode count.</td>
</tr>
<tr class="row-even"><td>0x34</td>
<td>__le32</td>
<td>bg_exclude_bitmap_hi</td>
<td>Upper 32-bits of location of snapshot exclusion bitmap.</td>
</tr>
<tr class="row-odd"><td>0x38</td>
<td>__le16</td>
<td>bg_block_bitmap_csum_hi</td>
<td>Upper 16-bits of the block bitmap checksum.</td>
</tr>
<tr class="row-even"><td>0x3A</td>
<td>__le16</td>
<td>bg_inode_bitmap_csum_hi</td>
<td>Upper 16-bits of the inode bitmap checksum.</td>
</tr>
<tr class="row-odd"><td>0x3C</td>
<td>__u32</td>
<td>bg_reserved</td>
<td>Padding to 64 bytes.</td>
</tr>
</tbody>
</table>
<p id="bgflags">Block group flags can be any combination of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x1</td>
<td>inode table and bitmap are not initialized (EXT4_BG_INODE_UNINIT).</td>
</tr>
<tr class="row-odd"><td>0x2</td>
<td>block bitmap is not initialized (EXT4_BG_BLOCK_UNINIT).</td>
</tr>
<tr class="row-even"><td>0x4</td>
<td>inode table is zeroed (EXT4_BG_INODE_ZEROED).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="block-and-inode-bitmaps">
<h2>Block and inode Bitmaps<a class="headerlink" href="#block-and-inode-bitmaps" title="Permalink to this headline">¶</a></h2>
<p>The data block bitmap tracks the usage of data blocks within the block
group.</p>
<p>The inode bitmap records which entries in the inode table are in use.</p>
<p>As with most bitmaps, one bit represents the usage status of one data
block or inode table entry. This implies a block group size of 8 *
number_of_bytes_in_a_logical_block.</p>
<p>NOTE: If <code class="docutils literal"><span class="pre">BLOCK_UNINIT</span></code> is set for a given block group, various parts
of the kernel and e2fsprogs code pretends that the block bitmap contains
zeros (i.e. all blocks in the group are free). However, it is not
necessarily the case that no blocks are in use – if <code class="docutils literal"><span class="pre">meta_bg</span></code> is set,
the bitmaps and group descriptor live inside the group. Unfortunately,
ext2fs_test_block_bitmap2() will return ‘0’ for those locations,
which produces confusing debugfs output.</p>
</div>
<div class="section" id="inode-table">
<h2>Inode Table<a class="headerlink" href="#inode-table" title="Permalink to this headline">¶</a></h2>
<p>Inode tables are statically allocated at mkfs time.  Each block group
descriptor points to the start of the table, and the superblock records
the number of inodes per group.  See the section on inodes for more
information.</p>
</div>
<div class="section" id="multiple-mount-protection">
<h2>Multiple Mount Protection<a class="headerlink" href="#multiple-mount-protection" title="Permalink to this headline">¶</a></h2>
<p>Multiple mount protection (MMP) is a feature that protects the
filesystem against multiple hosts trying to use the filesystem
simultaneously. When a filesystem is opened (for mounting, or fsck,
etc.), the MMP code running on the node (call it node A) checks a
sequence number. If the sequence number is EXT4_MMP_SEQ_CLEAN, the
open continues. If the sequence number is EXT4_MMP_SEQ_FSCK, then
fsck is (hopefully) running, and open fails immediately. Otherwise, the
open code will wait for twice the specified MMP check interval and check
the sequence number again. If the sequence number has changed, then the
filesystem is active on another machine and the open fails. If the MMP
code passes all of those checks, a new MMP sequence number is generated
and written to the MMP block, and the mount proceeds.</p>
<p>While the filesystem is live, the kernel sets up a timer to re-check the
MMP block at the specified MMP check interval. To perform the re-check,
the MMP sequence number is re-read; if it does not match the in-memory
MMP sequence number, then another node (node B) has mounted the
filesystem, and node A remounts the filesystem read-only. If the
sequence numbers match, the sequence number is incremented both in
memory and on disk, and the re-check is complete.</p>
<p>The hostname and device filename are written into the MMP block whenever
an open operation succeeds. The MMP code does not use these values; they
are provided purely for informational purposes.</p>
<p>The checksum is calculated against the FS UUID and the MMP structure.
The MMP structure (<code class="docutils literal"><span class="pre">struct</span> <span class="pre">mmp_struct</span></code>) is as follows:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>__le32</td>
<td>mmp_magic</td>
<td>Magic number for MMP, 0x004D4D50 (“MMP”).</td>
</tr>
<tr class="row-odd"><td>0x4</td>
<td>__le32</td>
<td>mmp_seq</td>
<td>Sequence number, updated periodically.</td>
</tr>
<tr class="row-even"><td>0x8</td>
<td>__le64</td>
<td>mmp_time</td>
<td>Time that the MMP block was last updated.</td>
</tr>
<tr class="row-odd"><td>0x10</td>
<td>char[64]</td>
<td>mmp_nodename</td>
<td>Hostname of the node that opened the filesystem.</td>
</tr>
<tr class="row-even"><td>0x50</td>
<td>char[32]</td>
<td>mmp_bdevname</td>
<td>Block device name of the filesystem.</td>
</tr>
<tr class="row-odd"><td>0x70</td>
<td>__le16</td>
<td>mmp_check_interval</td>
<td>The MMP re-check interval, in seconds.</td>
</tr>
<tr class="row-even"><td>0x72</td>
<td>__le16</td>
<td>mmp_pad1</td>
<td>Zero.</td>
</tr>
<tr class="row-odd"><td>0x74</td>
<td>__le32[226]</td>
<td>mmp_pad2</td>
<td>Zero.</td>
</tr>
<tr class="row-even"><td>0x3FC</td>
<td>__le32</td>
<td>mmp_checksum</td>
<td>Checksum of the MMP block.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="journal-jbd2">
<h2>Journal (jbd2)<a class="headerlink" href="#journal-jbd2" title="Permalink to this headline">¶</a></h2>
<p>Introduced in ext3, the ext4 filesystem employs a journal to protect the
filesystem against corruption in the case of a system crash. A small
continuous region of disk (default 128MiB) is reserved inside the
filesystem as a place to land “important” data writes on-disk as quickly
as possible. Once the important data transaction is fully written to the
disk and flushed from the disk write cache, a record of the data being
committed is also written to the journal. At some later point in time,
the journal code writes the transactions to their final locations on
disk (this could involve a lot of seeking or a lot of small
read-write-erases) before erasing the commit record. Should the system
crash during the second slow write, the journal can be replayed all the
way to the latest commit record, guaranteeing the atomicity of whatever
gets written through the journal to the disk. The effect of this is to
guarantee that the filesystem does not become stuck midway through a
metadata update.</p>
<p>For performance reasons, ext4 by default only writes filesystem metadata
through the journal. This means that file data blocks are /not/
guaranteed to be in any consistent state after a crash. If this default
guarantee level (<code class="docutils literal"><span class="pre">data=ordered</span></code>) is not satisfactory, there is a mount
option to control journal behavior. If <code class="docutils literal"><span class="pre">data=journal</span></code>, all data and
metadata are written to disk through the journal. This is slower but
safest. If <code class="docutils literal"><span class="pre">data=writeback</span></code>, dirty data blocks are not flushed to the
disk before the metadata are written to disk through the journal.</p>
<p>The journal inode is typically inode 8. The first 68 bytes of the
journal inode are replicated in the ext4 superblock. The journal itself
is normal (but hidden) file within the filesystem. The file usually
consumes an entire block group, though mke2fs tries to put it in the
middle of the disk.</p>
<p>All fields in jbd2 are written to disk in big-endian order. This is the
opposite of ext4.</p>
<p>NOTE: Both ext4 and ocfs2 use jbd2.</p>
<p>The maximum size of a journal embedded in an ext4 filesystem is 2^32
blocks. jbd2 itself does not seem to care.</p>
<div class="section" id="layout">
<h3>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">¶</a></h3>
<p>Generally speaking, the journal has this format:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="98%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Superblock</th>
<th class="head">descriptor_block (data_blocks or revocation_block) [more data or
revocations] commmit_block</th>
<th class="head">[more transactions…]</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#160;</td>
<td>One transaction</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Notice that a transaction begins with either a descriptor and some data,
or a block revocation list. A finished transaction always ends with a
commit. If there is no commit record (or the checksums don’t match), the
transaction will be discarded during replay.</p>
</div>
<div class="section" id="external-journal">
<h3>External Journal<a class="headerlink" href="#external-journal" title="Permalink to this headline">¶</a></h3>
<p>Optionally, an ext4 filesystem can be created with an external journal
device (as opposed to an internal journal, which uses a reserved inode).
In this case, on the filesystem device, <code class="docutils literal"><span class="pre">s_journal_inum</span></code> should be
zero and <code class="docutils literal"><span class="pre">s_journal_uuid</span></code> should be set. On the journal device there
will be an ext4 super block in the usual place, with a matching UUID.
The journal superblock will be in the next full block after the
superblock.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="95%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">1024 bytes of padding</th>
<th class="head">ext4 Superblock</th>
<th class="head">Journal Superblock</th>
<th class="head">descriptor_block (data_blocks or revocation_block) [more data or
revocations] commmit_block</th>
<th class="head">[more transactions…]</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>One transaction</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="block-header">
<h3>Block Header<a class="headerlink" href="#block-header" title="Permalink to this headline">¶</a></h3>
<p>Every block in the journal starts with a common 12-byte header
<code class="docutils literal"><span class="pre">struct</span> <span class="pre">journal_header_s</span></code>:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>__be32</td>
<td>h_magic</td>
<td>jbd2 magic number, 0xC03B3998.</td>
</tr>
<tr class="row-odd"><td>0x4</td>
<td>__be32</td>
<td>h_blocktype</td>
<td>Description of what this block contains. See the <a class="reference internal" href="#jbd2-blocktype">jbd2_blocktype</a> table
below.</td>
</tr>
<tr class="row-even"><td>0x8</td>
<td>__be32</td>
<td>h_sequence</td>
<td>The transaction ID that goes with this block.</td>
</tr>
</tbody>
</table>
<p id="jbd2-blocktype">The journal block type can be any one of:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>Descriptor. This block precedes a series of data blocks that were
written through the journal during a transaction.</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>Block commit record. This block signifies the completion of a
transaction.</td>
</tr>
<tr class="row-even"><td>3</td>
<td>Journal superblock, v1.</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>Journal superblock, v2.</td>
</tr>
<tr class="row-even"><td>5</td>
<td>Block revocation records. This speeds up recovery by enabling the
journal to skip writing blocks that were subsequently rewritten.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id1">
<h3>Super Block<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>The super block for the journal is much simpler as compared to ext4’s.
The key data kept within are size of the journal, and where to find the
start of the log of transactions.</p>
<p>The journal superblock is recorded as <code class="docutils literal"><span class="pre">struct</span> <span class="pre">journal_superblock_s</span></code>,
which is 1024 bytes long:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Static information describing the journal.</td>
</tr>
<tr class="row-odd"><td>0x0</td>
<td>journal_header_t (12 bytes)</td>
<td>s_header</td>
<td>Common header identifying this as a superblock.</td>
</tr>
<tr class="row-even"><td>0xC</td>
<td>__be32</td>
<td>s_blocksize</td>
<td>Journal device block size.</td>
</tr>
<tr class="row-odd"><td>0x10</td>
<td>__be32</td>
<td>s_maxlen</td>
<td>Total number of blocks in this journal.</td>
</tr>
<tr class="row-even"><td>0x14</td>
<td>__be32</td>
<td>s_first</td>
<td>First block of log information.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Dynamic information describing the current state of the log.</td>
</tr>
<tr class="row-even"><td>0x18</td>
<td>__be32</td>
<td>s_sequence</td>
<td>First commit ID expected in log.</td>
</tr>
<tr class="row-odd"><td>0x1C</td>
<td>__be32</td>
<td>s_start</td>
<td>Block number of the start of log. Contrary to the comments, this field
being zero does not imply that the journal is clean!</td>
</tr>
<tr class="row-even"><td>0x20</td>
<td>__be32</td>
<td>s_errno</td>
<td>Error value, as set by jbd2_journal_abort().</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>The remaining fields are only valid in a v2 superblock.</td>
</tr>
<tr class="row-even"><td>0x24</td>
<td>__be32</td>
<td>s_feature_compat;</td>
<td>Compatible feature set. See the table <a class="reference internal" href="#jbd2-compat">jbd2_compat</a> below.</td>
</tr>
<tr class="row-odd"><td>0x28</td>
<td>__be32</td>
<td>s_feature_incompat</td>
<td>Incompatible feature set. See the table <a class="reference internal" href="#jbd2-incompat">jbd2_incompat</a> below.</td>
</tr>
<tr class="row-even"><td>0x2C</td>
<td>__be32</td>
<td>s_feature_ro_compat</td>
<td>Read-only compatible feature set. There aren’t any of these currently.</td>
</tr>
<tr class="row-odd"><td>0x30</td>
<td>__u8</td>
<td>s_uuid[16]</td>
<td>128-bit uuid for journal. This is compared against the copy in the ext4
super block at mount time.</td>
</tr>
<tr class="row-even"><td>0x40</td>
<td>__be32</td>
<td>s_nr_users</td>
<td>Number of file systems sharing this journal.</td>
</tr>
<tr class="row-odd"><td>0x44</td>
<td>__be32</td>
<td>s_dynsuper</td>
<td>Location of dynamic super block copy. (Not used?)</td>
</tr>
<tr class="row-even"><td>0x48</td>
<td>__be32</td>
<td>s_max_transaction</td>
<td>Limit of journal blocks per transaction. (Not used?)</td>
</tr>
<tr class="row-odd"><td>0x4C</td>
<td>__be32</td>
<td>s_max_trans_data</td>
<td>Limit of data blocks per transaction. (Not used?)</td>
</tr>
<tr class="row-even"><td>0x50</td>
<td>__u8</td>
<td>s_checksum_type</td>
<td>Checksum algorithm used for the journal.  See <a class="reference internal" href="#jbd2-checksum-type">jbd2_checksum_type</a> for
more info.</td>
</tr>
<tr class="row-odd"><td>0x51</td>
<td>__u8[3]</td>
<td>s_padding2</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>0x54</td>
<td>__u32</td>
<td>s_padding[42]</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>0xFC</td>
<td>__be32</td>
<td>s_checksum</td>
<td>Checksum of the entire superblock, with this field set to zero.</td>
</tr>
<tr class="row-even"><td>0x100</td>
<td>__u8</td>
<td>s_users[16*48]</td>
<td>ids of all file systems sharing the log. e2fsprogs/Linux don’t allow
shared external journals, but I imagine Lustre (or ocfs2?), which use
the jbd2 code, might.</td>
</tr>
</tbody>
</table>
<p id="jbd2-compat">The journal compat features are any combination of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x1</td>
<td>Journal maintains checksums on the data blocks.
(JBD2_FEATURE_COMPAT_CHECKSUM)</td>
</tr>
</tbody>
</table>
<p id="jbd2-incompat">The journal incompat features are any combination of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x1</td>
<td>Journal has block revocation records. (JBD2_FEATURE_INCOMPAT_REVOKE)</td>
</tr>
<tr class="row-odd"><td>0x2</td>
<td>Journal can deal with 64-bit block numbers.
(JBD2_FEATURE_INCOMPAT_64BIT)</td>
</tr>
<tr class="row-even"><td>0x4</td>
<td>Journal commits asynchronously. (JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)</td>
</tr>
<tr class="row-odd"><td>0x8</td>
<td>This journal uses v2 of the checksum on-disk format. Each journal
metadata block gets its own checksum, and the block tags in the
descriptor table contain checksums for each of the data blocks in the
journal. (JBD2_FEATURE_INCOMPAT_CSUM_V2)</td>
</tr>
<tr class="row-even"><td>0x10</td>
<td>This journal uses v3 of the checksum on-disk format. This is the same as
v2, but the journal block tag size is fixed regardless of the size of
block numbers. (JBD2_FEATURE_INCOMPAT_CSUM_V3)</td>
</tr>
</tbody>
</table>
<p id="jbd2-checksum-type">Journal checksum type codes are one of the following.  crc32 or crc32c are the
most likely choices.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>CRC32</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>MD5</td>
</tr>
<tr class="row-even"><td>3</td>
<td>SHA1</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>CRC32C</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="descriptor-block">
<h3>Descriptor Block<a class="headerlink" href="#descriptor-block" title="Permalink to this headline">¶</a></h3>
<p>The descriptor block contains an array of journal block tags that
describe the final locations of the data blocks that follow in the
journal. Descriptor blocks are open-coded instead of being completely
described by a data structure, but here is the block structure anyway.
Descriptor blocks consume at least 36 bytes, but use a full block:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Descriptor</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>journal_header_t</td>
<td>(open coded)</td>
<td>Common block header.</td>
</tr>
<tr class="row-odd"><td>0xC</td>
<td>struct journal_block_tag_s</td>
<td>open coded array[]</td>
<td>Enough tags either to fill up the block or to describe all the data
blocks that follow this descriptor block.</td>
</tr>
</tbody>
</table>
<p>Journal block tags have any of the following formats, depending on which
journal feature and block tag flags are set.</p>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V3 is set, the journal block tag is
defined as <code class="docutils literal"><span class="pre">struct</span> <span class="pre">journal_block_tag3_s</span></code>, which looks like the
following. The size is 16 or 32 bytes.</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Descriptor</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>__be32</td>
<td>t_blocknr</td>
<td>Lower 32-bits of the location of where the corresponding data block
should end up on disk.</td>
</tr>
<tr class="row-odd"><td>0x4</td>
<td>__be32</td>
<td>t_flags</td>
<td>Flags that go with the descriptor. See the table <a class="reference internal" href="#jbd2-tag-flags">jbd2_tag_flags</a> for
more info.</td>
</tr>
<tr class="row-even"><td>0x8</td>
<td>__be32</td>
<td>t_blocknr_high</td>
<td>Upper 32-bits of the location of where the corresponding data block
should end up on disk. This is zero if JBD2_FEATURE_INCOMPAT_64BIT is
not enabled.</td>
</tr>
<tr class="row-odd"><td>0xC</td>
<td>__be32</td>
<td>t_checksum</td>
<td>Checksum of the journal UUID, the sequence number, and the data block.</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>This field appears to be open coded. It always comes at the end of the
tag, after t_checksum. This field is not present if the “same UUID” flag
is set.</td>
</tr>
<tr class="row-odd"><td>0x8 or 0xC</td>
<td>char</td>
<td>uuid[16]</td>
<td>A UUID to go with this tag. This field appears to be copied from the
<code class="docutils literal"><span class="pre">j_uuid</span></code> field in <code class="docutils literal"><span class="pre">struct</span> <span class="pre">journal_s</span></code>, but only tune2fs touches that
field.</td>
</tr>
</tbody>
</table>
<p id="jbd2-tag-flags">The journal tag flags are any combination of the following:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="99%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x1</td>
<td>On-disk block is escaped. The first four bytes of the data block just
happened to match the jbd2 magic number.</td>
</tr>
<tr class="row-odd"><td>0x2</td>
<td>This block has the same UUID as previous, therefore the UUID field is
omitted.</td>
</tr>
<tr class="row-even"><td>0x4</td>
<td>The data block was deleted by the transaction. (Not used?)</td>
</tr>
<tr class="row-odd"><td>0x8</td>
<td>This is the last tag in this descriptor block.</td>
</tr>
</tbody>
</table>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V3 is NOT set, the journal block tag
is defined as <code class="docutils literal"><span class="pre">struct</span> <span class="pre">journal_block_tag_s</span></code>, which looks like the
following. The size is 8, 12, 24, or 28 bytes:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Descriptor</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>__be32</td>
<td>t_blocknr</td>
<td>Lower 32-bits of the location of where the corresponding data block
should end up on disk.</td>
</tr>
<tr class="row-odd"><td>0x4</td>
<td>__be16</td>
<td>t_checksum</td>
<td>Checksum of the journal UUID, the sequence number, and the data block.
Note that only the lower 16 bits are stored.</td>
</tr>
<tr class="row-even"><td>0x6</td>
<td>__be16</td>
<td>t_flags</td>
<td>Flags that go with the descriptor. See the table <a class="reference internal" href="#jbd2-tag-flags">jbd2_tag_flags</a> for
more info.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>This next field is only present if the super block indicates support for
64-bit block numbers.</td>
</tr>
<tr class="row-even"><td>0x8</td>
<td>__be32</td>
<td>t_blocknr_high</td>
<td>Upper 32-bits of the location of where the corresponding data block
should end up on disk.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>This field appears to be open coded. It always comes at the end of the
tag, after t_flags or t_blocknr_high. This field is not present if the
“same UUID” flag is set.</td>
</tr>
<tr class="row-even"><td>0x8 or 0xC</td>
<td>char</td>
<td>uuid[16]</td>
<td>A UUID to go with this tag. This field appears to be copied from the
<code class="docutils literal"><span class="pre">j_uuid</span></code> field in <code class="docutils literal"><span class="pre">struct</span> <span class="pre">journal_s</span></code>, but only tune2fs touches that
field.</td>
</tr>
</tbody>
</table>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V2 or
JBD2_FEATURE_INCOMPAT_CSUM_V3 are set, the end of the block is a
<code class="docutils literal"><span class="pre">struct</span> <span class="pre">jbd2_journal_block_tail</span></code>, which looks like this:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Descriptor</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>__be32</td>
<td>t_checksum</td>
<td>Checksum of the journal UUID + the descriptor block, with this field set
to zero.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="data-block">
<h3>Data Block<a class="headerlink" href="#data-block" title="Permalink to this headline">¶</a></h3>
<p>In general, the data blocks being written to disk through the journal
are written verbatim into the journal file after the descriptor block.
However, if the first four bytes of the block match the jbd2 magic
number then those four bytes are replaced with zeroes and the “escaped”
flag is set in the descriptor block tag.</p>
</div>
<div class="section" id="revocation-block">
<h3>Revocation Block<a class="headerlink" href="#revocation-block" title="Permalink to this headline">¶</a></h3>
<p>A revocation block is used to prevent replay of a block in an earlier
transaction. This is used to mark blocks that were journalled at one
time but are no longer journalled. Typically this happens if a metadata
block is freed and re-allocated as a file data block; in this case, a
journal replay after the file block was written to disk will cause
corruption.</p>
<p><strong>NOTE</strong>: This mechanism is NOT used to express “this journal block is
superseded by this other journal block”, as the author (djwong)
mistakenly thought. Any block being added to a transaction will cause
the removal of all existing revocation records for that block.</p>
<p>Revocation blocks are described in
<code class="docutils literal"><span class="pre">struct</span> <span class="pre">jbd2_journal_revoke_header_s</span></code>, are at least 16 bytes in
length, but use a full block:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>journal_header_t</td>
<td>r_header</td>
<td>Common block header.</td>
</tr>
<tr class="row-odd"><td>0xC</td>
<td>__be32</td>
<td>r_count</td>
<td>Number of bytes used in this block.</td>
</tr>
<tr class="row-even"><td>0x10</td>
<td>__be32 or __be64</td>
<td>blocks[0]</td>
<td>Blocks to revoke.</td>
</tr>
</tbody>
</table>
<p>After r_count is a linear array of block numbers that are effectively
revoked by this transaction. The size of each block number is 8 bytes if
the superblock advertises 64-bit block number support, or 4 bytes
otherwise.</p>
<p>If JBD2_FEATURE_INCOMPAT_CSUM_V2 or
JBD2_FEATURE_INCOMPAT_CSUM_V3 are set, the end of the revocation
block is a <code class="docutils literal"><span class="pre">struct</span> <span class="pre">jbd2_journal_revoke_tail</span></code>, which has this format:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>__be32</td>
<td>r_checksum</td>
<td>Checksum of the journal UUID + revocation block</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="commit-block">
<h3>Commit Block<a class="headerlink" href="#commit-block" title="Permalink to this headline">¶</a></h3>
<p>The commit block is a sentry that indicates that a transaction has been
completely written to the journal. Once this commit block reaches the
journal, the data stored with this transaction can be written to their
final locations on disk.</p>
<p>The commit block is described by <code class="docutils literal"><span class="pre">struct</span> <span class="pre">commit_header</span></code>, which is 32
bytes long (but uses a full block):</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="1%" />
<col width="1%" />
<col width="1%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Type</th>
<th class="head">Name</th>
<th class="head">Descriptor</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x0</td>
<td>journal_header_s</td>
<td>(open coded)</td>
<td>Common block header.</td>
</tr>
<tr class="row-odd"><td>0xC</td>
<td>unsigned char</td>
<td>h_chksum_type</td>
<td>The type of checksum to use to verify the integrity of the data blocks
in the transaction. See <a class="reference internal" href="#jbd2-checksum-type">jbd2_checksum_type</a> for more info.</td>
</tr>
<tr class="row-even"><td>0xD</td>
<td>unsigned char</td>
<td>h_chksum_size</td>
<td>The number of bytes used by the checksum. Most likely 4.</td>
</tr>
<tr class="row-odd"><td>0xE</td>
<td>unsigned char</td>
<td>h_padding[2]</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>0x10</td>
<td>__be32</td>
<td>h_chksum[JBD2_CHECKSUM_BYTES]</td>
<td>32 bytes of space to store checksums. If
JBD2_FEATURE_INCOMPAT_CSUM_V2 or JBD2_FEATURE_INCOMPAT_CSUM_V3
are set, the first <code class="docutils literal"><span class="pre">__be32</span></code> is the checksum of the journal UUID and
the entire commit block, with this field zeroed. If
JBD2_FEATURE_COMPAT_CHECKSUM is set, the first <code class="docutils literal"><span class="pre">__be32</span></code> is the
crc32 of all the blocks already written to the transaction.</td>
</tr>
<tr class="row-odd"><td>0x30</td>
<td>__be64</td>
<td>h_commit_sec</td>
<td>The time that the transaction was committed, in seconds since the epoch.</td>
</tr>
<tr class="row-even"><td>0x38</td>
<td>__be32</td>
<td>h_commit_nsec</td>
<td>Nanoseconds component of the above timestamp.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>