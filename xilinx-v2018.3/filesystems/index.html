

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux Filesystems API &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SuperH Interfaces Guide" href="../sh/index.html" />
    <link rel="prev" title="Code Examples" href="../crypto/api-samples.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linux Filesystems API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-linux-vfs">The Linux VFS</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-filesystem-types">The Filesystem types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-directory-cache">The Directory Cache</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inode-handling">Inode Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#registration-and-superblocks">Registration and Superblocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-locks">File Locks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-functions">Other Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-proc-filesystem">The proc filesystem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sysctl-interface">sysctl interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#proc-filesystem-interface">proc filesystem interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#events-based-on-file-descriptors">Events based on file descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-filesystem-for-exporting-kernel-objects">The Filesystem for Exporting Kernel Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-debugfs-filesystem">The debugfs filesystem</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#debugfs-interface">debugfs interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-linux-journalling-api">The Linux Journalling API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#details">Details</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-types">Data Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#structures">Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#journal-level">Journal Level</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transasction-level">Transasction Level</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#see-also">See also</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#splice-api">splice API</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pipes-api">pipes API</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Linux Filesystems API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/filesystems/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-filesystems-api">
<h1>Linux Filesystems API<a class="headerlink" href="#linux-filesystems-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-linux-vfs">
<h2>The Linux VFS<a class="headerlink" href="#the-linux-vfs" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-filesystem-types">
<h3>The Filesystem types<a class="headerlink" href="#the-filesystem-types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.positive_aop_returns">
enum <code class="descname">positive_aop_returns</code><a class="headerlink" href="#c.positive_aop_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>aop return codes with specific semantics</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">AOP_WRITEPAGE_ACTIVATE</span></code></dt>
<dd>Informs the caller that page writeback has
completed, that the page is still locked, and
should be considered active.  The VM uses this hint
to return the page to the active list – it won’t
be a candidate for writeback again in the near
future.  Other callers must be careful to unlock
the page if they get this return.  Returned by
<code class="xref c c-func docutils literal"><span class="pre">writepage()</span></code>;</dd>
<dt><code class="docutils literal"><span class="pre">AOP_TRUNCATED_PAGE</span></code></dt>
<dd>The AOP method that was handed a locked page has
unlocked it and the page might have been truncated.
The caller should back up to acquiring a new page and
trying again.  The aop will be taking reasonable
precautions not to livelock.  If the caller held a page
reference, it should drop it before retrying.  Returned
by <code class="xref c c-func docutils literal"><span class="pre">readpage()</span></code>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>address_space_operation functions return these large constants to indicate
special semantics to the caller.  These are much larger than the bytes in a
page to allow for functions that return the number of bytes operated on in a
given page.</p>
<dl class="function">
<dt id="c.sb_end_write">
void <code class="descname">sb_end_write</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_write" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we wrote to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement number of writers to the filesystem. Wake up possible waiters
wanting to freeze the filesystem.</p>
<dl class="function">
<dt id="c.sb_end_pagefault">
void <code class="descname">sb_end_pagefault</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_pagefault" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock from a page fault</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we wrote to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement number of processes handling write page fault to the filesystem.
Wake up possible waiters wanting to freeze the filesystem.</p>
<dl class="function">
<dt id="c.sb_end_intwrite">
void <code class="descname">sb_end_intwrite</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_end_intwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>drop write access to a superblock for internal fs purposes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we wrote to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement fs-internal number of writers to the filesystem.  Wake up possible
waiters wanting to freeze the filesystem.</p>
<dl class="function">
<dt id="c.sb_start_write">
void <code class="descname">sb_start_write</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_start_write" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we write to</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a process wants to write data or metadata to a file system (i.e. dirty
a page or an inode), it should embed the operation in a <a class="reference internal" href="#c.sb_start_write" title="sb_start_write"><code class="xref c c-func docutils literal"><span class="pre">sb_start_write()</span></code></a> -
<a class="reference internal" href="#c.sb_end_write" title="sb_end_write"><code class="xref c c-func docutils literal"><span class="pre">sb_end_write()</span></code></a> pair to get exclusion against file system freezing. This
function increments number of writers preventing freezing. If the file
system is already frozen, the function waits until the file system is
thawed.</p>
<p>Since freeze protection behaves as a lock, users have to preserve
ordering of freeze protection and other filesystem locks. Generally,
freeze protection should be the outermost lock. In particular, we have:</p>
<dl class="docutils">
<dt>sb_start_write</dt>
<dd>-&gt; i_mutex                    (write path, truncate, directory ops, …)
-&gt; s_umount           (freeze_super, thaw_super)</dd>
</dl>
<dl class="function">
<dt id="c.sb_start_pagefault">
void <code class="descname">sb_start_pagefault</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sb_start_pagefault" title="Permalink to this definition">¶</a></dt>
<dd><p>get write access to a superblock from a page fault</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super we write to</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a process starts handling write page fault, it should embed the
operation into <a class="reference internal" href="#c.sb_start_pagefault" title="sb_start_pagefault"><code class="xref c c-func docutils literal"><span class="pre">sb_start_pagefault()</span></code></a> - <a class="reference internal" href="#c.sb_end_pagefault" title="sb_end_pagefault"><code class="xref c c-func docutils literal"><span class="pre">sb_end_pagefault()</span></code></a> pair to get
exclusion against file system freezing. This is needed since the page fault
is going to dirty a page. This function increments number of running page
faults preventing freezing. If the file system is already frozen, the
function waits until the file system is thawed.</p>
<p>Since page fault freeze protection behaves as a lock, users have to preserve
ordering of freeze protection and other filesystem locks. It is advised to
put <a class="reference internal" href="#c.sb_start_pagefault" title="sb_start_pagefault"><code class="xref c c-func docutils literal"><span class="pre">sb_start_pagefault()</span></code></a> close to mmap_sem in lock ordering. Page fault
handling code implies lock dependency:</p>
<dl class="docutils">
<dt>mmap_sem</dt>
<dd>-&gt; sb_start_pagefault</dd>
</dl>
<dl class="function">
<dt id="c.inode_inc_iversion">
void <code class="descname">inode_inc_iversion</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_inc_iversion" title="Permalink to this definition">¶</a></dt>
<dd><p>increments i_version</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode that need to be updated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Every time the inode is modified, the i_version field will be incremented.
The filesystem has to be mounted with i_version flag</p>
<dl class="function">
<dt id="c.filemap_set_wb_err">
void <code class="descname">filemap_set_wb_err</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_set_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>set a writeback error on an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping in which to set writeback error</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>error to be set in mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>When writeback fails in some way, we must record that error so that
userspace can be informed when fsync and the like are called.  We endeavor
to report errors on any file that was open at the time of the error.  Some
internal callers also need to know when writeback errors have occurred.</p>
<p>When a writeback error occurs, most filesystems will want to call
filemap_set_wb_err to record the error in the mapping so that it will be
automatically reported whenever fsync is called on the file.</p>
<dl class="function">
<dt id="c.filemap_check_wb_err">
int <code class="descname">filemap_check_wb_err</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, errseq_t<em>&nbsp;since</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_check_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>has an error occurred since the mark was sampled?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to check for writeback errors</dd>
<dt><code class="docutils literal"><span class="pre">errseq_t</span> <span class="pre">since</span></code></dt>
<dd>previously-sampled errseq_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grab the errseq_t value from the mapping, and see if it has changed “since”
the given value was sampled.</p>
<p>If it has then report the latest error set, otherwise return 0.</p>
<dl class="function">
<dt id="c.filemap_sample_wb_err">
errseq_t <code class="descname">filemap_sample_wb_err</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_sample_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>sample the current errseq_t to test for later errors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to be sampled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writeback errors are always reported relative to a particular sample point
in the past. This function provides those sample points.</p>
</div>
<div class="section" id="the-directory-cache">
<h3>The Directory Cache<a class="headerlink" href="#the-directory-cache" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__d_drop">
void <code class="descname">__d_drop</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__d_drop" title="Permalink to this definition">¶</a></dt>
<dd><p>drop a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry to drop</dd>
</dl>
<p><strong>Description</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">d_drop()</span></code> unhashes the entry from the parent dentry hashes, so that it won’t
be found through a VFS lookup any more. Note that this is different from
deleting the dentry - d_delete will try to mark the dentry negative if
possible, giving a successful _negative_ lookup, while d_drop will
just make the cache lookup fail.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">d_drop()</span></code> is used mainly for stuff that wants to invalidate a dentry for some
reason (NFS timeouts or autofs deletes).</p>
<p>__d_drop requires dentry-&gt;d_lock.</p>
<dl class="function">
<dt id="c.shrink_dcache_sb">
void <code class="descname">shrink_dcache_sb</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.shrink_dcache_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>shrink dcache for a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shrink the dcache for the specified super block. This is used to free
the dcache before unmounting a file system.</p>
<dl class="function">
<dt id="c.path_has_submounts">
int <code class="descname">path_has_submounts</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_has_submounts" title="Permalink to this definition">¶</a></dt>
<dd><p>check for mounts over a dentry in the current namespace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>path to check.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the parent or its subdirectories contain
a mount point in the current namespace.</p>
<dl class="function">
<dt id="c.shrink_dcache_parent">
void <code class="descname">shrink_dcache_parent</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.shrink_dcache_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>prune dcache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of entries to prune</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prune the dcache to remove unused children of the parent dentry.</p>
<dl class="function">
<dt id="c.d_invalidate">
void <code class="descname">d_invalidate</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>detach submounts, prune dcache, and drop</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry to invalidate (aka detach, prune and drop)</dd>
</dl>
<p><strong>Description</strong></p>
<p>no dcache lock.</p>
<p>The final d_drop is done as an atomic operation relative to
rename_lock ensuring there are no races with d_set_mounted.  This
ensures there are no unhashed dentries on the path to a mountpoint.</p>
<dl class="function">
<dt id="c.d_alloc">
struct dentry * <code class="descname">d_alloc</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;parent</em>, const struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a dcache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of entry to allocate</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>qstr of the name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a dentry. It returns <code class="docutils literal"><span class="pre">NULL</span></code> if there is insufficient memory
available. On a success the dentry is returned. The name passed in is
copied and the copy passed in may be reused after this call.</p>
<dl class="function">
<dt id="c.d_alloc_pseudo">
struct dentry * <code class="descname">d_alloc_pseudo</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, const struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_alloc_pseudo" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a dentry (for lookup-less filesystems)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>qstr of the name</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a filesystem that just pins its dentries in memory and never
performs lookups at all, return an unhashed IS_ROOT dentry.</p>
<dl class="function">
<dt id="c.d_instantiate">
void <code class="descname">d_instantiate</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_instantiate" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in inode information for a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to complete</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to attach to this dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in inode information in the entry.</p>
<p>This turns negative dentries into productive full members
of society.</p>
<p>NOTE! This assumes that the inode count has been incremented
(or otherwise set) by the caller to indicate that it is now
in use by the dcache.</p>
<dl class="function">
<dt id="c.d_instantiate_no_diralias">
int <code class="descname">d_instantiate_no_diralias</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_instantiate_no_diralias" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate a non-aliased dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to complete</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to attach to this dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in inode information in the entry.  If a directory alias is found, then
return an error (and drop inode).  Together with <code class="xref c c-func docutils literal"><span class="pre">d_materialise_unique()</span></code> this
guarantees that a directory inode may never have more than one alias.</p>
<dl class="function">
<dt id="c.d_find_any_alias">
struct dentry * <code class="descname">d_find_any_alias</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_find_any_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find any alias for a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to find an alias for</dd>
</dl>
<p><strong>Description</strong></p>
<p>If any aliases exist for the given inode, take and return a
reference for one of them.  If no aliases exist, return <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<dl class="function">
<dt id="c.d_obtain_alias">
struct dentry * <code class="descname">d_obtain_alias</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_obtain_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find or allocate a DISCONNECTED dentry for a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to allocate the dentry for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain a dentry for an inode resulting from NFS filehandle conversion or
similar open by handle operations.  The returned dentry may be anonymous,
or may have a full name (if the inode was already in the cache).</p>
<p>When called on a directory inode, we must ensure that the inode only ever
has one dentry.  If a dentry is found, that is returned instead of
allocating a new one.</p>
<p>On successful return, the reference to the inode has been transferred
to the dentry.  In case of an error the reference on the inode is released.
To make it easier to use in export operations a <code class="docutils literal"><span class="pre">NULL</span></code> or IS_ERR inode may
be passed in and the error will be propagated to the return value,
with a <code class="docutils literal"><span class="pre">NULL</span></code> <strong>inode</strong> replaced by ERR_PTR(-ESTALE).</p>
<dl class="function">
<dt id="c.d_obtain_root">
struct dentry * <code class="descname">d_obtain_root</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_obtain_root" title="Permalink to this definition">¶</a></dt>
<dd><p>find or allocate a dentry for a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to allocate the dentry for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain an IS_ROOT dentry for the root of a filesystem.</p>
<p>We must ensure that directory inodes only ever have one dentry.  If a
dentry is found, that is returned instead of allocating a new one.</p>
<p>On successful return, the reference to the inode has been transferred
to the dentry.  In case of an error the reference on the inode is
released.  A <code class="docutils literal"><span class="pre">NULL</span></code> or IS_ERR inode may be passed in and will be the
error will be propagate to the return value, with a <code class="docutils literal"><span class="pre">NULL</span></code> <strong>inode</strong>
replaced by ERR_PTR(-ESTALE).</p>
<dl class="function">
<dt id="c.d_add_ci">
struct dentry * <code class="descname">d_add_ci</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct inode *<em>&nbsp;inode</em>, struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_add_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup or allocate new dentry with case-exact name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>the negative dentry that was passed to the parent’s lookup func</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode case-insensitive lookup has found</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the case-exact name to be associated with the returned dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is to avoid filling the dcache with case-insensitive names to the
same inode, only the actual correct case is stored in the dcache for
case-insensitive filesystems.</p>
<p>For a case-insensitive lookup match and if the the case-exact dentry
already exists in in the dcache, use it and return it.</p>
<p>If no entry exists with the exact case name, allocate new dentry with
the exact case, and return the spliced entry.</p>
<dl class="function">
<dt id="c.d_lookup">
struct dentry * <code class="descname">d_lookup</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;parent</em>, const struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>search for a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent dentry</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>qstr of name we wish to find</dd>
</dl>
<p><strong>Return</strong></p>
<p>dentry, or NULL</p>
<p>d_lookup searches the children of the parent dentry for the name in
question. If the dentry is found its reference count is incremented and the
dentry is returned. The caller must use dput to free the entry when it has
finished using it. <code class="docutils literal"><span class="pre">NULL</span></code> is returned if the dentry does not exist.</p>
<dl class="function">
<dt id="c.d_hash_and_lookup">
struct dentry * <code class="descname">d_hash_and_lookup</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dir</em>, struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_hash_and_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>hash the qstr then search for a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>Directory to search in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>qstr of name we wish to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>On lookup failure NULL is returned; on bad name - ERR_PTR(-error)</p>
<dl class="function">
<dt id="c.d_delete">
void <code class="descname">d_delete</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry to delete</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the dentry into a negative dentry if possible, otherwise
remove it from the hash queues so it can be deleted later</p>
<dl class="function">
<dt id="c.d_rehash">
void <code class="descname">d_rehash</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_rehash" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry back to the hash</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to add to the hash</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a dentry to the hash according to its name.</p>
<dl class="function">
<dt id="c.d_add">
void <code class="descname">d_add</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add dentry to hash queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>The inode to attach to this dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds the entry to the hash queues and initializes <strong>inode</strong>.
The entry was actually filled in earlier during <a class="reference internal" href="#c.d_alloc" title="d_alloc"><code class="xref c c-func docutils literal"><span class="pre">d_alloc()</span></code></a>.</p>
<dl class="function">
<dt id="c.d_exact_alias">
struct dentry * <code class="descname">d_exact_alias</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;entry</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_exact_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>find and hash an exact unhashed alias</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>dentry to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>The inode to go with this dentry</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an unhashed dentry with the same name/parent and desired
inode already exists, hash and return it.  Otherwise, return
NULL.</p>
<p>Parent directory should be locked.</p>
<dl class="function">
<dt id="c.dentry_update_name_case">
void <code class="descname">dentry_update_name_case</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, const struct qstr *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dentry_update_name_case" title="Permalink to this definition">¶</a></dt>
<dd><p>update case insensitive dentry with a new name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry to be updated</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">qstr</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>new name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update a case insensitive dentry with new case of name.</p>
<p>dentry must have been returned by d_lookup with name <strong>name</strong>. Old and new
name lengths must match (ie. no d_compare which allows mismatched name
lengths).</p>
<p>Parent inode i_mutex must be held over d_lookup and into this call (to
keep renames and concurrent inserts, and readdir(2) away).</p>
<dl class="function">
<dt id="c.d_splice_alias">
struct dentry * <code class="descname">d_splice_alias</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_splice_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>splice a disconnected dentry into the tree if one exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode which may have a disconnected dentry</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>a negative dentry which we want to point to the inode.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If inode is a directory and has an IS_ROOT alias, then d_move that in
place of the given dentry and return it, else simply d_add the inode
to the dentry and return NULL.</p>
<p>If a non-IS_ROOT directory is found, the filesystem is corrupt, and
we should error out: directories can’t have multiple aliases.</p>
<p>This is needed in the lookup routine of any filesystem that is exportable
(via knfsd) so that we can build dcache paths to directories effectively.</p>
<p>If a dentry was found and moved, then it is returned.  Otherwise NULL
is returned.  This matches the expected return value of -&gt;lookup.</p>
<p>Cluster filesystems may call this function with a negative, hashed dentry.
In that case, we know that the inode will be a regular file, and also this
will only occur during atomic_open. So we need to check for the dentry
being already hashed only in the final case.</p>
<dl class="function">
<dt id="c.d_path">
char * <code class="descname">d_path</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;path</em>, char *<em>&nbsp;buf</em>, int<em>&nbsp;buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_path" title="Permalink to this definition">¶</a></dt>
<dd><p>return the path of a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to report</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to return value in</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>buffer length</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convert a dentry into an ASCII path name. If the entry has been deleted
the string ” (deleted)” is appended. Note that this is ambiguous.</p>
<p>Returns a pointer into the buffer or an error code if the path was
too long. Note: Callers should use the returned pointer, not the passed
in buffer, to use the name! The implementation often starts at an offset
into the buffer, and may leave 0 bytes at the start.</p>
<p>“buflen” should be positive.</p>
<dl class="function">
<dt id="c.dget_dlock">
struct dentry * <code class="descname">dget_dlock</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dget_dlock" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry to get a reference to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Given a dentry or <code class="docutils literal"><span class="pre">NULL</span></code> pointer increment the reference count
if appropriate and return the dentry. A dentry will not be
destroyed when it has references.</div></blockquote>
<dl class="function">
<dt id="c.d_unhashed">
int <code class="descname">d_unhashed</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_unhashed" title="Permalink to this definition">¶</a></dt>
<dd><p>is dentry hashed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>entry to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if the dentry passed is not currently hashed.</div></blockquote>
<dl class="function">
<dt id="c.d_really_is_negative">
bool <code class="descname">d_really_is_negative</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_really_is_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a dentry is really negative (ignoring fallthroughs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the dentry represents either an absent name or a name that
doesn’t map to an inode (ie. -&gt;d_inode is NULL).  The dentry could represent
a true miss, a whiteout that isn’t represented by a 0,0 chardev or a
fallthrough marker in an opaque directory.</p>
<p>Note!  (1) This should be used <em>only</em> by a filesystem to examine its own
dentries.  It should not be used to look at some other filesystem’s
dentries.  (2) It should also be used in combination with <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal"><span class="pre">d_inode()</span></code></a> to get
the inode.  (3) The dentry may have something attached to -&gt;d_lower and the
type field of the flags may be set to something other than miss or whiteout.</p>
<dl class="function">
<dt id="c.d_really_is_positive">
bool <code class="descname">d_really_is_positive</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_really_is_positive" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a dentry is really positive (ignoring fallthroughs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the dentry represents a name that maps to an inode
(ie. -&gt;d_inode is not NULL).  The dentry might still represent a whiteout if
that is represented on medium as a 0,0 chardev.</p>
<p>Note!  (1) This should be used <em>only</em> by a filesystem to examine its own
dentries.  It should not be used to look at some other filesystem’s
dentries.  (2) It should also be used in combination with <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal"><span class="pre">d_inode()</span></code></a> to get
the inode.</p>
<dl class="function">
<dt id="c.d_inode">
struct inode * <code class="descname">d_inode</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the actual inode of this dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper normal filesystems should use to get at their own inodes
in their own dentries and ignore the layering superimposed upon them.</p>
<dl class="function">
<dt id="c.d_inode_rcu">
struct inode * <code class="descname">d_inode_rcu</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_inode_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the actual inode of this dentry with <code class="xref c c-func docutils literal"><span class="pre">ACCESS_ONCE()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper normal filesystems should use to get at their own inodes
in their own dentries and ignore the layering superimposed upon them.</p>
<dl class="function">
<dt id="c.d_backing_inode">
struct inode * <code class="descname">d_backing_inode</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;upper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_backing_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get upper or lower inode we should be using</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">upper</span></code></dt>
<dd>The upper layer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper that should be used to get at the inode that will be used
if this dentry were to be opened as a file.  The inode may be on the upper
dentry or it may be on a lower dentry pinned by the upper.</p>
<p>Normal filesystems should not use this to access their own inodes.</p>
<dl class="function">
<dt id="c.d_backing_dentry">
struct dentry * <code class="descname">d_backing_dentry</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;upper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_backing_dentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Get upper or lower dentry we should be using</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">upper</span></code></dt>
<dd>The upper layer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the helper that should be used to get the dentry of the inode that
will be used if this dentry were opened as a file.  It may be the upper
dentry or it may be a lower dentry pinned by the upper.</p>
<p>Normal filesystems should not use this to access their own dentries.</p>
<dl class="function">
<dt id="c.d_real">
struct dentry * <code class="descname">d_real</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, const struct inode *<em>&nbsp;inode</em>, unsigned int<em>&nbsp;open_flags</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real dentry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>the dentry to query</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to select the dentry from multiple layers (can be NULL)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">open_flags</span></code></dt>
<dd>open flags to control copy-up behavior</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags to control what is returned by this function</dd>
</dl>
<p><strong>Description</strong></p>
<p>If dentry is on a union/overlay, then return the underlying, real dentry.
Otherwise return the dentry itself.</p>
<p>See also: Documentation/filesystems/vfs.txt</p>
<dl class="function">
<dt id="c.d_real_inode">
struct inode * <code class="descname">d_real_inode</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.d_real_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>The dentry to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>If dentry is on a union/overlay, then return the underlying, real inode.
Otherwise return <a class="reference internal" href="#c.d_inode" title="d_inode"><code class="xref c c-func docutils literal"><span class="pre">d_inode()</span></code></a>.</p>
</div>
<div class="section" id="inode-handling">
<h3>Inode Handling<a class="headerlink" href="#inode-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.inode_init_always">
int <code class="descname">inode_init_always</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_init_always" title="Permalink to this definition">¶</a></dt>
<dd><p>perform inode structure initialisation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock inode belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to initialise</dd>
</dl>
<p><strong>Description</strong></p>
<p>These are initializations that need to be done on every inode
allocation as the fields are not initialised by slab allocation.</p>
<dl class="function">
<dt id="c.drop_nlink">
void <code class="descname">drop_nlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drop_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly drop an inode’s link count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  In cases
where we are attempting to track writes to the
filesystem, a decrement to zero means an imminent
write when the file is truncated and actually unlinked
on the filesystem.</p>
<dl class="function">
<dt id="c.clear_nlink">
void <code class="descname">clear_nlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly zero an inode’s link count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  See
<a class="reference internal" href="#c.drop_nlink" title="drop_nlink"><code class="xref c c-func docutils literal"><span class="pre">drop_nlink()</span></code></a> for why we care about i_nlink hitting zero.</p>
<dl class="function">
<dt id="c.set_nlink">
void <code class="descname">set_nlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, unsigned int<em>&nbsp;nlink</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly set an inode’s link count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nlink</span></code></dt>
<dd>new nlink (should be non-zero)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.</p>
<dl class="function">
<dt id="c.inc_nlink">
void <code class="descname">inc_nlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inc_nlink" title="Permalink to this definition">¶</a></dt>
<dd><p>directly increment an inode’s link count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a low-level filesystem helper to replace any
direct filesystem manipulation of i_nlink.  Currently,
it is only here for parity with <code class="xref c c-func docutils literal"><span class="pre">dec_nlink()</span></code>.</p>
<dl class="function">
<dt id="c.inode_sb_list_add">
void <code class="descname">inode_sb_list_add</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_sb_list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add inode to the superblock list of inodes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to add</dd>
</dl>
<dl class="function">
<dt id="c.__insert_inode_hash">
void <code class="descname">__insert_inode_hash</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, unsigned long<em>&nbsp;hashval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__insert_inode_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>hash an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>unhashed inode</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>unsigned long value used to locate this object in the
inode_hashtable.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Add an inode to the inode hash for this superblock.</div></blockquote>
<dl class="function">
<dt id="c.__remove_inode_hash">
void <code class="descname">__remove_inode_hash</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__remove_inode_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an inode from the hash</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to unhash</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove an inode from the superblock.</div></blockquote>
<dl class="function">
<dt id="c.evict_inodes">
void <code class="descname">evict_inodes</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.evict_inodes" title="Permalink to this definition">¶</a></dt>
<dd><p>evict all evictable inodes for a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure that no inodes with zero refcount are retained.  This is
called by superblock shutdown after having MS_ACTIVE flag removed,
so any inode reaching zero refcount during or after that call will
be immediately evicted.</p>
<dl class="function">
<dt id="c.new_inode">
struct inode * <code class="descname">new_inode</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.new_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Allocates a new inode for given superblock. The default gfp_mask
for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE.
If HIGHMEM pages are unsuitable or it is known that pages allocated
for the page cache are not reclaimable or migratable,
<code class="xref c c-func docutils literal"><span class="pre">mapping_set_gfp_mask()</span></code> must be called with suitable flags on the
newly created inode’s mapping</div></blockquote>
<dl class="function">
<dt id="c.unlock_new_inode">
void <code class="descname">unlock_new_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_new_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>clear the I_NEW state and wake up any waiters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>new inode to unlock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when the inode is fully initialised to clear the new state of the
inode and wake up anyone waiting for the inode to finish initialisation.</p>
<dl class="function">
<dt id="c.lock_two_nondirectories">
void <code class="descname">lock_two_nondirectories</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode1</em>, struct inode *<em>&nbsp;inode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_two_nondirectories" title="Permalink to this definition">¶</a></dt>
<dd><p>take two i_mutexes on non-directory objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode1</span></code></dt>
<dd>first inode to lock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode2</span></code></dt>
<dd>second inode to lock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock any non-NULL argument that is not a directory.
Zero, one or two objects may be locked by this function.</p>
<dl class="function">
<dt id="c.unlock_two_nondirectories">
void <code class="descname">unlock_two_nondirectories</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode1</em>, struct inode *<em>&nbsp;inode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_two_nondirectories" title="Permalink to this definition">¶</a></dt>
<dd><p>release locks from <a class="reference internal" href="#c.lock_two_nondirectories" title="lock_two_nondirectories"><code class="xref c c-func docutils literal"><span class="pre">lock_two_nondirectories()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode1</span></code></dt>
<dd>first inode to unlock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode2</span></code></dt>
<dd>second inode to unlock</dd>
</dl>
<dl class="function">
<dt id="c.iget5_locked">
struct inode * <code class="descname">iget5_locked</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (*test) (struct inode<em>&nbsp;*</em>, void<em>&nbsp;*</em>, int (*set) (struct inode<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget5_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode from a mounted file system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to get</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">set</span></code></dt>
<dd>callback used to initialize a new struct inode</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>test</strong> and <strong>set</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
and if present it is return it with an increased reference count. This is
a generalized version of <a class="reference internal" href="#c.iget_locked" title="iget_locked"><code class="xref c c-func docutils literal"><span class="pre">iget_locked()</span></code></a> for file systems where the inode
number is not sufficient for unique identification of an inode.</p>
<p>If the inode is not in cache, allocate a new inode and return it locked,
hashed, and with the I_NEW flag set. The file system gets to fill it in
before unlocking it via <a class="reference internal" href="#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal"><span class="pre">unlock_new_inode()</span></code></a>.</p>
<p>Note both <strong>test</strong> and <strong>set</strong> are called with the inode_hash_lock held, so can’t
sleep.</p>
<dl class="function">
<dt id="c.iget_locked">
struct inode * <code class="descname">iget_locked</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;ino</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an inode from a mounted file system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ino</span></code></dt>
<dd>inode number to get</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>ino</strong> in the inode cache and if present
return it with an increased reference count. This is for file systems
where the inode number is sufficient for unique identification of an inode.</p>
<p>If the inode is not in cache, allocate a new inode and return it locked,
hashed, and with the I_NEW flag set.  The file system gets to fill it in
before unlocking it via <a class="reference internal" href="#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal"><span class="pre">unlock_new_inode()</span></code></a>.</p>
<dl class="function">
<dt id="c.iunique">
ino_t <code class="descname">iunique</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, ino_t<em>&nbsp;max_reserved</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iunique" title="Permalink to this definition">¶</a></dt>
<dd><p>get a unique inode number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock</dd>
<dt><code class="docutils literal"><span class="pre">ino_t</span> <span class="pre">max_reserved</span></code></dt>
<dd>highest reserved inode number</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Obtain an inode number that is unique on the system for a given
superblock. This is used by file systems that have no natural
permanent inode numbering system. An inode number is returned that
is higher than the reserved limit but unique.</p>
<p>BUGS:
With a large number of inodes live on the file system this function
currently becomes quite slow.</p>
</div></blockquote>
<dl class="function">
<dt id="c.ilookup5_nowait">
struct inode * <code class="descname">ilookup5_nowait</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (*test) (struct inode<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup5_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system to search</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to search for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>test</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache.
If the inode is in the cache, the inode is returned with an incremented
reference count.</p>
<p><strong>Note</strong></p>
<p>I_NEW is not waited upon so you have to be very careful what you do
with the returned inode.  You probably should be using <a class="reference internal" href="#c.ilookup5" title="ilookup5"><code class="xref c c-func docutils literal"><span class="pre">ilookup5()</span></code></a> instead.</p>
<p>Note2: <strong>test</strong> is called with the inode_hash_lock held, so can’t sleep.</p>
<dl class="function">
<dt id="c.ilookup5">
struct inode * <code class="descname">ilookup5</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (*test) (struct inode<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup5" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system to search</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to search for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>test</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode cache,
and if the inode is in the cache, return the inode with an incremented
reference count.  Waits on I_NEW before returning the inode.
returned with an incremented reference count.</p>
<p>This is a generalized version of <a class="reference internal" href="#c.ilookup" title="ilookup"><code class="xref c c-func docutils literal"><span class="pre">ilookup()</span></code></a> for file systems where the
inode number is not sufficient for unique identification of an inode.</p>
<p><strong>Note</strong></p>
<p><strong>test</strong> is called with the inode_hash_lock held, so can’t sleep.</p>
<dl class="function">
<dt id="c.ilookup">
struct inode * <code class="descname">ilookup</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;ino</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilookup" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system to search</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ino</span></code></dt>
<dd>inode number to search for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode <strong>ino</strong> in the inode cache, and if the inode is in the
cache, the inode is returned with an incremented reference count.</p>
<dl class="function">
<dt id="c.find_inode_nowait">
struct inode * <code class="descname">find_inode_nowait</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;hashval</em>, int (*match) (struct inode<em>&nbsp;*</em>, unsigned<em>&nbsp;long</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_inode_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>find an inode in the inode cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>super block of file system to search</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">hashval</span></code></dt>
<dd>hash value (usually inode number) to search for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">inode</span> <span class="pre">*,</span> <span class="pre">unsigned</span> <span class="pre">long,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">match</span></code></dt>
<dd>callback used for comparisons between inodes</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque data pointer to pass to <strong>match</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for the inode specified by <strong>hashval</strong> and <strong>data</strong> in the inode
cache, where the helper function <strong>match</strong> will return 0 if the inode
does not match, 1 if the inode does match, and -1 if the search
should be stopped.  The <strong>match</strong> function must be responsible for
taking the i_lock spin_lock and checking i_state for an inode being
freed or being initialized, and incrementing the reference count
before returning 1.  It also must not sleep, since it is called with
the inode_hash_lock spinlock held.</p>
<p>This is a even more generalized version of <a class="reference internal" href="#c.ilookup5" title="ilookup5"><code class="xref c c-func docutils literal"><span class="pre">ilookup5()</span></code></a> when the
function must never block — <code class="xref c c-func docutils literal"><span class="pre">find_inode()</span></code> can block in
<code class="xref c c-func docutils literal"><span class="pre">__wait_on_freeing_inode()</span></code> — or when the caller can not increment
the reference count because the resulting <a class="reference internal" href="#c.iput" title="iput"><code class="xref c c-func docutils literal"><span class="pre">iput()</span></code></a> might cause an
inode eviction.  The tradeoff is that the <strong>match</strong> funtion must be
very carefully implemented.</p>
<dl class="function">
<dt id="c.iput">
void <code class="descname">iput</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iput" title="Permalink to this definition">¶</a></dt>
<dd><p>put an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to put</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Puts an inode, dropping its usage count. If the inode use count hits
zero, the inode is then freed and may also be destroyed.</p>
<p>Consequently, <a class="reference internal" href="#c.iput" title="iput"><code class="xref c c-func docutils literal"><span class="pre">iput()</span></code></a> can sleep.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bmap">
sector_t <code class="descname">bmap</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, sector_t<em>&nbsp;block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bmap" title="Permalink to this definition">¶</a></dt>
<dd><p>find a block number in a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode of file</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt>
<dd>block to find</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns the block number on the device holding the inode that
is the disk block number for the block of the file requested.
That is, asked for block 4 of inode 1 the function will return the
disk block relative to the disk start that holds that block of the
file.</div></blockquote>
<dl class="function">
<dt id="c.file_update_time">
int <code class="descname">file_update_time</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_update_time" title="Permalink to this definition">¶</a></dt>
<dd><p>update mtime and ctime time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file accessed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Update the mtime and ctime members of an inode and mark the inode
for writeback.  Note that this function is meant exclusively for
usage in the file write path of filesystems, and filesystems may
choose to explicitly ignore update via this function with the
S_NOCMTIME inode flag, e.g. for network filesystem where these
timestamps are handled by the server.  This can return an error for
file systems who need to allocate space in order to update an inode.</div></blockquote>
<dl class="function">
<dt id="c.inode_init_owner">
void <code class="descname">inode_init_owner</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, const struct inode *<em>&nbsp;dir</em>, umode_t<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_init_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Init uid,gid,mode for new inode according to posix standards</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>New inode</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>Directory inode</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>mode of the new inode</dd>
</dl>
<dl class="function">
<dt id="c.inode_owner_or_capable">
bool <code class="descname">inode_owner_or_capable</code><span class="sig-paren">(</span>const struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_owner_or_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>check current task permissions to inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode being checked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if current either has CAP_FOWNER in a namespace with the
inode owner uid mapped, or owns the file.</p>
<dl class="function">
<dt id="c.inode_dio_wait">
void <code class="descname">inode_dio_wait</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_dio_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for outstanding DIO requests to finish</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Waits for all pending direct I/O requests to finish so that we can
proceed with a truncate or equivalent operation.</p>
<p>Must be called under a lock that serializes taking new references
to i_dio_count, usually by inode-&gt;i_mutex.</p>
<dl class="function">
<dt id="c.current_time">
struct timespec <code class="descname">current_time</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.current_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return FS time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the current time truncated to the time granularity supported by
the fs.</p>
<p>Note that inode and inode-&gt;sb cannot be NULL.
Otherwise, the function warns and returns time without truncation.</p>
<dl class="function">
<dt id="c.make_bad_inode">
void <code class="descname">make_bad_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.make_bad_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>mark an inode bad due to an I/O error</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>Inode to mark bad</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>When an inode cannot be read due to a media or remote network
failure this function makes the inode “bad” and causes I/O operations
on it to fail from this point on.</div></blockquote>
<dl class="function">
<dt id="c.is_bad_inode">
bool <code class="descname">is_bad_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_bad_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>is an inode errored</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to test</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if the inode in question has been marked as bad.</div></blockquote>
<dl class="function">
<dt id="c.iget_failed">
void <code class="descname">iget_failed</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iget_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark an under-construction inode as dead and release it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>The inode to discard</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark an under-construction inode as dead and release it.</p>
</div>
<div class="section" id="registration-and-superblocks">
<h3>Registration and Superblocks<a class="headerlink" href="#registration-and-superblocks" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.deactivate_locked_super">
void <code class="descname">deactivate_locked_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.deactivate_locked_super" title="Permalink to this definition">¶</a></dt>
<dd><p>drop an active reference to superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>superblock to deactivate</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Drops an active reference to superblock, converting it into a temporary
one if there is no other active references left.  In that case we
tell fs driver to shut it down and drop the temporary reference we
had just acquired.</p>
<p>Caller holds exclusive lock on superblock; that lock is released.</p>
</div></blockquote>
<dl class="function">
<dt id="c.deactivate_super">
void <code class="descname">deactivate_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.deactivate_super" title="Permalink to this definition">¶</a></dt>
<dd><p>drop an active reference to superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>superblock to deactivate</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Variant of <a class="reference internal" href="#c.deactivate_locked_super" title="deactivate_locked_super"><code class="xref c c-func docutils literal"><span class="pre">deactivate_locked_super()</span></code></a>, except that superblock is <em>not</em>
locked by caller.  If we are going to drop the final active reference,
lock will be acquired prior to that.</div></blockquote>
<dl class="function">
<dt id="c.generic_shutdown_super">
void <code class="descname">generic_shutdown_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_shutdown_super" title="Permalink to this definition">¶</a></dt>
<dd><p>common helper for -&gt;:c:func:<cite>kill_sb()</cite></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>superblock to kill</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.generic_shutdown_super" title="generic_shutdown_super"><code class="xref c c-func docutils literal"><span class="pre">generic_shutdown_super()</span></code></a> does all fs-independent work on superblock
shutdown.  Typical -&gt;:c:func:<cite>kill_sb()</cite> should pick all fs-specific objects
that need destruction out of superblock, call <a class="reference internal" href="#c.generic_shutdown_super" title="generic_shutdown_super"><code class="xref c c-func docutils literal"><span class="pre">generic_shutdown_super()</span></code></a>
and release aforementioned objects.  Note: dentries and inodes _are_
taken care of and do not need specific handling.</p>
<p>Upon calling this function, the filesystem may no longer alter or
rearrange the set of dentries belonging to this super_block, nor may it
change the attachments of dentries to inodes.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sget_userns">
struct super_block * <code class="descname">sget_userns</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;type</em>, int (*test) (struct super_block<em>&nbsp;*</em>, void<em>&nbsp;*</em>, int (*set) (struct super_block<em>&nbsp;*</em>, void<em>&nbsp;*</em>, int<em>&nbsp;flags</em>, struct user_namespace *<em>&nbsp;user_ns</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sget_userns" title="Permalink to this definition">¶</a></dt>
<dd><p>find or create a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>filesystem type superblock should belong to</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>comparison callback</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,void</span> <span class="pre">*)</span> <span class="pre">set</span></code></dt>
<dd>setup callback</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>mount flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*</span> <span class="pre">user_ns</span></code></dt>
<dd>User namespace for the super_block</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>argument to each of them</dd>
</dl>
<dl class="function">
<dt id="c.sget">
struct super_block * <code class="descname">sget</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;type</em>, int (*test) (struct super_block<em>&nbsp;*</em>, void<em>&nbsp;*</em>, int (*set) (struct super_block<em>&nbsp;*</em>, void<em>&nbsp;*</em>, int<em>&nbsp;flags</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sget" title="Permalink to this definition">¶</a></dt>
<dd><p>find or create a superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>filesystem type superblock should belong to</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,void</span> <span class="pre">*)</span> <span class="pre">test</span></code></dt>
<dd>comparison callback</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,void</span> <span class="pre">*)</span> <span class="pre">set</span></code></dt>
<dd>setup callback</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>mount flags</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>argument to each of them</dd>
</dl>
<dl class="function">
<dt id="c.iterate_supers_type">
void <code class="descname">iterate_supers_type</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;type</em>, void (*f) (struct super_block<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iterate_supers_type" title="Permalink to this definition">¶</a></dt>
<dd><p>call function for superblocks of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>fs type</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">super_block</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">f</span></code></dt>
<dd>function to call</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>argument to pass to it</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Scans the superblock list and calls given function, passing it
locked superblock and given argument.</div></blockquote>
<dl class="function">
<dt id="c.get_super">
struct super_block * <code class="descname">get_super</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_super" title="Permalink to this definition">¶</a></dt>
<dd><p>get the superblock of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>device to get the superblock for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Scans the superblock list and finds the superblock of the file system
mounted on the device given. <code class="docutils literal"><span class="pre">NULL</span></code> is returned if no match is found.</div></blockquote>
<dl class="function">
<dt id="c.get_super_thawed">
struct super_block * <code class="descname">get_super_thawed</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_super_thawed" title="Permalink to this definition">¶</a></dt>
<dd><p>get thawed superblock of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>device to get the superblock for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Scans the superblock list and finds the superblock of the file system
mounted on the device. The superblock is returned once it is thawed
(or immediately if it was not frozen). <code class="docutils literal"><span class="pre">NULL</span></code> is returned if no match
is found.</div></blockquote>
<dl class="function">
<dt id="c.get_super_exclusive_thawed">
struct super_block * <code class="descname">get_super_exclusive_thawed</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_super_exclusive_thawed" title="Permalink to this definition">¶</a></dt>
<dd><p>get thawed superblock of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>device to get the superblock for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Scans the superblock list and finds the superblock of the file system
mounted on the device. The superblock is returned once it is thawed
(or immediately if it was not frozen) and s_umount semaphore is held
in exclusive mode. <code class="docutils literal"><span class="pre">NULL</span></code> is returned if no match is found.</div></blockquote>
<dl class="function">
<dt id="c.freeze_super">
int <code class="descname">freeze_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freeze_super" title="Permalink to this definition">¶</a></dt>
<dd><p>lock the filesystem and force it into a consistent state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super to lock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Syncs the super to make sure the filesystem is consistent and calls the fs’s
freeze_fs.  Subsequent calls to this without first thawing the fs will return
-EBUSY.</p>
<p>During this function, sb-&gt;s_writers.frozen goes through these values:</p>
<p>SB_UNFROZEN: File system is normal, all writes progress as usual.</p>
<p>SB_FREEZE_WRITE: The file system is in the process of being frozen.  New
writes should be blocked, though page faults are still allowed. We wait for
all writes to complete and then proceed to the next stage.</p>
<p>SB_FREEZE_PAGEFAULT: Freezing continues. Now also page faults are blocked
but internal fs threads can still modify the filesystem (although they
should not dirty new pages or inodes), writeback can run etc. After waiting
for all running page faults we sync the filesystem which will clean all
dirty pages and inodes (no new dirty pages or inodes can be created when
sync is running).</p>
<p>SB_FREEZE_FS: The file system is frozen. Now all internal sources of fs
modification are blocked (e.g. XFS preallocation truncation on inode
reclaim). This is usually implemented by blocking new transactions for
filesystems that have them and need this additional guard. After all
internal writers are finished we call -&gt;:c:func:<cite>freeze_fs()</cite> to finish filesystem
freezing. Then we transition to SB_FREEZE_COMPLETE state. This state is
mostly auxiliary for filesystems to verify they do not modify frozen fs.</p>
<p>sb-&gt;s_writers.frozen is protected by sb-&gt;s_umount.</p>
<dl class="function">
<dt id="c.thaw_super">
int <code class="descname">thaw_super</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.thaw_super" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>unlock filesystem</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the super to thaw</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the filesystem and marks it writeable again after <a class="reference internal" href="#c.freeze_super" title="freeze_super"><code class="xref c c-func docutils literal"><span class="pre">freeze_super()</span></code></a>.</p>
</div>
<div class="section" id="file-locks">
<h3>File Locks<a class="headerlink" href="#file-locks" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.posix_lock_file">
int <code class="descname">posix_lock_file</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct file_lock *<em>&nbsp;fl</em>, struct file_lock *<em>&nbsp;conflock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_lock_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a POSIX-style lock to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>The file to apply the lock to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">conflock</span></code></dt>
<dd>Place to return a copy of the conflicting lock, if found.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a POSIX style lock to a file.
We merge adjacent &amp; overlapping locks whenever possible.
POSIX locks are sorted by owner task, then by starting address</p>
<p>Note that if called with an FL_EXISTS argument, the caller may determine
whether or not a lock was successfully freed by testing the return
value for -ENOENT.</p>
<dl class="function">
<dt id="c.locks_mandatory_area">
int <code class="descname">locks_mandatory_area</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;filp</em>, loff_t<em>&nbsp;start</em>, loff_t<em>&nbsp;end</em>, unsigned char<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_mandatory_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for a conflicting lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the file to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>how the file was opened (if it was)</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start</span></code></dt>
<dd>first byte in the file to check</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end</span></code></dt>
<dd>lastbyte in the file to check</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">type</span></code></dt>
<dd><code class="docutils literal"><span class="pre">F_WRLCK</span></code> for a write lock, else <code class="docutils literal"><span class="pre">F_RDLCK</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Searches the inode’s list of locks to find any POSIX locks which conflict.</p>
<dl class="function">
<dt id="c.__break_lease">
int <code class="descname">__break_lease</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, unsigned int<em>&nbsp;mode</em>, unsigned int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__break_lease" title="Permalink to this definition">¶</a></dt>
<dd><p>revoke all outstanding leases on file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode of the file to return</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt>
<dd>O_RDONLY: break only write leases; O_WRONLY or O_RDWR:
break all leases</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>FL_LEASE: break leases and delegations; FL_DELEG: break
only delegations</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>break_lease (inlined for speed) has checked there already is at least
some kind of lock (maybe a lease) on this file.  Leases are broken on
a call to <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> or <code class="xref c c-func docutils literal"><span class="pre">truncate()</span></code>.  This function can sleep unless you
specified <code class="docutils literal"><span class="pre">O_NONBLOCK</span></code> to your <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.lease_get_mtime">
void <code class="descname">lease_get_mtime</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct timespec *<em>&nbsp;time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lease_get_mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last modified time of an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timespec</span> <span class="pre">*</span> <span class="pre">time</span></code></dt>
<dd>pointer to a timespec which will contain the last modified time</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is to force NFS clients to flush their caches for files with
exclusive leases.  The justification is that if someone has an
exclusive lease, then they could be modifying it.</p>
<dl class="function">
<dt id="c.generic_setlease">
int <code class="descname">generic_setlease</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, long<em>&nbsp;arg</em>, struct file_lock **<em>&nbsp;flp</em>, void **<em>&nbsp;priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>type of lease to obtain</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">**</span> <span class="pre">flp</span></code></dt>
<dd>input - file_lock to use, output - file_lock inserted</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">priv</span></code></dt>
<dd>private data for lm_setup (may be NULL if lm_setup
doesn’t require it)</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The (input) flp-&gt;fl_lmops-&gt;lm_break function is required
by <code class="xref c c-func docutils literal"><span class="pre">break_lease()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.vfs_setlease">
int <code class="descname">vfs_setlease</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, long<em>&nbsp;arg</em>, struct file_lock **<em>&nbsp;lease</em>, void **<em>&nbsp;priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>type of lease to obtain</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">**</span> <span class="pre">lease</span></code></dt>
<dd>file_lock to use when adding a lease</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">priv</span></code></dt>
<dd>private info for lm_setup when adding a lease (may be
NULL if lm_setup doesn’t require it)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this to establish a lease on the file. The “lease” argument is not
used for F_UNLCK requests and may be NULL. For commands that set or alter
an existing lease, the <code class="docutils literal"><span class="pre">(*lease)-&gt;fl_lmops-&gt;lm_break</span></code> operation must be
set; if not, this function will return -ENOLCK (and generate a scary-looking
stack trace).</p>
<p>The “priv” pointer is passed directly to the lm_setup function as-is. It
may be NULL if the lm_setup operation doesn’t require it.</p>
<dl class="function">
<dt id="c.locks_lock_inode_wait">
int <code class="descname">locks_lock_inode_wait</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a lock to an inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode of the file to apply to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a POSIX or FLOCK style lock request to an inode.</p>
<dl class="function">
<dt id="c.vfs_test_lock">
int <code class="descname">vfs_test_lock</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_test_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>test file byte range lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>The file to test lock for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to test; also used to hold result</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns -ERRNO on failure.  Indicates presence of conflicting lock by
setting conf-&gt;fl_type to something other than F_UNLCK.</p>
<dl class="function">
<dt id="c.vfs_lock_file">
int <code class="descname">vfs_lock_file</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, unsigned int<em>&nbsp;cmd</em>, struct file_lock *<em>&nbsp;fl</em>, struct file_lock *<em>&nbsp;conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_lock_file" title="Permalink to this definition">¶</a></dt>
<dd><p>file byte range lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>The file to apply the lock to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>type of locking operation (F_SETLK, F_GETLK, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>Place to return a copy of the conflicting lock, if found.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A caller that doesn’t care about the conflicting lock may pass NULL
as the final argument.</p>
<p>If the filesystem defines a private -&gt;:c:func:<cite>lock()</cite> method, then <strong>conf</strong> will
be left unchanged; so a caller that cares should initialize it to
some acceptable default.</p>
<p>To avoid blocking kernel daemons, such as lockd, that need to acquire POSIX
locks, the -&gt;:c:func:<cite>lock()</cite> interface may return asynchronously, before the lock has
been granted or denied by the underlying filesystem, if (and only if)
lm_grant is set. Callers expecting -&gt;:c:func:<cite>lock()</cite> to return asynchronously
will only use F_SETLK, not F_SETLKW; they will set FL_SLEEP if (and only if)
the request is for a blocking lock. When -&gt;:c:func:<cite>lock()</cite> does return asynchronously,
it must return FILE_LOCK_DEFERRED, and call -&gt;:c:func:<cite>lm_grant()</cite> when the lock
request completes.
If the request is for non-blocking lock the file system should return
FILE_LOCK_DEFERRED then try to get the lock and call the callback routine
with the result. If the request timed out the callback routine will return a
nonzero return code and the file system should release the lock. The file
system is also responsible to keep a corresponding posix lock when it
grants a lock so the VFS can find out which locks are locally held and do
the correct lock cleanup when required.
The underlying filesystem must not drop the kernel lock or call
-&gt;:c:func:<cite>lm_grant()</cite> before returning to the caller with a FILE_LOCK_DEFERRED
return code.</p>
<dl class="function">
<dt id="c.posix_unblock_lock">
int <code class="descname">posix_unblock_lock</code><span class="sig-paren">(</span>struct file_lock *<em>&nbsp;waiter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_unblock_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>stop waiting for a file lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">waiter</span></code></dt>
<dd>the lock which was waiting</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>lockd needs to block waiting for locks.</div></blockquote>
<dl class="function">
<dt id="c.vfs_cancel_lock">
int <code class="descname">vfs_cancel_lock</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_cancel_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>file byte range unblock lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>The file to apply the unblock to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be unblocked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by lock managers to cancel blocked requests</p>
<dl class="function">
<dt id="c.posix_lock_inode_wait">
int <code class="descname">posix_lock_inode_wait</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.posix_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a POSIX-style lock to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode of file to which lock request should be applied</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a POSIX style lock request to an inode.</p>
<dl class="function">
<dt id="c.locks_mandatory_locked">
int <code class="descname">locks_mandatory_locked</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_mandatory_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for an active lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>the file to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Searches the inode’s list of locks to find any POSIX locks which conflict.
This function is called from <code class="xref c c-func docutils literal"><span class="pre">locks_verify_locked()</span></code> only.</p>
<dl class="function">
<dt id="c.fcntl_getlease">
int <code class="descname">fcntl_getlease</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fcntl_getlease" title="Permalink to this definition">¶</a></dt>
<dd><p>Enquire what lease is currently active</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The value returned by this function will be one of
(if no lease break is pending):</p>
<p><code class="docutils literal"><span class="pre">F_RDLCK</span></code> to indicate a shared lease is held.</p>
<p><code class="docutils literal"><span class="pre">F_WRLCK</span></code> to indicate an exclusive lease is held.</p>
<p><code class="docutils literal"><span class="pre">F_UNLCK</span></code> to indicate no lease is held.</p>
<p>(if a lease break is pending):</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">F_RDLCK</span></code> to indicate an exclusive lease needs to be</dt>
<dd>changed to a shared lease (or removed).</dd>
</dl>
<p><code class="docutils literal"><span class="pre">F_UNLCK</span></code> to indicate the lease needs to be removed.</p>
<p>XXX: sfr &amp; willy disagree over whether F_INPROGRESS
should be returned to userspace.</p>
</div></blockquote>
<dl class="function">
<dt id="c.check_conflicting_open">
int <code class="descname">check_conflicting_open</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em>, const long<em>&nbsp;arg</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_conflicting_open" title="Permalink to this definition">¶</a></dt>
<dd><p>see if the given dentry points to a file that has an existing open that would conflict with the desired lease.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry to check</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>type of lease that we’re trying to acquire</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>current lock flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if there’s an existing open fd on this file that would
conflict with the lease we’re trying to set.</p>
<dl class="function">
<dt id="c.fcntl_setlease">
int <code class="descname">fcntl_setlease</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;fd</em>, struct file *<em>&nbsp;filp</em>, long<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fcntl_setlease" title="Permalink to this definition">¶</a></dt>
<dd><p>sets a lease on an open file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>open file descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>type of lease to obtain</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Call this fcntl to establish a lease on the file.
Note that you also need to call <code class="docutils literal"><span class="pre">F_SETSIG</span></code> to
receive a signal when the lease is broken.</div></blockquote>
<dl class="function">
<dt id="c.flock_lock_inode_wait">
int <code class="descname">flock_lock_inode_wait</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file_lock *<em>&nbsp;fl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flock_lock_inode_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a FLOCK-style lock to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode of the file to apply to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The lock to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply a FLOCK style lock request to an inode.</p>
<dl class="function">
<dt id="c.sys_flock">
long <code class="descname">sys_flock</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;fd</em>, unsigned int<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_flock" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref c c-func docutils literal"><span class="pre">flock()</span></code> system call.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>the file descriptor to lock.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>the type of lock to apply.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Apply a <code class="docutils literal"><span class="pre">FL_FLOCK</span></code> style lock to an open file descriptor.
The <strong>cmd</strong> can be one of:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">LOCK_SH</span></code> – a shared lock.</li>
<li><code class="docutils literal"><span class="pre">LOCK_EX</span></code> – an exclusive lock.</li>
<li><code class="docutils literal"><span class="pre">LOCK_UN</span></code> – remove an existing lock.</li>
<li><code class="docutils literal"><span class="pre">LOCK_MAND</span></code> – a ‘mandatory’ flock.
This exists to emulate Windows Share Modes.</li>
</ul>
<p><code class="docutils literal"><span class="pre">LOCK_MAND</span></code> can be combined with <code class="docutils literal"><span class="pre">LOCK_READ</span></code> or <code class="docutils literal"><span class="pre">LOCK_WRITE</span></code> to allow other
processes read and write access respectively.</p>
</div></blockquote>
<dl class="function">
<dt id="c.locks_translate_pid">
pid_t <code class="descname">locks_translate_pid</code><span class="sig-paren">(</span>struct file_lock *<em>&nbsp;fl</em>, struct pid_namespace *<em>&nbsp;ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.locks_translate_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>translate a file_lock’s fl_pid number into a namespace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_lock</span> <span class="pre">*</span> <span class="pre">fl</span></code></dt>
<dd>The file_lock who’s fl_pid should be translated</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pid_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>The namespace into which the pid should be translated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to tranlate a fl_pid into a namespace virtual pid number</p>
</div>
<div class="section" id="other-functions">
<h3>Other Functions<a class="headerlink" href="#other-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.mpage_readpages">
int <code class="descname">mpage_readpages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct list_head *<em>&nbsp;pages</em>, unsigned<em>&nbsp;nr_pages</em>, get_block_t<em>&nbsp;get_block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mpage_readpages" title="Permalink to this definition">¶</a></dt>
<dd><p>populate an address space with some pages &amp; start reads against them</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">pages</span></code></dt>
<dd>The address of a list_head which contains the target pages.  These
pages have their -&gt;index populated and are otherwise uninitialised.
The page at <strong>pages</strong>-&gt;prev has the lowest file offset, and reads should be
issued in <strong>pages</strong>-&gt;prev to <strong>pages</strong>-&gt;next order.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">nr_pages</span></code></dt>
<dd>The number of pages at <strong>*pages</strong></dd>
<dt><code class="docutils literal"><span class="pre">get_block_t</span> <span class="pre">get_block</span></code></dt>
<dd>The filesystem’s block mapper function.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the pages and the blocks within each page, building and
emitting large BIOs.</p>
<p>If anything unusual happens, such as:</p>
<ul class="simple">
<li>encountering a page which has buffers</li>
<li>encountering a page which has a non-hole after a hole</li>
<li>encountering a page with non-contiguous blocks</li>
</ul>
<p>then this code just gives up and calls the buffer_head-based read function.
It does handle a page which has holes at the end - that is a common case:
the end-of-file on blocksize &lt; PAGE_SIZE setups.</p>
<p>BH_Boundary explanation:</p>
<p>There is a problem.  The mpage read code assembles several pages, gets all
their disk mappings, and then submits them all.  That’s fine, but obtaining
the disk mappings may require I/O.  Reads of indirect blocks, for example.</p>
<p>So an mpage read of the first 16 blocks of an ext2 file will cause I/O to be
submitted in the following order:</p>
<blockquote>
<div>12 0 1 2 3 4 5 6 7 8 9 10 11 13 14 15 16</div></blockquote>
<p>because the indirect block has to be read to get the mappings of blocks
13,14,15,16.  Obviously, this impacts performance.</p>
<p>So what we do it to allow the filesystem’s <code class="xref c c-func docutils literal"><span class="pre">get_block()</span></code> function to set
BH_Boundary when it maps block 11.  BH_Boundary says: mapping of the block
after this one will require I/O against a block which is probably close to
this one.  So you should push what I/O you have currently accumulated.</p>
<p>This all causes the disk requests to be issued in the correct order.</p>
<dl class="function">
<dt id="c.mpage_writepages">
int <code class="descname">mpage_writepages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct writeback_control *<em>&nbsp;wbc</em>, get_block_t<em>&nbsp;get_block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mpage_writepages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space &amp; <code class="xref c c-func docutils literal"><span class="pre">writepage()</span></code> all of them</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>subtract the number of written pages from <strong>*wbc</strong>-&gt;nr_to_write</dd>
<dt><code class="docutils literal"><span class="pre">get_block_t</span> <span class="pre">get_block</span></code></dt>
<dd>the filesystem’s block mapper function.
If this is NULL then use a_ops-&gt;writepage.  Otherwise, go
direct-to-BIO.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a library function, which implements the <code class="xref c c-func docutils literal"><span class="pre">writepages()</span></code>
address_space_operation.</p>
<p>If a page is already under I/O, <a class="reference internal" href="../core-api/kernel-api.html#c.generic_writepages" title="generic_writepages"><code class="xref c c-func docutils literal"><span class="pre">generic_writepages()</span></code></a> skips it, even
if it’s dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>.  <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">msync()</span></code> need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.</p>
<dl class="function">
<dt id="c.generic_permission">
int <code class="descname">generic_permission</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_permission" title="Permalink to this definition">¶</a></dt>
<dd><p>check for access rights on a Posix-like filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to check access rights for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>right to check for (<code class="docutils literal"><span class="pre">MAY_READ</span></code>, <code class="docutils literal"><span class="pre">MAY_WRITE</span></code>, <code class="docutils literal"><span class="pre">MAY_EXEC</span></code>, …)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to check for read/write/execute permissions on a file.
We use “fsuid” for this, letting us set arbitrary permissions
for filesystem access without changing the “normal” uids which
are used for other things.</p>
<p>generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk
request cannot be satisfied (eg. requires blocking or too much complexity).
It would then be called again in ref-walk mode.</p>
<dl class="function">
<dt id="c.__inode_permission">
int <code class="descname">__inode_permission</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__inode_permission" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for access rights to a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>Inode to check permission on</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>Right to check for (<code class="docutils literal"><span class="pre">MAY_READ</span></code>, <code class="docutils literal"><span class="pre">MAY_WRITE</span></code>, <code class="docutils literal"><span class="pre">MAY_EXEC</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for read/write/execute permissions on an inode.</p>
<p>When checking for MAY_APPEND, MAY_WRITE must also be set in <strong>mask</strong>.</p>
<p>This does not check for a read-only file system.  You probably want
<a class="reference internal" href="#c.inode_permission" title="inode_permission"><code class="xref c c-func docutils literal"><span class="pre">inode_permission()</span></code></a>.</p>
<dl class="function">
<dt id="c.inode_permission">
int <code class="descname">inode_permission</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_permission" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for access rights to a given inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>Inode to check permission on</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>Right to check for (<code class="docutils literal"><span class="pre">MAY_READ</span></code>, <code class="docutils literal"><span class="pre">MAY_WRITE</span></code>, <code class="docutils literal"><span class="pre">MAY_EXEC</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for read/write/execute permissions on an inode.  We use fs[ug]id for
this, letting us set arbitrary permissions for filesystem access without
changing the “normal” UIDs which are used for other things.</p>
<p>When checking for MAY_APPEND, MAY_WRITE must also be set in <strong>mask</strong>.</p>
<dl class="function">
<dt id="c.path_get">
void <code class="descname">path_get</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a path</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to get the reference to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a path increment the reference count to the dentry and the vfsmount.</p>
<dl class="function">
<dt id="c.path_put">
void <code class="descname">path_put</code><span class="sig-paren">(</span>const struct path *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.path_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a path</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to put the reference to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a path decrement the reference count to the dentry and the vfsmount.</p>
<dl class="function">
<dt id="c.vfs_path_lookup">
int <code class="descname">vfs_path_lookup</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct vfsmount *<em>&nbsp;mnt</em>, const char *<em>&nbsp;name</em>, unsigned int<em>&nbsp;flags</em>, struct path *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_path_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup a file path relative to a dentry-vfsmount pair</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>pointer to dentry of the base directory</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vfsmount</span> <span class="pre">*</span> <span class="pre">mnt</span></code></dt>
<dd>pointer to vfs mount of the base directory</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pointer to file name</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>lookup flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>pointer to struct path to fill</dd>
</dl>
<dl class="function">
<dt id="c.lookup_one_len">
struct dentry * <code class="descname">lookup_one_len</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;base</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one_len" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pathname component to lookup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>base directory to lookup from</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>maximum length <strong>len</strong> should be interpreted to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>The caller must hold base-&gt;i_mutex.</p>
<dl class="function">
<dt id="c.lookup_one_len_unlocked">
struct dentry * <code class="descname">lookup_one_len_unlocked</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;base</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_one_len_unlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>filesystem helper to lookup single pathname component</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pathname component to lookup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>base directory to lookup from</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>maximum length <strong>len</strong> should be interpreted to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this routine is purely a helper for filesystem usage and should
not be called by generic code.</p>
<p>Unlike lookup_one_len, it should be called without the parent
i_mutex held, and will take the i_mutex itself if necessary.</p>
<dl class="function">
<dt id="c.vfs_unlink">
int <code class="descname">vfs_unlink</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;dir</em>, struct dentry *<em>&nbsp;dentry</em>, struct inode **<em>&nbsp;delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>unlink a filesystem object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>parent directory</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>victim</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**</span> <span class="pre">delegated_inode</span></code></dt>
<dd>returns victim inode, if the inode is delegated.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold dir-&gt;i_mutex.</p>
<p>If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
return a reference to the inode in delegated_inode.  The caller
should then break the delegation on that inode and retry.  Because
breaking a delegation may take a long time, the caller should drop
dir-&gt;i_mutex before doing so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<dl class="function">
<dt id="c.vfs_link">
int <code class="descname">vfs_link</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;old_dentry</em>, struct inode *<em>&nbsp;dir</em>, struct dentry *<em>&nbsp;new_dentry</em>, struct inode **<em>&nbsp;delegated_inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dentry</span></code></dt>
<dd>object to be linked</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">dir</span></code></dt>
<dd>new parent</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">new_dentry</span></code></dt>
<dd>where to create the new link</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**</span> <span class="pre">delegated_inode</span></code></dt>
<dd>returns inode needing a delegation break</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold dir-&gt;i_mutex</p>
<p>If vfs_link discovers a delegation on the to-be-linked file in need
of breaking, it will return -EWOULDBLOCK and return a reference to the
inode in delegated_inode.  The caller should then break the delegation
and retry.  Because breaking a delegation may take a long time, the
caller should drop the i_mutex before doing so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<dl class="function">
<dt id="c.vfs_rename">
int <code class="descname">vfs_rename</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;old_dir</em>, struct dentry *<em>&nbsp;old_dentry</em>, struct inode *<em>&nbsp;new_dir</em>, struct dentry *<em>&nbsp;new_dentry</em>, struct inode **<em>&nbsp;delegated_inode</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename a filesystem object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">old_dir</span></code></dt>
<dd>parent of source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dentry</span></code></dt>
<dd>source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">new_dir</span></code></dt>
<dd>parent of destination</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">new_dentry</span></code></dt>
<dd>destination</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">**</span> <span class="pre">delegated_inode</span></code></dt>
<dd>returns an inode needing a delegation break</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>rename flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must hold multiple mutexes–see <code class="xref c c-func docutils literal"><span class="pre">lock_rename()</span></code>).</p>
<p>If vfs_rename discovers a delegation in need of breaking at either
the source or destination, it will return -EWOULDBLOCK and return a
reference to the inode in delegated_inode.  The caller should then
break the delegation and retry.  Because breaking a delegation may
take a long time, the caller should drop all locks before doing
so.</p>
<p>Alternatively, a caller may pass NULL for delegated_inode.  This may
be appropriate for callers that expect the underlying filesystem not
to be NFS exported.</p>
<p>The worst of all namespace operations - renaming directory. “Perverted”
doesn’t even start to describe it. Somebody in UCB had a heck of a trip…
Problems:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>we can get into loop creation.</li>
<li>race potential - two innocent renames can create a loop together.
That’s where 4.4 screws up. Current fix: serialization on
sb-&gt;s_vfs_rename_mutex. We might be more accurate, but that’s another
story.</li>
<li>we have to lock _four_ objects - parents and victim (if it exists),
and source (if it is not a directory).
And that - after we got -&gt;i_mutex on parents (until then we don’t know
whether the target exists).  Solution: try to be smart with locking
order for inodes.  We rely on the fact that tree topology may change
only under -&gt;s_vfs_rename_mutex _and_ that parent of the object we
move will be locked.  Thus we can rank directories by the tree
(ancestors first) and rank all non-directories after them.
That works since everybody except rename does “lock parent, lookup,
lock child” and rename is under -&gt;s_vfs_rename_mutex.
HOWEVER, it relies on the assumption that any object with -&gt;:c:func:<cite>lookup()</cite>
has no more than 1 dentry.  If “hybrid” objects will ever appear,
we’d better make sure that there’s no link(2) for them.</li>
<li>conversion from fhandle to dentry may come in the wrong moment - when
we are removing the target. Solution: we will have to grab -&gt;i_mutex
in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on
-&gt;i_mutex on parents, which works but leads to some truly excessive
locking].</li>
</ol>
</div></blockquote>
<dl class="function">
<dt id="c.vfs_readlink">
int <code class="descname">vfs_readlink</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, char __user *<em>&nbsp;buffer</em>, int<em>&nbsp;buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_readlink" title="Permalink to this definition">¶</a></dt>
<dd><p>copy symlink body into userspace buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry on which to get symbolic link</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>user memory pointer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Does not touch atime.  That’s up to the caller if necessary</p>
<p>Does not call security hook.</p>
<dl class="function">
<dt id="c.vfs_get_link">
const char * <code class="descname">vfs_get_link</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em>, struct delayed_call *<em>&nbsp;done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfs_get_link" title="Permalink to this definition">¶</a></dt>
<dd><p>get symlink body</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry on which to get symbolic link</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_call</span> <span class="pre">*</span> <span class="pre">done</span></code></dt>
<dd>caller needs to free returned data with this</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls security hook and i_op-&gt;:c:func:<cite>get_link()</cite> on the supplied inode.</p>
<p>It does not touch atime.  That’s up to the caller if necessary.</p>
<p>Does not work on “special” symlinks like /proc/$$/fd/N</p>
<dl class="function">
<dt id="c.sync_mapping_buffers">
int <code class="descname">sync_mapping_buffers</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_mapping_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait upon a mapping’s “associated” buffers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the mapping which wants those buffers written</dd>
</dl>
<p><strong>Description</strong></p>
<p>Starts I/O against the buffers at mapping-&gt;private_list, and waits upon
that I/O.</p>
<p>Basically, this is a convenience function for <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>.
<strong>mapping</strong> is a file or directory which needs those buffers to be written for
a successful <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>.</p>
<dl class="function">
<dt id="c.mark_buffer_dirty">
void <code class="descname">mark_buffer_dirty</code><span class="sig-paren">(</span>struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mark_buffer_dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a buffer_head as needing writeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>the buffer_head to mark dirty</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mark_buffer_dirty" title="mark_buffer_dirty"><code class="xref c c-func docutils literal"><span class="pre">mark_buffer_dirty()</span></code></a> will set the dirty bit against the buffer, then set its
backing page dirty, then tag the page as dirty in its address_space’s radix
tree and then attach the address_space’s inode to its superblock’s dirty
inode list.</p>
<p><a class="reference internal" href="#c.mark_buffer_dirty" title="mark_buffer_dirty"><code class="xref c c-func docutils literal"><span class="pre">mark_buffer_dirty()</span></code></a> is atomic.  It takes bh-&gt;b_page-&gt;mapping-&gt;private_lock,
mapping-&gt;tree_lock and mapping-&gt;host-&gt;i_lock.</p>
<dl class="function">
<dt id="c.__bread_gfp">
struct buffer_head * <code class="descname">__bread_gfp</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;block</em>, unsigned<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bread_gfp" title="Permalink to this definition">¶</a></dt>
<dd><p>reads a specified block and returns the bh</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the block_device to read from</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt>
<dd>number of block</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">size</span></code></dt>
<dd>size (in bytes) to read</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>page allocation flag</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Reads a specified block, and returns buffer head that contains it.
The page cache can be allocated from non-movable area
not to prevent page migration if you set gfp to zero.
It returns NULL if the block was unreadable.</div></blockquote>
<dl class="function">
<dt id="c.block_invalidatepage">
void <code class="descname">block_invalidatepage</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;offset</em>, unsigned int<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.block_invalidatepage" title="Permalink to this definition">¶</a></dt>
<dd><p>invalidate part or all of a buffer-backed page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page which is affected</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>start of the range to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt>
<dd>length of the range to invalidate</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.block_invalidatepage" title="block_invalidatepage"><code class="xref c c-func docutils literal"><span class="pre">block_invalidatepage()</span></code></a> is called when all or part of the page has become
invalidated by a truncate operation.</p>
<p><a class="reference internal" href="#c.block_invalidatepage" title="block_invalidatepage"><code class="xref c c-func docutils literal"><span class="pre">block_invalidatepage()</span></code></a> does not have to release all buffers, but it must
ensure that no dirty buffer is left outside <strong>offset</strong> and that no I/O
is underway against any of the blocks which are outside the truncation
point.  Because the caller is about to free (and possibly reuse) those
blocks on-disk.</p>
<dl class="function">
<dt id="c.clean_bdev_aliases">
void <code class="descname">clean_bdev_aliases</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;block</em>, sector_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clean_bdev_aliases" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>Block device to clean buffers in</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">block</span></code></dt>
<dd>Start of a range of blocks to clean</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">len</span></code></dt>
<dd>Number of blocks to clean</dd>
</dl>
<p><strong>Description</strong></p>
<p>We are taking a range of blocks for data and we don’t want writeback of any
buffer-cache aliases starting from return from this function and until the
moment when something will explicitly mark the buffer dirty (hopefully that
will not happen until we will free that block ;-) We don’t even need to mark
it not-uptodate - nobody can expect anything from a newly allocated buffer
anyway. We used to use <code class="xref c c-func docutils literal"><span class="pre">unmap_buffer()</span></code> for such invalidation, but that was
wrong. We definitely don’t want to mark the alias unmapped, for example - it
would confuse anyone who might pick it with <code class="xref c c-func docutils literal"><span class="pre">bread()</span></code> afterwards…</p>
<p>Also..  Note that <code class="xref c c-func docutils literal"><span class="pre">bforget()</span></code> doesn’t lock the buffer.  So there can be
writeout I/O going on against recently-freed buffers.  We don’t wait on that
I/O in <code class="xref c c-func docutils literal"><span class="pre">bforget()</span></code> - it’s more efficient to wait on the I/O only if we really
need to.  That happens here.</p>
<dl class="function">
<dt id="c.ll_rw_block">
void <code class="descname">ll_rw_block</code><span class="sig-paren">(</span>int<em>&nbsp;op</em>, int<em>&nbsp;op_flags</em>, int<em>&nbsp;nr</em>, struct buffer_head *<em>&nbsp;bhs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ll_rw_block" title="Permalink to this definition">¶</a></dt>
<dd><p>level access to block devices (DEPRECATED)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>whether to <code class="docutils literal"><span class="pre">READ</span></code> or <code class="docutils literal"><span class="pre">WRITE</span></code></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">op_flags</span></code></dt>
<dd>req_flag_bits</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>number of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_heads</span></code> in the array</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bhs</span></code></dt>
<dd>array of pointers to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.ll_rw_block" title="ll_rw_block"><code class="xref c c-func docutils literal"><span class="pre">ll_rw_block()</span></code></a> takes an array of pointers to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_heads</span></code>, and
requests an I/O operation on them, either a <code class="docutils literal"><span class="pre">REQ_OP_READ</span></code> or a <code class="docutils literal"><span class="pre">REQ_OP_WRITE</span></code>.
<strong>op_flags</strong> contains flags modifying the detailed I/O behavior, most notably
<code class="docutils literal"><span class="pre">REQ_RAHEAD</span></code>.</p>
<p>This function drops any buffer that it cannot get a lock on (with the
BH_Lock state bit), any buffer that appears to be clean when doing a write
request, and any buffer that appears to be up-to-date when doing read
request.  Further it marks as clean buffers that are processed for
writing (the buffer cache won’t assume that they are actually clean
until the buffer gets unlocked).</p>
<p>ll_rw_block sets b_end_io to simple completion handler that marks
the buffer up-to-date (if appropriate), unlocks the buffer and wakes
any waiters.</p>
<p>All of the buffers must be for the same device, and must also be a
multiple of the current approved size for the device.</p>
<dl class="function">
<dt id="c.bh_uptodate_or_lock">
int <code class="descname">bh_uptodate_or_lock</code><span class="sig-paren">(</span>struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bh_uptodate_or_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the buffer is uptodate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>struct buffer_head</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the buffer is up-to-date and false,
with the buffer locked, if not.</p>
<dl class="function">
<dt id="c.bh_submit_read">
int <code class="descname">bh_submit_read</code><span class="sig-paren">(</span>struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bh_submit_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit a locked buffer for reading</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>struct buffer_head</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero on success and -EIO on error.</p>
<dl class="function">
<dt id="c.bio_reset">
void <code class="descname">bio_reset</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reinitialize a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to reset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>After calling <a class="reference internal" href="#c.bio_reset" title="bio_reset"><code class="xref c c-func docutils literal"><span class="pre">bio_reset()</span></code></a>, <strong>bio</strong> will be in the same state as a freshly
allocated bio returned bio <a class="reference internal" href="#c.bio_alloc_bioset" title="bio_alloc_bioset"><code class="xref c c-func docutils literal"><span class="pre">bio_alloc_bioset()</span></code></a> - the only fields that are
preserved are the ones that are initialized by <a class="reference internal" href="#c.bio_alloc_bioset" title="bio_alloc_bioset"><code class="xref c c-func docutils literal"><span class="pre">bio_alloc_bioset()</span></code></a>. See
comment in struct bio.</div></blockquote>
<dl class="function">
<dt id="c.bio_chain">
void <code class="descname">bio_chain</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct bio *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>chain bio completions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>the target bio</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the <strong>bio</strong>’s parent bio</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller won’t have a bi_end_io called when <strong>bio</strong> completes - instead,
<strong>parent</strong>’s bi_end_io won’t be called until both <strong>parent</strong> and <strong>bio</strong> have
completed; the chained bio will also be freed when it completes.</p>
<p>The caller must not set bi_private or bi_end_io in <strong>bio</strong>.</p>
<dl class="function">
<dt id="c.bio_alloc_bioset">
struct bio * <code class="descname">bio_alloc_bioset</code><span class="sig-paren">(</span>gfp_t<em>&nbsp;gfp_mask</em>, unsigned int<em>&nbsp;nr_iovecs</em>, struct bio_set *<em>&nbsp;bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_alloc_bioset" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a bio for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>the <a href="#id1"><span class="problematic" id="id2">GFP_</span></a> mask given to the slab allocator</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_iovecs</span></code></dt>
<dd>number of iovecs to pre-allocate</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>the bio_set to allocate from.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If <strong>bs</strong> is NULL, uses <a class="reference internal" href="../core-api/kernel-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> to allocate the bio; else the allocation is
backed by the <strong>bs</strong>’s mempool.</p>
<p>When <strong>bs</strong> is not NULL, if <code class="docutils literal"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> is set then bio_alloc will
always be able to allocate a bio. This is due to the mempool guarantees.
To make this work, callers must never allocate more than 1 bio at a time
from this pool. Callers that need to allocate more than 1 bio must always
submit the previously allocated bio for IO before attempting to allocate
a new one. Failure to do so can cause deadlocks under memory pressure.</p>
<p>Note that when running under <a class="reference internal" href="../core-api/kernel-api.html#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> (i.e. any block
driver), bios are not submitted until after you return - see the code in
<a class="reference internal" href="../core-api/kernel-api.html#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> that converts recursion into iteration, to prevent
stack overflows.</p>
<p>This would normally mean allocating multiple bios under
<a class="reference internal" href="../core-api/kernel-api.html#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> would be susceptible to deadlocks, but we have
deadlock avoidance code that resubmits any blocked bios from a rescuer
thread.</p>
<p>However, we do not guarantee forward progress for allocations from other
mempools. Doing multiple allocations from the same mempool under
<a class="reference internal" href="../core-api/kernel-api.html#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> should be avoided - instead, use bio_set’s front_pad
for per bio allocations.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to new bio on success, NULL on failure.</div></blockquote>
<dl class="function">
<dt id="c.bio_put">
void <code class="descname">bio_put</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to release reference to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Put a reference to a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>, either one you have gotten with
bio_alloc, bio_get or bio_clone_*. The last put of a bio will free it.</div></blockquote>
<dl class="function">
<dt id="c.__bio_clone_fast">
void <code class="descname">__bio_clone_fast</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct bio *<em>&nbsp;bio_src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bio_clone_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a bio that shares the original bio’s biovec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio_src</span></code></dt>
<dd>bio to clone</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Clone a <code class="xref c c-type docutils literal"><span class="pre">bio</span></code>. Caller will own the returned bio, but not
the actual data it points to. Reference count of returned
bio will be one.</p>
<p>Caller must ensure that <strong>bio_src</strong> is not freed before <strong>bio</strong>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bio_clone_fast">
struct bio * <code class="descname">bio_clone_fast</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct bio_set *<em>&nbsp;bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_clone_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a bio that shares the original bio’s biovec</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to clone</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>bio_set to allocate from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Like __bio_clone_fast, only also allocates the returned bio</div></blockquote>
<dl class="function">
<dt id="c.bio_clone_bioset">
struct bio * <code class="descname">bio_clone_bioset</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio_src</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct bio_set *<em>&nbsp;bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_clone_bioset" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio_src</span></code></dt>
<dd>bio to clone</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>bio_set to allocate from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Clone bio. Caller will own the returned bio, but not the actual data it
points to. Reference count of returned bio will be one.</div></blockquote>
<dl class="function">
<dt id="c.bio_add_pc_page">
int <code class="descname">bio_add_pc_page</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;len</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_add_pc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to add page to bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the target queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page to add</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>vec entry length</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>vec entry offset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Attempt to add a page to the bio_vec maplist. This can fail for a
number of reasons, such as the bio being full or target block device
limitations. The target block device must allow bio’s up to PAGE_SIZE,
so it is always possible to add a single page to an empty bio.</p>
<p>This should only be used by REQ_PC bios.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bio_add_page">
int <code class="descname">bio_add_page</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;len</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_add_page" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to add page to bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page to add</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>vec entry length</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>vec entry offset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Attempt to add a page to the bio_vec maplist. This will only fail
if either bio-&gt;bi_vcnt == bio-&gt;bi_max_vecs or it’s a cloned bio.</div></blockquote>
<dl class="function">
<dt id="c.bio_iov_iter_get_pages">
int <code class="descname">bio_iov_iter_get_pages</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct iov_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_iov_iter_get_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>pin user or kernel pages and add them to a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to add pages to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>iov iterator describing the region to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pins as many pages from <em>iter and appends them to **bio*</em>’s bvec array. The
pages will have to be released using <code class="xref c c-func docutils literal"><span class="pre">put_page()</span></code> when done.</p>
<dl class="function">
<dt id="c.submit_bio_wait">
int <code class="descname">submit_bio_wait</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>submit a bio, and wait until it completes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> which describes the I/O</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple wrapper around <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code></a>. Returns 0 on success, or the error from
<a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal"><span class="pre">bio_endio()</span></code></a> on failure.</p>
<p>WARNING: Unlike to how <a class="reference internal" href="../core-api/kernel-api.html#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code></a> is usually used, this function does not
result in bio reference to be consumed. The caller must drop the reference
on his own.</p>
<dl class="function">
<dt id="c.bio_advance">
void <code class="descname">bio_advance</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, unsigned<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_advance" title="Permalink to this definition">¶</a></dt>
<dd><p>increment/complete a bio by some number of bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to advance</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">bytes</span></code></dt>
<dd>number of bytes to complete</dd>
</dl>
<p><strong>Description</strong></p>
<p>This updates bi_sector, bi_size and bi_idx; if the number of bytes to
complete doesn’t align with a bvec boundary, then bv_len and bv_offset will
be updated on the last bvec as well.</p>
<p><strong>bio</strong> will then represent the remaining, uncompleted portion of the io.</p>
<dl class="function">
<dt id="c.bio_alloc_pages">
int <code class="descname">bio_alloc_pages</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_alloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocates a single page for each bvec in a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to allocate pages for</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>flags for allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates pages up to <strong>bio</strong>-&gt;bi_vcnt.</p>
<p>Returns 0 on success, -ENOMEM on failure. On failure, any allocated pages are
freed.</p>
<dl class="function">
<dt id="c.bio_copy_data">
void <code class="descname">bio_copy_data</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;dst</em>, struct bio *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_copy_data" title="Permalink to this definition">¶</a></dt>
<dd><p>copy contents of data buffers from one chain of bios to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bio list</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bio list</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>src</strong> and <strong>dst</strong> are single bios, bi_next must be NULL - otherwise, treats
<strong>src</strong> and <strong>dst</strong> as linked lists of bios.</p>
<p>Stops when it reaches the end of either <strong>src</strong> or <strong>dst</strong> - that is, copies
min(src-&gt;bi_size, dst-&gt;bi_size) bytes (or the equivalent for lists of bios).</p>
<dl class="function">
<dt id="c.bio_map_kern">
struct bio * <code class="descname">bio_map_kern</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, void *<em>&nbsp;data</em>, unsigned int<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_map_kern" title="Permalink to this definition">¶</a></dt>
<dd><p>map kernel address into bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the struct request_queue for the bio</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to buffer to map</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length in bytes</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation flags for bio allocation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Map the kernel address into a bio suitable for io to a block
device. Returns an error pointer in case of error.</div></blockquote>
<dl class="function">
<dt id="c.bio_endio">
void <code class="descname">bio_endio</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_endio" title="Permalink to this definition">¶</a></dt>
<dd><p>end I/O on a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal"><span class="pre">bio_endio()</span></code></a> will end I/O on the whole bio. <a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal"><span class="pre">bio_endio()</span></code></a> is the preferred
way to end I/O on a bio. No one should call <code class="xref c c-func docutils literal"><span class="pre">bi_end_io()</span></code> directly on a
bio unless they own it and thus know that it has an end_io function.</p>
<p><a class="reference internal" href="#c.bio_endio" title="bio_endio"><code class="xref c c-func docutils literal"><span class="pre">bio_endio()</span></code></a> can be called several times on a bio that has been chained
using <a class="reference internal" href="#c.bio_chain" title="bio_chain"><code class="xref c c-func docutils literal"><span class="pre">bio_chain()</span></code></a>.  The -&gt;:c:func:<cite>bi_end_io()</cite> function will only be called the
last time.  At this point the BLK_TA_COMPLETE tracing event will be
generated if BIO_TRACE_COMPLETION is set.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bio_split">
struct bio * <code class="descname">bio_split</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, int<em>&nbsp;sectors</em>, gfp_t<em>&nbsp;gfp</em>, struct bio_set *<em>&nbsp;bs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_split" title="Permalink to this definition">¶</a></dt>
<dd><p>split a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to split</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sectors</span></code></dt>
<dd>number of sectors to split from the front of <strong>bio</strong></dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>gfp mask</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>bio set to allocate from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a new bio which represents <strong>sectors</strong> from the start of
<strong>bio</strong>, and updates <strong>bio</strong> to represent the remaining sectors.</p>
<p>Unless this is a discard request the newly allocated bio will point
to <strong>bio</strong>’s bi_io_vec; it is the caller’s responsibility to ensure that
<strong>bio</strong> is not freed before the split.</p>
<dl class="function">
<dt id="c.bio_trim">
void <code class="descname">bio_trim</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, int<em>&nbsp;offset</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>trim a bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to trim</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>number of sectors to trim from the front of <strong>bio</strong></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>size we want to trim <strong>bio</strong> to, in sectors</dd>
</dl>
<dl class="function">
<dt id="c.bioset_create">
struct bio_set * <code class="descname">bioset_create</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;pool_size</em>, unsigned int<em>&nbsp;front_pad</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bioset_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bio_set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pool_size</span></code></dt>
<dd>Number of bio and bio_vecs to cache in the mempool</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">front_pad</span></code></dt>
<dd>Number of bytes to allocate in front of the returned bio</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Flags to modify behavior, currently <code class="docutils literal"><span class="pre">BIOSET_NEED_BVECS</span></code>
and <code class="docutils literal"><span class="pre">BIOSET_NEED_RESCUER</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Set up a bio_set to be used with <strong>bio_alloc_bioset</strong>. Allows the caller
to ask for a number of bytes to be allocated in front of the bio.
Front pad allocation is useful for embedding the bio inside
another structure, to avoid allocating extra data to go with the bio.
Note that the bio must be embedded at the END of that structure always,
or things will break badly.
If <code class="docutils literal"><span class="pre">BIOSET_NEED_BVECS</span></code> is set in <strong>flags</strong>, a separate pool will be allocated
for allocating iovecs.  This pool is not needed e.g. for <a class="reference internal" href="#c.bio_clone_fast" title="bio_clone_fast"><code class="xref c c-func docutils literal"><span class="pre">bio_clone_fast()</span></code></a>.
If <code class="docutils literal"><span class="pre">BIOSET_NEED_RESCUER</span></code> is set, a workqueue is created which can be used to
dispatch queued requests when the mempool runs out of space.</div></blockquote>
<dl class="function">
<dt id="c.bio_associate_blkcg">
int <code class="descname">bio_associate_blkcg</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em>, struct cgroup_subsys_state *<em>&nbsp;blkcg_css</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_associate_blkcg" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a bio with the specified blkcg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>target bio</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*</span> <span class="pre">blkcg_css</span></code></dt>
<dd>css of the blkcg to associate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Associate <strong>bio</strong> with the blkcg specified by <strong>blkcg_css</strong>.  Block layer will
treat <strong>bio</strong> as if it were issued by a task which belongs to the blkcg.</p>
<p>This function takes an extra reference of <strong>blkcg_css</strong> which will be put
when <strong>bio</strong> is released.  The caller must own <strong>bio</strong> and is responsible for
synchronizing calls to this function.</p>
<dl class="function">
<dt id="c.bio_associate_current">
int <code class="descname">bio_associate_current</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_associate_current" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a bio with <code class="docutils literal"><span class="pre">current</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>target bio</dd>
</dl>
<p><strong>Description</strong></p>
<p>Associate <strong>bio</strong> with <code class="docutils literal"><span class="pre">current</span></code> if it hasn’t been associated yet.  Block
layer will treat <strong>bio</strong> as if it were issued by <code class="docutils literal"><span class="pre">current</span></code> no matter which
task actually issues it.</p>
<p>This function takes an extra reference of <strong>task</strong>’s io_context and blkcg
which will be put when <strong>bio</strong> is released.  The caller must own <strong>bio</strong>,
ensure <code class="docutils literal"><span class="pre">current-</span></code>&gt;io_context exists, and is responsible for synchronizing
calls to this function.</p>
<dl class="function">
<dt id="c.bio_clone_blkcg_association">
void <code class="descname">bio_clone_blkcg_association</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;dst</em>, struct bio *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bio_clone_blkcg_association" title="Permalink to this definition">¶</a></dt>
<dd><p>clone blkcg association from src to dst bio</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bio</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bio</dd>
</dl>
<dl class="function">
<dt id="c.seq_open">
int <code class="descname">seq_open</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, const struct seq_operations *<em>&nbsp;op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_open" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize sequential file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file we initialize</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">seq_operations</span> <span class="pre">*</span> <span class="pre">op</span></code></dt>
<dd>method table describing the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.seq_open" title="seq_open"><code class="xref c c-func docutils literal"><span class="pre">seq_open()</span></code></a> sets <strong>file</strong>, associating it with a sequence described
by <strong>op</strong>.  <strong>op</strong>-&gt;:c:func:<cite>start()</cite> sets the iterator up and returns the first
element of sequence. <strong>op</strong>-&gt;:c:func:<cite>stop()</cite> shuts it down.  <strong>op</strong>-&gt;:c:func:<cite>next()</cite>
returns the next element of sequence.  <strong>op</strong>-&gt;:c:func:<cite>show()</cite> prints element
into the buffer.  In case of error -&gt;:c:func:<cite>start()</cite> and -&gt;:c:func:<cite>next()</cite> return
ERR_PTR(error).  In the end of sequence they return <code class="docutils literal"><span class="pre">NULL</span></code>. -&gt;:c:func:<cite>show()</cite>
returns 0 in case of success and negative number in case of error.
Returning SEQ_SKIP means “discard this element and move on”.</div></blockquote>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt><a class="reference internal" href="#c.seq_open" title="seq_open"><code class="xref c c-func docutils literal"><span class="pre">seq_open()</span></code></a> will allocate a struct seq_file and store its</dt>
<dd>pointer in <strong>file</strong>-&gt;private_data. This pointer should not be modified.</dd>
</dl>
<dl class="function">
<dt id="c.seq_read">
ssize_t <code class="descname">seq_read</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, char __user *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>-&gt;:c:func:<cite>read()</cite> method for sequential files.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>the file to read from</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to read to</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the maximum number of bytes to read</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position in the file</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ready-made -&gt;f_op-&gt;:c:func:<cite>read()</cite></div></blockquote>
<dl class="function">
<dt id="c.seq_lseek">
loff_t <code class="descname">seq_lseek</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;offset</em>, int<em>&nbsp;whence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_lseek" title="Permalink to this definition">¶</a></dt>
<dd><p>-&gt;:c:func:<cite>llseek()</cite> method for sequential files.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>the file in question</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt>
<dd>new position</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">whence</span></code></dt>
<dd>0 for absolute, 1 for relative position</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ready-made -&gt;f_op-&gt;:c:func:<cite>llseek()</cite></div></blockquote>
<dl class="function">
<dt id="c.seq_release">
int <code class="descname">seq_release</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_release" title="Permalink to this definition">¶</a></dt>
<dd><p>free the structures associated with sequential file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>its inode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Frees the structures associated with sequential file; can be used
as -&gt;f_op-&gt;:c:func:<cite>release()</cite> if you don’t have private data to destroy.</div></blockquote>
<dl class="function">
<dt id="c.seq_escape">
void <code class="descname">seq_escape</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, const char *<em>&nbsp;s</em>, const char *<em>&nbsp;esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_escape" title="Permalink to this definition">¶</a></dt>
<dd><p>print string into buffer, escaping some characters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>target buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">esc</span></code></dt>
<dd>set of characters that need escaping</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Puts string into buffer, replacing each occurrence of character from
<strong>esc</strong> with usual octal escape.
Use <code class="xref c c-func docutils literal"><span class="pre">seq_has_overflowed()</span></code> to check for errors.</div></blockquote>
<dl class="function">
<dt id="c.mangle_path">
char * <code class="descname">mangle_path</code><span class="sig-paren">(</span>char *<em>&nbsp;s</em>, const char *<em>&nbsp;p</em>, const char *<em>&nbsp;esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mangle_path" title="Permalink to this definition">¶</a></dt>
<dd><p>mangle and copy path to buffer beginning</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>buffer start</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>beginning of path in above buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">esc</span></code></dt>
<dd>set of characters that need escaping</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Copy the path from <strong>p</strong> to <strong>s</strong>, replacing each occurrence of character from
<strong>esc</strong> with usual octal escape.
Returns pointer past last written character in <strong>s</strong>, or NULL in case of
failure.</div></blockquote>
<dl class="function">
<dt id="c.seq_path">
int <code class="descname">seq_path</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, const struct path *<em>&nbsp;path</em>, const char *<em>&nbsp;esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_path" title="Permalink to this definition">¶</a></dt>
<dd><p>seq_file interface to print a pathname</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>the seq_file handle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">path</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>the struct path to print</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">esc</span></code></dt>
<dd>set of characters to escape in the output</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the absolute path of ‘path’, as represented by the
dentry / mnt pair in the path parameter.</p>
<dl class="function">
<dt id="c.seq_file_path">
int <code class="descname">seq_file_path</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, struct file *<em>&nbsp;file</em>, const char *<em>&nbsp;esc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_file_path" title="Permalink to this definition">¶</a></dt>
<dd><p>seq_file interface to print a pathname of a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>the seq_file handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>the struct file to print</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">esc</span></code></dt>
<dd>set of characters to escape in the output</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the absolute path to the file.</p>
<dl class="function">
<dt id="c.seq_write">
int <code class="descname">seq_write</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;seq</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_write" title="Permalink to this definition">¶</a></dt>
<dd><p>write arbitrary data to buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">seq</span></code></dt>
<dd>seq_file identifying the buffer to which data should be written</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data address</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, non-zero otherwise.</p>
<dl class="function">
<dt id="c.seq_pad">
void <code class="descname">seq_pad</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;m</em>, char<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>write padding spaces to buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>seq_file identifying the buffer to which data should be written</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">c</span></code></dt>
<dd>the byte to append after padding if non-zero</dd>
</dl>
<dl class="function">
<dt id="c.seq_hlist_start">
struct hlist_node * <code class="descname">seq_hlist_start</code><span class="sig-paren">(</span>struct hlist_head *<em>&nbsp;head</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>the start position of the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;:c:func:<cite>start()</cite>.</p>
<dl class="function">
<dt id="c.seq_hlist_start_head">
struct hlist_node * <code class="descname">seq_hlist_start_head</code><span class="sig-paren">(</span>struct hlist_head *<em>&nbsp;head</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_head" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>the start position of the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;:c:func:<cite>start()</cite>. Call this function if you want to
print a header at the top of the output.</p>
<dl class="function">
<dt id="c.seq_hlist_next">
struct hlist_node * <code class="descname">seq_hlist_next</code><span class="sig-paren">(</span>void *<em>&nbsp;v</em>, struct hlist_head *<em>&nbsp;head</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the hlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>the current iterator</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;:c:func:<cite>next()</cite>.</p>
<dl class="function">
<dt id="c.seq_hlist_start_rcu">
struct hlist_node * <code class="descname">seq_hlist_start_rcu</code><span class="sig-paren">(</span>struct hlist_head *<em>&nbsp;head</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist protected by RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>the start position of the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;:c:func:<cite>start()</cite>.</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.seq_hlist_start_head_rcu">
struct hlist_node * <code class="descname">seq_hlist_start_head_rcu</code><span class="sig-paren">(</span>struct hlist_head *<em>&nbsp;head</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a hlist protected by RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>the start position of the sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;:c:func:<cite>start()</cite>. Call this function if you want to
print a header at the top of the output.</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.seq_hlist_next_rcu">
struct hlist_node * <code class="descname">seq_hlist_next_rcu</code><span class="sig-paren">(</span>void *<em>&nbsp;v</em>, struct hlist_head *<em>&nbsp;head</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the hlist protected by RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>the current iterator</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the hlist</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;:c:func:<cite>next()</cite>.</p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="../core-api/kernel-api.html#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.seq_hlist_start_percpu">
struct hlist_node * <code class="descname">seq_hlist_start_percpu</code><span class="sig-paren">(</span>struct hlist_head __percpu *<em>&nbsp;head</em>, int *<em>&nbsp;cpu</em>, loff_t<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_start_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>start an iteration of a percpu hlist array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to percpu array of struct hlist_heads</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">cpu</span></code></dt>
<dd>pointer to cpu “cursor”</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>start position of sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;:c:func:<cite>start()</cite>.</p>
<dl class="function">
<dt id="c.seq_hlist_next_percpu">
struct hlist_node * <code class="descname">seq_hlist_next_percpu</code><span class="sig-paren">(</span>void *<em>&nbsp;v</em>, struct hlist_head __percpu *<em>&nbsp;head</em>, int *<em>&nbsp;cpu</em>, loff_t *<em>&nbsp;pos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.seq_hlist_next_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>move to the next position of the percpu hlist array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer to current hlist_node</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to percpu array of struct hlist_heads</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">cpu</span></code></dt>
<dd>pointer to cpu “cursor”</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">pos</span></code></dt>
<dd>start position of sequence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called at seq_file-&gt;op-&gt;:c:func:<cite>next()</cite>.</p>
<dl class="function">
<dt id="c.register_filesystem">
int <code class="descname">register_filesystem</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;fs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_filesystem" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">fs</span></code></dt>
<dd>the file system structure</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Adds the file system passed to the list of file systems the kernel
is aware of for mount and other syscalls. Returns 0 on success,
or a negative errno code on an error.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> that is passed is linked into the kernel
structures and must not be freed until the file system has been
unregistered.</p>
</div></blockquote>
<dl class="function">
<dt id="c.unregister_filesystem">
int <code class="descname">unregister_filesystem</code><span class="sig-paren">(</span>struct file_system_type *<em>&nbsp;fs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_filesystem" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a file system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span> <span class="pre">*</span> <span class="pre">fs</span></code></dt>
<dd>filesystem to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a file system that was previously successfully registered
with the kernel. An error is returned if the file system is not found.
Zero is returned on a success.</p>
<p>Once this function has returned the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> structure
may be freed or reused.</p>
</div></blockquote>
<dl class="function">
<dt id="c.wbc_account_io">
void <code class="descname">wbc_account_io</code><span class="sig-paren">(</span>struct writeback_control *<em>&nbsp;wbc</em>, struct page *<em>&nbsp;page</em>, size_t<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wbc_account_io" title="Permalink to this definition">¶</a></dt>
<dd><p>account IO issued during writeback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>writeback_control of the writeback in progress</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page being written out</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">bytes</span></code></dt>
<dd>number of bytes being written out</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>bytes</strong> from <strong>page</strong> are about to written out during the writeback
controlled by <strong>wbc</strong>.  Keep the book for foreign inode detection.  See
<code class="xref c c-func docutils literal"><span class="pre">wbc_detach_inode()</span></code>.</p>
<dl class="function">
<dt id="c.inode_congested">
int <code class="descname">inode_congested</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;cong_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inode_congested" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether an inode is congested</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to test for congestion (may be NULL)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cong_bits</span></code></dt>
<dd>mask of WB_[a]sync_congested bits to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tests whether <strong>inode</strong> is congested.  <strong>cong_bits</strong> is the mask of congestion
bits to test and the return value is the mask of set bits.</p>
<p>If cgroup writeback is enabled for <strong>inode</strong>, the congestion state is
determined by whether the cgwb (cgroup bdi_writeback) for the blkcg
associated with <strong>inode</strong> is congested; otherwise, the root wb’s congestion
state is used.</p>
<p><strong>inode</strong> is allowed to be NULL as this function is often called on
mapping-&gt;host which is NULL for the swapper space.</p>
<dl class="function">
<dt id="c.__mark_inode_dirty">
void <code class="descname">__mark_inode_dirty</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mark_inode_dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>internal function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to mark</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>what kind of dirty (i.e. I_DIRTY_SYNC)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark an inode as dirty. Callers should use mark_inode_dirty or
mark_inode_dirty_sync.</p>
<p>Put the inode on the super block’s dirty list.</p>
<p>CAREFUL! We mark it dirty unconditionally, but move it onto the
dirty list only if it is hashed or if it refers to a blockdev.
If it was not hashed, it will never be added to the dirty list
even if it is later hashed, as it will have been marked dirty already.</p>
<p>In short, make sure you hash any inodes _before_ you start marking
them dirty.</p>
<p>Note that for blockdevs, inode-&gt;dirtied_when represents the dirtying time of
the block-special inode (/dev/hda1) itself.  And the -&gt;dirtied_when field of
the kernel-internal blockdev inode represents the dirtying time of the
blockdev’s pages.  This is why for I_DIRTY_PAGES we always use
page-&gt;mapping-&gt;host, so the page-dirtying time is recorded in the internal
blockdev inode.</p>
<dl class="function">
<dt id="c.writeback_inodes_sb_nr">
void <code class="descname">writeback_inodes_sb_nr</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;nr</em>, enum wb_reason<em>&nbsp;reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.writeback_inodes_sb_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>writeback dirty inodes from given super_block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the number of pages to write</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt>
<dd>reason why some writeback work initiated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start writeback on some inodes on this super_block. No guarantees are made
on how many (if any) will be written, and this function does not wait
for IO completion of submitted IO.</p>
<dl class="function">
<dt id="c.writeback_inodes_sb">
void <code class="descname">writeback_inodes_sb</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, enum wb_reason<em>&nbsp;reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.writeback_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>writeback dirty inodes from given super_block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt>
<dd>reason why some writeback work was initiated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start writeback on some inodes on this super_block. No guarantees are made
on how many (if any) will be written, and this function does not wait
for IO completion of submitted IO.</p>
<dl class="function">
<dt id="c.try_to_writeback_inodes_sb_nr">
bool <code class="descname">try_to_writeback_inodes_sb_nr</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, unsigned long<em>&nbsp;nr</em>, enum wb_reason<em>&nbsp;reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_writeback_inodes_sb_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>try to start writeback if none underway</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the number of pages to write</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt>
<dd>the reason of writeback</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoke writeback_inodes_sb_nr if no writeback is currently underway.
Returns 1 if writeback was started, 0 if not.</p>
<dl class="function">
<dt id="c.try_to_writeback_inodes_sb">
bool <code class="descname">try_to_writeback_inodes_sb</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em>, enum wb_reason<em>&nbsp;reason</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_writeback_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>try to start writeback if none underway</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">wb_reason</span> <span class="pre">reason</span></code></dt>
<dd>reason why some writeback work was initiated</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implement by <a class="reference internal" href="#c.try_to_writeback_inodes_sb_nr" title="try_to_writeback_inodes_sb_nr"><code class="xref c c-func docutils literal"><span class="pre">try_to_writeback_inodes_sb_nr()</span></code></a>
Returns 1 if writeback was started, 0 if not.</p>
<dl class="function">
<dt id="c.sync_inodes_sb">
void <code class="descname">sync_inodes_sb</code><span class="sig-paren">(</span>struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_inodes_sb" title="Permalink to this definition">¶</a></dt>
<dd><p>sync sb inode pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>the superblock</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function writes and waits on any dirty inode belonging to this
super_block.</p>
<dl class="function">
<dt id="c.write_inode_now">
int <code class="descname">write_inode_now</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_inode_now" title="Permalink to this definition">¶</a></dt>
<dd><p>write an inode to disk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode to write to disk</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sync</span></code></dt>
<dd>whether the write should be synchronous or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function commits an inode to disk immediately if it is dirty. This is
primarily needed by knfsd.</p>
<p>The caller must either have a ref on the inode or must have set I_WILL_FREE.</p>
<dl class="function">
<dt id="c.sync_inode">
int <code class="descname">sync_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct writeback_control *<em>&nbsp;wbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>write an inode and its pages to disk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode to sync</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>controls the writeback mode</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.sync_inode" title="sync_inode"><code class="xref c c-func docutils literal"><span class="pre">sync_inode()</span></code></a> will write an inode and its pages to disk.  It will also
correctly update the inode on its superblock’s dirty inode lists and will
update inode-&gt;i_state.</p>
<p>The caller must have a ref on the inode.</p>
<dl class="function">
<dt id="c.sync_inode_metadata">
int <code class="descname">sync_inode_metadata</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, int<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sync_inode_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>write an inode to disk</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode to sync</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">wait</span></code></dt>
<dd>wait for I/O to complete.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write an inode to disk and adjust its dirty state after completion.</p>
<p><strong>Note</strong></p>
<p>only writes the actual inode, no associated data or other metadata.</p>
<dl class="function">
<dt id="c.freeze_bdev">
struct super_block * <code class="descname">freeze_bdev</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.freeze_bdev" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>lock a filesystem and force it into a consistent state</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdevice to lock</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a superblock is found on this device, we take the s_umount semaphore
on it to make sure nobody unmounts until the snapshot creation is done.
The reference counter (bd_fsfreeze_count) guarantees that only the last
unfreeze process can unfreeze the frozen filesystem actually when multiple
freeze requests arrive simultaneously. It counts up in <a class="reference internal" href="#c.freeze_bdev" title="freeze_bdev"><code class="xref c c-func docutils literal"><span class="pre">freeze_bdev()</span></code></a> and
count down in <a class="reference internal" href="#c.thaw_bdev" title="thaw_bdev"><code class="xref c c-func docutils literal"><span class="pre">thaw_bdev()</span></code></a>. When it becomes 0, <a class="reference internal" href="#c.thaw_bdev" title="thaw_bdev"><code class="xref c c-func docutils literal"><span class="pre">thaw_bdev()</span></code></a> will unfreeze
actually.</p>
<dl class="function">
<dt id="c.thaw_bdev">
int <code class="descname">thaw_bdev</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct super_block *<em>&nbsp;sb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.thaw_bdev" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>unlock filesystem</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdevice to unlock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span> <span class="pre">*</span> <span class="pre">sb</span></code></dt>
<dd>associated superblock</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the filesystem and marks it writeable again after <a class="reference internal" href="#c.freeze_bdev" title="freeze_bdev"><code class="xref c c-func docutils literal"><span class="pre">freeze_bdev()</span></code></a>.</p>
<dl class="function">
<dt id="c.bdev_read_page">
int <code class="descname">bdev_read_page</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdev_read_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Start reading a page from a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>The device to read the page from</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>The offset on the device to read the page to (need not be aligned)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>On entry, the page should be locked.  It will be unlocked when the page
has been read.  If the block driver implements rw_page synchronously,
that will be true on exit from this function, but it need not be.</p>
<p>Errors returned by this function are usually “soft”, eg out of memory, or
queue full; callers should try a different route to read this page rather
than propagate an error back up the stack.</p>
<p><strong>Return</strong></p>
<p>negative errno if an error occurs, 0 if submission was successful.</p>
<dl class="function">
<dt id="c.bdev_write_page">
int <code class="descname">bdev_write_page</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, struct page *<em>&nbsp;page</em>, struct writeback_control *<em>&nbsp;wbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdev_write_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Start writing a page to a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>The device to write the page to</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>The offset on the device to write the page to (need not be aligned)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page to write</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>The writeback_control for the write</dd>
</dl>
<p><strong>Description</strong></p>
<p>On entry, the page should be locked and not currently under writeback.
On exit, if the write started successfully, the page will be unlocked and
under writeback.  If the write failed already (eg the driver failed to
queue the page to the device), the page will still be locked.  If the
caller is a -&gt;writepage implementation, it will need to unlock the page.</p>
<p>Errors returned by this function are usually “soft”, eg out of memory, or
queue full; callers should try a different route to write this page rather
than propagate an error back up the stack.</p>
<p><strong>Return</strong></p>
<p>negative errno if an error occurs, 0 if submission was successful.</p>
<dl class="function">
<dt id="c.bdgrab">
struct block_device * <code class="descname">bdgrab</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdgrab" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Grab a reference to an already referenced block device</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>Block device to grab a reference to.</dd>
</dl>
<dl class="function">
<dt id="c.bd_link_disk_holder">
int <code class="descname">bd_link_disk_holder</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_link_disk_holder" title="Permalink to this definition">¶</a></dt>
<dd><p>create symlinks between holding disk and slave bdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the claimed slave bdev</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>the holding disk</dd>
</dl>
<p><strong>Description</strong></p>
<p>DON’T USE THIS UNLESS YOU’RE ALREADY USING IT.</p>
<p>This functions creates the following sysfs symlinks.</p>
<ul class="simple">
<li>from “slaves” directory of the holder <strong>disk</strong> to the claimed <strong>bdev</strong></li>
<li>from “holders” directory of the <strong>bdev</strong> to the holder <strong>disk</strong></li>
</ul>
<p>For example, if /dev/dm-0 maps to /dev/sda and disk for dm-0 is
passed to <a class="reference internal" href="#c.bd_link_disk_holder" title="bd_link_disk_holder"><code class="xref c c-func docutils literal"><span class="pre">bd_link_disk_holder()</span></code></a>, then:</p>
<blockquote>
<div>/sys/block/dm-0/slaves/sda –&gt; /sys/block/sda
/sys/block/sda/holders/dm-0 –&gt; /sys/block/dm-0</div></blockquote>
<p>The caller must have claimed <strong>bdev</strong> before calling this function and
ensure that both <strong>bdev</strong> and <strong>disk</strong> are valid during the creation and
lifetime of these symlinks.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.bd_unlink_disk_holder">
void <code class="descname">bd_unlink_disk_holder</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bd_unlink_disk_holder" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy symlinks created by <a class="reference internal" href="#c.bd_link_disk_holder" title="bd_link_disk_holder"><code class="xref c c-func docutils literal"><span class="pre">bd_link_disk_holder()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the calimed slave bdev</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>the holding disk</dd>
</dl>
<p><strong>Description</strong></p>
<p>DON’T USE THIS UNLESS YOU’RE ALREADY USING IT.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.check_disk_size_change">
void <code class="descname">check_disk_size_change</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct block_device *<em>&nbsp;bdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_disk_size_change" title="Permalink to this definition">¶</a></dt>
<dd><p>checks for disk size change and adjusts bdev size.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>struct gendisk to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>struct bdev to adjust.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine checks to see if the bdev size does not match the disk size
and adjusts it if it differs.</p>
<dl class="function">
<dt id="c.revalidate_disk">
int <code class="descname">revalidate_disk</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.revalidate_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>wrapper for lower-level driver’s revalidate_disk call-back</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>struct gendisk to be revalidated</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is a wrapper for lower-level driver’s revalidate_disk
call-backs.  It is used to do common pre and post operations needed
for all revalidate_disk operations.</p>
<dl class="function">
<dt id="c.blkdev_get">
int <code class="descname">blkdev_get</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, fmode_t<em>&nbsp;mode</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_get" title="Permalink to this definition">¶</a></dt>
<dd><p>open a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>block_device to open</dd>
<dt><code class="docutils literal"><span class="pre">fmode_t</span> <span class="pre">mode</span></code></dt>
<dd>FMODE_* mask</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>exclusive holder identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open <strong>bdev</strong> with <strong>mode</strong>.  If <strong>mode</strong> includes <code class="docutils literal"><span class="pre">FMODE_EXCL</span></code>, <strong>bdev</strong> is
open with exclusive access.  Specifying <code class="docutils literal"><span class="pre">FMODE_EXCL</span></code> with <code class="docutils literal"><span class="pre">NULL</span></code>
<strong>holder</strong> is invalid.  Exclusive opens may nest for the same <strong>holder</strong>.</p>
<p>On success, the reference count of <strong>bdev</strong> is unchanged.  On failure,
<strong>bdev</strong> is put.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.blkdev_get_by_path">
struct block_device * <code class="descname">blkdev_get_by_path</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, fmode_t<em>&nbsp;mode</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_get_by_path" title="Permalink to this definition">¶</a></dt>
<dd><p>open a block device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to the block device to open</dd>
<dt><code class="docutils literal"><span class="pre">fmode_t</span> <span class="pre">mode</span></code></dt>
<dd>FMODE_* mask</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>exclusive holder identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open the blockdevice described by the device file at <strong>path</strong>.  <strong>mode</strong>
and <strong>holder</strong> are identical to <a class="reference internal" href="#c.blkdev_get" title="blkdev_get"><code class="xref c c-func docutils literal"><span class="pre">blkdev_get()</span></code></a>.</p>
<p>On success, the returned block_device has reference count of one.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>Pointer to block_device on success, ERR_PTR(-errno) on failure.</p>
<dl class="function">
<dt id="c.blkdev_get_by_dev">
struct block_device * <code class="descname">blkdev_get_by_dev</code><span class="sig-paren">(</span>dev_t<em>&nbsp;dev</em>, fmode_t<em>&nbsp;mode</em>, void *<em>&nbsp;holder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_get_by_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>open a block device by device number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>device number of block device to open</dd>
<dt><code class="docutils literal"><span class="pre">fmode_t</span> <span class="pre">mode</span></code></dt>
<dd>FMODE_* mask</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">holder</span></code></dt>
<dd>exclusive holder identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open the blockdevice described by device number <strong>dev</strong>.  <strong>mode</strong> and
<strong>holder</strong> are identical to <a class="reference internal" href="#c.blkdev_get" title="blkdev_get"><code class="xref c c-func docutils literal"><span class="pre">blkdev_get()</span></code></a>.</p>
<p>Use it ONLY if you really do not have anything better - i.e. when
you are behind a truly sucky interface and all you are given is a
device number.  _Never_ to be used for internal purposes.  If you
ever need it - reconsider your API.</p>
<p>On success, the returned block_device has reference count of one.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<p><strong>Return</strong></p>
<p>Pointer to block_device on success, ERR_PTR(-errno) on failure.</p>
<dl class="function">
<dt id="c.lookup_bdev">
struct block_device * <code class="descname">lookup_bdev</code><span class="sig-paren">(</span>const char *<em>&nbsp;pathname</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_bdev" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup a struct block_device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pathname</span></code></dt>
<dd>special file representing the block device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a reference to the blockdevice at <strong>pathname</strong> in the current
namespace if possible and return it.  Return ERR_PTR(error)
otherwise.</p>
</div>
</div>
<div class="section" id="the-proc-filesystem">
<h2>The proc filesystem<a class="headerlink" href="#the-proc-filesystem" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sysctl-interface">
<h3>sysctl interface<a class="headerlink" href="#sysctl-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.proc_dostring">
int <code class="descname">proc_dostring</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dostring" title="Permalink to this definition">¶</a></dt>
<dd><p>read a string sysctl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes a string from/to the user buffer. If the kernel
buffer provided is not large enough to hold the string, the
string is truncated. The copied string is <code class="docutils literal"><span class="pre">NULL-terminated</span></code>.
If the string is being read by the user process, it is copied
and a newline ‘n’ is added. It is truncated if the buffer is
not large enough.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec">
int <code class="descname">proc_dointvec</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_douintvec">
int <code class="descname">proc_douintvec</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_douintvec" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of unsigned integers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) unsigned integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec_minmax">
int <code class="descname">proc_dointvec_minmax</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers with min/max values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_douintvec_minmax">
int <code class="descname">proc_douintvec_minmax</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_douintvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of unsigned ints with min/max values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) unsigned integer
values from/to the user buffer, treated as an ASCII string. Negative
strings are not allowed.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max). There is a final sanity
check for UINT_MAX to avoid having to support wrap around uses from
userspace.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_doulongvec_minmax">
int <code class="descname">proc_doulongvec_minmax</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_doulongvec_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of long integers with min/max values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_doulongvec_ms_jiffies_minmax">
int <code class="descname">proc_doulongvec_ms_jiffies_minmax</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_doulongvec_ms_jiffies_minmax" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of millisecond values with min/max values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned long) unsigned long
values from/to the user buffer, treated as an ASCII string. The values
are treated as milliseconds, and converted to jiffies when they are stored.</p>
<p>This routine will ensure the values are within the range specified by
table-&gt;extra1 (min) and table-&gt;extra2 (max).</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec_jiffies">
int <code class="descname">proc_dointvec_jiffies</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as seconds</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in seconds, and are converted into
jiffies.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec_userhz_jiffies">
int <code class="descname">proc_dointvec_userhz_jiffies</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_userhz_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as 1/USER_HZ seconds</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>pointer to the file position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in 1/USER_HZ seconds, and
are converted into jiffies.</p>
<p>Returns 0 on success.</p>
<dl class="function">
<dt id="c.proc_dointvec_ms_jiffies">
int <code class="descname">proc_dointvec_ms_jiffies</code><span class="sig-paren">(</span>struct ctl_table *<em>&nbsp;table</em>, int<em>&nbsp;write</em>, void __user *<em>&nbsp;buffer</em>, size_t *<em>&nbsp;lenp</em>, loff_t *<em>&nbsp;ppos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_dointvec_ms_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>read a vector of integers as 1 milliseconds</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ctl_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>the sysctl table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd><code class="docutils literal"><span class="pre">TRUE</span></code> if this is a write to the sysctl file</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">lenp</span></code></dt>
<dd>the size of the user buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>the current position in the file</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) integer
values from/to the user buffer, treated as an ASCII string.
The values read are assumed to be in 1/1000 seconds, and
are converted into jiffies.</p>
<p>Returns 0 on success.</p>
</div>
<div class="section" id="proc-filesystem-interface">
<h3>proc filesystem interface<a class="headerlink" href="#proc-filesystem-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.proc_flush_task">
void <code class="descname">proc_flush_task</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.proc_flush_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove dcache entries for <strong>task</strong> from the /proc dcache.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task that should be flushed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>When flushing dentries from proc, one needs to flush them from global
proc (proc_mnt) and from all the namespaces’ procs this task was seen
in. This call is supposed to do all of this job.</p>
<p>Looks in the dcache for
/proc/<strong>pid</strong>
/proc/<strong>tgid</strong>/task/<strong>pid</strong>
if either directory is present flushes it and all of it’ts children
from the dcache.</p>
<p>It is safe and reasonable to cache /proc entries for a task until
that task exits.  After that they just clog up the dcache with
useless entries, possibly causing useful dcache entries to be
flushed instead.  This routine is proved to flush those useless
dcache entries at process exit time.</p>
<p><strong>NOTE</strong></p>
<dl class="docutils">
<dt>This routine is just an optimization so it does not guarantee</dt>
<dd>that no dcache entries will exist at process exit time it
just makes it very unlikely that any will persist.</dd>
</dl>
</div>
</div>
<div class="section" id="events-based-on-file-descriptors">
<h2>Events based on file descriptors<a class="headerlink" href="#events-based-on-file-descriptors" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.eventfd_signal">
__u64 <code class="descname">eventfd_signal</code><span class="sig-paren">(</span>struct eventfd_ctx *<em>&nbsp;ctx</em>, __u64<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <strong>n</strong> to the eventfd counter.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>[in] Pointer to the eventfd context.</dd>
<dt><code class="docutils literal"><span class="pre">__u64</span> <span class="pre">n</span></code></dt>
<dd>[in] Value of the counter to be added to the eventfd internal counter.
The value cannot be negative.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is supposed to be called by the kernel in paths that do not
allow sleeping. In this function we allow the counter to reach the ULLONG_MAX
value, and we signal this as overflow condition by returning a POLLERR
to poll(2).</p>
<p>Returns the amount by which the counter was incremented.  This will be less
than <strong>n</strong> if the counter has overflowed.</p>
<dl class="function">
<dt id="c.eventfd_ctx_get">
struct eventfd_ctx * <code class="descname">eventfd_ctx_get</code><span class="sig-paren">(</span>struct eventfd_ctx *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquires a reference to the internal eventfd context.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>[in] Pointer to the eventfd context.</dd>
</dl>
<p><strong>Return</strong></p>
<p>In case of success, returns a pointer to the eventfd context.</p>
<dl class="function">
<dt id="c.eventfd_ctx_put">
void <code class="descname">eventfd_ctx_put</code><span class="sig-paren">(</span>struct eventfd_ctx *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases a reference to the internal eventfd context.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>[in] Pointer to eventfd context.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The eventfd context reference must have been previously acquired either
with <a class="reference internal" href="#c.eventfd_ctx_get" title="eventfd_ctx_get"><code class="xref c c-func docutils literal"><span class="pre">eventfd_ctx_get()</span></code></a> or <a class="reference internal" href="#c.eventfd_ctx_fdget" title="eventfd_ctx_fdget"><code class="xref c c-func docutils literal"><span class="pre">eventfd_ctx_fdget()</span></code></a>.</p>
<dl class="function">
<dt id="c.eventfd_ctx_remove_wait_queue">
int <code class="descname">eventfd_ctx_remove_wait_queue</code><span class="sig-paren">(</span>struct eventfd_ctx *<em>&nbsp;ctx</em>, wait_queue_entry_t *<em>&nbsp;wait</em>, __u64 *<em>&nbsp;cnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_remove_wait_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the current counter and removes wait queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>[in] Pointer to eventfd context.</dd>
<dt><code class="docutils literal"><span class="pre">wait_queue_entry_t</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>[in] Wait queue to be removed.</dd>
<dt><code class="docutils literal"><span class="pre">__u64</span> <span class="pre">*</span> <span class="pre">cnt</span></code></dt>
<dd>[out] Pointer to the 64-bit counter value.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal"><span class="pre">0</span></code> if successful, or the following error codes:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>AGAIN</var></span></kbd></td>
<td>: The operation would have blocked.</td></tr>
</tbody>
</table>
<p>This is used to atomically remove a wait queue entry from the eventfd wait
queue head, and read/reset the counter value.</p>
<dl class="function">
<dt id="c.eventfd_ctx_read">
ssize_t <code class="descname">eventfd_ctx_read</code><span class="sig-paren">(</span>struct eventfd_ctx *<em>&nbsp;ctx</em>, int<em>&nbsp;no_wait</em>, __u64 *<em>&nbsp;cnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the eventfd counter or wait if it is zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">eventfd_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>[in] Pointer to eventfd context.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">no_wait</span></code></dt>
<dd>[in] Different from zero if the operation should not block.</dd>
<dt><code class="docutils literal"><span class="pre">__u64</span> <span class="pre">*</span> <span class="pre">cnt</span></code></dt>
<dd>[out] Pointer to the 64-bit counter value.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal"><span class="pre">0</span></code> if successful, or the following error codes:</p>
<blockquote>
<div><ul>
<li><table class="first docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>AGAIN</var></span></kbd></td>
<td><p class="first last">: The operation would have blocked but <strong>no_wait</strong> was non-zero.</p>
</td></tr>
</tbody>
</table>
</li>
<li><p class="first">-ERESTARTSYS : A signal interrupted the wait operation.</p>
</li>
</ul>
</div></blockquote>
<p>If <strong>no_wait</strong> is zero, the function might sleep until the eventfd internal
counter becomes greater than zero.</p>
<dl class="function">
<dt id="c.eventfd_fget">
struct file * <code class="descname">eventfd_fget</code><span class="sig-paren">(</span>int<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_fget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire a reference of an eventfd file descriptor.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>[in] Eventfd file descriptor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the eventfd file structure in case of success, or the
following error pointer:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>BADF</var></span></kbd></td>
<td>: Invalid <strong>fd</strong> file descriptor.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-E<var>INVAL</var></span></kbd></td>
<td>: The <strong>fd</strong> file descriptor is not an eventfd file.</td></tr>
</tbody>
</table>
<dl class="function">
<dt id="c.eventfd_ctx_fdget">
struct eventfd_ctx * <code class="descname">eventfd_ctx_fdget</code><span class="sig-paren">(</span>int<em>&nbsp;fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_fdget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquires a reference to the internal eventfd context.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>[in] Eventfd file descriptor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the internal eventfd context, otherwise the error
pointers returned by the following functions:</p>
<p>eventfd_fget</p>
<dl class="function">
<dt id="c.eventfd_ctx_fileget">
struct eventfd_ctx * <code class="descname">eventfd_ctx_fileget</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eventfd_ctx_fileget" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquires a reference to the internal eventfd context.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>[in] Eventfd file pointer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the internal eventfd context, otherwise the error
pointer:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-E<var>INVAL</var></span></kbd></td>
<td>: The <strong>fd</strong> file descriptor is not an eventfd file.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="the-filesystem-for-exporting-kernel-objects">
<h2>The Filesystem for Exporting Kernel Objects<a class="headerlink" href="#the-filesystem-for-exporting-kernel-objects" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.sysfs_create_file_ns">
int <code class="descname">sysfs_create_file_ns</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, const void *<em>&nbsp;ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_file_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>create an attribute file for an object with custom ns</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re creating for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>namespace the new file should belong to</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_add_file_to_group">
int <code class="descname">sysfs_add_file_to_group</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, const char *<em>&nbsp;group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_add_file_to_group" title="Permalink to this definition">¶</a></dt>
<dd><p>add an attribute file to a pre-existing group.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">group</span></code></dt>
<dd>group name.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_chmod_file">
int <code class="descname">sysfs_chmod_file</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, umode_t<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_chmod_file" title="Permalink to this definition">¶</a></dt>
<dd><p>update the modified mode value on an object attribute.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>file permissions.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_remove_file_ns">
void <code class="descname">sysfs_remove_file_ns</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, const void *<em>&nbsp;ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_file_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an object attribute with a custom ns tag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>namespace tag of the file to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hash the attribute name and namespace tag and kill the victim.</p>
<dl class="function">
<dt id="c.sysfs_remove_file_from_group">
void <code class="descname">sysfs_remove_file_from_group</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct attribute *<em>&nbsp;attr</em>, const char *<em>&nbsp;group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_file_from_group" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an attribute file from a group.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">group</span></code></dt>
<dd>group name.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_create_bin_file">
int <code class="descname">sysfs_create_bin_file</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct bin_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create binary file for object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_remove_bin_file">
void <code class="descname">sysfs_remove_bin_file</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const struct bin_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_bin_file" title="Permalink to this definition">¶</a></dt>
<dd><p>remove binary file for object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_create_link">
int <code class="descname">sysfs_create_link</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobject *<em>&nbsp;target</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_create_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create symlink between two objects.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object whose directory we’re creating the link in.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>object we’re pointing to.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the symlink.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_remove_link">
void <code class="descname">sysfs_remove_link</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_remove_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove symlink in object’s directory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the symlink to remove.</dd>
</dl>
<dl class="function">
<dt id="c.sysfs_rename_link_ns">
int <code class="descname">sysfs_rename_link_ns</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobject *<em>&nbsp;targ</em>, const char *<em>&nbsp;old</em>, const char *<em>&nbsp;new</em>, const void *<em>&nbsp;new_ns</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_rename_link_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>rename symlink in object’s directory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object we’re acting for.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">targ</span></code></dt>
<dd>object we’re pointing to.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>previous name of the symlink.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new name of the symlink.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">new_ns</span></code></dt>
<dd>new namespace of the symlink.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>A helper function for the common rename symlink idiom.</div></blockquote>
</div>
<div class="section" id="the-debugfs-filesystem">
<h2>The debugfs filesystem<a class="headerlink" href="#the-debugfs-filesystem" title="Permalink to this headline">¶</a></h2>
<div class="section" id="debugfs-interface">
<h3>debugfs interface<a class="headerlink" href="#debugfs-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.debugfs_lookup">
struct dentry * <code class="descname">debugfs_lookup</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>look up an existing debugfs file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to look up.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry of the file.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will return a pointer to a dentry if it succeeds.  If the file
doesn’t exist or an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.  The returned
dentry must be passed to <code class="xref c c-func docutils literal"><span class="pre">dput()</span></code> when it is no longer needed.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_create_file">
struct dentry * <code class="descname">debugfs_create_file</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> call.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the basic “create a file” function for debugfs.  It allows for a
wide range of flexibility in creating a file, or a directory (if you want
to create a directory, the <a class="reference internal" href="#c.debugfs_create_dir" title="debugfs_create_dir"><code class="xref c c-func docutils literal"><span class="pre">debugfs_create_dir()</span></code></a> function is
recommended to be used instead.)</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_create_file_unsafe">
struct dentry * <code class="descname">debugfs_create_file_unsafe</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file_unsafe" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> call.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.debugfs_create_file_unsafe" title="debugfs_create_file_unsafe"><code class="xref c c-func docutils literal"><span class="pre">debugfs_create_file_unsafe()</span></code></a> is completely analogous to
<a class="reference internal" href="#c.debugfs_create_file" title="debugfs_create_file"><code class="xref c c-func docutils literal"><span class="pre">debugfs_create_file()</span></code></a>, the only difference being that the fops
handed it will not get protected against file removals by the
debugfs core.</p>
<p>It is your responsibility to protect your struct file_operation
methods against file removals by means of <a class="reference internal" href="#c.debugfs_use_file_start" title="debugfs_use_file_start"><code class="xref c c-func docutils literal"><span class="pre">debugfs_use_file_start()</span></code></a>
and <a class="reference internal" href="#c.debugfs_use_file_finish" title="debugfs_use_file_finish"><code class="xref c c-func docutils literal"><span class="pre">debugfs_use_file_finish()</span></code></a>. -&gt;:c:func:<cite>open()</cite> is still protected by
debugfs though.</p>
<p>Any struct file_operations defined by means of
<code class="xref c c-func docutils literal"><span class="pre">DEFINE_DEBUGFS_ATTRIBUTE()</span></code> is protected against file removals and
thus, may be used here.</p>
<dl class="function">
<dt id="c.debugfs_create_file_size">
struct dentry * <code class="descname">debugfs_create_file_size</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em>, loff_t<em>&nbsp;file_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_file_size" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> call.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">file_size</span></code></dt>
<dd>initial file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the basic “create a file” function for debugfs.  It allows for a
wide range of flexibility in creating a file, or a directory (if you want
to create a directory, the <a class="reference internal" href="#c.debugfs_create_dir" title="debugfs_create_dir"><code class="xref c c-func docutils literal"><span class="pre">debugfs_create_dir()</span></code></a> function is
recommended to be used instead.)</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_create_dir">
struct dentry * <code class="descname">debugfs_create_dir</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>create a directory in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the directory to
create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
directory will be created in the root of the debugfs filesystem.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a directory in debugfs with the given name.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_create_automount">
struct dentry * <code class="descname">debugfs_create_automount</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, debugfs_automount_t<em>&nbsp;f</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_automount" title="Permalink to this definition">¶</a></dt>
<dd><p>create automount point in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is NULL, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_automount_t</span> <span class="pre">f</span></code></dt>
<dd>function to be called when pathname resolution steps on that one.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>opaque argument to pass to <code class="xref c c-func docutils literal"><span class="pre">f()</span></code>.</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>f</strong> should return what -&gt;:c:func:<cite>d_automount()</cite> would.</p>
<dl class="function">
<dt id="c.debugfs_create_symlink">
struct dentry * <code class="descname">debugfs_create_symlink</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, const char *<em>&nbsp;target</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>create a symbolic link in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the symbolic link to
create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this symbolic link.  This
should be a directory dentry if set.  If this parameter is NULL,
then the symbolic link will be created in the root of the debugfs
filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>a pointer to a string containing the path to the target of the
symbolic link.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a symbolic link with the given name in debugfs that
links to the given target path.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the symbolic
link is to be removed (no automatic cleanup happens if your module is
unloaded, you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_remove">
void <code class="descname">debugfs_remove</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a file or directory from the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>a pointer to a the dentry of the file or directory to be
removed.  If this parameter is NULL or an error value, nothing
will be done.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a file or directory in debugfs that was previously
created with a call to another debugfs function (like
<a class="reference internal" href="#c.debugfs_create_file" title="debugfs_create_file"><code class="xref c c-func docutils literal"><span class="pre">debugfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.</p>
<dl class="function">
<dt id="c.debugfs_remove_recursive">
void <code class="descname">debugfs_remove_recursive</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_remove_recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>recursively removes a directory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>a pointer to a the dentry of the directory to be removed.  If this
parameter is NULL or an error value, nothing will be done.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function recursively removes a directory tree in debugfs that
was previously created with a call to another debugfs function
(like <a class="reference internal" href="#c.debugfs_create_file" title="debugfs_create_file"><code class="xref c c-func docutils literal"><span class="pre">debugfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed, no automatic cleanup of files will happen when a module is
removed, you are responsible here.</p>
<dl class="function">
<dt id="c.debugfs_rename">
struct dentry * <code class="descname">debugfs_rename</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;old_dir</em>, struct dentry *<em>&nbsp;old_dentry</em>, struct dentry *<em>&nbsp;new_dir</em>, const char *<em>&nbsp;new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>rename a file/directory in the debugfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dir</span></code></dt>
<dd>a pointer to the parent dentry for the renamed object. This
should be a directory dentry.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">old_dentry</span></code></dt>
<dd>dentry of an object to be renamed.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">new_dir</span></code></dt>
<dd>a pointer to the parent dentry where the object should be
moved. This should be a directory dentry.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">new_name</span></code></dt>
<dd>a pointer to a string containing the target name.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function renames a file/directory in debugfs.  The target must not
exist for rename to succeed.</p>
<p>This function will return a pointer to old_dentry (which is updated to
reflect renaming) if it succeeds. If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be
returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.</p>
<dl class="function">
<dt id="c.debugfs_initialized">
bool <code class="descname">debugfs_initialized</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells whether debugfs has been registered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_use_file_start">
int <code class="descname">debugfs_use_file_start</code><span class="sig-paren">(</span>const struct dentry *<em>&nbsp;dentry</em>, int *<em>&nbsp;srcu_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_use_file_start" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of file data access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>the dentry object whose data is being accessed.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">srcu_idx</span></code></dt>
<dd>a pointer to some memory to store a SRCU index in.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Up to a matching call to <a class="reference internal" href="#c.debugfs_use_file_finish" title="debugfs_use_file_finish"><code class="xref c c-func docutils literal"><span class="pre">debugfs_use_file_finish()</span></code></a>, any
successive call into the file removing functions <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a>
and <a class="reference internal" href="#c.debugfs_remove_recursive" title="debugfs_remove_recursive"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove_recursive()</span></code></a> will block. Since associated private
file data may only get freed after a successful return of any of
the removal functions, you may safely access it after a successful
call to <a class="reference internal" href="#c.debugfs_use_file_start" title="debugfs_use_file_start"><code class="xref c c-func docutils literal"><span class="pre">debugfs_use_file_start()</span></code></a> without worrying about
lifetime issues.</p>
<p>If -<code class="docutils literal"><span class="pre">EIO</span></code> is returned, the file has already been removed and thus,
it is not safe to access any of its data. If, on the other hand,
it is allowed to access the file data, zero is returned.</p>
<p>Regardless of the return code, any call to
<a class="reference internal" href="#c.debugfs_use_file_start" title="debugfs_use_file_start"><code class="xref c c-func docutils literal"><span class="pre">debugfs_use_file_start()</span></code></a> must be followed by a matching call
to <a class="reference internal" href="#c.debugfs_use_file_finish" title="debugfs_use_file_finish"><code class="xref c c-func docutils literal"><span class="pre">debugfs_use_file_finish()</span></code></a>.</p>
<dl class="function">
<dt id="c.debugfs_use_file_finish">
void <code class="descname">debugfs_use_file_finish</code><span class="sig-paren">(</span>int<em>&nbsp;srcu_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_use_file_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the end of file data access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">srcu_idx</span></code></dt>
<dd>the SRCU index “created” by a former call to
<a class="reference internal" href="#c.debugfs_use_file_start" title="debugfs_use_file_start"><code class="xref c c-func docutils literal"><span class="pre">debugfs_use_file_start()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow any ongoing concurrent call into <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> or
<a class="reference internal" href="#c.debugfs_remove_recursive" title="debugfs_remove_recursive"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove_recursive()</span></code></a> blocked by a former call to
<a class="reference internal" href="#c.debugfs_use_file_start" title="debugfs_use_file_start"><code class="xref c c-func docutils literal"><span class="pre">debugfs_use_file_start()</span></code></a> to proceed and return to its caller.</p>
<dl class="function">
<dt id="c.debugfs_create_u8">
struct dentry * <code class="descname">debugfs_create_u8</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u8 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u8" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 8-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.  It is not wise to check for this value, but rather, check for
<code class="docutils literal"><span class="pre">NULL</span></code> or !``NULL`` instead as to eliminate the need for #ifdef in the calling
code.</p>
<dl class="function">
<dt id="c.debugfs_create_u16">
struct dentry * <code class="descname">debugfs_create_u16</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u16 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u16" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 16-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.  It is not wise to check for this value, but rather, check for
<code class="docutils literal"><span class="pre">NULL</span></code> or !``NULL`` instead as to eliminate the need for #ifdef in the calling
code.</p>
<dl class="function">
<dt id="c.debugfs_create_u32">
struct dentry * <code class="descname">debugfs_create_u32</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u32 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 32-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.  It is not wise to check for this value, but rather, check for
<code class="docutils literal"><span class="pre">NULL</span></code> or !``NULL`` instead as to eliminate the need for #ifdef in the calling
code.</p>
<dl class="function">
<dt id="c.debugfs_create_u64">
struct dentry * <code class="descname">debugfs_create_u64</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u64 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 64-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.  It is not wise to check for this value, but rather, check for
<code class="docutils literal"><span class="pre">NULL</span></code> or !``NULL`` instead as to eliminate the need for #ifdef in the calling
code.</p>
<dl class="function">
<dt id="c.debugfs_create_ulong">
struct dentry * <code class="descname">debugfs_create_ulong</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, unsigned long *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_ulong" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned long value.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.  It is not wise to check for this value, but rather, check for
<code class="docutils literal"><span class="pre">NULL</span></code> or !``NULL`` instead as to eliminate the need for #ifdef in the calling
code.</p>
<dl class="function">
<dt id="c.debugfs_create_x8">
struct dentry * <code class="descname">debugfs_create_x8</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u8 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x8" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 8-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_x16">
struct dentry * <code class="descname">debugfs_create_x16</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u16 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x16" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 16-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_x32">
struct dentry * <code class="descname">debugfs_create_x32</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u32 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 32-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_x64">
struct dentry * <code class="descname">debugfs_create_x64</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u64 *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_x64" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an unsigned 64-bit value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_size_t">
struct dentry * <code class="descname">debugfs_create_size_t</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, size_t *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_size_t" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an size_t value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_atomic_t">
struct dentry * <code class="descname">debugfs_create_atomic_t</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, atomic_t *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_atomic_t" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write an atomic_t value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<dl class="function">
<dt id="c.debugfs_create_bool">
struct dentry * <code class="descname">debugfs_create_bool</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, bool *<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read and write a boolean value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">value</span></code></dt>
<dd>a pointer to the variable that the file should read to and write
from.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that
contains the value of the variable <strong>value</strong>.  If the <strong>mode</strong> variable is so
set, it can be read from, and written to.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.  It is not wise to check for this value, but rather, check for
<code class="docutils literal"><span class="pre">NULL</span></code> or !``NULL`` instead as to eliminate the need for #ifdef in the calling
code.</p>
<dl class="function">
<dt id="c.debugfs_create_blob">
struct dentry * <code class="descname">debugfs_create_blob</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, struct debugfs_blob_wrapper *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read a binary blob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">debugfs_blob_wrapper</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>a pointer to a struct debugfs_blob_wrapper which contains a pointer
to the blob data and the size of the data.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that exports
<strong>blob</strong>-&gt;data as a binary blob. If the <strong>mode</strong> variable is so set it can be
read from. Writing is not supported.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.  It is not wise to check for this value, but rather, check for
<code class="docutils literal"><span class="pre">NULL</span></code> or !``NULL`` instead as to eliminate the need for #ifdef in the calling
code.</p>
<dl class="function">
<dt id="c.debugfs_create_u32_array">
struct dentry * <code class="descname">debugfs_create_u32_array</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, u32 *<em>&nbsp;array</em>, u32<em>&nbsp;elements</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_u32_array" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is used to read u32 array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>u32 array that provides data.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">elements</span></code></dt>
<dd>total number of elements in the array.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that exports
<strong>array</strong> as data. If the <strong>mode</strong> variable is so set it can be read from.
Writing is not supported. Seek within the file is also not supported.
Once array is created its size can not be changed.</p>
<p>The function returns a pointer to dentry on success. If debugfs is not
enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be returned.</p>
<dl class="function">
<dt id="c.debugfs_print_regs32">
void <code class="descname">debugfs_print_regs32</code><span class="sig-paren">(</span>struct seq_file *<em>&nbsp;s</em>, const struct debugfs_reg32 *<em>&nbsp;regs</em>, int<em>&nbsp;nregs</em>, void __iomem *<em>&nbsp;base</em>, char *<em>&nbsp;prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_print_regs32" title="Permalink to this definition">¶</a></dt>
<dd><p>use seq_print to describe a set of registers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the seq_file structure being used to generate output</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">debugfs_reg32</span> <span class="pre">*</span> <span class="pre">regs</span></code></dt>
<dd>an array if struct debugfs_reg32 structures</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nregs</span></code></dt>
<dd>the length of the above array</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>the base address to be used in reading the registers</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">prefix</span></code></dt>
<dd>a string to be prefixed to every output line</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function outputs a text block describing the current values of
some 32-bit hardware registers. It is meant to be used within debugfs
files based on seq_file that need to show registers, intermixed with other
information. The prefix argument may be used to specify a leading string,
because some peripherals have several blocks of identical registers,
for example configuration of dma channels</p>
<dl class="function">
<dt id="c.debugfs_create_regset32">
struct dentry * <code class="descname">debugfs_create_regset32</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, struct debugfs_regset32 *<em>&nbsp;regset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_regset32" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that returns register values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">debugfs_regset32</span> <span class="pre">*</span> <span class="pre">regset</span></code></dt>
<dd>a pointer to a struct debugfs_regset32, which contains a pointer
to an array of register definitions, the array size and the base
address where the register bank is to be found.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in debugfs with the given name that reports
the names and values of a set of 32-bit registers. If the <strong>mode</strong> variable
is so set it can be read from. Writing is not supported.</p>
<p>This function will return a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.debugfs_remove" title="debugfs_remove"><code class="xref c c-func docutils literal"><span class="pre">debugfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here.)  If an error occurs, <code class="docutils literal"><span class="pre">NULL</span></code> will be returned.</p>
<p>If debugfs is not enabled in the kernel, the value -<code class="docutils literal"><span class="pre">ENODEV</span></code> will be
returned.  It is not wise to check for this value, but rather, check for
<code class="docutils literal"><span class="pre">NULL</span></code> or !``NULL`` instead as to eliminate the need for #ifdef in the calling
code.</p>
<dl class="function">
<dt id="c.debugfs_create_devm_seqfile">
struct dentry * <code class="descname">debugfs_create_devm_seqfile</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, int (*read_fn) (struct seq_file<em>&nbsp;*s</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.debugfs_create_devm_seqfile" title="Permalink to this definition">¶</a></dt>
<dd><p>create a debugfs file that is bound to device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device related to this debugfs file.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the debugfs file.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the debugfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">seq_file</span> <span class="pre">*s,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">read_fn</span></code></dt>
<dd>function pointer called to print the seq_file content.</dd>
</dl>
</div>
</div>
<div class="section" id="the-linux-journalling-api">
<h2>The Linux Journalling API<a class="headerlink" href="#the-linux-journalling-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<div class="section" id="details">
<h4>Details<a class="headerlink" href="#details" title="Permalink to this headline">¶</a></h4>
<p>The journalling layer is easy to use. You need to first of all create a
journal_t data structure. There are two calls to do this dependent on
how you decide to allocate the physical media on which the journal
resides. The <a class="reference internal" href="#c.jbd2_journal_init_inode" title="jbd2_journal_init_inode"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_init_inode()</span></code></a> call is for journals stored in
filesystem inodes, or the <a class="reference internal" href="#c.jbd2_journal_init_dev" title="jbd2_journal_init_dev"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_init_dev()</span></code></a> call can be used
for journal stored on a raw device (in a continuous range of blocks). A
journal_t is a typedef for a struct pointer, so when you are finally
finished make sure you call <a class="reference internal" href="#c.jbd2_journal_destroy" title="jbd2_journal_destroy"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_destroy()</span></code></a> on it to free up
any used kernel memory.</p>
<p>Once you have got your journal_t object you need to ‘mount’ or load the
journal file. The journalling layer expects the space for the journal
was already allocated and initialized properly by the userspace tools.
When loading the journal you must call <a class="reference internal" href="#c.jbd2_journal_load" title="jbd2_journal_load"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_load()</span></code></a> to process
journal contents. If the client file system detects the journal contents
does not need to be processed (or even need not have valid contents), it
may call <a class="reference internal" href="#c.jbd2_journal_wipe" title="jbd2_journal_wipe"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_wipe()</span></code></a> to clear the journal contents before
calling <a class="reference internal" href="#c.jbd2_journal_load" title="jbd2_journal_load"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_load()</span></code></a>.</p>
<p>Note that jbd2_journal_wipe(..,0) calls
<a class="reference internal" href="#c.jbd2_journal_skip_recovery" title="jbd2_journal_skip_recovery"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_skip_recovery()</span></code></a> for you if it detects any outstanding
transactions in the journal and similarly <a class="reference internal" href="#c.jbd2_journal_load" title="jbd2_journal_load"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_load()</span></code></a> will
call <a class="reference internal" href="#c.jbd2_journal_recover" title="jbd2_journal_recover"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_recover()</span></code></a> if necessary. I would advise reading
<code class="xref c c-func docutils literal"><span class="pre">ext4_load_journal()</span></code> in fs/ext4/super.c for examples on this stage.</p>
<p>Now you can go ahead and start modifying the underlying filesystem.
Almost.</p>
<p>You still need to actually journal your filesystem changes, this is done
by wrapping them into transactions. Additionally you also need to wrap
the modification of each of the buffers with calls to the journal layer,
so it knows what the modifications you are actually making are. To do
this use <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start()</span></code></a> which returns a transaction handle.</p>
<p><a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start()</span></code></a> and its counterpart <a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_stop()</span></code></a>,
which indicates the end of a transaction are nestable calls, so you can
reenter a transaction if necessary, but remember you must call
<a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_stop()</span></code></a> the same number of times as
<a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start()</span></code></a> before the transaction is completed (or more
accurately leaves the update phase). Ext4/VFS makes use of this feature to
simplify handling of inode dirtying, quota support, etc.</p>
<p>Inside each transaction you need to wrap the modifications to the
individual buffers (blocks). Before you start to modify a buffer you
need to call <a class="reference internal" href="#c.jbd2_journal_get_create_access" title="jbd2_journal_get_create_access"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_get_create_access()</span></code></a> /
<a class="reference internal" href="#c.jbd2_journal_get_write_access" title="jbd2_journal_get_write_access"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_get_write_access()</span></code></a> /
<a class="reference internal" href="#c.jbd2_journal_get_undo_access" title="jbd2_journal_get_undo_access"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_get_undo_access()</span></code></a> as appropriate, this allows the
journalling layer to copy the unmodified
data if it needs to. After all the buffer may be part of a previously
uncommitted transaction. At this point you are at last ready to modify a
buffer, and once you are have done so you need to call
<a class="reference internal" href="#c.jbd2_journal_dirty_metadata" title="jbd2_journal_dirty_metadata"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_dirty_metadata()</span></code></a>. Or if you’ve asked for access to a
buffer you now know is now longer required to be pushed back on the
device you can call <a class="reference internal" href="#c.jbd2_journal_forget" title="jbd2_journal_forget"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_forget()</span></code></a> in much the same way as you
might have used <code class="xref c c-func docutils literal"><span class="pre">bforget()</span></code> in the past.</p>
<p>A <a class="reference internal" href="#c.jbd2_journal_flush" title="jbd2_journal_flush"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_flush()</span></code></a> may be called at any time to commit and
checkpoint all your transactions.</p>
<p>Then at umount time , in your <code class="xref c c-func docutils literal"><span class="pre">put_super()</span></code> you can then call
<a class="reference internal" href="#c.jbd2_journal_destroy" title="jbd2_journal_destroy"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_destroy()</span></code></a> to clean up your in-core journal object.</p>
<p>Unfortunately there a couple of ways the journal layer can cause a
deadlock. The first thing to note is that each task can only have a
single outstanding transaction at any one time, remember nothing commits
until the outermost <a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_stop()</span></code></a>. This means you must complete
the transaction at the end of each file/inode/address etc. operation you
perform, so that the journalling system isn’t re-entered on another
journal. Since transactions can’t be nested/batched across differing
journals, and another filesystem other than yours (say ext4) may be
modified in a later syscall.</p>
<p>The second case to bear in mind is that <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start()</span></code></a> can block
if there isn’t enough space in the journal for your transaction (based
on the passed nblocks param) - when it blocks it merely(!) needs to wait
for transactions to complete and be committed from other tasks, so
essentially we are waiting for <a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_stop()</span></code></a>. So to avoid
deadlocks you must treat <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start()</span></code></a> /
<a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_stop()</span></code></a> as if they were semaphores and include them in
your semaphore ordering rules to prevent
deadlocks. Note that <a class="reference internal" href="#c.jbd2_journal_extend" title="jbd2_journal_extend"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_extend()</span></code></a> has similar blocking
behaviour to <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start()</span></code></a> so you can deadlock here just as
easily as on <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start()</span></code></a>.</p>
<p>Try to reserve the right number of blocks the first time. ;-). This will
be the maximum number of blocks you are going to touch in this
transaction. I advise having a look at at least ext4_jbd.h to see the
basis on which ext4 uses to make these decisions.</p>
<p>Another wriggle to watch out for is your on-disk block allocation
strategy. Why? Because, if you do a delete, you need to ensure you
haven’t reused any of the freed blocks until the transaction freeing
these blocks commits. If you reused these blocks and crash happens,
there is no way to restore the contents of the reallocated blocks at the
end of the last fully committed transaction. One simple way of doing
this is to mark blocks as free in internal in-memory block allocation
structures only after the transaction freeing them commits. Ext4 uses
journal commit callback for this purpose.</p>
<p>With journal commit callbacks you can ask the journalling layer to call
a callback function when the transaction is finally committed to disk,
so that you can do some of your own management. You ask the journalling
layer for calling the callback by simply setting
<code class="docutils literal"><span class="pre">journal-&gt;j_commit_callback</span></code> function pointer and that function is
called after each transaction commit. You can also use
<code class="docutils literal"><span class="pre">transaction-&gt;t_private_list</span></code> for attaching entries to a transaction
that need processing when the transaction commits.</p>
<p>JBD2 also provides a way to block all transaction updates via
<a class="reference internal" href="#c.jbd2_journal_lock_updates" title="jbd2_journal_lock_updates"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_lock_updates()</span></code></a> /
<a class="reference internal" href="#c.jbd2_journal_unlock_updates" title="jbd2_journal_unlock_updates"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_unlock_updates()</span></code></a>. Ext4 uses this when it wants a
window with a clean and stable fs for a moment. E.g.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>jbd2_journal_lock_updates() //stop new stuff happening..
jbd2_journal_flush()        // checkpoint everything.
..do stuff on stable fs
jbd2_journal_unlock_updates() // carry on with filesystem use.
</pre></div>
</div>
<p>The opportunities for abuse and DOS attacks with this should be obvious,
if you allow unprivileged userspace to trigger codepaths containing
these calls.</p>
</div>
<div class="section" id="summary">
<h4>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h4>
<p>Using the journal is a matter of wrapping the different context changes,
being each mount, each modification (transaction) and each changed
buffer to tell the journalling layer about them.</p>
</div>
</div>
<div class="section" id="data-types">
<h3>Data Types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h3>
<p>The journalling layer uses typedefs to ‘hide’ the concrete definitions
of the structures used. As a client of the JBD2 layer you can just rely
on the using the pointer as a magic cookie of some sort. Obviously the
hiding is not enforced as this is ‘C’.</p>
<div class="section" id="structures">
<h4>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h4>
<dl class="type">
<dt id="c.handle_t">
typedef <code class="descname">handle_t</code><a class="headerlink" href="#c.handle_t" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle_t type represents a single atomic update being performed by some process.</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>All filesystem modifications made by the process go
through this handle.  Recursive operations (such as quota operations)
are gathered into a single update.</p>
<p>The buffer credits field is used to account for journaled buffers
being modified by the running process.  To ensure that there is
enough log space for all outstanding operations, we need to limit the
number of outstanding buffers possible at any time.  When the
operation completes, any buffer credits not used are credited back to
the transaction, so that at all times we know how many buffers the
outstanding updates on a transaction might possibly touch.</p>
<p>This is an opaque datatype.</p>
<dl class="type">
<dt id="c.journal_t">
typedef <code class="descname">journal_t</code><a class="headerlink" href="#c.journal_t" title="Permalink to this definition">¶</a></dt>
<dd><p>The journal_t maintains all of the journaling state information for a single filesystem.</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>journal_t is linked to from the fs superblock structure.</p>
<p>We use the journal_t to keep track of all outstanding transaction
activity on the filesystem, and to manage the state of the log
writing process.</p>
<p>This is an opaque datatype.</p>
<dl class="type">
<dt id="c.jbd2_inode">
struct <code class="descname">jbd2_inode</code><a class="headerlink" href="#c.jbd2_inode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct jbd2_inode {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<blockquote>
<div>present in a transaction so that we can sync them during commit.</div></blockquote>
<dl class="type">
<dt id="c.jbd2_journal_handle">
struct <code class="descname">jbd2_journal_handle</code><a class="headerlink" href="#c.jbd2_journal_handle" title="Permalink to this definition">¶</a></dt>
<dd><p>The handle_s type is the concrete type associated with handle_t.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct jbd2_journal_handle {
  union {unnamed_union};
  int h_buffer_credits;
  int h_ref;
  int h_err;
  unsigned int h_sync:1;
  unsigned int h_jdata:1;
  unsigned int h_aborted:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal"><span class="pre">h_buffer_credits</span></code></dt>
<dd>Number of remaining buffers we are allowed to dirty.</dd>
<dt><code class="docutils literal"><span class="pre">h_ref</span></code></dt>
<dd>Reference count on this handle</dd>
<dt><code class="docutils literal"><span class="pre">h_err</span></code></dt>
<dd>Field for caller’s use to track errors through large fs operations</dd>
<dt><code class="docutils literal"><span class="pre">h_sync</span></code></dt>
<dd>flag for sync-on-close</dd>
<dt><code class="docutils literal"><span class="pre">h_jdata</span></code></dt>
<dd>flag to force data journaling</dd>
<dt><code class="docutils literal"><span class="pre">h_aborted</span></code></dt>
<dd>flag indicating fatal error on handle</dd>
</dl>
<dl class="type">
<dt id="c.journal_s">
struct <code class="descname">journal_s</code><a class="headerlink" href="#c.journal_s" title="Permalink to this definition">¶</a></dt>
<dd><p>The journal_s type is the concrete type associated with journal_t.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct journal_s {
  unsigned long j_flags;
  int j_errno;
  struct buffer_head * j_sb_buffer;
  journal_superblock_t * j_superblock;
  int j_format_version;
  rwlock_t j_state_lock;
  int j_barrier_count;
  struct mutex j_barrier;
  transaction_t * j_running_transaction;
  transaction_t * j_committing_transaction;
  transaction_t * j_checkpoint_transactions;
  wait_queue_head_t j_wait_transaction_locked;
  wait_queue_head_t j_wait_done_commit;
  wait_queue_head_t j_wait_commit;
  wait_queue_head_t j_wait_updates;
  wait_queue_head_t j_wait_reserved;
  struct mutex j_checkpoint_mutex;
  unsigned long j_head;
  unsigned long j_tail;
  unsigned long j_free;
  unsigned long j_first;
  unsigned long j_last;
  struct block_device * j_dev;
  int j_blocksize;
  unsigned long long j_blk_offset;
  struct block_device * j_fs_dev;
  unsigned int j_maxlen;
  atomic_t j_reserved_credits;
  spinlock_t j_list_lock;
  struct inode * j_inode;
  tid_t j_tail_sequence;
  tid_t j_transaction_sequence;
  tid_t j_commit_sequence;
  tid_t j_commit_request;
  __u8 j_uuid;
  struct task_struct * j_task;
  int j_max_transaction_buffers;
  unsigned long j_commit_interval;
  struct timer_list j_commit_timer;
  spinlock_t j_revoke_lock;
  struct jbd2_revoke_table_s * j_revoke;
  struct jbd2_revoke_table_s * j_revoke_table;
  struct buffer_head ** j_wbuf;
  int j_wbufsize;
  pid_t j_last_sync_writer;
  spinlock_t j_history_lock;
  struct proc_dir_entry * j_proc_entry;
  struct transaction_stats_s j_stats;
  void * j_private;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
  struct lockdep_map j_trans_commit_map;
#endif
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">j_flags</span></code></dt>
<dd>General journaling state flags</dd>
<dt><code class="docutils literal"><span class="pre">j_errno</span></code></dt>
<dd>Is there an outstanding uncleared error on the journal (from a
prior abort)?</dd>
<dt><code class="docutils literal"><span class="pre">j_sb_buffer</span></code></dt>
<dd>First part of superblock buffer</dd>
<dt><code class="docutils literal"><span class="pre">j_superblock</span></code></dt>
<dd>Second part of superblock buffer</dd>
<dt><code class="docutils literal"><span class="pre">j_format_version</span></code></dt>
<dd>Version of the superblock format</dd>
<dt><code class="docutils literal"><span class="pre">j_state_lock</span></code></dt>
<dd>Protect the various scalars in the journal</dd>
<dt><code class="docutils literal"><span class="pre">j_barrier_count</span></code></dt>
<dd>Number of processes waiting to create a barrier lock</dd>
<dt><code class="docutils literal"><span class="pre">j_barrier</span></code></dt>
<dd>The barrier lock itself</dd>
<dt><code class="docutils literal"><span class="pre">j_running_transaction</span></code></dt>
<dd>The current running transaction..</dd>
<dt><code class="docutils literal"><span class="pre">j_committing_transaction</span></code></dt>
<dd>the transaction we are pushing to disk</dd>
<dt><code class="docutils literal"><span class="pre">j_checkpoint_transactions</span></code></dt>
<dd>a linked circular list of all transactions
waiting for checkpointing</dd>
<dt><code class="docutils literal"><span class="pre">j_wait_transaction_locked</span></code></dt>
<dd>Wait queue for waiting for a locked transaction
to start committing, or for a barrier lock to be released</dd>
<dt><code class="docutils literal"><span class="pre">j_wait_done_commit</span></code></dt>
<dd>Wait queue for waiting for commit to complete</dd>
<dt><code class="docutils literal"><span class="pre">j_wait_commit</span></code></dt>
<dd>Wait queue to trigger commit</dd>
<dt><code class="docutils literal"><span class="pre">j_wait_updates</span></code></dt>
<dd>Wait queue to wait for updates to complete</dd>
<dt><code class="docutils literal"><span class="pre">j_wait_reserved</span></code></dt>
<dd>Wait queue to wait for reserved buffer credits to drop</dd>
<dt><code class="docutils literal"><span class="pre">j_checkpoint_mutex</span></code></dt>
<dd>Mutex for locking against concurrent checkpoints</dd>
<dt><code class="docutils literal"><span class="pre">j_head</span></code></dt>
<dd>Journal head - identifies the first unused block in the journal</dd>
<dt><code class="docutils literal"><span class="pre">j_tail</span></code></dt>
<dd>Journal tail - identifies the oldest still-used block in the
journal.</dd>
<dt><code class="docutils literal"><span class="pre">j_free</span></code></dt>
<dd>Journal free - how many free blocks are there in the journal?</dd>
<dt><code class="docutils literal"><span class="pre">j_first</span></code></dt>
<dd>The block number of the first usable block</dd>
<dt><code class="docutils literal"><span class="pre">j_last</span></code></dt>
<dd>The block number one beyond the last usable block</dd>
<dt><code class="docutils literal"><span class="pre">j_dev</span></code></dt>
<dd>Device where we store the journal</dd>
<dt><code class="docutils literal"><span class="pre">j_blocksize</span></code></dt>
<dd>blocksize for the location where we store the journal.</dd>
<dt><code class="docutils literal"><span class="pre">j_blk_offset</span></code></dt>
<dd>starting block offset for into the device where we store the
journal</dd>
<dt><code class="docutils literal"><span class="pre">j_fs_dev</span></code></dt>
<dd>Device which holds the client fs.  For internal journal this will
be equal to j_dev</dd>
<dt><code class="docutils literal"><span class="pre">j_maxlen</span></code></dt>
<dd>Total maximum capacity of the journal region on disk.</dd>
<dt><code class="docutils literal"><span class="pre">j_reserved_credits</span></code></dt>
<dd>Number of buffers reserved from the running transaction</dd>
<dt><code class="docutils literal"><span class="pre">j_list_lock</span></code></dt>
<dd>Protects the buffer lists and internal buffer state.</dd>
<dt><code class="docutils literal"><span class="pre">j_inode</span></code></dt>
<dd>Optional inode where we store the journal.  If present, all journal
block numbers are mapped into this inode via <a class="reference internal" href="#c.bmap" title="bmap"><code class="xref c c-func docutils literal"><span class="pre">bmap()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">j_tail_sequence</span></code></dt>
<dd>Sequence number of the oldest transaction in the log</dd>
<dt><code class="docutils literal"><span class="pre">j_transaction_sequence</span></code></dt>
<dd>Sequence number of the next transaction to grant</dd>
<dt><code class="docutils literal"><span class="pre">j_commit_sequence</span></code></dt>
<dd>Sequence number of the most recently committed
transaction</dd>
<dt><code class="docutils literal"><span class="pre">j_commit_request</span></code></dt>
<dd>Sequence number of the most recent transaction wanting
commit</dd>
<dt><code class="docutils literal"><span class="pre">j_uuid</span></code></dt>
<dd>Uuid of client object.</dd>
<dt><code class="docutils literal"><span class="pre">j_task</span></code></dt>
<dd>Pointer to the current commit thread for this journal</dd>
<dt><code class="docutils literal"><span class="pre">j_max_transaction_buffers</span></code></dt>
<dd>Maximum number of metadata buffers to allow in a
single compound commit transaction</dd>
<dt><code class="docutils literal"><span class="pre">j_commit_interval</span></code></dt>
<dd>What is the maximum transaction lifetime before we begin
a commit?</dd>
<dt><code class="docutils literal"><span class="pre">j_commit_timer</span></code></dt>
<dd>The timer used to wakeup the commit thread</dd>
<dt><code class="docutils literal"><span class="pre">j_revoke_lock</span></code></dt>
<dd>Protect the revoke table</dd>
<dt><code class="docutils literal"><span class="pre">j_revoke</span></code></dt>
<dd>The revoke table - maintains the list of revoked blocks in the
current transaction.</dd>
<dt><code class="docutils literal"><span class="pre">j_revoke_table</span></code></dt>
<dd>alternate revoke tables for j_revoke</dd>
<dt><code class="docutils literal"><span class="pre">j_wbuf</span></code></dt>
<dd>array of buffer_heads for jbd2_journal_commit_transaction</dd>
<dt><code class="docutils literal"><span class="pre">j_wbufsize</span></code></dt>
<dd>maximum number of buffer_heads allowed in j_wbuf, the
number that will fit in j_blocksize</dd>
<dt><code class="docutils literal"><span class="pre">j_last_sync_writer</span></code></dt>
<dd>most recent pid which did a synchronous write</dd>
<dt><code class="docutils literal"><span class="pre">j_history_lock</span></code></dt>
<dd>Protect the transactions statistics history</dd>
<dt><code class="docutils literal"><span class="pre">j_proc_entry</span></code></dt>
<dd>procfs entry for the jbd statistics directory</dd>
<dt><code class="docutils literal"><span class="pre">j_stats</span></code></dt>
<dd>Overall statistics</dd>
<dt><code class="docutils literal"><span class="pre">j_private</span></code></dt>
<dd>An opaque pointer to fs-private information.</dd>
<dt><code class="docutils literal"><span class="pre">j_trans_commit_map</span></code></dt>
<dd>Lockdep entity to track transaction commit dependencies</dd>
</dl>
</div>
</div>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>The functions here are split into two groups those that affect a journal
as a whole, and those which are used to manage transactions</p>
<div class="section" id="journal-level">
<h4>Journal Level<a class="headerlink" href="#journal-level" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="c.jbd2_journal_force_commit_nested">
int <code class="descname">jbd2_journal_force_commit_nested</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_force_commit_nested" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to force
Returns true if progress was made.</dd>
</dl>
<p><strong>Description</strong></p>
<p>transaction.  This is used for forcing out undo-protected data which contains
bitmaps, when the fs is running out of space.</p>
<dl class="function">
<dt id="c.jbd2_journal_force_commit">
int <code class="descname">jbd2_journal_force_commit</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_force_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>force any uncommitted transactions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to force</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller want unconditional commit. We can only force the running transaction
if we don’t have an active handle, otherwise, we will deadlock.</p>
<dl class="function">
<dt id="c.jbd2_journal_init_dev">
<a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> * <code class="descname">jbd2_journal_init_dev</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, struct block_device *<em>&nbsp;fs_dev</em>, unsigned long long<em>&nbsp;start</em>, int<em>&nbsp;len</em>, int<em>&nbsp;blocksize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_init_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>creates and initialises a journal structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>Block device on which to create the journal</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">fs_dev</span></code></dt>
<dd>Device which hold journalled filesystem for this journal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>Block nr Start of journal.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>Length of the journal in blocks.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">blocksize</span></code></dt>
<dd>blocksize of journalling device</dd>
</dl>
<p><strong>Return</strong></p>
<p>a newly created journal_t *</p>
<blockquote>
<div>jbd2_journal_init_dev creates a journal which maps a fixed contiguous
range of blocks on an arbitrary block device.</div></blockquote>
<dl class="function">
<dt id="c.jbd2_journal_init_inode">
<a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> * <code class="descname">jbd2_journal_init_inode</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_init_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a journal which maps to a inode.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>An inode to create the journal in</dd>
</dl>
<p><strong>Description</strong></p>
<p>jbd2_journal_init_inode creates a journal which maps an on-disk inode as
the journal.  The inode must exist already, must support <a class="reference internal" href="#c.bmap" title="bmap"><code class="xref c c-func docutils literal"><span class="pre">bmap()</span></code></a> and
must have all data blocks preallocated.</p>
<dl class="function">
<dt id="c.jbd2_journal_update_sb_errno">
void <code class="descname">jbd2_journal_update_sb_errno</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_update_sb_errno" title="Permalink to this definition">¶</a></dt>
<dd><p>Update error in the journal.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>The journal to update.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update a journal’s errno.  Write updated superblock to disk waiting for IO
to complete.</p>
<dl class="function">
<dt id="c.jbd2_journal_load">
int <code class="descname">jbd2_journal_load</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read journal from disk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a journal_t structure which tells us which disk blocks contain
a journal, read the journal from disk to initialise the in-memory
structures.</p>
<dl class="function">
<dt id="c.jbd2_journal_destroy">
int <code class="descname">jbd2_journal_destroy</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a journal_t structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a journal_t structure once it is no longer in use by the
journaled object.
Return &lt;0 if we couldn’t clean up the journal.</p>
<dl class="function">
<dt id="c.jbd2_journal_check_used_features">
int <code class="descname">jbd2_journal_check_used_features</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, unsigned long<em>&nbsp;compat</em>, unsigned long<em>&nbsp;ro</em>, unsigned long<em>&nbsp;incompat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_check_used_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if features specified are used.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to check.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">compat</span></code></dt>
<dd>bitmask of compatible features</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ro</span></code></dt>
<dd>bitmask of features that force read-only mount</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">incompat</span></code></dt>
<dd>bitmask of incompatible features</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the journal uses all of a given set of
features.  Return true (non-zero) if it does.</p>
<dl class="function">
<dt id="c.jbd2_journal_check_available_features">
int <code class="descname">jbd2_journal_check_available_features</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, unsigned long<em>&nbsp;compat</em>, unsigned long<em>&nbsp;ro</em>, unsigned long<em>&nbsp;incompat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_check_available_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Check feature set in journalling layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to check.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">compat</span></code></dt>
<dd>bitmask of compatible features</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ro</span></code></dt>
<dd>bitmask of features that force read-only mount</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">incompat</span></code></dt>
<dd>bitmask of incompatible features</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check whether the journaling code supports the use of
all of a given set of features on this journal.  Return true</p>
<dl class="function">
<dt id="c.jbd2_journal_set_features">
int <code class="descname">jbd2_journal_set_features</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, unsigned long<em>&nbsp;compat</em>, unsigned long<em>&nbsp;ro</em>, unsigned long<em>&nbsp;incompat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_set_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a given journal feature in the superblock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">compat</span></code></dt>
<dd>bitmask of compatible features</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">ro</span></code></dt>
<dd>bitmask of features that force read-only mount</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">incompat</span></code></dt>
<dd>bitmask of incompatible features</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark a given journal feature as present on the
superblock.  Returns true if the requested features could be set.</p>
<dl class="function">
<dt id="c.jbd2_journal_flush">
int <code class="descname">jbd2_journal_flush</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush journal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush all data for a given journal to disk and empty the journal.
Filesystems can use this when remounting readonly to ensure that
recovery does not need to happen on remount.</p>
<dl class="function">
<dt id="c.jbd2_journal_wipe">
int <code class="descname">jbd2_journal_wipe</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, int<em>&nbsp;write</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_wipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Wipe journal contents</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to act on.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd>flag (see below)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wipe out all of the contents of a journal, safely.  This will produce
a warning if the journal contains any valid recovery information.
Must be called between journal_init_*() and <a class="reference internal" href="#c.jbd2_journal_load" title="jbd2_journal_load"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_load()</span></code></a>.</p>
<p>If ‘write’ is non-zero, then we wipe out the journal on disk; otherwise
we merely suppress recovery.</p>
<dl class="function">
<dt id="c.jbd2_journal_abort">
void <code class="descname">jbd2_journal_abort</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, int<em>&nbsp;errno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown the journal immediately.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>the journal to shutdown.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">errno</span></code></dt>
<dd>an error number to record in the journal indicating
the reason for the shutdown.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a complete, immediate shutdown of the ENTIRE
journal (not of a single transaction).  This operation cannot be
undone without closing and reopening the journal.</p>
<p>The jbd2_journal_abort function is intended to support higher level error
recovery mechanisms such as the ext2/ext3 remount-readonly error
mode.</p>
<p>Journal abort has very specific semantics.  Any existing dirty,
unjournaled buffers in the main filesystem will still be written to
disk by bdflush, but the journaling mechanism will be suspended
immediately and no further transaction commits will be honoured.</p>
<p>Any dirty, journaled buffers will be written back to disk without
hitting the journal.  Atomicity cannot be guaranteed on an aborted
filesystem, but we _do_ attempt to leave as much data as possible
behind for fsck to use for cleanup.</p>
<p>Any attempt to get a new transaction handle on a journal which is in
ABORT state will just result in an -EROFS error return.  A
jbd2_journal_stop on an existing handle will return -EIO if we have
entered abort state during the update.</p>
<p>Recursive transactions are not disturbed by journal abort until the
final jbd2_journal_stop, which will receive the -EIO error.</p>
<p>Finally, the jbd2_journal_abort call allows the caller to supply an errno
which will be recorded (if possible) in the journal superblock.  This
allows a client to record failure conditions in the middle of a
transaction without having to complete the transaction to record the
failure to disk.  ext3_error, for example, now uses this
functionality.</p>
<p>Errors which originate from within the journaling layer will NOT
supply an errno; a null errno implies that absolutely no further
writes are done to the journal (unless there are any already in
progress).</p>
<dl class="function">
<dt id="c.jbd2_journal_errno">
int <code class="descname">jbd2_journal_errno</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_errno" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the journal’s error state.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to examine.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the errno number set with <a class="reference internal" href="#c.jbd2_journal_abort" title="jbd2_journal_abort"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_abort()</span></code></a>, the last
time the journal was mounted - if the journal was stopped
without calling abort this will be 0.</p>
<p>If the journal has been aborted on this mount time -EROFS will
be returned.</p>
<dl class="function">
<dt id="c.jbd2_journal_clear_err">
int <code class="descname">jbd2_journal_clear_err</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_clear_err" title="Permalink to this definition">¶</a></dt>
<dd><p>clears the journal’s error state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>An error must be cleared or acked to take a FS out of readonly
mode.</p>
<dl class="function">
<dt id="c.jbd2_journal_ack_err">
void <code class="descname">jbd2_journal_ack_err</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_ack_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Ack journal err.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to act on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>An error must be cleared or acked to take a FS out of readonly
mode.</p>
<dl class="function">
<dt id="c.jbd2_journal_recover">
int <code class="descname">jbd2_journal_recover</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_recover" title="Permalink to this definition">¶</a></dt>
<dd><p>recovers a on-disk journal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>the journal to recover</dd>
</dl>
<p><strong>Description</strong></p>
<p>The primary function for recovering the log contents when mounting a
journaled device.</p>
<p>Recovery is done in three passes.  In the first pass, we look for the
end of the log.  In the second, we assemble the list of revoke
blocks.  In the third and final pass, we replay any un-revoked blocks
in the log.</p>
<dl class="function">
<dt id="c.jbd2_journal_skip_recovery">
int <code class="descname">jbd2_journal_skip_recovery</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_skip_recovery" title="Permalink to this definition">¶</a></dt>
<dd><p>Start journal and wipe exiting records</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to startup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locate any valid recovery information from the journal and set up the
journal structures in memory to ignore it (presumably because the
caller has evidence that it is out of date).
This function doesn’t appear to be exported..</p>
<p>We perform one pass over the journal to allow us to tell the user how
much recovery information is being erased, and to let us initialise
the journal transaction sequence numbers to the next unused ID.</p>
</div>
<div class="section" id="transasction-level">
<h4>Transasction Level<a class="headerlink" href="#transasction-level" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="c.jbd2_journal_start">
<a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> * <code class="descname">jbd2_journal_start</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, int<em>&nbsp;nblocks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a new handle.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to start transaction on.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nblocks</span></code></dt>
<dd>number of block buffer we might modify</dd>
</dl>
<p><strong>Description</strong></p>
<p>We make sure that the transaction can guarantee at least nblocks of
modified buffers in the log.  We block until the log can guarantee
that much space. Additionally, if rsv_blocks &gt; 0, we also create another
handle with rsv_blocks reserved blocks in the journal. This handle is
is stored in h_rsv_handle. It is not attached to any particular transaction
and thus doesn’t block transaction commit. If the caller uses this reserved
handle, it has to set h_rsv_handle to NULL as otherwise <a class="reference internal" href="#c.jbd2_journal_stop" title="jbd2_journal_stop"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_stop()</span></code></a>
on the parent handle will dispose the reserved one. Reserved handle has to
be converted to a normal handle using <a class="reference internal" href="#c.jbd2_journal_start_reserved" title="jbd2_journal_start_reserved"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start_reserved()</span></code></a> before
it can be used.</p>
<p>Return a pointer to a newly allocated handle, or an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> value
on failure.</p>
<dl class="function">
<dt id="c.jbd2_journal_start_reserved">
int <code class="descname">jbd2_journal_start_reserved</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;line_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_start_reserved" title="Permalink to this definition">¶</a></dt>
<dd><p>start reserved handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle to start</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">line_no</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Start handle that has been previously reserved with <code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_reserve()</span></code>.
This attaches <strong>handle</strong> to the running transaction (or creates one if there’s
not transaction running). Unlike <a class="reference internal" href="#c.jbd2_journal_start" title="jbd2_journal_start"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_start()</span></code></a> this function cannot
block on journal commit, checkpointing, or similar stuff. It can block on
memory allocation or frozen journal though.</p>
<p>Return 0 on success, non-zero on error - handle is freed in that case.</p>
<dl class="function">
<dt id="c.jbd2_journal_extend">
int <code class="descname">jbd2_journal_extend</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, int<em>&nbsp;nblocks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_extend" title="Permalink to this definition">¶</a></dt>
<dd><p>extend buffer credits.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle to ‘extend’</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nblocks</span></code></dt>
<dd>nr blocks to try to extend by.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some transactions, such as large extends and truncates, can be done
atomically all at once or in several stages.  The operation requests
a credit for a number of buffer modifications in advance, but can
extend its credit if it needs more.</p>
<p>jbd2_journal_extend tries to give the running handle more buffer credits.
It does not guarantee that allocation - this is a best-effort only.
The calling process MUST be able to deal cleanly with a failure to
extend here.</p>
<p>Return 0 on success, non-zero on failure.</p>
<p>return code &lt; 0 implies an error
return code &gt; 0 implies normal transaction-full status.</p>
<dl class="function">
<dt id="c.jbd2__journal_restart">
int <code class="descname">jbd2__journal_restart</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, int<em>&nbsp;nblocks</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2__journal_restart" title="Permalink to this definition">¶</a></dt>
<dd><p>restart a handle .</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>handle to restart</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nblocks</span></code></dt>
<dd>nr credits requested</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart a handle for a multi-transaction filesystem
operation.</p>
<p>If the <a class="reference internal" href="#c.jbd2_journal_extend" title="jbd2_journal_extend"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_extend()</span></code></a> call above fails to grant new buffer credits
to a running handle, a call to jbd2_journal_restart will commit the
handle’s transaction so far and reattach the handle to a new
transaction capable of guaranteeing the requested number of
credits. We preserve reserved handle if there’s any attached to the
passed in handle.</p>
<dl class="function">
<dt id="c.jbd2_journal_lock_updates">
void <code class="descname">jbd2_journal_lock_updates</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_lock_updates" title="Permalink to this definition">¶</a></dt>
<dd><p>establish a transaction barrier.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to establish a barrier on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This locks out any further updates from being started, and blocks
until all existing updates have completed, returning only once the
journal is in a quiescent state with no updates running.</p>
<p>The journal lock should not be held on entry.</p>
<dl class="function">
<dt id="c.jbd2_journal_unlock_updates">
void <code class="descname">jbd2_journal_unlock_updates</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_unlock_updates" title="Permalink to this definition">¶</a></dt>
<dd><p>release barrier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>Journal to release the barrier on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release a transaction barrier obtained with <a class="reference internal" href="#c.jbd2_journal_lock_updates" title="jbd2_journal_lock_updates"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_lock_updates()</span></code></a>.</p>
<p>Should be called without the journal lock held.</p>
<dl class="function">
<dt id="c.jbd2_journal_get_write_access">
int <code class="descname">jbd2_journal_get_write_access</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_get_write_access" title="Permalink to this definition">¶</a></dt>
<dd><p>notify intent to modify a buffer for metadata (not data) update.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction to add buffer modifications to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>bh to be used for metadata writes</dd>
</dl>
<p><strong>Return</strong></p>
<p>error code or 0 on success.</p>
<p>In full data journalling mode the buffer may be of type BJ_AsyncData,
because we’re <code class="docutils literal"><span class="pre">:c:func:`write()`ing</span></code> a buffer which is also part of a shared mapping.</p>
<dl class="function">
<dt id="c.jbd2_journal_get_create_access">
int <code class="descname">jbd2_journal_get_create_access</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_get_create_access" title="Permalink to this definition">¶</a></dt>
<dd><p>notify intent to use newly created bh</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction to new buffer to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>new buffer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call this if you create a new bh.</p>
<dl class="function">
<dt id="c.jbd2_journal_get_undo_access">
int <code class="descname">jbd2_journal_get_undo_access</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_get_undo_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Notify intent to modify metadata with non-rewindable consequences</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>buffer to undo</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sometimes there is a need to distinguish between metadata which has
been committed to disk and that which has not.  The ext3fs code uses
this for freeing and allocating space, we have to make sure that we
do not reuse freed space until the deallocation has been committed,
since if we overwrote that space we would make the delete
un-rewindable in case of a crash.</p>
<p>To deal with that, jbd2_journal_get_undo_access requests write access to a
buffer for parts of non-rewindable operations such as delete
operations on the bitmaps.  The journaling code must keep a copy of
the buffer’s contents prior to the undo_access call until such time
as we know that the buffer has definitely been committed to disk.</p>
<p>We never need to know which transaction the committed data is part
of, buffers touched here are guaranteed to be dirtied later and so
will be committed to a new transaction in due course, at which point
we can discard the old committed data pointer.</p>
<p>Returns error number or 0 on success.</p>
<dl class="function">
<dt id="c.jbd2_journal_set_triggers">
void <code class="descname">jbd2_journal_set_triggers</code><span class="sig-paren">(</span>struct buffer_head *<em>&nbsp;bh</em>, struct jbd2_buffer_trigger_type *<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_set_triggers" title="Permalink to this definition">¶</a></dt>
<dd><p>Add triggers for commit writeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>buffer to trigger on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">jbd2_buffer_trigger_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>struct jbd2_buffer_trigger_type containing the trigger(s).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set any triggers on this journal_head.  This is always safe, because
triggers for a committing buffer will be saved off, and triggers for
a running transaction will match the buffer in that transaction.</p>
<p>Call with NULL to clear the triggers.</p>
<dl class="function">
<dt id="c.jbd2_journal_dirty_metadata">
int <code class="descname">jbd2_journal_dirty_metadata</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_dirty_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a buffer as containing dirty metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction to add buffer to.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>buffer to mark</dd>
</dl>
<p><strong>Description</strong></p>
<p>mark dirty metadata which needs to be journaled as part of the current
transaction.</p>
<p>The buffer must have previously had <a class="reference internal" href="#c.jbd2_journal_get_write_access" title="jbd2_journal_get_write_access"><code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_get_write_access()</span></code></a>
called so that it has a valid journal_head attached to the buffer
head.</p>
<p>The buffer is placed on the transaction’s metadata list and is marked
as belonging to the transaction.</p>
<p>Returns error number or 0 on success.</p>
<p>Special care needs to be taken if the buffer already belongs to the
current committing transaction (in which case we should have frozen
data present for that commit).  In that case, we don’t relink the
buffer: that only gets done when the old transaction finally
completes its commit.</p>
<dl class="function">
<dt id="c.jbd2_journal_forget">
int <code class="descname">jbd2_journal_forget</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em>, struct buffer_head *<em>&nbsp;bh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_forget" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref c c-func docutils literal"><span class="pre">bforget()</span></code> for potentially-journaled buffers.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span> <span class="pre">*</span> <span class="pre">bh</span></code></dt>
<dd>bh to ‘forget’</dd>
</dl>
<p><strong>Description</strong></p>
<p>We can only do the bforget if there are no commits pending against the
buffer.  If the buffer is dirty in the current running transaction we
can safely unlink it.</p>
<p>bh may not be a journalled buffer at all - it may be a non-JBD
buffer which came off the hashtable.  Check for this.</p>
<p>Decrements bh-&gt;b_count by one.</p>
<p>Allow this call even if the handle has aborted — it may be part of
the caller’s cleanup after an abort.</p>
<dl class="function">
<dt id="c.jbd2_journal_stop">
int <code class="descname">jbd2_journal_stop</code><span class="sig-paren">(</span><a class="reference internal" href="#c.handle_t" title="handle_t">handle_t</a> *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>complete a transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">handle_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>transaction to complete.</dd>
</dl>
<p><strong>Description</strong></p>
<p>All done for a particular handle.</p>
<p>There is not much action needed here.  We just return any remaining
buffer credits to the transaction and remove the handle.  The only
complication is that we need to start a commit operation if the
filesystem is marked for synchronous update.</p>
<p>jbd2_journal_stop itself will not usually return an error, but it may
do so in unusual circumstances.  In particular, expect it to
return -EIO if a jbd2_journal_abort has been executed since the
transaction began.</p>
<dl class="function">
<dt id="c.jbd2_journal_try_to_free_buffers">
int <code class="descname">jbd2_journal_try_to_free_buffers</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, struct page *<em>&nbsp;page</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_try_to_free_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>try to free page buffers.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal for operation</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>to try and free</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>we use the mask to detect how hard should we try to release
buffers. If __GFP_DIRECT_RECLAIM and __GFP_FS is set, we wait for commit
code to release the buffers.</dd>
</dl>
<p><strong>Description</strong></p>
<p>For all the buffers on this page,
if they are fully written out ordered data, move them onto BUF_CLEAN
so <code class="xref c c-func docutils literal"><span class="pre">try_to_free_buffers()</span></code> can reap them.</p>
<p>This function returns non-zero if we wish <code class="xref c c-func docutils literal"><span class="pre">try_to_free_buffers()</span></code>
to be called. We do this if the page is releasable by <code class="xref c c-func docutils literal"><span class="pre">try_to_free_buffers()</span></code>.
We also do it if the page has locked or dirty buffers and the caller wants
us to perform sync or async writeout.</p>
<p>This complicates JBD locking somewhat.  We aren’t protected by the
BKL here.  We wish to remove the buffer from its committing or
running transaction’s -&gt;t_datalist via __jbd2_journal_unfile_buffer.</p>
<p>This may <em>change</em> the value of transaction_t-&gt;t_datalist, so anyone
who looks at t_datalist needs to lock against this function.</p>
<p>Even worse, someone may be doing a jbd2_journal_dirty_data on this
buffer.  So we need to lock against that.  <code class="xref c c-func docutils literal"><span class="pre">jbd2_journal_dirty_data()</span></code>
will come out of the lock with the buffer dirty, which makes it
ineligible for release here.</p>
<p>Who else is affected by this?  hmm…  Really the only contender
is <code class="xref c c-func docutils literal"><span class="pre">do_get_write_access()</span></code> - it could be looking at the buffer while
<code class="xref c c-func docutils literal"><span class="pre">journal_try_to_free_buffer()</span></code> is changing its state.  But that
cannot happen because we never reallocate freed data as metadata
while the data is part of a transaction.  Yes?</p>
<p>Return 0 on failure, 1 on success</p>
<dl class="function">
<dt id="c.jbd2_journal_invalidatepage">
int <code class="descname">jbd2_journal_invalidatepage</code><span class="sig-paren">(</span><a class="reference internal" href="#c.journal_t" title="journal_t">journal_t</a> *<em>&nbsp;journal</em>, struct page *<em>&nbsp;page</em>, unsigned int<em>&nbsp;offset</em>, unsigned int<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.jbd2_journal_invalidatepage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">journal_t</span> <span class="pre">*</span> <span class="pre">journal</span></code></dt>
<dd>journal to use for flush…</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page to flush</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>start of the range to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt>
<dd>length of the range to invalidate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reap page buffers containing data after in the specified range in page.
Can return -EBUSY if buffers are part of the committing transaction and
the page is straddling i_size. Caller then has to wait for current commit
and try again.</p>
</div>
</div>
<div class="section" id="see-also">
<h3>See also<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://kernel.org/pub/linux/kernel/people/sct/ext3/journal-design.ps.gz">Journaling the Linux ext2fs Filesystem, LinuxExpo 98, Stephen
Tweedie</a></p>
<p><a class="reference external" href="http://olstrans.sourceforge.net/release/OLS2000-ext3/OLS2000-ext3.html">Ext3 Journalling FileSystem, OLS 2000, Dr. Stephen
Tweedie</a></p>
</div>
</div>
<div class="section" id="splice-api">
<h2>splice API<a class="headerlink" href="#splice-api" title="Permalink to this headline">¶</a></h2>
<p>splice is a method for moving blocks of data around inside the kernel,
without continually transferring them between the kernel and user space.</p>
<dl class="function">
<dt id="c.splice_to_pipe">
ssize_t <code class="descname">splice_to_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_pipe_desc *<em>&nbsp;spd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_to_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>fill passed data into a pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to fill</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">splice_pipe_desc</span> <span class="pre">*</span> <span class="pre">spd</span></code></dt>
<dd>data to fill</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><strong>spd</strong> contains a map of pages and len/offset tuples, along with
the struct pipe_buf_operations associated with these pages. This
function will link that data to the pipe.</div></blockquote>
<dl class="function">
<dt id="c.generic_file_splice_read">
ssize_t <code class="descname">generic_file_splice_read</code><span class="sig-paren">(</span>struct file *<em>&nbsp;in</em>, loff_t *<em>&nbsp;ppos</em>, struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_splice_read" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from file to a pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>file to splice from</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>position in <strong>in</strong></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice to</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to splice</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Will read pages from given file and fill them into a pipe. Can be
used as long as it has more or less sane -&gt;:c:func:<cite>read_iter()</cite>.</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe_feed">
int <code class="descname">splice_from_pipe_feed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_desc *<em>&nbsp;sd</em>, splice_actor *<em>&nbsp;actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>feed available data from a pipe to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information to <strong>actor</strong></dd>
<dt><code class="docutils literal"><span class="pre">splice_actor</span> <span class="pre">*</span> <span class="pre">actor</span></code></dt>
<dd>handler that splices the data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function loops over the pipe and calls <strong>actor</strong> to do the
actual moving of a single struct pipe_buffer to the desired
destination.  It returns when there’s no more buffers left in
the pipe or if the requested number of bytes (<strong>sd</strong>-&gt;total_len)
have been copied.  It returns a positive number (one) if the
pipe needs to be filled with more data, zero if the required
number of bytes have been copied and -errno on error.</p>
<p>This, together with splice_from_pipe_{begin,end,next}, may be
used to implement the functionality of <a class="reference internal" href="#c.__splice_from_pipe" title="__splice_from_pipe"><code class="xref c c-func docutils literal"><span class="pre">__splice_from_pipe()</span></code></a> when
locking is required around copying the pipe buffers to the
destination.</p>
</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe_next">
int <code class="descname">splice_from_pipe_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_desc *<em>&nbsp;sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_next" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for some data to splice from</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information about the splice operation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function will wait for some data and return a positive
value (one) if pipe buffers are available.  It will return zero
or -errno if no more data needs to be spliced.</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe_begin">
void <code class="descname">splice_from_pipe_begin</code><span class="sig-paren">(</span>struct splice_desc *<em>&nbsp;sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>start splicing from pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information about the splice operation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function should be called before a loop containing
<a class="reference internal" href="#c.splice_from_pipe_next" title="splice_from_pipe_next"><code class="xref c c-func docutils literal"><span class="pre">splice_from_pipe_next()</span></code></a> and <a class="reference internal" href="#c.splice_from_pipe_feed" title="splice_from_pipe_feed"><code class="xref c c-func docutils literal"><span class="pre">splice_from_pipe_feed()</span></code></a> to
initialize the necessary fields of <strong>sd</strong>.</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe_end">
void <code class="descname">splice_from_pipe_end</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_desc *<em>&nbsp;sd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe_end" title="Permalink to this definition">¶</a></dt>
<dd><p>finish splicing from pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information about the splice operation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function will wake up pipe writers if necessary.  It should
be called after a loop containing <a class="reference internal" href="#c.splice_from_pipe_next" title="splice_from_pipe_next"><code class="xref c c-func docutils literal"><span class="pre">splice_from_pipe_next()</span></code></a> and
<a class="reference internal" href="#c.splice_from_pipe_feed" title="splice_from_pipe_feed"><code class="xref c c-func docutils literal"><span class="pre">splice_from_pipe_feed()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.__splice_from_pipe">
ssize_t <code class="descname">__splice_from_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct splice_desc *<em>&nbsp;sd</em>, splice_actor *<em>&nbsp;actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__splice_from_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to given actor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>information to <strong>actor</strong></dd>
<dt><code class="docutils literal"><span class="pre">splice_actor</span> <span class="pre">*</span> <span class="pre">actor</span></code></dt>
<dd>handler that splices the data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function does little more than loop over the pipe and call
<strong>actor</strong> to do the actual moving of a single struct pipe_buffer to
the desired destination. See pipe_to_file, pipe_to_sendpage, or
pipe_to_user.</div></blockquote>
<dl class="function">
<dt id="c.splice_from_pipe">
ssize_t <code class="descname">splice_from_pipe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct file *<em>&nbsp;out</em>, loff_t *<em>&nbsp;ppos</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em>, splice_actor *<em>&nbsp;actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_from_pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>file to splice to</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>position in <strong>out</strong></dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>how many bytes to splice</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
<dt><code class="docutils literal"><span class="pre">splice_actor</span> <span class="pre">*</span> <span class="pre">actor</span></code></dt>
<dd>handler that splices the data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>See __splice_from_pipe. This function locks the pipe inode,
otherwise it’s identical to <a class="reference internal" href="#c.__splice_from_pipe" title="__splice_from_pipe"><code class="xref c c-func docutils literal"><span class="pre">__splice_from_pipe()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.iter_file_splice_write">
ssize_t <code class="descname">iter_file_splice_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct file *<em>&nbsp;out</em>, loff_t *<em>&nbsp;ppos</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iter_file_splice_write" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe info</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>file to write to</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>position in <strong>out</strong></dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to splice</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Will either move or copy pages (determined by <strong>flags</strong> options) from
the given pipe inode to the given file.
This one is -&gt;write_iter-based.</div></blockquote>
<dl class="function">
<dt id="c.generic_splice_sendpage">
ssize_t <code class="descname">generic_splice_sendpage</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct file *<em>&nbsp;out</em>, loff_t *<em>&nbsp;ppos</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_splice_sendpage" title="Permalink to this definition">¶</a></dt>
<dd><p>splice data from a pipe to a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>pipe to splice from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>socket to write to</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>position in <strong>out</strong></dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to splice</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Will send <strong>len</strong> bytes from the pipe to a network socket. No data copying
is involved.</div></blockquote>
<dl class="function">
<dt id="c.splice_direct_to_actor">
ssize_t <code class="descname">splice_direct_to_actor</code><span class="sig-paren">(</span>struct file *<em>&nbsp;in</em>, struct splice_desc *<em>&nbsp;sd</em>, splice_direct_actor *<em>&nbsp;actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.splice_direct_to_actor" title="Permalink to this definition">¶</a></dt>
<dd><p>splices data directly between two non-pipes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>file to splice from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">splice_desc</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>actor information on where to splice to</dd>
<dt><code class="docutils literal"><span class="pre">splice_direct_actor</span> <span class="pre">*</span> <span class="pre">actor</span></code></dt>
<dd>handles the data splicing</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is a special case helper to splice directly between two
points, without requiring an explicit pipe. Internally an allocated
pipe is cached in the process, and reused during the lifetime of
that process.</div></blockquote>
<dl class="function">
<dt id="c.do_splice_direct">
long <code class="descname">do_splice_direct</code><span class="sig-paren">(</span>struct file *<em>&nbsp;in</em>, loff_t *<em>&nbsp;ppos</em>, struct file *<em>&nbsp;out</em>, loff_t *<em>&nbsp;opos</em>, size_t<em>&nbsp;len</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_splice_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>splices data directly between two files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>file to splice from</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>input file offset</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>file to splice to</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">opos</span></code></dt>
<dd>output file offset</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to splice</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>splice modifier flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For use by <code class="xref c c-func docutils literal"><span class="pre">do_sendfile()</span></code>. splice can easily emulate sendfile, but
doing it in the application would incur an extra system call
(splice in + splice out, as compared to just <code class="xref c c-func docutils literal"><span class="pre">sendfile()</span></code>). So this helper
can splice directly through a process-private pipe.</div></blockquote>
</div>
<div class="section" id="pipes-api">
<h2>pipes API<a class="headerlink" href="#pipes-api" title="Permalink to this headline">¶</a></h2>
<p>Pipe interfaces are all for in-kernel (builtin image) use. They are not
exported for use by modules.</p>
<dl class="type">
<dt id="c.pipe_buffer">
struct <code class="descname">pipe_buffer</code><a class="headerlink" href="#c.pipe_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>a linux kernel pipe buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct pipe_buffer {
  struct page * page;
  unsigned int offset;
  unsigned int len;
  const struct pipe_buf_operations * ops;
  unsigned int flags;
  unsigned long private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">page</span></code></dt>
<dd>the page containing the data for the pipe buffer</dd>
<dt><code class="docutils literal"><span class="pre">offset</span></code></dt>
<dd>offset of data inside the <strong>page</strong></dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>length of data inside the <strong>page</strong></dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>operations associated with this buffer. See <strong>pipe_buf_operations</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>pipe buffer flags. See above.</dd>
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>private data owned by the ops.</dd>
</dl>
<dl class="type">
<dt id="c.pipe_inode_info">
struct <code class="descname">pipe_inode_info</code><a class="headerlink" href="#c.pipe_inode_info" title="Permalink to this definition">¶</a></dt>
<dd><p>a linux kernel pipe</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct pipe_inode_info {
  struct mutex mutex;
  wait_queue_head_t wait;
  unsigned int nrbufs;
  unsigned int curbuf;
  unsigned int buffers;
  unsigned int readers;
  unsigned int writers;
  unsigned int files;
  unsigned int waiting_writers;
  unsigned int r_counter;
  unsigned int w_counter;
  struct page * tmp_page;
  struct fasync_struct * fasync_readers;
  struct fasync_struct * fasync_writers;
  struct pipe_buffer * bufs;
  struct user_struct * user;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>mutex protecting the whole thing</dd>
<dt><code class="docutils literal"><span class="pre">wait</span></code></dt>
<dd>reader/writer wait point in case of empty/full pipe</dd>
<dt><code class="docutils literal"><span class="pre">nrbufs</span></code></dt>
<dd>the number of non-empty pipe buffers in this pipe</dd>
<dt><code class="docutils literal"><span class="pre">curbuf</span></code></dt>
<dd>the current pipe buffer entry</dd>
<dt><code class="docutils literal"><span class="pre">buffers</span></code></dt>
<dd>total number of buffers (should be a power of 2)</dd>
<dt><code class="docutils literal"><span class="pre">readers</span></code></dt>
<dd>number of current readers of this pipe</dd>
<dt><code class="docutils literal"><span class="pre">writers</span></code></dt>
<dd>number of current writers of this pipe</dd>
<dt><code class="docutils literal"><span class="pre">files</span></code></dt>
<dd>number of struct file referring this pipe (protected by -&gt;i_lock)</dd>
<dt><code class="docutils literal"><span class="pre">waiting_writers</span></code></dt>
<dd>number of writers blocked waiting for room</dd>
<dt><code class="docutils literal"><span class="pre">r_counter</span></code></dt>
<dd>reader counter</dd>
<dt><code class="docutils literal"><span class="pre">w_counter</span></code></dt>
<dd>writer counter</dd>
<dt><code class="docutils literal"><span class="pre">tmp_page</span></code></dt>
<dd>cached released page</dd>
<dt><code class="docutils literal"><span class="pre">fasync_readers</span></code></dt>
<dd>reader side fasync</dd>
<dt><code class="docutils literal"><span class="pre">fasync_writers</span></code></dt>
<dd>writer side fasync</dd>
<dt><code class="docutils literal"><span class="pre">bufs</span></code></dt>
<dd>the circular array of pipe buffers</dd>
<dt><code class="docutils literal"><span class="pre">user</span></code></dt>
<dd>the user who created this pipe</dd>
</dl>
<dl class="function">
<dt id="c.pipe_buf_get">
void <code class="descname">pipe_buf_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a pipe_buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to get a reference to</dd>
</dl>
<dl class="function">
<dt id="c.pipe_buf_release">
void <code class="descname">pipe_buf_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_release" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a pipe_buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to put a reference to</dd>
</dl>
<dl class="function">
<dt id="c.pipe_buf_confirm">
int <code class="descname">pipe_buf_confirm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_confirm" title="Permalink to this definition">¶</a></dt>
<dd><p>verify contents of the pipe buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to confirm</dd>
</dl>
<dl class="function">
<dt id="c.pipe_buf_steal">
int <code class="descname">pipe_buf_steal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pipe_buf_steal" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to take ownership of a pipe_buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to attempt to steal</dd>
</dl>
<dl class="function">
<dt id="c.generic_pipe_buf_steal">
int <code class="descname">generic_pipe_buf_steal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_steal" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to take ownership of a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal"><span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to attempt to steal</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function attempts to steal the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code> attached to
<strong>buf</strong>. If successful, this function returns 0 and returns with
the page locked. The caller may then reuse the page for whatever
he wishes; the typical use is insertion into a different file
page cache.</div></blockquote>
<dl class="function">
<dt id="c.generic_pipe_buf_get">
void <code class="descname">generic_pipe_buf_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to get a reference to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function grabs an extra reference to <strong>buf</strong>. It’s used in
in the <code class="xref c c-func docutils literal"><span class="pre">tee()</span></code> system call, when we duplicate the buffers in one
pipe into another.</div></blockquote>
<dl class="function">
<dt id="c.generic_pipe_buf_confirm">
int <code class="descname">generic_pipe_buf_confirm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;info</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_confirm" title="Permalink to this definition">¶</a></dt>
<dd><p>verify contents of the pipe buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to confirm</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function does nothing, because the generic pipe code uses
pages that are always good when inserted into the pipe.</div></blockquote>
<dl class="function">
<dt id="c.generic_pipe_buf_release">
void <code class="descname">generic_pipe_buf_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.pipe_inode_info" title="pipe_inode_info">pipe_inode_info</a> *<em>&nbsp;pipe</em>, struct <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer">pipe_buffer</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_pipe_buf_release" title="Permalink to this definition">¶</a></dt>
<dd><p>put a reference to a <a class="reference internal" href="#c.pipe_buffer" title="pipe_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_inode_info</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>the pipe that the buffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pipe_buffer</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to put a reference to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function releases a reference to <strong>buf</strong>.</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../sh/index.html" class="btn btn-neutral float-right" title="SuperH Interfaces Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../crypto/api-samples.html" class="btn btn-neutral" title="Code Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>