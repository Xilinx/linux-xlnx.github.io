

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>11. CEC Kernel Support &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="12. MIPI CSI-2" href="csi2.html" />
    <link rel="prev" title="10. Media Controller devices" href="mc-core.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-common-functions">3. Digital TV Common functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-ring-buffer">4. Digital TV Ring buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-frontend-kabi">5. Digital TV Frontend kABI</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-demux-kabi">6. Digital TV Demux kABI</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#demux-callback-api">7. Demux Callback API</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-conditional-access-kabi">8. Digital TV Conditional Access kABI</a></li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">9. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">10. Media Controller devices</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">11. CEC Kernel Support</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-cec-protocol">11.1. The CEC Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cec-adapter-interface">11.2. CEC Adapter Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-the-low-level-cec-adapter">11.3. Implementing the Low-Level CEC Adapter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-the-interrupt-handler">11.4. Implementing the interrupt handler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-the-high-level-cec-adapter">11.5. Implementing the High-Level CEC Adapter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cec-framework-functions">11.6. CEC framework functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cec-pin-framework">11.7. CEC Pin framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cec-notifier-framework">11.8. CEC Notifier framework</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">12. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
        
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
        
      <li>11. CEC Kernel Support</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/media/kapi/cec-core.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cec-kernel-support">
<h1>11. CEC Kernel Support<a class="headerlink" href="#cec-kernel-support" title="Permalink to this headline">¶</a></h1>
<p>The CEC framework provides a unified kernel interface for use with HDMI CEC
hardware. It is designed to handle a multiple types of hardware (receivers,
transmitters, USB dongles). The framework also gives the option to decide
what to do in the kernel driver and what should be handled by userspace
applications. In addition it integrates the remote control passthrough
feature into the kernel’s remote control framework.</p>
<div class="section" id="the-cec-protocol">
<h2>11.1. The CEC Protocol<a class="headerlink" href="#the-cec-protocol" title="Permalink to this headline">¶</a></h2>
<p>The CEC protocol enables consumer electronic devices to communicate with each
other through the HDMI connection. The protocol uses logical addresses in the
communication. The logical address is strictly connected with the functionality
provided by the device. The TV acting as the communication hub is always
assigned address 0. The physical address is determined by the physical
connection between devices.</p>
<p>The CEC framework described here is up to date with the CEC 2.0 specification.
It is documented in the HDMI 1.4 specification with the new 2.0 bits documented
in the HDMI 2.0 specification. But for most of the features the freely available
HDMI 1.3a specification is sufficient:</p>
<p><a class="reference external" href="http://www.microprocessor.org/HDMISpecification13a.pdf">http://www.microprocessor.org/HDMISpecification13a.pdf</a></p>
</div>
<div class="section" id="cec-adapter-interface">
<h2>11.2. CEC Adapter Interface<a class="headerlink" href="#cec-adapter-interface" title="Permalink to this headline">¶</a></h2>
<p>The struct cec_adapter represents the CEC adapter hardware. It is created by
calling cec_allocate_adapter() and deleted by calling cec_delete_adapter():</p>
<dl class="function">
<dt>
<code class="descname">struct cec_adapter *cec_allocate_adapter(const struct cec_adap_ops *ops, void *priv,</code></dt>
<dt>
<code class="descname">const char *name, u32 caps, u8 available_las);</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<code class="descname">void cec_delete_adapter(struct cec_adapter *adap);</code></dt>
<dd></dd></dl>

<p>To create an adapter you need to pass the following information:</p>
<dl class="docutils">
<dt>ops:</dt>
<dd>adapter operations which are called by the CEC framework and that you
have to implement.</dd>
<dt>priv:</dt>
<dd>will be stored in adap-&gt;priv and can be used by the adapter ops.
Use cec_get_drvdata(adap) to get the priv pointer.</dd>
<dt>name:</dt>
<dd>the name of the CEC adapter. Note: this name will be copied.</dd>
<dt>caps:</dt>
<dd>capabilities of the CEC adapter. These capabilities determine the
capabilities of the hardware and which parts are to be handled
by userspace and which parts are handled by kernelspace. The
capabilities are returned by CEC_ADAP_G_CAPS.</dd>
<dt>available_las:</dt>
<dd>the number of simultaneous logical addresses that this
adapter can handle. Must be 1 &lt;= available_las &lt;= CEC_MAX_LOG_ADDRS.</dd>
</dl>
<p>To obtain the priv pointer use this helper function:</p>
<dl class="function">
<dt>
<code class="descname">void *cec_get_drvdata(const struct cec_adapter *adap);</code></dt>
<dd></dd></dl>

<p>To register the /dev/cecX device node and the remote control device (if
CEC_CAP_RC is set) you call:</p>
<dl class="function">
<dt>
<code class="descname">int cec_register_adapter(struct cec_adapter *adap, struct device *parent);</code></dt>
<dd></dd></dl>

<p>where parent is the parent device.</p>
<p>To unregister the devices call:</p>
<dl class="function">
<dt>
<code class="descname">void cec_unregister_adapter(struct cec_adapter *adap);</code></dt>
<dd></dd></dl>

<p>Note: if cec_register_adapter() fails, then call cec_delete_adapter() to
clean up. But if cec_register_adapter() succeeded, then only call
cec_unregister_adapter() to clean up, never cec_delete_adapter(). The
unregister function will delete the adapter automatically once the last user
of that /dev/cecX device has closed its file handle.</p>
</div>
<div class="section" id="implementing-the-low-level-cec-adapter">
<h2>11.3. Implementing the Low-Level CEC Adapter<a class="headerlink" href="#implementing-the-low-level-cec-adapter" title="Permalink to this headline">¶</a></h2>
<p>The following low-level adapter operations have to be implemented in
your driver:</p>
<dl class="type">
<dt id="c.cec_adap_ops">
struct <code class="descname">cec_adap_ops</code><a class="headerlink" href="#c.cec_adap_ops" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-none"><div class="highlight"><pre><span></span>struct cec_adap_ops
{
        /* Low-level callbacks */
        int (*adap_enable)(struct cec_adapter *adap, bool enable);
        int (*adap_monitor_all_enable)(struct cec_adapter *adap, bool enable);
        int (*adap_log_addr)(struct cec_adapter *adap, u8 logical_addr);
        int (*adap_transmit)(struct cec_adapter *adap, u8 attempts,
                              u32 signal_free_time, struct cec_msg *msg);
        void (*adap_status)(struct cec_adapter *adap, struct seq_file *file);
        void (*adap_free)(struct cec_adapter *adap);

        /* High-level callbacks */
        ...
};
</pre></div>
</div>
<p>The five low-level ops deal with various aspects of controlling the CEC adapter
hardware:</p>
<p>To enable/disable the hardware:</p>
<dl class="function">
<dt>
<code class="descname">int (*adap_enable)(struct cec_adapter *adap, bool enable);</code></dt>
<dd></dd></dl>

<p>This callback enables or disables the CEC hardware. Enabling the CEC hardware
means powering it up in a state where no logical addresses are claimed. This
op assumes that the physical address (adap-&gt;phys_addr) is valid when enable is
true and will not change while the CEC adapter remains enabled. The initial
state of the CEC adapter after calling cec_allocate_adapter() is disabled.</p>
<p>Note that adap_enable must return 0 if enable is false.</p>
<p>To enable/disable the ‘monitor all’ mode:</p>
<dl class="function">
<dt>
<code class="descname">int (*adap_monitor_all_enable)(struct cec_adapter *adap, bool enable);</code></dt>
<dd></dd></dl>

<p>If enabled, then the adapter should be put in a mode to also monitor messages
that not for us. Not all hardware supports this and this function is only
called if the CEC_CAP_MONITOR_ALL capability is set. This callback is optional
(some hardware may always be in ‘monitor all’ mode).</p>
<p>Note that adap_monitor_all_enable must return 0 if enable is false.</p>
<p>To program a new logical address:</p>
<dl class="function">
<dt>
<code class="descname">int (*adap_log_addr)(struct cec_adapter *adap, u8 logical_addr);</code></dt>
<dd></dd></dl>

<p>If logical_addr == CEC_LOG_ADDR_INVALID then all programmed logical addresses
are to be erased. Otherwise the given logical address should be programmed.
If the maximum number of available logical addresses is exceeded, then it
should return -ENXIO. Once a logical address is programmed the CEC hardware
can receive directed messages to that address.</p>
<p>Note that adap_log_addr must return 0 if logical_addr is CEC_LOG_ADDR_INVALID.</p>
<p>To transmit a new message:</p>
<dl class="function">
<dt>
<code class="descname">int (*adap_transmit)(struct cec_adapter *adap, u8 attempts,</code></dt>
<dt>
<code class="descname">u32 signal_free_time, struct cec_msg *msg);</code></dt>
<dd></dd></dl>

<p>This transmits a new message. The attempts argument is the suggested number of
attempts for the transmit.</p>
<p>The signal_free_time is the number of data bit periods that the adapter should
wait when the line is free before attempting to send a message. This value
depends on whether this transmit is a retry, a message from a new initiator or
a new message for the same initiator. Most hardware will handle this
automatically, but in some cases this information is needed.</p>
<p>The CEC_FREE_TIME_TO_USEC macro can be used to convert signal_free_time to
microseconds (one data bit period is 2.4 ms).</p>
<p>To log the current CEC hardware status:</p>
<dl class="function">
<dt>
<code class="descname">void (*adap_status)(struct cec_adapter *adap, struct seq_file *file);</code></dt>
<dd></dd></dl>

<p>This optional callback can be used to show the status of the CEC hardware.
The status is available through debugfs: cat /sys/kernel/debug/cec/cecX/status</p>
<p>To free any resources when the adapter is deleted:</p>
<dl class="function">
<dt>
<code class="descname">void (*adap_free)(struct cec_adapter *adap);</code></dt>
<dd></dd></dl>

<p>This optional callback can be used to free any resources that might have been
allocated by the driver. It’s called from cec_delete_adapter.</p>
<p>Your adapter driver will also have to react to events (typically interrupt
driven) by calling into the framework in the following situations:</p>
<p>When a transmit finished (successfully or otherwise):</p>
<dl class="function">
<dt>
<code class="descname">void cec_transmit_done(struct cec_adapter *adap, u8 status, u8 arb_lost_cnt,</code></dt>
<dt>
<code class="descname">u8 nack_cnt, u8 low_drive_cnt, u8 error_cnt);</code></dt>
<dd></dd></dl>

<p>or:</p>
<dl class="function">
<dt>
<code class="descname">void cec_transmit_attempt_done(struct cec_adapter *adap, u8 status);</code></dt>
<dd></dd></dl>

<p>The status can be one of:</p>
<dl class="docutils">
<dt>CEC_TX_STATUS_OK:</dt>
<dd>the transmit was successful.</dd>
<dt>CEC_TX_STATUS_ARB_LOST:</dt>
<dd>arbitration was lost: another CEC initiator
took control of the CEC line and you lost the arbitration.</dd>
<dt>CEC_TX_STATUS_NACK:</dt>
<dd>the message was nacked (for a directed message) or
acked (for a broadcast message). A retransmission is needed.</dd>
<dt>CEC_TX_STATUS_LOW_DRIVE:</dt>
<dd>low drive was detected on the CEC bus. This indicates that
a follower detected an error on the bus and requested a
retransmission.</dd>
<dt>CEC_TX_STATUS_ERROR:</dt>
<dd>some unspecified error occurred: this can be one of
the previous two if the hardware cannot differentiate or something
else entirely.</dd>
<dt>CEC_TX_STATUS_MAX_RETRIES:</dt>
<dd>could not transmit the message after trying multiple times.
Should only be set by the driver if it has hardware support for
retrying messages. If set, then the framework assumes that it
doesn’t have to make another attempt to transmit the message
since the hardware did that already.</dd>
</dl>
<p>The *_cnt arguments are the number of error conditions that were seen.
This may be 0 if no information is available. Drivers that do not support
hardware retry can just set the counter corresponding to the transmit error
to 1, if the hardware does support retry then either set these counters to
0 if the hardware provides no feedback of which errors occurred and how many
times, or fill in the correct values as reported by the hardware.</p>
<p>The cec_transmit_attempt_done() function is a helper for cases where the
hardware never retries, so the transmit is always for just a single
attempt. It will call cec_transmit_done() in turn, filling in 1 for the
count argument corresponding to the status. Or all 0 if the status was OK.</p>
<p>When a CEC message was received:</p>
<dl class="function">
<dt>
<code class="descname">void cec_received_msg(struct cec_adapter *adap, struct cec_msg *msg);</code></dt>
<dd></dd></dl>

<p>Speaks for itself.</p>
</div>
<div class="section" id="implementing-the-interrupt-handler">
<h2>11.4. Implementing the interrupt handler<a class="headerlink" href="#implementing-the-interrupt-handler" title="Permalink to this headline">¶</a></h2>
<p>Typically the CEC hardware provides interrupts that signal when a transmit
finished and whether it was successful or not, and it provides and interrupt
when a CEC message was received.</p>
<p>The CEC driver should always process the transmit interrupts first before
handling the receive interrupt. The framework expects to see the cec_transmit_done
call before the cec_received_msg call, otherwise it can get confused if the
received message was in reply to the transmitted message.</p>
</div>
<div class="section" id="implementing-the-high-level-cec-adapter">
<h2>11.5. Implementing the High-Level CEC Adapter<a class="headerlink" href="#implementing-the-high-level-cec-adapter" title="Permalink to this headline">¶</a></h2>
<p>The low-level operations drive the hardware, the high-level operations are
CEC protocol driven. The following high-level callbacks are available:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cec_adap_ops {
        /* Low-level callbacks */
        ...

        /* High-level CEC message callback */
        int (*received)(struct cec_adapter *adap, struct cec_msg *msg);
};
</pre></div>
</div>
<p>The received() callback allows the driver to optionally handle a newly
received CEC message</p>
<dl class="function">
<dt>
<code class="descname">int (*received)(struct cec_adapter *adap, struct cec_msg *msg);</code></dt>
<dd></dd></dl>

<p>If the driver wants to process a CEC message, then it can implement this
callback. If it doesn’t want to handle this message, then it should return
-ENOMSG, otherwise the CEC framework assumes it processed this message and
it will not do anything with it.</p>
</div>
<div class="section" id="cec-framework-functions">
<h2>11.6. CEC framework functions<a class="headerlink" href="#cec-framework-functions" title="Permalink to this headline">¶</a></h2>
<p>CEC Adapter drivers can call the following CEC framework functions:</p>
<dl class="function">
<dt>
<code class="descname">int cec_transmit_msg(struct cec_adapter *adap, struct cec_msg *msg,</code></dt>
<dt>
<code class="descname">bool block);</code></dt>
<dd></dd></dl>

<p>Transmit a CEC message. If block is true, then wait until the message has been
transmitted, otherwise just queue it and return.</p>
<dl class="function">
<dt>
<code class="descname">void cec_s_phys_addr(struct cec_adapter *adap, u16 phys_addr,</code></dt>
<dt>
<code class="descname">bool block);</code></dt>
<dd></dd></dl>

<p>Change the physical address. This function will set adap-&gt;phys_addr and
send an event if it has changed. If cec_s_log_addrs() has been called and
the physical address has become valid, then the CEC framework will start
claiming the logical addresses. If block is true, then this function won’t
return until this process has finished.</p>
<p>When the physical address is set to a valid value the CEC adapter will
be enabled (see the adap_enable op). When it is set to CEC_PHYS_ADDR_INVALID,
then the CEC adapter will be disabled. If you change a valid physical address
to another valid physical address, then this function will first set the
address to CEC_PHYS_ADDR_INVALID before enabling the new physical address.</p>
<dl class="function">
<dt>
<code class="descname">void cec_s_phys_addr_from_edid(struct cec_adapter *adap,</code></dt>
<dt>
<code class="descname">const struct edid *edid);</code></dt>
<dd></dd></dl>

<p>A helper function that extracts the physical address from the edid struct
and calls cec_s_phys_addr() with that address, or CEC_PHYS_ADDR_INVALID
if the EDID did not contain a physical address or edid was a NULL pointer.</p>
<dl class="function">
<dt>
<code class="descname">int cec_s_log_addrs(struct cec_adapter *adap,</code></dt>
<dt>
<code class="descname">struct cec_log_addrs *log_addrs, bool block);</code></dt>
<dd></dd></dl>

<p>Claim the CEC logical addresses. Should never be called if CEC_CAP_LOG_ADDRS
is set. If block is true, then wait until the logical addresses have been
claimed, otherwise just queue it and return. To unconfigure all logical
addresses call this function with log_addrs set to NULL or with
log_addrs-&gt;num_log_addrs set to 0. The block argument is ignored when
unconfiguring. This function will just return if the physical address is
invalid. Once the physical address becomes valid, then the framework will
attempt to claim these logical addresses.</p>
</div>
<div class="section" id="cec-pin-framework">
<h2>11.7. CEC Pin framework<a class="headerlink" href="#cec-pin-framework" title="Permalink to this headline">¶</a></h2>
<p>Most CEC hardware operates on full CEC messages where the software provides
the message and the hardware handles the low-level CEC protocol. But some
hardware only drives the CEC pin and software has to handle the low-level
CEC protocol. The CEC pin framework was created to handle such devices.</p>
<p>Note that due to the close-to-realtime requirements it can never be guaranteed
to work 100%. This framework uses highres timers internally, but if a
timer goes off too late by more than 300 microseconds wrong results can
occur. In reality it appears to be fairly reliable.</p>
<p>One advantage of this low-level implementation is that it can be used as
a cheap CEC analyser, especially if interrupts can be used to detect
CEC pin transitions from low to high or vice versa.</p>
<dl class="type">
<dt id="c.cec_pin_ops">
struct <code class="descname">cec_pin_ops</code><a class="headerlink" href="#c.cec_pin_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>low-level CEC pin operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cec_pin_ops {
  bool (* read) (struct cec_adapter *adap);
  void (* low) (struct cec_adapter *adap);
  void (* high) (struct cec_adapter *adap);
  bool (* enable_irq) (struct cec_adapter *adap);
  void (* disable_irq) (struct cec_adapter *adap);
  void (* free) (struct cec_adapter *adap);
  void (* status) (struct cec_adapter *adap, struct seq_file *file);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">read</span></code></dt>
<dd>read the CEC pin. Return true if high, false if low.</dd>
<dt><code class="docutils literal"><span class="pre">low</span></code></dt>
<dd>drive the CEC pin low.</dd>
<dt><code class="docutils literal"><span class="pre">high</span></code></dt>
<dd>stop driving the CEC pin. The pull-up will drive the pin
high, unless someone else is driving the pin low.</dd>
<dt><code class="docutils literal"><span class="pre">enable_irq</span></code></dt>
<dd>optional, enable the interrupt to detect pin voltage changes.</dd>
<dt><code class="docutils literal"><span class="pre">disable_irq</span></code></dt>
<dd>optional, disable the interrupt.</dd>
<dt><code class="docutils literal"><span class="pre">free</span></code></dt>
<dd>optional. Free any allocated resources. Called when the
adapter is deleted.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>optional, log status information.</dd>
</dl>
<p><strong>Description</strong></p>
<p>These operations are used by the cec pin framework to manipulate
the CEC pin.</p>
<dl class="function">
<dt id="c.cec_pin_changed">
void <code class="descname">cec_pin_changed</code><span class="sig-paren">(</span>struct cec_adapter *<em>&nbsp;adap</em>, bool<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_pin_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>update pin state from interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>pointer to the cec adapter</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">value</span></code></dt>
<dd>when true the pin is high, otherwise it is low</dd>
</dl>
<p><strong>Description</strong></p>
<p>If changes of the CEC voltage are detected via an interrupt, then
cec_pin_changed is called from the interrupt with the new value.</p>
<dl class="function">
<dt id="c.cec_pin_allocate_adapter">
struct cec_adapter * <code class="descname">cec_pin_allocate_adapter</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.cec_pin_ops" title="cec_pin_ops">cec_pin_ops</a> *<em>&nbsp;pin_ops</em>, void *<em>&nbsp;priv</em>, const char *<em>&nbsp;name</em>, u32<em>&nbsp;caps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_pin_allocate_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a pin-based cec adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cec_pin_ops</span> <span class="pre">*</span> <span class="pre">pin_ops</span></code></dt>
<dd>low-level pin operations</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>will be stored in adap-&gt;priv and can be used by the adapter ops.
Use cec_get_drvdata(adap) to get the priv pointer.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the CEC adapter. Note: this name will be copied.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">caps</span></code></dt>
<dd>capabilities of the CEC adapter. This will be ORed with
CEC_CAP_MONITOR_ALL and CEC_CAP_MONITOR_PIN.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a cec adapter using the cec pin framework.</p>
<p><strong>Return</strong></p>
<p>a pointer to the cec adapter or an error pointer</p>
</div>
<div class="section" id="cec-notifier-framework">
<h2>11.8. CEC Notifier framework<a class="headerlink" href="#cec-notifier-framework" title="Permalink to this headline">¶</a></h2>
<p>Most drm HDMI implementations have an integrated CEC implementation and no
notifier support is needed. But some have independent CEC implementations
that have their own driver. This could be an IP block for an SoC or a
completely separate chip that deals with the CEC pin. For those cases a
drm driver can install a notifier and use the notifier to inform the
CEC driver about changes in the physical address.</p>
<dl class="function">
<dt id="c.cec_notifier_get">
struct cec_notifier * <code class="descname">cec_notifier_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_get" title="Permalink to this definition">¶</a></dt>
<dd><p>find or create a new cec_notifier for the given device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that sends the events.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a notifier for device <strong>dev</strong> already exists, then increase the refcount
and return that notifier.</p>
<p>If it doesn’t exist, then allocate a new notifier struct and return a
pointer to that new struct.</p>
<p>Return NULL if the memory could not be allocated.</p>
<dl class="function">
<dt id="c.cec_notifier_put">
void <code class="descname">cec_notifier_put</code><span class="sig-paren">(</span>struct cec_notifier *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_put" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease refcount and delete when the refcount reaches 0.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>notifier</dd>
</dl>
<dl class="function">
<dt id="c.cec_notifier_set_phys_addr">
void <code class="descname">cec_notifier_set_phys_addr</code><span class="sig-paren">(</span>struct cec_notifier *<em>&nbsp;n</em>, u16<em>&nbsp;pa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_set_phys_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>set a new physical address.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the CEC notifier</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">pa</span></code></dt>
<dd>the CEC physical address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a new CEC physical address.
Does nothing if <strong>n</strong> == NULL.</p>
<dl class="function">
<dt id="c.cec_notifier_set_phys_addr_from_edid">
void <code class="descname">cec_notifier_set_phys_addr_from_edid</code><span class="sig-paren">(</span>struct cec_notifier *<em>&nbsp;n</em>, const struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_set_phys_addr_from_edid" title="Permalink to this definition">¶</a></dt>
<dd><p>set parse the PA from the EDID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the CEC notifier</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>the struct edid pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Parses the EDID to obtain the new CEC physical address and set it.
Does nothing if <strong>n</strong> == NULL.</p>
<dl class="function">
<dt id="c.cec_notifier_register">
void <code class="descname">cec_notifier_register</code><span class="sig-paren">(</span>struct cec_notifier *<em>&nbsp;n</em>, struct cec_adapter *<em>&nbsp;adap</em>, void (*callback) (struct cec_adapter<em>&nbsp;*adap</em>, u16<em>&nbsp;pa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a callback with the notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the CEC notifier</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>the CEC adapter, passed as argument to the callback function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">cec_adapter</span> <span class="pre">*adap,</span> <span class="pre">u16</span> <span class="pre">pa)</span> <span class="pre">callback</span></code></dt>
<dd>the callback function</dd>
</dl>
<dl class="function">
<dt id="c.cec_notifier_unregister">
void <code class="descname">cec_notifier_unregister</code><span class="sig-paren">(</span>struct cec_notifier *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister the callback from the notifier.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the CEC notifier</dd>
</dl>
<dl class="function">
<dt id="c.cec_register_cec_notifier">
void <code class="descname">cec_register_cec_notifier</code><span class="sig-paren">(</span>struct cec_adapter *<em>&nbsp;adap</em>, struct cec_notifier *<em>&nbsp;notifier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_register_cec_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>register the notifier with the cec adapter.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>the CEC adapter</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*</span> <span class="pre">notifier</span></code></dt>
<dd>the CEC notifier</dd>
</dl>
<dl class="function">
<dt id="c.cec_notifier_phys_addr_invalidate">
void <code class="descname">cec_notifier_phys_addr_invalidate</code><span class="sig-paren">(</span>struct cec_notifier *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cec_notifier_phys_addr_invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>set the physical address to INVALID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cec_notifier</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the CEC notifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simple helper function to invalidate the physical
address. Does nothing if <strong>n</strong> == NULL.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="csi2.html" class="btn btn-neutral float-right" title="12. MIPI CSI-2" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mc-core.html" class="btn btn-neutral" title="10. Media Controller devices" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>