

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1.14. V4L2 videobuf2 functions and data structures &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="1.15. V4L2 clocks" href="v4l2-clocks.html" />
    <link rel="prev" title="1.13. Videobuf Framework" href="v4l2-videobuf.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html">1.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html#structure-of-a-v4l-driver">1.2. Structure of a V4L driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html#structure-of-the-v4l2-framework">1.3. Structure of the V4L2 framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-dev.html">1.4. Video device’ s internal representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-device.html">1.5. V4L2 device instance</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-fh.html">1.6. V4L2 File handlers</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html">1.7. V4L2 sub-devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#v4l2-sub-device-userspace-api">1.8. V4L2 sub-device userspace API</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#i2c-sub-device-drivers">1.9. I2C sub-device drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#v4l2-sub-device-functions-and-data-structures">1.10. V4L2 sub-device functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-event.html">1.11. V4L2 events</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-controls.html">1.12. V4L2 Controls</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-videobuf.html">1.13. Videobuf Framework</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">1.14. V4L2 videobuf2 functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-clocks.html">1.15. V4L2 clocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-dv-timings.html">1.16. V4L2 DV Timings functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-flash-led-class.html">1.17. V4L2 flash functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mc.html">1.18. V4L2 Media Controller functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mediabus.html">1.19. V4L2 Media Bus functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mem2mem.html">1.20. V4L2 Memory to Memory functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-fwnode.html">1.21. V4L2 fwnode kAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-rect.html">1.22. V4L2 rect helper functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-tuner.html">1.23. Tuner functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-common.html">1.24. V4L2 common functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-tveeprom.html">1.25. Hauppauge TV EEPROM functions and data structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-common-functions">3. Digital TV Common functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-ring-buffer">4. Digital TV Ring buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-frontend-kabi">5. Digital TV Frontend kABI</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-demux-kabi">6. Digital TV Demux kABI</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#demux-callback-api">7. Demux Callback API</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html#digital-tv-conditional-access-kabi">8. Digital TV Conditional Access kABI</a></li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">9. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">10. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">11. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">12. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
        
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
        
          <li><a href="v4l2-core.html">1. Video4Linux devices</a> &raquo;</li>
        
      <li>1.14. V4L2 videobuf2 functions and data structures</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/media/kapi/v4l2-videobuf2.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="v4l2-videobuf2-functions-and-data-structures">
<span id="vb2-framework"></span><h1>1.14. V4L2 videobuf2 functions and data structures<a class="headerlink" href="#v4l2-videobuf2-functions-and-data-structures" title="Permalink to this headline">¶</a></h1>
<dl class="type">
<dt id="c.vb2_memory">
enum <code class="descname">vb2_memory</code><a class="headerlink" href="#c.vb2_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>type of memory model used to make the buffers visible on userspace.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VB2_MEMORY_UNKNOWN</span></code></dt>
<dd>Buffer status is unknown or it is not used yet on
userspace.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_MEMORY_MMAP</span></code></dt>
<dd>The buffers are allocated by the Kernel and it is
memory mapped via <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> ioctl. This model is
also used when the user is using the buffers via
<code class="xref c c-func docutils literal"><span class="pre">read()</span></code> or <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> system calls.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_MEMORY_USERPTR</span></code></dt>
<dd>The buffers was allocated in userspace and it is
memory mapped via <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> ioctl.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_MEMORY_DMABUF</span></code></dt>
<dd>The buffers are passed to userspace via DMA buffer.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_mem_ops">
struct <code class="descname">vb2_mem_ops</code><a class="headerlink" href="#c.vb2_mem_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>memory handling/memory allocator operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vb2_mem_ops {
  void *(* alloc) (struct device *dev, unsigned long attrs,unsigned long size,enum dma_data_direction dma_dir, gfp_t gfp_flags);
  void (* put) (void *buf_priv);
  struct dma_buf *(* get_dmabuf) (void *buf_priv, unsigned long flags);
  void *(* get_userptr) (struct device *dev, unsigned long vaddr,unsigned long size, enum dma_data_direction dma_dir);
  void (* put_userptr) (void *buf_priv);
  void (* prepare) (void *buf_priv);
  void (* finish) (void *buf_priv);
  void *(* attach_dmabuf) (struct device *dev,struct dma_buf *dbuf,unsigned long size, enum dma_data_direction dma_dir);
  void (* detach_dmabuf) (void *buf_priv);
  int (* map_dmabuf) (void *buf_priv);
  void (* unmap_dmabuf) (void *buf_priv);
  void *(* vaddr) (void *buf_priv);
  void *(* cookie) (void *buf_priv);
  unsigned int        (* num_users) (void *buf_priv);
  int (* mmap) (void *buf_priv, struct vm_area_struct *vma);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">alloc</span></code></dt>
<dd>allocate video memory and, optionally, allocator private data,
return <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure or a pointer to allocator private,
per-buffer data on success; the returned private structure
will then be passed as <strong>buf_priv</strong> argument to other ops in this
structure. Additional gfp_flags to use when allocating the
are also passed to this operation. These flags are from the
gfp_flags field of vb2_queue.</dd>
<dt><code class="docutils literal"><span class="pre">put</span></code></dt>
<dd>inform the allocator that the buffer will no longer be used;
usually will result in the allocator freeing the buffer (if
no other users of this buffer are present); the <strong>buf_priv</strong>
argument is the allocator private per-buffer structure
previously returned from the alloc callback.</dd>
<dt><code class="docutils literal"><span class="pre">get_dmabuf</span></code></dt>
<dd>acquire userspace memory for a hardware operation; used for
DMABUF memory types.</dd>
<dt><code class="docutils literal"><span class="pre">get_userptr</span></code></dt>
<dd>acquire userspace memory for a hardware operation; used for
USERPTR memory types; vaddr is the address passed to the
videobuf layer when queuing a video buffer of USERPTR type;
should return an allocator private per-buffer structure
associated with the buffer on success, <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure;
the returned private structure will then be passed as <strong>buf_priv</strong>
argument to other ops in this structure.</dd>
<dt><code class="docutils literal"><span class="pre">put_userptr</span></code></dt>
<dd>inform the allocator that a USERPTR buffer will no longer
be used.</dd>
<dt><code class="docutils literal"><span class="pre">prepare</span></code></dt>
<dd>called every time the buffer is passed from userspace to the
driver, useful for cache synchronisation, optional.</dd>
<dt><code class="docutils literal"><span class="pre">finish</span></code></dt>
<dd>called every time the buffer is passed back from the driver
to the userspace, also optional.</dd>
<dt><code class="docutils literal"><span class="pre">attach_dmabuf</span></code></dt>
<dd>attach a shared struct dma_buf for a hardware operation;
used for DMABUF memory types; dev is the alloc device
dbuf is the shared dma_buf; returns <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure;
allocator private per-buffer structure on success;
this needs to be used for further accesses to the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">detach_dmabuf</span></code></dt>
<dd>inform the exporter of the buffer that the current DMABUF
buffer is no longer used; the <strong>buf_priv</strong> argument is the
allocator private per-buffer structure previously returned
from the attach_dmabuf callback.</dd>
<dt><code class="docutils literal"><span class="pre">map_dmabuf</span></code></dt>
<dd>request for access to the dmabuf from allocator; the allocator
of dmabuf is informed that this driver is going to use the
dmabuf.</dd>
<dt><code class="docutils literal"><span class="pre">unmap_dmabuf</span></code></dt>
<dd>releases access control to the dmabuf - allocator is notified
that this driver is done using the dmabuf for now.</dd>
<dt><code class="docutils literal"><span class="pre">vaddr</span></code></dt>
<dd>return a kernel virtual address to a given memory buffer
associated with the passed private structure or NULL if no
such mapping exists.</dd>
<dt><code class="docutils literal"><span class="pre">cookie</span></code></dt>
<dd>return allocator specific cookie for a given memory buffer
associated with the passed private structure or NULL if not
available.</dd>
<dt><code class="docutils literal"><span class="pre">num_users</span></code></dt>
<dd>return the current number of users of a memory buffer;
return 1 if the videobuf layer (or actually the driver using
it) is the only user.</dd>
<dt><code class="docutils literal"><span class="pre">mmap</span></code></dt>
<dd>setup a userspace mapping for a given memory buffer under
the provided virtual memory region.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Those operations are used by the videobuf2 core to implement the memory
handling/memory allocators for each type of supported streaming I/O method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>Required ops for USERPTR types: get_userptr, put_userptr.</li>
<li>Required ops for MMAP types: alloc, put, num_users, mmap.</li>
<li>Required ops for read/write access types: alloc, put, num_users, vaddr.</li>
<li>Required ops for DMABUF types: attach_dmabuf, detach_dmabuf,
map_dmabuf, unmap_dmabuf.</li>
</ol>
</div>
<dl class="type">
<dt id="c.vb2_plane">
struct <code class="descname">vb2_plane</code><a class="headerlink" href="#c.vb2_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>plane information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vb2_plane {
  void * mem_priv;
  struct dma_buf * dbuf;
  unsigned int dbuf_mapped;
  unsigned int bytesused;
  unsigned int length;
  unsigned int min_length;
  union m;
  unsigned int data_offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mem_priv</span></code></dt>
<dd>private data with this plane</dd>
<dt><code class="docutils literal"><span class="pre">dbuf</span></code></dt>
<dd>dma_buf - shared buffer object</dd>
<dt><code class="docutils literal"><span class="pre">dbuf_mapped</span></code></dt>
<dd>flag to show whether dbuf is mapped or not</dd>
<dt><code class="docutils literal"><span class="pre">bytesused</span></code></dt>
<dd>number of bytes occupied by data in the plane (payload)</dd>
<dt><code class="docutils literal"><span class="pre">length</span></code></dt>
<dd>size of this plane (NOT the payload) in bytes</dd>
<dt><code class="docutils literal"><span class="pre">min_length</span></code></dt>
<dd>minimum required size of this plane (NOT the payload) in bytes.
<strong>length</strong> is always greater or equal to <strong>min_length</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">m</span></code></dt>
<dd>Union with memtype-specific data (<strong>offset</strong>, <strong>userptr</strong> or
<strong>fd</strong>).</dd>
<dt><code class="docutils literal"><span class="pre">data_offset</span></code></dt>
<dd>offset in the plane to the start of data; usually 0,
unless there is a header in front of the data
Should contain enough information to be able to cover all the fields
of struct v4l2_plane at videodev2.h</dd>
</dl>
<dl class="type">
<dt id="c.vb2_io_modes">
enum <code class="descname">vb2_io_modes</code><a class="headerlink" href="#c.vb2_io_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>queue access methods</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VB2_MMAP</span></code></dt>
<dd>driver supports MMAP with streaming API</dd>
<dt><code class="docutils literal"><span class="pre">VB2_USERPTR</span></code></dt>
<dd>driver supports USERPTR with streaming API</dd>
<dt><code class="docutils literal"><span class="pre">VB2_READ</span></code></dt>
<dd>driver supports <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> style access</dd>
<dt><code class="docutils literal"><span class="pre">VB2_WRITE</span></code></dt>
<dd>driver supports <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> style access</dd>
<dt><code class="docutils literal"><span class="pre">VB2_DMABUF</span></code></dt>
<dd>driver supports DMABUF with streaming API</dd>
</dl>
<dl class="type">
<dt id="c.vb2_buffer_state">
enum <code class="descname">vb2_buffer_state</code><a class="headerlink" href="#c.vb2_buffer_state" title="Permalink to this definition">¶</a></dt>
<dd><p>current video buffer state</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_DEQUEUED</span></code></dt>
<dd>buffer under userspace control</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_PREPARING</span></code></dt>
<dd>buffer is being prepared in videobuf</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_PREPARED</span></code></dt>
<dd>buffer prepared in videobuf and by the driver</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_QUEUED</span></code></dt>
<dd>buffer queued in videobuf, but not in driver</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_REQUEUEING</span></code></dt>
<dd>re-queue a buffer to the driver</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_ACTIVE</span></code></dt>
<dd>buffer queued in driver and possibly used
in a hardware operation</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_DONE</span></code></dt>
<dd>buffer returned from driver to videobuf, but
not yet dequeued to userspace</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_ERROR</span></code></dt>
<dd>same as above, but the operation on the buffer
has ended with an error, which will be reported
to the userspace when it is dequeued</dd>
</dl>
<dl class="type">
<dt id="c.vb2_buffer">
struct <code class="descname">vb2_buffer</code><a class="headerlink" href="#c.vb2_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a video buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vb2_buffer {
  struct vb2_queue * vb2_queue;
  unsigned int index;
  unsigned int type;
  unsigned int memory;
  unsigned int num_planes;
  struct vb2_plane planes;
  u64 timestamp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vb2_queue</span></code></dt>
<dd>the queue to which this driver belongs</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>id number of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>buffer type</dd>
<dt><code class="docutils literal"><span class="pre">memory</span></code></dt>
<dd>the method, in which the actual data is passed</dd>
<dt><code class="docutils literal"><span class="pre">num_planes</span></code></dt>
<dd>number of planes in the buffer
on an internal driver queue</dd>
<dt><code class="docutils literal"><span class="pre">planes</span></code></dt>
<dd>private per-plane information; do not change</dd>
<dt><code class="docutils literal"><span class="pre">timestamp</span></code></dt>
<dd>frame timestamp in ns</dd>
</dl>
<dl class="type">
<dt id="c.vb2_ops">
struct <code class="descname">vb2_ops</code><a class="headerlink" href="#c.vb2_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>driver-specific callbacks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vb2_ops {
  int (* queue_setup) (struct vb2_queue *q,unsigned int *num_buffers, unsigned int *num_planes, unsigned int sizes[], struct device *alloc_devs[]);
  void (* wait_prepare) (struct vb2_queue *q);
  void (* wait_finish) (struct vb2_queue *q);
  int (* buf_init) (struct vb2_buffer *vb);
  int (* buf_prepare) (struct vb2_buffer *vb);
  void (* buf_finish) (struct vb2_buffer *vb);
  void (* buf_cleanup) (struct vb2_buffer *vb);
  int (* start_streaming) (struct vb2_queue *q, unsigned int count);
  void (* stop_streaming) (struct vb2_queue *q);
  void (* buf_queue) (struct vb2_buffer *vb);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">queue_setup</span></code></dt>
<dd>called from <a class="reference internal" href="../uapi/v4l/vidioc-reqbufs.html#c.VIDIOC_REQBUFS" title="VIDIOC_REQBUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_REQBUFS()</span></code></a> and <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a>
handlers before memory allocation. It can be called
twice: if the original number of requested buffers
could not be allocated, then it will be called a
second time with the actually allocated number of
buffers to verify if that is OK.
The driver should return the required number of buffers
in *num_buffers, the required number of planes per
buffer in *num_planes, the size of each plane should be
set in the sizes[] array and optional per-plane
allocator specific device in the alloc_devs[] array.
When called from <a class="reference internal" href="../uapi/v4l/vidioc-reqbufs.html#c.VIDIOC_REQBUFS" title="VIDIOC_REQBUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_REQBUFS()</span></code></a>, *num_planes == 0,
the driver has to use the currently configured format to
determine the plane sizes and *num_buffers is the total
number of buffers that are being allocated. When called
from <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a>, *num_planes != 0 and it
describes the requested number of planes and sizes[]
contains the requested plane sizes. In this case
*num_buffers are being allocated additionally to
q-&gt;num_buffers. If either *num_planes or the requested
sizes are invalid callback must return <code class="docutils literal"><span class="pre">-EINVAL</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">wait_prepare</span></code></dt>
<dd>release any locks taken while calling vb2 functions;
it is called before an ioctl needs to wait for a new
buffer to arrive; required to avoid a deadlock in
blocking access type.</dd>
<dt><code class="docutils literal"><span class="pre">wait_finish</span></code></dt>
<dd>reacquire all locks released in the previous callback;
required to continue operation after sleeping while
waiting for a new buffer to arrive.</dd>
<dt><code class="docutils literal"><span class="pre">buf_init</span></code></dt>
<dd>called once after allocating a buffer (in MMAP case)
or after acquiring a new USERPTR buffer; drivers may
perform additional buffer-related initialization;
initialization failure (return != 0) will prevent
queue setup from completing successfully; optional.</dd>
<dt><code class="docutils literal"><span class="pre">buf_prepare</span></code></dt>
<dd>called every time the buffer is queued from userspace
and from the <a class="reference internal" href="../uapi/v4l/vidioc-prepare-buf.html#c.VIDIOC_PREPARE_BUF" title="VIDIOC_PREPARE_BUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_PREPARE_BUF()</span></code></a> ioctl; drivers may
perform any initialization required before each
hardware operation in this callback; drivers can
access/modify the buffer here as it is still synced for
the CPU; drivers that support <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a> must
also validate the buffer size; if an error is returned,
the buffer will not be queued in driver; optional.</dd>
<dt><code class="docutils literal"><span class="pre">buf_finish</span></code></dt>
<dd>called before every dequeue of the buffer back to
userspace; the buffer is synced for the CPU, so drivers
can access/modify the buffer contents; drivers may
perform any operations required before userspace
accesses the buffer; optional. The buffer state can be
one of the following: <code class="docutils literal"><span class="pre">DONE</span></code> and <code class="docutils literal"><span class="pre">ERROR</span></code> occur while
streaming is in progress, and the <code class="docutils literal"><span class="pre">PREPARED</span></code> state occurs
when the queue has been canceled and all pending
buffers are being returned to their default <code class="docutils literal"><span class="pre">DEQUEUED</span></code>
state. Typically you only have to do something if the
state is <code class="docutils literal"><span class="pre">VB2_BUF_STATE_DONE</span></code>, since in all other cases
the buffer contents will be ignored anyway.</dd>
<dt><code class="docutils literal"><span class="pre">buf_cleanup</span></code></dt>
<dd>called once before the buffer is freed; drivers may
perform any additional cleanup; optional.</dd>
<dt><code class="docutils literal"><span class="pre">start_streaming</span></code></dt>
<dd>called once to enter ‘streaming’ state; the driver may
receive buffers with <strong>buf_queue</strong> callback
before <strong>start_streaming</strong> is called; the driver gets the
number of already queued buffers in count parameter;
driver can return an error if hardware fails, in that
case all buffers that have been already given by
the <strong>buf_queue</strong> callback are to be returned by the driver
by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal"><span class="pre">vb2_buffer_done()</span></code></a> with <code class="docutils literal"><span class="pre">VB2_BUF_STATE_QUEUED</span></code>.
If you need a minimum number of buffers before you can
start streaming, then set <strong>min_buffers_needed</strong> in the
vb2_queue structure. If that is non-zero then
<strong>start_streaming</strong> won’t be called until at least that
many buffers have been queued up by userspace.</dd>
<dt><code class="docutils literal"><span class="pre">stop_streaming</span></code></dt>
<dd>called when ‘streaming’ state must be disabled; driver
should stop any DMA transactions or wait until they
finish and give back all buffers it got from <code class="xref c c-type docutils literal"><span class="pre">buf_queue</span></code>
callback by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal"><span class="pre">vb2_buffer_done()</span></code></a> with either
<code class="docutils literal"><span class="pre">VB2_BUF_STATE_DONE</span></code> or <code class="docutils literal"><span class="pre">VB2_BUF_STATE_ERROR</span></code>; may use
<a class="reference internal" href="#c.vb2_wait_for_all_buffers" title="vb2_wait_for_all_buffers"><code class="xref c c-func docutils literal"><span class="pre">vb2_wait_for_all_buffers()</span></code></a> function</dd>
<dt><code class="docutils literal"><span class="pre">buf_queue</span></code></dt>
<dd>passes buffer vb to the driver; driver may start
hardware operation on this buffer; driver should give
the buffer back by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal"><span class="pre">vb2_buffer_done()</span></code></a> function;
it is allways called after calling <a class="reference internal" href="../uapi/v4l/vidioc-streamon.html#c.VIDIOC_STREAMON" title="VIDIOC_STREAMON"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_STREAMON()</span></code></a>
ioctl; might be called before <strong>start_streaming</strong> callback
if user pre-queued buffers before calling
<a class="reference internal" href="../uapi/v4l/vidioc-streamon.html#c.VIDIOC_STREAMON" title="VIDIOC_STREAMON"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_STREAMON()</span></code></a>.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_buf_ops">
struct <code class="descname">vb2_buf_ops</code><a class="headerlink" href="#c.vb2_buf_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>driver-specific callbacks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vb2_buf_ops {
  int (* verify_planes_array) (struct vb2_buffer *vb, const void *pb);
  void (* fill_user_buffer) (struct vb2_buffer *vb, void *pb);
  int (* fill_vb2_buffer) (struct vb2_buffer *vb, const void *pb, struct vb2_plane *planes);
  void (* copy_timestamp) (struct vb2_buffer *vb, const void *pb);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">verify_planes_array</span></code></dt>
<dd>Verify that a given user space structure contains
enough planes for the buffer. This is called
for each dequeued buffer.</dd>
<dt><code class="docutils literal"><span class="pre">fill_user_buffer</span></code></dt>
<dd>given a vb2_buffer fill in the userspace structure.
For V4L2 this is a struct v4l2_buffer.</dd>
<dt><code class="docutils literal"><span class="pre">fill_vb2_buffer</span></code></dt>
<dd>given a userspace structure, fill in the vb2_buffer.
If the userspace structure is invalid, then this op
will return an error.</dd>
<dt><code class="docutils literal"><span class="pre">copy_timestamp</span></code></dt>
<dd>copy the timestamp from a userspace structure to
the vb2_buffer struct.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_queue">
struct <code class="descname">vb2_queue</code><a class="headerlink" href="#c.vb2_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>a videobuf queue</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vb2_queue {
  unsigned int type;
  unsigned int io_modes;
  struct device * dev;
  unsigned long dma_attrs;
  unsigned bidirectional:1;
  unsigned fileio_read_once:1;
  unsigned fileio_write_immediately:1;
  unsigned allow_zero_bytesused:1;
  unsigned quirk_poll_must_check_waiting_for_buffers:1;
  struct mutex * lock;
  void * owner;
  const struct vb2_ops * ops;
  const struct vb2_mem_ops * mem_ops;
  const struct vb2_buf_ops * buf_ops;
  void * drv_priv;
  unsigned int buf_struct_size;
  u32 timestamp_flags;
  gfp_t gfp_flags;
  u32 min_buffers_needed;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>private buffer type whose content is defined by the vb2-core
caller. For example, for V4L2, it should match
the types defined on enum <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buf_type</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">io_modes</span></code></dt>
<dd>supported io methods (see vb2_io_modes enum)</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>device to use for the default allocation context if the driver
doesn’t fill in the <strong>alloc_devs</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">dma_attrs</span></code></dt>
<dd>DMA attributes to use for the DMA.</dd>
<dt><code class="docutils literal"><span class="pre">bidirectional</span></code></dt>
<dd>when this flag is set the DMA direction for the buffers of
this queue will be overridden with DMA_BIDIRECTIONAL direction.
This is useful in cases where the hardware (firmware) writes to
a buffer which is mapped as read (DMA_TO_DEVICE), or reads from
buffer which is mapped for write (DMA_FROM_DEVICE) in order
to satisfy some internal hardware restrictions or adds a padding
needed by the processing algorithm. In case the DMA mapping is
not bidirectional but the hardware (firmware) trying to access
the buffer (in the opposite direction) this could lead to an
IOMMU protection faults.</dd>
<dt><code class="docutils literal"><span class="pre">fileio_read_once</span></code></dt>
<dd>report EOF after reading the first buffer</dd>
<dt><code class="docutils literal"><span class="pre">fileio_write_immediately</span></code></dt>
<dd>queue buffer after each <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> call</dd>
<dt><code class="docutils literal"><span class="pre">allow_zero_bytesused</span></code></dt>
<dd>allow bytesused == 0 to be passed to the driver</dd>
<dt><code class="docutils literal"><span class="pre">quirk_poll_must_check_waiting_for_buffers</span></code></dt>
<dd>Return POLLERR at poll when QBUF
has not been called. This is a vb1 idiom that has been adopted
also by vb2.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to a mutex that protects the vb2_queue struct. The
driver can set this to a mutex to let the v4l2 core serialize
the queuing ioctls. If the driver wants to handle locking
itself, then this should be set to NULL. This lock is not used
by the videobuf2 core API.</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>The filehandle that ‘owns’ the buffers, i.e. the filehandle
that called reqbufs, create_buffers or started fileio.
This field is not used by the videobuf2 core API, but it allows
drivers to easily associate an owner filehandle with the queue.</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>driver-specific callbacks</dd>
<dt><code class="docutils literal"><span class="pre">mem_ops</span></code></dt>
<dd>memory allocator specific callbacks</dd>
<dt><code class="docutils literal"><span class="pre">buf_ops</span></code></dt>
<dd>callbacks to deliver buffer information
between user-space and kernel-space</dd>
<dt><code class="docutils literal"><span class="pre">drv_priv</span></code></dt>
<dd>driver private data</dd>
<dt><code class="docutils literal"><span class="pre">buf_struct_size</span></code></dt>
<dd>size of the driver-specific buffer structure;
“0” indicates the driver doesn’t want to use a custom buffer
structure type. for example, sizeof(struct vb2_v4l2_buffer)
will be used for v4l2.</dd>
<dt><code class="docutils literal"><span class="pre">timestamp_flags</span></code></dt>
<dd>Timestamp flags; V4L2_BUF_FLAG_TIMESTAMP_* and
V4L2_BUF_FLAG_TSTAMP_SRC_*</dd>
<dt><code class="docutils literal"><span class="pre">gfp_flags</span></code></dt>
<dd>additional gfp flags used when allocating the buffers.
Typically this is 0, but it may be e.g. GFP_DMA or __GFP_DMA32
to force the buffer allocation to a specific memory zone.</dd>
<dt><code class="docutils literal"><span class="pre">min_buffers_needed</span></code></dt>
<dd>the minimum number of buffers needed before
<strong>start_streaming</strong> can be called. Used when a DMA engine
cannot be started unless at least this number of buffers
have been queued into the driver.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_plane_vaddr">
void * <code class="descname">vb2_plane_vaddr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_vaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a kernel virtual address of a given plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>vb2_buffer to which the plane in question belongs to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which the address is to be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a kernel virtual address of a given plane if
such a mapping exist, NULL otherwise.</p>
<dl class="function">
<dt id="c.vb2_plane_cookie">
void * <code class="descname">vb2_plane_cookie</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Return allocator specific cookie for the given plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>vb2_buffer to which the plane in question belongs to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which the cookie is to be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns an allocator specific cookie for a given plane if
available, NULL otherwise. The allocator should provide some simple static
inline function, which would convert this cookie to the allocator specific
type that can be used directly by the driver to access the buffer. This can
be for example physical address, pointer to scatter list or IOMMU mapping.</p>
<dl class="function">
<dt id="c.vb2_buffer_done">
void <code class="descname">vb2_buffer_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, enum <a class="reference internal" href="#c.vb2_buffer_state" title="vb2_buffer_state">vb2_buffer_state</a><em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_buffer_done" title="Permalink to this definition">¶</a></dt>
<dd><p>inform videobuf that an operation on a buffer is finished</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>vb2_buffer returned from the driver</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vb2_buffer_state</span> <span class="pre">state</span></code></dt>
<dd>either <code class="docutils literal"><span class="pre">VB2_BUF_STATE_DONE</span></code> if the operation finished
successfully, <code class="docutils literal"><span class="pre">VB2_BUF_STATE_ERROR</span></code> if the operation finished
with an error or <code class="docutils literal"><span class="pre">VB2_BUF_STATE_QUEUED</span></code> if the driver wants to
requeue buffers. If start_streaming fails then it should return
buffers with state <code class="docutils literal"><span class="pre">VB2_BUF_STATE_QUEUED</span></code> to put them back into
the queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by the driver after a hardware operation on
a buffer is finished and the buffer may be returned to userspace. The driver
cannot use this buffer anymore until it is queued back to it by videobuf
by the means of <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> callback. Only buffers previously queued
to the driver by <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> can be passed to this function.</p>
<p>While streaming a buffer can only be returned in state DONE or ERROR.
The start_streaming op can also return them in case the DMA engine cannot
be started for some reason. In that case the buffers should be returned with
state QUEUED.</p>
<dl class="function">
<dt id="c.vb2_discard_done">
void <code class="descname">vb2_discard_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_discard_done" title="Permalink to this definition">¶</a></dt>
<dd><p>discard all buffers marked as DONE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is intended to be used with suspend/resume operations. It
discards all ‘done’ buffers as they would be too old to be requested after
resume.</p>
<p>Drivers must stop the hardware and synchronize with interrupt handlers and/or
delayed works before calling this function to make sure no buffer will be
touched by the driver and/or hardware.</p>
<dl class="function">
<dt id="c.vb2_wait_for_all_buffers">
int <code class="descname">vb2_wait_for_all_buffers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_wait_for_all_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until all buffers are given back to vb2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will wait until all buffers that have been given to the driver
by <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> are given back to vb2 with <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal"><span class="pre">vb2_buffer_done()</span></code></a>. It
doesn’t call <code class="xref c c-func docutils literal"><span class="pre">wait_prepare()</span></code>/<code class="xref c c-func docutils literal"><span class="pre">wait_finish()</span></code> pair. It is intended to be called
with all locks taken, for example from <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;stop_streaming</span></code></a> callback.</p>
<dl class="function">
<dt id="c.vb2_core_querybuf">
void <code class="descname">vb2_core_querybuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int<em>&nbsp;index</em>, void *<em>&nbsp;pb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_querybuf" title="Permalink to this definition">¶</a></dt>
<dd><p>query video buffer information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>id number of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pb</span></code></dt>
<dd>buffer struct passed from userspace</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_querybuf ioctl handler in driver.
The passed buffer should have been verified.
This function fills the relevant information for the userspace.</p>
<dl class="function">
<dt id="c.vb2_core_reqbufs">
int <code class="descname">vb2_core_reqbufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em>&nbsp;memory</em>, unsigned int *<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_reqbufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt>
<dd>memory type</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">count</span></code></dt>
<dd>requested buffer count</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_reqbufs ioctl handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies streaming parameters passed from the userspace,</li>
<li>sets up the queue,</li>
<li>negotiates number of buffers and planes per buffer with the driver
to be used during streaming,</li>
<li>allocates internal buffer structures (struct vb2_buffer), according to
the agreed parameters,</li>
<li>for MMAP memory type, allocates actual video memory, using the
memory handling/allocation routines provided during queue initialization</li>
</ol>
<p>If req-&gt;count is 0, all the memory will be freed instead.
If the queue has been allocated previously (by a previous vb2_reqbufs) call
and the queue is not busy, memory will be reallocated.</p>
<p>The return values from this function are intended to be directly returned
from vidioc_reqbufs handler in driver.</p>
<dl class="function">
<dt id="c.vb2_core_create_bufs">
int <code class="descname">vb2_core_create_bufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em>&nbsp;memory</em>, unsigned int *<em>&nbsp;count</em>, unsigned int<em>&nbsp;requested_planes</em>, const unsigned int<em>&nbsp;requested_sizes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_create_bufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate buffers and any required auxiliary structs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt>
<dd>memory type</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">count</span></code></dt>
<dd>requested buffer count</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">requested_planes</span></code></dt>
<dd>number of planes requested</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">requested_sizes</span></code></dt>
<dd>array with the size of the planes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a> ioctl handler of a driver.
This function:</p>
<ol class="arabic simple">
<li>verifies parameter sanity</li>
<li>calls the .:c:func:<cite>queue_setup()</cite> queue operation</li>
<li>performs any necessary memory allocations</li>
</ol>
<p><strong>Return</strong></p>
<p>the return values from this function are intended to be directly
returned from <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a> handler in driver.</p>
<dl class="function">
<dt id="c.vb2_core_prepare_buf">
int <code class="descname">vb2_core_prepare_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int<em>&nbsp;index</em>, void *<em>&nbsp;pb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_prepare_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass ownership of a buffer from userspace to the kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>id number of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pb</span></code></dt>
<dd>buffer structure passed from userspace to vidioc_prepare_buf
handler in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_prepare_buf ioctl handler of a driver.
The passed buffer should have been verified.
This function calls buf_prepare callback in the driver (if provided),
in which driver-specific buffer initialization can be performed,</p>
<p>The return values from this function are intended to be directly returned
from vidioc_prepare_buf handler in driver.</p>
<dl class="function">
<dt id="c.vb2_core_qbuf">
int <code class="descname">vb2_core_qbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int<em>&nbsp;index</em>, void *<em>&nbsp;pb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_qbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a buffer from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>id number of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pb</span></code></dt>
<dd>buffer structure passed from userspace to vidioc_qbuf handler
in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_qbuf ioctl handler of a driver.
The passed buffer should have been verified.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>if necessary, calls buf_prepare callback in the driver (if provided), in
which driver-specific buffer initialization can be performed,</li>
<li>if streaming is on, queues the buffer in driver by the means of
<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> callback for processing.</li>
</ol>
<p>The return values from this function are intended to be directly returned
from vidioc_qbuf handler in driver.</p>
<dl class="function">
<dt id="c.vb2_core_dqbuf">
int <code class="descname">vb2_core_dqbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int *<em>&nbsp;pindex</em>, void *<em>&nbsp;pb</em>, bool<em>&nbsp;nonblocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_dqbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue a buffer to the userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">pindex</span></code></dt>
<dd>pointer to the buffer index. May be NULL</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pb</span></code></dt>
<dd>buffer structure passed from userspace to vidioc_dqbuf handler
in driver</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">nonblocking</span></code></dt>
<dd>if true, this call will not sleep waiting for a buffer if no
buffers ready for dequeuing are present. Normally the driver
would be passing (file-&gt;f_flags &amp; O_NONBLOCK) here</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_dqbuf ioctl handler of a driver.
The passed buffer should have been verified.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>calls buf_finish callback in the driver (if provided), in which
driver can perform any additional operations that may be required before
returning the buffer to userspace, such as cache sync,</li>
<li>the buffer struct members are filled with relevant information for
the userspace.</li>
</ol>
<p>The return values from this function are intended to be directly returned
from vidioc_dqbuf handler in driver.</p>
<dl class="function">
<dt id="c.vb2_core_expbuf">
int <code class="descname">vb2_core_expbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, int *<em>&nbsp;fd</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;index</em>, unsigned int<em>&nbsp;plane</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_expbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a buffer as a file descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">fd</span></code></dt>
<dd>file descriptor associated with DMABUF (set by driver) *</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>buffer type</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>id number of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>index of the plane to be exported, 0 for single plane queues</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags for newly created file, currently only O_CLOEXEC is
supported, refer to manual of open syscall for more details</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return values from this function are intended to be directly returned
from vidioc_expbuf handler in driver.</p>
<dl class="function">
<dt id="c.vb2_core_queue_init">
int <code class="descname">vb2_core_queue_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_queue_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a videobuf2 queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue; this structure should be allocated in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vb2_queue structure should be allocated by the driver. The driver is
responsible of clearing it’s content and setting initial values for some
required entries before calling this function.
q-&gt;ops, q-&gt;mem_ops, q-&gt;type and q-&gt;io_modes are mandatory. Please refer
to the struct vb2_queue description in include/media/videobuf2-core.h
for more information.</p>
<dl class="function">
<dt id="c.vb2_core_queue_release">
void <code class="descname">vb2_core_queue_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_queue_release" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming, release the queue and free memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stops streaming and performs necessary clean ups, including
freeing video buffer memory. The driver is responsible for freeing
the vb2_queue structure itself.</p>
<dl class="function">
<dt id="c.vb2_queue_error">
void <code class="descname">vb2_queue_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_error" title="Permalink to this definition">¶</a></dt>
<dd><p>signal a fatal error on the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flag that a fatal unrecoverable error has occurred and wake up all processes
waiting on the queue. Polling will now set POLLERR and queuing and dequeuing
buffers will return -EIO.</p>
<p>The error flag will be cleared when cancelling the queue, either from
vb2_streamoff or vb2_queue_release. Drivers should thus not call this
function before starting the stream, otherwise the error flag will remain set
until the queue is released when closing the device node.</p>
<dl class="function">
<dt id="c.vb2_mmap">
int <code class="descname">vb2_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map video buffers into application address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma passed to the mmap file operation handler in the driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from mmap file operation handler of a driver.
This function maps one plane of one of the available video buffers to
userspace. To map whole video memory allocated on reqbufs, this function
has to be called once per each plane per each buffer previously allocated.</p>
<p>When the userspace application calls mmap, it passes to it an offset returned
to it earlier by the means of vidioc_querybuf handler. That offset acts as
a “cookie”, which is then used to identify the plane to be mapped.
This function finds a plane with a matching offset and a mapping is performed
by the means of a provided memory operation.</p>
<p>The return values from this function are intended to be directly returned
from the mmap handler in driver.</p>
<dl class="function">
<dt id="c.vb2_core_poll">
unsigned int <code class="descname">vb2_core_poll</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct file *<em>&nbsp;file</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>implements poll userspace operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file argument passed to the poll file operation handler</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>wait argument passed to the poll file operation handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements poll file operation handler for a driver.
For CAPTURE queues, if a buffer is ready to be dequeued, the userspace will
be informed that the file descriptor of a video device is available for
reading.
For OUTPUT queues, if a buffer is ready to be dequeued, the file descriptor
will be reported as available for writing.</p>
<p>The return values from this function are intended to be directly returned
from poll handler in driver.</p>
<dl class="type">
<dt id="c.vb2_thread_fnc">
<code class="descname">vb2_thread_fnc</code><a class="headerlink" href="#c.vb2_thread_fnc" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: callback function for use with vb2_thread</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">int</span> <span class="pre">vb2_thread_fnc</span> <span class="pre">(struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv);</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">vb2_buffer</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>pointer to a private pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called whenever a buffer is dequeued in the thread.</p>
<dl class="function">
<dt id="c.vb2_thread_start">
int <code class="descname">vb2_thread_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, <a class="reference internal" href="#c.vb2_thread_fnc" title="vb2_thread_fnc">vb2_thread_fnc</a><em>&nbsp;fnc</em>, void *<em>&nbsp;priv</em>, const char *<em>&nbsp;thread_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_thread_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start a thread for the given queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
<dt><code class="docutils literal"><span class="pre">vb2_thread_fnc</span> <span class="pre">fnc</span></code></dt>
<dd>callback function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>priv pointer passed to the callback function</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">thread_name</span></code></dt>
<dd>the name of the thread. This will be prefixed with “vb2-“.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This starts a thread that will queue and dequeue until an error occurs
or <strong>vb2_thread_stop</strong> is called.</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">This function should not be used for anything else but the videobuf2-dvb
support. If you think you have another good use-case for this, then please
contact the linux-media mailing list first.</p>
</div>
<dl class="function">
<dt id="c.vb2_thread_stop">
int <code class="descname">vb2_thread_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_thread_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the thread for the given queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
</dl>
<dl class="function">
<dt id="c.vb2_is_streaming">
bool <code class="descname">vb2_is_streaming</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_is_streaming" title="Permalink to this definition">¶</a></dt>
<dd><p>return streaming status of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
</dl>
<dl class="function">
<dt id="c.vb2_fileio_is_active">
bool <code class="descname">vb2_fileio_is_active</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_fileio_is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if fileio is active.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns true if <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> or <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> is used to stream the data
as opposed to stream I/O. This is almost never an important distinction,
except in rare cases. One such case is that using <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> or <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> to
stream a format using V4L2_FIELD_ALTERNATE is not allowed since there
is no way you can pass the field information of each buffer to/from
userspace. A driver that supports this field format should check for
this in the queue_setup op and reject it if this function returns true.</p>
<dl class="function">
<dt id="c.vb2_is_busy">
bool <code class="descname">vb2_is_busy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_is_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>return busy status of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks if queue has any buffers allocated.</p>
<dl class="function">
<dt id="c.vb2_get_drv_priv">
void * <code class="descname">vb2_get_drv_priv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_drv_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>return driver private data associated with the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
</dl>
<dl class="function">
<dt id="c.vb2_set_plane_payload">
void <code class="descname">vb2_set_plane_payload</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_set_plane_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>set bytesused for the plane plane_no</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>buffer for which plane payload should be set</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which payload should be set</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>payload in bytes</dd>
</dl>
<dl class="function">
<dt id="c.vb2_get_plane_payload">
unsigned long <code class="descname">vb2_get_plane_payload</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_plane_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>get bytesused for the plane plane_no</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>buffer for which plane payload should be set</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which payload should be set</dd>
</dl>
<dl class="function">
<dt id="c.vb2_plane_size">
unsigned long <code class="descname">vb2_plane_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_size" title="Permalink to this definition">¶</a></dt>
<dd><p>return plane size in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>buffer for which plane size should be returned</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which size should be returned</dd>
</dl>
<dl class="function">
<dt id="c.vb2_start_streaming_called">
bool <code class="descname">vb2_start_streaming_called</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_start_streaming_called" title="Permalink to this definition">¶</a></dt>
<dd><p>return streaming status of driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
</dl>
<dl class="function">
<dt id="c.vb2_clear_last_buffer_dequeued">
void <code class="descname">vb2_clear_last_buffer_dequeued</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_clear_last_buffer_dequeued" title="Permalink to this definition">¶</a></dt>
<dd><p>clear last buffer dequeued flag of queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
</dl>
<dl class="function">
<dt id="c.vb2_buffer_in_use">
bool <code class="descname">vb2_buffer_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_buffer_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the buffer is in use and the queue cannot be freed (by the means of REQBUFS(0)) call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>buffer for which plane size should be returned</dd>
</dl>
<dl class="function">
<dt id="c.vb2_verify_memory_type">
int <code class="descname">vb2_verify_memory_type</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em>&nbsp;memory</em>, unsigned int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_verify_memory_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the memory type and buffer type passed to a buffer operation are compatible with the queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf queue</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt>
<dd>memory model, as defined by enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory"><code class="xref c c-type docutils literal"><span class="pre">vb2_memory</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>private buffer type whose content is defined by the vb2-core
caller. For example, for V4L2, it should match
the types defined on enum <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buf_type</span></code></a></dd>
</dl>
<dl class="type">
<dt id="c.vb2_v4l2_buffer">
struct <code class="descname">vb2_v4l2_buffer</code><a class="headerlink" href="#c.vb2_v4l2_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>video buffer information for v4l2</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vb2_v4l2_buffer {
  struct vb2_buffer vb2_buf;
  __u32 flags;
  __u32 field;
  struct v4l2_timecode timecode;
  __u32 sequence;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vb2_buf</span></code></dt>
<dd>video buffer 2</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>buffer informational flags</dd>
<dt><code class="docutils literal"><span class="pre">field</span></code></dt>
<dd>enum v4l2_field; field order of the image in the buffer</dd>
<dt><code class="docutils literal"><span class="pre">timecode</span></code></dt>
<dd>frame timecode</dd>
<dt><code class="docutils literal"><span class="pre">sequence</span></code></dt>
<dd>sequence count of this frame</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should contain enough information to be able to cover all the fields
of struct v4l2_buffer at videodev2.h</p>
<dl class="function">
<dt id="c.vb2_reqbufs">
int <code class="descname">vb2_reqbufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/vidioc-reqbufs.html#c.v4l2_requestbuffers" title="v4l2_requestbuffers">v4l2_requestbuffers</a> *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_reqbufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#c.vb2_core_reqbufs" title="vb2_core_reqbufs"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_reqbufs()</span></code></a> that also verifies the memory and type values.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_requestbuffers</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>struct passed from userspace to vidioc_reqbufs handler
in driver</dd>
</dl>
<dl class="function">
<dt id="c.vb2_create_bufs">
int <code class="descname">vb2_create_bufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.v4l2_create_buffers" title="v4l2_create_buffers">v4l2_create_buffers</a> *<em>&nbsp;create</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_create_bufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#c.vb2_core_create_bufs" title="vb2_core_create_bufs"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_create_bufs()</span></code></a> that also verifies the memory and type values.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_create_buffers</span> <span class="pre">*</span> <span class="pre">create</span></code></dt>
<dd>creation parameters, passed from userspace to vidioc_create_bufs
handler in driver</dd>
</dl>
<dl class="function">
<dt id="c.vb2_prepare_buf">
int <code class="descname">vb2_prepare_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buffer" title="v4l2_buffer">v4l2_buffer</a> *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_prepare_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass ownership of a buffer from userspace to the kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>buffer structure passed from userspace to vidioc_prepare_buf
handler in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_prepare_buf ioctl handler of a driver.
This function:</p>
<ol class="arabic simple">
<li>verifies the passed buffer,</li>
<li>calls buf_prepare callback in the driver (if provided), in which
driver-specific buffer initialization can be performed.</li>
</ol>
<p>The return values from this function are intended to be directly returned
from vidioc_prepare_buf handler in driver.</p>
<dl class="function">
<dt id="c.vb2_qbuf">
int <code class="descname">vb2_qbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buffer" title="v4l2_buffer">v4l2_buffer</a> *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_qbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a buffer from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>buffer structure passed from userspace to <a class="reference internal" href="../uapi/v4l/vidioc-qbuf.html#c.VIDIOC_QBUF" title="VIDIOC_QBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QBUF()</span></code></a> handler
in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="../uapi/v4l/vidioc-qbuf.html#c.VIDIOC_QBUF" title="VIDIOC_QBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QBUF()</span></code></a> ioctl handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies the passed buffer,</li>
<li>if necessary, calls buf_prepare callback in the driver (if provided), in
which driver-specific buffer initialization can be performed,</li>
<li>if streaming is on, queues the buffer in driver by the means of buf_queue
callback for processing.</li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="../uapi/v4l/vidioc-qbuf.html#c.VIDIOC_QBUF" title="VIDIOC_QBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QBUF()</span></code></a> handler in driver.</p>
<dl class="function">
<dt id="c.vb2_expbuf">
int <code class="descname">vb2_expbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/vidioc-expbuf.html#c.v4l2_exportbuffer" title="v4l2_exportbuffer">v4l2_exportbuffer</a> *<em>&nbsp;eb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_expbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a buffer as a file descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_exportbuffer</span> <span class="pre">*</span> <span class="pre">eb</span></code></dt>
<dd>export buffer structure passed from userspace to <a class="reference internal" href="../uapi/v4l/vidioc-expbuf.html#c.VIDIOC_EXPBUF" title="VIDIOC_EXPBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_EXPBUF()</span></code></a>
handler in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="../uapi/v4l/vidioc-expbuf.html#c.VIDIOC_EXPBUF" title="VIDIOC_EXPBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_EXPBUF()</span></code></a> handler in driver.</p>
<dl class="function">
<dt id="c.vb2_dqbuf">
int <code class="descname">vb2_dqbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buffer" title="v4l2_buffer">v4l2_buffer</a> *<em>&nbsp;b</em>, bool<em>&nbsp;nonblocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_dqbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue a buffer to the userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>buffer structure passed from userspace to <a class="reference internal" href="../uapi/v4l/vidioc-qbuf.html#c.VIDIOC_DQBUF" title="VIDIOC_DQBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_DQBUF()</span></code></a> handler
in driver</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">nonblocking</span></code></dt>
<dd>if true, this call will not sleep waiting for a buffer if no
buffers ready for dequeuing are present. Normally the driver
would be passing (file-&gt;f_flags &amp; O_NONBLOCK) here</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="../uapi/v4l/vidioc-qbuf.html#c.VIDIOC_DQBUF" title="VIDIOC_DQBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_DQBUF()</span></code></a> ioctl handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies the passed buffer,</li>
<li>calls buf_finish callback in the driver (if provided), in which
driver can perform any additional operations that may be required before
returning the buffer to userspace, such as cache sync,</li>
<li>the buffer struct members are filled with relevant information for
the userspace.</li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="../uapi/v4l/vidioc-qbuf.html#c.VIDIOC_DQBUF" title="VIDIOC_DQBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_DQBUF()</span></code></a> handler in driver.</p>
<dl class="function">
<dt id="c.vb2_streamon">
int <code class="descname">vb2_streamon</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type">v4l2_buf_type</a><em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_streamon" title="Permalink to this definition">¶</a></dt>
<dd><p>start streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span> <span class="pre">type</span></code></dt>
<dd>type argument passed from userspace to vidioc_streamon handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_streamon handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies current state</li>
<li>passes any previously queued buffers to the driver and starts streaming</li>
</ol>
<p>The return values from this function are intended to be directly returned
from vidioc_streamon handler in the driver.</p>
<dl class="function">
<dt id="c.vb2_streamoff">
int <code class="descname">vb2_streamoff</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type">v4l2_buf_type</a><em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_streamoff" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span> <span class="pre">type</span></code></dt>
<dd>type argument passed from userspace to vidioc_streamoff handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_streamoff handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies current state,</li>
<li>stop streaming and dequeues any queued buffers, including those previously
passed to the driver (after waiting for the driver to finish).</li>
</ol>
<p>This call can be used for pausing playback.
The return values from this function are intended to be directly returned
from vidioc_streamoff handler in the driver</p>
<dl class="function">
<dt id="c.vb2_queue_init">
int <code class="descname">vb2_queue_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a videobuf2 queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue; this structure should be allocated in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vb2_queue structure should be allocated by the driver. The driver is
responsible of clearing it’s content and setting initial values for some
required entries before calling this function.
q-&gt;ops, q-&gt;mem_ops, q-&gt;type and q-&gt;io_modes are mandatory. Please refer
to the struct vb2_queue description in include/media/videobuf2-core.h
for more information.</p>
<dl class="function">
<dt id="c.vb2_queue_release">
void <code class="descname">vb2_queue_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_release" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming, release the queue and free memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stops streaming and performs necessary clean ups, including
freeing video buffer memory. The driver is responsible for freeing
the vb2_queue structure itself.</p>
<dl class="function">
<dt id="c.vb2_poll">
unsigned int <code class="descname">vb2_poll</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct file *<em>&nbsp;file</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>implements poll userspace operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file argument passed to the poll file operation handler</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>wait argument passed to the poll file operation handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements poll file operation handler for a driver.
For CAPTURE queues, if a buffer is ready to be dequeued, the userspace will
be informed that the file descriptor of a video device is available for
reading.
For OUTPUT queues, if a buffer is ready to be dequeued, the file descriptor
will be reported as available for writing.</p>
<p>If the driver uses struct v4l2_fh, then <a class="reference internal" href="#c.vb2_poll" title="vb2_poll"><code class="xref c c-func docutils literal"><span class="pre">vb2_poll()</span></code></a> will also check for any
pending events.</p>
<p>The return values from this function are intended to be directly returned
from poll handler in driver.</p>
<dl class="function">
<dt id="c.vb2_ops_wait_prepare">
void <code class="descname">vb2_ops_wait_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;vq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_ops_wait_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to lock a struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">vq</span></code></dt>
<dd>pointer to struct vb2_queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: only use if vq-&gt;lock is non-NULL.</p>
<dl class="function">
<dt id="c.vb2_ops_wait_finish">
void <code class="descname">vb2_ops_wait_finish</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;vq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_ops_wait_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to unlock a struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">vq</span></code></dt>
<dd>pointer to struct vb2_queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: only use if vq-&gt;lock is non-NULL.</p>
<dl class="type">
<dt id="c.vb2_vmarea_handler">
struct <code class="descname">vb2_vmarea_handler</code><a class="headerlink" href="#c.vb2_vmarea_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>common vma refcount tracking handler</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vb2_vmarea_handler {
  refcount_t * refcount;
  void (* put) (void *arg);
  void * arg;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>pointer to refcount entry in the buffer</dd>
<dt><code class="docutils literal"><span class="pre">put</span></code></dt>
<dd>callback to function that decreases buffer refcount</dd>
<dt><code class="docutils literal"><span class="pre">arg</span></code></dt>
<dd>argument for <strong>put</strong> callback</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="v4l2-clocks.html" class="btn btn-neutral float-right" title="1.15. V4L2 clocks" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="v4l2-videobuf.html" class="btn btn-neutral" title="1.13. Videobuf Framework" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>