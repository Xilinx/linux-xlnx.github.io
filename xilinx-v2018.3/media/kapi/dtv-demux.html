

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.3. Digital TV Demux kABI &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2.4. Digital TV Conditional Access kABI" href="dtv-ca.html" />
    <link rel="prev" title="2.2. Digital TV Frontend kABI" href="dtv-frontend.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="dtv-common.html">2.1. Digital TV Common functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-frontend.html">2.2. Digital TV Frontend kABI</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">2.3. Digital TV Demux kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-ca.html">2.4. Digital TV Conditional Access kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-net.html">2.5. Digital TV Network kABI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">4. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
        
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
        
          <li><a href="dtv-core.html">2. Digital TV (DVB) devices</a> &raquo;</li>
        
      <li>2.3. Digital TV Demux kABI</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/media/kapi/dtv-demux.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="digital-tv-demux-kabi">
<h1>2.3. Digital TV Demux kABI<a class="headerlink" href="#digital-tv-demux-kabi" title="Permalink to this headline">¶</a></h1>
<div class="section" id="digital-tv-demux">
<h2>2.3.1. Digital TV Demux<a class="headerlink" href="#digital-tv-demux" title="Permalink to this headline">¶</a></h2>
<p>The Kernel Digital TV Demux kABI defines a driver-internal interface for
registering low-level, hardware specific driver to a hardware independent
demux layer. It is only of interest for Digital TV device driver writers.
The header file for this kABI is named <code class="docutils literal"><span class="pre">demux.h</span></code> and located in
<code class="docutils literal"><span class="pre">include/media</span></code>.</p>
<p>The demux kABI should be implemented for each demux in the system. It is
used to select the TS source of a demux and to manage the demux resources.
When the demux client allocates a resource via the demux kABI, it receives
a pointer to the kABI of that resource.</p>
<p>Each demux receives its TS input from a DVB front-end or from memory, as
set via this demux kABI. In a system with more than one front-end, the kABI
can be used to select one of the DVB front-ends as a TS source for a demux,
unless this is fixed in the HW platform.</p>
<p>The demux kABI only controls front-ends regarding to their connections with
demuxes; the kABI used to set the other front-end parameters, such as
tuning, are devined via the Digital TV Frontend kABI.</p>
<p>The functions that implement the abstract interface demux should be defined
static or module private and registered to the Demux core for external
access. It is not necessary to implement every function in the struct
<a class="reference internal" href="#c.dmx_demux" title="dmx_demux"><code class="xref c c-type docutils literal"><span class="pre">dmx_demux</span></code></a>. For example, a demux interface might support Section filtering,
but not PES filtering. The kABI client is expected to check the value of any
function pointer before calling the function: the value of <code class="docutils literal"><span class="pre">NULL</span></code> means
that the function is not available.</p>
<p>Whenever the functions of the demux API modify shared data, the
possibilities of lost update and race condition problems should be
addressed, e.g. by protecting parts of code with mutexes.</p>
<p>Note that functions called from a bottom half context must not sleep.
Even a simple memory allocation without using <code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code> can result in a
kernel thread being put to sleep if swapping is needed. For example, the
Linux Kernel calls the functions of a network device interface from a
bottom half context. Thus, if a demux kABI function is called from network
device code, the function must not sleep.</p>
</div>
<div class="section" id="demux-callback-api">
<h2>2.3.2. Demux Callback API<a class="headerlink" href="#demux-callback-api" title="Permalink to this headline">¶</a></h2>
<p>This kernel-space API comprises the callback functions that deliver filtered
data to the demux client. Unlike the other DVB kABIs, these functions are
provided by the client and called from the demux code.</p>
<p>The function pointers of this abstract interface are not packed into a
structure as in the other demux APIs, because the callback functions are
registered and used independent of each other. As an example, it is possible
for the API client to provide several callback functions for receiving TS
packets and no callbacks for PES packets or sections.</p>
<p>The functions that implement the callback API need not be re-entrant: when
a demux driver calls one of these functions, the driver is not allowed to
call the function again before the original call returns. If a callback is
triggered by a hardware interrupt, it is recommended to use the Linux
bottom half mechanism or start a tasklet instead of making the callback
function call directly from a hardware interrupt.</p>
<p>This mechanism is implemented by <a class="reference internal" href="#c.dmx_ts_cb" title="dmx_ts_cb"><code class="xref c c-func docutils literal"><span class="pre">dmx_ts_cb()</span></code></a> and <a class="reference internal" href="#c.dmx_section_cb" title="dmx_section_cb"><code class="xref c c-func docutils literal"><span class="pre">dmx_section_cb()</span></code></a>
callbacks.</p>
</div>
<div class="section" id="digital-tv-demux-device-registration-functions-and-data-structures">
<h2>2.3.3. Digital TV Demux device registration functions and data structures<a class="headerlink" href="#digital-tv-demux-device-registration-functions-and-data-structures" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.dmxdev_type">
enum <code class="descname">dmxdev_type</code><a class="headerlink" href="#c.dmxdev_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of demux filter type.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DMXDEV_TYPE_NONE</span></code></dt>
<dd>no filter set.</dd>
<dt><code class="docutils literal"><span class="pre">DMXDEV_TYPE_SEC</span></code></dt>
<dd>section filter.</dd>
<dt><code class="docutils literal"><span class="pre">DMXDEV_TYPE_PES</span></code></dt>
<dd>Program Elementary Stream (PES) filter.</dd>
</dl>
<dl class="type">
<dt id="c.dmxdev_state">
enum <code class="descname">dmxdev_state</code><a class="headerlink" href="#c.dmxdev_state" title="Permalink to this definition">¶</a></dt>
<dd><p>state machine for the dmxdev.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DMXDEV_STATE_FREE</span></code></dt>
<dd>indicates that the filter is freed.</dd>
<dt><code class="docutils literal"><span class="pre">DMXDEV_STATE_ALLOCATED</span></code></dt>
<dd>indicates that the filter was allocated
to be used.</dd>
<dt><code class="docutils literal"><span class="pre">DMXDEV_STATE_SET</span></code></dt>
<dd>indicates that the filter parameters are set.</dd>
<dt><code class="docutils literal"><span class="pre">DMXDEV_STATE_GO</span></code></dt>
<dd>indicates that the filter is running.</dd>
<dt><code class="docutils literal"><span class="pre">DMXDEV_STATE_DONE</span></code></dt>
<dd>indicates that a packet was already filtered
and the filter is now disabled.
Set only if <code class="docutils literal"><span class="pre">DMX_ONESHOT</span></code>. See
<a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_sct_filter_params" title="dmx_sct_filter_params"><code class="xref c c-type docutils literal"><span class="pre">dmx_sct_filter_params</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">DMXDEV_STATE_TIMEDOUT</span></code></dt>
<dd>Indicates a timeout condition.</dd>
</dl>
<dl class="type">
<dt id="c.dmxdev_feed">
struct <code class="descname">dmxdev_feed</code><a class="headerlink" href="#c.dmxdev_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>digital TV dmxdev feed</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dmxdev_feed {
  u16 pid;
  struct dmx_ts_feed *ts;
  struct list_head next;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pid</span></code></dt>
<dd>Program ID to be filtered</dd>
<dt><code class="docutils literal"><span class="pre">ts</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dmx_ts_feed" title="dmx_ts_feed"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_ts_feed</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">next</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointing to the next feed.</dd>
</dl>
<dl class="type">
<dt id="c.dmxdev_filter">
struct <code class="descname">dmxdev_filter</code><a class="headerlink" href="#c.dmxdev_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>digital TV dmxdev filter</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dmxdev_filter {
  union {
    struct dmx_section_filter *sec;
  } filter;
  union {
    struct list_head ts;
    struct dmx_section_feed *sec;
  } feed;
  union {
    struct dmx_sct_filter_params sec;
    struct dmx_pes_filter_params pes;
  } params;
  enum dmxdev_type type;
  enum dmxdev_state state;
  struct dmxdev *dev;
  struct dvb_ringbuffer buffer;
  struct dvb_vb2_ctx vb2_ctx;
  struct mutex mutex;
  struct timer_list timer;
  int todo;
  u8 secheader[3];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">filter</span></code></dt>
<dd>a union describing a dmxdev filter.
Currently used only for section filters.</dd>
<dt><code class="docutils literal"><span class="pre">filter.sec</span></code></dt>
<dd>a <a class="reference internal" href="#c.dmx_section_filter" title="dmx_section_filter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_section_filter</span></code></a> pointer.
For section filter only.</dd>
<dt><code class="docutils literal"><span class="pre">feed</span></code></dt>
<dd>a union describing a dmxdev feed.
Depending on the filter type, it can be either
<strong>feed.ts</strong> or <strong>feed.sec</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">feed.ts</span></code></dt>
<dd>a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> list.
For TS and PES feeds.</dd>
<dt><code class="docutils literal"><span class="pre">feed.sec</span></code></dt>
<dd>a <a class="reference internal" href="#c.dmx_section_feed" title="dmx_section_feed"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_section_feed</span></code></a> pointer.
For section feed only.</dd>
<dt><code class="docutils literal"><span class="pre">params</span></code></dt>
<dd>a union describing dmxdev filter parameters.
Depending on the filter type, it can be either
<strong>params.sec</strong> or <strong>params.pes</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">params.sec</span></code></dt>
<dd>a <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_sct_filter_params" title="dmx_sct_filter_params"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_sct_filter_params</span></code></a> embedded struct.
For section filter only.</dd>
<dt><code class="docutils literal"><span class="pre">params.pes</span></code></dt>
<dd>a <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_pes_filter_params" title="dmx_pes_filter_params"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_pes_filter_params</span></code></a> embedded struct.
For PES filter only.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the dmxdev filter, as defined by <a class="reference internal" href="#c.dmxdev_type" title="dmxdev_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dmxdev_type</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>state of the dmxdev filter, as defined by <a class="reference internal" href="#c.dmxdev_state" title="dmxdev_state"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dmxdev_state</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dmxdev" title="dmxdev"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmxdev</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">buffer</span></code></dt>
<dd>an embedded <a class="reference internal" href="dtv-common.html#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a> buffer.</dd>
<dt><code class="docutils literal"><span class="pre">vb2_ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>protects the access to <a class="reference internal" href="#c.dmxdev_filter" title="dmxdev_filter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmxdev_filter</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">timer</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span></code> embedded timer, used to check for
feed timeouts.
Only for section filter.</dd>
<dt><code class="docutils literal"><span class="pre">todo</span></code></dt>
<dd>index for the <strong>secheader</strong>.
Only for section filter.</dd>
<dt><code class="docutils literal"><span class="pre">secheader</span></code></dt>
<dd>buffer cache to parse the section header.
Only for section filter.</dd>
</dl>
<dl class="type">
<dt id="c.dmxdev">
struct <code class="descname">dmxdev</code><a class="headerlink" href="#c.dmxdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a digital TV demux device.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dmxdev {
  struct dvb_device *dvbdev;
  struct dvb_device *dvr_dvbdev;
  struct dmxdev_filter *filter;
  struct dmx_demux *demux;
  int filternum;
  int capabilities;
  unsigned int may_do_mmap:1;
  unsigned int exit:1;
#define DMXDEV_CAP_DUPLEX 1;
  struct dmx_frontend *dvr_orig_fe;
  struct dvb_ringbuffer dvr_buffer;
#define DVR_BUFFER_SIZE (10*188*1024);
  struct dvb_vb2_ctx dvr_vb2_ctx;
  struct mutex mutex;
  spinlock_t lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dvbdev</span></code></dt>
<dd>pointer to <a class="reference internal" href="dtv-common.html#c.dvb_device" title="dvb_device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_device</span></code></a> associated with
the demux device node.</dd>
<dt><code class="docutils literal"><span class="pre">dvr_dvbdev</span></code></dt>
<dd>pointer to <a class="reference internal" href="dtv-common.html#c.dvb_device" title="dvb_device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_device</span></code></a> associated with
the dvr device node.</dd>
<dt><code class="docutils literal"><span class="pre">filter</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dmxdev_filter" title="dmxdev_filter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmxdev_filter</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">demux</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dmx_demux" title="dmx_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_demux</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">filternum</span></code></dt>
<dd>number of filters.</dd>
<dt><code class="docutils literal"><span class="pre">capabilities</span></code></dt>
<dd>demux capabilities as defined by <a class="reference internal" href="#c.dmx_demux_caps" title="dmx_demux_caps"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dmx_demux_caps</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">may_do_mmap</span></code></dt>
<dd>flag used to indicate if the device may do mmap.</dd>
<dt><code class="docutils literal"><span class="pre">exit</span></code></dt>
<dd>flag to indicate that the demux is being released.</dd>
<dt><code class="docutils literal"><span class="pre">dvr_orig_fe</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dmx_frontend" title="dmx_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_frontend</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">dvr_buffer</span></code></dt>
<dd>embedded <a class="reference internal" href="dtv-common.html#c.dvb_ringbuffer" title="dvb_ringbuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_ringbuffer</span></code></a> for DVB output.</dd>
<dt><code class="docutils literal"><span class="pre">dvr_vb2_ctx</span></code></dt>
<dd>control struct for VB2 handler</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>protects the usage of this structure.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>protects access to <a class="reference internal" href="#c.dmxdev" title="dmxdev"><code class="xref c c-type docutils literal"><span class="pre">dmxdev-&gt;filter</span></code></a>-&gt;data.</dd>
</dl>
<dl class="function">
<dt id="c.dvb_dmxdev_init">
int <code class="descname">dvb_dmxdev_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dmxdev" title="dmxdev">dmxdev</a> *<em>&nbsp;dmxdev</em>, struct <a class="reference internal" href="dtv-common.html#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>&nbsp;adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_dmxdev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes a digital TV demux and registers both demux and DVR devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmxdev</span> <span class="pre">*</span> <span class="pre">dmxdev</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dmxdev" title="dmxdev"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmxdev</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>pointer to <a class="reference internal" href="dtv-common.html#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a>.</dd>
</dl>
<dl class="function">
<dt id="c.dvb_dmxdev_release">
void <code class="descname">dvb_dmxdev_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dmxdev" title="dmxdev">dmxdev</a> *<em>&nbsp;dmxdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_dmxdev_release" title="Permalink to this definition">¶</a></dt>
<dd><p>releases a digital TV demux and unregisters it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmxdev</span> <span class="pre">*</span> <span class="pre">dmxdev</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dmxdev" title="dmxdev"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmxdev</span></code></a>.</dd>
</dl>
</div>
<div class="section" id="high-level-digital-tv-demux-interface">
<h2>2.3.4. High-level Digital TV demux interface<a class="headerlink" href="#high-level-digital-tv-demux-interface" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.dvb_dmx_filter_type">
enum <code class="descname">dvb_dmx_filter_type</code><a class="headerlink" href="#c.dvb_dmx_filter_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of demux feed.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DMX_TYPE_TS</span></code></dt>
<dd>feed is in TS mode.</dd>
<dt><code class="docutils literal"><span class="pre">DMX_TYPE_SEC</span></code></dt>
<dd>feed is in Section mode.</dd>
</dl>
<dl class="type">
<dt id="c.dvb_dmx_state">
enum <code class="descname">dvb_dmx_state</code><a class="headerlink" href="#c.dvb_dmx_state" title="Permalink to this definition">¶</a></dt>
<dd><p>state machine for a demux filter.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DMX_STATE_FREE</span></code></dt>
<dd>indicates that the filter is freed.</dd>
<dt><code class="docutils literal"><span class="pre">DMX_STATE_ALLOCATED</span></code></dt>
<dd>indicates that the filter was allocated
to be used.</dd>
<dt><code class="docutils literal"><span class="pre">DMX_STATE_READY</span></code></dt>
<dd>indicates that the filter is ready
to be used.</dd>
<dt><code class="docutils literal"><span class="pre">DMX_STATE_GO</span></code></dt>
<dd>indicates that the filter is running.</dd>
</dl>
<dl class="type">
<dt id="c.dvb_demux_filter">
struct <code class="descname">dvb_demux_filter</code><a class="headerlink" href="#c.dvb_demux_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes a DVB demux section filter.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dvb_demux_filter {
  struct dmx_section_filter filter;
  u8 maskandmode[DMX_MAX_FILTER_SIZE];
  u8 maskandnotmode[DMX_MAX_FILTER_SIZE];
  bool doneq;
  struct dvb_demux_filter *next;
  struct dvb_demux_feed *feed;
  int index;
  enum dvb_dmx_state state;
  enum dvb_dmx_filter_type type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">filter</span></code></dt>
<dd>Section filter as defined by <a class="reference internal" href="#c.dmx_section_filter" title="dmx_section_filter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_section_filter</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">maskandmode</span></code></dt>
<dd>logical <code class="docutils literal"><span class="pre">and</span></code> bit mask.</dd>
<dt><code class="docutils literal"><span class="pre">maskandnotmode</span></code></dt>
<dd>logical <code class="docutils literal"><span class="pre">and</span> <span class="pre">not</span></code> bit mask.</dd>
<dt><code class="docutils literal"><span class="pre">doneq</span></code></dt>
<dd>flag that indicates when a filter is ready.</dd>
<dt><code class="docutils literal"><span class="pre">next</span></code></dt>
<dd>pointer to the next section filter.</dd>
<dt><code class="docutils literal"><span class="pre">feed</span></code></dt>
<dd><a class="reference internal" href="#c.dvb_demux_feed" title="dvb_demux_feed"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux_feed</span></code></a> pointer.</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>index of the used demux filter.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>state of the filter as described by <a class="reference internal" href="#c.dvb_dmx_state" title="dvb_dmx_state"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dvb_dmx_state</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the filter as described
by <a class="reference internal" href="#c.dvb_dmx_filter_type" title="dvb_dmx_filter_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dvb_dmx_filter_type</span></code></a>.</dd>
</dl>
<dl class="type">
<dt id="c.dvb_demux_feed">
struct <code class="descname">dvb_demux_feed</code><a class="headerlink" href="#c.dvb_demux_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>describes a DVB field</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dvb_demux_feed {
  union {
    struct dmx_ts_feed ts;
    struct dmx_section_feed sec;
  } feed;
  union {
    dmx_ts_cb ts;
    dmx_section_cb sec;
  } cb;
  struct dvb_demux *demux;
  void *priv;
  enum dvb_dmx_filter_type type;
  enum dvb_dmx_state state;
  u16 pid;
  ktime_t timeout;
  struct dvb_demux_filter *filter;
  u32 buffer_flags;
  enum ts_filter_type ts_type;
  enum dmx_ts_pes pes_type;
  int cc;
  bool pusi_seen;
  u16 peslen;
  struct list_head list_head;
  unsigned int index;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">feed</span></code></dt>
<dd>a union describing a digital TV feed.
Depending on the feed type, it can be either
<strong>feed.ts</strong> or <strong>feed.sec</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">feed.ts</span></code></dt>
<dd>a <a class="reference internal" href="#c.dmx_ts_feed" title="dmx_ts_feed"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_ts_feed</span></code></a> pointer.
For TS feed only.</dd>
<dt><code class="docutils literal"><span class="pre">feed.sec</span></code></dt>
<dd>a <a class="reference internal" href="#c.dmx_section_feed" title="dmx_section_feed"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_section_feed</span></code></a> pointer.
For section feed only.</dd>
<dt><code class="docutils literal"><span class="pre">cb</span></code></dt>
<dd>a union describing digital TV callbacks.
Depending on the feed type, it can be either
<strong>cb.ts</strong> or <strong>cb.sec</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">cb.ts</span></code></dt>
<dd>a <a class="reference internal" href="#c.dmx_ts_cb" title="dmx_ts_cb"><code class="xref c c-func docutils literal"><span class="pre">dmx_ts_cb()</span></code></a> calback function pointer.
For TS feed only.</dd>
<dt><code class="docutils literal"><span class="pre">cb.sec</span></code></dt>
<dd>a <a class="reference internal" href="#c.dmx_section_cb" title="dmx_section_cb"><code class="xref c c-func docutils literal"><span class="pre">dmx_section_cb()</span></code></a> callback function pointer.
For section feed only.</dd>
<dt><code class="docutils literal"><span class="pre">demux</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>private data that can optionally be used by a DVB driver.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the filter, as defined by <a class="reference internal" href="#c.dvb_dmx_filter_type" title="dvb_dmx_filter_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dvb_dmx_filter_type</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>state of the filter as defined by <a class="reference internal" href="#c.dvb_dmx_state" title="dvb_dmx_state"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dvb_dmx_state</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">pid</span></code></dt>
<dd>PID to be filtered.</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>feed timeout.</dd>
<dt><code class="docutils literal"><span class="pre">filter</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_demux_filter" title="dvb_demux_filter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux_filter</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">buffer_flags</span></code></dt>
<dd>Buffer flags used to report discontinuity users via DVB
memory mapped API, as defined by <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer_flags" title="dmx_buffer_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dmx_buffer_flags</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">ts_type</span></code></dt>
<dd>type of TS, as defined by <a class="reference internal" href="#c.ts_filter_type" title="ts_filter_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">ts_filter_type</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">pes_type</span></code></dt>
<dd>type of PES, as defined by <a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_ts_pes" title="dmx_ts_pes"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dmx_ts_pes</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">cc</span></code></dt>
<dd>MPEG-TS packet continuity counter</dd>
<dt><code class="docutils literal"><span class="pre">pusi_seen</span></code></dt>
<dd>if true, indicates that a discontinuity was detected.
it is used to prevent feeding of garbage from previous section.</dd>
<dt><code class="docutils literal"><span class="pre">peslen</span></code></dt>
<dd>length of the PES (Packet Elementary Stream).</dd>
<dt><code class="docutils literal"><span class="pre">list_head</span></code></dt>
<dd>head for the list of digital TV demux feeds.</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>a unique index for each feed. Can be used as hardware
pid filter index.</dd>
</dl>
<dl class="type">
<dt id="c.dvb_demux">
struct <code class="descname">dvb_demux</code><a class="headerlink" href="#c.dvb_demux" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a digital TV demux</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dvb_demux {
  struct dmx_demux dmx;
  void *priv;
  int filternum;
  int feednum;
  int (*start_feed)(struct dvb_demux_feed *feed);
  int (*stop_feed)(struct dvb_demux_feed *feed);
  int (*write_to_decoder)(struct dvb_demux_feed *feed, const u8 *buf, size_t len);
  u32 (*check_crc32)(struct dvb_demux_feed *feed, const u8 *buf, size_t len);
  void (*memcopy)(struct dvb_demux_feed *feed, u8 *dst, const u8 *src, size_t len);
  int users;
#define MAX_DVB_DEMUX_USERS 10;
  struct dvb_demux_filter *filter;
  struct dvb_demux_feed *feed;
  struct list_head frontend_list;
  struct dvb_demux_feed *pesfilter[DMX_PES_OTHER];
  u16 pids[DMX_PES_OTHER];
#define DMX_MAX_PID 0x2000;
  struct list_head feed_list;
  u8 tsbuf[204];
  int tsbufp;
  struct mutex mutex;
  spinlock_t lock;
  uint8_t *cnt_storage;
  ktime_t speed_last_time;
  uint32_t speed_pkts_cnt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dmx</span></code></dt>
<dd>embedded <a class="reference internal" href="#c.dmx_demux" title="dmx_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dmx_demux</span></code></a> with demux capabilities
and callbacks.</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>private data that can optionally be used by
a DVB driver.</dd>
<dt><code class="docutils literal"><span class="pre">filternum</span></code></dt>
<dd>maximum amount of DVB filters.</dd>
<dt><code class="docutils literal"><span class="pre">feednum</span></code></dt>
<dd>maximum amount of DVB feeds.</dd>
<dt><code class="docutils literal"><span class="pre">start_feed</span></code></dt>
<dd>callback routine to be called in order to start
a DVB feed.</dd>
<dt><code class="docutils literal"><span class="pre">stop_feed</span></code></dt>
<dd>callback routine to be called in order to stop
a DVB feed.</dd>
<dt><code class="docutils literal"><span class="pre">write_to_decoder</span></code></dt>
<dd>callback routine to be called if the feed is TS and
it is routed to an A/V decoder, when a new TS packet
is received.
Used only on av7110-av.c.</dd>
<dt><code class="docutils literal"><span class="pre">check_crc32</span></code></dt>
<dd>callback routine to check CRC. If not initialized,
dvb_demux will use an internal one.</dd>
<dt><code class="docutils literal"><span class="pre">memcopy</span></code></dt>
<dd>callback routine to memcopy received data.
If not initialized, dvb_demux will default to <a class="reference internal" href="../../core-api/kernel-api.html#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal"><span class="pre">memcpy()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">users</span></code></dt>
<dd>counter for the number of demux opened file descriptors.
Currently, it is limited to 10 users.</dd>
<dt><code class="docutils literal"><span class="pre">filter</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_demux_filter" title="dvb_demux_filter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux_filter</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">feed</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_demux_feed" title="dvb_demux_feed"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux_feed</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">frontend_list</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> with frontends used by the demux.</dd>
<dt><code class="docutils literal"><span class="pre">pesfilter</span></code></dt>
<dd>array of <a class="reference internal" href="#c.dvb_demux_feed" title="dvb_demux_feed"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux_feed</span></code></a> with the PES types
that will be filtered.</dd>
<dt><code class="docutils literal"><span class="pre">pids</span></code></dt>
<dd>list of filtered program IDs.</dd>
<dt><code class="docutils literal"><span class="pre">feed_list</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> with feeds.</dd>
<dt><code class="docutils literal"><span class="pre">tsbuf</span></code></dt>
<dd>temporary buffer used internally to store TS packets.</dd>
<dt><code class="docutils literal"><span class="pre">tsbufp</span></code></dt>
<dd>temporary buffer index used internally.</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span></code> used to protect feed set
logic.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">spinlock_t</span></code>, used to protect buffer handling.</dd>
<dt><code class="docutils literal"><span class="pre">cnt_storage</span></code></dt>
<dd>buffer used for TS/TEI continuity check.</dd>
<dt><code class="docutils literal"><span class="pre">speed_last_time</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">ktime_t</span></code> used for TS speed check.</dd>
<dt><code class="docutils literal"><span class="pre">speed_pkts_cnt</span></code></dt>
<dd>packets count used for TS speed check.</dd>
</dl>
<dl class="function">
<dt id="c.dvb_dmx_init">
int <code class="descname">dvb_dmx_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_demux" title="dvb_demux">dvb_demux</a> *<em>&nbsp;demux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_dmx_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a digital TV demux struct.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span> <span class="pre">*</span> <span class="pre">demux</span></code></dt>
<dd><a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span></code></a> to be initialized.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Before being able to register a digital TV demux struct, drivers
should call this routine. On its typical usage, some fields should
be initialized at the driver before calling it.</p>
<p>A typical usecase is:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>dvb-&gt;demux.dmx.capabilities =
        DMX_TS_FILTERING | DMX_SECTION_FILTERING |
        DMX_MEMORY_BASED_FILTERING;
dvb-&gt;demux.priv       = dvb;
dvb-&gt;demux.filternum  = 256;
dvb-&gt;demux.feednum    = 256;
dvb-&gt;demux.start_feed = driver_start_feed;
dvb-&gt;demux.stop_feed  = driver_stop_feed;
ret = dvb_dmx_init(&amp;dvb-&gt;demux);
if (ret &lt; 0)
        return ret;
</pre></div>
</div>
<dl class="function">
<dt id="c.dvb_dmx_release">
void <code class="descname">dvb_dmx_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_demux" title="dvb_demux">dvb_demux</a> *<em>&nbsp;demux</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_dmx_release" title="Permalink to this definition">¶</a></dt>
<dd><p>releases a digital TV demux internal buffers.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span> <span class="pre">*</span> <span class="pre">demux</span></code></dt>
<dd><a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span></code></a> to be released.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The DVB core internally allocates data at <strong>demux</strong>. This routine
releases those data. Please notice that the struct itelf is not
released, as it can be embedded on other structs.</p>
<dl class="function">
<dt id="c.dvb_dmx_swfilter_packets">
void <code class="descname">dvb_dmx_swfilter_packets</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_demux" title="dvb_demux">dvb_demux</a> *<em>&nbsp;demux</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_dmx_swfilter_packets" title="Permalink to this definition">¶</a></dt>
<dd><p>use dvb software filter for a buffer with multiple MPEG-TS packets with 188 bytes each.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span> <span class="pre">*</span> <span class="pre">demux</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer with data to be filtered</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of MPEG-TS packets with size of 188.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The routine will discard a DVB packet that don’t start with 0x47.</p>
<p>Use this routine if the DVB demux fills MPEG-TS buffers that are
already aligned.</p>
<p><strong>NOTE</strong></p>
<p>The <strong>buf</strong> size should have size equal to <code class="docutils literal"><span class="pre">count</span> <span class="pre">*</span> <span class="pre">188</span></code>.</p>
<dl class="function">
<dt id="c.dvb_dmx_swfilter">
void <code class="descname">dvb_dmx_swfilter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_demux" title="dvb_demux">dvb_demux</a> *<em>&nbsp;demux</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_dmx_swfilter" title="Permalink to this definition">¶</a></dt>
<dd><p>use dvb software filter for a buffer with multiple MPEG-TS packets with 188 bytes each.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span> <span class="pre">*</span> <span class="pre">demux</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer with data to be filtered</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of MPEG-TS packets with size of 188.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a DVB packet doesn’t start with 0x47, it will seek for the first
byte that starts with 0x47.</p>
<p>Use this routine if the DVB demux fill buffers that may not start with
a packet start mark (0x47).</p>
<p><strong>NOTE</strong></p>
<p>The <strong>buf</strong> size should have size equal to <code class="docutils literal"><span class="pre">count</span> <span class="pre">*</span> <span class="pre">188</span></code>.</p>
<dl class="function">
<dt id="c.dvb_dmx_swfilter_204">
void <code class="descname">dvb_dmx_swfilter_204</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_demux" title="dvb_demux">dvb_demux</a> *<em>&nbsp;demux</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_dmx_swfilter_204" title="Permalink to this definition">¶</a></dt>
<dd><p>use dvb software filter for a buffer with multiple MPEG-TS packets with 204 bytes each.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span> <span class="pre">*</span> <span class="pre">demux</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer with data to be filtered</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of MPEG-TS packets with size of 204.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a DVB packet doesn’t start with 0x47, it will seek for the first
byte that starts with 0x47.</p>
<p>Use this routine if the DVB demux fill buffers that may not start with
a packet start mark (0x47).</p>
<p><strong>NOTE</strong></p>
<p>The <strong>buf</strong> size should have size equal to <code class="docutils literal"><span class="pre">count</span> <span class="pre">*</span> <span class="pre">204</span></code>.</p>
<dl class="function">
<dt id="c.dvb_dmx_swfilter_raw">
void <code class="descname">dvb_dmx_swfilter_raw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_demux" title="dvb_demux">dvb_demux</a> *<em>&nbsp;demux</em>, const u8 *<em>&nbsp;buf</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_dmx_swfilter_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>make the raw data available to userspace without filtering</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span> <span class="pre">*</span> <span class="pre">demux</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_demux</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer with data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of packets to be passed. The actual size of each packet
depends on the <a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">dvb_demux-&gt;feed</span></code></a>-&gt;cb.ts logic.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use it if the driver needs to deliver the raw payload to userspace without
passing through the kernel demux. That is meant to support some
delivery systems that aren’t based on MPEG-TS.</p>
<p>This function relies on <a class="reference internal" href="#c.dvb_demux" title="dvb_demux"><code class="xref c c-type docutils literal"><span class="pre">dvb_demux-&gt;feed</span></code></a>-&gt;cb.ts to actually handle the
buffer.</p>
</div>
<div class="section" id="driver-internal-low-level-hardware-specific-driver-demux-interface">
<h2>2.3.5. Driver-internal low-level hardware specific driver demux interface<a class="headerlink" href="#driver-internal-low-level-hardware-specific-driver-demux-interface" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.ts_filter_type">
enum <code class="descname">ts_filter_type</code><a class="headerlink" href="#c.ts_filter_type" title="Permalink to this definition">¶</a></dt>
<dd><p>filter type bitmap for dmx_ts_feed.set()</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">TS_PACKET</span></code></dt>
<dd>Send TS packets (188 bytes) to callback (default).</dd>
<dt><code class="docutils literal"><span class="pre">TS_PAYLOAD_ONLY</span></code></dt>
<dd>In case TS_PACKET is set, only send the TS payload
(&lt;=184 bytes per packet) to callback</dd>
<dt><code class="docutils literal"><span class="pre">TS_DECODER</span></code></dt>
<dd>Send stream to built-in decoder (if present).</dd>
<dt><code class="docutils literal"><span class="pre">TS_DEMUX</span></code></dt>
<dd>In case TS_PACKET is set, send the TS to the demux
device, not to the dvr device</dd>
</dl>
<dl class="type">
<dt id="c.dmx_ts_feed">
struct <code class="descname">dmx_ts_feed</code><a class="headerlink" href="#c.dmx_ts_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure that contains a TS feed filter</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dmx_ts_feed {
  int is_filtering;
  struct dmx_demux *parent;
  void *priv;
  int (*set)(struct dmx_ts_feed *feed,u16 pid,int type,enum dmx_ts_pes pes_type, ktime_t timeout);
  int (*start_filtering)(struct dmx_ts_feed *feed);
  int (*stop_filtering)(struct dmx_ts_feed *feed);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">is_filtering</span></code></dt>
<dd>Set to non-zero when filtering in progress</dd>
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>pointer to struct dmx_demux</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>pointer to private data of the API client</dd>
<dt><code class="docutils literal"><span class="pre">set</span></code></dt>
<dd>sets the TS filter</dd>
<dt><code class="docutils literal"><span class="pre">start_filtering</span></code></dt>
<dd>starts TS filtering</dd>
<dt><code class="docutils literal"><span class="pre">stop_filtering</span></code></dt>
<dd>stops TS filtering</dd>
</dl>
<p><strong>Description</strong></p>
<p>A TS feed is typically mapped to a hardware PID filter on the demux chip.
Using this API, the client can set the filtering properties to start/stop
filtering TS packets on a particular TS feed.</p>
<dl class="type">
<dt id="c.dmx_section_filter">
struct <code class="descname">dmx_section_filter</code><a class="headerlink" href="#c.dmx_section_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure that describes a section filter</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dmx_section_filter {
  u8 filter_value[DMX_MAX_FILTER_SIZE];
  u8 filter_mask[DMX_MAX_FILTER_SIZE];
  u8 filter_mode[DMX_MAX_FILTER_SIZE];
  struct dmx_section_feed *parent;
  void *priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">filter_value</span></code></dt>
<dd>Contains up to 16 bytes (128 bits) of the TS section header
that will be matched by the section filter</dd>
<dt><code class="docutils literal"><span class="pre">filter_mask</span></code></dt>
<dd>Contains a 16 bytes (128 bits) filter mask with the bits
specified by <strong>filter_value</strong> that will be used on the filter
match logic.</dd>
<dt><code class="docutils literal"><span class="pre">filter_mode</span></code></dt>
<dd>Contains a 16 bytes (128 bits) filter mode.</dd>
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>Back-pointer to struct dmx_section_feed.</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>Pointer to private data of the API client.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>filter_mask</strong> controls which bits of <strong>filter_value</strong> are compared with
the section headers/payload. On a binary value of 1 in filter_mask, the
corresponding bits are compared. The filter only accepts sections that are
equal to filter_value in all the tested bit positions.</p>
<dl class="type">
<dt id="c.dmx_section_feed">
struct <code class="descname">dmx_section_feed</code><a class="headerlink" href="#c.dmx_section_feed" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure that contains a section feed filter</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dmx_section_feed {
  int is_filtering;
  struct dmx_demux *parent;
  void *priv;
  int check_crc;
  int (*set)(struct dmx_section_feed *feed,u16 pid, int check_crc);
  int (*allocate_filter)(struct dmx_section_feed *feed, struct dmx_section_filter **filter);
  int (*release_filter)(struct dmx_section_feed *feed, struct dmx_section_filter *filter);
  int (*start_filtering)(struct dmx_section_feed *feed);
  int (*stop_filtering)(struct dmx_section_feed *feed);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">is_filtering</span></code></dt>
<dd>Set to non-zero when filtering in progress</dd>
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>pointer to struct dmx_demux</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>pointer to private data of the API client</dd>
<dt><code class="docutils literal"><span class="pre">check_crc</span></code></dt>
<dd>If non-zero, check the CRC values of filtered sections.</dd>
<dt><code class="docutils literal"><span class="pre">set</span></code></dt>
<dd>sets the section filter</dd>
<dt><code class="docutils literal"><span class="pre">allocate_filter</span></code></dt>
<dd>This function is used to allocate a section filter on
the demux. It should only be called when no filtering
is in progress on this section feed. If a filter cannot
be allocated, the function fails with -ENOSPC.</dd>
<dt><code class="docutils literal"><span class="pre">release_filter</span></code></dt>
<dd>This function releases all the resources of a
previously allocated section filter. The function
should not be called while filtering is in progress
on this section feed. After calling this function,
the caller should not try to dereference the filter
pointer.</dd>
<dt><code class="docutils literal"><span class="pre">start_filtering</span></code></dt>
<dd>starts section filtering</dd>
<dt><code class="docutils literal"><span class="pre">stop_filtering</span></code></dt>
<dd>stops section filtering</dd>
</dl>
<p><strong>Description</strong></p>
<p>A TS feed is typically mapped to a hardware PID filter on the demux chip.
Using this API, the client can set the filtering properties to start/stop
filtering TS packets on a particular TS feed.</p>
<dl class="type">
<dt id="c.dmx_ts_cb">
<code class="descname">dmx_ts_cb</code><a class="headerlink" href="#c.dmx_ts_cb" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: DVB demux TS filter callback function prototype</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">int</span> <span class="pre">dmx_ts_cb</span> <span class="pre">(const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer1,</span> <span class="pre">size_t</span> <span class="pre">buffer1_length,</span> <span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer2,</span> <span class="pre">size_t</span> <span class="pre">buffer2_length,</span> <span class="pre">struct</span> <span class="pre">dmx_ts_feed</span> <span class="pre">*</span> <span class="pre">source,</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buffer_flags);</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer1</span></code></dt>
<dd>Pointer to the start of the filtered TS packets.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">buffer1_length</span></code></dt>
<dd>Length of the TS data in buffer1.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer2</span></code></dt>
<dd>Pointer to the tail of the filtered TS packets, or NULL.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">buffer2_length</span></code></dt>
<dd>Length of the TS data in buffer2.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmx_ts_feed</span> <span class="pre">*</span> <span class="pre">source</span></code></dt>
<dd>Indicates which TS feed is the source of the callback.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buffer_flags</span></code></dt>
<dd>Address where buffer flags are stored. Those are
used to report discontinuity users via DVB
memory mapped API, as defined by
<a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer_flags" title="dmx_buffer_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dmx_buffer_flags</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function callback prototype, provided by the client of the demux API,
is called from the demux code. The function is only called when filtering
on a TS feed has been enabled using the start_filtering() function at
the <a class="reference internal" href="#c.dmx_demux" title="dmx_demux"><code class="xref c c-type docutils literal"><span class="pre">dmx_demux</span></code></a>.
Any TS packets that match the filter settings are copied to a circular
buffer. The filtered TS packets are delivered to the client using this
callback function.
It is expected that the <strong>buffer1</strong> and <strong>buffer2</strong> callback parameters point to
addresses within the circular buffer, but other implementations are also
possible. Note that the called party should not try to free the memory
the <strong>buffer1</strong> and <strong>buffer2</strong> parameters point to.</p>
<p>When this function is called, the <strong>buffer1</strong> parameter typically points to
the start of the first undelivered TS packet within a circular buffer.
The <strong>buffer2</strong> buffer parameter is normally NULL, except when the received
TS packets have crossed the last address of the circular buffer and
“wrapped” to the beginning of the buffer. In the latter case the <strong>buffer1</strong>
parameter would contain an address within the circular buffer, while the
<strong>buffer2</strong> parameter would contain the first address of the circular buffer.
The number of bytes delivered with this function (i.e. <strong>buffer1_length</strong> +
<strong>buffer2_length</strong>) is usually equal to the value of callback_length parameter
given in the <code class="xref c c-func docutils literal"><span class="pre">set()</span></code> function, with one exception: if a timeout occurs before
receiving callback_length bytes of TS data, any undelivered packets are
immediately delivered to the client by calling this function. The timeout
duration is controlled by the <code class="xref c c-func docutils literal"><span class="pre">set()</span></code> function in the TS Feed API.</p>
<p>If a TS packet is received with errors that could not be fixed by the
TS-level forward error correction (FEC), the Transport_error_indicator
flag of the TS packet header should be set. The TS packet should not be
discarded, as the error can possibly be corrected by a higher layer
protocol. If the called party is slow in processing the callback, it
is possible that the circular buffer eventually fills up. If this happens,
the demux driver should discard any TS packets received while the buffer
is full and return -EOVERFLOW.</p>
<p>The type of data returned to the callback can be selected by the
<a class="reference internal" href="#c.dmx_ts_feed" title="dmx_ts_feed"><code class="xref c c-type docutils literal"><span class="pre">dmx_ts_feed</span></code></a>.**set** function. The type parameter decides if the raw
TS packet (TS_PACKET) or just the payload (TS_PACKET|TS_PAYLOAD_ONLY)
should be returned. If additionally the TS_DECODER bit is set the stream
will also be sent to the hardware MPEG decoder.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li>0, on success;</li>
<li>-EOVERFLOW, on buffer overflow.</li>
</ul>
<dl class="type">
<dt id="c.dmx_section_cb">
<code class="descname">dmx_section_cb</code><a class="headerlink" href="#c.dmx_section_cb" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: DVB demux TS filter callback function prototype</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">int</span> <span class="pre">dmx_section_cb</span> <span class="pre">(const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer1,</span> <span class="pre">size_t</span> <span class="pre">buffer1_len,</span> <span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer2,</span> <span class="pre">size_t</span> <span class="pre">buffer2_len,</span> <span class="pre">struct</span> <span class="pre">dmx_section_filter</span> <span class="pre">*</span> <span class="pre">source,</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buffer_flags);</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer1</span></code></dt>
<dd>Pointer to the start of the filtered section, e.g.
within the circular buffer of the demux driver.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">buffer1_len</span></code></dt>
<dd>Length of the filtered section data in <strong>buffer1</strong>,
including headers and CRC.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer2</span></code></dt>
<dd>Pointer to the tail of the filtered section data,
or NULL. Useful to handle the wrapping of a
circular buffer.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">buffer2_len</span></code></dt>
<dd>Length of the filtered section data in <strong>buffer2</strong>,
including headers and CRC.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dmx_section_filter</span> <span class="pre">*</span> <span class="pre">source</span></code></dt>
<dd>Indicates which section feed is the source of the
callback.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buffer_flags</span></code></dt>
<dd>Address where buffer flags are stored. Those are
used to report discontinuity users via DVB
memory mapped API, as defined by
<a class="reference internal" href="../uapi/dvb/dmx_types.html#c.dmx_buffer_flags" title="dmx_buffer_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">dmx_buffer_flags</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function callback prototype, provided by the client of the demux API,
is called from the demux code. The function is only called when
filtering of sections has been enabled using the function
<a class="reference internal" href="#c.dmx_ts_feed" title="dmx_ts_feed"><code class="xref c c-type docutils literal"><span class="pre">dmx_ts_feed</span></code></a>.**start_filtering**. When the demux driver has received a
complete section that matches at least one section filter, the client
is notified via this callback function. Normally this function is called
for each received section; however, it is also possible to deliver
multiple sections with one callback, for example when the system load
is high. If an error occurs while receiving a section, this
function should be called with the corresponding error type set in the
success field, whether or not there is data to deliver. The Section Feed
implementation should maintain a circular buffer for received sections.
However, this is not necessary if the Section Feed API is implemented as
a client of the TS Feed API, because the TS Feed implementation then
buffers the received data. The size of the circular buffer can be
configured using the <a class="reference internal" href="#c.dmx_ts_feed" title="dmx_ts_feed"><code class="xref c c-type docutils literal"><span class="pre">dmx_ts_feed</span></code></a>.**set** function in the Section Feed API.
If there is no room in the circular buffer when a new section is received,
the section must be discarded. If this happens, the value of the success
parameter should be DMX_OVERRUN_ERROR on the next callback.</p>
<dl class="type">
<dt id="c.dmx_frontend_source">
enum <code class="descname">dmx_frontend_source</code><a class="headerlink" href="#c.dmx_frontend_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to identify the type of frontend</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DMX_MEMORY_FE</span></code></dt>
<dd>The source of the demux is memory. It means that
the MPEG-TS to be filtered comes from userspace,
via <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> syscall.</dd>
<dt><code class="docutils literal"><span class="pre">DMX_FRONTEND_0</span></code></dt>
<dd>The source of the demux is a frontend connected
to the demux.</dd>
</dl>
<dl class="type">
<dt id="c.dmx_frontend">
struct <code class="descname">dmx_frontend</code><a class="headerlink" href="#c.dmx_frontend" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure that lists the frontends associated with a demux</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dmx_frontend {
  struct list_head connectivity_list;
  enum dmx_frontend_source source;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connectivity_list</span></code></dt>
<dd>List of front-ends that can be connected to a
particular demux;</dd>
<dt><code class="docutils literal"><span class="pre">source</span></code></dt>
<dd>Type of the frontend.</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>FIXME: this structure should likely be replaced soon by some</dt>
<dd>media-controller based logic.</dd>
</dl>
<dl class="type">
<dt id="c.dmx_demux_caps">
enum <code class="descname">dmx_demux_caps</code><a class="headerlink" href="#c.dmx_demux_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>MPEG-2 TS Demux capabilities bitmap</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DMX_TS_FILTERING</span></code></dt>
<dd>set if TS filtering is supported;</dd>
<dt><code class="docutils literal"><span class="pre">DMX_SECTION_FILTERING</span></code></dt>
<dd>set if section filtering is supported;</dd>
<dt><code class="docutils literal"><span class="pre">DMX_MEMORY_BASED_FILTERING</span></code></dt>
<dd>set if <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> available.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Those flags are OR’ed in the <a class="reference internal" href="#c.dmx_demux" title="dmx_demux"><code class="xref c c-type docutils literal"><span class="pre">dmx_demux.capabilities</span></code></a> field</p>
<dl class="function">
<dt id="c.DMX_FE_ENTRY">
<code class="descname">DMX_FE_ENTRY</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DMX_FE_ENTRY" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts elements in the list of registered front-ends from the generic type struct list_head to the type * struct dmx_frontend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>list of struct dmx_frontend</dd>
</dl>
<dl class="type">
<dt id="c.dmx_demux">
struct <code class="descname">dmx_demux</code><a class="headerlink" href="#c.dmx_demux" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure that contains the demux capabilities and callbacks.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct dmx_demux {
  enum dmx_demux_caps capabilities;
  struct dmx_frontend *frontend;
  void *priv;
  int (*open)(struct dmx_demux *demux);
  int (*close)(struct dmx_demux *demux);
  int (*write)(struct dmx_demux *demux, const char __user *buf, size_t count);
  int (*allocate_ts_feed)(struct dmx_demux *demux,struct dmx_ts_feed **feed, dmx_ts_cb callback);
  int (*release_ts_feed)(struct dmx_demux *demux, struct dmx_ts_feed *feed);
  int (*allocate_section_feed)(struct dmx_demux *demux,struct dmx_section_feed **feed, dmx_section_cb callback);
  int (*release_section_feed)(struct dmx_demux *demux, struct dmx_section_feed *feed);
  int (*add_frontend)(struct dmx_demux *demux, struct dmx_frontend *frontend);
  int (*remove_frontend)(struct dmx_demux *demux, struct dmx_frontend *frontend);
  struct list_head *(*get_frontends)(struct dmx_demux *demux);
  int (*connect_frontend)(struct dmx_demux *demux, struct dmx_frontend *frontend);
  int (*disconnect_frontend)(struct dmx_demux *demux);
  int (*get_pes_pids)(struct dmx_demux *demux, u16 *pids);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">capabilities</span></code></dt>
<dd>Bitfield of capability flags.</dd>
<dt><code class="docutils literal"><span class="pre">frontend</span></code></dt>
<dd>Front-end connected to the demux</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>Pointer to private data of the API client</dd>
<dt><code class="docutils literal"><span class="pre">open</span></code></dt>
<dd>This function reserves the demux for use by the caller and, if
necessary, initializes the demux. When the demux is no longer needed,
the function <strong>close</strong> should be called. It should be possible for
multiple clients to access the demux at the same time. Thus, the
function implementation should increment the demux usage count when
<strong>open</strong> is called and decrement it when <strong>close</strong> is called.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
It returns:
0 on success;
-EUSERS, if maximum usage count was reached;
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">close</span></code></dt>
<dd>This function reserves the demux for use by the caller and, if
necessary, initializes the demux. When the demux is no longer needed,
the function <strong>close</strong> should be called. It should be possible for
multiple clients to access the demux at the same time. Thus, the
function implementation should increment the demux usage count when
<strong>open</strong> is called and decrement it when <strong>close</strong> is called.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
It returns:
0 on success;
-ENODEV, if demux was not in use (e. g. no users);
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">write</span></code></dt>
<dd>This function provides the demux driver with a memory buffer
containing TS packets. Instead of receiving TS packets from the DVB
front-end, the demux driver software will read packets from memory.
Any clients of this demux with active TS, PES or Section filters will
receive filtered data via the Demux callback API (see 0). The function
returns when all the data in the buffer has been consumed by the demux.
Demux hardware typically cannot read TS from memory. If this is the
case, memory-based filtering has to be implemented entirely in software.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>buf</strong> function parameter contains a pointer to the TS data in
kernel-space memory.
The <strong>count</strong> function parameter contains the length of the TS data.
It returns:
0 on success;
-ERESTARTSYS, if mutex lock was interrupted;
-EINTR, if a signal handling is pending;
-ENODEV, if demux was removed;
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">allocate_ts_feed</span></code></dt>
<dd>Allocates a new TS feed, which is used to filter the TS
packets carrying a certain PID. The TS feed normally corresponds to a
hardware PID filter on the demux chip.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>feed</strong> function parameter contains a pointer to the TS feed API and
instance data.
The <strong>callback</strong> function parameter contains a pointer to the callback
function for passing received TS packet.
It returns:
0 on success;
-ERESTARTSYS, if mutex lock was interrupted;
-EBUSY, if no more TS feeds is available;
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">release_ts_feed</span></code></dt>
<dd>Releases the resources allocated with <strong>allocate_ts_feed</strong>.
Any filtering in progress on the TS feed should be stopped before
calling this function.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>feed</strong> function parameter contains a pointer to the TS feed API and
instance data.
It returns:
0 on success;
-EINVAL on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">allocate_section_feed</span></code></dt>
<dd>Allocates a new section feed, i.e. a demux resource
for filtering and receiving sections. On platforms with hardware
support for section filtering, a section feed is directly mapped to
the demux HW. On other platforms, TS packets are first PID filtered in
hardware and a hardware section filter then emulated in software. The
caller obtains an API pointer of type dmx_section_feed_t as an out
parameter. Using this API the caller can set filtering parameters and
start receiving sections.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>feed</strong> function parameter contains a pointer to the TS feed API and
instance data.
The <strong>callback</strong> function parameter contains a pointer to the callback
function for passing received TS packet.
It returns:
0 on success;
-EBUSY, if no more TS feeds is available;
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">release_section_feed</span></code></dt>
<dd>Releases the resources allocated with
<strong>allocate_section_feed</strong>, including allocated filters. Any filtering in
progress on the section feed should be stopped before calling this
function.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>feed</strong> function parameter contains a pointer to the TS feed API and
instance data.
It returns:
0 on success;
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">add_frontend</span></code></dt>
<dd>Registers a connectivity between a demux and a front-end,
i.e., indicates that the demux can be connected via a call to
<strong>connect_frontend</strong> to use the given front-end as a TS source. The
client of this function has to allocate dynamic or static memory for
the frontend structure and initialize its fields before calling this
function. This function is normally called during the driver
initialization. The caller must not free the memory of the frontend
struct before successfully calling <strong>remove_frontend</strong>.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>frontend</strong> function parameter contains a pointer to the front-end
instance data.
It returns:
0 on success;
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">remove_frontend</span></code></dt>
<dd>Indicates that the given front-end, registered by a call
to <strong>add_frontend</strong>, can no longer be connected as a TS source by this
demux. The function should be called when a front-end driver or a demux
driver is removed from the system. If the front-end is in use, the
function fails with the return value of -EBUSY. After successfully
calling this function, the caller can free the memory of the frontend
struct if it was dynamically allocated before the <strong>add_frontend</strong>
operation.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>frontend</strong> function parameter contains a pointer to the front-end
instance data.
It returns:
0 on success;
-ENODEV, if the front-end was not found,
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">get_frontends</span></code></dt>
<dd>Provides the APIs of the front-ends that have been
registered for this demux. Any of the front-ends obtained with this
call can be used as a parameter for <strong>connect_frontend</strong>. The include
file demux.h contains the macro <a class="reference internal" href="#c.DMX_FE_ENTRY" title="DMX_FE_ENTRY"><code class="xref c c-func docutils literal"><span class="pre">DMX_FE_ENTRY()</span></code></a> for converting an
element of the generic type struct <code class="xref c c-type docutils literal"><span class="pre">list_head</span></code> * to the type
struct <a class="reference internal" href="#c.dmx_frontend" title="dmx_frontend"><code class="xref c c-type docutils literal"><span class="pre">dmx_frontend</span></code></a> <em>. The caller must not free the memory of any of
the elements obtained via this function call.
The **demux*</em> function parameter contains a pointer to the demux API and
instance data.
It returns a struct list_head pointer to the list of front-end
interfaces, or NULL in the case of an empty list.</dd>
<dt><code class="docutils literal"><span class="pre">connect_frontend</span></code></dt>
<dd>Connects the TS output of the front-end to the input of
the demux. A demux can only be connected to a front-end registered to
the demux with the function <strong>add_frontend</strong>. It may or may not be
possible to connect multiple demuxes to the same front-end, depending
on the capabilities of the HW platform. When not used, the front-end
should be released by calling <strong>disconnect_frontend</strong>.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>frontend</strong> function parameter contains a pointer to the front-end
instance data.
It returns:
0 on success;
-EINVAL, on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">disconnect_frontend</span></code></dt>
<dd>Disconnects the demux and a front-end previously
connected by a <strong>connect_frontend</strong> call.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
It returns:
0 on success;
-EINVAL on bad parameter.</dd>
<dt><code class="docutils literal"><span class="pre">get_pes_pids</span></code></dt>
<dd>Get the PIDs for DMX_PES_AUDIO0, DMX_PES_VIDEO0,
DMX_PES_TELETEXT0, DMX_PES_SUBTITLE0 and DMX_PES_PCR0.
The <strong>demux</strong> function parameter contains a pointer to the demux API and
instance data.
The <strong>pids</strong> function parameter contains an array with five u16 elements
where the PIDs will be stored.
It returns:
0 on success;
-EINVAL on bad parameter.</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dtv-ca.html" class="btn btn-neutral float-right" title="2.4. Digital TV Conditional Access kABI" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dtv-frontend.html" class="btn btn-neutral" title="2.2. Digital TV Frontend kABI" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>