

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3.2. Streaming I/O (Memory Mapping) &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="3.3. Streaming I/O (User Pointers)" href="userp.html" />
    <link rel="prev" title="3.1. Read/Write" href="rw.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../media_uapi.html">Linux Media Infrastructure userspace API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="v4l2.html">Part I - Video for Linux API</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="common.html">1. Common API Elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="pixfmt.html">2. Image Formats</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="io.html">3. Input/Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="devices.html">4. Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="libv4l.html">5. Libv4l Userspace Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="compat.html">6. Changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="user-func.html">7. Function Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="common-defs.html">8. Common definitions for V4L2 and V4L2 subdev interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="videodev.html">9. Video For Linux Two Header File</a></li>
<li class="toctree-l4"><a class="reference internal" href="capture-example.html">10. Video Capture Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2grab-example.html">11. Video Grabber example using libv4l</a></li>
<li class="toctree-l4"><a class="reference internal" href="biblio.html">12. References</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2.html#revision-and-copyright">Revision and Copyright</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2.html#revision-history">Revision History</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dvb/dvbapi.html">Part II - Digital TV API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rc/remote_controllers.html">Part III - Remote Controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mediactl/media-controller.html">Part IV - Media Controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cec/cec-api.html">Part V - Consumer Electronics Control API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gen-errors.html">Generic Error Codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fdl-appendix.html">GNU Free Documentation License</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../media_kapi.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
        
          <li><a href="../../media_uapi.html">Linux Media Infrastructure userspace API</a> &raquo;</li>
        
          <li><a href="v4l2.html">Part I - Video for Linux API</a> &raquo;</li>
        
          <li><a href="io.html">3. Input/Output</a> &raquo;</li>
        
      <li>3.2. Streaming I/O (Memory Mapping)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/media/uapi/v4l/mmap.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="streaming-i-o-memory-mapping">
<span id="mmap"></span><h1>3.2. Streaming I/O (Memory Mapping)<a class="headerlink" href="#streaming-i-o-memory-mapping" title="Permalink to this headline">¶</a></h1>
<p>Input and output devices support this I/O method when the
<code class="docutils literal"><span class="pre">V4L2_CAP_STREAMING</span></code> flag in the <code class="docutils literal"><span class="pre">capabilities</span></code> field of struct
<a class="reference internal" href="vidioc-querycap.html#c.v4l2_capability" title="v4l2_capability"><code class="xref c c-type docutils literal"><span class="pre">v4l2_capability</span></code></a> returned by the
<a class="reference internal" href="vidioc-querycap.html#vidioc-querycap"><span class="std std-ref">ioctl VIDIOC_QUERYCAP</span></a> ioctl is set. There are two
streaming methods, to determine if the memory mapping flavor is
supported applications must call the <a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span class="std std-ref">ioctl VIDIOC_REQBUFS</span></a> ioctl
with the memory type set to <code class="docutils literal"><span class="pre">V4L2_MEMORY_MMAP</span></code>.</p>
<p>Streaming is an I/O method where only pointers to buffers are exchanged
between application and driver, the data itself is not copied. Memory
mapping is primarily intended to map buffers in device memory into the
application’s address space. Device memory can be for example the video
memory on a graphics card with a video capture add-on. However, being
the most efficient I/O method available for a long time, many other
drivers support streaming as well, allocating buffers in DMA-able main
memory.</p>
<p>A driver can support many sets of buffers. Each set is identified by a
unique buffer type value. The sets are independent and each set can hold
a different type of data. To access different sets at the same time
different file descriptors must be used. <a class="footnote-reference" href="#f1" id="id1">[1]</a></p>
<p>To allocate device buffers applications call the
<a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span class="std std-ref">ioctl VIDIOC_REQBUFS</span></a> ioctl with the desired number
of buffers and buffer type, for example <code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE</span></code>.
This ioctl can also be used to change the number of buffers or to free
the allocated memory, provided none of the buffers are still mapped.</p>
<p>Before applications can access the buffers they must map them into their
address space with the <a class="reference internal" href="func-mmap.html#func-mmap"><span class="std std-ref">mmap()</span></a> function. The
location of the buffers in device memory can be determined with the
<a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">ioctl VIDIOC_QUERYBUF</span></a> ioctl. In the single-planar
API case, the <code class="docutils literal"><span class="pre">m.offset</span></code> and <code class="docutils literal"><span class="pre">length</span></code> returned in a struct
<a class="reference internal" href="buffer.html#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a> are passed as sixth and second
parameter to the <a class="reference internal" href="func-mmap.html#func-mmap"><span class="std std-ref">mmap()</span></a> function. When using the
multi-planar API, struct <a class="reference internal" href="buffer.html#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a> contains an
array of struct <a class="reference internal" href="buffer.html#c.v4l2_plane" title="v4l2_plane"><code class="xref c c-type docutils literal"><span class="pre">v4l2_plane</span></code></a> structures, each
containing its own <code class="docutils literal"><span class="pre">m.offset</span></code> and <code class="docutils literal"><span class="pre">length</span></code>. When using the
multi-planar API, every plane of every buffer has to be mapped
separately, so the number of calls to <a class="reference internal" href="func-mmap.html#func-mmap"><span class="std std-ref">mmap()</span></a> should
be equal to number of buffers times number of planes in each buffer. The
offset and length values must not be modified. Remember, the buffers are
allocated in physical memory, as opposed to virtual memory, which can be
swapped out to disk. Applications should free the buffers as soon as
possible with the <a class="reference internal" href="func-munmap.html#func-munmap"><span class="std std-ref">munmap()</span></a> function.</p>
<div class="section" id="example-mapping-buffers-in-the-single-planar-api">
<h2>3.2.1. Example: Mapping buffers in the single-planar API<a class="headerlink" href="#example-mapping-buffers-in-the-single-planar-api" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="n">reqbuf</span><span class="p">;</span>
<span class="k">struct</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span> <span class="o">*</span><span class="n">buffers</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reqbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">reqbuf</span><span class="p">));</span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE</span><span class="p">;</span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ioctl</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">VIDIOC_REQBUFS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reqbuf</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINVAL</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Video capturing or mmap-streaming is not supported</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="nf">perror</span><span class="p">(</span><span class="s">&quot;VIDIOC_REQBUFS&quot;</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* We want at least five buffers. */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* You may need to free the buffers here. */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Not enough buffer memory</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">buffers</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buffers</span><span class="p">));</span>
<span class="n">assert</span><span class="p">(</span><span class="n">buffers</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="n">buffer</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">reqbuf</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ioctl</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">VIDIOC_QUERYBUF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;VIDIOC_QUERYBUF&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="cm">/* remember for munmap() */</span>

    <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
                <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="cm">/* recommended */</span>
                <span class="n">MAP_SHARED</span><span class="p">,</span>             <span class="cm">/* recommended */</span>
                <span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* If you do not exit here you should unmap() and free()</span>
<span class="cm">           the buffers mapped so far. */</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;mmap&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Cleanup. */</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">munmap</span><span class="p">(</span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">,</span> <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="example-mapping-buffers-in-the-multi-planar-api">
<h2>3.2.2. Example: Mapping buffers in the multi-planar API<a class="headerlink" href="#example-mapping-buffers-in-the-multi-planar-api" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">v4l2_requestbuffers</span> <span class="n">reqbuf</span><span class="p">;</span>
<span class="cm">/* Our current format uses 3 planes per buffer */</span>
<span class="cp">#define FMT_NUM_PLANES = 3</span>

<span class="k">struct</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">[</span><span class="n">FMT_NUM_PLANES</span><span class="p">];</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">[</span><span class="n">FMT_NUM_PLANES</span><span class="p">];</span>
<span class="p">}</span> <span class="o">*</span><span class="n">buffers</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reqbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">reqbuf</span><span class="p">));</span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</span><span class="p">;</span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span>
<span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">VIDIOC_REQBUFS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reqbuf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINVAL</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Video capturing or mmap-streaming is not supported</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="nf">perror</span><span class="p">(</span><span class="s">&quot;VIDIOC_REQBUFS&quot;</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* We want at least five buffers. */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* You may need to free the buffers here. */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Not enough buffer memory</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">buffers</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">buffers</span><span class="p">));</span>
<span class="n">assert</span><span class="p">(</span><span class="n">buffers</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">v4l2_buffer</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">v4l2_plane</span> <span class="n">planes</span><span class="p">[</span><span class="n">FMT_NUM_PLANES</span><span class="p">];</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">reqbuf</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">V4L2_MEMORY_MMAP</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="cm">/* length in struct v4l2_buffer in multi-planar API stores the size</span>
<span class="cm">     * of planes array. */</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">FMT_NUM_PLANES</span><span class="p">;</span>
    <span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span> <span class="o">=</span> <span class="n">planes</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">VIDIOC_QUERYBUF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">&quot;VIDIOC_QUERYBUF&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Every plane has to be mapped separately */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">FMT_NUM_PLANES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span><span class="p">;</span> <span class="cm">/* remember for munmap() */</span>

        <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">length</span><span class="p">,</span>
                 <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="cm">/* recommended */</span>
                 <span class="n">MAP_SHARED</span><span class="p">,</span>             <span class="cm">/* recommended */</span>
                 <span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">.</span><span class="n">m</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">m</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
            <span class="cm">/* If you do not exit here you should unmap() and free()</span>
<span class="cm">               the buffers and planes mapped so far. */</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">&quot;mmap&quot;</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Cleanup. */</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reqbuf</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">FMT_NUM_PLANES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">munmap</span><span class="p">(</span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</pre></div>
</div>
<p>Conceptually streaming drivers maintain two buffer queues, an incoming
and an outgoing queue. They separate the synchronous capture or output
operation locked to a video clock from the application which is subject
to random disk or network delays and preemption by other processes,
thereby reducing the probability of data loss. The queues are organized
as FIFOs, buffers will be output in the order enqueued in the incoming
FIFO, and were captured in the order dequeued from the outgoing FIFO.</p>
<p>The driver may require a minimum number of buffers enqueued at all times
to function, apart of this no limit exists on the number of buffers
applications can enqueue in advance, or dequeue and process. They can
also enqueue in a different order than buffers have been dequeued, and
the driver can <em>fill</em> enqueued <em>empty</em> buffers in any order.  <a class="footnote-reference" href="#f2" id="id2">[2]</a> The
index number of a buffer (struct <a class="reference internal" href="buffer.html#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a>
<code class="docutils literal"><span class="pre">index</span></code>) plays no role here, it only identifies the buffer.</p>
<p>Initially all mapped buffers are in dequeued state, inaccessible by the
driver. For capturing applications it is customary to first enqueue all
mapped buffers, then to start capturing and enter the read loop. Here
the application waits until a filled buffer can be dequeued, and
re-enqueues the buffer when the data is no longer needed. Output
applications fill and enqueue buffers, when enough buffers are stacked
up the output is started with <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMON</span></a>.
In the write loop, when the application runs out of free buffers, it
must wait until an empty buffer can be dequeued and reused.</p>
<p>To enqueue and dequeue a buffer applications use the <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</span></a>
and <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a> ioctl. The status of a buffer
being mapped, enqueued, full or empty can be determined at any time
using the <a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">ioctl VIDIOC_QUERYBUF</span></a> ioctl. Two methods exist to suspend
execution of the application until one or more buffers can be dequeued.
By default <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a> blocks when no buffer is
in the outgoing queue. When the <code class="docutils literal"><span class="pre">O_NONBLOCK</span></code> flag was given to the
<a class="reference internal" href="func-open.html#func-open"><span class="std std-ref">open()</span></a> function, <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a>
returns immediately with an <code class="docutils literal"><span class="pre">EAGAIN</span></code> error code when no buffer is
available. The <a class="reference internal" href="func-select.html#func-select"><span class="std std-ref">select()</span></a> or <a class="reference internal" href="func-poll.html#func-poll"><span class="std std-ref">poll()</span></a> functions are always available.</p>
<p>To start and stop capturing or output applications call the
<a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMON</span></a> and <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMOFF</span></a> ioctl.</p>
<p>Drivers implementing memory mapping I/O must support the
<a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span class="std std-ref">VIDIOC_REQBUFS</span></a>, <a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span class="std std-ref">VIDIOC_QUERYBUF</span></a>, <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_QBUF</span></a>, <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">VIDIOC_DQBUF</span></a>, <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMON</span></a>
and <a class="reference internal" href="vidioc-streamon.html#vidioc-streamon"><span class="std std-ref">VIDIOC_STREAMOFF</span></a> ioctls, the <a class="reference internal" href="func-mmap.html#func-mmap"><span class="std std-ref">mmap()</span></a>, <a class="reference internal" href="func-munmap.html#func-munmap"><span class="std std-ref">munmap()</span></a>, <a class="reference internal" href="func-select.html#func-select"><span class="std std-ref">select()</span></a> and <a class="reference internal" href="func-poll.html#func-poll"><span class="std std-ref">poll()</span></a> function. <a class="footnote-reference" href="#f3" id="id3">[3]</a></p>
<p>[capture example]</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>One could use one file descriptor and set the buffer type field
accordingly when calling <a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span class="std std-ref">ioctl VIDIOC_QBUF, VIDIOC_DQBUF</span></a> etc.,
but it makes the <a class="reference internal" href="func-select.html#func-select"><span class="std std-ref">select()</span></a> function ambiguous. We also
like the clean approach of one file descriptor per logical stream.
Video overlay for example is also a logical stream, although the CPU
is not needed for continuous operation.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Random enqueue order permits applications processing images out of
order (such as video codecs) to return buffers earlier, reducing the
probability of data loss. Random fill order allows drivers to reuse
buffers on a LIFO-basis, taking advantage of caches holding
scatter-gather lists and the like.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>At the driver level <a class="reference internal" href="func-select.html#func-select"><span class="std std-ref">select()</span></a> and <a class="reference internal" href="func-poll.html#func-poll"><span class="std std-ref">poll()</span></a> are
the same, and <a class="reference internal" href="func-select.html#func-select"><span class="std std-ref">select()</span></a> is too important to be optional.
The rest should be evident.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="userp.html" class="btn btn-neutral float-right" title="3.3. Streaming I/O (User Pointers)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rw.html" class="btn btn-neutral" title="3.1. Read/Write" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>