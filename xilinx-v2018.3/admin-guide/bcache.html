

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>A block layer cache (bcache) &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Power Management" href="pm/index.html" />
    <link rel="prev" title="Reliability, Availability and Serviceability" href="ras.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux kernel user’s and administrator’s guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="README.html">Linux kernel release 4.x &lt;http://kernel.org/&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel-parameters.html">The kernel’s command-line parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="devices.html">Linux allocated devices (4.x+ version)</a></li>
<li class="toctree-l2"><a class="reference internal" href="l1tf.html">L1TF - L1 Terminal Fault</a></li>
<li class="toctree-l2"><a class="reference internal" href="reporting-bugs.html">Reporting bugs</a></li>
<li class="toctree-l2"><a class="reference internal" href="security-bugs.html">Security bugs</a></li>
<li class="toctree-l2"><a class="reference internal" href="bug-hunting.html">Bug hunting</a></li>
<li class="toctree-l2"><a class="reference internal" href="bug-bisect.html">Bisecting a bug</a></li>
<li class="toctree-l2"><a class="reference internal" href="tainted-kernels.html">Tainted kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="ramoops.html">Ramoops oops/panic logger</a></li>
<li class="toctree-l2"><a class="reference internal" href="dynamic-debug-howto.html">Dynamic debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="init.html">Explaining the dreaded “No init found.” boot hang message</a></li>
<li class="toctree-l2"><a class="reference internal" href="sysfs-rules.html">Rules on how to access information in sysfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="initrd.html">Using the initial RAM disk (initrd)</a></li>
<li class="toctree-l2"><a class="reference internal" href="cgroup-v2.html">Control Group v2</a></li>
<li class="toctree-l2"><a class="reference internal" href="serial-console.html">Linux Serial Console</a></li>
<li class="toctree-l2"><a class="reference internal" href="braille-console.html">Linux Braille Console</a></li>
<li class="toctree-l2"><a class="reference internal" href="parport.html">Parport</a></li>
<li class="toctree-l2"><a class="reference internal" href="md.html">RAID arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="module-signing.html">Kernel module signing facility</a></li>
<li class="toctree-l2"><a class="reference internal" href="sysrq.html">Linux Magic System Request Key Hacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="unicode.html">Unicode support</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-softcursor.html">Software cursor for VGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="binfmt-misc.html">Kernel Support for miscellaneous (your favourite) Binary Formats v1.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="mono.html">Mono(tm) Binary Kernel Support for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="java.html">Java(tm) Binary Kernel Support for Linux v1.03</a></li>
<li class="toctree-l2"><a class="reference internal" href="ras.html">Reliability, Availability and Serviceability</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">A block layer cache (bcache)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#attaching">Attaching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#howto-cookbook">Howto/cookbook</a></li>
<li class="toctree-l3"><a class="reference internal" href="#troubleshooting-performance">Troubleshooting performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sysfs-backing-device">Sysfs - backing device</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sysfs-backing-device-stats">Sysfs - backing device stats</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sysfs-cache-set">Sysfs - cache set</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sysfs-cache-set-internal">Sysfs - cache set internal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sysfs-cache-device">Sysfs - Cache device</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="thunderbolt.html">Thunderbolt</a></li>
<li class="toctree-l2"><a class="reference internal" href="LSM/index.html">Linux Security Module Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="mm/index.html">Memory Management</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux kernel user’s and administrator’s guide</a> &raquo;</li>
        
      <li>A block layer cache (bcache)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/admin-guide/bcache.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="a-block-layer-cache-bcache">
<h1>A block layer cache (bcache)<a class="headerlink" href="#a-block-layer-cache-bcache" title="Permalink to this headline">¶</a></h1>
<p>Say you’ve got a big slow raid 6, and an ssd or three. Wouldn’t it be
nice if you could use them as cache… Hence bcache.</p>
<p>Wiki and git repositories are at:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://bcache.evilpiepirate.org">http://bcache.evilpiepirate.org</a></li>
<li><a class="reference external" href="http://evilpiepirate.org/git/linux-bcache.git">http://evilpiepirate.org/git/linux-bcache.git</a></li>
<li><a class="reference external" href="http://evilpiepirate.org/git/bcache-tools.git">http://evilpiepirate.org/git/bcache-tools.git</a></li>
</ul>
</div></blockquote>
<p>It’s designed around the performance characteristics of SSDs - it only allocates
in erase block sized buckets, and it uses a hybrid btree/log to track cached
extents (which can be anywhere from a single sector to the bucket size). It’s
designed to avoid random writes at all costs; it fills up an erase block
sequentially, then issues a discard before reusing it.</p>
<p>Both writethrough and writeback caching are supported. Writeback defaults to
off, but can be switched on and off arbitrarily at runtime. Bcache goes to
great lengths to protect your data - it reliably handles unclean shutdown. (It
doesn’t even have a notion of a clean shutdown; bcache simply doesn’t return
writes as completed until they’re on stable storage).</p>
<p>Writeback caching can use most of the cache for buffering writes - writing
dirty data to the backing device is always done sequentially, scanning from the
start to the end of the index.</p>
<p>Since random IO is what SSDs excel at, there generally won’t be much benefit
to caching large sequential IO. Bcache detects sequential IO and skips it;
it also keeps a rolling average of the IO sizes per task, and as long as the
average is above the cutoff it will skip all IO from that task - instead of
caching the first 512k after every seek. Backups and large file copies should
thus entirely bypass the cache.</p>
<p>In the event of a data IO error on the flash it will try to recover by reading
from disk or invalidating cache entries.  For unrecoverable errors (meta data
or dirty data), caching is automatically disabled; if dirty data was present
in the cache it first disables writeback caching and waits for all dirty data
to be flushed.</p>
<p>Getting started:
You’ll need make-bcache from the bcache-tools repository. Both the cache device
and backing device must be formatted before use:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>make-bcache -B /dev/sdb
make-bcache -C /dev/sdc
</pre></div>
</div>
<p>make-bcache has the ability to format multiple devices at the same time - if
you format your backing devices and cache device at the same time, you won’t
have to manually attach:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>make-bcache -B /dev/sda /dev/sdb -C /dev/sdc
</pre></div>
</div>
<p>bcache-tools now ships udev rules, and bcache devices are known to the kernel
immediately.  Without udev, you can manually register devices like this:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>echo /dev/sdb &gt; /sys/fs/bcache/register
echo /dev/sdc &gt; /sys/fs/bcache/register
</pre></div>
</div>
<p>Registering the backing device makes the bcache device show up in /dev; you can
now format it and use it as normal. But the first time using a new bcache
device, it’ll be running in passthrough mode until you attach it to a cache.
If you are thinking about using bcache later, it is recommended to setup all your
slow devices as bcache backing devices without a cache, and you can choose to add
a caching device later.
See ‘ATTACHING’ section below.</p>
<p>The devices show up as:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/dev/bcache&lt;N&gt;
</pre></div>
</div>
<p>As well as (with udev):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/dev/bcache/by-uuid/&lt;uuid&gt;
/dev/bcache/by-label/&lt;label&gt;
</pre></div>
</div>
<p>To get started:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>mkfs.ext4 /dev/bcache0
mount /dev/bcache0 /mnt
</pre></div>
</div>
<p>You can control bcache devices through sysfs at /sys/block/bcache&lt;N&gt;/bcache .
You can also control them through /sys/fs//bcache/&lt;cset-uuid&gt;/ .</p>
<p>Cache devices are managed as sets; multiple caches per set isn’t supported yet
but will allow for mirroring of metadata and dirty data in the future. Your new
cache set shows up as /sys/fs/bcache/&lt;UUID&gt;</p>
<div class="section" id="attaching">
<h2>Attaching<a class="headerlink" href="#attaching" title="Permalink to this headline">¶</a></h2>
<p>After your cache device and backing device are registered, the backing device
must be attached to your cache set to enable caching. Attaching a backing
device to a cache set is done thusly, with the UUID of the cache set in
/sys/fs/bcache:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>echo &lt;CSET-UUID&gt; &gt; /sys/block/bcache0/bcache/attach
</pre></div>
</div>
<p>This only has to be done once. The next time you reboot, just reregister all
your bcache devices. If a backing device has data in a cache somewhere, the
/dev/bcache&lt;N&gt; device won’t be created until the cache shows up - particularly
important if you have writeback caching turned on.</p>
<p>If you’re booting up and your cache device is gone and never coming back, you
can force run the backing device:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>echo 1 &gt; /sys/block/sdb/bcache/running
</pre></div>
</div>
<p>(You need to use /sys/block/sdb (or whatever your backing device is called), not
/sys/block/bcache0, because bcache0 doesn’t exist yet. If you’re using a
partition, the bcache directory would be at /sys/block/sdb/sdb2/bcache)</p>
<p>The backing device will still use that cache set if it shows up in the future,
but all the cached data will be invalidated. If there was dirty data in the
cache, don’t expect the filesystem to be recoverable - you will have massive
filesystem corruption, though ext4’s fsck does work miracles.</p>
</div>
<div class="section" id="error-handling">
<h2>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<p>Bcache tries to transparently handle IO errors to/from the cache device without
affecting normal operation; if it sees too many errors (the threshold is
configurable, and defaults to 0) it shuts down the cache device and switches all
the backing devices to passthrough mode.</p>
<blockquote>
<div><ul class="simple">
<li>For reads from the cache, if they error we just retry the read from the
backing device.</li>
<li>For writethrough writes, if the write to the cache errors we just switch to
invalidating the data at that lba in the cache (i.e. the same thing we do for
a write that bypasses the cache)</li>
<li>For writeback writes, we currently pass that error back up to the
filesystem/userspace. This could be improved - we could retry it as a write
that skips the cache so we don’t have to error the write.</li>
<li>When we detach, we first try to flush any dirty data (if we were running in
writeback mode). It currently doesn’t do anything intelligent if it fails to
read some of the dirty data, though.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="howto-cookbook">
<h2>Howto/cookbook<a class="headerlink" href="#howto-cookbook" title="Permalink to this headline">¶</a></h2>
<ol class="upperalpha simple">
<li>Starting a bcache with a missing caching device</li>
</ol>
<p>If registering the backing device doesn’t help, it’s already there, you just need
to force it to run without the cache:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:~# echo /dev/sdb1 &gt; /sys/fs/bcache/register
[  119.844831] bcache: register_bcache() error opening /dev/sdb1: device already registered
</pre></div>
</div>
<p>Next, you try to register your caching device if it’s present. However
if it’s absent, or registration fails for some reason, you can still
start your bcache without its cache, like so:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/block/sdb/sdb1/bcache# echo 1 &gt; running
</pre></div>
</div>
<p>Note that this may cause data loss if you were running in writeback mode.</p>
<ol class="upperalpha" start="2">
<li><p class="first">Bcache does not find its cache:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/block/md5/bcache# echo 0226553a-37cf-41d5-b3ce-8b1e944543a8 &gt; attach
[ 1933.455082] bcache: bch_cached_dev_attach() Couldn&#39;t find uuid for md5 in set
[ 1933.478179] bcache: __cached_dev_store() Can&#39;t attach 0226553a-37cf-41d5-b3ce-8b1e944543a8
[ 1933.478179] : cache set not found
</pre></div>
</div>
</li>
</ol>
<p>In this case, the caching device was simply not registered at boot
or disappeared and came back, and needs to be (re-)registered:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/block/md5/bcache# echo /dev/sdh2 &gt; /sys/fs/bcache/register
</pre></div>
</div>
<ol class="upperalpha simple" start="3">
<li>Corrupt bcache crashes the kernel at device registration time:</li>
</ol>
<p>This should never happen.  If it does happen, then you have found a bug!
Please report it to the bcache development list: <a class="reference external" href="mailto:linux-bcache&#37;&#52;&#48;vger&#46;kernel&#46;org">linux-bcache<span>&#64;</span>vger<span>&#46;</span>kernel<span>&#46;</span>org</a></p>
<p>Be sure to provide as much information that you can including kernel dmesg
output if available so that we may assist.</p>
<ol class="upperalpha simple" start="4">
<li>Recovering data without bcache:</li>
</ol>
<p>If bcache is not available in the kernel, a filesystem on the backing
device is still available at an 8KiB offset. So either via a loopdev
of the backing device created with –offset 8K, or any value defined by
–data-offset when you originally formatted bcache with <cite>make-bcache</cite>.</p>
<p>For example:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>losetup -o 8192 /dev/loop0 /dev/your_bcache_backing_dev
</pre></div>
</div>
<p>This should present your unmodified backing device data in /dev/loop0</p>
<p>If your cache is in writethrough mode, then you can safely discard the
cache device without loosing data.</p>
<ol class="upperalpha simple" start="5">
<li>Wiping a cache device</li>
</ol>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:~# wipefs -a /dev/sdh2
16 bytes were erased at offset 0x1018 (bcache)
they were: c6 85 73 f6 4e 1a 45 ca 82 65 f5 7f 48 ba 6d 81
</pre></div>
</div>
<p>After you boot back with bcache enabled, you recreate the cache and attach it:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:~# make-bcache -C /dev/sdh2
UUID:                   7be7e175-8f4c-4f99-94b2-9c904d227045
Set UUID:               5bc072a8-ab17-446d-9744-e247949913c1
version:                0
nbuckets:               106874
block_size:             1
bucket_size:            1024
nr_in_set:              1
nr_this_dev:            0
first_bucket:           1
[  650.511912] bcache: run_cache_set() invalidating existing data
[  650.549228] bcache: register_cache() registered cache device sdh2
</pre></div>
</div>
<p>start backing device with missing cache:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/block/md5/bcache# echo 1 &gt; running
</pre></div>
</div>
<p>attach new cache:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/block/md5/bcache# echo 5bc072a8-ab17-446d-9744-e247949913c1 &gt; attach
[  865.276616] bcache: bch_cached_dev_attach() Caching md5 as bcache0 on set 5bc072a8-ab17-446d-9744-e247949913c1
</pre></div>
</div>
<ol class="upperalpha" start="6">
<li><p class="first">Remove or replace a caching device:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/block/sda/sda7/bcache# echo 1 &gt; detach
[  695.872542] bcache: cached_dev_detach_finish() Caching disabled for sda7

host:~# wipefs -a /dev/nvme0n1p4
wipefs: error: /dev/nvme0n1p4: probing initialization failed: Device or resource busy
Ooops, it&#39;s disabled, but not unregistered, so it&#39;s still protected
</pre></div>
</div>
</li>
</ol>
<p>We need to go and unregister it:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/fs/bcache/b7ba27a1-2398-4649-8ae3-0959f57ba128# ls -l cache0
lrwxrwxrwx 1 root root 0 Feb 25 18:33 cache0 -&gt; ../../../devices/pci0000:00/0000:00:1d.0/0000:70:00.0/nvme/nvme0/nvme0n1/nvme0n1p4/bcache/
host:/sys/fs/bcache/b7ba27a1-2398-4649-8ae3-0959f57ba128# echo 1 &gt; stop
kernel: [  917.041908] bcache: cache_set_free() Cache set b7ba27a1-2398-4649-8ae3-0959f57ba128 unregistered
</pre></div>
</div>
<p>Now we can wipe it:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:~# wipefs -a /dev/nvme0n1p4
/dev/nvme0n1p4: 16 bytes were erased at offset 0x00001018 (bcache): c6 85 73 f6 4e 1a 45 ca 82 65 f5 7f 48 ba 6d 81
</pre></div>
</div>
<ol class="upperalpha simple" start="7">
<li>dm-crypt and bcache</li>
</ol>
<p>First setup bcache unencrypted and then install dmcrypt on top of
/dev/bcache&lt;N&gt; This will work faster than if you dmcrypt both the backing
and caching devices and then install bcache on top. [benchmarks?]</p>
<ol class="upperalpha simple" start="8">
<li>Stop/free a registered bcache to wipe and/or recreate it</li>
</ol>
<p>Suppose that you need to free up all bcache references so that you can
fdisk run and re-register a changed partition table, which won’t work
if there are any active backing or caching devices left on it:</p>
<ol class="arabic">
<li><p class="first">Is it present in /dev/bcache* ? (there are times where it won’t be)</p>
<p>If so, it’s easy:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/block/bcache0/bcache# echo 1 &gt; stop
</pre></div>
</div>
</li>
<li><p class="first">But if your backing device is gone, this won’t work:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/block/bcache0# cd bcache
bash: cd: bcache: No such file or directory
</pre></div>
</div>
<p>In this case, you may have to unregister the dmcrypt block device that
references this bcache to free it up:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:~# dmsetup remove oldds1
bcache: bcache_device_free() bcache0 stopped
bcache: cache_set_free() Cache set 5bc072a8-ab17-446d-9744-e247949913c1 unregistered
</pre></div>
</div>
<p>This causes the backing bcache to be removed from /sys/fs/bcache and
then it can be reused.  This would be true of any block device stacking
where bcache is a lower device.</p>
</li>
<li><p class="first">In other cases, you can also look in /sys/fs/bcache/:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/fs/bcache# ls -l */{cache?,bdev?}
lrwxrwxrwx 1 root root 0 Mar  5 09:39 0226553a-37cf-41d5-b3ce-8b1e944543a8/bdev1 -&gt; ../../../devices/virtual/block/dm-1/bcache/
lrwxrwxrwx 1 root root 0 Mar  5 09:39 0226553a-37cf-41d5-b3ce-8b1e944543a8/cache0 -&gt; ../../../devices/virtual/block/dm-4/bcache/
lrwxrwxrwx 1 root root 0 Mar  5 09:39 5bc072a8-ab17-446d-9744-e247949913c1/cache0 -&gt; ../../../devices/pci0000:00/0000:00:01.0/0000:01:00.0/ata10/host9/target9:0:0/9:0:0:0/block/sdl/sdl2/bcache/
</pre></div>
</div>
<p>The device names will show which UUID is relevant, cd in that directory
and stop the cache:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>host:/sys/fs/bcache/5bc072a8-ab17-446d-9744-e247949913c1# echo 1 &gt; stop
</pre></div>
</div>
<p>This will free up bcache references and let you reuse the partition for
other purposes.</p>
</li>
</ol>
</div>
<div class="section" id="troubleshooting-performance">
<h2>Troubleshooting performance<a class="headerlink" href="#troubleshooting-performance" title="Permalink to this headline">¶</a></h2>
<p>Bcache has a bunch of config options and tunables. The defaults are intended to
be reasonable for typical desktop and server workloads, but they’re not what you
want for getting the best possible numbers when benchmarking.</p>
<blockquote>
<div><ul>
<li><p class="first">Backing device alignment</p>
<p>The default metadata size in bcache is 8k.  If your backing device is
RAID based, then be sure to align this by a multiple of your stride
width using <cite>make-bcache –data-offset</cite>. If you intend to expand your
disk array in the future, then multiply a series of primes by your
raid stripe size to get the disk multiples that you would like.</p>
<p>For example:  If you have a 64k stripe size, then the following offset
would provide alignment for many common RAID5 data spindle counts:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>64k * 2*2*2*3*3*5*7 bytes = 161280k
</pre></div>
</div>
<p>That space is wasted, but for only 157.5MB you can grow your RAID 5
volume to the following data-spindle counts without re-aligning:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>3,4,5,6,7,8,9,10,12,14,15,18,20,21 ...
</pre></div>
</div>
</li>
<li><p class="first">Bad write performance</p>
<p>If write performance is not what you expected, you probably wanted to be
running in writeback mode, which isn’t the default (not due to a lack of
maturity, but simply because in writeback mode you’ll lose data if something
happens to your SSD):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># echo writeback &gt; /sys/block/bcache0/bcache/cache_mode
</pre></div>
</div>
</li>
<li><p class="first">Bad performance, or traffic not going to the SSD that you’d expect</p>
<p>By default, bcache doesn’t cache everything. It tries to skip sequential IO -
because you really want to be caching the random IO, and if you copy a 10
gigabyte file you probably don’t want that pushing 10 gigabytes of randomly
accessed data out of your cache.</p>
<p>But if you want to benchmark reads from cache, and you start out with fio
writing an 8 gigabyte test file - so you want to disable that:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># echo 0 &gt; /sys/block/bcache0/bcache/sequential_cutoff
</pre></div>
</div>
<p>To set it back to the default (4 mb), do:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># echo 4M &gt; /sys/block/bcache0/bcache/sequential_cutoff
</pre></div>
</div>
</li>
<li><p class="first">Traffic’s still going to the spindle/still getting cache misses</p>
<p>In the real world, SSDs don’t always keep up with disks - particularly with
slower SSDs, many disks being cached by one SSD, or mostly sequential IO. So
you want to avoid being bottlenecked by the SSD and having it slow everything
down.</p>
<p>To avoid that bcache tracks latency to the cache device, and gradually
throttles traffic if the latency exceeds a threshold (it does this by
cranking down the sequential bypass).</p>
<p>You can disable this if you need to by setting the thresholds to 0:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># echo 0 &gt; /sys/fs/bcache/&lt;cache set&gt;/congested_read_threshold_us
# echo 0 &gt; /sys/fs/bcache/&lt;cache set&gt;/congested_write_threshold_us
</pre></div>
</div>
<p>The default is 2000 us (2 milliseconds) for reads, and 20000 for writes.</p>
</li>
<li><p class="first">Still getting cache misses, of the same data</p>
<p>One last issue that sometimes trips people up is actually an old bug, due to
the way cache coherency is handled for cache misses. If a btree node is full,
a cache miss won’t be able to insert a key for the new data and the data
won’t be written to the cache.</p>
<p>In practice this isn’t an issue because as soon as a write comes along it’ll
cause the btree node to be split, and you need almost no write traffic for
this to not show up enough to be noticeable (especially since bcache’s btree
nodes are huge and index large regions of the device). But when you’re
benchmarking, if you’re trying to warm the cache by reading a bunch of data
and there’s no other traffic - that can be a problem.</p>
<p>Solution: warm the cache by doing writes, or use the testing branch (there’s
a fix for the issue there).</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="sysfs-backing-device">
<h2>Sysfs - backing device<a class="headerlink" href="#sysfs-backing-device" title="Permalink to this headline">¶</a></h2>
<p>Available at /sys/block/&lt;bdev&gt;/bcache, /sys/block/bcache*/bcache and
(if attached) /sys/fs/bcache/&lt;cset-uuid&gt;/bdev*</p>
<dl class="docutils">
<dt>attach</dt>
<dd>Echo the UUID of a cache set to this file to enable caching.</dd>
<dt>cache_mode</dt>
<dd>Can be one of either writethrough, writeback, writearound or none.</dd>
<dt>clear_stats</dt>
<dd>Writing to this file resets the running total stats (not the day/hour/5 minute
decaying versions).</dd>
<dt>detach</dt>
<dd>Write to this file to detach from a cache set. If there is dirty data in the
cache, it will be flushed first.</dd>
<dt>dirty_data</dt>
<dd>Amount of dirty data for this backing device in the cache. Continuously
updated unlike the cache set’s version, but may be slightly off.</dd>
<dt>label</dt>
<dd>Name of underlying device.</dd>
<dt>readahead</dt>
<dd>Size of readahead that should be performed.  Defaults to 0.  If set to e.g.
1M, it will round cache miss reads up to that size, but without overlapping
existing cache entries.</dd>
<dt>running</dt>
<dd>1 if bcache is running (i.e. whether the /dev/bcache device exists, whether
it’s in passthrough mode or caching).</dd>
<dt>sequential_cutoff</dt>
<dd>A sequential IO will bypass the cache once it passes this threshold; the
most recent 128 IOs are tracked so sequential IO can be detected even when
it isn’t all done at once.</dd>
<dt>sequential_merge</dt>
<dd>If non zero, bcache keeps a list of the last 128 requests submitted to compare
against all new requests to determine which new requests are sequential
continuations of previous requests for the purpose of determining sequential
cutoff. This is necessary if the sequential cutoff value is greater than the
maximum acceptable sequential size for any single request.</dd>
<dt>state</dt>
<dd><p class="first">The backing device can be in one of four different states:</p>
<p>no cache: Has never been attached to a cache set.</p>
<p>clean: Part of a cache set, and there is no cached dirty data.</p>
<p>dirty: Part of a cache set, and there is cached dirty data.</p>
<p class="last">inconsistent: The backing device was forcibly run by the user when there was
dirty data cached but the cache set was unavailable; whatever data was on the
backing device has likely been corrupted.</p>
</dd>
<dt>stop</dt>
<dd>Write to this file to shut down the bcache device and close the backing
device.</dd>
<dt>writeback_delay</dt>
<dd>When dirty data is written to the cache and it previously did not contain
any, waits some number of seconds before initiating writeback. Defaults to
30.</dd>
<dt>writeback_percent</dt>
<dd>If nonzero, bcache tries to keep around this percentage of the cache dirty by
throttling background writeback and using a PD controller to smoothly adjust
the rate.</dd>
<dt>writeback_rate</dt>
<dd>Rate in sectors per second - if writeback_percent is nonzero, background
writeback is throttled to this rate. Continuously adjusted by bcache but may
also be set by the user.</dd>
<dt>writeback_running</dt>
<dd>If off, writeback of dirty data will not take place at all. Dirty data will
still be added to the cache until it is mostly full; only meant for
benchmarking. Defaults to on.</dd>
</dl>
<div class="section" id="sysfs-backing-device-stats">
<h3>Sysfs - backing device stats<a class="headerlink" href="#sysfs-backing-device-stats" title="Permalink to this headline">¶</a></h3>
<p>There are directories with these numbers for a running total, as well as
versions that decay over the past day, hour and 5 minutes; they’re also
aggregated in the cache set directory as well.</p>
<dl class="docutils">
<dt>bypassed</dt>
<dd>Amount of IO (both reads and writes) that has bypassed the cache</dd>
<dt>cache_hits, cache_misses, cache_hit_ratio</dt>
<dd>Hits and misses are counted per individual IO as bcache sees them; a
partial hit is counted as a miss.</dd>
<dt>cache_bypass_hits, cache_bypass_misses</dt>
<dd>Hits and misses for IO that is intended to skip the cache are still counted,
but broken out here.</dd>
<dt>cache_miss_collisions</dt>
<dd>Counts instances where data was going to be inserted into the cache from a
cache miss, but raced with a write and data was already present (usually 0
since the synchronization for cache misses was rewritten)</dd>
<dt>cache_readaheads</dt>
<dd>Count of times readahead occurred.</dd>
</dl>
</div>
<div class="section" id="sysfs-cache-set">
<h3>Sysfs - cache set<a class="headerlink" href="#sysfs-cache-set" title="Permalink to this headline">¶</a></h3>
<p>Available at /sys/fs/bcache/&lt;cset-uuid&gt;</p>
<dl class="docutils">
<dt>average_key_size</dt>
<dd>Average data per key in the btree.</dd>
<dt>bdev&lt;0..n&gt;</dt>
<dd>Symlink to each of the attached backing devices.</dd>
<dt>block_size</dt>
<dd>Block size of the cache devices.</dd>
<dt>btree_cache_size</dt>
<dd>Amount of memory currently used by the btree cache</dd>
<dt>bucket_size</dt>
<dd>Size of buckets</dd>
<dt>cache&lt;0..n&gt;</dt>
<dd>Symlink to each of the cache devices comprising this cache set.</dd>
<dt>cache_available_percent</dt>
<dd>Percentage of cache device which doesn’t contain dirty data, and could
potentially be used for writeback.  This doesn’t mean this space isn’t used
for clean cached data; the unused statistic (in priority_stats) is typically
much lower.</dd>
<dt>clear_stats</dt>
<dd>Clears the statistics associated with this cache</dd>
<dt>dirty_data</dt>
<dd>Amount of dirty data is in the cache (updated when garbage collection runs).</dd>
<dt>flash_vol_create</dt>
<dd>Echoing a size to this file (in human readable units, k/M/G) creates a thinly
provisioned volume backed by the cache set.</dd>
<dt>io_error_halflife, io_error_limit</dt>
<dd>These determines how many errors we accept before disabling the cache.
Each error is decayed by the half life (in # ios).  If the decaying count
reaches io_error_limit dirty data is written out and the cache is disabled.</dd>
<dt>journal_delay_ms</dt>
<dd>Journal writes will delay for up to this many milliseconds, unless a cache
flush happens sooner. Defaults to 100.</dd>
<dt>root_usage_percent</dt>
<dd>Percentage of the root btree node in use.  If this gets too high the node
will split, increasing the tree depth.</dd>
<dt>stop</dt>
<dd>Write to this file to shut down the cache set - waits until all attached
backing devices have been shut down.</dd>
<dt>tree_depth</dt>
<dd>Depth of the btree (A single node btree has depth 0).</dd>
<dt>unregister</dt>
<dd>Detaches all backing devices and closes the cache devices; if dirty data is
present it will disable writeback caching and wait for it to be flushed.</dd>
</dl>
</div>
<div class="section" id="sysfs-cache-set-internal">
<h3>Sysfs - cache set internal<a class="headerlink" href="#sysfs-cache-set-internal" title="Permalink to this headline">¶</a></h3>
<p>This directory also exposes timings for a number of internal operations, with
separate files for average duration, average frequency, last occurrence and max
duration: garbage collection, btree read, btree node sorts and btree splits.</p>
<dl class="docutils">
<dt>active_journal_entries</dt>
<dd>Number of journal entries that are newer than the index.</dd>
<dt>btree_nodes</dt>
<dd>Total nodes in the btree.</dd>
<dt>btree_used_percent</dt>
<dd>Average fraction of btree in use.</dd>
<dt>bset_tree_stats</dt>
<dd>Statistics about the auxiliary search trees</dd>
<dt>btree_cache_max_chain</dt>
<dd>Longest chain in the btree node cache’s hash table</dd>
<dt>cache_read_races</dt>
<dd>Counts instances where while data was being read from the cache, the bucket
was reused and invalidated - i.e. where the pointer was stale after the read
completed. When this occurs the data is reread from the backing device.</dd>
<dt>trigger_gc</dt>
<dd>Writing to this file forces garbage collection to run.</dd>
</dl>
</div>
<div class="section" id="sysfs-cache-device">
<h3>Sysfs - Cache device<a class="headerlink" href="#sysfs-cache-device" title="Permalink to this headline">¶</a></h3>
<p>Available at /sys/block/&lt;cdev&gt;/bcache</p>
<dl class="docutils">
<dt>block_size</dt>
<dd>Minimum granularity of writes - should match hardware sector size.</dd>
<dt>btree_written</dt>
<dd>Sum of all btree writes, in (kilo/mega/giga) bytes</dd>
<dt>bucket_size</dt>
<dd>Size of buckets</dd>
<dt>cache_replacement_policy</dt>
<dd>One of either lru, fifo or random.</dd>
<dt>discard</dt>
<dd>Boolean; if on a discard/TRIM will be issued to each bucket before it is
reused. Defaults to off, since SATA TRIM is an unqueued command (and thus
slow).</dd>
<dt>freelist_percent</dt>
<dd>Size of the freelist as a percentage of nbuckets. Can be written to to
increase the number of buckets kept on the freelist, which lets you
artificially reduce the size of the cache at runtime. Mostly for testing
purposes (i.e. testing how different size caches affect your hit rate), but
since buckets are discarded when they move on to the freelist will also make
the SSD’s garbage collection easier by effectively giving it more reserved
space.</dd>
<dt>io_errors</dt>
<dd>Number of errors that have occurred, decayed by io_error_halflife.</dd>
<dt>metadata_written</dt>
<dd>Sum of all non data writes (btree writes and all other metadata).</dd>
<dt>nbuckets</dt>
<dd>Total buckets in this cache</dd>
<dt>priority_stats</dt>
<dd>Statistics about how recently data in the cache has been accessed.
This can reveal your working set size.  Unused is the percentage of
the cache that doesn’t contain any data.  Metadata is bcache’s
metadata overhead.  Average is the average priority of cache buckets.
Next is a list of quantiles with the priority threshold of each.</dd>
<dt>written</dt>
<dd>Sum of all data that has been written to the cache; comparison with
btree_written gives the amount of write inflation in bcache.</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pm/index.html" class="btn btn-neutral float-right" title="Power Management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ras.html" class="btn btn-neutral" title="Reliability, Availability and Serviceability" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>