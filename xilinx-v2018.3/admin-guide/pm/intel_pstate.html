

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>intel_pstate CPU Performance Scaling Driver &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Thunderbolt" href="../thunderbolt.html" />
    <link rel="prev" title="CPU Performance Scaling" href="cpufreq.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux kernel user’s and administrator’s guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../README.html">Linux kernel release 4.x &lt;http://kernel.org/&gt;</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kernel-parameters.html">The kernel’s command-line parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../devices.html">Linux allocated devices (4.x+ version)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reporting-bugs.html">Reporting bugs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security-bugs.html">Security bugs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bug-hunting.html">Bug hunting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bug-bisect.html">Bisecting a bug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tainted-kernels.html">Tainted kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ramoops.html">Ramoops oops/panic logger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dynamic-debug-howto.html">Dynamic debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../init.html">Explaining the dreaded “No init found.” boot hang message</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sysfs-rules.html">Rules on how to access information in sysfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../initrd.html">Using the initial RAM disk (initrd)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../serial-console.html">Linux Serial Console</a></li>
<li class="toctree-l2"><a class="reference internal" href="../braille-console.html">Linux Braille Console</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parport.html">Parport</a></li>
<li class="toctree-l2"><a class="reference internal" href="../md.html">RAID arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../module-signing.html">Kernel module signing facility</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sysrq.html">Linux Magic System Request Key Hacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../unicode.html">Unicode support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vga-softcursor.html">Software cursor for VGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../binfmt-misc.html">Kernel Support for miscellaneous (your favourite) Binary Formats v1.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mono.html">Mono(tm) Binary Kernel Support for Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../java.html">Java(tm) Binary Kernel Support for Linux v1.03</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ras.html">Reliability, Availability and Serviceability</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Power Management</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="strategies.html">Power Management Strategies</a></li>
<li class="toctree-l3"><a class="reference internal" href="system-wide.html">System-Wide Power Management</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="working-state.html">Working-State Power Management</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="cpufreq.html">CPU Performance Scaling</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#"><code class="docutils literal"><span class="pre">intel_pstate</span></code> CPU Performance Scaling Driver</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../thunderbolt.html">Thunderbolt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../LSM/index.html">Linux Security Module Usage</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux kernel user’s and administrator’s guide</a> &raquo;</li>
        
          <li><a href="index.html">Power Management</a> &raquo;</li>
        
          <li><a href="working-state.html">Working-State Power Management</a> &raquo;</li>
        
      <li><code class="docutils literal"><span class="pre">intel_pstate</span></code> CPU Performance Scaling Driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/admin-guide/pm/intel_pstate.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="intel-pstate-cpu-performance-scaling-driver">
<h1><code class="docutils literal"><span class="pre">intel_pstate</span></code> CPU Performance Scaling Driver<a class="headerlink" href="#intel-pstate-cpu-performance-scaling-driver" title="Permalink to this headline">¶</a></h1>
<div class="highlight-none"><div class="highlight"><pre><span></span>Copyright (c) 2017 Intel Corp., Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;
</pre></div>
</div>
<div class="section" id="general-information">
<h2>General Information<a class="headerlink" href="#general-information" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">intel_pstate</span></code> is a part of the
<a class="reference internal" href="cpufreq.html"><span class="doc">CPU performance scaling subsystem</span></a> in the Linux kernel
(<code class="docutils literal"><span class="pre">CPUFreq</span></code>).  It is a scaling driver for the Sandy Bridge and later
generations of Intel processors.  Note, however, that some of those processors
may not be supported.  [To understand <code class="docutils literal"><span class="pre">intel_pstate</span></code> it is necessary to know
how <code class="docutils literal"><span class="pre">CPUFreq</span></code> works in general, so this is the time to read <a class="reference internal" href="cpufreq.html"><span class="doc">CPU Performance Scaling</span></a> if
you have not done that yet.]</p>
<p>For the processors supported by <code class="docutils literal"><span class="pre">intel_pstate</span></code>, the P-state concept is broader
than just an operating frequency or an operating performance point (see the
<a class="reference external" href="http://events.linuxfoundation.org/sites/events/files/slides/LinuxConEurope_2015.pdf">LinuxCon Europe 2015 presentation by Kristen Accardi</a> for more
information about that).  For this reason, the representation of P-states used
by <code class="docutils literal"><span class="pre">intel_pstate</span></code> internally follows the hardware specification (for details
refer to <a class="reference external" href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-system-programming-manual-325384.html">Intel® 64 and IA-32 Architectures Software Developer’s Manual
Volume 3: System Programming Guide</a>).  However, the <code class="docutils literal"><span class="pre">CPUFreq</span></code> core
uses frequencies for identifying operating performance points of CPUs and
frequencies are involved in the user space interface exposed by it, so
<code class="docutils literal"><span class="pre">intel_pstate</span></code> maps its internal representation of P-states to frequencies too
(fortunately, that mapping is unambiguous).  At the same time, it would not be
practical for <code class="docutils literal"><span class="pre">intel_pstate</span></code> to supply the <code class="docutils literal"><span class="pre">CPUFreq</span></code> core with a table of
available frequencies due to the possible size of it, so the driver does not do
that.  Some functionality of the core is limited by that.</p>
<p>Since the hardware P-state selection interface used by <code class="docutils literal"><span class="pre">intel_pstate</span></code> is
available at the logical CPU level, the driver always works with individual
CPUs.  Consequently, if <code class="docutils literal"><span class="pre">intel_pstate</span></code> is in use, every <code class="docutils literal"><span class="pre">CPUFreq</span></code> policy
object corresponds to one logical CPU and <code class="docutils literal"><span class="pre">CPUFreq</span></code> policies are effectively
equivalent to CPUs.  In particular, this means that they become “inactive” every
time the corresponding CPU is taken offline and need to be re-initialized when
it goes back online.</p>
<p><code class="docutils literal"><span class="pre">intel_pstate</span></code> is not modular, so it cannot be unloaded, which means that the
only way to pass early-configuration-time parameters to it is via the kernel
command line.  However, its configuration can be adjusted via <code class="docutils literal"><span class="pre">sysfs</span></code> to a
great extent.  In some configurations it even is possible to unregister it via
<code class="docutils literal"><span class="pre">sysfs</span></code> which allows another <code class="docutils literal"><span class="pre">CPUFreq</span></code> scaling driver to be loaded and
registered (see <a class="reference internal" href="#status-attr">below</a>).</p>
</div>
<div class="section" id="operation-modes">
<h2>Operation Modes<a class="headerlink" href="#operation-modes" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">intel_pstate</span></code> can operate in three different modes: in the active mode with
or without hardware-managed P-states support and in the passive mode.  Which of
them will be in effect depends on what kernel command line options are used and
on the capabilities of the processor.</p>
<div class="section" id="active-mode">
<h3>Active Mode<a class="headerlink" href="#active-mode" title="Permalink to this headline">¶</a></h3>
<p>This is the default operation mode of <code class="docutils literal"><span class="pre">intel_pstate</span></code>.  If it works in this
mode, the <code class="docutils literal"><span class="pre">scaling_driver</span></code> policy attribute in <code class="docutils literal"><span class="pre">sysfs</span></code> for all <code class="docutils literal"><span class="pre">CPUFreq</span></code>
policies contains the string “intel_pstate”.</p>
<p>In this mode the driver bypasses the scaling governors layer of <code class="docutils literal"><span class="pre">CPUFreq</span></code> and
provides its own scaling algorithms for P-state selection.  Those algorithms
can be applied to <code class="docutils literal"><span class="pre">CPUFreq</span></code> policies in the same way as generic scaling
governors (that is, through the <code class="docutils literal"><span class="pre">scaling_governor</span></code> policy attribute in
<code class="docutils literal"><span class="pre">sysfs</span></code>).  [Note that different P-state selection algorithms may be chosen for
different policies, but that is not recommended.]</p>
<p>They are not generic scaling governors, but their names are the same as the
names of some of those governors.  Moreover, confusingly enough, they generally
do not work in the same way as the generic governors they share the names with.
For example, the <code class="docutils literal"><span class="pre">powersave</span></code> P-state selection algorithm provided by
<code class="docutils literal"><span class="pre">intel_pstate</span></code> is not a counterpart of the generic <code class="docutils literal"><span class="pre">powersave</span></code> governor
(roughly, it corresponds to the <code class="docutils literal"><span class="pre">schedutil</span></code> and <code class="docutils literal"><span class="pre">ondemand</span></code> governors).</p>
<p>There are two P-state selection algorithms provided by <code class="docutils literal"><span class="pre">intel_pstate</span></code> in the
active mode: <code class="docutils literal"><span class="pre">powersave</span></code> and <code class="docutils literal"><span class="pre">performance</span></code>.  The way they both operate
depends on whether or not the hardware-managed P-states (HWP) feature has been
enabled in the processor and possibly on the processor model.</p>
<p>Which of the P-state selection algorithms is used by default depends on the
<code class="xref c c-macro docutils literal"><span class="pre">CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE</span></code> kernel configuration option.
Namely, if that option is set, the <code class="docutils literal"><span class="pre">performance</span></code> algorithm will be used by
default, and the other one will be used by default if it is not set.</p>
<div class="section" id="active-mode-with-hwp">
<h4>Active Mode With HWP<a class="headerlink" href="#active-mode-with-hwp" title="Permalink to this headline">¶</a></h4>
<p>If the processor supports the HWP feature, it will be enabled during the
processor initialization and cannot be disabled after that.  It is possible
to avoid enabling it by passing the <code class="docutils literal"><span class="pre">intel_pstate=no_hwp</span></code> argument to the
kernel in the command line.</p>
<p>If the HWP feature has been enabled, <code class="docutils literal"><span class="pre">intel_pstate</span></code> relies on the processor to
select P-states by itself, but still it can give hints to the processor’s
internal P-state selection logic.  What those hints are depends on which P-state
selection algorithm has been applied to the given policy (or to the CPU it
corresponds to).</p>
<p>Even though the P-state selection is carried out by the processor automatically,
<code class="docutils literal"><span class="pre">intel_pstate</span></code> registers utilization update callbacks with the CPU scheduler
in this mode.  However, they are not used for running a P-state selection
algorithm, but for periodic updates of the current CPU frequency information to
be made available from the <code class="docutils literal"><span class="pre">scaling_cur_freq</span></code> policy attribute in <code class="docutils literal"><span class="pre">sysfs</span></code>.</p>
<div class="section" id="hwp-performance">
<h5>HWP + <code class="docutils literal"><span class="pre">performance</span></code><a class="headerlink" href="#hwp-performance" title="Permalink to this headline">¶</a></h5>
<p>In this configuration <code class="docutils literal"><span class="pre">intel_pstate</span></code> will write 0 to the processor’s
Energy-Performance Preference (EPP) knob (if supported) or its
Energy-Performance Bias (EPB) knob (otherwise), which means that the processor’s
internal P-state selection logic is expected to focus entirely on performance.</p>
<p>This will override the EPP/EPB setting coming from the <code class="docutils literal"><span class="pre">sysfs</span></code> interface
(see <a class="reference internal" href="#energy-vs-performance-hints">Energy vs Performance Hints</a> below).</p>
<p>Also, in this configuration the range of P-states available to the processor’s
internal P-state selection logic is always restricted to the upper boundary
(that is, the maximum P-state that the driver is allowed to use).</p>
</div>
<div class="section" id="hwp-powersave">
<h5>HWP + <code class="docutils literal"><span class="pre">powersave</span></code><a class="headerlink" href="#hwp-powersave" title="Permalink to this headline">¶</a></h5>
<p>In this configuration <code class="docutils literal"><span class="pre">intel_pstate</span></code> will set the processor’s
Energy-Performance Preference (EPP) knob (if supported) or its
Energy-Performance Bias (EPB) knob (otherwise) to whatever value it was
previously set to via <code class="docutils literal"><span class="pre">sysfs</span></code> (or whatever default value it was
set to by the platform firmware).  This usually causes the processor’s
internal P-state selection logic to be less performance-focused.</p>
</div>
</div>
<div class="section" id="active-mode-without-hwp">
<h4>Active Mode Without HWP<a class="headerlink" href="#active-mode-without-hwp" title="Permalink to this headline">¶</a></h4>
<p>This is the default operation mode for processors that do not support the HWP
feature.  It also is used by default with the <code class="docutils literal"><span class="pre">intel_pstate=no_hwp</span></code> argument
in the kernel command line.  However, in this mode <code class="docutils literal"><span class="pre">intel_pstate</span></code> may refuse
to work with the given processor if it does not recognize it.  [Note that
<code class="docutils literal"><span class="pre">intel_pstate</span></code> will never refuse to work with any processor with the HWP
feature enabled.]</p>
<p>In this mode <code class="docutils literal"><span class="pre">intel_pstate</span></code> registers utilization update callbacks with the
CPU scheduler in order to run a P-state selection algorithm, either
<code class="docutils literal"><span class="pre">powersave</span></code> or <code class="docutils literal"><span class="pre">performance</span></code>, depending on the <code class="docutils literal"><span class="pre">scaling_cur_freq</span></code> policy
setting in <code class="docutils literal"><span class="pre">sysfs</span></code>.  The current CPU frequency information to be made
available from the <code class="docutils literal"><span class="pre">scaling_cur_freq</span></code> policy attribute in <code class="docutils literal"><span class="pre">sysfs</span></code> is
periodically updated by those utilization update callbacks too.</p>
<div class="section" id="performance">
<h5><code class="docutils literal"><span class="pre">performance</span></code><a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h5>
<p>Without HWP, this P-state selection algorithm is always the same regardless of
the processor model and platform configuration.</p>
<p>It selects the maximum P-state it is allowed to use, subject to limits set via
<code class="docutils literal"><span class="pre">sysfs</span></code>, every time the driver configuration for the given CPU is updated
(e.g. via <code class="docutils literal"><span class="pre">sysfs</span></code>).</p>
<p>This is the default P-state selection algorithm if the
<code class="xref c c-macro docutils literal"><span class="pre">CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE</span></code> kernel configuration option
is set.</p>
</div>
<div class="section" id="powersave">
<h5><code class="docutils literal"><span class="pre">powersave</span></code><a class="headerlink" href="#powersave" title="Permalink to this headline">¶</a></h5>
<p>Without HWP, this P-state selection algorithm is similar to the algorithm
implemented by the generic <code class="docutils literal"><span class="pre">schedutil</span></code> scaling governor except that the
utilization metric used by it is based on numbers coming from feedback
registers of the CPU.  It generally selects P-states proportional to the
current CPU utilization.</p>
<p>This algorithm is run by the driver’s utilization update callback for the
given CPU when it is invoked by the CPU scheduler, but not more often than
every 10 ms.  Like in the <code class="docutils literal"><span class="pre">performance</span></code> case, the hardware configuration
is not touched if the new P-state turns out to be the same as the current
one.</p>
<p>This is the default P-state selection algorithm if the
<code class="xref c c-macro docutils literal"><span class="pre">CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE</span></code> kernel configuration option
is not set.</p>
</div>
</div>
</div>
<div class="section" id="passive-mode">
<h3>Passive Mode<a class="headerlink" href="#passive-mode" title="Permalink to this headline">¶</a></h3>
<p>This mode is used if the <code class="docutils literal"><span class="pre">intel_pstate=passive</span></code> argument is passed to the
kernel in the command line (it implies the <code class="docutils literal"><span class="pre">intel_pstate=no_hwp</span></code> setting too).
Like in the active mode without HWP support, in this mode <code class="docutils literal"><span class="pre">intel_pstate</span></code> may
refuse to work with the given processor if it does not recognize it.</p>
<p>If the driver works in this mode, the <code class="docutils literal"><span class="pre">scaling_driver</span></code> policy attribute in
<code class="docutils literal"><span class="pre">sysfs</span></code> for all <code class="docutils literal"><span class="pre">CPUFreq</span></code> policies contains the string “intel_cpufreq”.
Then, the driver behaves like a regular <code class="docutils literal"><span class="pre">CPUFreq</span></code> scaling driver.  That is,
it is invoked by generic scaling governors when necessary to talk to the
hardware in order to change the P-state of a CPU (in particular, the
<code class="docutils literal"><span class="pre">schedutil</span></code> governor can invoke it directly from scheduler context).</p>
<p>While in this mode, <code class="docutils literal"><span class="pre">intel_pstate</span></code> can be used with all of the (generic)
scaling governors listed by the <code class="docutils literal"><span class="pre">scaling_available_governors</span></code> policy attribute
in <code class="docutils literal"><span class="pre">sysfs</span></code> (and the P-state selection algorithms described above are not
used).  Then, it is responsible for the configuration of policy objects
corresponding to CPUs and provides the <code class="docutils literal"><span class="pre">CPUFreq</span></code> core (and the scaling
governors attached to the policy objects) with accurate information on the
maximum and minimum operating frequencies supported by the hardware (including
the so-called “turbo” frequency ranges).  In other words, in the passive mode
the entire range of available P-states is exposed by <code class="docutils literal"><span class="pre">intel_pstate</span></code> to the
<code class="docutils literal"><span class="pre">CPUFreq</span></code> core.  However, in this mode the driver does not register
utilization update callbacks with the CPU scheduler and the <code class="docutils literal"><span class="pre">scaling_cur_freq</span></code>
information comes from the <code class="docutils literal"><span class="pre">CPUFreq</span></code> core (and is the last frequency selected
by the current scaling governor for the given policy).</p>
</div>
</div>
<div class="section" id="turbo-p-states-support">
<span id="turbo"></span><h2>Turbo P-states Support<a class="headerlink" href="#turbo-p-states-support" title="Permalink to this headline">¶</a></h2>
<p>In the majority of cases, the entire range of P-states available to
<code class="docutils literal"><span class="pre">intel_pstate</span></code> can be divided into two sub-ranges that correspond to
different types of processor behavior, above and below a boundary that
will be referred to as the “turbo threshold” in what follows.</p>
<p>The P-states above the turbo threshold are referred to as “turbo P-states” and
the whole sub-range of P-states they belong to is referred to as the “turbo
range”.  These names are related to the Turbo Boost technology allowing a
multicore processor to opportunistically increase the P-state of one or more
cores if there is enough power to do that and if that is not going to cause the
thermal envelope of the processor package to be exceeded.</p>
<p>Specifically, if software sets the P-state of a CPU core within the turbo range
(that is, above the turbo threshold), the processor is permitted to take over
performance scaling control for that core and put it into turbo P-states of its
choice going forward.  However, that permission is interpreted differently by
different processor generations.  Namely, the Sandy Bridge generation of
processors will never use any P-states above the last one set by software for
the given core, even if it is within the turbo range, whereas all of the later
processor generations will take it as a license to use any P-states from the
turbo range, even above the one set by software.  In other words, on those
processors setting any P-state from the turbo range will enable the processor
to put the given core into all turbo P-states up to and including the maximum
supported one as it sees fit.</p>
<p>One important property of turbo P-states is that they are not sustainable.  More
precisely, there is no guarantee that any CPUs will be able to stay in any of
those states indefinitely, because the power distribution within the processor
package may change over time  or the thermal envelope it was designed for might
be exceeded if a turbo P-state was used for too long.</p>
<p>In turn, the P-states below the turbo threshold generally are sustainable.  In
fact, if one of them is set by software, the processor is not expected to change
it to a lower one unless in a thermal stress or a power limit violation
situation (a higher P-state may still be used if it is set for another CPU in
the same package at the same time, for example).</p>
<p>Some processors allow multiple cores to be in turbo P-states at the same time,
but the maximum P-state that can be set for them generally depends on the number
of cores running concurrently.  The maximum turbo P-state that can be set for 3
cores at the same time usually is lower than the analogous maximum P-state for
2 cores, which in turn usually is lower than the maximum turbo P-state that can
be set for 1 core.  The one-core maximum turbo P-state is thus the maximum
supported one overall.</p>
<p>The maximum supported turbo P-state, the turbo threshold (the maximum supported
non-turbo P-state) and the minimum supported P-state are specific to the
processor model and can be determined by reading the processor’s model-specific
registers (MSRs).  Moreover, some processors support the Configurable TDP
(Thermal Design Power) feature and, when that feature is enabled, the turbo
threshold effectively becomes a configurable value that can be set by the
platform firmware.</p>
<p>Unlike <code class="docutils literal"><span class="pre">_PSS</span></code> objects in the ACPI tables, <code class="docutils literal"><span class="pre">intel_pstate</span></code> always exposes
the entire range of available P-states, including the whole turbo range, to the
<code class="docutils literal"><span class="pre">CPUFreq</span></code> core and (in the passive mode) to generic scaling governors.  This
generally causes turbo P-states to be set more often when <code class="docutils literal"><span class="pre">intel_pstate</span></code> is
used relative to ACPI-based CPU performance scaling (see <a class="reference internal" href="#acpi-cpufreq">below</a>
for more information).</p>
<p>Moreover, since <code class="docutils literal"><span class="pre">intel_pstate</span></code> always knows what the real turbo threshold is
(even if the Configurable TDP feature is enabled in the processor), its
<code class="docutils literal"><span class="pre">no_turbo</span></code> attribute in <code class="docutils literal"><span class="pre">sysfs</span></code> (described <a class="reference internal" href="#no-turbo-attr">below</a>) should
work as expected in all cases (that is, if set to disable turbo P-states, it
always should prevent <code class="docutils literal"><span class="pre">intel_pstate</span></code> from using them).</p>
</div>
<div class="section" id="processor-support">
<h2>Processor Support<a class="headerlink" href="#processor-support" title="Permalink to this headline">¶</a></h2>
<p>To handle a given processor <code class="docutils literal"><span class="pre">intel_pstate</span></code> requires a number of different
pieces of information on it to be known, including:</p>
<blockquote>
<div><ul class="simple">
<li>The minimum supported P-state.</li>
<li>The maximum supported <a class="reference internal" href="#turbo">non-turbo P-state</a>.</li>
<li>Whether or not turbo P-states are supported at all.</li>
<li>The maximum supported <a class="reference internal" href="#turbo">one-core turbo P-state</a> (if turbo P-states
are supported).</li>
<li>The scaling formula to translate the driver’s internal representation
of P-states into frequencies and the other way around.</li>
</ul>
</div></blockquote>
<p>Generally, ways to obtain that information are specific to the processor model
or family.  Although it often is possible to obtain all of it from the processor
itself (using model-specific registers), there are cases in which hardware
manuals need to be consulted to get to it too.</p>
<p>For this reason, there is a list of supported processors in <code class="docutils literal"><span class="pre">intel_pstate</span></code> and
the driver initialization will fail if the detected processor is not in that
list, unless it supports the <a class="reference internal" href="#active-mode">HWP feature</a>.  [The interface to
obtain all of the information listed above is the same for all of the processors
supporting the HWP feature, which is why they all are supported by
<code class="docutils literal"><span class="pre">intel_pstate</span></code>.]</p>
</div>
<div class="section" id="user-space-interface-in-sysfs">
<h2>User Space Interface in <code class="docutils literal"><span class="pre">sysfs</span></code><a class="headerlink" href="#user-space-interface-in-sysfs" title="Permalink to this headline">¶</a></h2>
<div class="section" id="global-attributes">
<h3>Global Attributes<a class="headerlink" href="#global-attributes" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">intel_pstate</span></code> exposes several global attributes (files) in <code class="docutils literal"><span class="pre">sysfs</span></code> to
control its functionality at the system level.  They are located in the
<code class="docutils literal"><span class="pre">/sys/devices/system/cpu/cpufreq/intel_pstate/</span></code> directory and affect all
CPUs.</p>
<p>Some of them are not present if the <code class="docutils literal"><span class="pre">intel_pstate=per_cpu_perf_limits</span></code>
argument is passed to the kernel in the command line.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">max_perf_pct</span></code></dt>
<dd><p class="first">Maximum P-state the driver is allowed to set in percent of the
maximum supported performance level (the highest supported <a class="reference internal" href="#turbo">turbo
P-state</a>).</p>
<p class="last">This attribute will not be exposed if the
<code class="docutils literal"><span class="pre">intel_pstate=per_cpu_perf_limits</span></code> argument is present in the kernel
command line.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">min_perf_pct</span></code></dt>
<dd><p class="first">Minimum P-state the driver is allowed to set in percent of the
maximum supported performance level (the highest supported <a class="reference internal" href="#turbo">turbo
P-state</a>).</p>
<p class="last">This attribute will not be exposed if the
<code class="docutils literal"><span class="pre">intel_pstate=per_cpu_perf_limits</span></code> argument is present in the kernel
command line.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">num_pstates</span></code></dt>
<dd><p class="first">Number of P-states supported by the processor (between 0 and 255
inclusive) including both turbo and non-turbo P-states (see
<a class="reference internal" href="#turbo-p-states-support">Turbo P-states Support</a>).</p>
<p>The value of this attribute is not affected by the <code class="docutils literal"><span class="pre">no_turbo</span></code>
setting described <a class="reference internal" href="#no-turbo-attr">below</a>.</p>
<p class="last">This attribute is read-only.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">turbo_pct</span></code></dt>
<dd><p class="first">Ratio of the <a class="reference internal" href="#turbo">turbo range</a> size to the size of the entire
range of supported P-states, in percent.</p>
<p class="last">This attribute is read-only.</p>
</dd>
</dl>
<dl class="docutils" id="no-turbo-attr">
<dt><code class="docutils literal"><span class="pre">no_turbo</span></code></dt>
<dd><p class="first">If set (equal to 1), the driver is not allowed to set any turbo P-states
(see <a class="reference internal" href="#turbo-p-states-support">Turbo P-states Support</a>).  If unset (equalt to 0, which is the
default), turbo P-states can be set by the driver.
[Note that <code class="docutils literal"><span class="pre">intel_pstate</span></code> does not support the general <code class="docutils literal"><span class="pre">boost</span></code>
attribute (supported by some other scaling drivers) which is replaced
by this one.]</p>
<p class="last">This attrubute does not affect the maximum supported frequency value
supplied to the <code class="docutils literal"><span class="pre">CPUFreq</span></code> core and exposed via the policy interface,
but it affects the maximum possible value of per-policy P-state limits
(see <a class="reference internal" href="#interpretation-of-policy-attributes">Interpretation of Policy Attributes</a> below for details).</p>
</dd>
</dl>
<dl class="docutils" id="status-attr">
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd><p class="first">Operation mode of the driver: “active”, “passive” or “off”.</p>
<dl class="docutils">
<dt>“active”</dt>
<dd>The driver is functional and in the <a class="reference internal" href="#active-mode">active mode</a>.</dd>
<dt>“passive”</dt>
<dd>The driver is functional and in the <a class="reference internal" href="#passive-mode">passive mode</a>.</dd>
<dt>“off”</dt>
<dd>The driver is not functional (it is not registered as a scaling
driver with the <code class="docutils literal"><span class="pre">CPUFreq</span></code> core).</dd>
</dl>
<p>This attribute can be written to in order to change the driver’s
operation mode or to unregister it.  The string written to it must be
one of the possible values of it and, if successful, the write will
cause the driver to switch over to the operation mode represented by
that string - or to be unregistered in the “off” case.  [Actually,
switching over from the active mode to the passive mode or the other
way around causes the driver to be unregistered and registered again
with a different set of callbacks, so all of its settings (the global
as well as the per-policy ones) are then reset to their default
values, possibly depending on the target operation mode.]</p>
<p class="last">That only is supported in some configurations, though (for example, if
the <a class="reference internal" href="#active-mode-with-hwp">HWP feature is enabled in the processor</a>,
the operation mode of the driver cannot be changed), and if it is not
supported in the current configuration, writes to this attribute with
fail with an appropriate error.</p>
</dd>
</dl>
</div>
<div class="section" id="interpretation-of-policy-attributes">
<h3>Interpretation of Policy Attributes<a class="headerlink" href="#interpretation-of-policy-attributes" title="Permalink to this headline">¶</a></h3>
<p>The interpretation of some <code class="docutils literal"><span class="pre">CPUFreq</span></code> policy attributes described in
<a class="reference internal" href="cpufreq.html"><span class="doc">CPU Performance Scaling</span></a> is special with <code class="docutils literal"><span class="pre">intel_pstate</span></code> as the current scaling driver
and it generally depends on the driver’s <a class="reference internal" href="#operation-modes">operation mode</a>.</p>
<p>First of all, the values of the <code class="docutils literal"><span class="pre">cpuinfo_max_freq</span></code>, <code class="docutils literal"><span class="pre">cpuinfo_min_freq</span></code> and
<code class="docutils literal"><span class="pre">scaling_cur_freq</span></code> attributes are produced by applying a processor-specific
multiplier to the internal P-state representation used by <code class="docutils literal"><span class="pre">intel_pstate</span></code>.
Also, the values of the <code class="docutils literal"><span class="pre">scaling_max_freq</span></code> and <code class="docutils literal"><span class="pre">scaling_min_freq</span></code>
attributes are capped by the frequency corresponding to the maximum P-state that
the driver is allowed to set.</p>
<p>If the <code class="docutils literal"><span class="pre">no_turbo</span></code> <a class="reference internal" href="#no-turbo-attr">global attribute</a> is set, the driver is
not allowed to use turbo P-states, so the maximum value of <code class="docutils literal"><span class="pre">scaling_max_freq</span></code>
and <code class="docutils literal"><span class="pre">scaling_min_freq</span></code> is limited to the maximum non-turbo P-state frequency.
Accordingly, setting <code class="docutils literal"><span class="pre">no_turbo</span></code> causes <code class="docutils literal"><span class="pre">scaling_max_freq</span></code> and
<code class="docutils literal"><span class="pre">scaling_min_freq</span></code> to go down to that value if they were above it before.
However, the old values of <code class="docutils literal"><span class="pre">scaling_max_freq</span></code> and <code class="docutils literal"><span class="pre">scaling_min_freq</span></code> will be
restored after unsetting <code class="docutils literal"><span class="pre">no_turbo</span></code>, unless these attributes have been written
to after <code class="docutils literal"><span class="pre">no_turbo</span></code> was set.</p>
<p>If <code class="docutils literal"><span class="pre">no_turbo</span></code> is not set, the maximum possible value of <code class="docutils literal"><span class="pre">scaling_max_freq</span></code>
and <code class="docutils literal"><span class="pre">scaling_min_freq</span></code> corresponds to the maximum supported turbo P-state,
which also is the value of <code class="docutils literal"><span class="pre">cpuinfo_max_freq</span></code> in either case.</p>
<p>Next, the following policy attributes have special meaning if
<code class="docutils literal"><span class="pre">intel_pstate</span></code> works in the <a class="reference internal" href="#active-mode">active mode</a>:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">scaling_available_governors</span></code></dt>
<dd>List of P-state selection algorithms provided by <code class="docutils literal"><span class="pre">intel_pstate</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">scaling_governor</span></code></dt>
<dd>P-state selection algorithm provided by <code class="docutils literal"><span class="pre">intel_pstate</span></code> currently in
use with the given policy.</dd>
<dt><code class="docutils literal"><span class="pre">scaling_cur_freq</span></code></dt>
<dd>Frequency of the average P-state of the CPU represented by the given
policy for the time interval between the last two invocations of the
driver’s utilization update callback by the CPU scheduler for that CPU.</dd>
</dl>
<p>The meaning of these attributes in the <a class="reference internal" href="#passive-mode">passive mode</a> is the
same as for other scaling drivers.</p>
<p>Additionally, the value of the <code class="docutils literal"><span class="pre">scaling_driver</span></code> attribute for <code class="docutils literal"><span class="pre">intel_pstate</span></code>
depends on the operation mode of the driver.  Namely, it is either
“intel_pstate” (in the <a class="reference internal" href="#active-mode">active mode</a>) or “intel_cpufreq” (in the
<a class="reference internal" href="#passive-mode">passive mode</a>).</p>
</div>
<div class="section" id="coordination-of-p-state-limits">
<h3>Coordination of P-State Limits<a class="headerlink" href="#coordination-of-p-state-limits" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">intel_pstate</span></code> allows P-state limits to be set in two ways: with the help of
the <code class="docutils literal"><span class="pre">max_perf_pct</span></code> and <code class="docutils literal"><span class="pre">min_perf_pct</span></code> <a class="reference internal" href="#global-attributes">global attributes</a> or via the <code class="docutils literal"><span class="pre">scaling_max_freq</span></code> and <code class="docutils literal"><span class="pre">scaling_min_freq</span></code>
<code class="docutils literal"><span class="pre">CPUFreq</span></code> policy attributes.  The coordination between those limits is based
on the following rules, regardless of the current operation mode of the driver:</p>
<blockquote>
<div><ol class="arabic simple">
<li>All CPUs are affected by the global limits (that is, none of them can be
requested to run faster than the global maximum and none of them can be
requested to run slower than the global minimum).</li>
<li>Each individual CPU is affected by its own per-policy limits (that is, it
cannot be requested to run faster than its own per-policy maximum and it
cannot be requested to run slower than its own per-policy minimum).</li>
<li>The global and per-policy limits can be set independently.</li>
</ol>
</div></blockquote>
<p>If the <a class="reference internal" href="#active-mode-with-hwp">HWP feature is enabled in the processor</a>, the
resulting effective values are written into its registers whenever the limits
change in order to request its internal P-state selection logic to always set
P-states within these limits.  Otherwise, the limits are taken into account by
scaling governors (in the <a class="reference internal" href="#passive-mode">passive mode</a>) and by the driver
every time before setting a new P-state for a CPU.</p>
<p>Additionally, if the <code class="docutils literal"><span class="pre">intel_pstate=per_cpu_perf_limits</span></code> command line argument
is passed to the kernel, <code class="docutils literal"><span class="pre">max_perf_pct</span></code> and <code class="docutils literal"><span class="pre">min_perf_pct</span></code> are not exposed
at all and the only way to set the limits is by using the policy attributes.</p>
</div>
<div class="section" id="energy-vs-performance-hints">
<h3>Energy vs Performance Hints<a class="headerlink" href="#energy-vs-performance-hints" title="Permalink to this headline">¶</a></h3>
<p>If <code class="docutils literal"><span class="pre">intel_pstate</span></code> works in the <a class="reference internal" href="#active-mode-with-hwp">active mode with the HWP feature enabled</a> in the processor, additional attributes are present
in every <code class="docutils literal"><span class="pre">CPUFreq</span></code> policy directory in <code class="docutils literal"><span class="pre">sysfs</span></code>.  They are intended to allow
user space to help <code class="docutils literal"><span class="pre">intel_pstate</span></code> to adjust the processor’s internal P-state
selection logic by focusing it on performance or on energy-efficiency, or
somewhere between the two extremes:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">energy_performance_preference</span></code></dt>
<dd><p class="first">Current value of the energy vs performance hint for the given policy
(or the CPU represented by it).</p>
<p class="last">The hint can be changed by writing to this attribute.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">energy_performance_available_preferences</span></code></dt>
<dd><p class="first">List of strings that can be written to the
<code class="docutils literal"><span class="pre">energy_performance_preference</span></code> attribute.</p>
<p class="last">They represent different energy vs performance hints and should be
self-explanatory, except that <code class="docutils literal"><span class="pre">default</span></code> represents whatever hint
value was set by the platform firmware.</p>
</dd>
</dl>
<p>Strings written to the <code class="docutils literal"><span class="pre">energy_performance_preference</span></code> attribute are
internally translated to integer values written to the processor’s
Energy-Performance Preference (EPP) knob (if supported) or its
Energy-Performance Bias (EPB) knob.</p>
<p>[Note that tasks may by migrated from one CPU to another by the scheduler’s
load-balancing algorithm and if different energy vs performance hints are
set for those CPUs, that may lead to undesirable outcomes.  To avoid such
issues it is better to set the same energy vs performance hint for all CPUs
or to pin every task potentially sensitive to them to a specific CPU.]</p>
</div>
</div>
<div class="section" id="intel-pstate-vs-acpi-cpufreq">
<span id="acpi-cpufreq"></span><h2><code class="docutils literal"><span class="pre">intel_pstate</span></code> vs <code class="docutils literal"><span class="pre">acpi-cpufreq</span></code><a class="headerlink" href="#intel-pstate-vs-acpi-cpufreq" title="Permalink to this headline">¶</a></h2>
<p>On the majority of systems supported by <code class="docutils literal"><span class="pre">intel_pstate</span></code>, the ACPI tables
provided by the platform firmware contain <code class="docutils literal"><span class="pre">_PSS</span></code> objects returning information
that can be used for CPU performance scaling (refer to the <a class="reference external" href="http://www.uefi.org/sites/default/files/resources/ACPI_6_1.pdf">ACPI specification</a>
for details on the <code class="docutils literal"><span class="pre">_PSS</span></code> objects and the format of the information returned
by them).</p>
<p>The information returned by the ACPI <code class="docutils literal"><span class="pre">_PSS</span></code> objects is used by the
<code class="docutils literal"><span class="pre">acpi-cpufreq</span></code> scaling driver.  On systems supported by <code class="docutils literal"><span class="pre">intel_pstate</span></code>
the <code class="docutils literal"><span class="pre">acpi-cpufreq</span></code> driver uses the same hardware CPU performance scaling
interface, but the set of P-states it can use is limited by the <code class="docutils literal"><span class="pre">_PSS</span></code>
output.</p>
<p>On those systems each <code class="docutils literal"><span class="pre">_PSS</span></code> object returns a list of P-states supported by
the corresponding CPU which basically is a subset of the P-states range that can
be used by <code class="docutils literal"><span class="pre">intel_pstate</span></code> on the same system, with one exception: the whole
<a class="reference internal" href="#turbo">turbo range</a> is represented by one item in it (the topmost one).  By
convention, the frequency returned by <code class="docutils literal"><span class="pre">_PSS</span></code> for that item is greater by 1 MHz
than the frequency of the highest non-turbo P-state listed by it, but the
corresponding P-state representation (following the hardware specification)
returned for it matches the maximum supported turbo P-state (or is the
special value 255 meaning essentially “go as high as you can get”).</p>
<p>The list of P-states returned by <code class="docutils literal"><span class="pre">_PSS</span></code> is reflected by the table of
available frequencies supplied by <code class="docutils literal"><span class="pre">acpi-cpufreq</span></code> to the <code class="docutils literal"><span class="pre">CPUFreq</span></code> core and
scaling governors and the minimum and maximum supported frequencies reported by
it come from that list as well.  In particular, given the special representation
of the turbo range described above, this means that the maximum supported
frequency reported by <code class="docutils literal"><span class="pre">acpi-cpufreq</span></code> is higher by 1 MHz than the frequency
of the highest supported non-turbo P-state listed by <code class="docutils literal"><span class="pre">_PSS</span></code> which, of course,
affects decisions made by the scaling governors, except for <code class="docutils literal"><span class="pre">powersave</span></code> and
<code class="docutils literal"><span class="pre">performance</span></code>.</p>
<p>For example, if a given governor attempts to select a frequency proportional to
estimated CPU load and maps the load of 100% to the maximum supported frequency
(possibly multiplied by a constant), then it will tend to choose P-states below
the turbo threshold if <code class="docutils literal"><span class="pre">acpi-cpufreq</span></code> is used as the scaling driver, because
in that case the turbo range corresponds to a small fraction of the frequency
band it can use (1 MHz vs 1 GHz or more).  In consequence, it will only go to
the turbo range for the highest loads and the other loads above 50% that might
benefit from running at turbo frequencies will be given non-turbo P-states
instead.</p>
<p>One more issue related to that may appear on systems supporting the
<a class="reference internal" href="#turbo">Configurable TDP feature</a> allowing the platform firmware to set the
turbo threshold.  Namely, if that is not coordinated with the lists of P-states
returned by <code class="docutils literal"><span class="pre">_PSS</span></code> properly, there may be more than one item corresponding to
a turbo P-state in those lists and there may be a problem with avoiding the
turbo range (if desirable or necessary).  Usually, to avoid using turbo
P-states overall, <code class="docutils literal"><span class="pre">acpi-cpufreq</span></code> simply avoids using the topmost state listed
by <code class="docutils literal"><span class="pre">_PSS</span></code>, but that is not sufficient when there are other turbo P-states in
the list returned by it.</p>
<p>Apart from the above, <code class="docutils literal"><span class="pre">acpi-cpufreq</span></code> works like <code class="docutils literal"><span class="pre">intel_pstate</span></code> in the
<a class="reference internal" href="#passive-mode">passive mode</a>, except that the number of P-states it can set
is limited to the ones listed by the ACPI <code class="docutils literal"><span class="pre">_PSS</span></code> objects.</p>
</div>
<div class="section" id="kernel-command-line-options-for-intel-pstate">
<h2>Kernel Command Line Options for <code class="docutils literal"><span class="pre">intel_pstate</span></code><a class="headerlink" href="#kernel-command-line-options-for-intel-pstate" title="Permalink to this headline">¶</a></h2>
<p>Several kernel command line options can be used to pass early-configuration-time
parameters to <code class="docutils literal"><span class="pre">intel_pstate</span></code> in order to enforce specific behavior of it.  All
of them have to be prepended with the <code class="docutils literal"><span class="pre">intel_pstate=</span></code> prefix.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd>Do not register <code class="docutils literal"><span class="pre">intel_pstate</span></code> as the scaling driver even if the
processor is supported by it.</dd>
<dt><code class="docutils literal"><span class="pre">passive</span></code></dt>
<dd><p class="first">Register <code class="docutils literal"><span class="pre">intel_pstate</span></code> in the <a class="reference internal" href="#passive-mode">passive mode</a> to
start with.</p>
<p class="last">This option implies the <code class="docutils literal"><span class="pre">no_hwp</span></code> one described below.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">force</span></code></dt>
<dd><p class="first">Register <code class="docutils literal"><span class="pre">intel_pstate</span></code> as the scaling driver instead of
<code class="docutils literal"><span class="pre">acpi-cpufreq</span></code> even if the latter is preferred on the given system.</p>
<p>This may prevent some platform features (such as thermal controls and
power capping) that rely on the availability of ACPI P-states
information from functioning as expected, so it should be used with
caution.</p>
<p class="last">This option does not work with processors that are not supported by
<code class="docutils literal"><span class="pre">intel_pstate</span></code> and on platforms where the <code class="docutils literal"><span class="pre">pcc-cpufreq</span></code> scaling
driver is used instead of <code class="docutils literal"><span class="pre">acpi-cpufreq</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">no_hwp</span></code></dt>
<dd>Do not enable the <a class="reference internal" href="#active-mode-with-hwp">hardware-managed P-states (HWP) feature</a> even if it is supported by the processor.</dd>
<dt><code class="docutils literal"><span class="pre">hwp_only</span></code></dt>
<dd>Register <code class="docutils literal"><span class="pre">intel_pstate</span></code> as the scaling driver only if the
<a class="reference internal" href="#active-mode-with-hwp">hardware-managed P-states (HWP) feature</a> is
supported by the processor.</dd>
<dt><code class="docutils literal"><span class="pre">support_acpi_ppc</span></code></dt>
<dd><p class="first">Take ACPI <code class="docutils literal"><span class="pre">_PPC</span></code> performance limits into account.</p>
<p class="last">If the preferred power management profile in the FADT (Fixed ACPI
Description Table) is set to “Enterprise Server” or “Performance
Server”, the ACPI <code class="docutils literal"><span class="pre">_PPC</span></code> limits are taken into account by default
and this option has no effect.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">per_cpu_perf_limits</span></code></dt>
<dd>Use per-logical-CPU P-State limits (see <a class="reference internal" href="#coordination-of-p-state-limits">Coordination of P-state
Limits</a> for details).</dd>
</dl>
</div>
<div class="section" id="diagnostics-and-tuning">
<h2>Diagnostics and Tuning<a class="headerlink" href="#diagnostics-and-tuning" title="Permalink to this headline">¶</a></h2>
<div class="section" id="trace-events">
<h3>Trace Events<a class="headerlink" href="#trace-events" title="Permalink to this headline">¶</a></h3>
<p>There are two static trace events that can be used for <code class="docutils literal"><span class="pre">intel_pstate</span></code>
diagnostics.  One of them is the <code class="docutils literal"><span class="pre">cpu_frequency</span></code> trace event generally used
by <code class="docutils literal"><span class="pre">CPUFreq</span></code>, and the other one is the <code class="docutils literal"><span class="pre">pstate_sample</span></code> trace event specific
to <code class="docutils literal"><span class="pre">intel_pstate</span></code>.  Both of them are triggered by <code class="docutils literal"><span class="pre">intel_pstate</span></code> only if
it works in the <a class="reference internal" href="#active-mode">active mode</a>.</p>
<p>The following sequence of shell commands can be used to enable them and see
their output (if the kernel is generally configured to support event tracing):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># cd /sys/kernel/debug/tracing/
# echo 1 &gt; events/power/pstate_sample/enable
# echo 1 &gt; events/power/cpu_frequency/enable
# cat trace
gnome-terminal--4510  [001] ..s.  1177.680733: pstate_sample: core_busy=107 scaled=94 from=26 to=26 mperf=1143818 aperf=1230607 tsc=29838618 freq=2474476
cat-5235  [002] ..s.  1177.681723: cpu_frequency: state=2900000 cpu_id=2
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">intel_pstate</span></code> works in the <a class="reference internal" href="#passive-mode">passive mode</a>, the
<code class="docutils literal"><span class="pre">cpu_frequency</span></code> trace event will be triggered either by the <code class="docutils literal"><span class="pre">schedutil</span></code>
scaling governor (for the policies it is attached to), or by the <code class="docutils literal"><span class="pre">CPUFreq</span></code>
core (for the policies with other scaling governors).</p>
</div>
<div class="section" id="ftrace">
<h3><code class="docutils literal"><span class="pre">ftrace</span></code><a class="headerlink" href="#ftrace" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">ftrace</span></code> interface can be used for low-level diagnostics of
<code class="docutils literal"><span class="pre">intel_pstate</span></code>.  For example, to check how often the function to set a
P-state is called, the <code class="docutils literal"><span class="pre">ftrace</span></code> filter can be set to to
<code class="xref c c-func docutils literal"><span class="pre">intel_pstate_set_pstate()</span></code>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># cd /sys/kernel/debug/tracing/
# cat available_filter_functions | grep -i pstate
intel_pstate_set_pstate
intel_pstate_cpu_init
...
# echo intel_pstate_set_pstate &gt; set_ftrace_filter
# echo function &gt; current_tracer
# cat trace | head -15
# tracer: function
#
# entries-in-buffer/entries-written: 80/80   #P:4
#
#                              _-----=&gt; irqs-off
#                             / _----=&gt; need-resched
#                            | / _---=&gt; hardirq/softirq
#                            || / _--=&gt; preempt-depth
#                            ||| /     delay
#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION
#              | |       |   ||||       |         |
            Xorg-3129  [000] ..s.  2537.644844: intel_pstate_set_pstate &lt;-intel_pstate_timer_func
 gnome-terminal--4510  [002] ..s.  2537.649844: intel_pstate_set_pstate &lt;-intel_pstate_timer_func
     gnome-shell-3409  [001] ..s.  2537.650850: intel_pstate_set_pstate &lt;-intel_pstate_timer_func
          &lt;idle&gt;-0     [000] ..s.  2537.654843: intel_pstate_set_pstate &lt;-intel_pstate_timer_func
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../thunderbolt.html" class="btn btn-neutral float-right" title="Thunderbolt" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cpufreq.html" class="btn btn-neutral" title="CPU Performance Scaling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>