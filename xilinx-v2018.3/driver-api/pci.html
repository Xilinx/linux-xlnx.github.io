

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PCI Support Library &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Serial Peripheral Interface (SPI)" href="spi.html" />
    <link rel="prev" title="USB3 debug port" href="usb/usb3-debug-port.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>PCI Support Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/pci.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pci-support-library">
<h1>PCI Support Library<a class="headerlink" href="#pci-support-library" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.pci_bus_max_busnr">
unsigned char <code class="descname">pci_bus_max_busnr</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_max_busnr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns maximum PCI bus number of given bus’ children</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>pointer to PCI bus structure to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus, returns the highest PCI bus number present in the set
including the given PCI bus and its list of child PCI buses.</p>
<dl class="function">
<dt id="c.pci_find_capability">
int <code class="descname">pci_find_capability</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>query for devices’ capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cap</span></code></dt>
<dd>capability code</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell if a device supports a given PCI capability.
Returns the address of the requested capability structure within the
device’s PCI configuration space or 0 in case the device does not
support it.  Possible values for <strong>cap</strong>:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">PCI_CAP_ID_PM</span></code>           Power Management
<code class="docutils literal"><span class="pre">PCI_CAP_ID_AGP</span></code>          Accelerated Graphics Port
<code class="docutils literal"><span class="pre">PCI_CAP_ID_VPD</span></code>          Vital Product Data
<code class="docutils literal"><span class="pre">PCI_CAP_ID_SLOTID</span></code>       Slot Identification
<code class="docutils literal"><span class="pre">PCI_CAP_ID_MSI</span></code>          Message Signalled Interrupts
<code class="docutils literal"><span class="pre">PCI_CAP_ID_CHSWP</span></code>        CompactPCI HotSwap
<code class="docutils literal"><span class="pre">PCI_CAP_ID_PCIX</span></code>         PCI-X
<code class="docutils literal"><span class="pre">PCI_CAP_ID_EXP</span></code>          PCI Express</div></blockquote>
<dl class="function">
<dt id="c.pci_bus_find_capability">
int <code class="descname">pci_bus_find_capability</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em>, unsigned int<em>&nbsp;devfn</em>, int<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_find_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>query for devices’ capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the PCI bus to query</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cap</span></code></dt>
<dd>capability code</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.pci_find_capability" title="pci_find_capability"><code class="xref c c-func docutils literal"><span class="pre">pci_find_capability()</span></code></a> but works for pci devices that do not have a
pci_dev structure set up yet.</p>
<p>Returns the address of the requested capability structure within the
device’s PCI configuration space or 0 in case the device does not
support it.</p>
<dl class="function">
<dt id="c.pci_find_next_ext_capability">
int <code class="descname">pci_find_next_ext_capability</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;start</em>, int<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_ext_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an extended capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>address at which to start looking (0 to start at beginning of list)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cap</span></code></dt>
<dd>capability code</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the next matching extended capability structure
within the device’s PCI configuration space or 0 if the device does
not support it.  Some capabilities can occur several times, e.g., the
vendor-specific capability, and this provides a way to find them all.</p>
<dl class="function">
<dt id="c.pci_find_ext_capability">
int <code class="descname">pci_find_ext_capability</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_ext_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an extended capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cap</span></code></dt>
<dd>capability code</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the requested extended capability structure
within the device’s PCI configuration space or 0 if the device does
not support it.  Possible values for <strong>cap</strong>:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">PCI_EXT_CAP_ID_ERR</span></code>         Advanced Error Reporting
<code class="docutils literal"><span class="pre">PCI_EXT_CAP_ID_VC</span></code>          Virtual Channel
<code class="docutils literal"><span class="pre">PCI_EXT_CAP_ID_DSN</span></code>         Device Serial Number
<code class="docutils literal"><span class="pre">PCI_EXT_CAP_ID_PWR</span></code>         Power Budgeting</div></blockquote>
<dl class="function">
<dt id="c.pci_find_next_ht_capability">
int <code class="descname">pci_find_next_ht_capability</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;pos</em>, int<em>&nbsp;ht_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_ht_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>query a device’s Hypertransport capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>Position from which to continue searching</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ht_cap</span></code></dt>
<dd>Hypertransport capability code</dd>
</dl>
<p><strong>Description</strong></p>
<p>To be used in conjunction with <a class="reference internal" href="#c.pci_find_ht_capability" title="pci_find_ht_capability"><code class="xref c c-func docutils literal"><span class="pre">pci_find_ht_capability()</span></code></a> to search for
all capabilities matching <strong>ht_cap</strong>. <strong>pos</strong> should always be a value returned
from <a class="reference internal" href="#c.pci_find_ht_capability" title="pci_find_ht_capability"><code class="xref c c-func docutils literal"><span class="pre">pci_find_ht_capability()</span></code></a>.</p>
<p>NB. To be 100% safe against broken PCI devices, the caller should take
steps to avoid an infinite loop.</p>
<dl class="function">
<dt id="c.pci_find_ht_capability">
int <code class="descname">pci_find_ht_capability</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;ht_cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_ht_capability" title="Permalink to this definition">¶</a></dt>
<dd><p>query a device’s Hypertransport capabilities</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ht_cap</span></code></dt>
<dd>Hypertransport capability code</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell if a device supports a given Hypertransport capability.
Returns an address within the device’s PCI configuration space
or 0 in case the device does not support the request capability.
The address points to the PCI capability, of type PCI_CAP_ID_HT,
which has a Hypertransport capability matching <strong>ht_cap</strong>.</p>
<dl class="function">
<dt id="c.pci_find_parent_resource">
struct resource * <code class="descname">pci_find_parent_resource</code><span class="sig-paren">(</span>const struct pci_dev *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_parent_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>return resource region of parent bus of given region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device structure contains resources to be searched</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>child resource record for which parent is sought</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For given resource region of given device, return the resource
region of parent bus the given region is contained in.</div></blockquote>
<dl class="function">
<dt id="c.pci_find_resource">
struct resource * <code class="descname">pci_find_resource</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Return matching PCI device resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Resource to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Goes over standard PCI resources (BARs) and checks if the given resource
is partially or fully contained in any of them. In that case the
matching resource is returned, <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.pci_find_pcie_root_port">
struct pci_dev * <code class="descname">pci_find_pcie_root_port</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_pcie_root_port" title="Permalink to this definition">¶</a></dt>
<dd><p>return PCIe Root Port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>Traverse up the parent chain and return the PCIe Root Port PCI Device
for a given PCI Device.</p>
<dl class="function">
<dt id="c.__pci_complete_power_transition">
int <code class="descname">__pci_complete_power_transition</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, pci_power_t<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_complete_power_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete power transition of a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to handle.</dd>
<dt><code class="docutils literal"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt>
<dd>State to put the device into.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should not be called directly by device drivers.</p>
<dl class="function">
<dt id="c.pci_set_power_state">
int <code class="descname">pci_set_power_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, pci_power_t<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_power_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the power state of a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to handle.</dd>
<dt><code class="docutils literal"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt>
<dd>PCI power state (D0, D1, D2, D3hot) to put the device into.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transition a device to a new power state, using the platform firmware and/or
the device’s PCI PM registers.</p>
<p>RETURN VALUE:
-EINVAL if the requested state is invalid.
-EIO if device does not support PCI PM or its PM capabilities register has a
wrong version, or device doesn’t support the requested state.
0 if the transition is to D1 or D2 but D1 and D2 are not supported.
0 if device already is in the requested state.
0 if the transition is to D3 but D3 is not supported.
0 if device’s power state has been successfully changed.</p>
<dl class="function">
<dt id="c.pci_choose_state">
pci_power_t <code class="descname">pci_choose_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, pm_message_t<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_choose_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the power state of a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to be suspended</dd>
<dt><code class="docutils literal"><span class="pre">pm_message_t</span> <span class="pre">state</span></code></dt>
<dd>target sleep state for the whole system. This is the value
that is passed to <code class="xref c c-func docutils literal"><span class="pre">suspend()</span></code> function.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns PCI power state suitable for given device and given system
message.</p>
<dl class="function">
<dt id="c.pci_save_state">
int <code class="descname">pci_save_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_save_state" title="Permalink to this definition">¶</a></dt>
<dd><p>save the PCI configuration space of a device before suspending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd><ul class="first last simple">
<li>PCI device that we’re dealing with</li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="c.pci_restore_state">
void <code class="descname">pci_restore_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_restore_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore the saved state of a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd><ul class="first last simple">
<li>PCI device that we’re dealing with</li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="c.pci_store_saved_state">
struct pci_saved_state * <code class="descname">pci_store_saved_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_store_saved_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and return an opaque struct containing the device saved state.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device that we’re dealing with</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return NULL if no state or error.</p>
<dl class="function">
<dt id="c.pci_load_saved_state">
int <code class="descname">pci_load_saved_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, struct pci_saved_state *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_load_saved_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reload the provided save state into struct pci_dev.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device that we’re dealing with</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_saved_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>Saved state returned from <a class="reference internal" href="#c.pci_store_saved_state" title="pci_store_saved_state"><code class="xref c c-func docutils literal"><span class="pre">pci_store_saved_state()</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.pci_load_and_free_saved_state">
int <code class="descname">pci_load_and_free_saved_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, struct pci_saved_state **<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_load_and_free_saved_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reload the save state pointed to by state, and free the memory allocated for it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device that we’re dealing with</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_saved_state</span> <span class="pre">**</span> <span class="pre">state</span></code></dt>
<dd>Pointer to saved state returned from <a class="reference internal" href="#c.pci_store_saved_state" title="pci_store_saved_state"><code class="xref c c-func docutils literal"><span class="pre">pci_store_saved_state()</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.pci_reenable_device">
int <code class="descname">pci_reenable_device</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reenable_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume abandoned device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to be resumed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Note this function is a backend of pci_default_resume and is not supposed
to be called by normal code, write proper resume handler and use it instead.</div></blockquote>
<dl class="function">
<dt id="c.pci_enable_device_io">
int <code class="descname">pci_enable_device_io</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device_io" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a device for use with IO space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Initialize device before it’s used by a driver. Ask low-level code
to enable I/O resources. Wake up the device if it was suspended.
Beware, this function can fail.</div></blockquote>
<dl class="function">
<dt id="c.pci_enable_device_mem">
int <code class="descname">pci_enable_device_mem</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device_mem" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a device for use with Memory space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Initialize device before it’s used by a driver. Ask low-level code
to enable Memory resources. Wake up the device if it was suspended.
Beware, this function can fail.</div></blockquote>
<dl class="function">
<dt id="c.pci_enable_device">
int <code class="descname">pci_enable_device</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize device before it’s used by a driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize device before it’s used by a driver. Ask low-level code
to enable I/O and memory. Wake up the device if it was suspended.
Beware, this function can fail.</p>
<p>Note we don’t actually enable the device many times if we call
this function repeatedly (we just increment the count).</p>
</div></blockquote>
<dl class="function">
<dt id="c.pcim_enable_device">
int <code class="descname">pcim_enable_device</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcim_enable_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal"><span class="pre">pci_enable_device()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal"><span class="pre">pci_enable_device()</span></code></a>.</p>
<dl class="function">
<dt id="c.pcim_pin_device">
void <code class="descname">pcim_pin_device</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcim_pin_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin managed PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device to pin</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pin managed PCI device <strong>pdev</strong>.  Pinned device won’t be disabled on
driver detach.  <strong>pdev</strong> must have been enabled with
<a class="reference internal" href="#c.pcim_enable_device" title="pcim_enable_device"><code class="xref c c-func docutils literal"><span class="pre">pcim_enable_device()</span></code></a>.</p>
<dl class="function">
<dt id="c.pci_disable_device">
void <code class="descname">pci_disable_device</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable PCI device after use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to be disabled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Signal to the system that the PCI device is not in use by the system
anymore.  This only involves disabling PCI bus-mastering, if active.</p>
<p>Note we don’t actually disable the device until all callers of
<a class="reference internal" href="#c.pci_enable_device" title="pci_enable_device"><code class="xref c c-func docutils literal"><span class="pre">pci_enable_device()</span></code></a> have called <a class="reference internal" href="#c.pci_disable_device" title="pci_disable_device"><code class="xref c c-func docutils literal"><span class="pre">pci_disable_device()</span></code></a>.</p>
<dl class="function">
<dt id="c.pci_set_pcie_reset_state">
int <code class="descname">pci_set_pcie_reset_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, enum pcie_reset_state<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_pcie_reset_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set reset state for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCIe device reset</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">pcie_reset_state</span> <span class="pre">state</span></code></dt>
<dd>Reset state to enter into</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the PCI reset state for the device.</p>
<dl class="function">
<dt id="c.pci_pme_capable">
bool <code class="descname">pci_pme_capable</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, pci_power_t<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_pme_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>check the capability of PCI device to generate PME#</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to handle.</dd>
<dt><code class="docutils literal"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt>
<dd>PCI state from which device will issue PME#.</dd>
</dl>
<dl class="function">
<dt id="c.pci_pme_active">
void <code class="descname">pci_pme_active</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_pme_active" title="Permalink to this definition">¶</a></dt>
<dd><p>enable or disable PCI device’s PME# function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to handle.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>‘true’ to enable PME# generation; ‘false’ to disable it.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must verify that the device is capable of generating PME# before
calling this function with <strong>enable</strong> equal to ‘true’.</p>
<dl class="function">
<dt id="c.pci_enable_wake">
int <code class="descname">pci_enable_wake</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, pci_power_t<em>&nbsp;state</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>enable PCI device as wakeup event source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device affected</dd>
<dt><code class="docutils literal"><span class="pre">pci_power_t</span> <span class="pre">state</span></code></dt>
<dd>PCI state from which device will issue wakeup events</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>True to enable event generation; false to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enables the device as a wakeup event source, or disables it.
When such events involves platform-specific hooks, those hooks are
called automatically by this routine.</p>
<p>Devices with legacy power management (no standard PCI PM capabilities)
always require such platform hooks.</p>
<p>RETURN VALUE:
0 is returned on success
-EINVAL is returned if device is not supposed to wake up the system
Error code depending on the platform is returned if both the platform and
the native mechanism fail to enable the generation of wake-up events</p>
<dl class="function">
<dt id="c.pci_wake_from_d3">
int <code class="descname">pci_wake_from_d3</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, bool<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_wake_from_d3" title="Permalink to this definition">¶</a></dt>
<dd><p>enable/disable device to wake up from D3_hot or D3_cold</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to prepare</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">enable</span></code></dt>
<dd>True to enable wake-up event generation; false to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many drivers want the device to wake up the system from D3_hot or D3_cold
and this function allows them to set that up cleanly - <a class="reference internal" href="#c.pci_enable_wake" title="pci_enable_wake"><code class="xref c c-func docutils literal"><span class="pre">pci_enable_wake()</span></code></a>
should not be called twice in a row to enable wake-up due to PCI PM vs ACPI
ordering constraints.</p>
<p>This function only returns error code if the device is not capable of
generating PME# from both D3_hot and D3_cold, and the platform is unable to
enable wake-up power for it.</p>
<dl class="function">
<dt id="c.pci_prepare_to_sleep">
int <code class="descname">pci_prepare_to_sleep</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_prepare_to_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare PCI device for system-wide transition into a sleep state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to handle.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Choose the power state appropriate for the device depending on whether
it can wake up the system and/or is power manageable by the platform
(PCI_D3hot is the default) and put the device into that state.</p>
<dl class="function">
<dt id="c.pci_back_from_sleep">
int <code class="descname">pci_back_from_sleep</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_back_from_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>turn PCI device on during system-wide transition into working state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to handle.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable device’s system wake-up capability and put it into D0.</p>
<dl class="function">
<dt id="c.pci_dev_run_wake">
bool <code class="descname">pci_dev_run_wake</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_run_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device can generate run-time wake-up events.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to check.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the device itself is capable of generating wake-up events
(through the platform or using the native PCIe PME) or if the device supports
PME and one of its upstream bridges can generate wake-up events.</p>
<dl class="function">
<dt id="c.pci_d3cold_enable">
void <code class="descname">pci_d3cold_enable</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_d3cold_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable D3cold for device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers to enable D3cold from the device
they handle.  It also updates upstream PCI bridge PM capabilities
accordingly.</p>
<dl class="function">
<dt id="c.pci_d3cold_disable">
void <code class="descname">pci_d3cold_disable</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_d3cold_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable D3cold for device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers to disable D3cold from the device
they handle.  It also updates upstream PCI bridge PM capabilities
accordingly.</p>
<dl class="function">
<dt id="c.pci_common_swizzle">
u8 <code class="descname">pci_common_swizzle</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, u8 *<em>&nbsp;pinp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_common_swizzle" title="Permalink to this definition">¶</a></dt>
<dd><p>swizzle INTx all the way to root bridge</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">pinp</span></code></dt>
<dd>pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI
bridges all the way up to a PCI root bus.</p>
<dl class="function">
<dt id="c.pci_release_region">
void <code class="descname">pci_release_region</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;bar</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a PCI bar</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device whose resources were previously reserved by pci_request_region</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bar</span></code></dt>
<dd>BAR to release</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Releases the PCI I/O and memory resources previously reserved by a
successful call to pci_request_region.  Call this function only
after all use of the PCI regions has ceased.</div></blockquote>
<dl class="function">
<dt id="c.pci_request_region">
int <code class="descname">pci_request_region</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;bar</em>, const char *<em>&nbsp;res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_region" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve PCI I/O and memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device whose resources are to be reserved</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bar</span></code></dt>
<dd>BAR to be reserved</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">res_name</span></code></dt>
<dd>Name to be associated with resource</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Mark the PCI region associated with PCI device <strong>pdev</strong> BAR <strong>bar</strong> as
being reserved by owner <strong>res_name</strong>.  Do not access any
address inside the PCI regions unless this call returns
successfully.</p>
<p>Returns 0 on success, or <code class="docutils literal"><span class="pre">EBUSY</span></code> on error.  A warning
message is also printed on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pci_request_region_exclusive">
int <code class="descname">pci_request_region_exclusive</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;bar</em>, const char *<em>&nbsp;res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_region_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserved PCI I/O and memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device whose resources are to be reserved</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bar</span></code></dt>
<dd>BAR to be reserved</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">res_name</span></code></dt>
<dd>Name to be associated with resource.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Mark the PCI region associated with PCI device <strong>pdev</strong> BR <strong>bar</strong> as
being reserved by owner <strong>res_name</strong>.  Do not access any
address inside the PCI regions unless this call returns
successfully.</p>
<p>Returns 0 on success, or <code class="docutils literal"><span class="pre">EBUSY</span></code> on error.  A warning
message is also printed on failure.</p>
<p>The key difference that _exclusive makes it that userspace is
explicitly not allowed to map the resource via /dev/mem or
sysfs.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pci_release_selected_regions">
void <code class="descname">pci_release_selected_regions</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;bars</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_selected_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Release selected PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device whose resources were previously reserved</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bars</span></code></dt>
<dd>Bitmask of BARs to be released</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release selected PCI I/O and memory resources previously reserved.
Call this function only after all use of the PCI regions has ceased.</p>
<dl class="function">
<dt id="c.pci_request_selected_regions">
int <code class="descname">pci_request_selected_regions</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;bars</em>, const char *<em>&nbsp;res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_selected_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve selected PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device whose resources are to be reserved</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bars</span></code></dt>
<dd>Bitmask of BARs to be requested</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">res_name</span></code></dt>
<dd>Name to be associated with resource</dd>
</dl>
<dl class="function">
<dt id="c.pci_release_regions">
void <code class="descname">pci_release_regions</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_release_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Release reserved PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device whose resources were previously reserved by pci_request_regions</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Releases all PCI I/O and memory resources previously reserved by a
successful call to pci_request_regions.  Call this function only
after all use of the PCI regions has ceased.</div></blockquote>
<dl class="function">
<dt id="c.pci_request_regions">
int <code class="descname">pci_request_regions</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, const char *<em>&nbsp;res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserved PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device whose resources are to be reserved</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">res_name</span></code></dt>
<dd>Name to be associated with resource.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Mark all PCI regions associated with PCI device <strong>pdev</strong> as
being reserved by owner <strong>res_name</strong>.  Do not access any
address inside the PCI regions unless this call returns
successfully.</p>
<p>Returns 0 on success, or <code class="docutils literal"><span class="pre">EBUSY</span></code> on error.  A warning
message is also printed on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pci_request_regions_exclusive">
int <code class="descname">pci_request_regions_exclusive</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, const char *<em>&nbsp;res_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_regions_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserved PCI I/O and memory resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device whose resources are to be reserved</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">res_name</span></code></dt>
<dd>Name to be associated with resource.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Mark all PCI regions associated with PCI device <strong>pdev</strong> as
being reserved by owner <strong>res_name</strong>.  Do not access any
address inside the PCI regions unless this call returns
successfully.</p>
<p><a class="reference internal" href="#c.pci_request_regions_exclusive" title="pci_request_regions_exclusive"><code class="xref c c-func docutils literal"><span class="pre">pci_request_regions_exclusive()</span></code></a> will mark the region so that
/dev/mem and the sysfs MMIO access will not be allowed.</p>
<p>Returns 0 on success, or <code class="docutils literal"><span class="pre">EBUSY</span></code> on error.  A warning
message is also printed on failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pci_remap_iospace">
int <code class="descname">pci_remap_iospace</code><span class="sig-paren">(</span>const struct resource *<em>&nbsp;res</em>, phys_addr_t<em>&nbsp;phys_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remap_iospace" title="Permalink to this definition">¶</a></dt>
<dd><p>Remap the memory mapped I/O space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Resource describing the I/O space</dd>
<dt><code class="docutils literal"><span class="pre">phys_addr_t</span> <span class="pre">phys_addr</span></code></dt>
<dd>physical address of range to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remap the memory mapped I/O space described by the <strong>res</strong>
and the CPU physical address <strong>phys_addr</strong> into virtual address space.
Only architectures that have memory mapped IO functions defined
(and the PCI_IOBASE value defined) should call this function.</div></blockquote>
<dl class="function">
<dt id="c.pci_unmap_iospace">
void <code class="descname">pci_unmap_iospace</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unmap_iospace" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmap the memory mapped I/O space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>resource to be unmapped</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Unmap the CPU virtual address <strong>res</strong> from virtual address space.
Only architectures that have memory mapped IO functions defined
(and the PCI_IOBASE value defined) should call this function.</div></blockquote>
<dl class="function">
<dt id="c.devm_pci_remap_cfgspace">
void __iomem * <code class="descname">devm_pci_remap_cfgspace</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, resource_size_t<em>&nbsp;offset</em>, resource_size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pci_remap_cfgspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <code class="xref c c-func docutils literal"><span class="pre">pci_remap_cfgspace()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Generic device to remap IO address for</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">offset</span></code></dt>
<dd>Resource address to map</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of map</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <code class="xref c c-func docutils literal"><span class="pre">pci_remap_cfgspace()</span></code>.  Map is automatically unmapped on driver
detach.</p>
<dl class="function">
<dt id="c.devm_pci_remap_cfg_resource">
void __iomem * <code class="descname">devm_pci_remap_cfg_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_pci_remap_cfg_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>check, request region and ioremap cfg resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>generic device to handle the resource for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>configuration space resource to be handled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that a resource is a valid memory region, requests the memory
region and ioremaps with <code class="xref c c-func docutils literal"><span class="pre">pci_remap_cfgspace()</span></code> API that ensures the
proper PCI configuration space memory attributes are guaranteed.</p>
<p>All operations are managed and will be undone on driver detach.</p>
<p>Returns a pointer to the remapped memory or an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> encoded error code
on failure. Usage example:</p>
<blockquote>
<div><p>res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
base = devm_pci_remap_cfg_resource(<code class="xref c c-type docutils literal"><span class="pre">pdev-&gt;dev</span></code>, res);
if (IS_ERR(base))</p>
<blockquote>
<div>return PTR_ERR(base);</div></blockquote>
</div></blockquote>
<dl class="function">
<dt id="c.pci_set_master">
void <code class="descname">pci_set_master</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_master" title="Permalink to this definition">¶</a></dt>
<dd><p>enables bus-mastering for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device to enable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables bus-mastering on the device and calls <code class="xref c c-func docutils literal"><span class="pre">pcibios_set_master()</span></code>
to do the needed arch specific settings.</p>
<dl class="function">
<dt id="c.pci_clear_master">
void <code class="descname">pci_clear_master</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_clear_master" title="Permalink to this definition">¶</a></dt>
<dd><p>disables bus-mastering for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device to disable</dd>
</dl>
<dl class="function">
<dt id="c.pci_set_cacheline_size">
int <code class="descname">pci_set_cacheline_size</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_cacheline_size" title="Permalink to this definition">¶</a></dt>
<dd><p>ensure the CACHE_LINE_SIZE register is programmed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device for which MWI is to be enabled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_set_mwi.
Originally copied from drivers/net/acenic.c.
Copyright 1998-2001 by Jes Sorensen, &lt;jes**trained**-monkey.org&gt;.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
<dl class="function">
<dt id="c.pci_set_mwi">
int <code class="descname">pci_set_mwi</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_mwi" title="Permalink to this definition">¶</a></dt>
<dd><p>enables memory-write-invalidate PCI transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device for which MWI is enabled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables the Memory-Write-Invalidate transaction in <code class="docutils literal"><span class="pre">PCI_COMMAND</span></code>.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
<dl class="function">
<dt id="c.pci_try_set_mwi">
int <code class="descname">pci_try_set_mwi</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_try_set_mwi" title="Permalink to this definition">¶</a></dt>
<dd><p>enables memory-write-invalidate PCI transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device for which MWI is enabled</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables the Memory-Write-Invalidate transaction in <code class="docutils literal"><span class="pre">PCI_COMMAND</span></code>.
Callers are not required to check the return value.</p>
<p><strong>Return</strong></p>
<p>An appropriate -ERRNO error value on error, or zero for success.</p>
<dl class="function">
<dt id="c.pci_clear_mwi">
void <code class="descname">pci_clear_mwi</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_clear_mwi" title="Permalink to this definition">¶</a></dt>
<dd><p>disables Memory-Write-Invalidate for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables PCI Memory-Write-Invalidate transaction on the device</p>
<dl class="function">
<dt id="c.pci_intx">
void <code class="descname">pci_intx</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_intx" title="Permalink to this definition">¶</a></dt>
<dd><p>enables/disables PCI INTx for device dev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>the PCI device to operate on</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">enable</span></code></dt>
<dd>boolean: whether to enable or disable PCI INTx</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables/disables PCI INTx for device dev</p>
<dl class="function">
<dt id="c.pci_check_and_mask_intx">
bool <code class="descname">pci_check_and_mask_intx</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_check_and_mask_intx" title="Permalink to this definition">¶</a></dt>
<dd><p>mask INTx on pending interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the device dev has its INTx line asserted, mask it and
return true in that case. False is returned if no interrupt was
pending.</p>
<dl class="function">
<dt id="c.pci_check_and_unmask_intx">
bool <code class="descname">pci_check_and_unmask_intx</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_check_and_unmask_intx" title="Permalink to this definition">¶</a></dt>
<dd><p>unmask INTx if no interrupt is pending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the device dev has its INTx line asserted, unmask it if not
and return true. False is returned and the mask remains active if
there was still an interrupt pending.</p>
<dl class="function">
<dt id="c.pci_wait_for_pending_transaction">
int <code class="descname">pci_wait_for_pending_transaction</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_wait_for_pending_transaction" title="Permalink to this definition">¶</a></dt>
<dd><p>waits for pending transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if transaction is pending 1 otherwise.</p>
<dl class="function">
<dt id="c.pcie_flr">
void <code class="descname">pcie_flr</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_flr" title="Permalink to this definition">¶</a></dt>
<dd><p>initiate a PCIe function level reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initiate a function level reset on <strong>dev</strong>.  The caller should ensure the
device supports FLR before calling this function, e.g. by using the
<code class="xref c c-func docutils literal"><span class="pre">pcie_has_flr()</span></code> helper.</p>
<dl class="function">
<dt id="c.pci_reset_bridge_secondary_bus">
void <code class="descname">pci_reset_bridge_secondary_bus</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_bridge_secondary_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the secondary bus on a PCI bridge.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Bridge device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the bridge control register to assert reset on the secondary bus.
Devices on the secondary bus are left in power-on state.</p>
<dl class="function">
<dt id="c.__pci_reset_function">
int <code class="descname">__pci_reset_function</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_reset_function" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a PCI device function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>The device function is presumed to be unused when this function is called.
Resetting the device will make the contents of PCI configuration space
random, so any caller of this must be prepared to reinitialise the
device including MSI, bus mastering, BARs, decoding IO and memory spaces,
etc.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
<dl class="function">
<dt id="c.__pci_reset_function_locked">
int <code class="descname">__pci_reset_function_locked</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_reset_function_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a PCI device function while holding the <strong>dev</strong> mutex lock.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>The device function is presumed to be unused and the caller is holding
the device mutex lock when this function is called.
Resetting the device will make the contents of PCI configuration space
random, so any caller of this must be prepared to reinitialise the
device including MSI, bus mastering, BARs, decoding IO and memory spaces,
etc.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
<dl class="function">
<dt id="c.pci_reset_function">
int <code class="descname">pci_reset_function</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_function" title="Permalink to this definition">¶</a></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>This function does not just reset the PCI portion of a device, but
clears all the state associated with the device.  This function differs
from __pci_reset_function in that it saves and restores device state
over the reset.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
<dl class="function">
<dt id="c.pci_reset_function_locked">
int <code class="descname">pci_reset_function_locked</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_function_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices allow an individual function to be reset without affecting
other functions in the same device.  The PCI device must be responsive
to PCI config space in order to use this function.</p>
<p>This function does not just reset the PCI portion of a device, but
clears all the state associated with the device.  This function differs
from <a class="reference internal" href="#c.__pci_reset_function" title="__pci_reset_function"><code class="xref c c-func docutils literal"><span class="pre">__pci_reset_function()</span></code></a> in that it saves and restores device state
over the reset.  It also differs from <a class="reference internal" href="#c.pci_reset_function" title="pci_reset_function"><code class="xref c c-func docutils literal"><span class="pre">pci_reset_function()</span></code></a> in that it
requires the PCI device lock to be held.</p>
<p>Returns 0 if the device function was successfully reset or negative if the
device doesn’t support resetting a single function.</p>
<dl class="function">
<dt id="c.pci_try_reset_function">
int <code class="descname">pci_try_reset_function</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_try_reset_function" title="Permalink to this definition">¶</a></dt>
<dd><p>quiesce and reset a PCI device function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as above, except return -EAGAIN if unable to lock device.</p>
<dl class="function">
<dt id="c.pci_probe_reset_slot">
int <code class="descname">pci_probe_reset_slot</code><span class="sig-paren">(</span>struct pci_slot *<em>&nbsp;slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_probe_reset_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>probe whether a PCI slot can be reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*</span> <span class="pre">slot</span></code></dt>
<dd>PCI slot to probe</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if slot can be reset, negative if a slot reset is not supported.</p>
<dl class="function">
<dt id="c.pci_reset_slot">
int <code class="descname">pci_reset_slot</code><span class="sig-paren">(</span>struct pci_slot *<em>&nbsp;slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a PCI slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*</span> <span class="pre">slot</span></code></dt>
<dd>PCI slot to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>A PCI bus may host multiple slots, each slot may support a reset mechanism
independent of other slots.  For instance, some slots may support slot power
control.  In the case of a 1:1 bus to slot architecture, this function may
wrap the bus reset to avoid spurious slot related events such as hotplug.
Generally a slot reset should be attempted before a bus reset.  All of the
function of the slot and any subordinate buses behind the slot are reset
through this function.  PCI config space of all devices in the slot and
behind the slot is saved before and restored after reset.</p>
<p>Return 0 on success, non-zero on error.</p>
<dl class="function">
<dt id="c.pci_try_reset_slot">
int <code class="descname">pci_try_reset_slot</code><span class="sig-paren">(</span>struct pci_slot *<em>&nbsp;slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_try_reset_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to reset a PCI slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*</span> <span class="pre">slot</span></code></dt>
<dd>PCI slot to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as above except return -EAGAIN if the slot cannot be locked</p>
<dl class="function">
<dt id="c.pci_probe_reset_bus">
int <code class="descname">pci_probe_reset_bus</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_probe_reset_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>probe whether a PCI bus can be reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>PCI bus to probe</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 if bus can be reset, negative if a bus reset is not supported.</p>
<dl class="function">
<dt id="c.pci_reset_bus">
int <code class="descname">pci_reset_bus</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_reset_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a PCI bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>top level PCI bus to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do a bus reset on the given bus and any subordinate buses, saving
and restoring state of all devices.</p>
<p>Return 0 on success, non-zero on error.</p>
<dl class="function">
<dt id="c.pci_try_reset_bus">
int <code class="descname">pci_try_reset_bus</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_try_reset_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to reset a PCI bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>top level PCI bus to reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as above except return -EAGAIN if the bus cannot be locked</p>
<dl class="function">
<dt id="c.pcix_get_max_mmrbc">
int <code class="descname">pcix_get_max_mmrbc</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_get_max_mmrbc" title="Permalink to this definition">¶</a></dt>
<dd><p>get PCI-X maximum designed memory read byte count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Returns mmrbc: maximum designed memory read count in bytes</dt>
<dd>or appropriate error value.</dd>
</dl>
<dl class="function">
<dt id="c.pcix_get_mmrbc">
int <code class="descname">pcix_get_mmrbc</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_get_mmrbc" title="Permalink to this definition">¶</a></dt>
<dd><p>get PCI-X maximum memory read byte count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Returns mmrbc: maximum memory read count in bytes</dt>
<dd>or appropriate error value.</dd>
</dl>
<dl class="function">
<dt id="c.pcix_set_mmrbc">
int <code class="descname">pcix_set_mmrbc</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;mmrbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcix_set_mmrbc" title="Permalink to this definition">¶</a></dt>
<dd><p>set PCI-X maximum memory read byte count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mmrbc</span></code></dt>
<dd>maximum memory read count in bytes
valid values are 512, 1024, 2048, 4096</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum memory read byte count, some bridges have erratas
that prevent this.</p>
<dl class="function">
<dt id="c.pcie_get_readrq">
int <code class="descname">pcie_get_readrq</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_readrq" title="Permalink to this definition">¶</a></dt>
<dd><p>get PCI Express read request size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Returns maximum memory read request in bytes</dt>
<dd>or appropriate error value.</dd>
</dl>
<dl class="function">
<dt id="c.pcie_set_readrq">
int <code class="descname">pcie_set_readrq</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_set_readrq" title="Permalink to this definition">¶</a></dt>
<dd><p>set PCI Express maximum memory read request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">rq</span></code></dt>
<dd>maximum memory read count in bytes
valid values are 128, 256, 512, 1024, 2048, 4096</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum memory read request in bytes</p>
<dl class="function">
<dt id="c.pcie_get_mps">
int <code class="descname">pcie_get_mps</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_mps" title="Permalink to this definition">¶</a></dt>
<dd><p>get PCI Express maximum payload size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns maximum payload size in bytes</p>
<dl class="function">
<dt id="c.pcie_set_mps">
int <code class="descname">pcie_set_mps</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;mps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_set_mps" title="Permalink to this definition">¶</a></dt>
<dd><p>set PCI Express maximum payload size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mps</span></code></dt>
<dd>maximum payload size in bytes
valid values are 128, 256, 512, 1024, 2048, 4096</dd>
</dl>
<p><strong>Description</strong></p>
<p>If possible sets maximum payload size</p>
<dl class="function">
<dt id="c.pcie_get_minimum_link">
int <code class="descname">pcie_get_minimum_link</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, enum pci_bus_speed *<em>&nbsp;speed</em>, enum pcie_link_width *<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_get_minimum_link" title="Permalink to this definition">¶</a></dt>
<dd><p>determine minimum link settings of a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">pci_bus_speed</span> <span class="pre">*</span> <span class="pre">speed</span></code></dt>
<dd>storage for minimum speed</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">pcie_link_width</span> <span class="pre">*</span> <span class="pre">width</span></code></dt>
<dd>storage for minimum width</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will walk up the PCI device chain and determine the minimum
link width and speed of the device.</p>
<dl class="function">
<dt id="c.pci_select_bars">
int <code class="descname">pci_select_bars</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_select_bars" title="Permalink to this definition">¶</a></dt>
<dd><p>Make BAR mask from the type of resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device for which BAR mask is made</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>resource type mask to be selected</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper routine makes bar mask from the type of resource.</p>
<dl class="function">
<dt id="c.pci_add_dynid">
int <code class="descname">pci_add_dynid</code><span class="sig-paren">(</span>struct pci_driver *<em>&nbsp;drv</em>, unsigned int<em>&nbsp;vendor</em>, unsigned int<em>&nbsp;device</em>, unsigned int<em>&nbsp;subvendor</em>, unsigned int<em>&nbsp;subdevice</em>, unsigned int<em>&nbsp;class</em>, unsigned int<em>&nbsp;class_mask</em>, unsigned long<em>&nbsp;driver_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_add_dynid" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new PCI device ID to this driver and re-probe devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>target pci driver</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt>
<dd>PCI vendor ID</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt>
<dd>PCI device ID</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">subvendor</span></code></dt>
<dd>PCI subvendor ID</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">subdevice</span></code></dt>
<dd>PCI subdevice ID</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class</span></code></dt>
<dd>PCI class</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class_mask</span></code></dt>
<dd>PCI class mask</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">driver_data</span></code></dt>
<dd>private driver data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a new dynamic pci device ID to this driver and causes the
driver to probe for all devices again.  <strong>drv</strong> must have been
registered prior to calling this function.</p>
<p><strong>Context</strong></p>
<p>Does GFP_KERNEL allocation.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.pci_match_id">
const struct pci_device_id * <code class="descname">pci_match_id</code><span class="sig-paren">(</span>const struct pci_device_id *<em>&nbsp;ids</em>, struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_match_id" title="Permalink to this definition">¶</a></dt>
<dd><p>See if a pci device matches a given pci_id table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>array of PCI device id structures to search in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device structure to match against.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used by a driver to check whether a PCI device present in the
system is in its list of supported devices.  Returns the matching
pci_device_id structure or <code class="docutils literal"><span class="pre">NULL</span></code> if there is no match.</p>
<p>Deprecated, don’t use this as it will not catch any dynamic ids
that a driver might want to check for.</p>
<dl class="function">
<dt id="c.__pci_register_driver">
int <code class="descname">__pci_register_driver</code><span class="sig-paren">(</span>struct pci_driver *<em>&nbsp;drv</em>, struct module *<em>&nbsp;owner</em>, const char *<em>&nbsp;mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new pci driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>the driver structure to register</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owner module of drv</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">mod_name</span></code></dt>
<dd>module name string</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the driver structure to the list of registered drivers.
Returns a negative value on error, otherwise 0.
If no error occurred, the driver remains registered even if
no device was claimed during registration.</p>
<dl class="function">
<dt id="c.pci_unregister_driver">
void <code class="descname">pci_unregister_driver</code><span class="sig-paren">(</span>struct pci_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a pci driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>the driver structure to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deletes the driver structure from the list of registered PCI drivers,
gives it a chance to clean up by calling its <code class="xref c c-func docutils literal"><span class="pre">remove()</span></code> function for
each device it was responsible for, and marks those devices as
driverless.</p>
<dl class="function">
<dt id="c.pci_dev_driver">
struct pci_driver * <code class="descname">pci_dev_driver</code><span class="sig-paren">(</span>const struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>get the pci_driver of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the appropriate pci_driver structure or <code class="docutils literal"><span class="pre">NULL</span></code> if there is no
registered driver for the device.</p>
<dl class="function">
<dt id="c.pci_dev_get">
struct pci_dev * <code class="descname">pci_dev_get</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_get" title="Permalink to this definition">¶</a></dt>
<dd><p>increments the reference count of the pci device structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device being referenced</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each live reference to a device should be refcounted.</p>
<p>Drivers for PCI devices should normally record such references in
their <code class="xref c c-func docutils literal"><span class="pre">probe()</span></code> methods, when they bind to a device, and release
them by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal"><span class="pre">pci_dev_put()</span></code></a>, in their <code class="xref c c-func docutils literal"><span class="pre">disconnect()</span></code> methods.</p>
<p>A pointer to the device with the incremented reference counter is returned.</p>
<dl class="function">
<dt id="c.pci_dev_put">
void <code class="descname">pci_dev_put</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a use of the pci device structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that’s been disconnected</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called when a user of a device is finished with it.  When the last
user of the device calls this function, the memory of the device is freed.</p>
<dl class="function">
<dt id="c.pci_stop_and_remove_bus_device">
void <code class="descname">pci_stop_and_remove_bus_device</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_stop_and_remove_bus_device" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a PCI device and any children</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a PCI device from the device lists, informing the drivers
that the device has been removed.  We also remove any subordinate
buses and children in a depth-first manner.</p>
<p>For each device we remove, delete the device structure from the
device lists, remove the /proc entry, and notify userspace
(/sbin/hotplug).</p>
<dl class="function">
<dt id="c.pci_find_bus">
struct pci_bus * <code class="descname">pci_find_bus</code><span class="sig-paren">(</span>int<em>&nbsp;domain</em>, int<em>&nbsp;busnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>locate PCI bus from a given domain and bus number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">domain</span></code></dt>
<dd>number of PCI domain to search</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">busnr</span></code></dt>
<dd>number of desired PCI bus</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus number and domain number, the desired PCI bus is located
in the global list of PCI buses.  If the bus is found, a pointer to its
data structure is returned.  If no bus is found, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.pci_find_next_bus">
struct pci_bus * <code class="descname">pci_find_next_bus</code><span class="sig-paren">(</span>const struct pci_bus *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_find_next_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>begin or continue searching for a PCI bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>Previous PCI bus found, or <code class="docutils literal"><span class="pre">NULL</span></code> for new search.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI buses.  A new search is
initiated by passing <code class="docutils literal"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.  Otherwise if
<strong>from</strong> is not <code class="docutils literal"><span class="pre">NULL</span></code>, searches continue from next device on the
global list.</p>
<dl class="function">
<dt id="c.pci_get_slot">
struct pci_dev * <code class="descname">pci_get_slot</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em>, unsigned int<em>&nbsp;devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>locate PCI device for a given PCI slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>PCI bus on which desired PCI device resides</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt>
<dd>encodes number of PCI slot in which the desired PCI
device resides and the logical device number within that slot
in case of multi-function devices.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI bus and slot/function number, the desired PCI device
is located in the list of PCI devices.
If the device is found, its reference count is increased and this
function returns a pointer to its data structure.  The caller must
decrement the reference count by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal"><span class="pre">pci_dev_put()</span></code></a>.
If no device is found, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.pci_get_domain_bus_and_slot">
struct pci_dev * <code class="descname">pci_get_domain_bus_and_slot</code><span class="sig-paren">(</span>int<em>&nbsp;domain</em>, unsigned int<em>&nbsp;bus</em>, unsigned int<em>&nbsp;devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_domain_bus_and_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>locate PCI device for a given PCI domain (segment), bus, and slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">domain</span></code></dt>
<dd>PCI domain/segment on which the PCI device resides.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bus</span></code></dt>
<dd>PCI bus on which desired PCI device resides</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">devfn</span></code></dt>
<dd>encodes number of PCI slot in which the desired PCI device
resides and the logical device number within that slot in case of
multi-function devices.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a PCI domain, bus, and slot/function number, the desired PCI
device is located in the list of PCI devices. If the device is
found, its reference count is increased and this function returns a
pointer to its data structure.  The caller must decrement the
reference count by calling <a class="reference internal" href="#c.pci_dev_put" title="pci_dev_put"><code class="xref c c-func docutils literal"><span class="pre">pci_dev_put()</span></code></a>.  If no device is found,
<code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.pci_get_subsys">
struct pci_dev * <code class="descname">pci_get_subsys</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;vendor</em>, unsigned int<em>&nbsp;device</em>, unsigned int<em>&nbsp;ss_vendor</em>, unsigned int<em>&nbsp;ss_device</em>, struct pci_dev *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_subsys" title="Permalink to this definition">¶</a></dt>
<dd><p>begin or continue searching for a PCI device by vendor/subvendor/device/subdevice id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt>
<dd>PCI vendor id to match, or <code class="docutils literal"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt>
<dd>PCI device id to match, or <code class="docutils literal"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ss_vendor</span></code></dt>
<dd>PCI subsystem vendor id to match, or <code class="docutils literal"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ss_device</span></code></dt>
<dd>PCI subsystem device id to match, or <code class="docutils literal"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>Previous PCI device found in search, or <code class="docutils literal"><span class="pre">NULL</span></code> for new search.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is found
with a matching <strong>vendor</strong>, <strong>device</strong>, <strong>ss_vendor</strong> and <strong>ss_device</strong>, a pointer to its
device structure is returned, and the reference count to the device is
incremented.  Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.  A new search is initiated by
passing <code class="docutils literal"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.  Otherwise if <strong>from</strong> is not <code class="docutils literal"><span class="pre">NULL</span></code>,
searches continue from next device on the global list.
The reference count for <strong>from</strong> is always decremented if it is not <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<dl class="function">
<dt id="c.pci_get_device">
struct pci_dev * <code class="descname">pci_get_device</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;vendor</em>, unsigned int<em>&nbsp;device</em>, struct pci_dev *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>begin or continue searching for a PCI device by vendor/device id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">vendor</span></code></dt>
<dd>PCI vendor id to match, or <code class="docutils literal"><span class="pre">PCI_ANY_ID</span></code> to match all vendor ids</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">device</span></code></dt>
<dd>PCI device id to match, or <code class="docutils literal"><span class="pre">PCI_ANY_ID</span></code> to match all device ids</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>Previous PCI device found in search, or <code class="docutils literal"><span class="pre">NULL</span></code> for new search.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is
found with a matching <strong>vendor</strong> and <strong>device</strong>, the reference count to the
device is incremented and a pointer to its device structure is returned.
Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.  A new search is initiated by passing <code class="docutils literal"><span class="pre">NULL</span></code>
as the <strong>from</strong> argument.  Otherwise if <strong>from</strong> is not <code class="docutils literal"><span class="pre">NULL</span></code>, searches continue
from next device on the global list.  The reference count for <strong>from</strong> is
always decremented if it is not <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<dl class="function">
<dt id="c.pci_get_class">
struct pci_dev * <code class="descname">pci_get_class</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;class</em>, struct pci_dev *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_get_class" title="Permalink to this definition">¶</a></dt>
<dd><p>begin or continue searching for a PCI device by class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">class</span></code></dt>
<dd>search for a PCI device with this class designation</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>Previous PCI device found in search, or <code class="docutils literal"><span class="pre">NULL</span></code> for new search.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of known PCI devices.  If a PCI device is
found with a matching <strong>class</strong>, the reference count to the device is
incremented and a pointer to its device structure is returned.
Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.
A new search is initiated by passing <code class="docutils literal"><span class="pre">NULL</span></code> as the <strong>from</strong> argument.
Otherwise if <strong>from</strong> is not <code class="docutils literal"><span class="pre">NULL</span></code>, searches continue from next device
on the global list.  The reference count for <strong>from</strong> is always decremented
if it is not <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<dl class="function">
<dt id="c.pci_dev_present">
int <code class="descname">pci_dev_present</code><span class="sig-paren">(</span>const struct pci_device_id *<em>&nbsp;ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_dev_present" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if device matching the device list is present, 0 if not.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_device_id</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>A pointer to a null terminated list of struct pci_device_id structures
that describe the type of PCI device the caller is trying to find.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obvious fact: You do not have a reference to any device that might be found
by this function, so if that device is removed from the system right after
this function is finished, the value will be stale.  Use this function to
find devices that are usually built into a system, or for a general hint as
to if another device happens to be present at this specific moment in time.</p>
<dl class="function">
<dt id="c.pci_msi_mask_irq">
void <code class="descname">pci_msi_mask_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a> *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_mask_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic irq chip callback to mask PCI/MSI interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to irqdata associated to that interrupt</dd>
</dl>
<dl class="function">
<dt id="c.pci_msi_unmask_irq">
void <code class="descname">pci_msi_unmask_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../core-api/genericirq.html#c.irq_data" title="irq_data">irq_data</a> *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_unmask_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic irq chip callback to unmask PCI/MSI interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_data</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to irqdata associated to that interrupt</dd>
</dl>
<dl class="function">
<dt id="c.pci_msi_vec_count">
int <code class="descname">pci_msi_vec_count</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_vec_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of MSI vectors a device can send</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to report about</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the number of MSI vectors a device requested via
Multiple Message Capable register. It returns a negative errno if the
device is not capable sending MSI interrupts. Otherwise, the call succeeds
and returns a power of two, up to a maximum of 2^5 (32), according to the
MSI specification.</p>
<dl class="function">
<dt id="c.pci_msix_vec_count">
int <code class="descname">pci_msix_vec_count</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msix_vec_count" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of device’s MSI-X table entries</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the pci_dev data structure of MSI-X device function
This function returns the number of device’s MSI-X table entries and
therefore the number of MSI-X vectors device is capable of sending.
It returns a negative errno if the device is not capable of sending MSI-X
interrupts.</dd>
</dl>
<dl class="function">
<dt id="c.pci_msi_enabled">
int <code class="descname">pci_msi_enabled</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>is MSI enabled?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if MSI has not been disabled by the command-line option
pci=nomsi.</p>
<dl class="function">
<dt id="c.pci_enable_msix_range">
int <code class="descname">pci_enable_msix_range</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, struct msix_entry *<em>&nbsp;entries</em>, int<em>&nbsp;minvec</em>, int<em>&nbsp;maxvec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_msix_range" title="Permalink to this definition">¶</a></dt>
<dd><p>configure device’s MSI-X capability structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the pci_dev data structure of MSI-X device function</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">msix_entry</span> <span class="pre">*</span> <span class="pre">entries</span></code></dt>
<dd>pointer to an array of MSI-X entries</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">minvec</span></code></dt>
<dd>minimum number of MSI-X irqs requested</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">maxvec</span></code></dt>
<dd>maximum number of MSI-X irqs requested</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the MSI-X capability structure of device function with a maximum
possible number of interrupts in the range between <strong>minvec</strong> and <strong>maxvec</strong>
upon its software driver call to request for MSI-X mode enabled on its
hardware device function. It returns a negative errno if an error occurs.
If it succeeds, it returns the actual number of interrupts allocated and
indicates the successful configuration of MSI-X capability structure
with new allocated MSI-X interrupts.</p>
<dl class="function">
<dt id="c.pci_alloc_irq_vectors_affinity">
int <code class="descname">pci_alloc_irq_vectors_affinity</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;min_vecs</em>, unsigned int<em>&nbsp;max_vecs</em>, unsigned int<em>&nbsp;flags</em>, const struct <a class="reference internal" href="../core-api/genericirq.html#c.irq_affinity" title="irq_affinity">irq_affinity</a> *<em>&nbsp;affd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_alloc_irq_vectors_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate multiple IRQs for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to operate on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min_vecs</span></code></dt>
<dd>minimum number of vectors required (must be &gt;= 1)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_vecs</span></code></dt>
<dd>maximum (desired) number of vectors</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags or quirks for the allocation</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">irq_affinity</span> <span class="pre">*</span> <span class="pre">affd</span></code></dt>
<dd>optional description of the affinity requirements</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate up to <strong>max_vecs</strong> interrupt vectors for <strong>dev</strong>, using MSI-X or MSI
vectors if available, and fall back to a single legacy vector
if neither is available.  Return the number of vectors allocated,
(which might be smaller than <strong>max_vecs</strong>) if successful, or a negative
error code on error. If less than <strong>min_vecs</strong> interrupt vectors are
available for <strong>dev</strong> the function will fail with -ENOSPC.</p>
<p>To get the Linux IRQ number used for a vector that can be passed to
<code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> use the <a class="reference internal" href="#c.pci_irq_vector" title="pci_irq_vector"><code class="xref c c-func docutils literal"><span class="pre">pci_irq_vector()</span></code></a> helper.</p>
<dl class="function">
<dt id="c.pci_free_irq_vectors">
void <code class="descname">pci_free_irq_vectors</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_free_irq_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>free previously allocated IRQs for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undoes the allocations and enabling in <code class="xref c c-func docutils literal"><span class="pre">pci_alloc_irq_vectors()</span></code>.</p>
<dl class="function">
<dt id="c.pci_irq_vector">
int <code class="descname">pci_irq_vector</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_irq_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>return Linux IRQ number of a device vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to operate on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>device-relative interrupt vector index (0-based).</dd>
</dl>
<dl class="function">
<dt id="c.pci_irq_get_affinity">
const struct cpumask * <code class="descname">pci_irq_get_affinity</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_irq_get_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>return the affinity of a particular msi vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to operate on</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>device-relative interrupt vector index (0-based).</dd>
</dl>
<dl class="function">
<dt id="c.pci_irq_get_node">
int <code class="descname">pci_irq_get_node</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, int<em>&nbsp;vec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_irq_get_node" title="Permalink to this definition">¶</a></dt>
<dd><p>return the numa node of a particular msi vector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device to operate on</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vec</span></code></dt>
<dd>device-relative interrupt vector index (0-based).</dd>
</dl>
<dl class="function">
<dt id="c.pci_msi_create_irq_domain">
struct irq_domain * <code class="descname">pci_msi_create_irq_domain</code><span class="sig-paren">(</span>struct fwnode_handle *<em>&nbsp;fwnode</em>, struct msi_domain_info *<em>&nbsp;info</em>, struct irq_domain *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_msi_create_irq_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a MSI interrupt domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt>
<dd>Optional fwnode of the interrupt controller</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">msi_domain_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>MSI domain info</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>Parent irq domain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates the domain and chip ops and creates a MSI interrupt domain.</p>
<p><strong>Return</strong></p>
<p>A domain pointer or NULL in case of failure.</p>
<dl class="function">
<dt id="c.pci_bus_alloc_resource">
int <code class="descname">pci_bus_alloc_resource</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em>, struct resource *<em>&nbsp;res</em>, resource_size_t<em>&nbsp;size</em>, resource_size_t<em>&nbsp;align</em>, resource_size_t<em>&nbsp;min</em>, unsigned long<em>&nbsp;type_mask</em>, resource_size_t (*alignf) (void<em>&nbsp;*</em>, const struct resource<em>&nbsp;*</em>, resource_size_t, resource_size_t, void *<em>&nbsp;alignf_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_alloc_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a resource from a parent bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>PCI bus</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>resource to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>size of resource to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment of resource to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">min</span></code></dt>
<dd>minimum /proc/iomem address to allocate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">type_mask</span></code></dt>
<dd>IORESOURCE_* type flags</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">resource_size_t,</span> <span class="pre">resource_size_t)</span> <span class="pre">alignf</span></code></dt>
<dd>resource alignment function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">alignf_data</span></code></dt>
<dd>data argument for resource alignment function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given the PCI bus a device resides on, the size, minimum address,
alignment and type, try to find an acceptable resource allocation
for a specific device resource.</p>
<dl class="function">
<dt id="c.pci_bus_add_device">
void <code class="descname">pci_bus_add_device</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>start driver for a single device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds add sysfs entries and start device drivers</p>
<dl class="function">
<dt id="c.pci_bus_add_devices">
void <code class="descname">pci_bus_add_devices</code><span class="sig-paren">(</span>const struct pci_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_add_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>start driver for PCI devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus to check for new devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start driver for PCI devices and add some sysfs entries.</p>
<dl class="function">
<dt id="c.pci_bus_set_ops">
struct pci_ops * <code class="descname">pci_bus_set_ops</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em>, struct pci_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_bus_set_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Set raw operations of pci bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>pci bus struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>new raw operations</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return previous raw operations</p>
<dl class="function">
<dt id="c.pci_read_vpd">
ssize_t <code class="descname">pci_read_vpd</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, loff_t<em>&nbsp;pos</em>, size_t<em>&nbsp;count</em>, void *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_read_vpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one entry from Vital Product Data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pci device struct</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>offset in vpd space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to read</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to where to store result</dd>
</dl>
<dl class="function">
<dt id="c.pci_write_vpd">
ssize_t <code class="descname">pci_write_vpd</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, loff_t<em>&nbsp;pos</em>, size_t<em>&nbsp;count</em>, const void *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_write_vpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Write entry to Vital Product Data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pci device struct</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">pos</span></code></dt>
<dd>offset in vpd space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to write</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer containing write data</dd>
</dl>
<dl class="function">
<dt id="c.pci_set_vpd_size">
int <code class="descname">pci_set_vpd_size</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_set_vpd_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Set size of Vital Product Data space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pci device struct</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>size of vpd space</dd>
</dl>
<dl class="function">
<dt id="c.pci_cfg_access_lock">
void <code class="descname">pci_cfg_access_lock</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock PCI config reads/writes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pci device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>When access is locked, any userspace reads or writes to config
space and concurrent lock requests will sleep until access is
allowed via <a class="reference internal" href="#c.pci_cfg_access_unlock" title="pci_cfg_access_unlock"><code class="xref c c-func docutils literal"><span class="pre">pci_cfg_access_unlock()</span></code></a> again.</p>
<dl class="function">
<dt id="c.pci_cfg_access_trylock">
bool <code class="descname">pci_cfg_access_trylock</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>try to lock PCI config reads/writes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pci device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as pci_cfg_access_lock, but will return 0 if access is
already locked, 1 otherwise. This function can be used from
atomic contexts.</p>
<dl class="function">
<dt id="c.pci_cfg_access_unlock">
void <code class="descname">pci_cfg_access_unlock</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_cfg_access_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock PCI config reads/writes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pci device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows PCI config accesses to resume.</p>
<dl class="function">
<dt id="c.pci_lost_interrupt">
enum pci_lost_interrupt_reason <code class="descname">pci_lost_interrupt</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_lost_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>reports a lost PCI interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>device whose interrupt is lost</dd>
</dl>
<p><strong>Description</strong></p>
<p>The primary function of this routine is to report a lost interrupt
in a standard way which users can recognise (instead of blaming the
driver).</p>
<p><strong>Return</strong></p>
<p>a suggestion for fixing it (although the driver is not required to
act on this).</p>
<dl class="function">
<dt id="c.pci_request_irq">
int <code class="descname">pci_request_irq</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;nr</em>, irq_handler_t<em>&nbsp;handler</em>, irq_handler_t<em>&nbsp;thread_fn</em>, void *<em>&nbsp;dev_id</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.pci_request_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line for a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to operate on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>device-relative interrupt vector index (0-based).</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts.
If NULL and thread_fn != NULL the default primary handler is
installed.</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">thread_fn</span></code></dt>
<dd>Function called from the IRQ handler thread
If NULL, no IRQ thread is created</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Cookie passed back to the handler function</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>Printf-like format string naming the handler</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call allocates interrupt resources and enables the interrupt line and
IRQ handling. From the point this call is made <strong>handler</strong> and <strong>thread_fn</strong> may
be invoked.  All interrupts requested using this function might be shared.</p>
<p><strong>dev_id</strong> must not be NULL and must be globally unique.</p>
<dl class="function">
<dt id="c.pci_free_irq">
void <code class="descname">pci_free_irq</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;nr</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_free_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with pci_request_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to operate on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>device-relative interrupt vector index (0-based).</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove an interrupt handler. The handler is removed and if the interrupt
line is no longer in use by any driver it is disabled.  The caller must
ensure the interrupt is disabled on the device before calling this function.
The function does not return until any executing interrupts for this IRQ
have completed.</p>
<p>This function must not be called from interrupt context.</p>
<dl class="function">
<dt id="c.__ht_create_irq">
int <code class="descname">__ht_create_irq</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;idx</em>, ht_irq_update_t *<em>&nbsp;update</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__ht_create_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>create an irq and attach it to a device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The hypertransport device to find the irq capability on.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>Which of the possible irqs to attach to.</dd>
<dt><code class="docutils literal"><span class="pre">ht_irq_update_t</span> <span class="pre">*</span> <span class="pre">update</span></code></dt>
<dd>Function to be called when changing the htirq message</dd>
</dl>
<p><strong>Description</strong></p>
<p>The irq number of the new irq or a negative error value is returned.</p>
<dl class="function">
<dt id="c.ht_create_irq">
int <code class="descname">ht_create_irq</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ht_create_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>create an irq and attach it to a device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The hypertransport device to find the irq capability on.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>Which of the possible irqs to attach to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>ht_create_irq needs to be called for all hypertransport devices
that generate irqs.</p>
<p>The irq number of the new irq or a negative error value is returned.</p>
<dl class="function">
<dt id="c.ht_destroy_irq">
void <code class="descname">ht_destroy_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ht_destroy_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy an irq created with ht_create_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>irq to be destroyed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reverses ht_create_irq removing the specified irq from
existence.  The irq should be free before this happens.</p>
<dl class="function">
<dt id="c.pcie_relaxed_ordering_enabled">
bool <code class="descname">pcie_relaxed_ordering_enabled</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pcie_relaxed_ordering_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Probe for PCIe relaxed ordering enable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>PCI device to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the device has enabled relaxed ordering attribute.</p>
<dl class="function">
<dt id="c.pci_scan_slot">
int <code class="descname">pci_scan_slot</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em>, int<em>&nbsp;devfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_scan_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>scan a PCI slot on a bus for devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>PCI bus to scan</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">devfn</span></code></dt>
<dd>slot number to scan (must have zero function.)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan a PCI slot on the specified PCI bus for devices, adding
discovered devices to the <strong>bus</strong>-&gt;devices list.  New devices
will not have is_added set.</p>
<p>Returns the number of new devices found.</p>
<dl class="function">
<dt id="c.pci_rescan_bus">
unsigned int <code class="descname">pci_rescan_bus</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_rescan_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>scan a PCI bus for devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>PCI bus to scan</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan a PCI bus and child buses for new devices, adds them,
and enables them.</p>
<p>Returns the max number of subordinate bus discovered.</p>
<dl class="function">
<dt id="c.pci_create_slot">
struct pci_slot * <code class="descname">pci_create_slot</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;parent</em>, int<em>&nbsp;slot_nr</em>, const char *<em>&nbsp;name</em>, struct hotplug_slot *<em>&nbsp;hotplug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>create or increment refcount for physical PCI slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>struct pci_bus of parent bridge</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">slot_nr</span></code></dt>
<dd>PCI_SLOT(pci_dev-&gt;devfn) or -1 for placeholder</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>user visible string presented in /sys/bus/pci/slots/&lt;name&gt;</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*</span> <span class="pre">hotplug</span></code></dt>
<dd>set if caller is hotplug driver, NULL otherwise</dd>
</dl>
<p><strong>Description</strong></p>
<p>PCI slots have first class attributes such as address, speed, width,
and a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pci_slot</span></code> is used to manage them. This interface will
either return a new <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pci_slot</span></code> to the caller, or if the pci_slot
already exists, its refcount will be incremented.</p>
<p>Slots are uniquely identified by a <strong>pci_bus</strong>, <strong>slot_nr</strong> tuple.</p>
<p>There are known platforms with broken firmware that assign the same
name to multiple slots. Workaround these broken platforms by renaming
the slots on behalf of the caller. If firmware assigns name N to
multiple slots:</p>
<p>The first slot is assigned N
The second slot is assigned N-1
The third slot is assigned N-2
etc.</p>
<p>Placeholder slots:
In most cases, <strong>pci_bus</strong>, <strong>slot_nr</strong> will be sufficient to uniquely identify
a slot. There is one notable exception - pSeries (rpaphp), where the
<strong>slot_nr</strong> cannot be determined until a device is actually inserted into
the slot. In this scenario, the caller may pass -1 for <strong>slot_nr</strong>.</p>
<p>The following semantics are imposed when the caller passes <strong>slot_nr</strong> ==
-1. First, we no longer check for an existing <code class="docutils literal"><span class="pre">struct</span></code> pci_slot, as there
may be many slots with <strong>slot_nr</strong> of -1.  The other change in semantics is
user-visible, which is the ‘address’ parameter presented in sysfs will
consist solely of a dddd:bb tuple, where dddd is the PCI domain of the
<code class="docutils literal"><span class="pre">struct</span></code> pci_bus and bb is the bus number. In other words, the devfn of
the ‘placeholder’ slot will not be displayed.</p>
<dl class="function">
<dt id="c.pci_destroy_slot">
void <code class="descname">pci_destroy_slot</code><span class="sig-paren">(</span>struct pci_slot *<em>&nbsp;slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_destroy_slot" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement refcount for physical PCI slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*</span> <span class="pre">slot</span></code></dt>
<dd>struct pci_slot to decrement</dd>
</dl>
<p><strong>Description</strong></p>
<p><code class="docutils literal"><span class="pre">struct</span></code> pci_slot is refcounted, so destroying them is really easy; we
just call kobject_put on its kobj and let our release methods do the
rest.</p>
<dl class="function">
<dt id="c.pci_hp_create_module_link">
void <code class="descname">pci_hp_create_module_link</code><span class="sig-paren">(</span>struct pci_slot *<em>&nbsp;pci_slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_create_module_link" title="Permalink to this definition">¶</a></dt>
<dd><p>create symbolic link to the hotplug driver module.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*</span> <span class="pre">pci_slot</span></code></dt>
<dd>struct pci_slot</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_hotplug_core.c to create symbolic link to
the hotplug driver module.</p>
<dl class="function">
<dt id="c.pci_hp_remove_module_link">
void <code class="descname">pci_hp_remove_module_link</code><span class="sig-paren">(</span>struct pci_slot *<em>&nbsp;pci_slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_remove_module_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove symbolic link to the hotplug driver module.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_slot</span> <span class="pre">*</span> <span class="pre">pci_slot</span></code></dt>
<dd>struct pci_slot</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for pci_hotplug_core.c to remove symbolic link to
the hotplug driver module.</p>
<dl class="function">
<dt id="c.pci_enable_rom">
int <code class="descname">pci_enable_rom</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>enable ROM decoding for a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device to enable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enable ROM decoding on <strong>dev</strong>.  This involves simply turning on the last
bit of the PCI ROM BAR.  Note that some cards may share address decoders
between the ROM and other resources, so enabling it may disable access
to MMIO registers or other card memory.</p>
<dl class="function">
<dt id="c.pci_disable_rom">
void <code class="descname">pci_disable_rom</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>disable ROM decoding for a PCI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>PCI device to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable ROM decoding on a PCI device by turning off the last bit in the
ROM BAR.</p>
<dl class="function">
<dt id="c.pci_map_rom">
void __iomem * <code class="descname">pci_map_rom</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, size_t *<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_map_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>map a PCI ROM to kernel space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>pointer to pci device struct</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt>
<dd>pointer to receive size of pci window over ROM</dd>
</dl>
<p><strong>Return</strong></p>
<p>kernel virtual pointer to image of ROM</p>
<p>Map a PCI ROM into kernel space. If ROM is boot video ROM,
the shadow BIOS copy will be returned instead of the
actual ROM.</p>
<dl class="function">
<dt id="c.pci_unmap_rom">
void <code class="descname">pci_unmap_rom</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, void __iomem *<em>&nbsp;rom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_unmap_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap the ROM from kernel space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>pointer to pci device struct</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__iomem</span> <span class="pre">*</span> <span class="pre">rom</span></code></dt>
<dd>virtual address of the previous mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a mapping of a previously mapped ROM</p>
<dl class="function">
<dt id="c.pci_platform_rom">
void __iomem * <code class="descname">pci_platform_rom</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, size_t *<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_platform_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>provides a pointer to any ROM image provided by the platform</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>pointer to pci device struct</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt>
<dd>pointer to receive size of pci window over ROM</dd>
</dl>
<dl class="function">
<dt id="c.pci_enable_sriov">
int <code class="descname">pci_enable_sriov</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, int<em>&nbsp;nr_virtfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_enable_sriov" title="Permalink to this definition">¶</a></dt>
<dd><p>enable the SR-IOV capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_virtfn</span></code></dt>
<dd>number of virtual functions to enable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, or negative on failure.</p>
<dl class="function">
<dt id="c.pci_disable_sriov">
void <code class="descname">pci_disable_sriov</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_disable_sriov" title="Permalink to this definition">¶</a></dt>
<dd><p>disable the SR-IOV capability</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device</dd>
</dl>
<dl class="function">
<dt id="c.pci_num_vf">
int <code class="descname">pci_num_vf</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_num_vf" title="Permalink to this definition">¶</a></dt>
<dd><p>return number of VFs associated with a PF device_release_driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of VFs, or 0 if SR-IOV is not enabled.</p>
<dl class="function">
<dt id="c.pci_vfs_assigned">
int <code class="descname">pci_vfs_assigned</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_vfs_assigned" title="Permalink to this definition">¶</a></dt>
<dd><p>returns number of VFs are assigned to a guest</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of VFs belonging to this device that are assigned to a guest.
If device is not a physical function returns 0.</p>
<dl class="function">
<dt id="c.pci_sriov_set_totalvfs">
int <code class="descname">pci_sriov_set_totalvfs</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em>, u16<em>&nbsp;numvfs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_sriov_set_totalvfs" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>reduce the TotalVFs available</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI PF device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">numvfs</span></code></dt>
<dd>number that should be used for TotalVFs supported</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from PF driver’s probe routine with
device’s mutex held.</p>
<p>Returns 0 if PF is an SRIOV-capable device and
value of numvfs valid. If not a PF return -ENOSYS;
if numvfs is invalid return -EINVAL;
if VFs already enabled, return -EBUSY.</p>
<dl class="function">
<dt id="c.pci_sriov_get_totalvfs">
int <code class="descname">pci_sriov_get_totalvfs</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_sriov_get_totalvfs" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>get total VFs supported on this device</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the PCI PF device</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a PCIe device with SRIOV support, return the PCIe
SRIOV capability value of TotalVFs or the value of driver_max_VFs
if the driver reduced it.  Otherwise 0.</p>
<dl class="function">
<dt id="c.pci_read_legacy_io">
ssize_t <code class="descname">pci_read_legacy_io</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct kobject *<em>&nbsp;kobj</em>, struct bin_attribute *<em>&nbsp;bin_attr</em>, char *<em>&nbsp;buf</em>, loff_t<em>&nbsp;off</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_read_legacy_io" title="Permalink to this definition">¶</a></dt>
<dd><p>read byte(s) from legacy I/O port space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>open sysfs file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>kobject corresponding to file to read from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">bin_attr</span></code></dt>
<dd>struct bin_attribute for this file</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store results</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt>
<dd>offset into legacy I/O port space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci_legacy_read).</p>
<dl class="function">
<dt id="c.pci_write_legacy_io">
ssize_t <code class="descname">pci_write_legacy_io</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct kobject *<em>&nbsp;kobj</em>, struct bin_attribute *<em>&nbsp;bin_attr</em>, char *<em>&nbsp;buf</em>, loff_t<em>&nbsp;off</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_write_legacy_io" title="Permalink to this definition">¶</a></dt>
<dd><p>write byte(s) to legacy I/O port space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>open sysfs file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>kobject corresponding to file to read from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">bin_attr</span></code></dt>
<dd>struct bin_attribute for this file</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer containing value to be written</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt>
<dd>offset into legacy I/O port space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific
callback routine (pci_legacy_write).</p>
<dl class="function">
<dt id="c.pci_mmap_legacy_mem">
int <code class="descname">pci_mmap_legacy_mem</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct kobject *<em>&nbsp;kobj</em>, struct bin_attribute *<em>&nbsp;attr</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_legacy_mem" title="Permalink to this definition">¶</a></dt>
<dd><p>map legacy PCI memory into user memory space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>open sysfs file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>kobject corresponding to device to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>struct bin_attribute for this file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>struct vm_area_struct passed to mmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses an arch specific callback, pci_mmap_legacy_mem_page_range, to mmap
legacy memory space (first meg of bus space) into application virtual
memory space.</p>
<dl class="function">
<dt id="c.pci_mmap_legacy_io">
int <code class="descname">pci_mmap_legacy_io</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct kobject *<em>&nbsp;kobj</em>, struct bin_attribute *<em>&nbsp;attr</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_legacy_io" title="Permalink to this definition">¶</a></dt>
<dd><p>map legacy PCI IO into user memory space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>open sysfs file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>kobject corresponding to device to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>struct bin_attribute for this file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>struct vm_area_struct passed to mmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses an arch specific callback, pci_mmap_legacy_io_page_range, to mmap
legacy IO space (first meg of bus space) into application virtual
memory space. Returns -ENOSYS if the operation isn’t supported</p>
<dl class="function">
<dt id="c.pci_adjust_legacy_attr">
void <code class="descname">pci_adjust_legacy_attr</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;b</em>, enum pci_mmap_state<em>&nbsp;mmap_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_adjust_legacy_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>adjustment of legacy file attributes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>bus to create files under</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">pci_mmap_state</span> <span class="pre">mmap_type</span></code></dt>
<dd>I/O port or memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stub implementation. Can be overridden by arch if necessary.</p>
<dl class="function">
<dt id="c.pci_create_legacy_files">
void <code class="descname">pci_create_legacy_files</code><span class="sig-paren">(</span>struct pci_bus *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_legacy_files" title="Permalink to this definition">¶</a></dt>
<dd><p>create legacy I/O port and memory files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>bus to create files under</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some platforms allow access to legacy I/O port and ISA memory space on
a per-bus basis.  This routine creates the files and ties them into
their associated read, write and mmap files from pci-sysfs.c</p>
<p>On error unwind, but don’t propagate the error to the caller
as it is ok to set up the PCI bus without these files.</p>
<dl class="function">
<dt id="c.pci_mmap_resource">
int <code class="descname">pci_mmap_resource</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct bin_attribute *<em>&nbsp;attr</em>, struct vm_area_struct *<em>&nbsp;vma</em>, int<em>&nbsp;write_combine</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_mmap_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>map a PCI resource into user memory space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>kobject for mapping</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>struct bin_attribute for the file being mapped</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>struct vm_area_struct passed into the mmap</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write_combine</span></code></dt>
<dd>1 for write_combine mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the regular PCI mapping routines to map a PCI resource into userspace.</p>
<dl class="function">
<dt id="c.pci_remove_resource_files">
void <code class="descname">pci_remove_resource_files</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remove_resource_files" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup resource files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>dev to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>If we created resource files for <strong>pdev</strong>, remove them from sysfs and
free their resources.</p>
<dl class="function">
<dt id="c.pci_create_resource_files">
int <code class="descname">pci_create_resource_files</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_create_resource_files" title="Permalink to this definition">¶</a></dt>
<dd><p>create resource files in sysfs for <strong>dev</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>dev in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the resources in <strong>pdev</strong> creating files for each resource available.</p>
<dl class="function">
<dt id="c.pci_write_rom">
ssize_t <code class="descname">pci_write_rom</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct kobject *<em>&nbsp;kobj</em>, struct bin_attribute *<em>&nbsp;bin_attr</em>, char *<em>&nbsp;buf</em>, loff_t<em>&nbsp;off</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_write_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>used to enable access to the PCI ROM display</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>sysfs file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>kernel object handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">bin_attr</span></code></dt>
<dd>struct bin_attribute for this file</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>user input</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt>
<dd>file offset</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of byte in input</dd>
</dl>
<p><strong>Description</strong></p>
<p>writing anything except 0 enables it</p>
<dl class="function">
<dt id="c.pci_read_rom">
ssize_t <code class="descname">pci_read_rom</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct kobject *<em>&nbsp;kobj</em>, struct bin_attribute *<em>&nbsp;bin_attr</em>, char *<em>&nbsp;buf</em>, loff_t<em>&nbsp;off</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_read_rom" title="Permalink to this definition">¶</a></dt>
<dd><p>read a PCI ROM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>sysfs file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>kernel object handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">bin_attr</span></code></dt>
<dd>struct bin_attribute for this file</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>where to put the data we read from the ROM</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">off</span></code></dt>
<dd>file offset</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put <strong>count</strong> bytes starting at <strong>off</strong> into <strong>buf</strong> from the ROM in the PCI
device corresponding to <strong>kobj</strong>.</p>
<dl class="function">
<dt id="c.pci_remove_sysfs_dev_files">
void <code class="descname">pci_remove_sysfs_dev_files</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_remove_sysfs_dev_files" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup PCI specific sysfs files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>device whose entries we should free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup when <strong>pdev</strong> is removed from sysfs.</p>
</div>
<div class="section" id="pci-hotplug-support-library">
<h1>PCI Hotplug Support Library<a class="headerlink" href="#pci-hotplug-support-library" title="Permalink to this headline">¶</a></h1>
<dl class="function">
<dt id="c.__pci_hp_register">
int <code class="descname">__pci_hp_register</code><span class="sig-paren">(</span>struct hotplug_slot *<em>&nbsp;slot</em>, struct pci_bus *<em>&nbsp;bus</em>, int<em>&nbsp;devnr</em>, const char *<em>&nbsp;name</em>, struct module *<em>&nbsp;owner</em>, const char *<em>&nbsp;mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pci_hp_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a hotplug_slot with the PCI hotplug subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*</span> <span class="pre">slot</span></code></dt>
<dd>pointer to the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to register</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus this slot is on</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">devnr</span></code></dt>
<dd>device number</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name registered with kobject core</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>caller module owner</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">mod_name</span></code></dt>
<dd>caller module name</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a hotplug slot with the pci hotplug subsystem, which will allow
userspace interaction to the slot.</p>
<p>Returns 0 if successful, anything else for an error.</p>
<dl class="function">
<dt id="c.pci_hp_deregister">
int <code class="descname">pci_hp_deregister</code><span class="sig-paren">(</span>struct hotplug_slot *<em>&nbsp;slot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_deregister" title="Permalink to this definition">¶</a></dt>
<dd><p>deregister a hotplug_slot with the PCI hotplug subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*</span> <span class="pre">slot</span></code></dt>
<dd>pointer to the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hotplug_slot</span></code> to deregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>slot</strong> must have been registered with the pci hotplug subsystem
previously with a call to <code class="xref c c-func docutils literal"><span class="pre">pci_hp_register()</span></code>.</p>
<p>Returns 0 if successful, anything else for an error.</p>
<dl class="function">
<dt id="c.pci_hp_change_slot_info">
int <code class="descname">pci_hp_change_slot_info</code><span class="sig-paren">(</span>struct hotplug_slot *<em>&nbsp;slot</em>, struct hotplug_slot_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pci_hp_change_slot_info" title="Permalink to this definition">¶</a></dt>
<dd><p>changes the slot’s information structure in the core</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hotplug_slot</span> <span class="pre">*</span> <span class="pre">slot</span></code></dt>
<dd>pointer to the slot whose info has changed</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hotplug_slot_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>pointer to the info copy into the slot’s info structure</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>slot</strong> must have been registered with the pci
hotplug subsystem previously with a call to <code class="xref c c-func docutils literal"><span class="pre">pci_hp_register()</span></code>.</p>
<p>Returns 0 if successful, anything else for an error.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="spi.html" class="btn btn-neutral float-right" title="Serial Peripheral Interface (SPI)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="usb/usb3-debug-port.html" class="btn btn-neutral" title="USB3 debug port" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>