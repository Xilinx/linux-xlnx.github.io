

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux kernel SLIMbus support &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SoundWire Documentation" href="soundwire/index.html" />
    <link rel="prev" title="PXA/MMP - DMA Slave controller" href="dmaengine/pxa_dma.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Linux kernel SLIMbus support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-slimbus">What is SLIMbus?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-description">Hardware description:</a></li>
<li class="toctree-l4"><a class="reference internal" href="#software-description">Software description:</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-notifications-to-the-driver">Device notifications to the driver:</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-and-controller-apis">Driver and Controller APIs:</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clock-pause">Clock-pause:</a></li>
<li class="toctree-l4"><a class="reference internal" href="#messaging">Messaging:</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Linux kernel SLIMbus support</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/slimbus.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-kernel-slimbus-support">
<h1>Linux kernel SLIMbus support<a class="headerlink" href="#linux-kernel-slimbus-support" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-slimbus">
<h3>What is SLIMbus?<a class="headerlink" href="#what-is-slimbus" title="Permalink to this headline">¶</a></h3>
<p>SLIMbus (Serial Low Power Interchip Media Bus) is a specification developed by
MIPI (Mobile Industry Processor Interface) alliance. The bus uses master/slave
configuration, and is a 2-wire multi-drop implementation (clock, and data).</p>
<p>Currently, SLIMbus is used to interface between application processors of SoCs
(System-on-Chip) and peripheral components (typically codec). SLIMbus uses
Time-Division-Multiplexing to accommodate multiple data channels, and
a control channel.</p>
<p>The control channel is used for various control functions such as bus
management, configuration and status updates. These messages can be unicast (e.g.
reading/writing device specific values), or multicast (e.g. data channel
reconfiguration sequence is a broadcast message announced to all devices)</p>
<p>A data channel is used for data-transfer between 2 SLIMbus devices. Data
channel uses dedicated ports on the device.</p>
</div>
<div class="section" id="hardware-description">
<h3>Hardware description:<a class="headerlink" href="#hardware-description" title="Permalink to this headline">¶</a></h3>
<p>SLIMbus specification has different types of device classifications based on
their capabilities.
A manager device is responsible for enumeration, configuration, and dynamic
channel allocation. Every bus has 1 active manager.</p>
<p>A generic device is a device providing application functionality (e.g. codec).</p>
<p>Framer device is responsible for clocking the bus, and transmitting frame-sync
and framing information on the bus.</p>
<p>Each SLIMbus component has an interface device for monitoring physical layer.</p>
<p>Typically each SoC contains SLIMbus component having 1 manager, 1 framer device,
1 generic device (for data channel support), and 1 interface device.
External peripheral SLIMbus component usually has 1 generic device (for
functionality/data channel support), and an associated interface device.
The generic device’s registers are mapped as ‘value elements’ so that they can
be written/read using SLIMbus control channel exchanging control/status type of
information.
In case there are multiple framer devices on the same bus, manager device is
responsible to select the active-framer for clocking the bus.</p>
<p>Per specification, SLIMbus uses “clock gears” to do power management based on
current frequency and bandwidth requirements. There are 10 clock gears and each
gear changes the SLIMbus frequency to be twice its previous gear.</p>
<p>Each device has a 6-byte enumeration-address and the manager assigns every
device with a 1-byte logical address after the devices report presence on the
bus.</p>
</div>
<div class="section" id="software-description">
<h3>Software description:<a class="headerlink" href="#software-description" title="Permalink to this headline">¶</a></h3>
<p>There are 2 types of SLIMbus drivers:</p>
<p>slim_controller represents a ‘controller’ for SLIMbus. This driver should
implement duties needed by the SoC (manager device, associated
interface device for monitoring the layers and reporting errors, default
framer device).</p>
<p>slim_device represents the ‘generic device/component’ for SLIMbus, and a
slim_driver should implement driver for that slim_device.</p>
</div>
<div class="section" id="device-notifications-to-the-driver">
<h3>Device notifications to the driver:<a class="headerlink" href="#device-notifications-to-the-driver" title="Permalink to this headline">¶</a></h3>
<p>Since SLIMbus devices have mechanisms for reporting their presence, the
framework allows drivers to bind when corresponding devices report their
presence on the bus.
However, it is possible that the driver needs to be probed
first so that it can enable corresponding SLIMbus device (e.g. power it up and/or
take it out of reset). To support that behavior, the framework allows drivers
to probe first as well  (e.g. using standard DeviceTree compatibility field).
This creates the necessity for the driver to know when the device is functional
(i.e. reported present). device_up callback is used for that reason when the
device reports present and is assigned a logical address by the controller.</p>
<p>Similarly, SLIMbus devices ‘report absent’ when they go down. A ‘device_down’
callback notifies the driver when the device reports absent and its logical
address assignment is invalidated by the controller.</p>
<p>Another notification “boot_device” is used to notify the slim_driver when
controller resets the bus. This notification allows the driver to take necessary
steps to boot the device so that it’s functional after the bus has been reset.</p>
</div>
<div class="section" id="driver-and-controller-apis">
<h3>Driver and Controller APIs:<a class="headerlink" href="#driver-and-controller-apis" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.slim_eaddr">
struct <code class="descname">slim_eaddr</code><a class="headerlink" href="#c.slim_eaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumeration address for a SLIMbus device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_eaddr {
  u8 instance;
  u8 dev_index;
  u16 prod_code;
  u16 manf_id;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">instance</span></code></dt>
<dd>Instance value</dd>
<dt><code class="docutils literal"><span class="pre">dev_index</span></code></dt>
<dd>Device index</dd>
<dt><code class="docutils literal"><span class="pre">prod_code</span></code></dt>
<dd>Product code</dd>
<dt><code class="docutils literal"><span class="pre">manf_id</span></code></dt>
<dd>Manufacturer Id for the device</dd>
</dl>
<dl class="type">
<dt id="c.slim_device_status">
enum <code class="descname">slim_device_status</code><a class="headerlink" href="#c.slim_device_status" title="Permalink to this definition">¶</a></dt>
<dd><p>slim device status</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SLIM_DEVICE_STATUS_DOWN</span></code></dt>
<dd>Slim device is absent or not reported yet.</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_DEVICE_STATUS_UP</span></code></dt>
<dd>Slim device is announced on the bus.</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_DEVICE_STATUS_RESERVED</span></code></dt>
<dd>Reserved for future use.</dd>
</dl>
<dl class="type">
<dt id="c.slim_device">
struct <code class="descname">slim_device</code><a class="headerlink" href="#c.slim_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Slim device handle.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_device {
  struct device           dev;
  struct slim_eaddr       e_addr;
  struct slim_controller  *ctrl;
  enum slim_device_status status;
  u8 laddr;
  bool is_laddr_valid;
  struct list_head        stream_list;
  spinlock_t stream_list_lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Driver model representation of the device.</dd>
<dt><code class="docutils literal"><span class="pre">e_addr</span></code></dt>
<dd>Enumeration address of this device.</dd>
<dt><code class="docutils literal"><span class="pre">ctrl</span></code></dt>
<dd>slim controller instance.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>slim device status</dd>
<dt><code class="docutils literal"><span class="pre">laddr</span></code></dt>
<dd>1-byte Logical address of this device.</dd>
<dt><code class="docutils literal"><span class="pre">is_laddr_valid</span></code></dt>
<dd>indicates if the laddr is valid or not</dd>
<dt><code class="docutils literal"><span class="pre">stream_list</span></code></dt>
<dd>List of streams on this device</dd>
<dt><code class="docutils literal"><span class="pre">stream_list_lock</span></code></dt>
<dd>lock to protect the stream list</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the client/device handle returned when a SLIMbus
device is registered with a controller.
Pointer to this structure is used by client-driver as a handle.</p>
<dl class="type">
<dt id="c.slim_driver">
struct <code class="descname">slim_driver</code><a class="headerlink" href="#c.slim_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus ‘generic device’ (slave) device driver (similar to ‘spi_device’ on SPI)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_driver {
  int (*probe)(struct slim_device *sl);
  void (*remove)(struct slim_device *sl);
  void (*shutdown)(struct slim_device *sl);
  int (*device_status)(struct slim_device *sl, enum slim_device_status s);
  struct device_driver            driver;
  const struct slim_device_id     *id_table;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>Binds this driver to a SLIMbus device.</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>Unbinds this driver from the SLIMbus device.</dd>
<dt><code class="docutils literal"><span class="pre">shutdown</span></code></dt>
<dd>Standard shutdown callback used during powerdown/halt.</dd>
<dt><code class="docutils literal"><span class="pre">device_status</span></code></dt>
<dd>This callback is called when
- The device reports present and gets a laddr assigned
- The device reports absent, or the bus goes down.</dd>
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>SLIMbus device drivers should initialize name and owner field of
this structure</dd>
<dt><code class="docutils literal"><span class="pre">id_table</span></code></dt>
<dd>List of SLIMbus devices supported by this driver</dd>
</dl>
<dl class="type">
<dt id="c.slim_val_inf">
struct <code class="descname">slim_val_inf</code><a class="headerlink" href="#c.slim_val_inf" title="Permalink to this definition">¶</a></dt>
<dd><p>Slimbus value or information element</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_val_inf {
  u16 start_offset;
  u8 num_bytes;
  u8 *rbuf;
  const u8                *wbuf;
  struct completion      *comp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">start_offset</span></code></dt>
<dd>Specifies starting offset in information/value element map</dd>
<dt><code class="docutils literal"><span class="pre">num_bytes</span></code></dt>
<dd>upto 16. This ensures that the message will fit the slicesize
per SLIMbus spec</dd>
<dt><code class="docutils literal"><span class="pre">rbuf</span></code></dt>
<dd>buffer to read the values</dd>
<dt><code class="docutils literal"><span class="pre">wbuf</span></code></dt>
<dd>buffer to write</dd>
<dt><code class="docutils literal"><span class="pre">comp</span></code></dt>
<dd>completion for asynchronous operations, valid only if TID is
required for transaction, like REQUEST operations.
Rest of the transactions are synchronous anyway.</dd>
</dl>
<dl class="type">
<dt id="c.slim_stream_config">
struct <code class="descname">slim_stream_config</code><a class="headerlink" href="#c.slim_stream_config" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus stream configuration Configuring a stream is done at hw_params or prepare call from audio drivers where they have all the required information regarding rate, number of channels and so on. There is a 1:1 mapping of channel and ports.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_stream_config {
  unsigned int rate;
  unsigned int bps;
  unsigned int ch_count;
  unsigned int *chs;
  unsigned long port_mask;
  int direction;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">rate</span></code></dt>
<dd>data rate</dd>
<dt><code class="docutils literal"><span class="pre">bps</span></code></dt>
<dd>bits per data sample</dd>
<dt><code class="docutils literal"><span class="pre">ch_count</span></code></dt>
<dd>number of channels</dd>
<dt><code class="docutils literal"><span class="pre">chs</span></code></dt>
<dd>pointer to list of channel numbers</dd>
<dt><code class="docutils literal"><span class="pre">port_mask</span></code></dt>
<dd>port mask of ports to use for this stream</dd>
<dt><code class="docutils literal"><span class="pre">direction</span></code></dt>
<dd>direction of the stream, SNDRV_PCM_STREAM_PLAYBACK
or SNDRV_PCM_STREAM_CAPTURE.</dd>
</dl>
<dl class="function">
<dt id="c.module_slim_driver">
<code class="descname">module_slim_driver</code><span class="sig-paren">(</span><em>__slim_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_slim_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a SLIMbus driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__slim_driver</span></code></dt>
<dd>slimbus_driver struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for SLIMbus drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code></a></p>
<dl class="type">
<dt id="c.slim_framer">
struct <code class="descname">slim_framer</code><a class="headerlink" href="#c.slim_framer" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents SLIMbus framer. Every controller may have multiple framers. There is 1 active framer device responsible for clocking the bus. Manager is responsible for framer hand-over.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_framer {
  struct device           dev;
  struct slim_eaddr       e_addr;
  int rootfreq;
  int superfreq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Driver model representation of the device.</dd>
<dt><code class="docutils literal"><span class="pre">e_addr</span></code></dt>
<dd>Enumeration address of the framer.</dd>
<dt><code class="docutils literal"><span class="pre">rootfreq</span></code></dt>
<dd>Root Frequency at which the framer can run. This is maximum
frequency (‘clock gear 10’) at which the bus can operate.</dd>
<dt><code class="docutils literal"><span class="pre">superfreq</span></code></dt>
<dd>Superframes per root frequency. Every frame is 6144 bits.</dd>
</dl>
<dl class="type">
<dt id="c.slim_msg_txn">
struct <code class="descname">slim_msg_txn</code><a class="headerlink" href="#c.slim_msg_txn" title="Permalink to this definition">¶</a></dt>
<dd><p>Message to be sent by the controller. This structure has packet header, payload and buffer to be filled (if any)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_msg_txn {
  u8 rl;
  u8 mt;
  u8 mc;
  u8 dt;
  u16 ec;
  u8 tid;
  u8 la;
  struct slim_val_inf     *msg;
  struct completion      *comp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">rl</span></code></dt>
<dd>Header field. remaining length.</dd>
<dt><code class="docutils literal"><span class="pre">mt</span></code></dt>
<dd>Header field. Message type.</dd>
<dt><code class="docutils literal"><span class="pre">mc</span></code></dt>
<dd>Header field. LSB is message code for type mt.</dd>
<dt><code class="docutils literal"><span class="pre">dt</span></code></dt>
<dd>Header field. Destination type.</dd>
<dt><code class="docutils literal"><span class="pre">ec</span></code></dt>
<dd>Element code. Used for elemental access APIs.</dd>
<dt><code class="docutils literal"><span class="pre">tid</span></code></dt>
<dd>Transaction ID. Used for messages expecting response.
(relevant for message-codes involving read operation)</dd>
<dt><code class="docutils literal"><span class="pre">la</span></code></dt>
<dd>Logical address of the device this message is going to.
(Not used when destination type is broadcast.)</dd>
<dt><code class="docutils literal"><span class="pre">msg</span></code></dt>
<dd>Elemental access message to be read/written</dd>
<dt><code class="docutils literal"><span class="pre">comp</span></code></dt>
<dd>completion if read/write is synchronous, used internally
for tid based transactions.</dd>
</dl>
<dl class="type">
<dt id="c.slim_clk_state">
enum <code class="descname">slim_clk_state</code><a class="headerlink" href="#c.slim_clk_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SLIM_CLK_ACTIVE</span></code></dt>
<dd>SLIMbus clock is active</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CLK_ENTERING_PAUSE</span></code></dt>
<dd>SLIMbus clock pause sequence is being sent on the
bus. If this succeeds, state changes to SLIM_CLK_PAUSED. If the
transition fails, state changes back to SLIM_CLK_ACTIVE</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CLK_PAUSED</span></code></dt>
<dd>SLIMbus controller clock has paused.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>maintaining current clock state.</div></blockquote>
<dl class="type">
<dt id="c.slim_sched">
struct <code class="descname">slim_sched</code><a class="headerlink" href="#c.slim_sched" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_sched {
  enum slim_clk_state     clk_state;
  struct completion       pause_comp;
  struct mutex            m_reconf;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">clk_state</span></code></dt>
<dd>Controller’s clock state from enum slim_clk_state</dd>
<dt><code class="docutils literal"><span class="pre">pause_comp</span></code></dt>
<dd>Signals completion of clock pause sequence. This is useful when
client tries to call SLIMbus transaction when controller is entering
clock pause.</dd>
<dt><code class="docutils literal"><span class="pre">m_reconf</span></code></dt>
<dd>This mutex is held until current reconfiguration (data channel
scheduling, message bandwidth reservation) is done. Message APIs can
use the bus concurrently when this mutex is held since elemental access
messages can be sent on the bus when reconfiguration is in progress.</dd>
</dl>
<dl class="type">
<dt id="c.slim_port_direction">
enum <code class="descname">slim_port_direction</code><a class="headerlink" href="#c.slim_port_direction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SLIM_PORT_SINK</span></code></dt>
<dd>SLIMbus port is a sink</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PORT_SOURCE</span></code></dt>
<dd>SLIMbus port is a source</dd>
</dl>
<dl class="type">
<dt id="c.slim_port_state">
enum <code class="descname">slim_port_state</code><a class="headerlink" href="#c.slim_port_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SLIM_PORT_DISCONNECTED</span></code></dt>
<dd>SLIMbus port is disconnected
entered from Unconfigure/configured state after
DISCONNECT_PORT or REMOVE_CHANNEL core command</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PORT_UNCONFIGURED</span></code></dt>
<dd>SLIMbus port is in unconfigured state.
entered from disconnect state after CONNECT_SOURCE/SINK core command</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PORT_CONFIGURED</span></code></dt>
<dd>SLIMbus port is in configured state.
entered from unconfigured state after DEFINE_CHANNEL, DEFINE_CONTENT
and ACTIVATE_CHANNEL core commands. Ready for data transmission.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>according to SLIMbus Spec 2.0</div></blockquote>
<dl class="type">
<dt id="c.slim_channel_state">
enum <code class="descname">slim_channel_state</code><a class="headerlink" href="#c.slim_channel_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SLIM_CH_STATE_DISCONNECTED</span></code></dt>
<dd>SLIMbus channel is disconnected</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_STATE_ALLOCATED</span></code></dt>
<dd>SLIMbus channel is allocated</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_STATE_ASSOCIATED</span></code></dt>
<dd>SLIMbus channel is associated with port</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_STATE_DEFINED</span></code></dt>
<dd>SLIMbus channel parameters are defined</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_STATE_CONTENT_DEFINED</span></code></dt>
<dd>SLIMbus channel content is defined</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_STATE_ACTIVE</span></code></dt>
<dd>SLIMbus channel is active and ready for data</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_STATE_REMOVED</span></code></dt>
<dd>SLIMbus channel is inactive and removed</dd>
</dl>
<dl class="type">
<dt id="c.slim_ch_data_fmt">
enum <code class="descname">slim_ch_data_fmt</code><a class="headerlink" href="#c.slim_ch_data_fmt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SLIM_CH_DATA_FMT_NOT_DEFINED</span></code></dt>
<dd>Undefined</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_DATA_FMT_LPCM_AUDIO</span></code></dt>
<dd>LPCM audio</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_DATA_FMT_IEC61937_COMP_AUDIO</span></code></dt>
<dd>IEC61937 Compressed audio</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_DATA_FMT_PACKED_PDM_AUDIO</span></code></dt>
<dd>Packed PDM audio</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Table 60 of SLIMbus Spec 1.01.01</div></blockquote>
<dl class="type">
<dt id="c.slim_ch_aux_bit_fmt">
enum <code class="descname">slim_ch_aux_bit_fmt</code><a class="headerlink" href="#c.slim_ch_aux_bit_fmt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SLIM_CH_AUX_FMT_NOT_APPLICABLE</span></code></dt>
<dd>Undefined</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_AUX_FMT_ZCUV_TUNNEL_IEC60958</span></code></dt>
<dd>ZCUV for tunneling IEC60958</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_CH_AUX_FMT_USER_DEFINED</span></code></dt>
<dd>User defined</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Table 63 of SLIMbus Spec 2.0</div></blockquote>
<dl class="type">
<dt id="c.slim_channel">
struct <code class="descname">slim_channel</code><a class="headerlink" href="#c.slim_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus channel, used for state machine</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_channel {
  int id;
  int prrate;
  int seg_dist;
  enum slim_ch_data_fmt data_fmt;
  enum slim_ch_aux_bit_fmt aux_fmt;
  enum slim_channel_state state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>ID of channel</dd>
<dt><code class="docutils literal"><span class="pre">prrate</span></code></dt>
<dd>Presense rate of channel from Table 66 of SLIMbus 2.0 Specs</dd>
<dt><code class="docutils literal"><span class="pre">seg_dist</span></code></dt>
<dd>segment distribution code from Table 20 of SLIMbus 2.0 Specs</dd>
<dt><code class="docutils literal"><span class="pre">data_fmt</span></code></dt>
<dd>Data format of channel.</dd>
<dt><code class="docutils literal"><span class="pre">aux_fmt</span></code></dt>
<dd>Aux format for this channel.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>channel state machine</dd>
</dl>
<dl class="type">
<dt id="c.slim_port">
struct <code class="descname">slim_port</code><a class="headerlink" href="#c.slim_port" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus port</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_port {
  int id;
  enum slim_port_direction direction;
  enum slim_port_state state;
  struct slim_channel ch;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>Port id</dd>
<dt><code class="docutils literal"><span class="pre">direction</span></code></dt>
<dd>Port direction, Source or Sink.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>state machine of port.</dd>
<dt><code class="docutils literal"><span class="pre">ch</span></code></dt>
<dd>channel associated with this port.</dd>
</dl>
<dl class="type">
<dt id="c.slim_transport_protocol">
enum <code class="descname">slim_transport_protocol</code><a class="headerlink" href="#c.slim_transport_protocol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SLIM_PROTO_ISO</span></code></dt>
<dd>Isochronous Protocol, no flow control as data rate match
channel rate flow control embedded in the data.</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PROTO_PUSH</span></code></dt>
<dd>Pushed Protocol, includes flow control, Used to carry
data whose rate is equal to, or lower than the channel rate.</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PROTO_PULL</span></code></dt>
<dd>Pulled Protocol, similar usage as pushed protocol
but pull is a unicast.</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PROTO_LOCKED</span></code></dt>
<dd>Locked Protocol</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PROTO_ASYNC_SMPLX</span></code></dt>
<dd>Asynchronous Protocol-Simplex</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PROTO_ASYNC_HALF_DUP</span></code></dt>
<dd>Asynchronous Protocol-Half-duplex</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PROTO_EXT_SMPLX</span></code></dt>
<dd>Extended Asynchronous Protocol-Simplex</dd>
<dt><code class="docutils literal"><span class="pre">SLIM_PROTO_EXT_HALF_DUP</span></code></dt>
<dd>Extended Asynchronous Protocol-Half-duplex</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Table 47 of SLIMbus 2.0 specs.</div></blockquote>
<dl class="type">
<dt id="c.slim_stream_runtime">
struct <code class="descname">slim_stream_runtime</code><a class="headerlink" href="#c.slim_stream_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>SLIMbus stream runtime instance</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_stream_runtime {
  const char *name;
  struct slim_device *dev;
  int direction;
  enum slim_transport_protocol prot;
  unsigned int rate;
  unsigned int bps;
  unsigned int ratem;
  int num_ports;
  struct slim_port *ports;
  struct list_head node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the stream</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>SLIM Device instance associated with this stream</dd>
<dt><code class="docutils literal"><span class="pre">direction</span></code></dt>
<dd>direction of stream</dd>
<dt><code class="docutils literal"><span class="pre">prot</span></code></dt>
<dd>Transport protocol used in this stream</dd>
<dt><code class="docutils literal"><span class="pre">rate</span></code></dt>
<dd>Data rate of samples *</dd>
<dt><code class="docutils literal"><span class="pre">bps</span></code></dt>
<dd>bits per sample</dd>
<dt><code class="docutils literal"><span class="pre">ratem</span></code></dt>
<dd>rate multipler which is super frame rate/data rate</dd>
<dt><code class="docutils literal"><span class="pre">num_ports</span></code></dt>
<dd>number of ports</dd>
<dt><code class="docutils literal"><span class="pre">ports</span></code></dt>
<dd>pointer to instance of ports</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>list head for stream associated with slim device.</dd>
</dl>
<dl class="type">
<dt id="c.slim_controller">
struct <code class="descname">slim_controller</code><a class="headerlink" href="#c.slim_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls every instance of SLIMbus (similar to ‘master’ on SPI)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct slim_controller {
  struct device           *dev;
  unsigned int            id;
  char name[SLIMBUS_NAME_SIZE];
  int min_cg;
  int max_cg;
  int clkgear;
  struct ida              laddr_ida;
  struct slim_framer      *a_framer;
  struct mutex            lock;
  struct list_head        devices;
  struct idr              tid_idr;
  spinlock_t txn_lock;
  struct slim_sched       sched;
  int (*xfer_msg)(struct slim_controller *ctrl, struct slim_msg_txn *tx);
  int (*set_laddr)(struct slim_controller *ctrl, struct slim_eaddr *ea, u8 laddr);
  int (*get_laddr)(struct slim_controller *ctrl, struct slim_eaddr *ea, u8 *laddr);
  int (*enable_stream)(struct slim_stream_runtime *rt);
  int (*disable_stream)(struct slim_stream_runtime *rt);
  int (*wakeup)(struct slim_controller *ctrl);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Device interface to this driver</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>Board-specific number identifier for this controller/bus</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name for this controller</dd>
<dt><code class="docutils literal"><span class="pre">min_cg</span></code></dt>
<dd>Minimum clock gear supported by this controller (default value: 1)</dd>
<dt><code class="docutils literal"><span class="pre">max_cg</span></code></dt>
<dd>Maximum clock gear supported by this controller (default value: 10)</dd>
<dt><code class="docutils literal"><span class="pre">clkgear</span></code></dt>
<dd>Current clock gear in which this bus is running</dd>
<dt><code class="docutils literal"><span class="pre">laddr_ida</span></code></dt>
<dd>logical address id allocator</dd>
<dt><code class="docutils literal"><span class="pre">a_framer</span></code></dt>
<dd>Active framer which is clocking the bus managed by this controller</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>Mutex protecting controller data structures</dd>
<dt><code class="docutils literal"><span class="pre">devices</span></code></dt>
<dd>Slim device list</dd>
<dt><code class="docutils literal"><span class="pre">tid_idr</span></code></dt>
<dd>tid id allocator</dd>
<dt><code class="docutils literal"><span class="pre">txn_lock</span></code></dt>
<dd>Lock to protect table of transactions</dd>
<dt><code class="docutils literal"><span class="pre">sched</span></code></dt>
<dd>scheduler structure used by the controller</dd>
<dt><code class="docutils literal"><span class="pre">xfer_msg</span></code></dt>
<dd>Transfer a message on this controller (this can be a broadcast
control/status message like data channel setup, or a unicast message
like value element read/write.</dd>
<dt><code class="docutils literal"><span class="pre">set_laddr</span></code></dt>
<dd>Setup logical address at laddr for the slave with elemental
address e_addr. Drivers implementing controller will be expected to
send unicast message to this device with its logical address.</dd>
<dt><code class="docutils literal"><span class="pre">get_laddr</span></code></dt>
<dd>It is possible that controller needs to set fixed logical
address table and get_laddr can be used in that case so that controller
can do this assignment. Use case is when the master is on the remote
processor side, who is resposible for allocating laddr.</dd>
<dt><code class="docutils literal"><span class="pre">enable_stream</span></code></dt>
<dd>This function pointer implements controller-specific procedure
to enable a stream.</dd>
<dt><code class="docutils literal"><span class="pre">disable_stream</span></code></dt>
<dd>This function pointer implements controller-specific procedure
to disable stream.</dd>
<dt><code class="docutils literal"><span class="pre">wakeup</span></code></dt>
<dd>This function pointer implements controller-specific procedure
to wake it up from clock-pause. Framework will call this to bring
the controller out of clock pause.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>‘Manager device’ is responsible for  device management, bandwidth
allocation, channel setup, and port associations per channel.
Device management means Logical address assignment/removal based on
enumeration (report-present, report-absent) of a device.
Bandwidth allocation is done dynamically by the manager based on active
channels on the bus, message-bandwidth requests made by SLIMbus devices.
Based on current bandwidth usage, manager chooses a frequency to run
the bus at (in steps of ‘clock-gear’, 1 through 10, each clock gear
representing twice the frequency than the previous gear).
Manager is also responsible for entering (and exiting) low-power-mode
(known as ‘clock pause’).
Manager can do handover of framer if there are multiple framers on the
bus and a certain usecase warrants using certain framer to avoid keeping
previous framer being powered-on.</p>
<p>Controller here performs duties of the manager device, and ‘interface
device’. Interface device is responsible for monitoring the bus and
reporting information such as loss-of-synchronization, data
slot-collision.</p>
</div></blockquote>
<dl class="function">
<dt id="c.slim_unregister_controller">
int <code class="descname">slim_unregister_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_unregister_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>Controller tear-down.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>Controller to tear-down.</dd>
</dl>
<dl class="function">
<dt id="c.slim_report_absent">
void <code class="descname">slim_report_absent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> *<em>&nbsp;sbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_report_absent" title="Permalink to this definition">¶</a></dt>
<dd><p>Controller calls this function when a device reports absent, OR when the device cannot be communicated with</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*</span> <span class="pre">sbdev</span></code></dt>
<dd>Device that cannot be reached, or sent report absent</dd>
</dl>
<dl class="function">
<dt id="c.slim_get_device">
struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> * <code class="descname">slim_get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em>, struct <a class="reference internal" href="#c.slim_eaddr" title="slim_eaddr">slim_eaddr</a> *<em>&nbsp;e_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>get handle to a device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>Controller on which this device will be added/queried</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_eaddr</span> <span class="pre">*</span> <span class="pre">e_addr</span></code></dt>
<dd>Enumeration address of the device to be queried</dd>
</dl>
<p><strong>Return</strong></p>
<p>pointer to a device if it has already reported. Creates a new
device and returns pointer to it if the device has not yet enumerated.</p>
<dl class="function">
<dt id="c.of_slim_get_device">
struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> * <code class="descname">of_slim_get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em>, struct device_node *<em>&nbsp;np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_slim_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>get handle to a device using dt node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>Controller on which this device will be added/queried</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>node pointer to device</dd>
</dl>
<p><strong>Return</strong></p>
<p>pointer to a device if it has already reported. Creates a new
device and returns pointer to it if the device has not yet enumerated.</p>
<dl class="function">
<dt id="c.slim_device_report_present">
int <code class="descname">slim_device_report_present</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em>, struct <a class="reference internal" href="#c.slim_eaddr" title="slim_eaddr">slim_eaddr</a> *<em>&nbsp;e_addr</em>, u8 *<em>&nbsp;laddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_device_report_present" title="Permalink to this definition">¶</a></dt>
<dd><p>Report enumerated device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>Controller with which device is enumerated.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_eaddr</span> <span class="pre">*</span> <span class="pre">e_addr</span></code></dt>
<dd>Enumeration address of the device.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">laddr</span></code></dt>
<dd>Return logical address (if valid flag is false)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by controller in response to REPORT_PRESENT. Framework will assign
a logical address to this enumeration address.
Function returns -EXFULL to indicate that all logical addresses are already
taken.</p>
<dl class="function">
<dt id="c.slim_get_logical_addr">
int <code class="descname">slim_get_logical_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> *<em>&nbsp;sbdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_get_logical_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>get/allocate logical address of a SLIMbus device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*</span> <span class="pre">sbdev</span></code></dt>
<dd>client handle requesting the address.</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero if a logical address is valid or a new logical address
has been assigned. error code in case of error.</p>
</div>
<div class="section" id="clock-pause">
<h3>Clock-pause:<a class="headerlink" href="#clock-pause" title="Permalink to this headline">¶</a></h3>
<p>SLIMbus mandates that a reconfiguration sequence (known as clock-pause) be
broadcast to all active devices on the bus before the bus can enter low-power
mode. Controller uses this sequence when it decides to enter low-power mode so
that corresponding clocks and/or power-rails can be turned off to save power.
Clock-pause is exited by waking up framer device (if controller driver initiates
exiting low power mode), or by toggling the data line (if a slave device wants
to initiate it).</p>
<div class="section" id="clock-pause-apis">
<h4>Clock-pause APIs:<a class="headerlink" href="#clock-pause-apis" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="c.slim_ctrl_clk_pause">
int <code class="descname">slim_ctrl_clk_pause</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em>, bool<em>&nbsp;wakeup</em>, u8<em>&nbsp;restart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_ctrl_clk_pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by slimbus controller to enter/exit ‘clock pause’</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>controller requesting bus to be paused or woken up</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">wakeup</span></code></dt>
<dd>Wakeup this controller from clock pause.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">restart</span></code></dt>
<dd>Restart time value per spec used for clock pause. This value
isn’t used when controller is to be woken up.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Slimbus specification needs this sequence to turn-off clocks for the bus.
The sequence involves sending 3 broadcast messages (reconfiguration
sequence) to inform all devices on the bus.
To exit clock-pause, controller typically wakes up active framer device.
This API executes clock pause reconfiguration sequence if wakeup is false.
If wakeup is true, controller’s wakeup is called.
For entering clock-pause, -EBUSY is returned if a message txn in pending.</p>
</div>
</div>
<div class="section" id="messaging">
<h3>Messaging:<a class="headerlink" href="#messaging" title="Permalink to this headline">¶</a></h3>
<p>The framework supports regmap and read/write apis to exchange control-information
with a SLIMbus device. APIs can be synchronous or asynchronous.
The header file &lt;linux/slimbus.h&gt; has more documentation about messaging APIs.</p>
<div class="section" id="messaging-apis">
<h4>Messaging APIs:<a class="headerlink" href="#messaging-apis" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="c.slim_msg_response">
void <code class="descname">slim_msg_response</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em>, u8 *<em>&nbsp;reply</em>, u8<em>&nbsp;tid</em>, u8<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_msg_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Deliver Message response received from a device to the framework.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>Controller handle</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">reply</span></code></dt>
<dd>Reply received from the device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">tid</span></code></dt>
<dd>Transaction ID received with which framework can associate reply.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">len</span></code></dt>
<dd>Length of the reply</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by controller to inform framework about the response received.
This helps in making the API asynchronous, and controller-driver doesn’t need
to manage 1 more table other than the one managed by framework mapping TID
with buffers</p>
<dl class="function">
<dt id="c.slim_alloc_txn_tid">
int <code class="descname">slim_alloc_txn_tid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em>, struct <a class="reference internal" href="#c.slim_msg_txn" title="slim_msg_txn">slim_msg_txn</a> *<em>&nbsp;txn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_alloc_txn_tid" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a tid to txn</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>Controller handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_msg_txn</span> <span class="pre">*</span> <span class="pre">txn</span></code></dt>
<dd>transaction to be allocated with tid.</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero on success with valid txn-&gt;tid and error code on failures.</p>
<dl class="function">
<dt id="c.slim_free_txn_tid">
void <code class="descname">slim_free_txn_tid</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em>, struct <a class="reference internal" href="#c.slim_msg_txn" title="slim_msg_txn">slim_msg_txn</a> *<em>&nbsp;txn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_free_txn_tid" title="Permalink to this definition">¶</a></dt>
<dd><p>Freee tid of txn</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>Controller handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_msg_txn</span> <span class="pre">*</span> <span class="pre">txn</span></code></dt>
<dd>transaction whose tid should be freed</dd>
</dl>
<dl class="function">
<dt id="c.slim_do_transfer">
int <code class="descname">slim_do_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_controller" title="slim_controller">slim_controller</a> *<em>&nbsp;ctrl</em>, struct <a class="reference internal" href="#c.slim_msg_txn" title="slim_msg_txn">slim_msg_txn</a> *<em>&nbsp;txn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_do_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a SLIMbus-messaging transaction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_controller</span> <span class="pre">*</span> <span class="pre">ctrl</span></code></dt>
<dd>Controller handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_msg_txn</span> <span class="pre">*</span> <span class="pre">txn</span></code></dt>
<dd>Transaction to be sent over SLIMbus</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by controller to transmit messaging transactions not dealing with
Interface/Value elements. (e.g. transmittting a message to assign logical
address to a slave device</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>-ETIMEDOUT: If transmission of this message timed out</dt>
<dd>(e.g. due to bus lines not being clocked or driven by controller)</dd>
</dl>
<dl class="function">
<dt id="c.slim_xfer_msg">
int <code class="descname">slim_xfer_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> *<em>&nbsp;sbdev</em>, struct <a class="reference internal" href="#c.slim_val_inf" title="slim_val_inf">slim_val_inf</a> *<em>&nbsp;msg</em>, u8<em>&nbsp;mc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_xfer_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Transfer a value info message on slim device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*</span> <span class="pre">sbdev</span></code></dt>
<dd>slim device to which this msg has to be transfered</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_val_inf</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>value info message pointer</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">mc</span></code></dt>
<dd>message code of the message</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by drivers which want to transfer a vlaue or info elements.</p>
<p><strong>Return</strong></p>
<p>-ETIMEDOUT: If transmission of this message timed out</p>
<dl class="function">
<dt id="c.slim_read">
int <code class="descname">slim_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> *<em>&nbsp;sdev</em>, u32<em>&nbsp;addr</em>, size_t<em>&nbsp;count</em>, u8 *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read SLIMbus value element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>client handle.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">addr</span></code></dt>
<dd>address of value element to read.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to read. Maximum bytes allowed are 16.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>will return what the value element value was</dd>
</dl>
<p><strong>Return</strong></p>
<p>-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)</p>
<dl class="function">
<dt id="c.slim_readb">
int <code class="descname">slim_readb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> *<em>&nbsp;sdev</em>, u32<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_readb" title="Permalink to this definition">¶</a></dt>
<dd><p>Read byte from SLIMbus value element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>client handle.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">addr</span></code></dt>
<dd>address in the value element to read.</dd>
</dl>
<p><strong>Return</strong></p>
<p>byte value of value element.</p>
<dl class="function">
<dt id="c.slim_write">
int <code class="descname">slim_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> *<em>&nbsp;sdev</em>, u32<em>&nbsp;addr</em>, size_t<em>&nbsp;count</em>, u8 *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write SLIMbus value element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>client handle.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">addr</span></code></dt>
<dd>address in the value element to write.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to write. Maximum bytes allowed are 16.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>value to write to value element</dd>
</dl>
<p><strong>Return</strong></p>
<p>-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)</p>
<dl class="function">
<dt id="c.slim_writeb">
int <code class="descname">slim_writeb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.slim_device" title="slim_device">slim_device</a> *<em>&nbsp;sdev</em>, u32<em>&nbsp;addr</em>, u8<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.slim_writeb" title="Permalink to this definition">¶</a></dt>
<dd><p>Write byte to SLIMbus value element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">slim_device</span> <span class="pre">*</span> <span class="pre">sdev</span></code></dt>
<dd>client handle.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">addr</span></code></dt>
<dd>address of value element to write.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">value</span></code></dt>
<dd>value to write to value element</dd>
</dl>
<p><strong>Return</strong></p>
<p>-EINVAL for Invalid parameters, -ETIMEDOUT If transmission of
this message timed out (e.g. due to bus lines not being clocked
or driven by controller)</p>
</div>
<div class="section" id="streaming-apis">
<h4>Streaming APIs:<a class="headerlink" href="#streaming-apis" title="Permalink to this headline">¶</a></h4>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="soundwire/index.html" class="btn btn-neutral float-right" title="SoundWire Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dmaengine/pxa_dma.html" class="btn btn-neutral" title="PXA/MMP - DMA Slave controller" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>