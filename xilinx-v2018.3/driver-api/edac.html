

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Error Detection And Correction (EDAC) Devices &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SCSI Interfaces Guide" href="scsi.html" />
    <link rel="prev" title="High Speed Synchronous Serial Interface (HSI)" href="hsi.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Error Detection And Correction (EDAC) Devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#main-concepts-used-at-the-edac-subsystem">Main Concepts used at the EDAC subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-controllers">Memory Controllers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pci-controllers">PCI Controllers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#edac-blocks">EDAC Blocks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Error Detection And Correction (EDAC) Devices</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/edac.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="error-detection-and-correction-edac-devices">
<h1>Error Detection And Correction (EDAC) Devices<a class="headerlink" href="#error-detection-and-correction-edac-devices" title="Permalink to this headline">¶</a></h1>
<div class="section" id="main-concepts-used-at-the-edac-subsystem">
<h2>Main Concepts used at the EDAC subsystem<a class="headerlink" href="#main-concepts-used-at-the-edac-subsystem" title="Permalink to this headline">¶</a></h2>
<p>There are several things to be aware of that aren’t at all obvious, like
<em>sockets, *socket sets</em>, <em>banks</em>, <em>rows</em>, <em>chip-select rows</em>, <em>channels</em>,
etc…</p>
<p>These are some of the many terms that are thrown about that don’t always
mean what people think they mean (Inconceivable!).  In the interest of
creating a common ground for discussion, terms and their definitions
will be established.</p>
<ul class="simple">
<li>Memory devices</li>
</ul>
<p>The individual DRAM chips on a memory stick.  These devices commonly
output 4 and 8 bits each (x4, x8). Grouping several of these in parallel
provides the number of bits that the memory controller expects:
typically 72 bits, in order to provide 64 bits + 8 bits of ECC data.</p>
<ul class="simple">
<li>Memory Stick</li>
</ul>
<p>A printed circuit board that aggregates multiple memory devices in
parallel.  In general, this is the Field Replaceable Unit (FRU) which
gets replaced, in the case of excessive errors. Most often it is also
called DIMM (Dual Inline Memory Module).</p>
<ul class="simple">
<li>Memory Socket</li>
</ul>
<p>A physical connector on the motherboard that accepts a single memory
stick. Also called as “slot” on several datasheets.</p>
<ul class="simple">
<li>Channel</li>
</ul>
<p>A memory controller channel, responsible to communicate with a group of
DIMMs. Each channel has its own independent control (command) and data
bus, and can be used independently or grouped with other channels.</p>
<ul class="simple">
<li>Branch</li>
</ul>
<p>It is typically the highest hierarchy on a Fully-Buffered DIMM memory
controller. Typically, it contains two channels. Two channels at the
same branch can be used in single mode or in lockstep mode. When
lockstep is enabled, the cacheline is doubled, but it generally brings
some performance penalty. Also, it is generally not possible to point to
just one memory stick when an error occurs, as the error correction code
is calculated using two DIMMs instead of one. Due to that, it is capable
of correcting more errors than on single mode.</p>
<ul class="simple">
<li>Single-channel</li>
</ul>
<p>The data accessed by the memory controller is contained into one dimm
only. E. g. if the data is 64 bits-wide, the data flows to the CPU using
one 64 bits parallel access. Typically used with SDR, DDR, DDR2 and DDR3
memories. FB-DIMM and RAMBUS use a different concept for channel, so
this concept doesn’t apply there.</p>
<ul class="simple">
<li>Double-channel</li>
</ul>
<p>The data size accessed by the memory controller is interlaced into two
dimms, accessed at the same time. E. g. if the DIMM is 64 bits-wide (72
bits with ECC), the data flows to the CPU using a 128 bits parallel
access.</p>
<ul class="simple">
<li>Chip-select row</li>
</ul>
<p>This is the name of the DRAM signal used to select the DRAM ranks to be
accessed. Common chip-select rows for single channel are 64 bits, for
dual channel 128 bits. It may not be visible by the memory controller,
as some DIMM types have a memory buffer that can hide direct access to
it from the Memory Controller.</p>
<ul class="simple">
<li>Single-Ranked stick</li>
</ul>
<p>A Single-ranked stick has 1 chip-select row of memory. Motherboards
commonly drive two chip-select pins to a memory stick. A single-ranked
stick, will occupy only one of those rows. The other will be unused.</p>
<ul class="simple" id="doubleranked">
<li>Double-Ranked stick</li>
</ul>
<p>A double-ranked stick has two chip-select rows which access different
sets of memory devices.  The two rows cannot be accessed concurrently.</p>
<ul class="simple">
<li>Double-sided stick</li>
</ul>
<p><strong>DEPRECATED TERM</strong>, see <a class="reference internal" href="#doubleranked"><span class="std std-ref">Double-Ranked stick</span></a>.</p>
<p>A double-sided stick has two chip-select rows which access different sets
of memory devices. The two rows cannot be accessed concurrently.
“Double-sided” is irrespective of the memory devices being mounted on
both sides of the memory stick.</p>
<ul class="simple">
<li>Socket set</li>
</ul>
<p>All of the memory sticks that are required for a single memory access or
all of the memory sticks spanned by a chip-select row.  A single socket
set has two chip-select rows and if double-sided sticks are used these
will occupy those chip-select rows.</p>
<ul class="simple">
<li>Bank</li>
</ul>
<p>This term is avoided because it is unclear when needing to distinguish
between chip-select rows and socket sets.</p>
</div>
<div class="section" id="memory-controllers">
<h2>Memory Controllers<a class="headerlink" href="#memory-controllers" title="Permalink to this headline">¶</a></h2>
<p>Most of the EDAC core is focused on doing Memory Controller error detection.
The <a class="reference internal" href="#c.edac_mc_alloc" title="edac_mc_alloc"><code class="xref c c-func docutils literal"><span class="pre">edac_mc_alloc()</span></code></a>. It uses internally the struct <code class="docutils literal"><span class="pre">mem_ctl_info</span></code>
to describe the memory controllers, with is an opaque struct for the EDAC
drivers. Only the EDAC core is allowed to touch it.</p>
<dl class="type">
<dt id="c.dev_type">
enum <code class="descname">dev_type</code><a class="headerlink" href="#c.dev_type" title="Permalink to this definition">¶</a></dt>
<dd><p>describe the type of memory DRAM chips used at the stick</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DEV_UNKNOWN</span></code></dt>
<dd>Can’t be determined, or MC doesn’t support detect it</dd>
<dt><code class="docutils literal"><span class="pre">DEV_X1</span></code></dt>
<dd>1 bit for data</dd>
<dt><code class="docutils literal"><span class="pre">DEV_X2</span></code></dt>
<dd>2 bits for data</dd>
<dt><code class="docutils literal"><span class="pre">DEV_X4</span></code></dt>
<dd>4 bits for data</dd>
<dt><code class="docutils literal"><span class="pre">DEV_X8</span></code></dt>
<dd>8 bits for data</dd>
<dt><code class="docutils literal"><span class="pre">DEV_X16</span></code></dt>
<dd>16 bits for data</dd>
<dt><code class="docutils literal"><span class="pre">DEV_X32</span></code></dt>
<dd>32 bits for data</dd>
<dt><code class="docutils literal"><span class="pre">DEV_X64</span></code></dt>
<dd>64 bits for data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Typical values are x4 and x8.</p>
<dl class="type">
<dt id="c.hw_event_mc_err_type">
enum <code class="descname">hw_event_mc_err_type</code><a class="headerlink" href="#c.hw_event_mc_err_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of the detected error</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">HW_EVENT_ERR_CORRECTED</span></code></dt>
<dd>Corrected Error - Indicates that an ECC
corrected error was detected</dd>
<dt><code class="docutils literal"><span class="pre">HW_EVENT_ERR_UNCORRECTED</span></code></dt>
<dd>Uncorrected Error - Indicates an error that
can’t be corrected by ECC, but it is not
fatal (maybe it is on an unused memory area,
or the memory controller could recover from
it for example, by re-trying the operation).</dd>
<dt><code class="docutils literal"><span class="pre">HW_EVENT_ERR_DEFERRED</span></code></dt>
<dd>Deferred Error - Indicates an uncorrectable
error whose handling is not urgent. This could
be due to hardware data poisoning where the
system can continue operation until the poisoned
data is consumed. Preemptive measures may also
be taken, e.g. offlining pages, etc.</dd>
<dt><code class="docutils literal"><span class="pre">HW_EVENT_ERR_FATAL</span></code></dt>
<dd>Fatal Error - Uncorrected error that could not
be recovered.</dd>
<dt><code class="docutils literal"><span class="pre">HW_EVENT_ERR_INFO</span></code></dt>
<dd>Informational - The CPER spec defines a forth
type of error: informational logs.</dd>
</dl>
<dl class="type">
<dt id="c.mem_type">
enum <code class="descname">mem_type</code><a class="headerlink" href="#c.mem_type" title="Permalink to this definition">¶</a></dt>
<dd><p>memory types. For a more detailed reference, please see <a class="reference external" href="http://en.wikipedia.org/wiki/DRAM">http://en.wikipedia.org/wiki/DRAM</a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MEM_EMPTY</span></code></dt>
<dd>Empty csrow</dd>
<dt><code class="docutils literal"><span class="pre">MEM_RESERVED</span></code></dt>
<dd>Reserved csrow type</dd>
<dt><code class="docutils literal"><span class="pre">MEM_UNKNOWN</span></code></dt>
<dd>Unknown csrow type</dd>
<dt><code class="docutils literal"><span class="pre">MEM_FPM</span></code></dt>
<dd>FPM - Fast Page Mode, used on systems up to 1995.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_EDO</span></code></dt>
<dd>EDO - Extended data out, used on systems up to 1998.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_BEDO</span></code></dt>
<dd>BEDO - Burst Extended data out, an EDO variant.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_SDR</span></code></dt>
<dd>SDR - Single data rate SDRAM
<a class="reference external" href="http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory">http://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory</a>
They use 3 pins for chip select: Pins 0 and 2 are
for rank 0; pins 1 and 3 are for rank 1, if the memory
is dual-rank.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_RDR</span></code></dt>
<dd>Registered SDR SDRAM</dd>
<dt><code class="docutils literal"><span class="pre">MEM_DDR</span></code></dt>
<dd>Double data rate SDRAM
<a class="reference external" href="http://en.wikipedia.org/wiki/DDR_SDRAM">http://en.wikipedia.org/wiki/DDR_SDRAM</a></dd>
<dt><code class="docutils literal"><span class="pre">MEM_RDDR</span></code></dt>
<dd>Registered Double data rate SDRAM
This is a variant of the DDR memories.
A registered memory has a buffer inside it, hiding
part of the memory details to the memory controller.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_RMBS</span></code></dt>
<dd>Rambus DRAM, used on a few Pentium III/IV controllers.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_DDR2</span></code></dt>
<dd>DDR2 RAM, as described at JEDEC JESD79-2F.
Those memories are labeled as “PC2-” instead of “PC” to
differentiate from DDR.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_FB_DDR2</span></code></dt>
<dd>Fully-Buffered DDR2, as described at JEDEC Std No. 205
and JESD206.
Those memories are accessed per DIMM slot, and not by
a chip select signal.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_RDDR2</span></code></dt>
<dd>Registered DDR2 RAM
This is a variant of the DDR2 memories.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_XDR</span></code></dt>
<dd>Rambus XDR
It is an evolution of the original RAMBUS memories,
created to compete with DDR2. Weren’t used on any
x86 arch, but cell_edac PPC memory controller uses it.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_DDR3</span></code></dt>
<dd>DDR3 RAM</dd>
<dt><code class="docutils literal"><span class="pre">MEM_RDDR3</span></code></dt>
<dd>Registered DDR3 RAM
This is a variant of the DDR3 memories.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_LRDDR3</span></code></dt>
<dd>Load-Reduced DDR3 memory.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_DDR4</span></code></dt>
<dd>Unbuffered DDR4 RAM</dd>
<dt><code class="docutils literal"><span class="pre">MEM_RDDR4</span></code></dt>
<dd>Registered DDR4 RAM
This is a variant of the DDR4 memories.</dd>
<dt><code class="docutils literal"><span class="pre">MEM_LRDDR4</span></code></dt>
<dd>Load-Reduced DDR4 memory.</dd>
</dl>
<dl class="type">
<dt id="c.edac_type">
enum <code class="descname">edac_type</code><a class="headerlink" href="#c.edac_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type - Error Detection and Correction capabilities and mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">EDAC_UNKNOWN</span></code></dt>
<dd>Unknown if ECC is available</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_NONE</span></code></dt>
<dd>Doesn’t support ECC</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_RESERVED</span></code></dt>
<dd>Reserved ECC type</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_PARITY</span></code></dt>
<dd>Detects parity errors</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_EC</span></code></dt>
<dd>Error Checking - no correction</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_SECDED</span></code></dt>
<dd>Single bit error correction, Double detection</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_S2ECD2ED</span></code></dt>
<dd>Chipkill x2 devices - do these exist?</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_S4ECD4ED</span></code></dt>
<dd>Chipkill x4 devices</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_S8ECD8ED</span></code></dt>
<dd>Chipkill x8 devices</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_S16ECD16ED</span></code></dt>
<dd>Chipkill x16 devices</dd>
</dl>
<dl class="type">
<dt id="c.scrub_type">
enum <code class="descname">scrub_type</code><a class="headerlink" href="#c.scrub_type" title="Permalink to this definition">¶</a></dt>
<dd><p>scrubbing capabilities</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SCRUB_UNKNOWN</span></code></dt>
<dd>Unknown if scrubber is available</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_NONE</span></code></dt>
<dd>No scrubber</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_SW_PROG</span></code></dt>
<dd>SW progressive (sequential) scrubbing</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_SW_SRC</span></code></dt>
<dd>Software scrub only errors</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_SW_PROG_SRC</span></code></dt>
<dd>Progressive software scrub from an error</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_SW_TUNABLE</span></code></dt>
<dd>Software scrub frequency is tunable</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_HW_PROG</span></code></dt>
<dd>HW progressive (sequential) scrubbing</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_HW_SRC</span></code></dt>
<dd>Hardware scrub only errors</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_HW_PROG_SRC</span></code></dt>
<dd>Progressive hardware scrub from an error</dd>
<dt><code class="docutils literal"><span class="pre">SCRUB_HW_TUNABLE</span></code></dt>
<dd>Hardware scrub frequency is tunable</dd>
</dl>
<dl class="type">
<dt id="c.edac_mc_layer_type">
enum <code class="descname">edac_mc_layer_type</code><a class="headerlink" href="#c.edac_mc_layer_type" title="Permalink to this definition">¶</a></dt>
<dd><p>memory controller hierarchy layer</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">EDAC_MC_LAYER_BRANCH</span></code></dt>
<dd>memory layer is named “branch”</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_MC_LAYER_CHANNEL</span></code></dt>
<dd>memory layer is named “channel”</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_MC_LAYER_SLOT</span></code></dt>
<dd>memory layer is named “slot”</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_MC_LAYER_CHIP_SELECT</span></code></dt>
<dd>memory layer is named “chip select”</dd>
<dt><code class="docutils literal"><span class="pre">EDAC_MC_LAYER_ALL_MEM</span></code></dt>
<dd>memory layout is unknown. All memory is mapped
as a single memory area. This is used when
retrieving errors from a firmware driven driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used by the drivers to tell edac_mc_sysfs what name should
be used when describing a memory stick location.</p>
<dl class="type">
<dt id="c.edac_mc_layer">
struct <code class="descname">edac_mc_layer</code><a class="headerlink" href="#c.edac_mc_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>describes the memory controller hierarchy</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct edac_mc_layer {
  enum edac_mc_layer_type type;
  unsigned size;
  bool is_virt_csrow;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>layer type</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>number of components per layer. For example,
if the channel layer has two channels, size = 2</dd>
<dt><code class="docutils literal"><span class="pre">is_virt_csrow</span></code></dt>
<dd>This layer is part of the “csrow” when old API
compatibility mode is enabled. Otherwise, it is
a channel</dd>
</dl>
<dl class="function">
<dt id="c.EDAC_DIMM_OFF">
<code class="descname">EDAC_DIMM_OFF</code><span class="sig-paren">(</span><em>layers</em>, <em>nlayers</em>, <em>layer0</em>, <em>layer1</em>, <em>layer2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.EDAC_DIMM_OFF" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro responsible to get a pointer offset inside a pointer array for the element given by [layer0,layer1,layer2] position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">layers</span></code></dt>
<dd>a struct edac_mc_layer array, describing how many elements
were allocated for each layer</dd>
<dt><code class="docutils literal"><span class="pre">nlayers</span></code></dt>
<dd>Number of layers at the <strong>layers</strong> array</dd>
<dt><code class="docutils literal"><span class="pre">layer0</span></code></dt>
<dd>layer0 position</dd>
<dt><code class="docutils literal"><span class="pre">layer1</span></code></dt>
<dd>layer1 position. Unused if n_layers &lt; 2</dd>
<dt><code class="docutils literal"><span class="pre">layer2</span></code></dt>
<dd>layer2 position. Unused if n_layers &lt; 3</dd>
</dl>
<p><strong>Description</strong></p>
<p>For 1 layer, this macro returns “var[layer0] - var”;</p>
<p>For 2 layers, this macro is similar to allocate a bi-dimensional array
and to return “var[layer0][layer1] - var”;</p>
<p>For 3 layers, this macro is similar to allocate a tri-dimensional array
and to return “var[layer0][layer1][layer2] - var”.</p>
<p>A loop could be used here to make it more generic, but, as we only have
3 layers, this is a little faster.</p>
<p>By design, layers can never be 0 or more than 3. If that ever happens,
a NULL is returned, causing an OOPS during the memory allocation routine,
with would point to the developer that he’s doing something wrong.</p>
<dl class="function">
<dt id="c.EDAC_DIMM_PTR">
<code class="descname">EDAC_DIMM_PTR</code><span class="sig-paren">(</span><em>layers</em>, <em>var</em>, <em>nlayers</em>, <em>layer0</em>, <em>layer1</em>, <em>layer2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.EDAC_DIMM_PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>Macro responsible to get a pointer inside a pointer array for the element given by [layer0,layer1,layer2] position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">layers</span></code></dt>
<dd>a struct edac_mc_layer array, describing how many elements
were allocated for each layer</dd>
<dt><code class="docutils literal"><span class="pre">var</span></code></dt>
<dd>name of the var where we want to get the pointer
(like mci-&gt;dimms)</dd>
<dt><code class="docutils literal"><span class="pre">nlayers</span></code></dt>
<dd>Number of layers at the <strong>layers</strong> array</dd>
<dt><code class="docutils literal"><span class="pre">layer0</span></code></dt>
<dd>layer0 position</dd>
<dt><code class="docutils literal"><span class="pre">layer1</span></code></dt>
<dd>layer1 position. Unused if n_layers &lt; 2</dd>
<dt><code class="docutils literal"><span class="pre">layer2</span></code></dt>
<dd>layer2 position. Unused if n_layers &lt; 3</dd>
</dl>
<p><strong>Description</strong></p>
<p>For 1 layer, this macro returns “var[layer0]”;</p>
<p>For 2 layers, this macro is similar to allocate a bi-dimensional array
and to return “var[layer0][layer1]”;</p>
<p>For 3 layers, this macro is similar to allocate a tri-dimensional array
and to return “var[layer0][layer1][layer2]”;</p>
<dl class="type">
<dt id="c.rank_info">
struct <code class="descname">rank_info</code><a class="headerlink" href="#c.rank_info" title="Permalink to this definition">¶</a></dt>
<dd><p>contains the information for one DIMM rank</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct rank_info {
  int chan_idx;
  struct csrow_info * csrow;
  struct dimm_info * dimm;
  u32 ce_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">chan_idx</span></code></dt>
<dd>channel number where the rank is (typically, 0 or 1)</dd>
<dt><code class="docutils literal"><span class="pre">csrow</span></code></dt>
<dd>A pointer to the chip select row structure (the parent
structure). The location of the rank is given by
the (csrow-&gt;csrow_idx, chan_idx) vector.</dd>
<dt><code class="docutils literal"><span class="pre">dimm</span></code></dt>
<dd>A pointer to the DIMM structure, where the DIMM label
information is stored.</dd>
<dt><code class="docutils literal"><span class="pre">ce_count</span></code></dt>
<dd>number of correctable errors for this rank</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>FIXME: Currently, the EDAC core model will assume one DIMM per rank.</dt>
<dd>This is a bad assumption, but it makes this patch easier. Later
patches in this series will fix this issue.</dd>
</dl>
<dl class="type">
<dt id="c.edac_raw_error_desc">
struct <code class="descname">edac_raw_error_desc</code><a class="headerlink" href="#c.edac_raw_error_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw error report structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct edac_raw_error_desc {
  char location;
  char label;
  long grain;
  u16 error_count;
  int top_layer;
  int mid_layer;
  int low_layer;
  unsigned long page_frame_number;
  unsigned long offset_in_page;
  unsigned long syndrome;
  const char * msg;
  const char * other_detail;
  bool enable_per_layer_report;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">location</span></code></dt>
<dd>location of the error</dd>
<dt><code class="docutils literal"><span class="pre">label</span></code></dt>
<dd>label of the affected DIMM(s)</dd>
<dt><code class="docutils literal"><span class="pre">grain</span></code></dt>
<dd>minimum granularity for an error report, in bytes</dd>
<dt><code class="docutils literal"><span class="pre">error_count</span></code></dt>
<dd>number of errors of the same type</dd>
<dt><code class="docutils literal"><span class="pre">top_layer</span></code></dt>
<dd>top layer of the error (layer[0])</dd>
<dt><code class="docutils literal"><span class="pre">mid_layer</span></code></dt>
<dd>middle layer of the error (layer[1])</dd>
<dt><code class="docutils literal"><span class="pre">low_layer</span></code></dt>
<dd>low layer of the error (layer[2])</dd>
<dt><code class="docutils literal"><span class="pre">page_frame_number</span></code></dt>
<dd>page where the error happened</dd>
<dt><code class="docutils literal"><span class="pre">offset_in_page</span></code></dt>
<dd>page offset</dd>
<dt><code class="docutils literal"><span class="pre">syndrome</span></code></dt>
<dd>syndrome of the error (or 0 if unknown or if
the syndrome is not applicable)</dd>
<dt><code class="docutils literal"><span class="pre">msg</span></code></dt>
<dd>error message</dd>
<dt><code class="docutils literal"><span class="pre">other_detail</span></code></dt>
<dd>other driver-specific detail about the error</dd>
<dt><code class="docutils literal"><span class="pre">enable_per_layer_report</span></code></dt>
<dd>if false, the error affects all layers
(typically, a memory controller error)</dd>
</dl>
<dl class="function">
<dt id="c.edac_mc_alloc">
struct mem_ctl_info * <code class="descname">edac_mc_alloc</code><span class="sig-paren">(</span>unsigned<em>&nbsp;mc_num</em>, unsigned<em>&nbsp;n_layers</em>, struct <a class="reference internal" href="#c.edac_mc_layer" title="edac_mc_layer">edac_mc_layer</a> *<em>&nbsp;layers</em>, unsigned<em>&nbsp;sz_pvt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate and partially fill a struct <code class="xref c c-type docutils literal"><span class="pre">mem_ctl_info</span></code>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">mc_num</span></code></dt>
<dd>Memory controller number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">n_layers</span></code></dt>
<dd>Number of MC hierarchy layers</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_mc_layer</span> <span class="pre">*</span> <span class="pre">layers</span></code></dt>
<dd>Describes each layer as seen by the Memory Controller</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">sz_pvt</span></code></dt>
<dd>size of private storage needed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Everything is kmalloc’ed as one big chunk - more efficient.
Only can be used if all structures have the same lifetime - otherwise
you have to allocate and initialize your own structures.</p>
<p>Use <a class="reference internal" href="#c.edac_mc_free" title="edac_mc_free"><code class="xref c c-func docutils literal"><span class="pre">edac_mc_free()</span></code></a> to free mc structures allocated by this function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">drivers handle multi-rank memories in different ways: in some
drivers, one multi-rank memory stick is mapped as one entry, while, in
others, a single multi-rank memory stick would be mapped into several
entries. Currently, this function will allocate multiple struct dimm_info
on such scenarios, as grouping the multiple ranks require drivers change.</p>
</div>
<p><strong>Return</strong></p>
<blockquote>
<div>On success, return a pointer to struct mem_ctl_info pointer;
<code class="docutils literal"><span class="pre">NULL</span></code> otherwise</div></blockquote>
<dl class="function">
<dt id="c.edac_mc_add_mc_with_groups">
int <code class="descname">edac_mc_add_mc_with_groups</code><span class="sig-paren">(</span>struct mem_ctl_info *<em>&nbsp;mci</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_add_mc_with_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the <strong>mci</strong> structure into the mci global list and create sysfs entries associated with <strong>mci</strong> structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt>
<dd>pointer to the mci structure to be added to the list</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>optional attribute groups for the driver-specific sysfs entries</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div>0 on Success, or an error code on failure</div></blockquote>
<dl class="function">
<dt id="c.edac_mc_free">
void <code class="descname">edac_mc_free</code><span class="sig-paren">(</span>struct mem_ctl_info *<em>&nbsp;mci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Frees a previously allocated <strong>mci</strong> structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt>
<dd>pointer to a struct mem_ctl_info structure</dd>
</dl>
<dl class="function">
<dt id="c.edac_has_mcs">
bool <code class="descname">edac_has_mcs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_has_mcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if any MCs have been allocated.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div>True if MC instances have been registered successfully.
False otherwise.</div></blockquote>
<dl class="function">
<dt id="c.edac_mc_find">
struct mem_ctl_info * <code class="descname">edac_mc_find</code><span class="sig-paren">(</span>int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for a mem_ctl_info structure whose index is <strong>idx</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>index to be seek</dd>
</dl>
<p><strong>Description</strong></p>
<p>If found, return a pointer to the structure.
Else return NULL.</p>
<dl class="function">
<dt id="c.find_mci_by_dev">
struct mem_ctl_info * <code class="descname">find_mci_by_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_mci_by_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan list of controllers looking for the one that manages the <strong>dev</strong> device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to a struct device related with the MCI</dd>
</dl>
<p><strong>Return</strong></p>
<p>on success, returns a pointer to struct <code class="xref c c-type docutils literal"><span class="pre">mem_ctl_info</span></code>;
<code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.edac_mc_del_mc">
struct mem_ctl_info * <code class="descname">edac_mc_del_mc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_del_mc" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove sysfs entries for mci structure associated with <strong>dev</strong> and remove mci structure from global list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">device</span></code></a> representing mci structure to remove.</dd>
</dl>
<p><strong>Return</strong></p>
<p>pointer to removed mci structure, or <code class="docutils literal"><span class="pre">NULL</span></code> if device not found.</p>
<dl class="function">
<dt id="c.edac_mc_find_csrow_by_page">
int <code class="descname">edac_mc_find_csrow_by_page</code><span class="sig-paren">(</span>struct mem_ctl_info *<em>&nbsp;mci</em>, unsigned long<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_find_csrow_by_page" title="Permalink to this definition">¶</a></dt>
<dd><p>Ancillary routine to identify what csrow contains a memory page.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt>
<dd>pointer to a struct mem_ctl_info structure</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page</span></code></dt>
<dd>memory page to find</dd>
</dl>
<p><strong>Return</strong></p>
<p>on success, returns the csrow. -1 if not found.</p>
<dl class="function">
<dt id="c.edac_raw_mc_handle_error">
void <code class="descname">edac_raw_mc_handle_error</code><span class="sig-paren">(</span>const enum <a class="reference internal" href="#c.hw_event_mc_err_type" title="hw_event_mc_err_type">hw_event_mc_err_type</a><em>&nbsp;type</em>, struct mem_ctl_info *<em>&nbsp;mci</em>, struct <a class="reference internal" href="#c.edac_raw_error_desc" title="edac_raw_error_desc">edac_raw_error_desc</a> *<em>&nbsp;e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_raw_mc_handle_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports a memory event to userspace without doing anything to discover the error location.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hw_event_mc_err_type</span> <span class="pre">type</span></code></dt>
<dd>severity of the error (CE/UE/Fatal)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt>
<dd>a struct mem_ctl_info pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_raw_error_desc</span> <span class="pre">*</span> <span class="pre">e</span></code></dt>
<dd>error description</dd>
</dl>
<p><strong>Description</strong></p>
<p>This raw function is used internally by <a class="reference internal" href="#c.edac_mc_handle_error" title="edac_mc_handle_error"><code class="xref c c-func docutils literal"><span class="pre">edac_mc_handle_error()</span></code></a>. It should
only be called directly when the hardware error come directly from BIOS,
like in the case of APEI GHES driver.</p>
<dl class="function">
<dt id="c.edac_mc_handle_error">
void <code class="descname">edac_mc_handle_error</code><span class="sig-paren">(</span>const enum <a class="reference internal" href="#c.hw_event_mc_err_type" title="hw_event_mc_err_type">hw_event_mc_err_type</a><em>&nbsp;type</em>, struct mem_ctl_info *<em>&nbsp;mci</em>, const u16<em>&nbsp;error_count</em>, const unsigned long<em>&nbsp;page_frame_number</em>, const unsigned long<em>&nbsp;offset_in_page</em>, const unsigned long<em>&nbsp;syndrome</em>, const int<em>&nbsp;top_layer</em>, const int<em>&nbsp;mid_layer</em>, const int<em>&nbsp;low_layer</em>, const char *<em>&nbsp;msg</em>, const char *<em>&nbsp;other_detail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_mc_handle_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports a memory event to userspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hw_event_mc_err_type</span> <span class="pre">type</span></code></dt>
<dd>severity of the error (CE/UE/Fatal)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mem_ctl_info</span> <span class="pre">*</span> <span class="pre">mci</span></code></dt>
<dd>a struct mem_ctl_info pointer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">error_count</span></code></dt>
<dd>Number of errors of the same type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_frame_number</span></code></dt>
<dd>mem page where the error occurred</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">offset_in_page</span></code></dt>
<dd>offset of the error inside the page</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">syndrome</span></code></dt>
<dd>ECC syndrome</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">top_layer</span></code></dt>
<dd>Memory layer[0] position</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">mid_layer</span></code></dt>
<dd>Memory layer[1] position</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">low_layer</span></code></dt>
<dd>Memory layer[2] position</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>Message meaningful to the end users that
explains the event</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">other_detail</span></code></dt>
<dd>Technical details about the event that
may help hardware manufacturers and
EDAC developers to analyse the event</dd>
</dl>
</div>
<div class="section" id="pci-controllers">
<h2>PCI Controllers<a class="headerlink" href="#pci-controllers" title="Permalink to this headline">¶</a></h2>
<p>The EDAC subsystem provides a mechanism to handle PCI controllers by calling
the <a class="reference internal" href="#c.edac_pci_alloc_ctl_info" title="edac_pci_alloc_ctl_info"><code class="xref c c-func docutils literal"><span class="pre">edac_pci_alloc_ctl_info()</span></code></a>. It will use the struct
<code class="xref c c-type docutils literal"><span class="pre">edac_pci_ctl_info</span></code> to describe the PCI controllers.</p>
<dl class="function">
<dt id="c.edac_pci_alloc_ctl_info">
struct edac_pci_ctl_info * <code class="descname">edac_pci_alloc_ctl_info</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;sz_pvt</em>, const char *<em>&nbsp;edac_pci_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_alloc_ctl_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz_pvt</span></code></dt>
<dd>size of the private info at struct <code class="xref c c-type docutils literal"><span class="pre">edac_pci_ctl_info</span></code></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">edac_pci_name</span></code></dt>
<dd>name of the PCI device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The <code class="xref c c-func docutils literal"><span class="pre">alloc()</span></code> function for the ‘edac_pci’ control info
structure.</div></blockquote>
<p>The chip driver will allocate one of these for each
edac_pci it is going to control/register with the EDAC CORE.</p>
<p><strong>Return</strong></p>
<p>a pointer to struct <code class="xref c c-type docutils literal"><span class="pre">edac_pci_ctl_info</span></code> on success; <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.edac_pci_free_ctl_info">
void <code class="descname">edac_pci_free_ctl_info</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em>&nbsp;pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_free_ctl_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt>
<dd>pointer to struct <code class="xref c c-type docutils literal"><span class="pre">edac_pci_ctl_info</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Last action on the pci control structure.</div></blockquote>
<p>Calls the remove sysfs information, which will unregister
this control struct’s kobj. When that kobj’s ref count
goes to zero, its release function will be call and then
<a class="reference internal" href="../core-api/kernel-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a> the memory.</p>
<dl class="function">
<dt id="c.edac_pci_alloc_index">
int <code class="descname">edac_pci_alloc_index</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_alloc_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div>allocated index number</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_add_device">
int <code class="descname">edac_pci_add_device</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em>&nbsp;pci</em>, int<em>&nbsp;edac_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_add_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt>
<dd>pointer to the edac_device structure to be added to the list</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">edac_idx</span></code></dt>
<dd>A unique numeric identifier to be assigned to the
‘edac_pci’ structure.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>edac_pci global list and create sysfs entries associated with
edac_pci structure.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>0 on Success, or an error code on failure</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_del_device">
struct edac_pci_ctl_info * <code class="descname">edac_pci_del_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_del_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Pointer to ‘struct device’ representing edac_pci structure
to remove</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove sysfs entries for specified edac_pci structure and
then remove edac_pci structure from global list</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to removed edac_pci structure,
or <code class="docutils literal"><span class="pre">NULL</span></code> if device not found</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_create_generic_ctl">
struct edac_pci_ctl_info * <code class="descname">edac_pci_create_generic_ctl</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;mod_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_create_generic_ctl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">device</span></code></a>;</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">mod_name</span></code></dt>
<dd>name of the PCI device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>A generic constructor for a PCI parity polling device
Some systems have more than one domain of PCI busses.
For systems with one domain, then this API will
provide for a generic poller.</div></blockquote>
<p>This routine calls the <a class="reference internal" href="#c.edac_pci_alloc_ctl_info" title="edac_pci_alloc_ctl_info"><code class="xref c c-func docutils literal"><span class="pre">edac_pci_alloc_ctl_info()</span></code></a> for
the generic device, with default values</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Pointer to struct <code class="xref c c-type docutils literal"><span class="pre">edac_pci_ctl_info</span></code> on success, <code class="docutils literal"><span class="pre">NULL</span></code> on</dt>
<dd>failure.</dd>
</dl>
<dl class="function">
<dt id="c.edac_pci_release_generic_ctl">
void <code class="descname">edac_pci_release_generic_ctl</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em>&nbsp;pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_release_generic_ctl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt>
<dd>pointer to struct <code class="xref c c-type docutils literal"><span class="pre">edac_pci_ctl_info</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The release function of a generic EDAC PCI polling device</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_create_sysfs">
int <code class="descname">edac_pci_create_sysfs</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em>&nbsp;pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_create_sysfs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt>
<dd>pointer to struct <code class="xref c c-type docutils literal"><span class="pre">edac_pci_ctl_info</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Create the controls/attributes for the specified EDAC PCI device</div></blockquote>
<dl class="function">
<dt id="c.edac_pci_remove_sysfs">
void <code class="descname">edac_pci_remove_sysfs</code><span class="sig-paren">(</span>struct edac_pci_ctl_info *<em>&nbsp;pci</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_pci_remove_sysfs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_pci_ctl_info</span> <span class="pre">*</span> <span class="pre">pci</span></code></dt>
<dd>pointer to struct <code class="xref c c-type docutils literal"><span class="pre">edac_pci_ctl_info</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>remove the controls and attributes for this EDAC PCI device</div></blockquote>
</div>
<div class="section" id="edac-blocks">
<h2>EDAC Blocks<a class="headerlink" href="#edac-blocks" title="Permalink to this headline">¶</a></h2>
<p>The EDAC subsystem also provides a generic mechanism to report errors on
other parts of the hardware via <code class="xref c c-func docutils literal"><span class="pre">edac_device_alloc_ctl_info()</span></code> function.</p>
<p>The structures <code class="xref c c-type docutils literal"><span class="pre">edac_dev_sysfs_block_attribute</span></code>,
<code class="xref c c-type docutils literal"><span class="pre">edac_device_block</span></code>, <code class="xref c c-type docutils literal"><span class="pre">edac_device_instance</span></code> and
<code class="xref c c-type docutils literal"><span class="pre">edac_device_ctl_info</span></code> provide a generic or abstract ‘edac_device’
representation at sysfs.</p>
<p>This set of structures and the code that implements the APIs for the same, provide for registering EDAC type devices which are NOT standard memory or
PCI, like:</p>
<ul class="simple">
<li>CPU caches (L1 and L2)</li>
<li>DMA engines</li>
<li>Core CPU switches</li>
<li>Fabric switch units</li>
<li>PCIe interface controllers</li>
<li>other EDAC/ECC type devices that can be monitored for
errors, etc.</li>
</ul>
<p>It allows for a 2 level set of hierarchy.</p>
<p>For example, a cache could be composed of L1, L2 and L3 levels of cache.
Each CPU core would have its own L1 cache, while sharing L2 and maybe L3
caches. On such case, those can be represented via the following sysfs
nodes:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/sys/devices/system/edac/..

pci/            &lt;existing pci directory (if available)&gt;
mc/             &lt;existing memory device directory&gt;
cpu/cpu0/..     &lt;L1 and L2 block directory&gt;
        /L1-cache/ce_count
                 /ue_count
        /L2-cache/ce_count
                 /ue_count
cpu/cpu1/..     &lt;L1 and L2 block directory&gt;
        /L1-cache/ce_count
                 /ue_count
        /L2-cache/ce_count
                 /ue_count
...

the L1 and L2 directories would be &quot;edac_device_block&#39;s&quot;
</pre></div>
</div>
<dl class="function">
<dt id="c.edac_device_add_device">
int <code class="descname">edac_device_add_device</code><span class="sig-paren">(</span>struct edac_device_ctl_info *<em>&nbsp;edac_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_add_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*</span> <span class="pre">edac_dev</span></code></dt>
<dd>pointer to edac_device structure to be added to the list
‘edac_device’ structure.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>edac_device global list and create sysfs entries associated with
edac_device structure.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>0 on Success, or an error code on failure</div></blockquote>
<dl class="function">
<dt id="c.edac_device_del_device">
struct edac_device_ctl_info * <code class="descname">edac_device_del_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_del_device" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Pointer to struct <a class="reference internal" href="infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">device</span></code></a> representing the edac device
structure to remove.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove sysfs entries for specified edac_device structure and
then remove edac_device structure from global list</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to removed edac_device structure,
or <code class="docutils literal"><span class="pre">NULL</span></code> if device not found.</div></blockquote>
<dl class="function">
<dt id="c.edac_device_handle_ue">
void <code class="descname">edac_device_handle_ue</code><span class="sig-paren">(</span>struct edac_device_ctl_info *<em>&nbsp;edac_dev</em>, int<em>&nbsp;inst_nr</em>, int<em>&nbsp;block_nr</em>, const char *<em>&nbsp;msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*</span> <span class="pre">edac_dev</span></code></dt>
<dd>pointer to struct <code class="xref c c-type docutils literal"><span class="pre">edac_device_ctl_info</span></code></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt>
<dd>number of the instance where the UE error happened</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt>
<dd>number of the block where the UE error happened</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>message to be printed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>perform a common output and handling of an ‘edac_dev’ UE event</div></blockquote>
<dl class="function">
<dt id="c.edac_device_handle_ce">
void <code class="descname">edac_device_handle_ce</code><span class="sig-paren">(</span>struct edac_device_ctl_info *<em>&nbsp;edac_dev</em>, int<em>&nbsp;inst_nr</em>, int<em>&nbsp;block_nr</em>, const char *<em>&nbsp;msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_handle_ce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">edac_device_ctl_info</span> <span class="pre">*</span> <span class="pre">edac_dev</span></code></dt>
<dd>pointer to struct <code class="xref c c-type docutils literal"><span class="pre">edac_device_ctl_info</span></code></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">inst_nr</span></code></dt>
<dd>number of the instance where the CE error happened</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">block_nr</span></code></dt>
<dd>number of the block where the CE error happened</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>message to be printed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>perform a common output and handling of an ‘edac_dev’ CE event</div></blockquote>
<dl class="function">
<dt id="c.edac_device_alloc_index">
int <code class="descname">edac_device_alloc_index</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.edac_device_alloc_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div>allocated index number</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="scsi.html" class="btn btn-neutral float-right" title="SCSI Interfaces Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hsi.html" class="btn btn-neutral" title="High Speed Synchronous Serial Interface (HSI)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>