

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Serial Peripheral Interface (SPI) &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="I2C and SMBus Subsystem" href="i2c.html" />
    <link rel="prev" title="PCI Support Library" href="pci.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>Serial Peripheral Interface (SPI)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/spi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="serial-peripheral-interface-spi">
<h1>Serial Peripheral Interface (SPI)<a class="headerlink" href="#serial-peripheral-interface-spi" title="Permalink to this headline">¶</a></h1>
<p>SPI is the “Serial Peripheral Interface”, widely used with embedded
systems because it is a simple and efficient interface: basically a
multiplexed shift register. Its three signal wires hold a clock (SCK,
often in the range of 1-20 MHz), a “Master Out, Slave In” (MOSI) data
line, and a “Master In, Slave Out” (MISO) data line. SPI is a full
duplex protocol; for each bit shifted out the MOSI line (one per clock)
another is shifted in on the MISO line. Those bits are assembled into
words of various sizes on the way to and from system memory. An
additional chipselect line is usually active-low (nCS); four signals are
normally used for each peripheral, plus sometimes an interrupt.</p>
<p>The SPI bus facilities listed here provide a generalized interface to
declare SPI busses and devices, manage them according to the standard
Linux driver model, and perform input/output operations. At this time,
only “master” side interfaces are supported, where Linux talks to SPI
peripherals and does not implement such a peripheral itself. (Interfaces
to support implementing SPI slaves would necessarily look different.)</p>
<p>The programming interface is structured around two kinds of driver, and
two kinds of device. A “Controller Driver” abstracts the controller
hardware, which may be as simple as a set of GPIO pins or as complex as
a pair of FIFOs connected to dual DMA engines on the other side of the
SPI shift register (maximizing throughput). Such drivers bridge between
whatever bus they sit on (often the platform bus) and SPI, and expose
the SPI side of their device as a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">spi_master</span></code>. SPI devices are children of that master,
represented as a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span></code></a> and
manufactured from <a class="reference internal" href="#c.spi_board_info" title="spi_board_info"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">spi_board_info</span></code></a> descriptors which are usually provided by
board-specific initialization code. A <a class="reference internal" href="#c.spi_driver" title="spi_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">spi_driver</span></code></a> is called a “Protocol Driver”, and is bound to a
spi_device using normal driver model calls.</p>
<p>The I/O model is a set of queued messages. Protocol drivers submit one
or more <a class="reference internal" href="#c.spi_message" title="spi_message"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span></code></a> objects,
which are processed and completed asynchronously. (There are synchronous
wrappers, however.) Messages are built from one or more
<a class="reference internal" href="#c.spi_transfer" title="spi_transfer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">spi_transfer</span></code></a> objects, each of
which wraps a full duplex SPI transfer. A variety of protocol tweaking
options are needed, because different chips adopt very different
policies for how they use the bits transferred with SPI.</p>
<dl class="type">
<dt id="c.spi_statistics">
struct <code class="descname">spi_statistics</code><a class="headerlink" href="#c.spi_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>statistics for spi transfers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_statistics {
  spinlock_t lock;
  unsigned long messages;
  unsigned long transfers;
  unsigned long errors;
  unsigned long timedout;
  unsigned long spi_sync;
  unsigned long spi_sync_immediate;
  unsigned long spi_async;
  unsigned long long bytes;
  unsigned long long bytes_rx;
  unsigned long long bytes_tx;
#define SPI_STATISTICS_HISTO_SIZE 17
  unsigned long transfer_bytes_histo;
  unsigned long transfers_split_maxsize;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>lock protecting this structure</dd>
<dt><code class="docutils literal"><span class="pre">messages</span></code></dt>
<dd>number of spi-messages handled</dd>
<dt><code class="docutils literal"><span class="pre">transfers</span></code></dt>
<dd>number of spi_transfers handled</dd>
<dt><code class="docutils literal"><span class="pre">errors</span></code></dt>
<dd>number of errors during spi_transfer</dd>
<dt><code class="docutils literal"><span class="pre">timedout</span></code></dt>
<dd>number of timeouts during spi_transfer</dd>
<dt><code class="docutils literal"><span class="pre">spi_sync</span></code></dt>
<dd>number of times spi_sync is used</dd>
<dt><code class="docutils literal"><span class="pre">spi_sync_immediate</span></code></dt>
<dd>number of times spi_sync is executed immediately
in calling context without queuing and scheduling</dd>
<dt><code class="docutils literal"><span class="pre">spi_async</span></code></dt>
<dd>number of times spi_async is used</dd>
<dt><code class="docutils literal"><span class="pre">bytes</span></code></dt>
<dd>number of bytes transferred to/from device</dd>
<dt><code class="docutils literal"><span class="pre">bytes_rx</span></code></dt>
<dd>number of bytes received from device</dd>
<dt><code class="docutils literal"><span class="pre">bytes_tx</span></code></dt>
<dd>number of bytes sent to device</dd>
<dt><code class="docutils literal"><span class="pre">transfer_bytes_histo</span></code></dt>
<dd>transfer bytes histogramm</dd>
<dt><code class="docutils literal"><span class="pre">transfers_split_maxsize</span></code></dt>
<dd>number of transfers that have been split because of
maxsize limit</dd>
</dl>
<dl class="type">
<dt id="c.spi_device">
struct <code class="descname">spi_device</code><a class="headerlink" href="#c.spi_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Controller side proxy for an SPI slave device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_device {
  struct device dev;
  struct spi_controller * controller;
  struct spi_controller * master;
  u32 max_speed_hz;
  u8 chip_select;
  u8 bits_per_word;
  u16 mode;
#define SPI_CPHA      0x01
#define SPI_CPOL      0x02
#define SPI_MODE_0    (0|0
#define SPI_MODE_1    (0|SPI_CPHA
#define SPI_MODE_2    (SPI_CPOL|0
#define SPI_MODE_3    (SPI_CPOL|SPI_CPHA
#define SPI_CS_HIGH   0x04
#define SPI_LSB_FIRST 0x08
#define SPI_3WIRE     0x10
#define SPI_LOOP      0x20
#define SPI_NO_CS     0x40
#define SPI_READY     0x80
#define SPI_TX_DUAL   0x100
#define SPI_TX_QUAD   0x200
#define SPI_RX_DUAL   0x400
#define SPI_RX_QUAD   0x800
  int irq;
  void * controller_state;
  void * controller_data;
  char modalias;
  int cs_gpio;
  struct spi_statistics statistics;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Driver model representation of the device.</dd>
<dt><code class="docutils literal"><span class="pre">controller</span></code></dt>
<dd>SPI controller used with the device.</dd>
<dt><code class="docutils literal"><span class="pre">master</span></code></dt>
<dd>Copy of controller, for backwards compatibility.</dd>
<dt><code class="docutils literal"><span class="pre">max_speed_hz</span></code></dt>
<dd>Maximum clock rate to be used with this chip
(on this board); may be changed by the device’s driver.
The spi_transfer.speed_hz can override this for each transfer.</dd>
<dt><code class="docutils literal"><span class="pre">chip_select</span></code></dt>
<dd>Chipselect, distinguishing chips handled by <strong>controller</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">bits_per_word</span></code></dt>
<dd>Data transfers involve one or more words; word sizes
like eight or 12 bits are common.  In-memory wordsizes are
powers of two bytes (e.g. 20 bit samples use 32 bits).
This may be changed by the device’s driver, or left at the
default (0) indicating protocol words are eight bit bytes.
The spi_transfer.bits_per_word can override this for each transfer.</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>The spi mode defines how data is clocked out and in.
This may be changed by the device’s driver.
The “active low” default for chipselect mode can be overridden
(by specifying SPI_CS_HIGH) as can the “MSB first” default for
each word in a transfer (by specifying SPI_LSB_FIRST).</dd>
<dt><code class="docutils literal"><span class="pre">irq</span></code></dt>
<dd>Negative, or the number passed to <code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> to receive
interrupts from this device.</dd>
<dt><code class="docutils literal"><span class="pre">controller_state</span></code></dt>
<dd>Controller’s runtime state</dd>
<dt><code class="docutils literal"><span class="pre">controller_data</span></code></dt>
<dd>Board-specific definitions for controller, such as
FIFO initialization parameters; from board_info.controller_data</dd>
<dt><code class="docutils literal"><span class="pre">modalias</span></code></dt>
<dd>Name of the driver to use with this device, or an alias
for that name.  This appears in the sysfs “modalias” attribute
for driver coldplugging, and in uevents used for hotplugging</dd>
<dt><code class="docutils literal"><span class="pre">cs_gpio</span></code></dt>
<dd>gpio number of the chipselect line (optional, -ENOENT when
when not using a GPIO line)</dd>
<dt><code class="docutils literal"><span class="pre">statistics</span></code></dt>
<dd>statistics for the spi_device</dd>
</dl>
<p><strong>Description</strong></p>
<p>A <strong>spi_device</strong> is used to interchange data between an SPI slave
(usually a discrete chip) and CPU memory.</p>
<p>In <strong>dev</strong>, the platform_data is used to hold information about this
device that’s meaningful to the device’s protocol driver, but not
to its controller.  One example might be an identifier for a chip
variant with slightly different functionality; another might be
information about how this particular board wires the chip’s pins.</p>
<dl class="type">
<dt id="c.spi_driver">
struct <code class="descname">spi_driver</code><a class="headerlink" href="#c.spi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Host side “protocol” driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_driver {
  const struct spi_device_id * id_table;
  int (* probe) (struct spi_device *spi);
  int (* remove) (struct spi_device *spi);
  void (* shutdown) (struct spi_device *spi);
  struct device_driver driver;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id_table</span></code></dt>
<dd>List of SPI devices supported by this driver</dd>
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>Binds this driver to the spi device.  Drivers can verify
that the device is actually present, and may need to configure
characteristics (such as bits_per_word) which weren’t needed for
the initial configuration done during system setup.</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>Unbinds this driver from the spi device</dd>
<dt><code class="docutils literal"><span class="pre">shutdown</span></code></dt>
<dd>Standard shutdown callback used during system state
transitions such as powerdown/halt and kexec</dd>
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>SPI device drivers should initialize the name and owner
field of this structure.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents the kind of device driver that uses SPI messages to
interact with the hardware at the other end of a SPI link.  It’s called
a “protocol” driver because it works through messages rather than talking
directly to SPI hardware (which is what the underlying SPI controller
driver does to pass those messages).  These protocols are defined in the
specification for the device(s) supported by the driver.</p>
<p>As a rule, those device protocols represent the lowest level interface
supported by a driver, and it will support upper level interfaces too.
Examples of such upper levels include frameworks like MTD, networking,
MMC, RTC, filesystem character device nodes, and hardware monitoring.</p>
<dl class="function">
<dt id="c.spi_unregister_driver">
void <code class="descname">spi_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_driver" title="spi_driver">spi_driver</a> *<em>&nbsp;sdrv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse effect of spi_register_driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_driver</span> <span class="pre">*</span> <span class="pre">sdrv</span></code></dt>
<dd>the driver to unregister</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<dl class="function">
<dt id="c.module_spi_driver">
<code class="descname">module_spi_driver</code><span class="sig-paren">(</span><em>__spi_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_spi_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a SPI driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__spi_driver</span></code></dt>
<dd>spi_driver struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for SPI drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code></a></p>
<dl class="type">
<dt id="c.spi_controller">
struct <code class="descname">spi_controller</code><a class="headerlink" href="#c.spi_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>interface to SPI master or slave controller</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_controller {
  struct device dev;
  struct list_head list;
  s16 bus_num;
  u16 num_chipselect;
  u16 dma_alignment;
  u16 mode_bits;
  u32 bits_per_word_mask;
#define SPI_BPW_MASK(bits
#define SPI_BIT_MASK(bits
#define SPI_BPW_RANGE_MASK(min# max
  u32 min_speed_hz;
  u32 max_speed_hz;
  u16 flags;
#define SPI_CONTROLLER_HALF_DUPLEX    BIT(0
#define SPI_CONTROLLER_NO_RX          BIT(1
#define SPI_CONTROLLER_NO_TX          BIT(2
#define SPI_CONTROLLER_MUST_RX                BIT(3
#define SPI_CONTROLLER_MUST_TX                BIT(4
#define SPI_MASTER_GPIO_SS            BIT(5
#define SPI_MASTER_QUAD_MODE  BIT(6
#define SPI_MASTER_DATA_STRIPE        BIT(7
#define SPI_MASTER_BOTH_CS    BIT(8
#define SPI_MASTER_U_PAGE       BIT(9
  bool slave;
  size_t (* max_transfer_size) (struct spi_device *spi);
  size_t (* max_message_size) (struct spi_device *spi);
  struct mutex io_mutex;
  spinlock_t bus_lock_spinlock;
  struct mutex bus_lock_mutex;
  bool bus_lock_flag;
  int (* setup) (struct spi_device *spi);
  int (* transfer) (struct spi_device *spi, struct spi_message *mesg);
  void (* cleanup) (struct spi_device *spi);
  bool (* can_dma) (struct spi_controller *ctlr,struct spi_device *spi, struct spi_transfer *xfer);
  bool queued;
  struct kthread_worker kworker;
  struct task_struct * kworker_task;
  struct kthread_work pump_messages;
  spinlock_t queue_lock;
  struct list_head queue;
  struct spi_message * cur_msg;
  bool idling;
  bool busy;
  bool running;
  bool rt;
  bool auto_runtime_pm;
  bool cur_msg_prepared;
  bool cur_msg_mapped;
  struct completion xfer_completion;
  size_t max_dma_len;
  int (* prepare_transfer_hardware) (struct spi_controller *ctlr);
  int (* transfer_one_message) (struct spi_controller *ctlr, struct spi_message *mesg);
  int (* unprepare_transfer_hardware) (struct spi_controller *ctlr);
  int (* prepare_message) (struct spi_controller *ctlr, struct spi_message *message);
  int (* unprepare_message) (struct spi_controller *ctlr, struct spi_message *message);
  int (* slave_abort) (struct spi_controller *ctlr);
  int (* spi_flash_read) (struct spi_device *spi, struct spi_flash_read_message *msg);
  bool (* spi_flash_can_dma) (struct spi_device *spi, struct spi_flash_read_message *msg);
  bool (* flash_read_supported) (struct spi_device *spi);
  void (* set_cs) (struct spi_device *spi, bool enable);
  int (* transfer_one) (struct spi_controller *ctlr, struct spi_device *spi, struct spi_transfer *transfer);
  void (* handle_err) (struct spi_controller *ctlr, struct spi_message *message);
  int * cs_gpios;
  struct spi_statistics statistics;
  struct dma_chan * dma_tx;
  struct dma_chan * dma_rx;
  void * dummy_rx;
  void * dummy_tx;
  int (* fw_translate_cs) (struct spi_controller *ctlr, unsigned cs);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>device interface to this driver</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>link with the global spi_controller list</dd>
<dt><code class="docutils literal"><span class="pre">bus_num</span></code></dt>
<dd>board-specific (and often SOC-specific) identifier for a
given SPI controller.</dd>
<dt><code class="docutils literal"><span class="pre">num_chipselect</span></code></dt>
<dd>chipselects are used to distinguish individual
SPI slaves, and are numbered from zero to num_chipselects.
each slave has a chipselect signal, but it’s common that not
every chipselect is connected to a slave.</dd>
<dt><code class="docutils literal"><span class="pre">dma_alignment</span></code></dt>
<dd>SPI controller constraint on DMA buffers alignment.</dd>
<dt><code class="docutils literal"><span class="pre">mode_bits</span></code></dt>
<dd>flags understood by this controller driver</dd>
<dt><code class="docutils literal"><span class="pre">bits_per_word_mask</span></code></dt>
<dd>A mask indicating which values of bits_per_word are
supported by the driver. Bit n indicates that a bits_per_word n+1 is
supported. If set, the SPI core will reject any transfer with an
unsupported bits_per_word. If not set, this value is simply ignored,
and it’s up to the individual driver to perform any validation.</dd>
<dt><code class="docutils literal"><span class="pre">min_speed_hz</span></code></dt>
<dd>Lowest supported transfer speed</dd>
<dt><code class="docutils literal"><span class="pre">max_speed_hz</span></code></dt>
<dd>Highest supported transfer speed</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>other constraints relevant to this driver</dd>
<dt><code class="docutils literal"><span class="pre">slave</span></code></dt>
<dd>indicates that this is an SPI slave controller</dd>
<dt><code class="docutils literal"><span class="pre">max_transfer_size</span></code></dt>
<dd>function that returns the max transfer size for
a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal"><span class="pre">spi_device</span></code></a>; may be <code class="docutils literal"><span class="pre">NULL</span></code>, so the default <code class="docutils literal"><span class="pre">SIZE_MAX</span></code> will be used.</dd>
<dt><code class="docutils literal"><span class="pre">max_message_size</span></code></dt>
<dd>function that returns the max message size for
a <a class="reference internal" href="#c.spi_device" title="spi_device"><code class="xref c c-type docutils literal"><span class="pre">spi_device</span></code></a>; may be <code class="docutils literal"><span class="pre">NULL</span></code>, so the default <code class="docutils literal"><span class="pre">SIZE_MAX</span></code> will be used.</dd>
<dt><code class="docutils literal"><span class="pre">io_mutex</span></code></dt>
<dd>mutex for physical bus access</dd>
<dt><code class="docutils literal"><span class="pre">bus_lock_spinlock</span></code></dt>
<dd>spinlock for SPI bus locking</dd>
<dt><code class="docutils literal"><span class="pre">bus_lock_mutex</span></code></dt>
<dd>mutex for exclusion of multiple callers</dd>
<dt><code class="docutils literal"><span class="pre">bus_lock_flag</span></code></dt>
<dd>indicates that the SPI bus is locked for exclusive use</dd>
<dt><code class="docutils literal"><span class="pre">setup</span></code></dt>
<dd>updates the device mode and clocking records used by a
device’s SPI controller; protocol code may call this.  This
must fail if an unrecognized or unsupported mode is requested.
It’s always safe to call this unless transfers are pending on
the device whose settings are being modified.</dd>
<dt><code class="docutils literal"><span class="pre">transfer</span></code></dt>
<dd>adds a message to the controller’s transfer queue.</dd>
<dt><code class="docutils literal"><span class="pre">cleanup</span></code></dt>
<dd>frees controller-specific state</dd>
<dt><code class="docutils literal"><span class="pre">can_dma</span></code></dt>
<dd>determine whether this controller supports DMA</dd>
<dt><code class="docutils literal"><span class="pre">queued</span></code></dt>
<dd>whether this controller is providing an internal message queue</dd>
<dt><code class="docutils literal"><span class="pre">kworker</span></code></dt>
<dd>thread struct for message pump</dd>
<dt><code class="docutils literal"><span class="pre">kworker_task</span></code></dt>
<dd>pointer to task for message pump kworker thread</dd>
<dt><code class="docutils literal"><span class="pre">pump_messages</span></code></dt>
<dd>work struct for scheduling work to the message pump</dd>
<dt><code class="docutils literal"><span class="pre">queue_lock</span></code></dt>
<dd>spinlock to syncronise access to message queue</dd>
<dt><code class="docutils literal"><span class="pre">queue</span></code></dt>
<dd>message queue</dd>
<dt><code class="docutils literal"><span class="pre">cur_msg</span></code></dt>
<dd>the currently in-flight message</dd>
<dt><code class="docutils literal"><span class="pre">idling</span></code></dt>
<dd>the device is entering idle state</dd>
<dt><code class="docutils literal"><span class="pre">busy</span></code></dt>
<dd>message pump is busy</dd>
<dt><code class="docutils literal"><span class="pre">running</span></code></dt>
<dd>message pump is running</dd>
<dt><code class="docutils literal"><span class="pre">rt</span></code></dt>
<dd>whether this queue is set to run as a realtime task</dd>
<dt><code class="docutils literal"><span class="pre">auto_runtime_pm</span></code></dt>
<dd>the core should ensure a runtime PM reference is held
while the hardware is prepared, using the parent
device for the spidev</dd>
<dt><code class="docutils literal"><span class="pre">cur_msg_prepared</span></code></dt>
<dd>spi_prepare_message was called for the currently
in-flight message</dd>
<dt><code class="docutils literal"><span class="pre">cur_msg_mapped</span></code></dt>
<dd>message has been mapped for DMA</dd>
<dt><code class="docutils literal"><span class="pre">xfer_completion</span></code></dt>
<dd>used by core <code class="xref c c-func docutils literal"><span class="pre">transfer_one_message()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">max_dma_len</span></code></dt>
<dd>Maximum length of a DMA transfer for the device.</dd>
<dt><code class="docutils literal"><span class="pre">prepare_transfer_hardware</span></code></dt>
<dd>a message will soon arrive from the queue
so the subsystem requests the driver to prepare the transfer hardware
by issuing this call</dd>
<dt><code class="docutils literal"><span class="pre">transfer_one_message</span></code></dt>
<dd>the subsystem calls the driver to transfer a single
message while queuing transfers that arrive in the meantime. When the
driver is finished with this message, it must call
<a class="reference internal" href="#c.spi_finalize_current_message" title="spi_finalize_current_message"><code class="xref c c-func docutils literal"><span class="pre">spi_finalize_current_message()</span></code></a> so the subsystem can issue the next
message</dd>
<dt><code class="docutils literal"><span class="pre">unprepare_transfer_hardware</span></code></dt>
<dd>there are currently no more messages on the
queue so the subsystem notifies the driver that it may relax the
hardware by issuing this call</dd>
<dt><code class="docutils literal"><span class="pre">prepare_message</span></code></dt>
<dd>set up the controller to transfer a single message,
for example doing DMA mapping.  Called from threaded
context.</dd>
<dt><code class="docutils literal"><span class="pre">unprepare_message</span></code></dt>
<dd>undo any work done by <code class="xref c c-func docutils literal"><span class="pre">prepare_message()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">slave_abort</span></code></dt>
<dd>abort the ongoing transfer request on an SPI slave controller</dd>
<dt><code class="docutils literal"><span class="pre">spi_flash_read</span></code></dt>
<dd>to support spi-controller hardwares that provide
accelerated interface to read from flash devices.</dd>
<dt><code class="docutils literal"><span class="pre">spi_flash_can_dma</span></code></dt>
<dd>analogous to <code class="xref c c-func docutils literal"><span class="pre">can_dma()</span></code> interface, but for
controllers implementing spi_flash_read.</dd>
<dt><code class="docutils literal"><span class="pre">flash_read_supported</span></code></dt>
<dd>spi device supports flash read</dd>
<dt><code class="docutils literal"><span class="pre">set_cs</span></code></dt>
<dd>set the logic level of the chip select line.  May be called
from interrupt context.</dd>
<dt><code class="docutils literal"><span class="pre">transfer_one</span></code></dt>
<dd><p class="first">transfer a single spi_transfer.
- return 0 if the transfer is finished,
- return 1 if the transfer is still in progress. When</p>
<blockquote class="last">
<div>the driver is finished with this transfer it must
call <a class="reference internal" href="#c.spi_finalize_current_transfer" title="spi_finalize_current_transfer"><code class="xref c c-func docutils literal"><span class="pre">spi_finalize_current_transfer()</span></code></a> so the subsystem
can issue the next transfer. Note: transfer_one and
transfer_one_message are mutually exclusive; when both
are set, the generic subsystem does not call your
transfer_one callback.</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">handle_err</span></code></dt>
<dd>the subsystem calls the driver to handle an error that occurs
in the generic implementation of <code class="xref c c-func docutils literal"><span class="pre">transfer_one_message()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">cs_gpios</span></code></dt>
<dd>Array of GPIOs to use as chip select lines; one per CS
number. Any individual value may be -ENOENT for CS lines that
are not GPIOs (driven by the SPI controller itself).</dd>
<dt><code class="docutils literal"><span class="pre">statistics</span></code></dt>
<dd>statistics for the spi_controller</dd>
<dt><code class="docutils literal"><span class="pre">dma_tx</span></code></dt>
<dd>DMA transmit channel</dd>
<dt><code class="docutils literal"><span class="pre">dma_rx</span></code></dt>
<dd>DMA receive channel</dd>
<dt><code class="docutils literal"><span class="pre">dummy_rx</span></code></dt>
<dd>dummy receive buffer for full-duplex devices</dd>
<dt><code class="docutils literal"><span class="pre">dummy_tx</span></code></dt>
<dd>dummy transmit buffer for full-duplex devices</dd>
<dt><code class="docutils literal"><span class="pre">fw_translate_cs</span></code></dt>
<dd>If the boot firmware uses different numbering scheme
what Linux expects, this optional hook can be used to translate
between the two.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each SPI controller can communicate with one or more <strong>spi_device</strong>
children.  These make a small bus, sharing MOSI, MISO and SCK signals
but not chip select signals.  Each device may be configured to use a
different clock rate, since those shared signals are ignored unless
the chip is selected.</p>
<p>The driver for an SPI controller manages access to those devices through
a queue of spi_message transactions, copying data between CPU memory and
an SPI slave device.  For each such message it queues, it calls the
message’s completion function when the transaction completes.</p>
<dl class="type">
<dt id="c.spi_res">
struct <code class="descname">spi_res</code><a class="headerlink" href="#c.spi_res" title="Permalink to this definition">¶</a></dt>
<dd><p>spi resource management structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_res {
  struct list_head entry;
  spi_res_release_t release;
  unsigned long long data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">entry</span></code></dt>
<dd>list entry</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>release code called prior to freeing this resource</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>extra data allocated for the specific use-case</dd>
</dl>
<p><strong>Description</strong></p>
<p>this is based on ideas from devres, but focused on life-cycle
management during spi_message processing</p>
<dl class="type">
<dt id="c.spi_transfer">
struct <code class="descname">spi_transfer</code><a class="headerlink" href="#c.spi_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>a read/write buffer pair</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_transfer {
  const void * tx_buf;
  void * rx_buf;
  unsigned len;
  dma_addr_t tx_dma;
  dma_addr_t rx_dma;
  struct sg_table tx_sg;
  struct sg_table rx_sg;
  unsigned cs_change:1;
  unsigned tx_nbits:3;
  unsigned rx_nbits:3;
#define SPI_NBITS_SINGLE      0x01
#define SPI_NBITS_DUAL                0x02
#define SPI_NBITS_QUAD                0x04
  u8 bits_per_word;
  u16 delay_usecs;
  u32 speed_hz;
  u32 dummy;
  struct list_head transfer_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tx_buf</span></code></dt>
<dd>data to be written (dma-safe memory), or NULL</dd>
<dt><code class="docutils literal"><span class="pre">rx_buf</span></code></dt>
<dd>data to be read (dma-safe memory), or NULL</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>size of rx and tx buffers (in bytes)</dd>
<dt><code class="docutils literal"><span class="pre">tx_dma</span></code></dt>
<dd>DMA address of tx_buf, if <strong>spi_message</strong>.is_dma_mapped</dd>
<dt><code class="docutils literal"><span class="pre">rx_dma</span></code></dt>
<dd>DMA address of rx_buf, if <strong>spi_message</strong>.is_dma_mapped</dd>
<dt><code class="docutils literal"><span class="pre">tx_sg</span></code></dt>
<dd>Scatterlist for transmit, currently not for client use</dd>
<dt><code class="docutils literal"><span class="pre">rx_sg</span></code></dt>
<dd>Scatterlist for receive, currently not for client use</dd>
<dt><code class="docutils literal"><span class="pre">cs_change</span></code></dt>
<dd>affects chipselect after this transfer completes</dd>
<dt><code class="docutils literal"><span class="pre">tx_nbits</span></code></dt>
<dd>number of bits used for writing. If 0 the default
(SPI_NBITS_SINGLE) is used.</dd>
<dt><code class="docutils literal"><span class="pre">rx_nbits</span></code></dt>
<dd>number of bits used for reading. If 0 the default
(SPI_NBITS_SINGLE) is used.</dd>
<dt><code class="docutils literal"><span class="pre">bits_per_word</span></code></dt>
<dd>select a bits_per_word other than the device default
for this transfer. If 0 the default (from <strong>spi_device</strong>) is used.</dd>
<dt><code class="docutils literal"><span class="pre">delay_usecs</span></code></dt>
<dd>microseconds to delay after this transfer before
(optionally) changing the chipselect status, then starting
the next transfer or completing this <strong>spi_message</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">speed_hz</span></code></dt>
<dd>Select a speed other than the device default for this
transfer. If 0 the default (from <strong>spi_device</strong>) is used.</dd>
<dt><code class="docutils literal"><span class="pre">dummy</span></code></dt>
<dd>number of dummy cycles.</dd>
<dt><code class="docutils literal"><span class="pre">transfer_list</span></code></dt>
<dd>transfers are sequenced through <strong>spi_message</strong>.transfers</dd>
</dl>
<p><strong>Description</strong></p>
<p>SPI transfers always write the same number of bytes as they read.
Protocol drivers should always provide <strong>rx_buf</strong> and/or <strong>tx_buf</strong>.
In some cases, they may also want to provide DMA addresses for
the data being transferred; that may reduce overhead, when the
underlying driver uses dma.</p>
<p>If the transmit buffer is null, zeroes will be shifted out
while filling <strong>rx_buf</strong>.  If the receive buffer is null, the data
shifted in will be discarded.  Only “len” bytes shift out (or in).
It’s an error to try to shift out a partial word.  (For example, by
shifting out three bytes with word size of sixteen or twenty bits;
the former uses two bytes per word, the latter uses four bytes.)</p>
<p>In-memory data values are always in native CPU byte order, translated
from the wire byte order (big-endian except with SPI_LSB_FIRST).  So
for example when bits_per_word is sixteen, buffers are 2N bytes long
(<strong>len</strong> = 2N) and hold N sixteen bit words in CPU byte order.</p>
<p>When the word size of the SPI transfer is not a power-of-two multiple
of eight bits, those in-memory words include extra bits.  In-memory
words are always seen by protocol drivers as right-justified, so the
undefined (rx) or unused (tx) bits are always the most significant bits.</p>
<p>All SPI transfers start with the relevant chipselect active.  Normally
it stays selected until after the last transfer in a message.  Drivers
can affect the chipselect signal using cs_change.</p>
<p>(i) If the transfer isn’t the last one in the message, this flag is
used to make the chipselect briefly go inactive in the middle of the
message.  Toggling chipselect in this way may be needed to terminate
a chip command, letting a single spi_message perform all of group of
chip transactions together.</p>
<p>(ii) When the transfer is the last one in the message, the chip may
stay selected until the next transfer.  On multi-device SPI busses
with nothing blocking messages going to other devices, this is just
a performance hint; starting a message to another device deselects
this one.  But in other cases, this can be used to ensure correctness.
Some devices need protocol transactions to be built from a series of
spi_message submissions, where the content of one message is determined
by the results of previous messages and where the whole transaction
ends when the chipselect goes intactive.</p>
<p>When SPI can transfer in 1x,2x or 4x. It can get this transfer information
from device through <strong>tx_nbits</strong> and <strong>rx_nbits</strong>. In Bi-direction, these
two should both be set. User can set transfer mode with SPI_NBITS_SINGLE(1x)
SPI_NBITS_DUAL(2x) and SPI_NBITS_QUAD(4x) to support these three transfer.</p>
<p>The code that submits an spi_message (and its spi_transfers)
to the lower layers is responsible for managing its memory.
Zero-initialize every field you don’t set up explicitly, to
insulate against future API updates.  After you submit a message
and its transfers, ignore them until its completion callback.</p>
<dl class="type">
<dt id="c.spi_message">
struct <code class="descname">spi_message</code><a class="headerlink" href="#c.spi_message" title="Permalink to this definition">¶</a></dt>
<dd><p>one multi-segment SPI transaction</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_message {
  struct list_head transfers;
  struct spi_device * spi;
  unsigned is_dma_mapped:1;
  void (* complete) (void *context);
  void * context;
  unsigned frame_length;
  unsigned actual_length;
  int status;
  struct list_head queue;
  void * state;
  struct list_head resources;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">transfers</span></code></dt>
<dd>list of transfer segments in this transaction</dd>
<dt><code class="docutils literal"><span class="pre">spi</span></code></dt>
<dd>SPI device to which the transaction is queued</dd>
<dt><code class="docutils literal"><span class="pre">is_dma_mapped</span></code></dt>
<dd>if true, the caller provided both dma and cpu virtual
addresses for each transfer buffer</dd>
<dt><code class="docutils literal"><span class="pre">complete</span></code></dt>
<dd>called to report transaction completions</dd>
<dt><code class="docutils literal"><span class="pre">context</span></code></dt>
<dd>the argument to <code class="xref c c-func docutils literal"><span class="pre">complete()</span></code> when it’s called</dd>
<dt><code class="docutils literal"><span class="pre">frame_length</span></code></dt>
<dd>the total number of bytes in the message</dd>
<dt><code class="docutils literal"><span class="pre">actual_length</span></code></dt>
<dd>the total number of bytes that were transferred in all
successful segments</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>zero for success, else negative errno</dd>
<dt><code class="docutils literal"><span class="pre">queue</span></code></dt>
<dd>for use by whichever driver currently owns the message</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>for use by whichever driver currently owns the message</dd>
<dt><code class="docutils literal"><span class="pre">resources</span></code></dt>
<dd>for resource management when the spi message is processed</dd>
</dl>
<p><strong>Description</strong></p>
<p>A <strong>spi_message</strong> is used to execute an atomic sequence of data transfers,
each represented by a struct spi_transfer.  The sequence is “atomic”
in the sense that no other spi_message may use that SPI bus until that
sequence completes.  On some systems, many such sequences can execute as
as single programmed DMA transfer.  On all systems, these messages are
queued, and might complete after transactions to other devices.  Messages
sent to a given spi_device are always executed in FIFO order.</p>
<p>The code that submits an spi_message (and its spi_transfers)
to the lower layers is responsible for managing its memory.
Zero-initialize every field you don’t set up explicitly, to
insulate against future API updates.  After you submit a message
and its transfers, ignore them until its completion callback.</p>
<dl class="function">
<dt id="c.spi_message_init_with_transfers">
void <code class="descname">spi_message_init_with_transfers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;m</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a> *<em>&nbsp;xfers</em>, unsigned int<em>&nbsp;num_xfers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_message_init_with_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize spi_message and append transfers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">m</span></code></dt>
<dd>spi_message to be initialized</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*</span> <span class="pre">xfers</span></code></dt>
<dd>An array of spi transfers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_xfers</span></code></dt>
<dd>Number of items in the xfer array</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes the given spi_message and adds each spi_transfer in
the given array to the message.</p>
<dl class="type">
<dt id="c.spi_replaced_transfers">
struct <code class="descname">spi_replaced_transfers</code><a class="headerlink" href="#c.spi_replaced_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>structure describing the spi_transfer replacements that have occurred so that they can get reverted</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_replaced_transfers {
  spi_replaced_release_t release;
  void * extradata;
  struct list_head replaced_transfers;
  struct list_head * replaced_after;
  size_t inserted;
  struct spi_transfer inserted_transfers;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>some extra release code to get executed prior to
relasing this structure</dd>
<dt><code class="docutils literal"><span class="pre">extradata</span></code></dt>
<dd>pointer to some extra data if requested or NULL</dd>
<dt><code class="docutils literal"><span class="pre">replaced_transfers</span></code></dt>
<dd>transfers that have been replaced and which need
to get restored</dd>
<dt><code class="docutils literal"><span class="pre">replaced_after</span></code></dt>
<dd>the transfer after which the <strong>replaced_transfers</strong>
are to get re-inserted</dd>
<dt><code class="docutils literal"><span class="pre">inserted</span></code></dt>
<dd>number of transfers inserted</dd>
<dt><code class="docutils literal"><span class="pre">inserted_transfers</span></code></dt>
<dd>array of spi_transfers of array-size <strong>inserted</strong>,
that have been replacing replaced_transfers</dd>
</dl>
<p><strong>note</strong></p>
<p>that <strong>extradata</strong> will point to <strong>inserted_transfers**[**inserted</strong>]
if some extra allocation is requested, so alignment will be the same
as for spi_transfers</p>
<dl class="function">
<dt id="c.spi_sync_transfer">
int <code class="descname">spi_sync_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a> *<em>&nbsp;xfers</em>, unsigned int<em>&nbsp;num_xfers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronous SPI data transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*</span> <span class="pre">xfers</span></code></dt>
<dd>An array of spi_transfers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_xfers</span></code></dt>
<dd>Number of items in the xfer array</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Does a synchronous SPI data transfer of the given spi_transfer array.</p>
<p>For more specific semantics see <a class="reference internal" href="#c.spi_sync" title="spi_sync"><code class="xref c c-func docutils literal"><span class="pre">spi_sync()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Return: zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_write">
int <code class="descname">spi_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, const void *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_write" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device to which data will be written</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>data buffer size</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function writes the buffer <strong>buf</strong>.
Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_read">
int <code class="descname">spi_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_read" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device from which data will be read</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>data buffer size</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function reads the buffer <strong>buf</strong>.
Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_w8r8">
ssize_t <code class="descname">spi_w8r8</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, u8<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r8" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 8 bit read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt>
<dd>command to be written before data is read back</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) eight bit number returned by the
device, or else a negative error code.</p>
<dl class="function">
<dt id="c.spi_w8r16">
ssize_t <code class="descname">spi_w8r16</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, u8<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r16" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 16 bit read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt>
<dd>command to be written before data is read back</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>The number is returned in wire-order, which is at least sometimes
big-endian.</p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) sixteen bit number returned by the
device, or else a negative error code.</p>
<dl class="function">
<dt id="c.spi_w8r16be">
ssize_t <code class="descname">spi_w8r16be</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, u8<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_w8r16be" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous 8 bit write followed by 16 bit big-endian read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">cmd</span></code></dt>
<dd>command to be written before data is read back</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This function is similar to spi_w8r16, with the exception that it will
convert the read 16 bit data word from big-endian to native endianness.</p>
<p>Callable only from contexts that can sleep.</p>
<p><strong>Return</strong></p>
<p>the (unsigned) sixteen bit number returned by the device in cpu
endianness, or else a negative error code.</p>
<dl class="type">
<dt id="c.spi_flash_read_message">
struct <code class="descname">spi_flash_read_message</code><a class="headerlink" href="#c.spi_flash_read_message" title="Permalink to this definition">¶</a></dt>
<dd><p>flash specific information for spi-masters that provide accelerated flash read interfaces</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_flash_read_message {
  void * buf;
  loff_t from;
  size_t len;
  size_t retlen;
  u8 read_opcode;
  u8 addr_width;
  u8 dummy_bytes;
  u8 opcode_nbits;
  u8 addr_nbits;
  u8 data_nbits;
  struct sg_table rx_sg;
  bool cur_msg_mapped;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>buffer to read data</dd>
<dt><code class="docutils literal"><span class="pre">from</span></code></dt>
<dd>offset within the flash from where data is to be read</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>length of data to be read</dd>
<dt><code class="docutils literal"><span class="pre">retlen</span></code></dt>
<dd>actual length of data read</dd>
<dt><code class="docutils literal"><span class="pre">read_opcode</span></code></dt>
<dd>read_opcode to be used to communicate with flash</dd>
<dt><code class="docutils literal"><span class="pre">addr_width</span></code></dt>
<dd>number of address bytes</dd>
<dt><code class="docutils literal"><span class="pre">dummy_bytes</span></code></dt>
<dd>number of dummy bytes</dd>
<dt><code class="docutils literal"><span class="pre">opcode_nbits</span></code></dt>
<dd>number of lines to send opcode</dd>
<dt><code class="docutils literal"><span class="pre">addr_nbits</span></code></dt>
<dd>number of lines to send address</dd>
<dt><code class="docutils literal"><span class="pre">data_nbits</span></code></dt>
<dd>number of lines for data</dd>
<dt><code class="docutils literal"><span class="pre">rx_sg</span></code></dt>
<dd>Scatterlist for receive data read from flash</dd>
<dt><code class="docutils literal"><span class="pre">cur_msg_mapped</span></code></dt>
<dd>message has been mapped for DMA</dd>
</dl>
<dl class="type">
<dt id="c.spi_board_info">
struct <code class="descname">spi_board_info</code><a class="headerlink" href="#c.spi_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>board-specific template for a SPI device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct spi_board_info {
  char modalias;
  const void * platform_data;
  const struct property_entry * properties;
  void * controller_data;
  int irq;
  u32 max_speed_hz;
  u16 bus_num;
  u16 chip_select;
  u16 mode;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">modalias</span></code></dt>
<dd>Initializes spi_device.modalias; identifies the driver.</dd>
<dt><code class="docutils literal"><span class="pre">platform_data</span></code></dt>
<dd>Initializes spi_device.platform_data; the particular
data stored there is driver-specific.</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>Additional device properties for the device.</dd>
<dt><code class="docutils literal"><span class="pre">controller_data</span></code></dt>
<dd>Initializes spi_device.controller_data; some
controllers need hints about hardware setup, e.g. for DMA.</dd>
<dt><code class="docutils literal"><span class="pre">irq</span></code></dt>
<dd>Initializes spi_device.irq; depends on how the board is wired.</dd>
<dt><code class="docutils literal"><span class="pre">max_speed_hz</span></code></dt>
<dd>Initializes spi_device.max_speed_hz; based on limits
from the chip datasheet and board-specific signal quality issues.</dd>
<dt><code class="docutils literal"><span class="pre">bus_num</span></code></dt>
<dd>Identifies which spi_controller parents the spi_device; unused
by <a class="reference internal" href="#c.spi_new_device" title="spi_new_device"><code class="xref c c-func docutils literal"><span class="pre">spi_new_device()</span></code></a>, and otherwise depends on board wiring.</dd>
<dt><code class="docutils literal"><span class="pre">chip_select</span></code></dt>
<dd>Initializes spi_device.chip_select; depends on how
the board is wired.</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>Initializes spi_device.mode; based on the chip datasheet, board
wiring (some devices support both 3WIRE and standard modes), and
possibly presence of an inverter in the chipselect path.</dd>
</dl>
<p><strong>Description</strong></p>
<p>When adding new SPI devices to the device tree, these structures serve
as a partial device template.  They hold information which can’t always
be determined by drivers.  Information that <code class="xref c c-func docutils literal"><span class="pre">probe()</span></code> can establish (such
as the default transfer wordsize) is not included here.</p>
<p>These structures are used in two places.  Their primary role is to
be stored in tables of board-specific device descriptors, which are
declared early in board initialization and then used (much later) to
populate a controller’s device tree after the that controller’s driver
initializes.  A secondary (and atypical) role is as a parameter to
<a class="reference internal" href="#c.spi_new_device" title="spi_new_device"><code class="xref c c-func docutils literal"><span class="pre">spi_new_device()</span></code></a> call, which happens after those controller drivers
are active in some dynamic board configuration models.</p>
<dl class="function">
<dt id="c.spi_register_board_info">
int <code class="descname">spi_register_board_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_board_info" title="spi_board_info">spi_board_info</a> const *<em>&nbsp;info</em>, unsigned<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_register_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>register SPI devices for a given board</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_board_info</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>array of chip descriptors</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">n</span></code></dt>
<dd>how many descriptors are provided</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Board-specific early init code calls this (probably during arch_initcall)
with segments of the SPI device table.  Any device nodes are created later,
after the relevant parent SPI controller (bus_num) is defined.  We keep
this table of devices forever, so that reloading a controller driver will
not make Linux forget about these hard-wired devices.</p>
<p>Other code can also call this, e.g. a particular add-on board might provide
SPI devices through its expansion connector, so code initializing that board
would naturally declare its SPI devices.</p>
<p>The board info passed can safely be __initdata … but be careful of
any embedded pointers (platform_data, etc), they’re copied as-is.
Device properties are deep-copied though.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.__spi_register_driver">
int <code class="descname">__spi_register_driver</code><span class="sig-paren">(</span>struct module *<em>&nbsp;owner</em>, struct <a class="reference internal" href="#c.spi_driver" title="spi_driver">spi_driver</a> *<em>&nbsp;sdrv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__spi_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>register a SPI driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owner module of the driver to register</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_driver</span> <span class="pre">*</span> <span class="pre">sdrv</span></code></dt>
<dd>the driver to register</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_alloc_device">
struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> * <code class="descname">spi_alloc_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_alloc_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a new SPI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>Controller to which device is connected</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Allows a driver to allocate and initialize a spi_device without
registering it immediately.  This allows a driver to directly
fill the spi_device with device parameters before calling
<a class="reference internal" href="#c.spi_add_device" title="spi_add_device"><code class="xref c c-func docutils literal"><span class="pre">spi_add_device()</span></code></a> on it.</p>
<p>Caller is responsible to call <a class="reference internal" href="#c.spi_add_device" title="spi_add_device"><code class="xref c c-func docutils literal"><span class="pre">spi_add_device()</span></code></a> on the returned
spi_device structure to add it to the SPI controller.  If the caller
needs to discard the spi_device without adding it, then it should
call <code class="xref c c-func docutils literal"><span class="pre">spi_dev_put()</span></code> on it.</p>
<p><strong>Return</strong></p>
<p>a pointer to the new device, or NULL.</p>
<dl class="function">
<dt id="c.spi_add_device">
int <code class="descname">spi_add_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_add_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Add spi_device allocated with spi_alloc_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>spi_device to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Companion function to spi_alloc_device.  Devices allocated with
spi_alloc_device can be added onto the spi bus with this function.</p>
<p><strong>Return</strong></p>
<p>0 on success; negative errno on failure</p>
<dl class="function">
<dt id="c.spi_new_device">
struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> * <code class="descname">spi_new_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em>, struct <a class="reference internal" href="#c.spi_board_info" title="spi_board_info">spi_board_info</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_new_device" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate one new SPI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>Controller to which device is connected</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_board_info</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>Describes the SPI device</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>On typical mainboards, this is purely internal; and it’s not needed
after board init creates the hard-wired devices.  Some development
platforms may not be able to use spi_register_board_info though, and
this is exported so that for example a USB or parport based adapter
driver could add devices (which it would learn about out-of-band).</p>
<p><strong>Return</strong></p>
<p>the new device, or NULL.</p>
<dl class="function">
<dt id="c.spi_unregister_device">
void <code class="descname">spi_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a single SPI device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>spi_device to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start making the passed SPI device vanish. Normally this would be handled
by <a class="reference internal" href="#c.spi_unregister_controller" title="spi_unregister_controller"><code class="xref c c-func docutils literal"><span class="pre">spi_unregister_controller()</span></code></a>.</p>
<dl class="function">
<dt id="c.spi_finalize_current_transfer">
void <code class="descname">spi_finalize_current_transfer</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_finalize_current_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>report completion of a transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the controller reporting completion</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by SPI drivers using the core <code class="xref c c-func docutils literal"><span class="pre">transfer_one_message()</span></code>
implementation to notify it that the current interrupt driven
transfer has finished and the next one may be scheduled.</p>
<dl class="function">
<dt id="c.spi_get_next_queued_message">
struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> * <code class="descname">spi_get_next_queued_message</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_get_next_queued_message" title="Permalink to this definition">¶</a></dt>
<dd><p>called by driver to check for queued messages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the controller to check for queued messages</dd>
</dl>
<p><strong>Description</strong></p>
<p>If there are more messages in the queue, the next message is returned from
this call.</p>
<p><strong>Return</strong></p>
<p>the next message in the queue, else NULL if the queue is empty.</p>
<dl class="function">
<dt id="c.spi_finalize_current_message">
void <code class="descname">spi_finalize_current_message</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_finalize_current_message" title="Permalink to this definition">¶</a></dt>
<dd><p>the current message is complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the controller to return the message to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by the driver to notify the core that the message in the front of the
queue is complete and can be removed from the queue.</p>
<dl class="function">
<dt id="c.spi_slave_abort">
int <code class="descname">spi_slave_abort</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_slave_abort" title="Permalink to this definition">¶</a></dt>
<dd><p>abort the ongoing transfer request on an SPI slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device used for the current transfer</dd>
</dl>
<dl class="function">
<dt id="c.__spi_alloc_controller">
struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> * <code class="descname">__spi_alloc_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;size</em>, bool<em>&nbsp;slave</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__spi_alloc_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an SPI master or slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the controller, possibly using the platform_bus</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>how much zeroed driver-private data to allocate; the pointer to this
memory is in the driver_data field of the returned device,
accessible with <code class="xref c c-func docutils literal"><span class="pre">spi_controller_get_devdata()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">slave</span></code></dt>
<dd>flag indicating whether to allocate an SPI master (false) or SPI
slave (true) controller</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call is used only by SPI controller drivers, which are the
only ones directly touching chip registers.  It’s how they allocate
an spi_controller structure, prior to calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal"><span class="pre">spi_register_controller()</span></code></a>.</p>
<p>This must be called from context that can sleep.</p>
<p>The caller is responsible for assigning the bus number and initializing the
controller’s methods before calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal"><span class="pre">spi_register_controller()</span></code></a>; and (after
errors adding the device) calling <code class="xref c c-func docutils literal"><span class="pre">spi_controller_put()</span></code> to prevent a memory
leak.</p>
<p><strong>Return</strong></p>
<p>the SPI controller structure on success, else NULL.</p>
<dl class="function">
<dt id="c.spi_register_controller">
int <code class="descname">spi_register_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_register_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>register SPI master or slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>initialized master, originally from <code class="xref c c-func docutils literal"><span class="pre">spi_alloc_master()</span></code> or
<code class="xref c c-func docutils literal"><span class="pre">spi_alloc_slave()</span></code></dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>SPI controllers connect to their drivers using some non-SPI bus,
such as the platform bus.  The final stage of <code class="xref c c-func docutils literal"><span class="pre">probe()</span></code> in that code
includes calling <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal"><span class="pre">spi_register_controller()</span></code></a> to hook up to this SPI bus glue.</p>
<p>SPI controllers use board specific (often SOC specific) bus numbers,
and board-specific addressing for SPI devices combines those numbers
with chip select numbers.  Since SPI does not directly support dynamic
device identification, boards need configuration tables telling which
chip is at which address.</p>
<p>This must be called from context that can sleep.  It returns zero on
success, else a negative error code (dropping the controller’s refcount).
After a successful return, the caller is responsible for calling
<a class="reference internal" href="#c.spi_unregister_controller" title="spi_unregister_controller"><code class="xref c c-func docutils literal"><span class="pre">spi_unregister_controller()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.devm_spi_register_controller">
int <code class="descname">devm_spi_register_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_spi_register_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>register managed SPI master or slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device managing SPI controller</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>initialized controller, originally from <code class="xref c c-func docutils literal"><span class="pre">spi_alloc_master()</span></code> or
<code class="xref c c-func docutils literal"><span class="pre">spi_alloc_slave()</span></code></dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Register a SPI device as with <a class="reference internal" href="#c.spi_register_controller" title="spi_register_controller"><code class="xref c c-func docutils literal"><span class="pre">spi_register_controller()</span></code></a> which will
automatically be unregister</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_unregister_controller">
void <code class="descname">spi_unregister_controller</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_unregister_controller" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister SPI master or slave controller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the controller being unregistered</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call is used only by SPI controller drivers, which are the
only ones directly touching chip registers.</p>
<p>This must be called from context that can sleep.</p>
<dl class="function">
<dt id="c.spi_busnum_to_master">
struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> * <code class="descname">spi_busnum_to_master</code><span class="sig-paren">(</span>u16<em>&nbsp;bus_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_busnum_to_master" title="Permalink to this definition">¶</a></dt>
<dd><p>look up master associated with bus_num</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">bus_num</span></code></dt>
<dd>the master’s bus number</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may be used with devices that are registered after
arch init time.  It returns a refcounted pointer to the relevant
spi_controller (which the caller must release), or NULL if there is
no such master registered.</p>
<p><strong>Return</strong></p>
<p>the SPI master structure on success, else NULL.</p>
<dl class="function">
<dt id="c.spi_res_alloc">
void * <code class="descname">spi_res_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, spi_res_release_t<em>&nbsp;release</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_res_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a spi resource that is life-cycle managed during the processing of a spi_message while using spi_transfer_one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>the spi device for which we allocate memory</dd>
<dt><code class="docutils literal"><span class="pre">spi_res_release_t</span> <span class="pre">release</span></code></dt>
<dd>the release code to execute for this resource</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size to alloc and return</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>GFP allocation flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>the pointer to the allocated data</p>
<p>This may get enhanced in the future to allocate from a memory pool
of the <strong>spi_device</strong> or <strong>spi_controller</strong> to avoid repeated allocations.</p>
<dl class="function">
<dt id="c.spi_res_free">
void <code class="descname">spi_res_free</code><span class="sig-paren">(</span>void *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_res_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free an spi resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>pointer to the custom data of a resource</dd>
</dl>
<dl class="function">
<dt id="c.spi_res_add">
void <code class="descname">spi_res_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em>, void *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_res_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a spi_res to the spi_message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>the spi message</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>the spi_resource</dd>
</dl>
<dl class="function">
<dt id="c.spi_res_release">
void <code class="descname">spi_res_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_res_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release all spi resources for this message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the <strong>spi_controller</strong></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>the <strong>spi_message</strong></dd>
</dl>
<dl class="function">
<dt id="c.spi_replace_transfers">
struct <a class="reference internal" href="#c.spi_replaced_transfers" title="spi_replaced_transfers">spi_replaced_transfers</a> * <code class="descname">spi_replace_transfers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;msg</em>, struct <a class="reference internal" href="#c.spi_transfer" title="spi_transfer">spi_transfer</a> *<em>&nbsp;xfer_first</em>, size_t<em>&nbsp;remove</em>, size_t<em>&nbsp;insert</em>, spi_replaced_release_t<em>&nbsp;release</em>, size_t<em>&nbsp;extradatasize</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_replace_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>replace transfers with several transfers and register change with spi_message.resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>the spi_message we work upon</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_transfer</span> <span class="pre">*</span> <span class="pre">xfer_first</span></code></dt>
<dd>the first spi_transfer we want to replace</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">remove</span></code></dt>
<dd>number of transfers to remove</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">insert</span></code></dt>
<dd>the number of transfers we want to insert instead</dd>
<dt><code class="docutils literal"><span class="pre">spi_replaced_release_t</span> <span class="pre">release</span></code></dt>
<dd>extra release code necessary in some circumstances</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">extradatasize</span></code></dt>
<dd>extra data to allocate (with alignment guarantees
of struct <strong>spi_transfer</strong>)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>gfp flags</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>pointer to <strong>spi_replaced_transfers</strong>,</dt>
<dd>PTR_ERR(…) in case of errors.</dd>
</dl>
<dl class="function">
<dt id="c.spi_split_transfers_maxsize">
int <code class="descname">spi_split_transfers_maxsize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;msg</em>, size_t<em>&nbsp;maxsize</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_split_transfers_maxsize" title="Permalink to this definition">¶</a></dt>
<dd><p>split spi transfers into multiple transfers when an individual transfer exceeds a certain size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>the <strong>spi_controller</strong> for this transfer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>the <strong>spi_message</strong> to transform</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">maxsize</span></code></dt>
<dd>the maximum when to apply this</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>GFP allocation flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>status of transformation</p>
<dl class="function">
<dt id="c.spi_setup">
int <code class="descname">spi_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>setup SPI mode and clock rate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>the device whose settings are being modified</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep, and no requests are queued to the device</p>
<p><strong>Description</strong></p>
<p>SPI protocol drivers may need to update the transfer mode if the
device doesn’t work with its default.  They may likewise need
to update clock rates or word sizes from initial values.  This function
changes those settings, and must be called from a context that can sleep.
Except for SPI_CS_HIGH, which takes effect immediately, the changes take
effect the next time the device is selected and data is transferred to
or from it.  When this function returns, the spi device is deselected.</p>
<p>Note that this call will fail if the protocol driver specifies an option
that the underlying controller or its driver does not support.  For
example, not all hardware supports wire transfers using nine bit words,
LSB-first wire encoding, or active-high chipselects.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_async">
int <code class="descname">spi_async</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_async" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous SPI transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>describes the data transfers, including completion callback</dd>
</dl>
<p><strong>Context</strong></p>
<p>any (irqs may be blocked, etc)</p>
<p><strong>Description</strong></p>
<p>This call may be used in_irq and other contexts which can’t sleep,
as well as from task contexts which can sleep.</p>
<p>The completion callback is invoked in a context which can’t sleep.
Before that invocation, the value of message-&gt;status is undefined.
When the callback is issued, message-&gt;status holds either zero (to
indicate complete success) or a negative error code.  After that
callback returns, the driver which issued the transfer request may
deallocate the associated memory; it’s no longer in use by any SPI
core or controller driver code.</p>
<p>Note that although all messages to a spi_device are handled in
FIFO order, messages may go to different devices in other orders.
Some device might be higher priority, or have various “hard” access
time requirements, for example.</p>
<p>On detection of any fault during the transfer, processing of
the entire message is aborted, and the device is deselected.
Until returning from the associated message completion callback,
no other spi_message queued to that device will be processed.
(This rule applies equally to all the synchronous transfer calls,
which are wrappers around this core asynchronous primitive.)</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_async_locked">
int <code class="descname">spi_async_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_async_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>version of spi_async with exclusive bus usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>describes the data transfers, including completion callback</dd>
</dl>
<p><strong>Context</strong></p>
<p>any (irqs may be blocked, etc)</p>
<p><strong>Description</strong></p>
<p>This call may be used in_irq and other contexts which can’t sleep,
as well as from task contexts which can sleep.</p>
<p>The completion callback is invoked in a context which can’t sleep.
Before that invocation, the value of message-&gt;status is undefined.
When the callback is issued, message-&gt;status holds either zero (to
indicate complete success) or a negative error code.  After that
callback returns, the driver which issued the transfer request may
deallocate the associated memory; it’s no longer in use by any SPI
core or controller driver code.</p>
<p>Note that although all messages to a spi_device are handled in
FIFO order, messages may go to different devices in other orders.
Some device might be higher priority, or have various “hard” access
time requirements, for example.</p>
<p>On detection of any fault during the transfer, processing of
the entire message is aborted, and the device is deselected.
Until returning from the associated message completion callback,
no other spi_message queued to that device will be processed.
(This rule applies equally to all the synchronous transfer calls,
which are wrappers around this core asynchronous primitive.)</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_sync">
int <code class="descname">spi_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>blocking/synchronous SPI data transfers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>describes the data transfers</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.  Low-overhead controller
drivers may DMA directly into and out of the message buffers.</p>
<p>Note that the SPI device’s chip select is active during the message,
and then is normally disabled between messages.  Drivers for some
frequently-used devices may want to minimize costs of selecting a chip,
by leaving it selected in anticipation that the next message will go
to the same chip.  (That may increase power usage.)</p>
<p>Also, the caller is guaranteeing that the memory associated with the
message will not be freed before this call returns.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_sync_locked">
int <code class="descname">spi_sync_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, struct <a class="reference internal" href="#c.spi_message" title="spi_message">spi_message</a> *<em>&nbsp;message</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_sync_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>version of spi_sync with exclusive bus usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_message</span> <span class="pre">*</span> <span class="pre">message</span></code></dt>
<dd>describes the data transfers</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.  Low-overhead controller
drivers may DMA directly into and out of the message buffers.</p>
<p>This call should be used by drivers that require exclusive access to the
SPI bus. It has to be preceded by a spi_bus_lock call. The SPI bus must
be released by a spi_bus_unlock call when the exclusive access is over.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
<dl class="function">
<dt id="c.spi_bus_lock">
int <code class="descname">spi_bus_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_bus_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain a lock for exclusive SPI bus usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>SPI bus master that should be locked for exclusive bus access</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.</p>
<p>This call should be used by drivers that require exclusive access to the
SPI bus. The SPI bus must be released by a spi_bus_unlock call when the
exclusive access is over. Data transfer must be done by spi_sync_locked
and spi_async_locked calls when the SPI bus lock is held.</p>
<p><strong>Return</strong></p>
<p>always zero.</p>
<dl class="function">
<dt id="c.spi_bus_unlock">
int <code class="descname">spi_bus_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_controller" title="spi_controller">spi_controller</a> *<em>&nbsp;ctlr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_bus_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the lock for exclusive SPI bus usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_controller</span> <span class="pre">*</span> <span class="pre">ctlr</span></code></dt>
<dd>SPI bus master that was locked for exclusive bus access</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This call may only be used from a context that may sleep.  The sleep
is non-interruptible, and has no timeout.</p>
<p>This call releases an SPI bus lock previously obtained by an spi_bus_lock
call.</p>
<p><strong>Return</strong></p>
<p>always zero.</p>
<dl class="function">
<dt id="c.spi_write_then_read">
int <code class="descname">spi_write_then_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.spi_device" title="spi_device">spi_device</a> *<em>&nbsp;spi</em>, const void *<em>&nbsp;txbuf</em>, unsigned<em>&nbsp;n_tx</em>, void *<em>&nbsp;rxbuf</em>, unsigned<em>&nbsp;n_rx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spi_write_then_read" title="Permalink to this definition">¶</a></dt>
<dd><p>SPI synchronous write followed by read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">spi_device</span> <span class="pre">*</span> <span class="pre">spi</span></code></dt>
<dd>device with which data will be exchanged</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">txbuf</span></code></dt>
<dd>data to be written (need not be dma-safe)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">n_tx</span></code></dt>
<dd>size of txbuf, in bytes</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">rxbuf</span></code></dt>
<dd>buffer into which data will be read (need not be dma-safe)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">n_rx</span></code></dt>
<dd>size of rxbuf, in bytes</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This performs a half duplex MicroWire style transaction with the
device, sending txbuf and then reading rxbuf.  The return value
is zero for success, else a negative errno status code.
This call may only be used from a context that may sleep.</p>
<p>Parameters to this routine are always copied using a small buffer;
portable code should never use this for more than 32 bytes.
Performance-sensitive or bulk transfer code should instead use
spi_{async,sync}() calls with dma-safe buffers.</p>
<p><strong>Return</strong></p>
<p>zero on success, else a negative error code.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="i2c.html" class="btn btn-neutral float-right" title="I2C and SMBus Subsystem" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pci.html" class="btn btn-neutral" title="PCI Support Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>