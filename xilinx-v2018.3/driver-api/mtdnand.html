

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>MTD NAND Driver Programming Interface &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Parallel Port Devices" href="miscellaneous.html" />
    <link rel="prev" title="libATA Developer’s Guide" href="libata.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">MTD NAND Driver Programming Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#known-bugs-and-assumptions">Known Bugs And Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#documentation-hints">Documentation hints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#function-identifiers-xxx">Function identifiers [XXX]</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-member-identifiers-xxx">Struct member identifiers [XXX]</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#basic-board-driver">Basic board driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic-defines">Basic defines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#partition-defines">Partition defines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-control-function">Hardware control function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-ready-function">Device ready function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#init-function">Init function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exit-function">Exit function</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-board-driver-functions">Advanced board driver functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#multiple-chip-control">Multiple chip control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-ecc-support">Hardware ECC support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bad-block-table-support">Bad block table support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spare-area-auto-placement">Spare area (auto)placement</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spare-area-autoplacement-default-schemes">Spare area autoplacement default schemes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#filesystem-support">Filesystem support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tools">Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constants">Constants</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#chip-option-constants">Chip option constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ecc-selection-constants">ECC selection constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-control-related-constants">Hardware control related constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bad-block-table-related-constants">Bad block table related constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structures">Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#public-functions-provided">Public Functions Provided</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internal-functions-provided">Internal Functions Provided</a></li>
<li class="toctree-l3"><a class="reference internal" href="#credits">Credits</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>MTD NAND Driver Programming Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/mtdnand.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mtd-nand-driver-programming-interface">
<h1>MTD NAND Driver Programming Interface<a class="headerlink" href="#mtd-nand-driver-programming-interface" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Thomas Gleixner</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The generic NAND driver supports almost all NAND and AG-AND based chips
and connects them to the Memory Technology Devices (MTD) subsystem of
the Linux Kernel.</p>
<p>This documentation is provided for developers who want to implement
board drivers or filesystem drivers suitable for NAND devices.</p>
</div>
<div class="section" id="known-bugs-and-assumptions">
<h2>Known Bugs And Assumptions<a class="headerlink" href="#known-bugs-and-assumptions" title="Permalink to this headline">¶</a></h2>
<p>None.</p>
</div>
<div class="section" id="documentation-hints">
<h2>Documentation hints<a class="headerlink" href="#documentation-hints" title="Permalink to this headline">¶</a></h2>
<p>The function and structure docs are autogenerated. Each function and
struct member has a short description which is marked with an [XXX]
identifier. The following chapters explain the meaning of those
identifiers.</p>
<div class="section" id="function-identifiers-xxx">
<h3>Function identifiers [XXX]<a class="headerlink" href="#function-identifiers-xxx" title="Permalink to this headline">¶</a></h3>
<p>The functions are marked with [XXX] identifiers in the short comment.
The identifiers explain the usage and scope of the functions. Following
identifiers are used:</p>
<ul>
<li><p class="first">[MTD Interface]</p>
<p>These functions provide the interface to the MTD kernel API. They are
not replaceable and provide functionality which is complete hardware
independent.</p>
</li>
<li><p class="first">[NAND Interface]</p>
<p>These functions are exported and provide the interface to the NAND
kernel API.</p>
</li>
<li><p class="first">[GENERIC]</p>
<p>Generic functions are not replaceable and provide functionality which
is complete hardware independent.</p>
</li>
<li><p class="first">[DEFAULT]</p>
<p>Default functions provide hardware related functionality which is
suitable for most of the implementations. These functions can be
replaced by the board driver if necessary. Those functions are called
via pointers in the NAND chip description structure. The board driver
can set the functions which should be replaced by board dependent
functions before calling nand_scan(). If the function pointer is
NULL on entry to nand_scan() then the pointer is set to the default
function which is suitable for the detected chip type.</p>
</li>
</ul>
</div>
<div class="section" id="struct-member-identifiers-xxx">
<h3>Struct member identifiers [XXX]<a class="headerlink" href="#struct-member-identifiers-xxx" title="Permalink to this headline">¶</a></h3>
<p>The struct members are marked with [XXX] identifiers in the comment. The
identifiers explain the usage and scope of the members. Following
identifiers are used:</p>
<ul>
<li><p class="first">[INTERN]</p>
<p>These members are for NAND driver internal use only and must not be
modified. Most of these values are calculated from the chip geometry
information which is evaluated during nand_scan().</p>
</li>
<li><p class="first">[REPLACEABLE]</p>
<p>Replaceable members hold hardware related functions which can be
provided by the board driver. The board driver can set the functions
which should be replaced by board dependent functions before calling
nand_scan(). If the function pointer is NULL on entry to
nand_scan() then the pointer is set to the default function which is
suitable for the detected chip type.</p>
</li>
<li><p class="first">[BOARDSPECIFIC]</p>
<p>Board specific members hold hardware related information which must
be provided by the board driver. The board driver must set the
function pointers and datafields before calling nand_scan().</p>
</li>
<li><p class="first">[OPTIONAL]</p>
<p>Optional members can hold information relevant for the board driver.
The generic NAND driver code does not use this information.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="basic-board-driver">
<h2>Basic board driver<a class="headerlink" href="#basic-board-driver" title="Permalink to this headline">¶</a></h2>
<p>For most boards it will be sufficient to provide just the basic
functions and fill out some really board dependent members in the nand
chip description structure.</p>
<div class="section" id="basic-defines">
<h3>Basic defines<a class="headerlink" href="#basic-defines" title="Permalink to this headline">¶</a></h3>
<p>At least you have to provide a nand_chip structure and a storage for
the ioremap’ed chip address. You can allocate the nand_chip structure
using kmalloc or you can allocate it statically. The NAND chip structure
embeds an mtd structure which will be registered to the MTD subsystem.
You can extract a pointer to the mtd structure from a nand_chip pointer
using the nand_to_mtd() helper.</p>
<p>Kmalloc based example</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static struct mtd_info *board_mtd;
static void __iomem *baseaddr;
</pre></div>
</div>
<p>Static example</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static struct nand_chip board_chip;
static void __iomem *baseaddr;
</pre></div>
</div>
</div>
<div class="section" id="partition-defines">
<h3>Partition defines<a class="headerlink" href="#partition-defines" title="Permalink to this headline">¶</a></h3>
<p>If you want to divide your device into partitions, then define a
partitioning scheme suitable to your board.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#define NUM_PARTITIONS 2
static struct mtd_partition partition_info[] = {
    { .name = &quot;Flash partition 1&quot;,
      .offset =  0,
      .size =    8 * 1024 * 1024 },
    { .name = &quot;Flash partition 2&quot;,
      .offset =  MTDPART_OFS_NEXT,
      .size =    MTDPART_SIZ_FULL },
};
</pre></div>
</div>
</div>
<div class="section" id="hardware-control-function">
<h3>Hardware control function<a class="headerlink" href="#hardware-control-function" title="Permalink to this headline">¶</a></h3>
<p>The hardware control function provides access to the control pins of the
NAND chip(s). The access can be done by GPIO pins or by address lines.
If you use address lines, make sure that the timing requirements are
met.</p>
<p><em>GPIO based example</em></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
    switch(cmd){
        case NAND_CTL_SETCLE: /* Set CLE pin high */ break;
        case NAND_CTL_CLRCLE: /* Set CLE pin low */ break;
        case NAND_CTL_SETALE: /* Set ALE pin high */ break;
        case NAND_CTL_CLRALE: /* Set ALE pin low */ break;
        case NAND_CTL_SETNCE: /* Set nCE pin low */ break;
        case NAND_CTL_CLRNCE: /* Set nCE pin high */ break;
    }
}
</pre></div>
</div>
<p><em>Address lines based example.</em> It’s assumed that the nCE pin is driven
by a chip select decoder.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static void board_hwcontrol(struct mtd_info *mtd, int cmd)
{
    struct nand_chip *this = mtd_to_nand(mtd);
    switch(cmd){
        case NAND_CTL_SETCLE: this-&gt;IO_ADDR_W |= CLE_ADRR_BIT;  break;
        case NAND_CTL_CLRCLE: this-&gt;IO_ADDR_W &amp;= ~CLE_ADRR_BIT; break;
        case NAND_CTL_SETALE: this-&gt;IO_ADDR_W |= ALE_ADRR_BIT;  break;
        case NAND_CTL_CLRALE: this-&gt;IO_ADDR_W &amp;= ~ALE_ADRR_BIT; break;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="device-ready-function">
<h3>Device ready function<a class="headerlink" href="#device-ready-function" title="Permalink to this headline">¶</a></h3>
<p>If the hardware interface has the ready busy pin of the NAND chip
connected to a GPIO or other accessible I/O pin, this function is used
to read back the state of the pin. The function has no arguments and
should return 0, if the device is busy (R/B pin is low) and 1, if the
device is ready (R/B pin is high). If the hardware interface does not
give access to the ready busy pin, then the function must not be defined
and the function pointer this-&gt;dev_ready is set to NULL.</p>
</div>
<div class="section" id="init-function">
<h3>Init function<a class="headerlink" href="#init-function" title="Permalink to this headline">¶</a></h3>
<p>The init function allocates memory and sets up all the board specific
parameters and function pointers. When everything is set up nand_scan()
is called. This function tries to detect and identify then chip. If a
chip is found all the internal data fields are initialized accordingly.
The structure(s) have to be zeroed out first and then filled with the
necessary information about the device.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static int __init board_init (void)
{
    struct nand_chip *this;
    int err = 0;

    /* Allocate memory for MTD device structure and private data */
    this = kzalloc(sizeof(struct nand_chip), GFP_KERNEL);
    if (!this) {
        printk (&quot;Unable to allocate NAND MTD device structure.\n&quot;);
        err = -ENOMEM;
        goto out;
    }

    board_mtd = nand_to_mtd(this);

    /* map physical address */
    baseaddr = ioremap(CHIP_PHYSICAL_ADDRESS, 1024);
    if (!baseaddr) {
        printk(&quot;Ioremap to access NAND chip failed\n&quot;);
        err = -EIO;
        goto out_mtd;
    }

    /* Set address of NAND IO lines */
    this-&gt;IO_ADDR_R = baseaddr;
    this-&gt;IO_ADDR_W = baseaddr;
    /* Reference hardware control function */
    this-&gt;hwcontrol = board_hwcontrol;
    /* Set command delay time, see datasheet for correct value */
    this-&gt;chip_delay = CHIP_DEPENDEND_COMMAND_DELAY;
    /* Assign the device ready function, if available */
    this-&gt;dev_ready = board_dev_ready;
    this-&gt;eccmode = NAND_ECC_SOFT;

    /* Scan to find existence of the device */
    if (nand_scan (board_mtd, 1)) {
        err = -ENXIO;
        goto out_ior;
    }

    add_mtd_partitions(board_mtd, partition_info, NUM_PARTITIONS);
    goto out;

out_ior:
    iounmap(baseaddr);
out_mtd:
    kfree (this);
out:
    return err;
}
module_init(board_init);
</pre></div>
</div>
</div>
<div class="section" id="exit-function">
<h3>Exit function<a class="headerlink" href="#exit-function" title="Permalink to this headline">¶</a></h3>
<p>The exit function is only necessary if the driver is compiled as a
module. It releases all resources which are held by the chip driver and
unregisters the partitions in the MTD layer.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#ifdef MODULE
static void __exit board_cleanup (void)
{
    /* Release resources, unregister device */
    nand_release (board_mtd);

    /* unmap physical address */
    iounmap(baseaddr);

    /* Free the MTD device structure */
    kfree (mtd_to_nand(board_mtd));
}
module_exit(board_cleanup);
#endif
</pre></div>
</div>
</div>
</div>
<div class="section" id="advanced-board-driver-functions">
<h2>Advanced board driver functions<a class="headerlink" href="#advanced-board-driver-functions" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes the advanced functionality of the NAND driver.
For a list of functions which can be overridden by the board driver see
the documentation of the nand_chip structure.</p>
<div class="section" id="multiple-chip-control">
<h3>Multiple chip control<a class="headerlink" href="#multiple-chip-control" title="Permalink to this headline">¶</a></h3>
<p>The nand driver can control chip arrays. Therefore the board driver must
provide an own select_chip function. This function must (de)select the
requested chip. The function pointer in the nand_chip structure must be
set before calling nand_scan(). The maxchip parameter of nand_scan()
defines the maximum number of chips to scan for. Make sure that the
select_chip function can handle the requested number of chips.</p>
<p>The nand driver concatenates the chips to one virtual chip and provides
this virtual chip to the MTD layer.</p>
<p><em>Note: The driver can only handle linear chip arrays of equally sized
chips. There is no support for parallel arrays which extend the
buswidth.</em></p>
<p><em>GPIO based example</em></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static void board_select_chip (struct mtd_info *mtd, int chip)
{
    /* Deselect all chips, set all nCE pins high */
    GPIO(BOARD_NAND_NCE) |= 0xff;
    if (chip &gt;= 0)
        GPIO(BOARD_NAND_NCE) &amp;= ~ (1 &lt;&lt; chip);
}
</pre></div>
</div>
<p><em>Address lines based example.</em> Its assumed that the nCE pins are
connected to an address decoder.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static void board_select_chip (struct mtd_info *mtd, int chip)
{
    struct nand_chip *this = mtd_to_nand(mtd);

    /* Deselect all chips */
    this-&gt;IO_ADDR_R &amp;= ~BOARD_NAND_ADDR_MASK;
    this-&gt;IO_ADDR_W &amp;= ~BOARD_NAND_ADDR_MASK;
    switch (chip) {
    case 0:
        this-&gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIP0;
        this-&gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIP0;
        break;
    ....
    case n:
        this-&gt;IO_ADDR_R |= BOARD_NAND_ADDR_CHIPn;
        this-&gt;IO_ADDR_W |= BOARD_NAND_ADDR_CHIPn;
        break;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="hardware-ecc-support">
<h3>Hardware ECC support<a class="headerlink" href="#hardware-ecc-support" title="Permalink to this headline">¶</a></h3>
<div class="section" id="functions-and-constants">
<h4>Functions and constants<a class="headerlink" href="#functions-and-constants" title="Permalink to this headline">¶</a></h4>
<p>The nand driver supports three different types of hardware ECC.</p>
<ul>
<li><p class="first">NAND_ECC_HW3_256</p>
<p>Hardware ECC generator providing 3 bytes ECC per 256 byte.</p>
</li>
<li><p class="first">NAND_ECC_HW3_512</p>
<p>Hardware ECC generator providing 3 bytes ECC per 512 byte.</p>
</li>
<li><p class="first">NAND_ECC_HW6_512</p>
<p>Hardware ECC generator providing 6 bytes ECC per 512 byte.</p>
</li>
<li><p class="first">NAND_ECC_HW8_512</p>
<p>Hardware ECC generator providing 6 bytes ECC per 512 byte.</p>
</li>
</ul>
<p>If your hardware generator has a different functionality add it at the
appropriate place in nand_base.c</p>
<p>The board driver must provide following functions:</p>
<ul>
<li><p class="first">enable_hwecc</p>
<p>This function is called before reading / writing to the chip. Reset
or initialize the hardware generator in this function. The function
is called with an argument which let you distinguish between read and
write operations.</p>
</li>
<li><p class="first">calculate_ecc</p>
<p>This function is called after read / write from / to the chip.
Transfer the ECC from the hardware to the buffer. If the option
NAND_HWECC_SYNDROME is set then the function is only called on
write. See below.</p>
</li>
<li><p class="first">correct_data</p>
<p>In case of an ECC error this function is called for error detection
and correction. Return 1 respectively 2 in case the error can be
corrected. If the error is not correctable return -1. If your
hardware generator matches the default algorithm of the nand_ecc
software generator then use the correction function provided by
nand_ecc instead of implementing duplicated code.</p>
</li>
</ul>
</div>
<div class="section" id="hardware-ecc-with-syndrome-calculation">
<h4>Hardware ECC with syndrome calculation<a class="headerlink" href="#hardware-ecc-with-syndrome-calculation" title="Permalink to this headline">¶</a></h4>
<p>Many hardware ECC implementations provide Reed-Solomon codes and
calculate an error syndrome on read. The syndrome must be converted to a
standard Reed-Solomon syndrome before calling the error correction code
in the generic Reed-Solomon library.</p>
<p>The ECC bytes must be placed immediately after the data bytes in order
to make the syndrome generator work. This is contrary to the usual
layout used by software ECC. The separation of data and out of band area
is not longer possible. The nand driver code handles this layout and the
remaining free bytes in the oob area are managed by the autoplacement
code. Provide a matching oob-layout in this case. See rts_from4.c and
diskonchip.c for implementation reference. In those cases we must also
use bad block tables on FLASH, because the ECC layout is interfering
with the bad block marker positions. See bad block table support for
details.</p>
</div>
</div>
<div class="section" id="bad-block-table-support">
<h3>Bad block table support<a class="headerlink" href="#bad-block-table-support" title="Permalink to this headline">¶</a></h3>
<p>Most NAND chips mark the bad blocks at a defined position in the spare
area. Those blocks must not be erased under any circumstances as the bad
block information would be lost. It is possible to check the bad block
mark each time when the blocks are accessed by reading the spare area of
the first page in the block. This is time consuming so a bad block table
is used.</p>
<p>The nand driver supports various types of bad block tables.</p>
<ul>
<li><p class="first">Per device</p>
<p>The bad block table contains all bad block information of the device
which can consist of multiple chips.</p>
</li>
<li><p class="first">Per chip</p>
<p>A bad block table is used per chip and contains the bad block
information for this particular chip.</p>
</li>
<li><p class="first">Fixed offset</p>
<p>The bad block table is located at a fixed offset in the chip
(device). This applies to various DiskOnChip devices.</p>
</li>
<li><p class="first">Automatic placed</p>
<p>The bad block table is automatically placed and detected either at
the end or at the beginning of a chip (device)</p>
</li>
<li><p class="first">Mirrored tables</p>
<p>The bad block table is mirrored on the chip (device) to allow updates
of the bad block table without data loss.</p>
</li>
</ul>
<p>nand_scan() calls the function nand_default_bbt().
nand_default_bbt() selects appropriate default bad block table
descriptors depending on the chip information which was retrieved by
nand_scan().</p>
<p>The standard policy is scanning the device for bad blocks and build a
ram based bad block table which allows faster access than always
checking the bad block information on the flash chip itself.</p>
<div class="section" id="flash-based-tables">
<h4>Flash based tables<a class="headerlink" href="#flash-based-tables" title="Permalink to this headline">¶</a></h4>
<p>It may be desired or necessary to keep a bad block table in FLASH. For
AG-AND chips this is mandatory, as they have no factory marked bad
blocks. They have factory marked good blocks. The marker pattern is
erased when the block is erased to be reused. So in case of powerloss
before writing the pattern back to the chip this block would be lost and
added to the bad blocks. Therefore we scan the chip(s) when we detect
them the first time for good blocks and store this information in a bad
block table before erasing any of the blocks.</p>
<p>The blocks in which the tables are stored are protected against
accidental access by marking them bad in the memory bad block table. The
bad block table management functions are allowed to circumvent this
protection.</p>
<p>The simplest way to activate the FLASH based bad block table support is
to set the option NAND_BBT_USE_FLASH in the bbt_option field of the
nand chip structure before calling nand_scan(). For AG-AND chips is
this done by default. This activates the default FLASH based bad block
table functionality of the NAND driver. The default bad block table
options are</p>
<ul class="simple">
<li>Store bad block table per chip</li>
<li>Use 2 bits per block</li>
<li>Automatic placement at the end of the chip</li>
<li>Use mirrored tables with version numbers</li>
<li>Reserve 4 blocks at the end of the chip</li>
</ul>
</div>
<div class="section" id="user-defined-tables">
<h4>User defined tables<a class="headerlink" href="#user-defined-tables" title="Permalink to this headline">¶</a></h4>
<p>User defined tables are created by filling out a nand_bbt_descr
structure and storing the pointer in the nand_chip structure member
bbt_td before calling nand_scan(). If a mirror table is necessary a
second structure must be created and a pointer to this structure must be
stored in bbt_md inside the nand_chip structure. If the bbt_md member
is set to NULL then only the main table is used and no scan for the
mirrored table is performed.</p>
<p>The most important field in the nand_bbt_descr structure is the
options field. The options define most of the table properties. Use the
predefined constants from rawnand.h to define the options.</p>
<ul>
<li><p class="first">Number of bits per block</p>
<p>The supported number of bits is 1, 2, 4, 8.</p>
</li>
<li><p class="first">Table per chip</p>
<p>Setting the constant NAND_BBT_PERCHIP selects that a bad block
table is managed for each chip in a chip array. If this option is not
set then a per device bad block table is used.</p>
</li>
<li><p class="first">Table location is absolute</p>
<p>Use the option constant NAND_BBT_ABSPAGE and define the absolute
page number where the bad block table starts in the field pages. If
you have selected bad block tables per chip and you have a multi chip
array then the start page must be given for each chip in the chip
array. Note: there is no scan for a table ident pattern performed, so
the fields pattern, veroffs, offs, len can be left uninitialized</p>
</li>
<li><p class="first">Table location is automatically detected</p>
<p>The table can either be located in the first or the last good blocks
of the chip (device). Set NAND_BBT_LASTBLOCK to place the bad block
table at the end of the chip (device). The bad block tables are
marked and identified by a pattern which is stored in the spare area
of the first page in the block which holds the bad block table. Store
a pointer to the pattern in the pattern field. Further the length of
the pattern has to be stored in len and the offset in the spare area
must be given in the offs member of the nand_bbt_descr structure.
For mirrored bad block tables different patterns are mandatory.</p>
</li>
<li><p class="first">Table creation</p>
<p>Set the option NAND_BBT_CREATE to enable the table creation if no
table can be found during the scan. Usually this is done only once if
a new chip is found.</p>
</li>
<li><p class="first">Table write support</p>
<p>Set the option NAND_BBT_WRITE to enable the table write support.
This allows the update of the bad block table(s) in case a block has
to be marked bad due to wear. The MTD interface function
block_markbad is calling the update function of the bad block table.
If the write support is enabled then the table is updated on FLASH.</p>
<p>Note: Write support should only be enabled for mirrored tables with
version control.</p>
</li>
<li><p class="first">Table version control</p>
<p>Set the option NAND_BBT_VERSION to enable the table version
control. It’s highly recommended to enable this for mirrored tables
with write support. It makes sure that the risk of losing the bad
block table information is reduced to the loss of the information
about the one worn out block which should be marked bad. The version
is stored in 4 consecutive bytes in the spare area of the device. The
position of the version number is defined by the member veroffs in
the bad block table descriptor.</p>
</li>
<li><p class="first">Save block contents on write</p>
<p>In case that the block which holds the bad block table does contain
other useful information, set the option NAND_BBT_SAVECONTENT. When
the bad block table is written then the whole block is read the bad
block table is updated and the block is erased and everything is
written back. If this option is not set only the bad block table is
written and everything else in the block is ignored and erased.</p>
</li>
<li><p class="first">Number of reserved blocks</p>
<p>For automatic placement some blocks must be reserved for bad block
table storage. The number of reserved blocks is defined in the
maxblocks member of the bad block table description structure.
Reserving 4 blocks for mirrored tables should be a reasonable number.
This also limits the number of blocks which are scanned for the bad
block table ident pattern.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="spare-area-auto-placement">
<h3>Spare area (auto)placement<a class="headerlink" href="#spare-area-auto-placement" title="Permalink to this headline">¶</a></h3>
<p>The nand driver implements different possibilities for placement of
filesystem data in the spare area,</p>
<ul class="simple">
<li>Placement defined by fs driver</li>
<li>Automatic placement</li>
</ul>
<p>The default placement function is automatic placement. The nand driver
has built in default placement schemes for the various chiptypes. If due
to hardware ECC functionality the default placement does not fit then
the board driver can provide a own placement scheme.</p>
<p>File system drivers can provide a own placement scheme which is used
instead of the default placement scheme.</p>
<p>Placement schemes are defined by a nand_oobinfo structure</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_oobinfo {
    int useecc;
    int eccbytes;
    int eccpos[24];
    int oobfree[8][2];
};
</pre></div>
</div>
<ul>
<li><p class="first">useecc</p>
<p>The useecc member controls the ecc and placement function. The header
file include/mtd/mtd-abi.h contains constants to select ecc and
placement. MTD_NANDECC_OFF switches off the ecc complete. This is
not recommended and available for testing and diagnosis only.
MTD_NANDECC_PLACE selects caller defined placement,
MTD_NANDECC_AUTOPLACE selects automatic placement.</p>
</li>
<li><p class="first">eccbytes</p>
<p>The eccbytes member defines the number of ecc bytes per page.</p>
</li>
<li><p class="first">eccpos</p>
<p>The eccpos array holds the byte offsets in the spare area where the
ecc codes are placed.</p>
</li>
<li><p class="first">oobfree</p>
<p>The oobfree array defines the areas in the spare area which can be
used for automatic placement. The information is given in the format
{offset, size}. offset defines the start of the usable area, size the
length in bytes. More than one area can be defined. The list is
terminated by an {0, 0} entry.</p>
</li>
</ul>
<div class="section" id="placement-defined-by-fs-driver">
<h4>Placement defined by fs driver<a class="headerlink" href="#placement-defined-by-fs-driver" title="Permalink to this headline">¶</a></h4>
<p>The calling function provides a pointer to a nand_oobinfo structure
which defines the ecc placement. For writes the caller must provide a
spare area buffer along with the data buffer. The spare area buffer size
is (number of pages) * (size of spare area). For reads the buffer size
is (number of pages) * ((size of spare area) + (number of ecc steps per
page) * sizeof (int)). The driver stores the result of the ecc check
for each tuple in the spare buffer. The storage sequence is:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>&lt;spare data page 0&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;

...

&lt;spare data page n&gt;&lt;ecc result 0&gt;...&lt;ecc result n&gt;
</pre></div>
</div>
<p>This is a legacy mode used by YAFFS1.</p>
<p>If the spare area buffer is NULL then only the ECC placement is done
according to the given scheme in the nand_oobinfo structure.</p>
</div>
<div class="section" id="automatic-placement">
<h4>Automatic placement<a class="headerlink" href="#automatic-placement" title="Permalink to this headline">¶</a></h4>
<p>Automatic placement uses the built in defaults to place the ecc bytes in
the spare area. If filesystem data have to be stored / read into the
spare area then the calling function must provide a buffer. The buffer
size per page is determined by the oobfree array in the nand_oobinfo
structure.</p>
<p>If the spare area buffer is NULL then only the ECC placement is done
according to the default builtin scheme.</p>
</div>
</div>
<div class="section" id="spare-area-autoplacement-default-schemes">
<h3>Spare area autoplacement default schemes<a class="headerlink" href="#spare-area-autoplacement-default-schemes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="byte-pagesize">
<h4>256 byte pagesize<a class="headerlink" href="#byte-pagesize" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="23%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Content</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00</td>
<td>ECC byte 0</td>
<td>Error correction code byte 0</td>
</tr>
<tr class="row-odd"><td>0x01</td>
<td>ECC byte 1</td>
<td>Error correction code byte 1</td>
</tr>
<tr class="row-even"><td>0x02</td>
<td>ECC byte 2</td>
<td>Error correction code byte 2</td>
</tr>
<tr class="row-odd"><td>0x03</td>
<td>Autoplace 0</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>0x04</td>
<td>Autoplace 1</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>0x05</td>
<td>Bad block marker</td>
<td>If any bit in this byte is zero, then this
block is bad. This applies only to the first
page in a block. In the remaining pages this
byte is reserved</td>
</tr>
<tr class="row-even"><td>0x06</td>
<td>Autoplace 2</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>0x07</td>
<td>Autoplace 3</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id1">
<h4>512 byte pagesize<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="23%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Content</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00</td>
<td>ECC byte 0</td>
<td>Error correction code byte 0 of the lower
256 Byte data in this page</td>
</tr>
<tr class="row-odd"><td>0x01</td>
<td>ECC byte 1</td>
<td>Error correction code byte 1 of the lower
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x02</td>
<td>ECC byte 2</td>
<td>Error correction code byte 2 of the lower
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x03</td>
<td>ECC byte 3</td>
<td>Error correction code byte 0 of the upper
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x04</td>
<td>reserved</td>
<td>reserved</td>
</tr>
<tr class="row-odd"><td>0x05</td>
<td>Bad block marker</td>
<td>If any bit in this byte is zero, then this
block is bad. This applies only to the first
page in a block. In the remaining pages this
byte is reserved</td>
</tr>
<tr class="row-even"><td>0x06</td>
<td>ECC byte 4</td>
<td>Error correction code byte 1 of the upper
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x07</td>
<td>ECC byte 5</td>
<td>Error correction code byte 2 of the upper
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x08 - 0x0F</td>
<td>Autoplace 0 - 7</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id2">
<h4>2048 byte pagesize<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="23%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Offset</th>
<th class="head">Content</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x00</td>
<td>Bad block marker</td>
<td>If any bit in this byte is zero, then this block
is bad. This applies only to the first page in a
block. In the remaining pages this byte is
reserved</td>
</tr>
<tr class="row-odd"><td>0x01</td>
<td>Reserved</td>
<td>Reserved</td>
</tr>
<tr class="row-even"><td>0x02-0x27</td>
<td>Autoplace 0 - 37</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>0x28</td>
<td>ECC byte 0</td>
<td>Error correction code byte 0 of the first
256 Byte data in this page</td>
</tr>
<tr class="row-even"><td>0x29</td>
<td>ECC byte 1</td>
<td>Error correction code byte 1 of the first
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x2A</td>
<td>ECC byte 2</td>
<td>Error correction code byte 2 of the first
256 Bytes data in this page</td>
</tr>
<tr class="row-even"><td>0x2B</td>
<td>ECC byte 3</td>
<td>Error correction code byte 0 of the second
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x2C</td>
<td>ECC byte 4</td>
<td>Error correction code byte 1 of the second
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x2D</td>
<td>ECC byte 5</td>
<td>Error correction code byte 2 of the second
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x2E</td>
<td>ECC byte 6</td>
<td>Error correction code byte 0 of the third
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x2F</td>
<td>ECC byte 7</td>
<td>Error correction code byte 1 of the third
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x30</td>
<td>ECC byte 8</td>
<td>Error correction code byte 2 of the third
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x31</td>
<td>ECC byte 9</td>
<td>Error correction code byte 0 of the fourth
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x32</td>
<td>ECC byte 10</td>
<td>Error correction code byte 1 of the fourth
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x33</td>
<td>ECC byte 11</td>
<td>Error correction code byte 2 of the fourth
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x34</td>
<td>ECC byte 12</td>
<td>Error correction code byte 0 of the fifth
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x35</td>
<td>ECC byte 13</td>
<td>Error correction code byte 1 of the fifth
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x36</td>
<td>ECC byte 14</td>
<td>Error correction code byte 2 of the fifth
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x37</td>
<td>ECC byte 15</td>
<td>Error correction code byte 0 of the sixth
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x38</td>
<td>ECC byte 16</td>
<td>Error correction code byte 1 of the sixth
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x39</td>
<td>ECC byte 17</td>
<td>Error correction code byte 2 of the sixth
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x3A</td>
<td>ECC byte 18</td>
<td>Error correction code byte 0 of the seventh
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x3B</td>
<td>ECC byte 19</td>
<td>Error correction code byte 1 of the seventh
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x3C</td>
<td>ECC byte 20</td>
<td>Error correction code byte 2 of the seventh
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x3D</td>
<td>ECC byte 21</td>
<td>Error correction code byte 0 of the eighth
256 Bytes of data in this page</td>
</tr>
<tr class="row-odd"><td>0x3E</td>
<td>ECC byte 22</td>
<td>Error correction code byte 1 of the eighth
256 Bytes of data in this page</td>
</tr>
<tr class="row-even"><td>0x3F</td>
<td>ECC byte 23</td>
<td>Error correction code byte 2 of the eighth
256 Bytes of data in this page</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="filesystem-support">
<h2>Filesystem support<a class="headerlink" href="#filesystem-support" title="Permalink to this headline">¶</a></h2>
<p>The NAND driver provides all necessary functions for a filesystem via
the MTD interface.</p>
<p>Filesystems must be aware of the NAND peculiarities and restrictions.
One major restrictions of NAND Flash is, that you cannot write as often
as you want to a page. The consecutive writes to a page, before erasing
it again, are restricted to 1-3 writes, depending on the manufacturers
specifications. This applies similar to the spare area.</p>
<p>Therefore NAND aware filesystems must either write in page size chunks
or hold a writebuffer to collect smaller writes until they sum up to
pagesize. Available NAND aware filesystems: JFFS2, YAFFS.</p>
<p>The spare area usage to store filesystem data is controlled by the spare
area placement functionality which is described in one of the earlier
chapters.</p>
</div>
<div class="section" id="tools">
<h2>Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h2>
<p>The MTD project provides a couple of helpful tools to handle NAND Flash.</p>
<ul class="simple">
<li>flasherase, flasheraseall: Erase and format FLASH partitions</li>
<li>nandwrite: write filesystem images to NAND FLASH</li>
<li>nanddump: dump the contents of a NAND FLASH partitions</li>
</ul>
<p>These tools are aware of the NAND restrictions. Please use those tools
instead of complaining about errors which are caused by non NAND aware
access methods.</p>
</div>
<div class="section" id="constants">
<h2>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes the constants which might be relevant for a
driver developer.</p>
<div class="section" id="chip-option-constants">
<h3>Chip option constants<a class="headerlink" href="#chip-option-constants" title="Permalink to this headline">¶</a></h3>
<div class="section" id="constants-for-chip-id-table">
<h4>Constants for chip id table<a class="headerlink" href="#constants-for-chip-id-table" title="Permalink to this headline">¶</a></h4>
<p>These constants are defined in rawnand.h. They are OR-ed together to
describe the chip functionality:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* Buswitdh is 16 bit */
#define NAND_BUSWIDTH_16    0x00000002
/* Device supports partial programming without padding */
#define NAND_NO_PADDING     0x00000004
/* Chip has cache program function */
#define NAND_CACHEPRG       0x00000008
/* Chip has copy back function */
#define NAND_COPYBACK       0x00000010
/* AND Chip which has 4 banks and a confusing page / block
 * assignment. See Renesas datasheet for further information */
#define NAND_IS_AND     0x00000020
/* Chip has a array of 4 pages which can be read without
 * additional ready /busy waits */
#define NAND_4PAGE_ARRAY    0x00000040
</pre></div>
</div>
</div>
<div class="section" id="constants-for-runtime-options">
<h4>Constants for runtime options<a class="headerlink" href="#constants-for-runtime-options" title="Permalink to this headline">¶</a></h4>
<p>These constants are defined in rawnand.h. They are OR-ed together to
describe the functionality:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* The hw ecc generator provides a syndrome instead a ecc value on read
 * This can only work if we have the ecc bytes directly behind the
 * data bytes. Applies for DOC and AG-AND Renesas HW Reed Solomon generators */
#define NAND_HWECC_SYNDROME 0x00020000
</pre></div>
</div>
</div>
</div>
<div class="section" id="ecc-selection-constants">
<h3>ECC selection constants<a class="headerlink" href="#ecc-selection-constants" title="Permalink to this headline">¶</a></h3>
<p>Use these constants to select the ECC algorithm:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* No ECC. Usage is not recommended ! */
#define NAND_ECC_NONE       0
/* Software ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_SOFT       1
/* Hardware ECC 3 byte ECC per 256 Byte data */
#define NAND_ECC_HW3_256    2
/* Hardware ECC 3 byte ECC per 512 Byte data */
#define NAND_ECC_HW3_512    3
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW6_512    4
/* Hardware ECC 6 byte ECC per 512 Byte data */
#define NAND_ECC_HW8_512    6
</pre></div>
</div>
</div>
<div class="section" id="hardware-control-related-constants">
<h3>Hardware control related constants<a class="headerlink" href="#hardware-control-related-constants" title="Permalink to this headline">¶</a></h3>
<p>These constants describe the requested hardware access function when the
boardspecific hardware control function is called:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* Select the chip by setting nCE to low */
#define NAND_CTL_SETNCE     1
/* Deselect the chip by setting nCE to high */
#define NAND_CTL_CLRNCE     2
/* Select the command latch by setting CLE to high */
#define NAND_CTL_SETCLE     3
/* Deselect the command latch by setting CLE to low */
#define NAND_CTL_CLRCLE     4
/* Select the address latch by setting ALE to high */
#define NAND_CTL_SETALE     5
/* Deselect the address latch by setting ALE to low */
#define NAND_CTL_CLRALE     6
/* Set write protection by setting WP to high. Not used! */
#define NAND_CTL_SETWP      7
/* Clear write protection by setting WP to low. Not used! */
#define NAND_CTL_CLRWP      8
</pre></div>
</div>
</div>
<div class="section" id="bad-block-table-related-constants">
<h3>Bad block table related constants<a class="headerlink" href="#bad-block-table-related-constants" title="Permalink to this headline">¶</a></h3>
<p>These constants describe the options used for bad block table
descriptors:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* Options for the bad block table descriptors */

/* The number of bits used per block in the bbt on the device */
#define NAND_BBT_NRBITS_MSK 0x0000000F
#define NAND_BBT_1BIT       0x00000001
#define NAND_BBT_2BIT       0x00000002
#define NAND_BBT_4BIT       0x00000004
#define NAND_BBT_8BIT       0x00000008
/* The bad block table is in the last good block of the device */
#define NAND_BBT_LASTBLOCK  0x00000010
/* The bbt is at the given page, else we must scan for the bbt */
#define NAND_BBT_ABSPAGE    0x00000020
/* bbt is stored per chip on multichip devices */
#define NAND_BBT_PERCHIP    0x00000080
/* bbt has a version counter at offset veroffs */
#define NAND_BBT_VERSION    0x00000100
/* Create a bbt if none axists */
#define NAND_BBT_CREATE     0x00000200
/* Write bbt if necessary */
#define NAND_BBT_WRITE      0x00001000
/* Read and write back block contents when writing bbt */
#define NAND_BBT_SAVECONTENT    0x00002000
</pre></div>
</div>
</div>
</div>
<div class="section" id="structures">
<h2>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the structures
which are used in the NAND driver and might be relevant for a driver
developer. Each struct member has a short description which is marked
with an [XXX] identifier. See the chapter “Documentation hints” for an
explanation.</p>
<dl class="type">
<dt id="c.nand_id">
struct <code class="descname">nand_id</code><a class="headerlink" href="#c.nand_id" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND id structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_id {
  u8 data;
  int len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>buffer containing the id bytes.</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>ID length.</dd>
</dl>
<dl class="type">
<dt id="c.nand_hw_control">
struct <code class="descname">nand_hw_control</code><a class="headerlink" href="#c.nand_hw_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Control structure for hardware controller (e.g ECC generator) shared among independent devices</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_hw_control {
  spinlock_t lock;
  struct nand_chip * active;
  wait_queue_head_t wq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>protection lock</dd>
<dt><code class="docutils literal"><span class="pre">active</span></code></dt>
<dd>the mtd device which holds the controller currently</dd>
<dt><code class="docutils literal"><span class="pre">wq</span></code></dt>
<dd>wait queue to sleep on if a NAND operation is in
progress used instead of the per chip wait queue
when a hw controller is available.</dd>
</dl>
<dl class="type">
<dt id="c.nand_ecc_step_info">
struct <code class="descname">nand_ecc_step_info</code><a class="headerlink" href="#c.nand_ecc_step_info" title="Permalink to this definition">¶</a></dt>
<dd><p>ECC step information of ECC engine</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_ecc_step_info {
  int stepsize;
  const int * strengths;
  int nstrengths;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">stepsize</span></code></dt>
<dd>data bytes per ECC step</dd>
<dt><code class="docutils literal"><span class="pre">strengths</span></code></dt>
<dd>array of supported strengths</dd>
<dt><code class="docutils literal"><span class="pre">nstrengths</span></code></dt>
<dd>number of supported strengths</dd>
</dl>
<dl class="type">
<dt id="c.nand_ecc_caps">
struct <code class="descname">nand_ecc_caps</code><a class="headerlink" href="#c.nand_ecc_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>capability of ECC engine</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_ecc_caps {
  const struct nand_ecc_step_info * stepinfos;
  int nstepinfos;
  int (* calc_ecc_bytes) (int step_size, int strength);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">stepinfos</span></code></dt>
<dd>array of ECC step information</dd>
<dt><code class="docutils literal"><span class="pre">nstepinfos</span></code></dt>
<dd>number of ECC step information</dd>
<dt><code class="docutils literal"><span class="pre">calc_ecc_bytes</span></code></dt>
<dd>driver’s hook to calculate ECC bytes per step</dd>
</dl>
<dl class="type">
<dt id="c.nand_ecc_ctrl">
struct <code class="descname">nand_ecc_ctrl</code><a class="headerlink" href="#c.nand_ecc_ctrl" title="Permalink to this definition">¶</a></dt>
<dd><p>Control structure for ECC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_ecc_ctrl {
  nand_ecc_modes_t mode;
  enum nand_ecc_algo algo;
  int steps;
  int size;
  int bytes;
  int total;
  int strength;
  int prepad;
  int postpad;
  unsigned int options;
  void * priv;
  void (* hwctl) (struct mtd_info *mtd, int mode);
  int (* calculate) (struct mtd_info *mtd, const uint8_t *dat, uint8_t *ecc_code);
  int (* correct) (struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc, uint8_t *calc_ecc);
  int (* read_page_raw) (struct mtd_info *mtd, struct nand_chip *chip, uint8_t *buf, int oob_required, int page);
  int (* write_page_raw) (struct mtd_info *mtd, struct nand_chip *chip, const uint8_t *buf, int oob_required, int page);
  int (* read_page) (struct mtd_info *mtd, struct nand_chip *chip, uint8_t *buf, int oob_required, int page);
  int (* read_subpage) (struct mtd_info *mtd, struct nand_chip *chip, uint32_t offs, uint32_t len, uint8_t *buf, int page);
  int (* write_subpage) (struct mtd_info *mtd, struct nand_chip *chip,uint32_t offset, uint32_t data_len, const uint8_t *data_buf, int oob_required, int page);
  int (* write_page) (struct mtd_info *mtd, struct nand_chip *chip, const uint8_t *buf, int oob_required, int page);
  int (* write_oob_raw) (struct mtd_info *mtd, struct nand_chip *chip, int page);
  int (* read_oob_raw) (struct mtd_info *mtd, struct nand_chip *chip, int page);
  int (* read_oob) (struct mtd_info *mtd, struct nand_chip *chip, int page);
  int (* write_oob) (struct mtd_info *mtd, struct nand_chip *chip, int page);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>ECC mode</dd>
<dt><code class="docutils literal"><span class="pre">algo</span></code></dt>
<dd>ECC algorithm</dd>
<dt><code class="docutils literal"><span class="pre">steps</span></code></dt>
<dd>number of ECC steps per page</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>data bytes per ECC step</dd>
<dt><code class="docutils literal"><span class="pre">bytes</span></code></dt>
<dd>ECC bytes per step</dd>
<dt><code class="docutils literal"><span class="pre">total</span></code></dt>
<dd>total number of ECC bytes per page</dd>
<dt><code class="docutils literal"><span class="pre">strength</span></code></dt>
<dd>max number of correctible bits per ECC step</dd>
<dt><code class="docutils literal"><span class="pre">prepad</span></code></dt>
<dd>padding information for syndrome based ECC generators</dd>
<dt><code class="docutils literal"><span class="pre">postpad</span></code></dt>
<dd>padding information for syndrome based ECC generators</dd>
<dt><code class="docutils literal"><span class="pre">options</span></code></dt>
<dd>ECC specific options (see NAND_ECC_XXX flags defined above)</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>pointer to private ECC control data</dd>
<dt><code class="docutils literal"><span class="pre">hwctl</span></code></dt>
<dd>function to control hardware ECC generator. Must only
be provided if an hardware ECC is available</dd>
<dt><code class="docutils literal"><span class="pre">calculate</span></code></dt>
<dd>function for ECC calculation or readback from ECC hardware</dd>
<dt><code class="docutils literal"><span class="pre">correct</span></code></dt>
<dd>function for ECC correction, matching to ECC generator (sw/hw).
Should return a positive number representing the number of
corrected bitflips, -EBADMSG if the number of bitflips exceed
ECC strength, or any other error code if the error is not
directly related to correction.
If -EBADMSG is returned the input buffers should be left
untouched.</dd>
<dt><code class="docutils literal"><span class="pre">read_page_raw</span></code></dt>
<dd>function to read a raw page without ECC. This function
should hide the specific layout used by the ECC
controller and always return contiguous in-band and
out-of-band data even if they’re not stored
contiguously on the NAND chip (e.g.
NAND_ECC_HW_SYNDROME interleaves in-band and
out-of-band data).</dd>
<dt><code class="docutils literal"><span class="pre">write_page_raw</span></code></dt>
<dd>function to write a raw page without ECC. This function
should hide the specific layout used by the ECC
controller and consider the passed data as contiguous
in-band and out-of-band data. ECC controller is
responsible for doing the appropriate transformations
to adapt to its specific layout (e.g.
NAND_ECC_HW_SYNDROME interleaves in-band and
out-of-band data).</dd>
<dt><code class="docutils literal"><span class="pre">read_page</span></code></dt>
<dd>function to read a page according to the ECC generator
requirements; returns maximum number of bitflips corrected in
any single ECC step, -EIO hw error</dd>
<dt><code class="docutils literal"><span class="pre">read_subpage</span></code></dt>
<dd>function to read parts of the page covered by ECC;
returns same as <code class="xref c c-func docutils literal"><span class="pre">read_page()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">write_subpage</span></code></dt>
<dd>function to write parts of the page covered by ECC.</dd>
<dt><code class="docutils literal"><span class="pre">write_page</span></code></dt>
<dd>function to write a page according to the ECC generator
requirements.</dd>
<dt><code class="docutils literal"><span class="pre">write_oob_raw</span></code></dt>
<dd>function to write chip OOB data without ECC</dd>
<dt><code class="docutils literal"><span class="pre">read_oob_raw</span></code></dt>
<dd>function to read chip OOB data without ECC</dd>
<dt><code class="docutils literal"><span class="pre">read_oob</span></code></dt>
<dd>function to read chip OOB data</dd>
<dt><code class="docutils literal"><span class="pre">write_oob</span></code></dt>
<dd>function to write chip OOB data</dd>
</dl>
<dl class="type">
<dt id="c.nand_buffers">
struct <code class="descname">nand_buffers</code><a class="headerlink" href="#c.nand_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>buffer structure for read/write</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_buffers {
  uint8_t * ecccalc;
  uint8_t * ecccode;
  uint8_t * databuf;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ecccalc</span></code></dt>
<dd>buffer pointer for calculated ECC, size is oobsize.</dd>
<dt><code class="docutils literal"><span class="pre">ecccode</span></code></dt>
<dd>buffer pointer for ECC read from flash, size is oobsize.</dd>
<dt><code class="docutils literal"><span class="pre">databuf</span></code></dt>
<dd>buffer pointer for data, size is (page size + oobsize).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not change the order of buffers. databuf and oobrbuf must be in
consecutive order.</p>
<dl class="type">
<dt id="c.nand_sdr_timings">
struct <code class="descname">nand_sdr_timings</code><a class="headerlink" href="#c.nand_sdr_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>SDR NAND chip timings</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_sdr_timings {
  u64 tBERS_max;
  u32 tCCS_min;
  u64 tPROG_max;
  u64 tR_max;
  u32 tALH_min;
  u32 tADL_min;
  u32 tALS_min;
  u32 tAR_min;
  u32 tCEA_max;
  u32 tCEH_min;
  u32 tCH_min;
  u32 tCHZ_max;
  u32 tCLH_min;
  u32 tCLR_min;
  u32 tCLS_min;
  u32 tCOH_min;
  u32 tCS_min;
  u32 tDH_min;
  u32 tDS_min;
  u32 tFEAT_max;
  u32 tIR_min;
  u32 tITC_max;
  u32 tRC_min;
  u32 tREA_max;
  u32 tREH_min;
  u32 tRHOH_min;
  u32 tRHW_min;
  u32 tRHZ_max;
  u32 tRLOH_min;
  u32 tRP_min;
  u32 tRR_min;
  u64 tRST_max;
  u32 tWB_max;
  u32 tWC_min;
  u32 tWH_min;
  u32 tWHR_min;
  u32 tWP_min;
  u32 tWW_min;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tBERS_max</span></code></dt>
<dd>Block erase time</dd>
<dt><code class="docutils literal"><span class="pre">tCCS_min</span></code></dt>
<dd>Change column setup time</dd>
<dt><code class="docutils literal"><span class="pre">tPROG_max</span></code></dt>
<dd>Page program time</dd>
<dt><code class="docutils literal"><span class="pre">tR_max</span></code></dt>
<dd>Page read time</dd>
<dt><code class="docutils literal"><span class="pre">tALH_min</span></code></dt>
<dd>ALE hold time</dd>
<dt><code class="docutils literal"><span class="pre">tADL_min</span></code></dt>
<dd>ALE to data loading time</dd>
<dt><code class="docutils literal"><span class="pre">tALS_min</span></code></dt>
<dd>ALE setup time</dd>
<dt><code class="docutils literal"><span class="pre">tAR_min</span></code></dt>
<dd>ALE to RE# delay</dd>
<dt><code class="docutils literal"><span class="pre">tCEA_max</span></code></dt>
<dd>CE# access time</dd>
<dt><code class="docutils literal"><span class="pre">tCEH_min</span></code></dt>
<dd>CE# high hold time</dd>
<dt><code class="docutils literal"><span class="pre">tCH_min</span></code></dt>
<dd>CE# hold time</dd>
<dt><code class="docutils literal"><span class="pre">tCHZ_max</span></code></dt>
<dd>CE# high to output hi-Z</dd>
<dt><code class="docutils literal"><span class="pre">tCLH_min</span></code></dt>
<dd>CLE hold time</dd>
<dt><code class="docutils literal"><span class="pre">tCLR_min</span></code></dt>
<dd>CLE to RE# delay</dd>
<dt><code class="docutils literal"><span class="pre">tCLS_min</span></code></dt>
<dd>CLE setup time</dd>
<dt><code class="docutils literal"><span class="pre">tCOH_min</span></code></dt>
<dd>CE# high to output hold</dd>
<dt><code class="docutils literal"><span class="pre">tCS_min</span></code></dt>
<dd>CE# setup time</dd>
<dt><code class="docutils literal"><span class="pre">tDH_min</span></code></dt>
<dd>Data hold time</dd>
<dt><code class="docutils literal"><span class="pre">tDS_min</span></code></dt>
<dd>Data setup time</dd>
<dt><code class="docutils literal"><span class="pre">tFEAT_max</span></code></dt>
<dd>Busy time for Set Features and Get Features</dd>
<dt><code class="docutils literal"><span class="pre">tIR_min</span></code></dt>
<dd>Output hi-Z to RE# low</dd>
<dt><code class="docutils literal"><span class="pre">tITC_max</span></code></dt>
<dd>Interface and Timing Mode Change time</dd>
<dt><code class="docutils literal"><span class="pre">tRC_min</span></code></dt>
<dd>RE# cycle time</dd>
<dt><code class="docutils literal"><span class="pre">tREA_max</span></code></dt>
<dd>RE# access time</dd>
<dt><code class="docutils literal"><span class="pre">tREH_min</span></code></dt>
<dd>RE# high hold time</dd>
<dt><code class="docutils literal"><span class="pre">tRHOH_min</span></code></dt>
<dd>RE# high to output hold</dd>
<dt><code class="docutils literal"><span class="pre">tRHW_min</span></code></dt>
<dd>RE# high to WE# low</dd>
<dt><code class="docutils literal"><span class="pre">tRHZ_max</span></code></dt>
<dd>RE# high to output hi-Z</dd>
<dt><code class="docutils literal"><span class="pre">tRLOH_min</span></code></dt>
<dd>RE# low to output hold</dd>
<dt><code class="docutils literal"><span class="pre">tRP_min</span></code></dt>
<dd>RE# pulse width</dd>
<dt><code class="docutils literal"><span class="pre">tRR_min</span></code></dt>
<dd>Ready to RE# low (data only)</dd>
<dt><code class="docutils literal"><span class="pre">tRST_max</span></code></dt>
<dd>Device reset time, measured from the falling edge of R/B# to the
rising edge of R/B#.</dd>
<dt><code class="docutils literal"><span class="pre">tWB_max</span></code></dt>
<dd>WE# high to SR[6] low</dd>
<dt><code class="docutils literal"><span class="pre">tWC_min</span></code></dt>
<dd>WE# cycle time</dd>
<dt><code class="docutils literal"><span class="pre">tWH_min</span></code></dt>
<dd>WE# high hold time</dd>
<dt><code class="docutils literal"><span class="pre">tWHR_min</span></code></dt>
<dd>WE# high to RE# low</dd>
<dt><code class="docutils literal"><span class="pre">tWP_min</span></code></dt>
<dd>WE# pulse width</dd>
<dt><code class="docutils literal"><span class="pre">tWW_min</span></code></dt>
<dd>WP# transition to WE# low</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct defines the timing requirements of a SDR NAND chip.
These information can be found in every NAND datasheets and the timings
meaning are described in the ONFI specifications:
www.onfi.org/~/media/ONFI/specs/onfi_3_1_spec.pdf (chapter 4.15 Timing
Parameters)</p>
<p>All these timings are expressed in picoseconds.</p>
<dl class="type">
<dt id="c.nand_data_interface_type">
enum <code class="descname">nand_data_interface_type</code><a class="headerlink" href="#c.nand_data_interface_type" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND interface timing type</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">NAND_SDR_IFACE</span></code></dt>
<dd>Single Data Rate interface</dd>
</dl>
<dl class="type">
<dt id="c.nand_data_interface">
struct <code class="descname">nand_data_interface</code><a class="headerlink" href="#c.nand_data_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND interface timing</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_data_interface {
  enum nand_data_interface_type type;
  union timings;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the timing</dd>
<dt><code class="docutils literal"><span class="pre">timings</span></code></dt>
<dd>The timing, type according to <strong>type</strong></dd>
</dl>
<dl class="function">
<dt id="c.nand_get_sdr_timings">
const struct <a class="reference internal" href="#c.nand_sdr_timings" title="nand_sdr_timings">nand_sdr_timings</a> * <code class="descname">nand_get_sdr_timings</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.nand_data_interface" title="nand_data_interface">nand_data_interface</a> *<em>&nbsp;conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_sdr_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>get SDR timing from data interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_data_interface</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>The data interface</dd>
</dl>
<dl class="type">
<dt id="c.nand_manufacturer_ops">
struct <code class="descname">nand_manufacturer_ops</code><a class="headerlink" href="#c.nand_manufacturer_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND Manufacturer operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_manufacturer_ops {
  void (* detect) (struct nand_chip *chip);
  int (* init) (struct nand_chip *chip);
  void (* cleanup) (struct nand_chip *chip);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">detect</span></code></dt>
<dd>detect the NAND memory organization and capabilities</dd>
<dt><code class="docutils literal"><span class="pre">init</span></code></dt>
<dd>initialize all vendor specific fields (like the -&gt;:c:func:<cite>read_retry()</cite>
implementation) if any.</dd>
<dt><code class="docutils literal"><span class="pre">cleanup</span></code></dt>
<dd>the -&gt;:c:func:<cite>init()</cite> function may have allocated resources, -&gt;:c:func:<cite>cleanup()</cite>
is here to let vendor specific code release those resources.</dd>
</dl>
<dl class="type">
<dt id="c.nand_chip">
struct <code class="descname">nand_chip</code><a class="headerlink" href="#c.nand_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND Private Flash Chip Data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_chip {
  struct mtd_info mtd;
  void __iomem * IO_ADDR_R;
  void __iomem * IO_ADDR_W;
  uint8_t (* read_byte) (struct mtd_info *mtd);
  u16 (* read_word) (struct mtd_info *mtd);
  void (* write_byte) (struct mtd_info *mtd, uint8_t byte);
  void (* write_buf) (struct mtd_info *mtd, const uint8_t *buf, int len);
  void (* read_buf) (struct mtd_info *mtd, uint8_t *buf, int len);
  void (* select_chip) (struct mtd_info *mtd, int chip);
  int (* block_bad) (struct mtd_info *mtd, loff_t ofs);
  int (* block_markbad) (struct mtd_info *mtd, loff_t ofs);
  void (* cmd_ctrl) (struct mtd_info *mtd, int dat, unsigned int ctrl);
  int (* dev_ready) (struct mtd_info *mtd);
  void (* cmdfunc) (struct mtd_info *mtd, unsigned command, int column, int page_addr);
  int(* waitfunc) (struct mtd_info *mtd, struct nand_chip *this);
  int (* erase) (struct mtd_info *mtd, int page);
  int (* scan_bbt) (struct mtd_info *mtd);
  int (* onfi_set_features) (struct mtd_info *mtd, struct nand_chip *chip, int feature_addr, uint8_t *subfeature_para);
  int (* onfi_get_features) (struct mtd_info *mtd, struct nand_chip *chip, int feature_addr, uint8_t *subfeature_para);
  int (* setup_read_retry) (struct mtd_info *mtd, int retry_mode);
  int (* setup_data_interface) (struct mtd_info *mtd, int chipnr, const struct nand_data_interface *conf);
  int chip_delay;
  unsigned int options;
  unsigned int bbt_options;
  int page_shift;
  int phys_erase_shift;
  int bbt_erase_shift;
  int chip_shift;
  int numchips;
  uint64_t chipsize;
  int pagemask;
  int pagebuf;
  unsigned int pagebuf_bitflips;
  int subpagesize;
  uint8_t bits_per_cell;
  uint16_t ecc_strength_ds;
  uint16_t ecc_step_ds;
  int onfi_timing_mode_default;
  int badblockpos;
  int badblockbits;
  struct nand_id id;
  int onfi_version;
  int jedec_version;
  union manufacturer;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mtd</span></code></dt>
<dd>MTD device registered to the MTD framework</dd>
<dt><code class="docutils literal"><span class="pre">IO_ADDR_R</span></code></dt>
<dd>[BOARDSPECIFIC] address to read the 8 I/O lines of the
flash device</dd>
<dt><code class="docutils literal"><span class="pre">IO_ADDR_W</span></code></dt>
<dd>[BOARDSPECIFIC] address to write the 8 I/O lines of the
flash device.</dd>
<dt><code class="docutils literal"><span class="pre">read_byte</span></code></dt>
<dd>[REPLACEABLE] read one byte from the chip</dd>
<dt><code class="docutils literal"><span class="pre">read_word</span></code></dt>
<dd>[REPLACEABLE] read one word from the chip</dd>
<dt><code class="docutils literal"><span class="pre">write_byte</span></code></dt>
<dd>[REPLACEABLE] write a single byte to the chip on the
low 8 I/O lines</dd>
<dt><code class="docutils literal"><span class="pre">write_buf</span></code></dt>
<dd>[REPLACEABLE] write data from the buffer to the chip</dd>
<dt><code class="docutils literal"><span class="pre">read_buf</span></code></dt>
<dd>[REPLACEABLE] read data from the chip into the buffer</dd>
<dt><code class="docutils literal"><span class="pre">select_chip</span></code></dt>
<dd>[REPLACEABLE] select chip nr</dd>
<dt><code class="docutils literal"><span class="pre">block_bad</span></code></dt>
<dd>[REPLACEABLE] check if a block is bad, using OOB markers</dd>
<dt><code class="docutils literal"><span class="pre">block_markbad</span></code></dt>
<dd>[REPLACEABLE] mark a block bad</dd>
<dt><code class="docutils literal"><span class="pre">cmd_ctrl</span></code></dt>
<dd>[BOARDSPECIFIC] hardwarespecific function for controlling
ALE/CLE/nCE. Also used to write command and address</dd>
<dt><code class="docutils literal"><span class="pre">dev_ready</span></code></dt>
<dd>[BOARDSPECIFIC] hardwarespecific function for accessing
device ready/busy line. If set to NULL no access to
ready/busy is available and the ready/busy information
is read from the chip status register.</dd>
<dt><code class="docutils literal"><span class="pre">cmdfunc</span></code></dt>
<dd>[REPLACEABLE] hardwarespecific function for writing
commands to the chip.</dd>
<dt><code class="docutils literal"><span class="pre">waitfunc</span></code></dt>
<dd>[REPLACEABLE] hardwarespecific function for wait on
ready.</dd>
<dt><code class="docutils literal"><span class="pre">erase</span></code></dt>
<dd>[REPLACEABLE] erase function</dd>
<dt><code class="docutils literal"><span class="pre">scan_bbt</span></code></dt>
<dd>[REPLACEABLE] function to scan bad block table</dd>
<dt><code class="docutils literal"><span class="pre">onfi_set_features</span></code></dt>
<dd>[REPLACEABLE] set the features for ONFI nand</dd>
<dt><code class="docutils literal"><span class="pre">onfi_get_features</span></code></dt>
<dd>[REPLACEABLE] get the features for ONFI nand</dd>
<dt><code class="docutils literal"><span class="pre">setup_read_retry</span></code></dt>
<dd>[FLASHSPECIFIC] flash (vendor) specific function for
setting the read-retry mode. Mostly needed for MLC NAND.</dd>
<dt><code class="docutils literal"><span class="pre">setup_data_interface</span></code></dt>
<dd>[OPTIONAL] setup the data interface and timing. If
chipnr is set to <code class="docutils literal"><span class="pre">NAND_DATA_IFACE_CHECK_ONLY</span></code> this
means the configuration should not be applied but
only checked.</dd>
<dt><code class="docutils literal"><span class="pre">chip_delay</span></code></dt>
<dd>[BOARDSPECIFIC] chip dependent delay for transferring
data from array to read regs (tR).</dd>
<dt><code class="docutils literal"><span class="pre">options</span></code></dt>
<dd>[BOARDSPECIFIC] various chip options. They can partly
be set to inform nand_scan about special functionality.
See the defines for further explanation.</dd>
<dt><code class="docutils literal"><span class="pre">bbt_options</span></code></dt>
<dd>[INTERN] bad block specific options. All options used
here must come from bbm.h. By default, these options
will be copied to the appropriate nand_bbt_descr’s.</dd>
<dt><code class="docutils literal"><span class="pre">page_shift</span></code></dt>
<dd>[INTERN] number of address bits in a page (column
address bits).</dd>
<dt><code class="docutils literal"><span class="pre">phys_erase_shift</span></code></dt>
<dd>[INTERN] number of address bits in a physical eraseblock</dd>
<dt><code class="docutils literal"><span class="pre">bbt_erase_shift</span></code></dt>
<dd>[INTERN] number of address bits in a bbt entry</dd>
<dt><code class="docutils literal"><span class="pre">chip_shift</span></code></dt>
<dd>[INTERN] number of address bits in one chip</dd>
<dt><code class="docutils literal"><span class="pre">numchips</span></code></dt>
<dd>[INTERN] number of physical chips</dd>
<dt><code class="docutils literal"><span class="pre">chipsize</span></code></dt>
<dd>[INTERN] the size of one chip for multichip arrays</dd>
<dt><code class="docutils literal"><span class="pre">pagemask</span></code></dt>
<dd>[INTERN] page number mask = number of (pages / chip) - 1</dd>
<dt><code class="docutils literal"><span class="pre">pagebuf</span></code></dt>
<dd>[INTERN] holds the pagenumber which is currently in
data_buf.</dd>
<dt><code class="docutils literal"><span class="pre">pagebuf_bitflips</span></code></dt>
<dd>[INTERN] holds the bitflip count for the page which is
currently in data_buf.</dd>
<dt><code class="docutils literal"><span class="pre">subpagesize</span></code></dt>
<dd>[INTERN] holds the subpagesize</dd>
<dt><code class="docutils literal"><span class="pre">bits_per_cell</span></code></dt>
<dd>[INTERN] number of bits per cell. i.e., 1 means SLC.</dd>
<dt><code class="docutils literal"><span class="pre">ecc_strength_ds</span></code></dt>
<dd>[INTERN] ECC correctability from the datasheet.
Minimum amount of bit errors per <strong>ecc_step_ds</strong> guaranteed
to be correctable. If unknown, set to zero.</dd>
<dt><code class="docutils literal"><span class="pre">ecc_step_ds</span></code></dt>
<dd>[INTERN] ECC step required by the <strong>ecc_strength_ds</strong>,
also from the datasheet. It is the recommended ECC step
size, if known; if unknown, set to zero.</dd>
<dt><code class="docutils literal"><span class="pre">onfi_timing_mode_default</span></code></dt>
<dd>[INTERN] default ONFI timing mode. This field is
set to the actually used ONFI mode if the chip is
ONFI compliant or deduced from the datasheet if
the NAND chip is not ONFI compliant.</dd>
<dt><code class="docutils literal"><span class="pre">badblockpos</span></code></dt>
<dd>[INTERN] position of the bad block marker in the oob
area.</dd>
<dt><code class="docutils literal"><span class="pre">badblockbits</span></code></dt>
<dd>[INTERN] minimum number of set bits in a good block’s
bad block marker position; i.e., BBM == 11110111b is
not bad when badblockbits == 7</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>[INTERN] holds NAND ID</dd>
<dt><code class="docutils literal"><span class="pre">onfi_version</span></code></dt>
<dd>[INTERN] holds the chip ONFI version (BCD encoded),
non 0 if ONFI supported.</dd>
<dt><code class="docutils literal"><span class="pre">jedec_version</span></code></dt>
<dd>[INTERN] holds the chip JEDEC version (BCD encoded),
non 0 if JEDEC supported.</dd>
<dt><code class="docutils literal"><span class="pre">manufacturer</span></code></dt>
<dd>[INTERN] Contains manufacturer information</dd>
</dl>
<dl class="type">
<dt id="c.nand_flash_dev">
struct <code class="descname">nand_flash_dev</code><a class="headerlink" href="#c.nand_flash_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND Flash Device ID Structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_flash_dev {
  char * name;
  union ecc;
  int onfi_timing_mode_default;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>a human-readable name of the NAND chip</dd>
<dt><code class="docutils literal"><span class="pre">ecc</span></code></dt>
<dd>The ECC step required by the <strong>ecc</strong>.strength_ds, same as the
<strong>ecc_step_ds</strong> in nand_chip{}, also from the datasheet.
For example, the “4bit ECC for each 512Byte” can be set with
NAND_ECC_INFO(4, 512).</dd>
<dt><code class="docutils literal"><span class="pre">onfi_timing_mode_default</span></code></dt>
<dd>the default ONFI timing mode entered after a NAND
reset. Should be deduced from timings described
in the datasheet.</dd>
</dl>
<dl class="type">
<dt id="c.nand_manufacturer">
struct <code class="descname">nand_manufacturer</code><a class="headerlink" href="#c.nand_manufacturer" title="Permalink to this definition">¶</a></dt>
<dd><p>NAND Flash Manufacturer structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct nand_manufacturer {
  int id;
  char * name;
  const struct nand_manufacturer_ops * ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>manufacturer ID code of device.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Manufacturer name</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>manufacturer operations</dd>
</dl>
<dl class="type">
<dt id="c.platform_nand_chip">
struct <code class="descname">platform_nand_chip</code><a class="headerlink" href="#c.platform_nand_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>chip level device structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct platform_nand_chip {
  int nr_chips;
  int chip_offset;
  int nr_partitions;
  struct mtd_partition * partitions;
  int chip_delay;
  unsigned int options;
  unsigned int bbt_options;
  const char ** part_probe_types;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">nr_chips</span></code></dt>
<dd>max. number of chips to scan for</dd>
<dt><code class="docutils literal"><span class="pre">chip_offset</span></code></dt>
<dd>chip number offset</dd>
<dt><code class="docutils literal"><span class="pre">nr_partitions</span></code></dt>
<dd>number of partitions pointed to by partitions (or zero)</dd>
<dt><code class="docutils literal"><span class="pre">partitions</span></code></dt>
<dd>mtd partition list</dd>
<dt><code class="docutils literal"><span class="pre">chip_delay</span></code></dt>
<dd>R/B delay value in us</dd>
<dt><code class="docutils literal"><span class="pre">options</span></code></dt>
<dd>Option flags, e.g. 16bit buswidth</dd>
<dt><code class="docutils literal"><span class="pre">bbt_options</span></code></dt>
<dd>BBT option flags, e.g. NAND_BBT_USE_FLASH</dd>
<dt><code class="docutils literal"><span class="pre">part_probe_types</span></code></dt>
<dd>NULL-terminated array of probe types</dd>
</dl>
<dl class="type">
<dt id="c.platform_nand_ctrl">
struct <code class="descname">platform_nand_ctrl</code><a class="headerlink" href="#c.platform_nand_ctrl" title="Permalink to this definition">¶</a></dt>
<dd><p>controller level device structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct platform_nand_ctrl {
  int (* probe) (struct platform_device *pdev);
  void (* remove) (struct platform_device *pdev);
  void (* hwcontrol) (struct mtd_info *mtd, int cmd);
  int (* dev_ready) (struct mtd_info *mtd);
  void (* select_chip) (struct mtd_info *mtd, int chip);
  void (* cmd_ctrl) (struct mtd_info *mtd, int dat, unsigned int ctrl);
  void (* write_buf) (struct mtd_info *mtd, const uint8_t *buf, int len);
  void (* read_buf) (struct mtd_info *mtd, uint8_t *buf, int len);
  unsigned char (* read_byte) (struct mtd_info *mtd);
  void * priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>platform specific function to probe/setup hardware</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>platform specific function to remove/teardown hardware</dd>
<dt><code class="docutils literal"><span class="pre">hwcontrol</span></code></dt>
<dd>platform specific hardware control structure</dd>
<dt><code class="docutils literal"><span class="pre">dev_ready</span></code></dt>
<dd>platform specific function to read ready/busy pin</dd>
<dt><code class="docutils literal"><span class="pre">select_chip</span></code></dt>
<dd>platform specific chip select function</dd>
<dt><code class="docutils literal"><span class="pre">cmd_ctrl</span></code></dt>
<dd>platform specific function for controlling
ALE/CLE/nCE. Also used to write command and address</dd>
<dt><code class="docutils literal"><span class="pre">write_buf</span></code></dt>
<dd>platform specific function for write buffer</dd>
<dt><code class="docutils literal"><span class="pre">read_buf</span></code></dt>
<dd>platform specific function for read buffer</dd>
<dt><code class="docutils literal"><span class="pre">read_byte</span></code></dt>
<dd>platform specific function to read one byte from chip</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>private data to transport driver specific settings</dd>
</dl>
<p><strong>Description</strong></p>
<p>All fields are optional and depend on the hardware driver requirements</p>
<dl class="type">
<dt id="c.platform_nand_data">
struct <code class="descname">platform_nand_data</code><a class="headerlink" href="#c.platform_nand_data" title="Permalink to this definition">¶</a></dt>
<dd><p>container structure for platform-specific data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct platform_nand_data {
  struct platform_nand_chip chip;
  struct platform_nand_ctrl ctrl;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">chip</span></code></dt>
<dd>chip level chip structure</dd>
<dt><code class="docutils literal"><span class="pre">ctrl</span></code></dt>
<dd>controller level device structure</dd>
</dl>
<dl class="function">
<dt id="c.nand_opcode_8bits">
int <code class="descname">nand_opcode_8bits</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;command</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_opcode_8bits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">command</span></code></dt>
<dd>opcode to check</dd>
</dl>
</div>
<div class="section" id="public-functions-provided">
<h2>Public Functions Provided<a class="headerlink" href="#public-functions-provided" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the NAND kernel
API functions which are exported. Each function has a short description
which is marked with an [XXX] identifier. See the chapter “Documentation
hints” for an explanation.</p>
<dl class="function">
<dt id="c.nand_wait_ready">
void <code class="descname">nand_wait_ready</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_wait_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Wait for the ready pin after commands.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for the ready pin after a command, and warn if a timeout occurs.</p>
<dl class="function">
<dt id="c.nand_check_erased_ecc_chunk">
int <code class="descname">nand_check_erased_ecc_chunk</code><span class="sig-paren">(</span>void *<em>&nbsp;data</em>, int<em>&nbsp;datalen</em>, void *<em>&nbsp;ecc</em>, int<em>&nbsp;ecclen</em>, void *<em>&nbsp;extraoob</em>, int<em>&nbsp;extraooblen</em>, int<em>&nbsp;bitflips_threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_check_erased_ecc_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>check if an ECC chunk contains (almost) only 0xff data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data buffer to test</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">datalen</span></code></dt>
<dd>data length</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ecc</span></code></dt>
<dd>ECC buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ecclen</span></code></dt>
<dd>ECC length</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">extraoob</span></code></dt>
<dd>extra OOB buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">extraooblen</span></code></dt>
<dd>extra OOB length</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bitflips_threshold</span></code></dt>
<dd>maximum number of bitflips</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if a data buffer and its associated ECC and OOB data contains only
0xff pattern, which means the underlying region has been erased and is
ready to be programmed.
The bitflips_threshold specify the maximum number of bitflips before
considering the region as not erased.</p>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>1/ ECC algorithms are working on pre-defined block sizes which are usually</dt>
<dd>different from the NAND page size. When fixing bitflips, ECC engines will
report the number of errors per chunk, and the NAND core infrastructure
expect you to return the maximum number of bitflips for the whole page.
This is why you should always use this function on a single chunk and
not on the whole page. After checking each chunk you should update your
max_bitflips value accordingly.</dd>
<dt>2/ When checking for bitflips in erased pages you should not only check</dt>
<dd>the payload data but also their associated ECC data, because a user might
have programmed almost all bits to 1 but a few. In this case, we
shouldn’t consider the chunk as erased, and checking ECC bytes prevent
this case.</dd>
<dt>3/ The extraoob argument is optional, and should be used if some of your OOB</dt>
<dd>data are protected by the ECC engine.
It could also be used if you support subpages and want to attach some
extra OOB data to an ECC chunk.</dd>
</dl>
<p>Returns a positive number of bitflips less than or equal to
bitflips_threshold, or -ERROR_CODE for bitflips in excess of the
threshold. In case of success, the passed buffers are filled with 0xff.</p>
<dl class="function">
<dt id="c.nand_read_page_raw">
int <code class="descname">nand_read_page_raw</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] read raw page data without ecc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store read data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>caller requires OOB data read to chip-&gt;oob_poi</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not for syndrome calculating ECC controllers, which use a special oob layout.</p>
<dl class="function">
<dt id="c.nand_read_oob_std">
int <code class="descname">nand_read_oob_std</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_oob_std" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] the most common OOB data read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<dl class="function">
<dt id="c.nand_read_oob_syndrome">
int <code class="descname">nand_read_oob_syndrome</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_oob_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] OOB data read function for HW ECC with syndromes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<dl class="function">
<dt id="c.nand_write_oob_std">
int <code class="descname">nand_write_oob_std</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_oob_std" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] the most common OOB data write function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
</dl>
<dl class="function">
<dt id="c.nand_write_oob_syndrome">
int <code class="descname">nand_write_oob_syndrome</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_oob_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] OOB data write function for HW ECC with syndrome - only for large page flash</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
</dl>
<dl class="function">
<dt id="c.nand_write_page_raw">
int <code class="descname">nand_write_page_raw</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] raw page write function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>must write chip-&gt;oob_poi to OOB</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not for syndrome calculating ECC controllers, which use a special oob layout.</p>
<dl class="function">
<dt id="c.nand_onfi_get_set_features_notsupp">
int <code class="descname">nand_onfi_get_set_features_notsupp</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;addr</em>, u8 *<em>&nbsp;subfeature_param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_onfi_get_set_features_notsupp" title="Permalink to this definition">¶</a></dt>
<dd><p>set/get features stub returning -ENOTSUPP</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>feature address.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">subfeature_param</span></code></dt>
<dd>the subfeature parameters, a four bytes array.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be used by NAND controller drivers that do not support the SET/GET
FEATURES operations.</p>
<dl class="function">
<dt id="c.nand_scan_ident">
int <code class="descname">nand_scan_ident</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, int<em>&nbsp;maxchips</em>, struct <a class="reference internal" href="#c.nand_flash_dev" title="nand_flash_dev">nand_flash_dev</a> *<em>&nbsp;table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_scan_ident" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Scan for the NAND device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">maxchips</span></code></dt>
<dd>number of chips to scan for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_flash_dev</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>alternative NAND ID table</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first phase of the normal <a class="reference internal" href="#c.nand_scan" title="nand_scan"><code class="xref c c-func docutils literal"><span class="pre">nand_scan()</span></code></a> function. It reads the
flash ID and sets up MTD fields accordingly.</p>
<dl class="function">
<dt id="c.nand_check_ecc_caps">
int <code class="descname">nand_check_ecc_caps</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, const struct <a class="reference internal" href="#c.nand_ecc_caps" title="nand_ecc_caps">nand_ecc_caps</a> *<em>&nbsp;caps</em>, int<em>&nbsp;oobavail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_check_ecc_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>check the sanity of preset ECC settings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_ecc_caps</span> <span class="pre">*</span> <span class="pre">caps</span></code></dt>
<dd>ECC caps info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oobavail</span></code></dt>
<dd>OOB size that the ECC engine can use</dd>
</dl>
<p><strong>Description</strong></p>
<p>When ECC step size and strength are already set, check if they are supported
by the controller and the calculated ECC bytes fit within the chip’s OOB.
On success, the calculated ECC bytes is set.</p>
<dl class="function">
<dt id="c.nand_match_ecc_req">
int <code class="descname">nand_match_ecc_req</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, const struct <a class="reference internal" href="#c.nand_ecc_caps" title="nand_ecc_caps">nand_ecc_caps</a> *<em>&nbsp;caps</em>, int<em>&nbsp;oobavail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_match_ecc_req" title="Permalink to this definition">¶</a></dt>
<dd><p>meet the chip’s requirement with least ECC bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_ecc_caps</span> <span class="pre">*</span> <span class="pre">caps</span></code></dt>
<dd>ECC engine caps info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oobavail</span></code></dt>
<dd>OOB size that the ECC engine can use</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a chip’s ECC requirement is provided, try to meet it with the least
number of ECC bytes (i.e. with the largest number of OOB-free bytes).
On success, the chosen ECC settings are set.</p>
<dl class="function">
<dt id="c.nand_maximize_ecc">
int <code class="descname">nand_maximize_ecc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, const struct <a class="reference internal" href="#c.nand_ecc_caps" title="nand_ecc_caps">nand_ecc_caps</a> *<em>&nbsp;caps</em>, int<em>&nbsp;oobavail</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_maximize_ecc" title="Permalink to this definition">¶</a></dt>
<dd><p>choose the max ECC strength available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">nand_ecc_caps</span> <span class="pre">*</span> <span class="pre">caps</span></code></dt>
<dd>ECC engine caps info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oobavail</span></code></dt>
<dd>OOB size that the ECC engine can use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Choose the max ECC strength that is supported on the controller, and can fit
within the chip’s OOB.  On success, the chosen ECC settings are set.</p>
<dl class="function">
<dt id="c.nand_scan_tail">
int <code class="descname">nand_scan_tail</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_scan_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Scan for the NAND device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the second phase of the normal <a class="reference internal" href="#c.nand_scan" title="nand_scan"><code class="xref c c-func docutils literal"><span class="pre">nand_scan()</span></code></a> function. It fills out
all the uninitialized function pointers with the defaults and scans for a
bad block table if appropriate.</p>
<dl class="function">
<dt id="c.nand_scan">
int <code class="descname">nand_scan</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, int<em>&nbsp;maxchips</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Scan for the NAND device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">maxchips</span></code></dt>
<dd>number of chips to scan for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This fills out all the uninitialized function pointers with the defaults.
The flash ID is read and the mtd/chip structures are filled with the
appropriate values.</p>
<dl class="function">
<dt id="c.nand_cleanup">
void <code class="descname">nand_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Free resources held by the NAND device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>NAND chip object</dd>
</dl>
<dl class="function">
<dt id="c.nand_release">
void <code class="descname">nand_release</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_release" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Unregister the MTD device and free resources held by the NAND device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<dl class="function">
<dt id="c.__nand_calculate_ecc">
void <code class="descname">__nand_calculate_ecc</code><span class="sig-paren">(</span>const unsigned char *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;eccsize</em>, unsigned char *<em>&nbsp;code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__nand_calculate_ecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Calculate 3-byte ECC for 256/512-byte block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>input buffer with raw data</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">eccsize</span></code></dt>
<dd>data bytes per ECC step (256 or 512)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">code</span></code></dt>
<dd>output buffer with ECC</dd>
</dl>
<dl class="function">
<dt id="c.nand_calculate_ecc">
int <code class="descname">nand_calculate_ecc</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, const unsigned char *<em>&nbsp;buf</em>, unsigned char *<em>&nbsp;code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_calculate_ecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Calculate 3-byte ECC for 256/512-byte block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD block structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>input buffer with raw data</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">code</span></code></dt>
<dd>output buffer with ECC</dd>
</dl>
<dl class="function">
<dt id="c.__nand_correct_data">
int <code class="descname">__nand_correct_data</code><span class="sig-paren">(</span>unsigned char *<em>&nbsp;buf</em>, unsigned char *<em>&nbsp;read_ecc</em>, unsigned char *<em>&nbsp;calc_ecc</em>, unsigned int<em>&nbsp;eccsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__nand_correct_data" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Detect and correct bit error(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>raw data read from the chip</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">read_ecc</span></code></dt>
<dd>ECC from the chip</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">calc_ecc</span></code></dt>
<dd>the ECC calculated from raw data</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">eccsize</span></code></dt>
<dd>data bytes per ECC step (256 or 512)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Detect and correct a 1 bit error for eccsize byte block</p>
<dl class="function">
<dt id="c.nand_correct_data">
int <code class="descname">nand_correct_data</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, unsigned char *<em>&nbsp;buf</em>, unsigned char *<em>&nbsp;read_ecc</em>, unsigned char *<em>&nbsp;calc_ecc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_correct_data" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Detect and correct bit error(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD block structure</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>raw data read from the chip</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">read_ecc</span></code></dt>
<dd>ECC from the chip</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">calc_ecc</span></code></dt>
<dd>the ECC calculated from raw data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Detect and correct a 1 bit error for 256/512 byte block</p>
</div>
<div class="section" id="internal-functions-provided">
<h2>Internal Functions Provided<a class="headerlink" href="#internal-functions-provided" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains the autogenerated documentation of the NAND driver
internal functions. Each function has a short description which is
marked with an [XXX] identifier. See the chapter “Documentation hints”
for an explanation. The functions marked with [DEFAULT] might be
relevant for a board driver developer.</p>
<dl class="function">
<dt id="c.nand_release_device">
void <code class="descname">nand_release_device</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_release_device" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] release chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release chip lock and wake up anyone waiting on the device.</p>
<dl class="function">
<dt id="c.nand_read_byte">
uint8_t <code class="descname">nand_read_byte</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] read one byte from the chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default read function for 8bit buswidth</p>
<dl class="function">
<dt id="c.nand_read_byte16">
uint8_t <code class="descname">nand_read_byte16</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_byte16" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] read one byte endianness aware from the chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default read function for 16bit buswidth with endianness conversion.</p>
<dl class="function">
<dt id="c.nand_read_word">
u16 <code class="descname">nand_read_word</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_word" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] read one word from the chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default read function for 16bit buswidth without endianness conversion.</p>
<dl class="function">
<dt id="c.nand_select_chip">
void <code class="descname">nand_select_chip</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, int<em>&nbsp;chipnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_select_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] control CE line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chipnr</span></code></dt>
<dd>chipnumber to select, -1 for deselect</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default select function for 1 chip devices.</p>
<dl class="function">
<dt id="c.nand_write_byte">
void <code class="descname">nand_write_byte</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t<em>&nbsp;byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] write single byte to chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">byte</span></code></dt>
<dd>value to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default function to write a byte to I/O[7:0]</p>
<dl class="function">
<dt id="c.nand_write_byte16">
void <code class="descname">nand_write_byte16</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t<em>&nbsp;byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_byte16" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] write single byte to a chip with width 16</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">byte</span></code></dt>
<dd>value to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default function to write a byte to I/O[7:0] on a 16-bit wide chip.</p>
<dl class="function">
<dt id="c.nand_write_buf">
void <code class="descname">nand_write_buf</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] write buffer to chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default write function for 8bit buswidth.</p>
<dl class="function">
<dt id="c.nand_read_buf">
void <code class="descname">nand_read_buf</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] read chip data into buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store date</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default read function for 8bit buswidth.</p>
<dl class="function">
<dt id="c.nand_write_buf16">
void <code class="descname">nand_write_buf16</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_buf16" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] write buffer to chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default write function for 16bit buswidth.</p>
<dl class="function">
<dt id="c.nand_read_buf16">
void <code class="descname">nand_read_buf16</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_buf16" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] read chip data into buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store date</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default read function for 16bit buswidth.</p>
<dl class="function">
<dt id="c.nand_block_bad">
int <code class="descname">nand_block_bad</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] Read bad block marker from the chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt>
<dd>offset from device start</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check, if the block is bad.</p>
<dl class="function">
<dt id="c.nand_default_block_markbad">
int <code class="descname">nand_default_block_markbad</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_default_block_markbad" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] mark a block bad via bad block marker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt>
<dd>offset from device start</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the default implementation, which can be overridden by a hardware
specific driver. It provides the details for writing a bad block marker to a
block.</p>
<dl class="function">
<dt id="c.nand_block_markbad_lowlevel">
int <code class="descname">nand_block_markbad_lowlevel</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_markbad_lowlevel" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a block bad</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt>
<dd>offset from device start</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function performs the generic NAND bad block marking steps (i.e., bad
block table(s) and/or marker(s)). We only allow the hardware driver to
specify how to write bad block markers to OOB (chip-&gt;block_markbad).</p>
<p>We try operations in the following order:</p>
<blockquote>
<div><ol class="arabic simple">
<li>erase the affected block, to allow OOB marker to be written cleanly</li>
<li>write bad block marker to OOB area of affected block (unless flag
NAND_BBT_NO_OOB_BBM is present)</li>
<li>update the BBT</li>
</ol>
</div></blockquote>
<p>Note that we retain the first error encountered in (2) or (3), finish the
procedures, and dump the error in the end.</p>
<dl class="function">
<dt id="c.nand_check_wp">
int <code class="descname">nand_check_wp</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_check_wp" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] check if the chip is write protected</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check, if the device is write protected. The function expects, that the
device is already selected.</p>
<dl class="function">
<dt id="c.nand_block_isreserved">
int <code class="descname">nand_block_isreserved</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_isreserved" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Check if a block is marked reserved.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt>
<dd>offset from device start</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the block is marked as reserved.</p>
<dl class="function">
<dt id="c.nand_block_checkbad">
int <code class="descname">nand_block_checkbad</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;ofs</em>, int<em>&nbsp;allowbbt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_checkbad" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Check if a block is marked bad</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt>
<dd>offset from device start</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">allowbbt</span></code></dt>
<dd>1, if its allowed to access the bbt area</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check, if the block is bad. Either by reading the bad block table or
calling of the scan function.</p>
<dl class="function">
<dt id="c.panic_nand_wait_ready">
void <code class="descname">panic_nand_wait_ready</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, unsigned long<em>&nbsp;timeo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.panic_nand_wait_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Wait for the ready pin after commands.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeo</span></code></dt>
<dd>Timeout</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper function for nand_wait_ready used when needing to wait in interrupt
context.</p>
<dl class="function">
<dt id="c.nand_wait_status_ready">
void <code class="descname">nand_wait_status_ready</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, unsigned long<em>&nbsp;timeo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_wait_status_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Wait for the ready status after commands.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeo</span></code></dt>
<dd>Timeout in ms</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for status ready (i.e. command done) or timeout.</p>
<dl class="function">
<dt id="c.nand_command">
void <code class="descname">nand_command</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, unsigned int<em>&nbsp;command</em>, int<em>&nbsp;column</em>, int<em>&nbsp;page_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_command" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] Send command to NAND device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">command</span></code></dt>
<dd>the command to be sent</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">column</span></code></dt>
<dd>the column address for this command, -1 if none</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page_addr</span></code></dt>
<dd>the page address for this command, -1 if none</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send command to NAND device. This function is used for small page devices
(512 Bytes per page).</p>
<dl class="function">
<dt id="c.nand_command_lp">
void <code class="descname">nand_command_lp</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, unsigned int<em>&nbsp;command</em>, int<em>&nbsp;column</em>, int<em>&nbsp;page_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_command_lp" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] Send command to NAND large page device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">command</span></code></dt>
<dd>the command to be sent</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">column</span></code></dt>
<dd>the column address for this command, -1 if none</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page_addr</span></code></dt>
<dd>the page address for this command, -1 if none</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send command to NAND device. This is the version for the new large page
devices. We don’t have the separate regions as we have in the small page
devices. We must emulate NAND_CMD_READOOB to keep the code compatible.</p>
<dl class="function">
<dt id="c.panic_nand_get_device">
void <code class="descname">panic_nand_get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, struct mtd_info *<em>&nbsp;mtd</em>, int<em>&nbsp;new_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.panic_nand_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Get chip for selected access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the nand chip descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_state</span></code></dt>
<dd>the state which is requested</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used when in panic, no locks are taken.</p>
<dl class="function">
<dt id="c.nand_get_device">
int <code class="descname">nand_get_device</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, int<em>&nbsp;new_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_get_device" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Get chip for selected access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_state</span></code></dt>
<dd>the state which is requested</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get the device and lock it for exclusive access</p>
<dl class="function">
<dt id="c.panic_nand_wait">
void <code class="descname">panic_nand_wait</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, unsigned long<em>&nbsp;timeo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.panic_nand_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] wait until the command is done</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>NAND chip structure</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">timeo</span></code></dt>
<dd>timeout</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for command done. This is a helper function for nand_wait used when
we are in interrupt context. May happen when in panic and trying to write
an oops through mtdoops.</p>
<dl class="function">
<dt id="c.nand_wait">
int <code class="descname">nand_wait</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>[DEFAULT] wait until the command is done</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>NAND chip structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for command done. This applies to erase and program only.</p>
<dl class="function">
<dt id="c.nand_reset_data_interface">
int <code class="descname">nand_reset_data_interface</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;chipnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_reset_data_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset data interface and timings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>The NAND chip</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chipnr</span></code></dt>
<dd>Internal die id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the Data interface and timings to ONFI mode 0.</p>
<p>Returns 0 for success or negative error code otherwise.</p>
<dl class="function">
<dt id="c.nand_setup_data_interface">
int <code class="descname">nand_setup_data_interface</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;chipnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_setup_data_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the best data interface and timings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>The NAND chip</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chipnr</span></code></dt>
<dd>Internal die id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find and configure the best data interface and NAND timings supported by
the chip and the driver.
First tries to retrieve supported timing modes from ONFI information,
and if the NAND chip does not support ONFI, relies on the
-&gt;onfi_timing_mode_default specified in the nand_ids table.</p>
<p>Returns 0 for success or negative error code otherwise.</p>
<dl class="function">
<dt id="c.nand_init_data_interface">
int <code class="descname">nand_init_data_interface</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_init_data_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>find the best data interface and timings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>The NAND chip</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the best data interface and NAND timings supported by the chip
and the driver.
First tries to retrieve supported timing modes from ONFI information,
and if the NAND chip does not support ONFI, relies on the
-&gt;onfi_timing_mode_default specified in the nand_ids table. After this
function nand_chip-&gt;data_interface is initialized with the best timing mode
available.</p>
<p>Returns 0 for success or negative error code otherwise.</p>
<dl class="function">
<dt id="c.nand_reset">
int <code class="descname">nand_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;chipnr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset and initialize a NAND device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>The NAND chip</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chipnr</span></code></dt>
<dd>Internal die id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or negative error code otherwise</p>
<dl class="function">
<dt id="c.nand_check_erased_buf">
int <code class="descname">nand_check_erased_buf</code><span class="sig-paren">(</span>void *<em>&nbsp;buf</em>, int<em>&nbsp;len</em>, int<em>&nbsp;bitflips_threshold</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_check_erased_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a buffer contains (almost) only 0xff data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to test</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>buffer length</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bitflips_threshold</span></code></dt>
<dd>maximum number of bitflips</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if a buffer contains only 0xff, which means the underlying region
has been erased and is ready to be programmed.
The bitflips_threshold specify the maximum number of bitflips before
considering the region is not erased.</p>
<p><strong>Note</strong></p>
<p>The logic of this function has been extracted from the memweight
implementation, except that nand_check_erased_buf function exit before
testing the whole buffer if the number of bitflips exceed the
bitflips_threshold value.</p>
<p>Returns a positive number of bitflips less than or equal to
bitflips_threshold, or -ERROR_CODE for bitflips in excess of the
threshold.</p>
<dl class="function">
<dt id="c.nand_read_page_raw_syndrome">
int <code class="descname">nand_read_page_raw_syndrome</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_raw_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] read raw page data without ecc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store read data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>caller requires OOB data read to chip-&gt;oob_poi</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>We need a special oob layout and handling even when OOB isn’t used.</p>
<dl class="function">
<dt id="c.nand_read_page_swecc">
int <code class="descname">nand_read_page_swecc</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_swecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] software ECC based page read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store read data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>caller requires OOB data read to chip-&gt;oob_poi</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<dl class="function">
<dt id="c.nand_read_subpage">
int <code class="descname">nand_read_subpage</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint32_t<em>&nbsp;data_offs</em>, uint32_t<em>&nbsp;readlen</em>, uint8_t *<em>&nbsp;bufpoi</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_subpage" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] ECC based sub-page read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">data_offs</span></code></dt>
<dd>offset of requested data within the page</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">readlen</span></code></dt>
<dd>data length</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">bufpoi</span></code></dt>
<dd>buffer to store read data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<dl class="function">
<dt id="c.nand_read_page_hwecc">
int <code class="descname">nand_read_page_hwecc</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_hwecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC based page read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store read data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>caller requires OOB data read to chip-&gt;oob_poi</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not for syndrome calculating ECC controllers which need a special oob layout.</p>
<dl class="function">
<dt id="c.nand_read_page_hwecc_oob_first">
int <code class="descname">nand_read_page_hwecc_oob_first</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_hwecc_oob_first" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hw ecc, read oob first</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store read data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>caller requires OOB data read to chip-&gt;oob_poi</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hardware ECC for large page chips, require OOB to be read first. For this
ECC mode, the write_page method is re-used from ECC_HW. These methods
read/write ECC from the OOB area, unlike the ECC_HW_SYNDROME support with
multiple ECC steps, follows the “infix ECC” scheme and reads/writes ECC from
the data area, by overwriting the NAND manufacturer bad block markings.</p>
<dl class="function">
<dt id="c.nand_read_page_syndrome">
int <code class="descname">nand_read_page_syndrome</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_page_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC syndrome based page read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to store read data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>caller requires OOB data read to chip-&gt;oob_poi</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hw generator calculates the error syndrome automatically. Therefore we
need a special oob layout and handling.</p>
<dl class="function">
<dt id="c.nand_transfer_oob">
uint8_t * <code class="descname">nand_transfer_oob</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;oob</em>, struct mtd_oob_ops *<em>&nbsp;ops</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_transfer_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Transfer oob to client buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">oob</span></code></dt>
<dd>oob destination address</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>oob ops structure</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>size of oob to transfer</dd>
</dl>
<dl class="function">
<dt id="c.nand_setup_read_retry">
int <code class="descname">nand_setup_read_retry</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, int<em>&nbsp;retry_mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_setup_read_retry" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Set the READ RETRY mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">retry_mode</span></code></dt>
<dd>the retry mode to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some vendors supply a special command to shift the Vt threshold, to be used
when there are too many bitflips in a page (i.e., ECC error). After setting
a new threshold, the host should retry reading the page.</p>
<dl class="function">
<dt id="c.nand_do_read_ops">
int <code class="descname">nand_do_read_ops</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;from</em>, struct mtd_oob_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_do_read_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Read data with ECC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt>
<dd>offset to read from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>oob ops structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Internal function. Called with chip held.</p>
<dl class="function">
<dt id="c.nand_read">
int <code class="descname">nand_read</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;from</em>, size_t<em>&nbsp;len</em>, size_t *<em>&nbsp;retlen</em>, uint8_t *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] MTD compatibility function for nand_do_read_ecc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt>
<dd>offset to read from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to read</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">retlen</span></code></dt>
<dd>pointer to variable to store the number of read bytes</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the databuffer to put data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get hold of the chip and call nand_do_read.</p>
<dl class="function">
<dt id="c.nand_do_read_oob">
int <code class="descname">nand_do_read_oob</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;from</em>, struct mtd_oob_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_do_read_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] NAND read out-of-band</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt>
<dd>offset to read from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>oob operations description structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND read out-of-band data from the spare area.</p>
<dl class="function">
<dt id="c.nand_read_oob">
int <code class="descname">nand_read_oob</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;from</em>, struct mtd_oob_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_read_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND read data and/or out-of-band</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt>
<dd>offset to read from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>oob operation description structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND read data and/or out-of-band data.</p>
<dl class="function">
<dt id="c.nand_write_page_raw_syndrome">
int <code class="descname">nand_write_page_raw_syndrome</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_raw_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] raw page write function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>must write chip-&gt;oob_poi to OOB</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>We need a special oob layout and handling even when ECC isn’t checked.</p>
<dl class="function">
<dt id="c.nand_write_page_swecc">
int <code class="descname">nand_write_page_swecc</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_swecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] software ECC based page write function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>must write chip-&gt;oob_poi to OOB</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
</dl>
<dl class="function">
<dt id="c.nand_write_page_hwecc">
int <code class="descname">nand_write_page_hwecc</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_hwecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC based page write function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>must write chip-&gt;oob_poi to OOB</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
</dl>
<dl class="function">
<dt id="c.nand_write_subpage_hwecc">
int <code class="descname">nand_write_subpage_hwecc</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint32_t<em>&nbsp;offset</em>, uint32_t<em>&nbsp;data_len</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_subpage_hwecc" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC based subpage write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">offset</span></code></dt>
<dd>column address of subpage within the page</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">data_len</span></code></dt>
<dd>data length</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>must write chip-&gt;oob_poi to OOB</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
</dl>
<dl class="function">
<dt id="c.nand_write_page_syndrome">
int <code class="descname">nand_write_page_syndrome</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page_syndrome" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] hardware ECC syndrome based page write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>mtd info structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>must write chip-&gt;oob_poi to OOB</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hw generator calculates the error syndrome automatically. Therefore we
need a special oob layout and handling.</p>
<dl class="function">
<dt id="c.nand_write_page">
int <code class="descname">nand_write_page</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, uint32_t<em>&nbsp;offset</em>, int<em>&nbsp;data_len</em>, const uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;oob_required</em>, int<em>&nbsp;page</em>, int<em>&nbsp;raw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_page" title="Permalink to this definition">¶</a></dt>
<dd><p>write one page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>NAND chip descriptor</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">offset</span></code></dt>
<dd>address offset within the page</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">data_len</span></code></dt>
<dd>length of actual data to be written</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the data to write</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oob_required</span></code></dt>
<dd>must write chip-&gt;oob_poi to OOB</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>page number to write</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">raw</span></code></dt>
<dd>use _raw version of write_page</dd>
</dl>
<dl class="function">
<dt id="c.nand_fill_oob">
uint8_t * <code class="descname">nand_fill_oob</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;oob</em>, size_t<em>&nbsp;len</em>, struct mtd_oob_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_fill_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Transfer client buffer to oob</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">oob</span></code></dt>
<dd>oob data buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>oob data write length</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>oob ops structure</dd>
</dl>
<dl class="function">
<dt id="c.nand_do_write_ops">
int <code class="descname">nand_do_write_ops</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;to</em>, struct mtd_oob_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_do_write_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] NAND write with ECC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt>
<dd>offset to write to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>oob operations description structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND write with ECC.</p>
<dl class="function">
<dt id="c.panic_nand_write">
int <code class="descname">panic_nand_write</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;to</em>, size_t<em>&nbsp;len</em>, size_t *<em>&nbsp;retlen</em>, const uint8_t *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.panic_nand_write" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND write with ECC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt>
<dd>offset to write to</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to write</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">retlen</span></code></dt>
<dd>pointer to variable to store the number of written bytes</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the data to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND write with ECC. Used when performing writes in interrupt context, this
may for example be called by mtdoops when writing an oops while in panic.</p>
<dl class="function">
<dt id="c.nand_write">
int <code class="descname">nand_write</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;to</em>, size_t<em>&nbsp;len</em>, size_t *<em>&nbsp;retlen</em>, const uint8_t *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND write with ECC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt>
<dd>offset to write to</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to write</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">retlen</span></code></dt>
<dd>pointer to variable to store the number of written bytes</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the data to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND write with ECC.</p>
<dl class="function">
<dt id="c.nand_do_write_oob">
int <code class="descname">nand_do_write_oob</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;to</em>, struct mtd_oob_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_do_write_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND write out-of-band</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt>
<dd>offset to write to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>oob operation description structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>NAND write out-of-band.</p>
<dl class="function">
<dt id="c.nand_write_oob">
int <code class="descname">nand_write_oob</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;to</em>, struct mtd_oob_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_write_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] NAND write data and/or out-of-band</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt>
<dd>offset to write to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_oob_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>oob operation description structure</dd>
</dl>
<dl class="function">
<dt id="c.single_erase">
int <code class="descname">single_erase</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, int<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.single_erase" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] NAND standard block erase command function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>the page address of the block which will be erased</dd>
</dl>
<p><strong>Description</strong></p>
<p>Standard erase command for NAND chips. Returns NAND status.</p>
<dl class="function">
<dt id="c.nand_erase">
int <code class="descname">nand_erase</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct erase_info *<em>&nbsp;instr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_erase" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] erase block(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">erase_info</span> <span class="pre">*</span> <span class="pre">instr</span></code></dt>
<dd>erase instruction</dd>
</dl>
<p><strong>Description</strong></p>
<p>Erase one ore more blocks.</p>
<dl class="function">
<dt id="c.nand_erase_nand">
int <code class="descname">nand_erase_nand</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct erase_info *<em>&nbsp;instr</em>, int<em>&nbsp;allowbbt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_erase_nand" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] erase block(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">erase_info</span> <span class="pre">*</span> <span class="pre">instr</span></code></dt>
<dd>erase instruction</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">allowbbt</span></code></dt>
<dd>allow erasing the bbt area</dd>
</dl>
<p><strong>Description</strong></p>
<p>Erase one ore more blocks.</p>
<dl class="function">
<dt id="c.nand_sync">
void <code class="descname">nand_sync</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] sync</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sync is actually a wait for chip ready function.</p>
<dl class="function">
<dt id="c.nand_block_isbad">
int <code class="descname">nand_block_isbad</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_isbad" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Check if block at offset is bad</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt>
<dd>offset relative to mtd start</dd>
</dl>
<dl class="function">
<dt id="c.nand_block_markbad">
int <code class="descname">nand_block_markbad</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;ofs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_block_markbad" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Mark block at the given offset as bad</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt>
<dd>offset relative to mtd start</dd>
</dl>
<dl class="function">
<dt id="c.nand_max_bad_blocks">
int <code class="descname">nand_max_bad_blocks</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;ofs</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_max_bad_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Max number of bad blocks for an mtd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">ofs</span></code></dt>
<dd>offset relative to mtd start</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of mtd</dd>
</dl>
<dl class="function">
<dt id="c.nand_onfi_set_features">
int <code class="descname">nand_onfi_set_features</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;addr</em>, uint8_t *<em>&nbsp;subfeature_param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_onfi_set_features" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] set features for ONFI nand</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>feature address.</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">subfeature_param</span></code></dt>
<dd>the subfeature parameters, a four bytes array.</dd>
</dl>
<dl class="function">
<dt id="c.nand_onfi_get_features">
int <code class="descname">nand_onfi_get_features</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;chip</em>, int<em>&nbsp;addr</em>, uint8_t *<em>&nbsp;subfeature_param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_onfi_get_features" title="Permalink to this definition">¶</a></dt>
<dd><p>[REPLACEABLE] get features for ONFI nand</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>nand chip info structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>feature address.</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">subfeature_param</span></code></dt>
<dd>the subfeature parameters, a four bytes array.</dd>
</dl>
<dl class="function">
<dt id="c.nand_suspend">
int <code class="descname">nand_suspend</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Suspend the NAND flash</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<dl class="function">
<dt id="c.nand_resume">
void <code class="descname">nand_resume</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Resume the NAND flash</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<dl class="function">
<dt id="c.nand_shutdown">
void <code class="descname">nand_shutdown</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>[MTD Interface] Finish the current NAND operation and prevent further operations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<dl class="function">
<dt id="c.check_pattern">
int <code class="descname">check_pattern</code><span class="sig-paren">(</span>uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;len</em>, int<em>&nbsp;paglen</em>, struct nand_bbt_descr *<em>&nbsp;td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] check if a pattern is in the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to search</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>the length of buffer to search</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">paglen</span></code></dt>
<dd>the pagelength</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>search pattern descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for a pattern at the given place. Used to search bad block tables and
good / bad block identifiers.</p>
<dl class="function">
<dt id="c.check_short_pattern">
int <code class="descname">check_short_pattern</code><span class="sig-paren">(</span>uint8_t *<em>&nbsp;buf</em>, struct nand_bbt_descr *<em>&nbsp;td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_short_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] check if a pattern is in the buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer to search</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>search pattern descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for a pattern at the given place. Used to search bad block tables and
good / bad block identifiers. Same as check_pattern, but no optional empty
check.</p>
<dl class="function">
<dt id="c.add_marker_len">
u32 <code class="descname">add_marker_len</code><span class="sig-paren">(</span>struct nand_bbt_descr *<em>&nbsp;td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_marker_len" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the length of the marker in data area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>BBT descriptor used for computation</dd>
</dl>
<p><strong>Description</strong></p>
<p>The length will be 0 if the marker is located in OOB area.</p>
<dl class="function">
<dt id="c.read_bbt">
int <code class="descname">read_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, int<em>&nbsp;page</em>, int<em>&nbsp;num</em>, struct nand_bbt_descr *<em>&nbsp;td</em>, int<em>&nbsp;offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Read the bad block table starting from page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">page</span></code></dt>
<dd>the starting page</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>the number of bbt descriptors to read</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>the bbt describtion table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offs</span></code></dt>
<dd>block number offset in the table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the bad block table starting from page.</p>
<dl class="function">
<dt id="c.read_abs_bbt">
int <code class="descname">read_abs_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, struct nand_bbt_descr *<em>&nbsp;td</em>, int<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_abs_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Read the bad block table starting at a given page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>descriptor for the bad block table</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chip</span></code></dt>
<dd>read the table for a specific chip, -1 read all chips; applies only if
NAND_BBT_PERCHIP option is set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the bad block table for all chips starting at a given page. We assume
that the bbt bits are in consecutive order.</p>
<dl class="function">
<dt id="c.scan_read_oob">
int <code class="descname">scan_read_oob</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, loff_t<em>&nbsp;offs</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.scan_read_oob" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Scan data+OOB region to buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt>
<dd>offset at which to scan</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of data region to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan read data from data+OOB. May traverse multiple pages, interleaving
page,OOB,page,OOB,… in buf. Completes transfer and returns the “strongest”
ECC condition (error or bitflip). May quit on the first (non-ECC) error.</p>
<dl class="function">
<dt id="c.read_abs_bbts">
void <code class="descname">read_abs_bbts</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, struct nand_bbt_descr *<em>&nbsp;td</em>, struct nand_bbt_descr *<em>&nbsp;md</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_abs_bbts" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Read the bad block table(s) for all chips starting at a given page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>descriptor for the bad block table</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">md</span></code></dt>
<dd>descriptor for the bad block table mirror</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the bad block table(s) for all chips starting at a given page. We
assume that the bbt bits are in consecutive order.</p>
<dl class="function">
<dt id="c.create_bbt">
int <code class="descname">create_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, struct nand_bbt_descr *<em>&nbsp;bd</em>, int<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.create_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] Create a bad block table by scanning the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">bd</span></code></dt>
<dd>descriptor for the good/bad block search pattern</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chip</span></code></dt>
<dd>create the table for a specific chip, -1 read all chips; applies only
if NAND_BBT_PERCHIP option is set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a bad block table by scanning the device for the given good/bad block
identify pattern.</p>
<dl class="function">
<dt id="c.search_bbt">
int <code class="descname">search_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, struct nand_bbt_descr *<em>&nbsp;td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.search_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] scan the device for a specific bad block table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>descriptor for the bad block table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the bad block table by searching for a given ident pattern. Search is
preformed either from the beginning up or from the end of the device
downwards. The search starts always at the start of a block. If the option
NAND_BBT_PERCHIP is given, each chip is searched for a bbt, which contains
the bad block information of this chip. This is necessary to provide support
for certain DOC devices.</p>
<p>The bbt ident pattern resides in the oob area of the first page in a block.</p>
<dl class="function">
<dt id="c.search_read_bbts">
void <code class="descname">search_read_bbts</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, struct nand_bbt_descr *<em>&nbsp;td</em>, struct nand_bbt_descr *<em>&nbsp;md</em><span class="sig-paren">)</span><a class="headerlink" href="#c.search_read_bbts" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] scan the device for bad block table(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>descriptor for the bad block table</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">md</span></code></dt>
<dd>descriptor for the bad block table mirror</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search and read the bad block table(s).</p>
<dl class="function">
<dt id="c.get_bbt_block">
int <code class="descname">get_bbt_block</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;this</em>, struct nand_bbt_descr *<em>&nbsp;td</em>, struct nand_bbt_descr *<em>&nbsp;md</em>, int<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_bbt_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first valid eraseblock suitable to store a BBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">this</span></code></dt>
<dd>the NAND device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>the BBT description</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">md</span></code></dt>
<dd>the mirror BBT descriptor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chip</span></code></dt>
<dd>the CHIP selector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions returns a positive block number pointing a valid eraseblock
suitable to store a BBT (i.e. in the range reserved for BBT), or -ENOSPC if
all blocks are already used of marked bad. If td-&gt;pages[chip] was already
pointing to a valid block we re-use it, otherwise we search for the next
valid one.</p>
<dl class="function">
<dt id="c.mark_bbt_block_bad">
void <code class="descname">mark_bbt_block_bad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;this</em>, struct nand_bbt_descr *<em>&nbsp;td</em>, int<em>&nbsp;chip</em>, int<em>&nbsp;block</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mark_bbt_block_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark one of the block reserved for BBT bad</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">this</span></code></dt>
<dd>the NAND device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>the BBT description</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chip</span></code></dt>
<dd>the CHIP selector</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">block</span></code></dt>
<dd>the BBT block to mark</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blocks reserved for BBT can become bad. This functions is an helper to mark
such blocks as bad. It takes care of updating the in-memory BBT, marking the
block as bad using a bad block marker and invalidating the associated
td-&gt;pages[] entry.</p>
<dl class="function">
<dt id="c.write_bbt">
int <code class="descname">write_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, struct nand_bbt_descr *<em>&nbsp;td</em>, struct nand_bbt_descr *<em>&nbsp;md</em>, int<em>&nbsp;chipsel</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] (Re)write the bad block table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>descriptor for the bad block table</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">md</span></code></dt>
<dd>descriptor for the bad block table mirror</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">chipsel</span></code></dt>
<dd>selector for a specific chip, -1 for all</dd>
</dl>
<p><strong>Description</strong></p>
<p>(Re)write the bad block table.</p>
<dl class="function">
<dt id="c.nand_memory_bbt">
int <code class="descname">nand_memory_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct nand_bbt_descr *<em>&nbsp;bd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_memory_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] create a memory based bad block table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">bd</span></code></dt>
<dd>descriptor for the good/bad block search pattern</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function creates a memory based bbt by scanning the device for
manufacturer / software marked good / bad blocks.</p>
<dl class="function">
<dt id="c.check_create">
int <code class="descname">check_create</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, uint8_t *<em>&nbsp;buf</em>, struct nand_bbt_descr *<em>&nbsp;bd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_create" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] create and write bbt(s) if necessary</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>temporary buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">bd</span></code></dt>
<dd>descriptor for the good/bad block search pattern</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function checks the results of the previous call to read_bbt and creates
/ updates the bbt(s) if necessary. Creation is necessary if no bbt was found
for the chip/device. Update is necessary if one of the tables is missing or
the version nr. of one table is less than the other.</p>
<dl class="function">
<dt id="c.mark_bbt_region">
void <code class="descname">mark_bbt_region</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct nand_bbt_descr *<em>&nbsp;td</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mark_bbt_region" title="Permalink to this definition">¶</a></dt>
<dd><p>[GENERIC] mark the bad block table regions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">td</span></code></dt>
<dd>bad block table descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>The bad block table regions are marked as “bad” to prevent accidental
erasures / writes. The regions are identified by the mark 0x02.</p>
<dl class="function">
<dt id="c.verify_bbt_descr">
void <code class="descname">verify_bbt_descr</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct nand_bbt_descr *<em>&nbsp;bd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.verify_bbt_descr" title="Permalink to this definition">¶</a></dt>
<dd><p>verify the bad block description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">bd</span></code></dt>
<dd>the table to verify</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions performs a few sanity checks on the bad block description
table.</p>
<dl class="function">
<dt id="c.nand_scan_bbt">
int <code class="descname">nand_scan_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, struct nand_bbt_descr *<em>&nbsp;bd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_scan_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] scan, find, read and maybe create bad block table(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_bbt_descr</span> <span class="pre">*</span> <span class="pre">bd</span></code></dt>
<dd>descriptor for the good/bad block search pattern</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function checks, if a bad block table(s) is/are already available. If
not it scans the device for manufacturer marked good / bad blocks and writes
the bad block table(s) to the selected place.</p>
<p>The bad block table memory is allocated here. It must be freed by calling
the nand_free_bbt function.</p>
<dl class="function">
<dt id="c.nand_update_bbt">
int <code class="descname">nand_update_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_update_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>update bad block table(s)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt>
<dd>the offset of the newly marked block</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function updates the bad block table(s).</p>
<dl class="function">
<dt id="c.nand_create_badblock_pattern">
int <code class="descname">nand_create_badblock_pattern</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.nand_chip" title="nand_chip">nand_chip</a> *<em>&nbsp;this</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_create_badblock_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>[INTERN] Creates a BBT descriptor structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nand_chip</span> <span class="pre">*</span> <span class="pre">this</span></code></dt>
<dd>NAND chip to create descriptor for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates and initializes a nand_bbt_descr for BBM detection
based on the properties of <strong>this</strong>. The new descriptor is stored in
this-&gt;badblock_pattern. Thus, this-&gt;badblock_pattern should be NULL when
passed to this function.</p>
<dl class="function">
<dt id="c.nand_default_bbt">
int <code class="descname">nand_default_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_default_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Select a default bad block table for the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function selects the default bad block table support for the device and
calls the nand_scan_bbt function.</p>
<dl class="function">
<dt id="c.nand_isreserved_bbt">
int <code class="descname">nand_isreserved_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_isreserved_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Check if a block is reserved</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt>
<dd>offset in the device</dd>
</dl>
<dl class="function">
<dt id="c.nand_isbad_bbt">
int <code class="descname">nand_isbad_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;offs</em>, int<em>&nbsp;allowbbt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_isbad_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Check if a block is bad</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt>
<dd>offset in the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">allowbbt</span></code></dt>
<dd>allow access to bad block table region</dd>
</dl>
<dl class="function">
<dt id="c.nand_markbad_bbt">
int <code class="descname">nand_markbad_bbt</code><span class="sig-paren">(</span>struct mtd_info *<em>&nbsp;mtd</em>, loff_t<em>&nbsp;offs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nand_markbad_bbt" title="Permalink to this definition">¶</a></dt>
<dd><p>[NAND Interface] Mark a block bad in the BBT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mtd_info</span> <span class="pre">*</span> <span class="pre">mtd</span></code></dt>
<dd>MTD device structure</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offs</span></code></dt>
<dd>offset of the bad block</dd>
</dl>
</div>
<div class="section" id="credits">
<h2>Credits<a class="headerlink" href="#credits" title="Permalink to this headline">¶</a></h2>
<p>The following people have contributed to the NAND driver:</p>
<ol class="arabic simple">
<li>Steven J. Hill<a class="reference external" href="mailto:sjhill&#37;&#52;&#48;realitydiluted&#46;com">sjhill<span>&#64;</span>realitydiluted<span>&#46;</span>com</a></li>
<li>David Woodhouse<a class="reference external" href="mailto:dwmw2&#37;&#52;&#48;infradead&#46;org">dwmw2<span>&#64;</span>infradead<span>&#46;</span>org</a></li>
<li>Thomas Gleixner<a class="reference external" href="mailto:tglx&#37;&#52;&#48;linutronix&#46;de">tglx<span>&#64;</span>linutronix<span>&#46;</span>de</a></li>
</ol>
<p>A lot of users have provided bugfixes, improvements and helping hands
for testing. Thanks a lot.</p>
<p>The following people have contributed to this document:</p>
<ol class="arabic simple">
<li>Thomas Gleixner<a class="reference external" href="mailto:tglx&#37;&#52;&#48;linutronix&#46;de">tglx<span>&#64;</span>linutronix<span>&#46;</span>de</a></li>
</ol>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="miscellaneous.html" class="btn btn-neutral float-right" title="Parallel Port Devices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="libata.html" class="btn btn-neutral" title="libATA Developer’s Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>