

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>VME Device Drivers &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linux 802.11 Driver Developer’s Guide" href="80211/index.html" />
    <link rel="prev" title="Writing s390 channel device drivers" href="s390-drivers.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">VME Device Drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver-registration">Driver registration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resource-management">Resource management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#master-windows">Master windows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#master-window-configuration">Master window configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#master-window-access">Master window access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#slave-windows">Slave windows</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#slave-window-configuration">Slave window configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slave-window-buffer-allocation">Slave window buffer allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slave-window-access">Slave window access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dma-channels">DMA channels</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#list-management">List Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-population">List Population</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transfer-attributes">Transfer Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-execution">List Execution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interrupts">Interrupts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#attaching-interrupt-handlers">Attaching Interrupt Handlers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-generation">Interrupt Generation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#location-monitors">Location monitors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#location-monitor-management">Location Monitor Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#location-monitor-configuration">Location Monitor Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#location-monitor-use">Location Monitor Use</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#slot-detection">Slot Detection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bus-detection">Bus Detection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vme-api">VME API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>VME Device Drivers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/vme.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vme-device-drivers">
<h1>VME Device Drivers<a class="headerlink" href="#vme-device-drivers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="driver-registration">
<h2>Driver registration<a class="headerlink" href="#driver-registration" title="Permalink to this headline">¶</a></h2>
<p>As with other subsystems within the Linux kernel, VME device drivers register
with the VME subsystem, typically called from the devices init routine.  This is
achieved via a call to <a class="reference internal" href="#c.vme_register_driver" title="vme_register_driver"><code class="xref c c-func docutils literal"><span class="pre">vme_register_driver()</span></code></a>.</p>
<p>A pointer to a structure of type <a class="reference internal" href="#c.vme_driver" title="vme_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vme_driver</span></code></a> must
be provided to the registration function. Along with the maximum number of
devices your driver is able to support.</p>
<p>At the minimum, the ‘.name’, ‘.match’ and ‘.probe’ elements of
<a class="reference internal" href="#c.vme_driver" title="vme_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vme_driver</span></code></a> should be correctly set. The ‘.name’
element is a pointer to a string holding the device driver’s name.</p>
<p>The ‘.match’ function allows control over which VME devices should be registered
with the driver. The match function should return 1 if a device should be
probed and 0 otherwise. This example match function (from vme_user.c) limits
the number of devices probed to one:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define USER_BUS_MAX    1</span>
<span class="p">...</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">vme_user_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">vme_dev</span> <span class="o">*</span><span class="n">vdev</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">num</span> <span class="o">&gt;=</span> <span class="n">USER_BUS_MAX</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The ‘.probe’ element should contain a pointer to the probe routine. The
probe routine is passed a <a class="reference internal" href="#c.vme_dev" title="vme_dev"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span></code></a> pointer as an
argument.</p>
<p>Here, the ‘num’ field refers to the sequential device ID for this specific
driver. The bridge number (or bus number) can be accessed using
dev-&gt;bridge-&gt;num.</p>
<p>A function is also provided to unregister the driver from the VME core called
<a class="reference internal" href="#c.vme_unregister_driver" title="vme_unregister_driver"><code class="xref c c-func docutils literal"><span class="pre">vme_unregister_driver()</span></code></a> and should usually be called from the device
driver’s exit routine.</p>
</div>
<div class="section" id="resource-management">
<h2>Resource management<a class="headerlink" href="#resource-management" title="Permalink to this headline">¶</a></h2>
<p>Once a driver has registered with the VME core the provided match routine will
be called the number of times specified during the registration. If a match
succeeds, a non-zero value should be returned. A zero return value indicates
failure. For all successful matches, the probe routine of the corresponding
driver is called. The probe routine is passed a pointer to the devices
device structure. This pointer should be saved, it will be required for
requesting VME resources.</p>
<p>The driver can request ownership of one or more master windows
(<a class="reference internal" href="#c.vme_master_request" title="vme_master_request"><code class="xref c c-func docutils literal"><span class="pre">vme_master_request()</span></code></a>), slave windows (<a class="reference internal" href="#c.vme_slave_request" title="vme_slave_request"><code class="xref c c-func docutils literal"><span class="pre">vme_slave_request()</span></code></a>)
and/or dma channels (<a class="reference internal" href="#c.vme_dma_request" title="vme_dma_request"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_request()</span></code></a>). Rather than allowing the device
driver to request a specific window or DMA channel (which may be used by a
different driver) the API allows a resource to be assigned based on the required
attributes of the driver in question. For slave windows these attributes are
split into the VME address spaces that need to be accessed in ‘aspace’ and VME
bus cycle types required in ‘cycle’. Master windows add a further set of
attributes in ‘width’ specifying the required data transfer widths. These
attributes are defined as bitmasks and as such any combination of the
attributes can be requested for a single window, the core will assign a window
that meets the requirements, returning a pointer of type vme_resource that
should be used to identify the allocated resource when it is used. For DMA
controllers, the request function requires the potential direction of any
transfers to be provided in the route attributes. This is typically VME-to-MEM
and/or MEM-to-VME, though some hardware can support VME-to-VME and MEM-to-MEM
transfers as well as test pattern generation. If an unallocated window fitting
the requirements can not be found a NULL pointer will be returned.</p>
<p>Functions are also provided to free window allocations once they are no longer
required. These functions (<a class="reference internal" href="#c.vme_master_free" title="vme_master_free"><code class="xref c c-func docutils literal"><span class="pre">vme_master_free()</span></code></a>, <a class="reference internal" href="#c.vme_slave_free" title="vme_slave_free"><code class="xref c c-func docutils literal"><span class="pre">vme_slave_free()</span></code></a>
and <a class="reference internal" href="#c.vme_dma_free" title="vme_dma_free"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_free()</span></code></a>) should be passed the pointer to the resource
provided during resource allocation.</p>
</div>
<div class="section" id="master-windows">
<h2>Master windows<a class="headerlink" href="#master-windows" title="Permalink to this headline">¶</a></h2>
<p>Master windows provide access from the local processor[s] out onto the VME bus.
The number of windows available and the available access modes is dependent on
the underlying chipset. A window must be configured before it can be used.</p>
<div class="section" id="master-window-configuration">
<h3>Master window configuration<a class="headerlink" href="#master-window-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a master window has been assigned <a class="reference internal" href="#c.vme_master_set" title="vme_master_set"><code class="xref c c-func docutils literal"><span class="pre">vme_master_set()</span></code></a> can be used to
configure it and <a class="reference internal" href="#c.vme_master_get" title="vme_master_get"><code class="xref c c-func docutils literal"><span class="pre">vme_master_get()</span></code></a> to retrieve the current settings. The
address spaces, transfer widths and cycle types are the same as described
under resource management, however some of the options are mutually exclusive.
For example, only one address space may be specified.</p>
</div>
<div class="section" id="master-window-access">
<h3>Master window access<a class="headerlink" href="#master-window-access" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_master_read" title="vme_master_read"><code class="xref c c-func docutils literal"><span class="pre">vme_master_read()</span></code></a> can be used to read from and
<a class="reference internal" href="#c.vme_master_write" title="vme_master_write"><code class="xref c c-func docutils literal"><span class="pre">vme_master_write()</span></code></a> used to write to configured master windows.</p>
<p>In addition to simple reads and writes, <a class="reference internal" href="#c.vme_master_rmw" title="vme_master_rmw"><code class="xref c c-func docutils literal"><span class="pre">vme_master_rmw()</span></code></a> is provided to
do a read-modify-write transaction. Parts of a VME window can also be mapped
into user space memory using <a class="reference internal" href="#c.vme_master_mmap" title="vme_master_mmap"><code class="xref c c-func docutils literal"><span class="pre">vme_master_mmap()</span></code></a>.</p>
</div>
</div>
<div class="section" id="slave-windows">
<h2>Slave windows<a class="headerlink" href="#slave-windows" title="Permalink to this headline">¶</a></h2>
<p>Slave windows provide devices on the VME bus access into mapped portions of the
local memory. The number of windows available and the access modes that can be
used is dependent on the underlying chipset. A window must be configured before
it can be used.</p>
<div class="section" id="slave-window-configuration">
<h3>Slave window configuration<a class="headerlink" href="#slave-window-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a slave window has been assigned <a class="reference internal" href="#c.vme_slave_set" title="vme_slave_set"><code class="xref c c-func docutils literal"><span class="pre">vme_slave_set()</span></code></a> can be used to
configure it and <a class="reference internal" href="#c.vme_slave_get" title="vme_slave_get"><code class="xref c c-func docutils literal"><span class="pre">vme_slave_get()</span></code></a> to retrieve the current settings.</p>
<p>The address spaces, transfer widths and cycle types are the same as described
under resource management, however some of the options are mutually exclusive.
For example, only one address space may be specified.</p>
</div>
<div class="section" id="slave-window-buffer-allocation">
<h3>Slave window buffer allocation<a class="headerlink" href="#slave-window-buffer-allocation" title="Permalink to this headline">¶</a></h3>
<p>Functions are provided to allow the user to allocate
(<a class="reference internal" href="#c.vme_alloc_consistent" title="vme_alloc_consistent"><code class="xref c c-func docutils literal"><span class="pre">vme_alloc_consistent()</span></code></a>) and free (<a class="reference internal" href="#c.vme_free_consistent" title="vme_free_consistent"><code class="xref c c-func docutils literal"><span class="pre">vme_free_consistent()</span></code></a>)
contiguous buffers which will be accessible by the VME bridge. These functions
do not have to be used, other methods can be used to allocate a buffer, though
care must be taken to ensure that they are contiguous and accessible by the VME
bridge.</p>
</div>
<div class="section" id="slave-window-access">
<h3>Slave window access<a class="headerlink" href="#slave-window-access" title="Permalink to this headline">¶</a></h3>
<p>Slave windows map local memory onto the VME bus, the standard methods for
accessing memory should be used.</p>
</div>
</div>
<div class="section" id="dma-channels">
<h2>DMA channels<a class="headerlink" href="#dma-channels" title="Permalink to this headline">¶</a></h2>
<p>The VME DMA transfer provides the ability to run link-list DMA transfers. The
API introduces the concept of DMA lists. Each DMA list is a link-list which can
be passed to a DMA controller. Multiple lists can be created, extended,
executed, reused and destroyed.</p>
<div class="section" id="list-management">
<h3>List Management<a class="headerlink" href="#list-management" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_new_dma_list" title="vme_new_dma_list"><code class="xref c c-func docutils literal"><span class="pre">vme_new_dma_list()</span></code></a> is provided to create and
<a class="reference internal" href="#c.vme_dma_list_free" title="vme_dma_list_free"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_list_free()</span></code></a> to destroy DMA lists. Execution of a list will not
automatically destroy the list, thus enabling a list to be reused for repetitive
tasks.</p>
</div>
<div class="section" id="list-population">
<h3>List Population<a class="headerlink" href="#list-population" title="Permalink to this headline">¶</a></h3>
<p>An item can be added to a list using <a class="reference internal" href="#c.vme_dma_list_add" title="vme_dma_list_add"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_list_add()</span></code></a> (the source and
destination attributes need to be created before calling this function, this is
covered under “Transfer Attributes”).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The detailed attributes of the transfers source and destination
are not checked until an entry is added to a DMA list, the request
for a DMA channel purely checks the directions in which the
controller is expected to transfer data. As a result it is
possible for this call to return an error, for example if the
source or destination is in an unsupported VME address space.</p>
</div>
</div>
<div class="section" id="transfer-attributes">
<h3>Transfer Attributes<a class="headerlink" href="#transfer-attributes" title="Permalink to this headline">¶</a></h3>
<p>The attributes for the source and destination are handled separately from adding
an item to a list. This is due to the diverse attributes required for each type
of source and destination. There are functions to create attributes for PCI, VME
and pattern sources and destinations (where appropriate):</p>
<blockquote>
<div><ul class="simple">
<li>PCI source or destination: <a class="reference internal" href="#c.vme_dma_pci_attribute" title="vme_dma_pci_attribute"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_pci_attribute()</span></code></a></li>
<li>VME source or destination: <a class="reference internal" href="#c.vme_dma_vme_attribute" title="vme_dma_vme_attribute"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_vme_attribute()</span></code></a></li>
<li>Pattern source: <a class="reference internal" href="#c.vme_dma_pattern_attribute" title="vme_dma_pattern_attribute"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_pattern_attribute()</span></code></a></li>
</ul>
</div></blockquote>
<p>The function <a class="reference internal" href="#c.vme_dma_free_attribute" title="vme_dma_free_attribute"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_free_attribute()</span></code></a> should be used to free an
attribute.</p>
</div>
<div class="section" id="list-execution">
<h3>List Execution<a class="headerlink" href="#list-execution" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_dma_list_exec" title="vme_dma_list_exec"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_list_exec()</span></code></a> queues a list for execution and will
return once the list has been executed.</p>
</div>
</div>
<div class="section" id="interrupts">
<h2>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h2>
<p>The VME API provides functions to attach and detach callbacks to specific VME
level and status ID combinations and for the generation of VME interrupts with
specific VME level and status IDs.</p>
<div class="section" id="attaching-interrupt-handlers">
<h3>Attaching Interrupt Handlers<a class="headerlink" href="#attaching-interrupt-handlers" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_irq_request" title="vme_irq_request"><code class="xref c c-func docutils literal"><span class="pre">vme_irq_request()</span></code></a> can be used to attach and
<a class="reference internal" href="#c.vme_irq_free" title="vme_irq_free"><code class="xref c c-func docutils literal"><span class="pre">vme_irq_free()</span></code></a> to free a specific VME level and status ID combination.
Any given combination can only be assigned a single callback function. A void
pointer parameter is provided, the value of which is passed to the callback
function, the use of this pointer is user undefined. The callback parameters are
as follows. Care must be taken in writing a callback function, callback
functions run in interrupt context:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">statid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="interrupt-generation">
<h3>Interrupt Generation<a class="headerlink" href="#interrupt-generation" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_irq_generate" title="vme_irq_generate"><code class="xref c c-func docutils literal"><span class="pre">vme_irq_generate()</span></code></a> can be used to generate a VME interrupt
at a given VME level and VME status ID.</p>
</div>
</div>
<div class="section" id="location-monitors">
<h2>Location monitors<a class="headerlink" href="#location-monitors" title="Permalink to this headline">¶</a></h2>
<p>The VME API provides the following functionality to configure the location
monitor.</p>
<div class="section" id="location-monitor-management">
<h3>Location Monitor Management<a class="headerlink" href="#location-monitor-management" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_lm_request" title="vme_lm_request"><code class="xref c c-func docutils literal"><span class="pre">vme_lm_request()</span></code></a> is provided to request the use of a block
of location monitors and <a class="reference internal" href="#c.vme_lm_free" title="vme_lm_free"><code class="xref c c-func docutils literal"><span class="pre">vme_lm_free()</span></code></a> to free them after they are no
longer required. Each block may provide a number of location monitors,
monitoring adjacent locations. The function <a class="reference internal" href="#c.vme_lm_count" title="vme_lm_count"><code class="xref c c-func docutils literal"><span class="pre">vme_lm_count()</span></code></a> can be used
to determine how many locations are provided.</p>
</div>
<div class="section" id="location-monitor-configuration">
<h3>Location Monitor Configuration<a class="headerlink" href="#location-monitor-configuration" title="Permalink to this headline">¶</a></h3>
<p>Once a bank of location monitors has been allocated, the function
<a class="reference internal" href="#c.vme_lm_set" title="vme_lm_set"><code class="xref c c-func docutils literal"><span class="pre">vme_lm_set()</span></code></a> is provided to configure the location and mode of the
location monitor. The function <a class="reference internal" href="#c.vme_lm_get" title="vme_lm_get"><code class="xref c c-func docutils literal"><span class="pre">vme_lm_get()</span></code></a> can be used to retrieve
existing settings.</p>
</div>
<div class="section" id="location-monitor-use">
<h3>Location Monitor Use<a class="headerlink" href="#location-monitor-use" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="#c.vme_lm_attach" title="vme_lm_attach"><code class="xref c c-func docutils literal"><span class="pre">vme_lm_attach()</span></code></a> enables a callback to be attached and
<a class="reference internal" href="#c.vme_lm_detach" title="vme_lm_detach"><code class="xref c c-func docutils literal"><span class="pre">vme_lm_detach()</span></code></a> allows on to be detached from each location monitor
location. Each location monitor can monitor a number of adjacent locations. The
callback function is declared as follows.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="slot-detection">
<h2>Slot Detection<a class="headerlink" href="#slot-detection" title="Permalink to this headline">¶</a></h2>
<p>The function <a class="reference internal" href="#c.vme_slot_num" title="vme_slot_num"><code class="xref c c-func docutils literal"><span class="pre">vme_slot_num()</span></code></a> returns the slot ID of the provided bridge.</p>
</div>
<div class="section" id="bus-detection">
<h2>Bus Detection<a class="headerlink" href="#bus-detection" title="Permalink to this headline">¶</a></h2>
<p>The function <a class="reference internal" href="#c.vme_bus_num" title="vme_bus_num"><code class="xref c c-func docutils literal"><span class="pre">vme_bus_num()</span></code></a> returns the bus ID of the provided bridge.</p>
</div>
<div class="section" id="vme-api">
<h2>VME API<a class="headerlink" href="#vme-api" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.vme_dev">
struct <code class="descname">vme_dev</code><a class="headerlink" href="#c.vme_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure representing a VME device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vme_dev {
  int num;
  struct vme_bridge * bridge;
  struct device dev;
  struct list_head drv_list;
  struct list_head bridge_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">num</span></code></dt>
<dd>The device number</dd>
<dt><code class="docutils literal"><span class="pre">bridge</span></code></dt>
<dd>Pointer to the bridge device this device is on</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Internal device structure</dd>
<dt><code class="docutils literal"><span class="pre">drv_list</span></code></dt>
<dd>List of devices (per driver)</dd>
<dt><code class="docutils literal"><span class="pre">bridge_list</span></code></dt>
<dd>List of devices (per bridge)</dd>
</dl>
<dl class="type">
<dt id="c.vme_driver">
struct <code class="descname">vme_driver</code><a class="headerlink" href="#c.vme_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Structure representing a VME driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vme_driver {
  const char * name;
  int (* match) (struct vme_dev *);
  int (* probe) (struct vme_dev *);
  int (* remove) (struct vme_dev *);
  struct device_driver driver;
  struct list_head devices;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Driver name, should be unique among VME drivers and usually the same
as the module name.</dd>
<dt><code class="docutils literal"><span class="pre">match</span></code></dt>
<dd>Callback used to determine whether probe should be run.</dd>
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>Callback for device binding, called when new device is detected.</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>Callback, called on device removal.</dd>
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>Underlying generic device driver structure.</dd>
<dt><code class="docutils literal"><span class="pre">devices</span></code></dt>
<dd>List of VME devices (struct vme_dev) associated with this driver.</dd>
</dl>
<dl class="function">
<dt id="c.vme_alloc_consistent">
void * <code class="descname">vme_alloc_consistent</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, size_t<em>&nbsp;size</em>, dma_addr_t *<em>&nbsp;dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_alloc_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate contiguous memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME resource.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of allocation required.</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">dma</span></code></dt>
<dd>Pointer to variable to store physical address of allocation.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a contiguous block of memory for use by the driver. This is used to
create the buffers for the slave windows.</p>
<p><strong>Return</strong></p>
<p>Virtual address of allocation on success, NULL on failure.</p>
<dl class="function">
<dt id="c.vme_free_consistent">
void <code class="descname">vme_free_consistent</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, size_t<em>&nbsp;size</em>, void *<em>&nbsp;vaddr</em>, dma_addr_t<em>&nbsp;dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_free_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Free previously allocated memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME resource.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of allocation to free.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>Virtual address of allocation.</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">dma</span></code></dt>
<dd>Physical address of allocation.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free previously allocated block of contiguous memory.</p>
<dl class="function">
<dt id="c.vme_get_size">
size_t <code class="descname">vme_get_size</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function returning size of a VME window</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME slave or master resource.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine the size of the VME window provided. This is a helper
function, wrappering the call to vme_master_get or vme_slave_get
depending on the type of window resource handed to it.</p>
<p><strong>Return</strong></p>
<p>Size of the window on success, zero on failure.</p>
<dl class="function">
<dt id="c.vme_slave_request">
struct vme_resource * <code class="descname">vme_slave_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em>, u32<em>&nbsp;address</em>, u32<em>&nbsp;cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slave_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a VME slave window resource.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">address</span></code></dt>
<dd>Required VME address space.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt>
<dd>Required VME data transfer cycle type.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request use of a VME window resource capable of being set for the requested
address space and data transfer cycle.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME resource on success, NULL on failure.</p>
<dl class="function">
<dt id="c.vme_slave_set">
int <code class="descname">vme_slave_set</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, int<em>&nbsp;enabled</em>, unsigned long long<em>&nbsp;vme_base</em>, unsigned long long<em>&nbsp;size</em>, dma_addr_t<em>&nbsp;buf_base</em>, u32<em>&nbsp;aspace</em>, u32<em>&nbsp;cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slave_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set VME slave window configuration.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME slave resource.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">enabled</span></code></dt>
<dd>State to which the window should be configured.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">vme_base</span></code></dt>
<dd>Base address for the window.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>Size of the VME window.</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">buf_base</span></code></dt>
<dd>Based address of buffer used to provide VME slave window storage.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">aspace</span></code></dt>
<dd>VME address space for the VME window.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt>
<dd>VME data transfer cycle type for the VME window.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set configuration for provided VME slave window.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt>
<dd>device, if an invalid resource has been provided or invalid
attributes are provided. Hardware specific errors may also be
returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_slave_get">
int <code class="descname">vme_slave_get</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, int *<em>&nbsp;enabled</em>, unsigned long long *<em>&nbsp;vme_base</em>, unsigned long long *<em>&nbsp;size</em>, dma_addr_t *<em>&nbsp;buf_base</em>, u32 *<em>&nbsp;aspace</em>, u32 *<em>&nbsp;cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slave_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve VME slave window configuration.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME slave resource.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">enabled</span></code></dt>
<dd>Pointer to variable for storing state.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">vme_base</span></code></dt>
<dd>Pointer to variable for storing window base address.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">size</span></code></dt>
<dd>Pointer to variable for storing window size.</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">buf_base</span></code></dt>
<dd>Pointer to variable for storing slave buffer base address.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">aspace</span></code></dt>
<dd>Pointer to variable for storing VME address space.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">cycle</span></code></dt>
<dd>Pointer to variable for storing VME data transfer cycle type.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return configuration for provided VME slave window.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt>
<dd>device or if an invalid resource has been provided.</dd>
</dl>
<dl class="function">
<dt id="c.vme_slave_free">
void <code class="descname">vme_slave_free</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slave_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free VME slave window</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME slave resource.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the provided slave resource so that it may be reallocated.</p>
<dl class="function">
<dt id="c.vme_master_request">
struct vme_resource * <code class="descname">vme_master_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em>, u32<em>&nbsp;address</em>, u32<em>&nbsp;cycle</em>, u32<em>&nbsp;dwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a VME master window resource.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">address</span></code></dt>
<dd>Required VME address space.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt>
<dd>Required VME data transfer cycle type.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">dwidth</span></code></dt>
<dd>Required VME data transfer width.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request use of a VME window resource capable of being set for the requested
address space, data transfer cycle and width.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME resource on success, NULL on failure.</p>
<dl class="function">
<dt id="c.vme_master_set">
int <code class="descname">vme_master_set</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, int<em>&nbsp;enabled</em>, unsigned long long<em>&nbsp;vme_base</em>, unsigned long long<em>&nbsp;size</em>, u32<em>&nbsp;aspace</em>, u32<em>&nbsp;cycle</em>, u32<em>&nbsp;dwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set VME master window configuration.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME master resource.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">enabled</span></code></dt>
<dd>State to which the window should be configured.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">vme_base</span></code></dt>
<dd>Base address for the window.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>Size of the VME window.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">aspace</span></code></dt>
<dd>VME address space for the VME window.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt>
<dd>VME data transfer cycle type for the VME window.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">dwidth</span></code></dt>
<dd>VME data transfer width for the VME window.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set configuration for provided VME master window.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt>
<dd>device, if an invalid resource has been provided or invalid
attributes are provided. Hardware specific errors may also be
returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_master_get">
int <code class="descname">vme_master_get</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, int *<em>&nbsp;enabled</em>, unsigned long long *<em>&nbsp;vme_base</em>, unsigned long long *<em>&nbsp;size</em>, u32 *<em>&nbsp;aspace</em>, u32 *<em>&nbsp;cycle</em>, u32 *<em>&nbsp;dwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve VME master window configuration.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME master resource.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">enabled</span></code></dt>
<dd>Pointer to variable for storing state.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">vme_base</span></code></dt>
<dd>Pointer to variable for storing window base address.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">size</span></code></dt>
<dd>Pointer to variable for storing window size.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">aspace</span></code></dt>
<dd>Pointer to variable for storing VME address space.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">cycle</span></code></dt>
<dd>Pointer to variable for storing VME data transfer cycle type.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">dwidth</span></code></dt>
<dd>Pointer to variable for storing VME data transfer width.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return configuration for provided VME master window.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt>
<dd>device or if an invalid resource has been provided.</dd>
</dl>
<dl class="function">
<dt id="c.vme_master_read">
ssize_t <code class="descname">vme_master_read</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;count</em>, loff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from VME space into a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME master resource.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Pointer to buffer where data should be transferred.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>Number of bytes to transfer.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt>
<dd>Offset into VME master window at which to start transfer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform read of count bytes of data from location on VME bus which maps into
the VME master window at offset to buf.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Number of bytes read, -EINVAL if resource is not a VME master</dt>
<dd>resource or read operation is not supported. -EFAULT returned if
invalid offset is provided. Hardware specific errors may also be
returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_master_write">
ssize_t <code class="descname">vme_master_write</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;count</em>, loff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data out to VME space from a buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME master resource.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Pointer to buffer holding data to transfer.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>Number of bytes to transfer.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt>
<dd>Offset into VME master window at which to start transfer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform write of count bytes of data from buf to location on VME bus which
maps into the VME master window at offset.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Number of bytes written, -EINVAL if resource is not a VME master</dt>
<dd>resource or write operation is not supported. -EFAULT returned if
invalid offset is provided. Hardware specific errors may also be
returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_master_rmw">
unsigned int <code class="descname">vme_master_rmw</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, unsigned int<em>&nbsp;mask</em>, unsigned int<em>&nbsp;compare</em>, unsigned int<em>&nbsp;swap</em>, loff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_rmw" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform read-modify-write cycle.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME master resource.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>Bits to be compared and swapped in operation.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">compare</span></code></dt>
<dd>Bits to be compared with data read from offset.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">swap</span></code></dt>
<dd>Bits to be swapped in data read from offset.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">offset</span></code></dt>
<dd>Offset into VME master window at which to perform operation.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform read-modify-write cycle on provided location:
- Location on VME bus is read.
- Bits selected by mask are compared with compare.
- Where a selected bit matches that in compare and are selected in swap,
the bit is swapped.
- Result written back to location on VME bus.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Bytes written on success, -EINVAL if resource is not a VME master</dt>
<dd>resource or RMW operation is not supported. Hardware specific
errors may also be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_master_mmap">
int <code class="descname">vme_master_mmap</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Mmap region of VME master window.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME master resource.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>Pointer to definition of user mapping.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Memory map a region of the VME master window into user space.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL if resource is not a VME master</dt>
<dd>resource or -EFAULT if map exceeds window size. Other generic mmap
errors may also be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_master_free">
void <code class="descname">vme_master_free</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_master_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free VME master window</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME master resource.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the provided master resource so that it may be reallocated.</p>
<dl class="function">
<dt id="c.vme_dma_request">
struct vme_resource * <code class="descname">vme_dma_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em>, u32<em>&nbsp;route</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a DMA controller.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">route</span></code></dt>
<dd>Required src/destination combination.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request a VME DMA controller with capability to perform transfers bewteen
requested source/destination combination.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME DMA resource on success, NULL on failure.</p>
<dl class="function">
<dt id="c.vme_new_dma_list">
struct vme_dma_list * <code class="descname">vme_new_dma_list</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_new_dma_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new VME DMA list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME DMA resource.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new VME DMA list. It is the responsibility of the user to free
the list once it is no longer required with <a class="reference internal" href="#c.vme_dma_list_free" title="vme_dma_list_free"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_list_free()</span></code></a>.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Pointer to new VME DMA list, NULL on allocation failure or invalid</dt>
<dd>VME DMA resource.</dd>
</dl>
<dl class="function">
<dt id="c.vme_dma_pattern_attribute">
struct vme_dma_attr * <code class="descname">vme_dma_pattern_attribute</code><span class="sig-paren">(</span>u32<em>&nbsp;pattern</em>, u32<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_pattern_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Create “Pattern” type VME DMA list attribute.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">pattern</span></code></dt>
<dd>Value to use used as pattern</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>Type of pattern to be written.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create VME DMA list attribute for pattern generation. It is the
responsibility of the user to free used attributes using
<a class="reference internal" href="#c.vme_dma_free_attribute" title="vme_dma_free_attribute"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_free_attribute()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME DMA attribute, NULL on failure.</p>
<dl class="function">
<dt id="c.vme_dma_pci_attribute">
struct vme_dma_attr * <code class="descname">vme_dma_pci_attribute</code><span class="sig-paren">(</span>dma_addr_t<em>&nbsp;address</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_pci_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Create “PCI” type VME DMA list attribute.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">address</span></code></dt>
<dd>PCI base address for DMA transfer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create VME DMA list attribute pointing to a location on PCI for DMA
transfers. It is the responsibility of the user to free used attributes
using <a class="reference internal" href="#c.vme_dma_free_attribute" title="vme_dma_free_attribute"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_free_attribute()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME DMA attribute, NULL on failure.</p>
<dl class="function">
<dt id="c.vme_dma_vme_attribute">
struct vme_dma_attr * <code class="descname">vme_dma_vme_attribute</code><span class="sig-paren">(</span>unsigned long long<em>&nbsp;address</em>, u32<em>&nbsp;aspace</em>, u32<em>&nbsp;cycle</em>, u32<em>&nbsp;dwidth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_vme_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Create “VME” type VME DMA list attribute.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">address</span></code></dt>
<dd>VME base address for DMA transfer.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">aspace</span></code></dt>
<dd>VME address space to use for DMA transfer.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt>
<dd>VME bus cycle to use for DMA transfer.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">dwidth</span></code></dt>
<dd>VME data width to use for DMA transfer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create VME DMA list attribute pointing to a location on the VME bus for DMA
transfers. It is the responsibility of the user to free used attributes
using <a class="reference internal" href="#c.vme_dma_free_attribute" title="vme_dma_free_attribute"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_free_attribute()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Pointer to VME DMA attribute, NULL on failure.</p>
<dl class="function">
<dt id="c.vme_dma_free_attribute">
void <code class="descname">vme_dma_free_attribute</code><span class="sig-paren">(</span>struct vme_dma_attr *<em>&nbsp;attributes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_free_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Free DMA list attribute.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dma_attr</span> <span class="pre">*</span> <span class="pre">attributes</span></code></dt>
<dd>Pointer to DMA list attribute.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free VME DMA list attribute. VME DMA list attributes can be safely freed
once <a class="reference internal" href="#c.vme_dma_list_add" title="vme_dma_list_add"><code class="xref c c-func docutils literal"><span class="pre">vme_dma_list_add()</span></code></a> has returned.</p>
<dl class="function">
<dt id="c.vme_dma_list_add">
int <code class="descname">vme_dma_list_add</code><span class="sig-paren">(</span>struct vme_dma_list *<em>&nbsp;list</em>, struct vme_dma_attr *<em>&nbsp;src</em>, struct vme_dma_attr *<em>&nbsp;dest</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add enty to a VME DMA list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dma_list</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>Pointer to VME list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dma_attr</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Pointer to DMA list attribute to use as source.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dma_attr</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Pointer to DMA list attribute to use as destination.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>Number of bytes to transfer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an entry to the provided VME DMA list. Entry requires pointers to source
and destination DMA attributes and a count.</p>
<p>Please note, the attributes supported as source and destinations for
transfers are hardware dependent.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt>
<dd>device or if the link list has already been submitted for execution.
Hardware specific errors also possible.</dd>
</dl>
<dl class="function">
<dt id="c.vme_dma_list_exec">
int <code class="descname">vme_dma_list_exec</code><span class="sig-paren">(</span>struct vme_dma_list *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_list_exec" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a VME DMA list for execution.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dma_list</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>Pointer to VME list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue the provided VME DMA list for execution. The call will return once the
list has been executed.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL if operation is not supported on this</dt>
<dd>device. Hardware specific errors also possible.</dd>
</dl>
<dl class="function">
<dt id="c.vme_dma_list_free">
int <code class="descname">vme_dma_list_free</code><span class="sig-paren">(</span>struct vme_dma_list *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_list_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a VME DMA list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dma_list</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>Pointer to VME list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the provided DMA list and all its entries.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL on invalid VME resource, -EBUSY if resource</dt>
<dd>is still in use. Hardware specific errors also possible.</dd>
</dl>
<dl class="function">
<dt id="c.vme_dma_free">
int <code class="descname">vme_dma_free</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_dma_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a VME DMA resource.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME DMA resource.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the provided DMA resource so that it may be reallocated.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL on invalid VME resource, -EBUSY if resource</dt>
<dd>is still active.</dd>
</dl>
<dl class="function">
<dt id="c.vme_irq_request">
int <code class="descname">vme_irq_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em>, int<em>&nbsp;level</em>, int<em>&nbsp;statid</em>, void (*callback)<em>&nbsp;(int</em>, int, void<em>&nbsp;*</em>, void *<em>&nbsp;priv_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_irq_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a specific VME interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">level</span></code></dt>
<dd>Interrupt priority being requested.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">statid</span></code></dt>
<dd>Interrupt vector being requested.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(int,</span> <span class="pre">int,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">callback</span></code></dt>
<dd>Pointer to callback function called when VME interrupt/vector
received.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv_data</span></code></dt>
<dd>Generic pointer that will be passed to the callback function.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Request callback to be attached as a handler for VME interrupts with provided
level and statid.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL on invalid vme device, level or if the</dt>
<dd>function is not supported, -EBUSY if the level/statid combination is
already in use. Hardware specific errors also possible.</dd>
</dl>
<dl class="function">
<dt id="c.vme_irq_free">
void <code class="descname">vme_irq_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em>, int<em>&nbsp;level</em>, int<em>&nbsp;statid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_irq_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a VME interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">level</span></code></dt>
<dd>Interrupt priority of interrupt being freed.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">statid</span></code></dt>
<dd>Interrupt vector of interrupt being freed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove previously attached callback from VME interrupt priority/vector.</p>
<dl class="function">
<dt id="c.vme_irq_generate">
int <code class="descname">vme_irq_generate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em>, int<em>&nbsp;level</em>, int<em>&nbsp;statid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_irq_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate VME interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">level</span></code></dt>
<dd>Interrupt priority at which to assert the interrupt.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">statid</span></code></dt>
<dd>Interrupt vector to associate with the interrupt.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a VME interrupt of the provided level and with the provided
statid.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL on invalid vme device, level or if the</dt>
<dd>function is not supported. Hardware specific errors also possible.</dd>
</dl>
<dl class="function">
<dt id="c.vme_lm_request">
struct vme_resource * <code class="descname">vme_lm_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Request a VME location monitor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a location monitor resource to the driver. A location monitor
allows the driver to monitor accesses to a contiguous number of
addresses on the VME bus.</p>
<p><strong>Return</strong></p>
<p>Pointer to a VME resource on success or NULL on failure.</p>
<dl class="function">
<dt id="c.vme_lm_count">
int <code class="descname">vme_lm_count</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine number of VME Addresses monitored</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME location monitor resource.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The number of contiguous addresses monitored is hardware dependent.
Return the number of contiguous addresses monitored by the
location monitor.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Count of addresses monitored or -EINVAL when provided with an</dt>
<dd>invalid location monitor resource.</dd>
</dl>
<dl class="function">
<dt id="c.vme_lm_set">
int <code class="descname">vme_lm_set</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, unsigned long long<em>&nbsp;lm_base</em>, u32<em>&nbsp;aspace</em>, u32<em>&nbsp;cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure location monitor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME location monitor resource.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">lm_base</span></code></dt>
<dd>Base address to monitor.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">aspace</span></code></dt>
<dd>VME address space to monitor.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">cycle</span></code></dt>
<dd>VME bus cycle type to monitor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the base address, address space and cycle type of accesses to be
monitored by the location monitor.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt>
<dd>monitor resource or function is not supported. Hardware specific
errors may also be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_lm_get">
int <code class="descname">vme_lm_get</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, unsigned long long *<em>&nbsp;lm_base</em>, u32 *<em>&nbsp;aspace</em>, u32 *<em>&nbsp;cycle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve location monitor settings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME location monitor resource.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">lm_base</span></code></dt>
<dd>Pointer used to output the base address monitored.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">aspace</span></code></dt>
<dd>Pointer used to output the address space monitored.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">cycle</span></code></dt>
<dd>Pointer used to output the VME bus cycle type monitored.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the base address, address space and cycle type of accesses to
be monitored by the location monitor.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt>
<dd>monitor resource or function is not supported. Hardware specific
errors may also be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_lm_attach">
int <code class="descname">vme_lm_attach</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, int<em>&nbsp;monitor</em>, void (*callback) (void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide callback for location monitor address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME location monitor resource.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">monitor</span></code></dt>
<dd>Offset to which callback should be attached.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">callback</span></code></dt>
<dd>Pointer to callback function called when triggered.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Generic pointer that will be passed to the callback function.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attach a callback to the specificed offset into the location monitors
monitored addresses. A generic pointer is provided to allow data to be
passed to the callback when called.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt>
<dd>monitor resource or function is not supported. Hardware specific
errors may also be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_lm_detach">
int <code class="descname">vme_lm_detach</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em>, int<em>&nbsp;monitor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove callback for location monitor address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME location monitor resource.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">monitor</span></code></dt>
<dd>Offset to which callback should be removed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove the callback associated with the specificed offset into the
location monitors monitored addresses.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt>
<dd>monitor resource or function is not supported. Hardware specific
errors may also be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_lm_free">
void <code class="descname">vme_lm_free</code><span class="sig-paren">(</span>struct vme_resource *<em>&nbsp;resource</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_lm_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free allocated VME location monitor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_resource</span> <span class="pre">*</span> <span class="pre">resource</span></code></dt>
<dd>Pointer to VME location monitor resource.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free allocation of a VME location monitor.</p>
<dl class="docutils">
<dt>WARNING: This function currently expects that any callbacks that have</dt>
<dd>been attached to the location monitor have been removed.</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>Zero on success, -EINVAL when provided with an invalid location</dt>
<dd>monitor resource.</dd>
</dl>
<dl class="function">
<dt id="c.vme_slot_num">
int <code class="descname">vme_slot_num</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_slot_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve slot ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the slot ID associated with the provided VME device.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>The slot ID on success, -EINVAL if VME bridge cannot be determined</dt>
<dd>or the function is not supported. Hardware specific errors may also
be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vme_bus_num">
int <code class="descname">vme_bus_num</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_dev" title="vme_dev">vme_dev</a> *<em>&nbsp;vdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_bus_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve bus number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_dev</span> <span class="pre">*</span> <span class="pre">vdev</span></code></dt>
<dd>Pointer to VME device struct vme_dev assigned to driver instance.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Retrieve the bus enumeration associated with the provided VME device.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>The bus number on success, -EINVAL if VME bridge cannot be</dt>
<dd>determined.</dd>
</dl>
<dl class="function">
<dt id="c.vme_register_driver">
int <code class="descname">vme_register_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_driver" title="vme_driver">vme_driver</a> *<em>&nbsp;drv</em>, unsigned int<em>&nbsp;ndevs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_register_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a VME driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>Pointer to VME driver structure to register.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ndevs</span></code></dt>
<dd>Maximum number of devices to allow to be enumerated.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a VME device driver with the VME subsystem.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error value on registration failure.</p>
<dl class="function">
<dt id="c.vme_unregister_driver">
void <code class="descname">vme_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vme_driver" title="vme_driver">vme_driver</a> *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vme_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a VME driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vme_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>Pointer to VME driver structure to unregister.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a VME device driver from the VME subsystem.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="80211/index.html" class="btn btn-neutral float-right" title="Linux 802.11 Driver Developer’s Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="s390-drivers.html" class="btn btn-neutral" title="Writing s390 channel device drivers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>