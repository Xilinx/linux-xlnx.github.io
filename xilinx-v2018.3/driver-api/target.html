

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>target and iSCSI Interfaces Guide &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="MTD NAND Driver Programming Interface" href="mtdnand.html" />
    <link rel="prev" title="libATA Developer’s Guide" href="libata.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">target and iSCSI Interfaces Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction-and-overview">Introduction and Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#target-core-device-interfaces">Target core device interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#target-core-transport-interfaces">Target core transport interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#target-supported-userspace-i-o">Target-supported userspace I/O</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#userspace-i-o">Userspace I/O</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ring-design">Ring Design</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#iscsi-helper-functions">iSCSI helper functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iscsi-boot-information">iSCSI boot information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iscsi-transport-class">iSCSI transport class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iscsi-tcp-interfaces">iSCSI TCP interfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>target and iSCSI Interfaces Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/target.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="target-and-iscsi-interfaces-guide">
<h1>target and iSCSI Interfaces Guide<a class="headerlink" href="#target-and-iscsi-interfaces-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction-and-overview">
<h2>Introduction and Overview<a class="headerlink" href="#introduction-and-overview" title="Permalink to this headline">¶</a></h2>
<p>TBD</p>
</div>
<div class="section" id="target-core-device-interfaces">
<h2>Target core device interfaces<a class="headerlink" href="#target-core-device-interfaces" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="target-core-transport-interfaces">
<h2>Target core transport interfaces<a class="headerlink" href="#target-core-transport-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.transport_init_session">
void <code class="descname">transport_init_session</code><span class="sig-paren">(</span>struct se_session *<em>&nbsp;se_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_init_session" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a session object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>Session object pointer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must have zero-initialized <strong>se_sess</strong> before calling this function.</p>
<dl class="function">
<dt id="c.transport_alloc_session">
struct se_session * <code class="descname">transport_alloc_session</code><span class="sig-paren">(</span>enum target_prot_op<em>&nbsp;sup_prot_ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_alloc_session" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a session object and initialize it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">target_prot_op</span> <span class="pre">sup_prot_ops</span></code></dt>
<dd>bitmask that defines which T10-PI modes are supported.</dd>
</dl>
<dl class="function">
<dt id="c.transport_alloc_session_tags">
int <code class="descname">transport_alloc_session_tags</code><span class="sig-paren">(</span>struct se_session *<em>&nbsp;se_sess</em>, unsigned int<em>&nbsp;tag_num</em>, unsigned int<em>&nbsp;tag_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_alloc_session_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate target driver private data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>Session pointer.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tag_num</span></code></dt>
<dd>Maximum number of in-flight commands between initiator and target.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">tag_size</span></code></dt>
<dd>Size in bytes of the private data a target driver associates with
each command.</dd>
</dl>
<dl class="function">
<dt id="c.target_submit_cmd_map_sgls">
int <code class="descname">target_submit_cmd_map_sgls</code><span class="sig-paren">(</span>struct se_cmd *<em>&nbsp;se_cmd</em>, struct se_session *<em>&nbsp;se_sess</em>, unsigned char *<em>&nbsp;cdb</em>, unsigned char *<em>&nbsp;sense</em>, u64<em>&nbsp;unpacked_lun</em>, u32<em>&nbsp;data_length</em>, int<em>&nbsp;task_attr</em>, int<em>&nbsp;data_dir</em>, int<em>&nbsp;flags</em>, struct scatterlist *<em>&nbsp;sgl</em>, u32<em>&nbsp;sgl_count</em>, struct scatterlist *<em>&nbsp;sgl_bidi</em>, u32<em>&nbsp;sgl_bidi_count</em>, struct scatterlist *<em>&nbsp;sgl_prot</em>, u32<em>&nbsp;sgl_prot_count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_submit_cmd_map_sgls" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup unpacked lun and submit uninitialized se_cmd + use pre-allocated SGL memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*</span> <span class="pre">se_cmd</span></code></dt>
<dd>command descriptor to submit</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>associated se_sess for endpoint</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cdb</span></code></dt>
<dd>pointer to SCSI CDB</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">sense</span></code></dt>
<dd>pointer to SCSI sense buffer</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">unpacked_lun</span></code></dt>
<dd>unpacked LUN to reference for struct se_lun</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">data_length</span></code></dt>
<dd>fabric expected data transfer length</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">task_attr</span></code></dt>
<dd>SAM task attribute</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">data_dir</span></code></dt>
<dd>DMA data direction</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags for command submission from target_sc_flags_tables</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sgl</span></code></dt>
<dd>struct scatterlist memory for unidirectional mapping</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">sgl_count</span></code></dt>
<dd>scatterlist count for unidirectional mapping</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sgl_bidi</span></code></dt>
<dd>struct scatterlist memory for bidirectional READ mapping</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">sgl_bidi_count</span></code></dt>
<dd>scatterlist count for bidirectional READ mapping</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sgl_prot</span></code></dt>
<dd>struct scatterlist memory protection information</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">sgl_prot_count</span></code></dt>
<dd>scatterlist count for protection information</dd>
</dl>
<p><strong>Description</strong></p>
<p>Task tags are supported if the caller has set <strong>se_cmd</strong>-&gt;tag.</p>
<p>Returns non zero to signal active I/O shutdown failure.  All other
setup exceptions will be returned as a SCSI CHECK_CONDITION response,
but still return zero here.</p>
<p>This may only be called from process context, and also currently
assumes internal allocation of fabric payload buffer by target-core.</p>
<dl class="function">
<dt id="c.target_submit_cmd">
int <code class="descname">target_submit_cmd</code><span class="sig-paren">(</span>struct se_cmd *<em>&nbsp;se_cmd</em>, struct se_session *<em>&nbsp;se_sess</em>, unsigned char *<em>&nbsp;cdb</em>, unsigned char *<em>&nbsp;sense</em>, u64<em>&nbsp;unpacked_lun</em>, u32<em>&nbsp;data_length</em>, int<em>&nbsp;task_attr</em>, int<em>&nbsp;data_dir</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_submit_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup unpacked lun and submit uninitialized se_cmd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*</span> <span class="pre">se_cmd</span></code></dt>
<dd>command descriptor to submit</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>associated se_sess for endpoint</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cdb</span></code></dt>
<dd>pointer to SCSI CDB</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">sense</span></code></dt>
<dd>pointer to SCSI sense buffer</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">unpacked_lun</span></code></dt>
<dd>unpacked LUN to reference for struct se_lun</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">data_length</span></code></dt>
<dd>fabric expected data transfer length</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">task_attr</span></code></dt>
<dd>SAM task attribute</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">data_dir</span></code></dt>
<dd>DMA data direction</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags for command submission from target_sc_flags_tables</dd>
</dl>
<p><strong>Description</strong></p>
<p>Task tags are supported if the caller has set <strong>se_cmd</strong>-&gt;tag.</p>
<p>Returns non zero to signal active I/O shutdown failure.  All other
setup exceptions will be returned as a SCSI CHECK_CONDITION response,
but still return zero here.</p>
<p>This may only be called from process context, and also currently
assumes internal allocation of fabric payload buffer by target-core.</p>
<p>It also assumes interal target core SGL memory allocation.</p>
<dl class="function">
<dt id="c.target_submit_tmr">
int <code class="descname">target_submit_tmr</code><span class="sig-paren">(</span>struct se_cmd *<em>&nbsp;se_cmd</em>, struct se_session *<em>&nbsp;se_sess</em>, unsigned char *<em>&nbsp;sense</em>, u64<em>&nbsp;unpacked_lun</em>, void *<em>&nbsp;fabric_tmr_ptr</em>, unsigned char<em>&nbsp;tm_type</em>, gfp_t<em>&nbsp;gfp</em>, u64<em>&nbsp;tag</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_submit_tmr" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup unpacked lun and submit uninitialized se_cmd for TMR CDBs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*</span> <span class="pre">se_cmd</span></code></dt>
<dd>command descriptor to submit</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>associated se_sess for endpoint</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">sense</span></code></dt>
<dd>pointer to SCSI sense buffer</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">unpacked_lun</span></code></dt>
<dd>unpacked LUN to reference for struct se_lun</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">fabric_tmr_ptr</span></code></dt>
<dd>fabric context for TMR req</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">tm_type</span></code></dt>
<dd>Type of TM request</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>gfp type for caller</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">tag</span></code></dt>
<dd>referenced task tag for TMR_ABORT_TASK</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>submit cmd flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Callable from all contexts.</p>
<dl class="function">
<dt id="c.target_get_sess_cmd">
int <code class="descname">target_get_sess_cmd</code><span class="sig-paren">(</span>struct se_cmd *<em>&nbsp;se_cmd</em>, bool<em>&nbsp;ack_kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_get_sess_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Add command to active -&gt;sess_cmd_list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*</span> <span class="pre">se_cmd</span></code></dt>
<dd>command descriptor to add</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">ack_kref</span></code></dt>
<dd>Signal that fabric will perform an ack <a class="reference internal" href="#c.target_put_sess_cmd" title="target_put_sess_cmd"><code class="xref c c-func docutils literal"><span class="pre">target_put_sess_cmd()</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.target_put_sess_cmd">
int <code class="descname">target_put_sess_cmd</code><span class="sig-paren">(</span>struct se_cmd *<em>&nbsp;se_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_put_sess_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease the command reference count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*</span> <span class="pre">se_cmd</span></code></dt>
<dd>command to drop a reference from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 1 if and only if this <a class="reference internal" href="#c.target_put_sess_cmd" title="target_put_sess_cmd"><code class="xref c c-func docutils literal"><span class="pre">target_put_sess_cmd()</span></code></a> call caused the
refcount to drop to zero. Returns zero otherwise.</p>
<dl class="function">
<dt id="c.target_sess_cmd_list_set_waiting">
void <code class="descname">target_sess_cmd_list_set_waiting</code><span class="sig-paren">(</span>struct se_session *<em>&nbsp;se_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_sess_cmd_list_set_waiting" title="Permalink to this definition">¶</a></dt>
<dd><p>Set sess_tearing_down so no new commands are queued.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>session to flag</dd>
</dl>
<dl class="function">
<dt id="c.target_wait_for_sess_cmds">
void <code class="descname">target_wait_for_sess_cmds</code><span class="sig-paren">(</span>struct se_session *<em>&nbsp;se_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.target_wait_for_sess_cmds" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for outstanding commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_session</span> <span class="pre">*</span> <span class="pre">se_sess</span></code></dt>
<dd>session to wait for active I/O</dd>
</dl>
<dl class="function">
<dt id="c.transport_wait_for_tasks">
bool <code class="descname">transport_wait_for_tasks</code><span class="sig-paren">(</span>struct se_cmd *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_wait_for_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>set CMD_T_STOP and wait for t_transport_stop_comp</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">se_cmd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>command to wait on</dd>
</dl>
</div>
<div class="section" id="target-supported-userspace-i-o">
<h2>Target-supported userspace I/O<a class="headerlink" href="#target-supported-userspace-i-o" title="Permalink to this headline">¶</a></h2>
<div class="section" id="userspace-i-o">
<h3>Userspace I/O<a class="headerlink" href="#userspace-i-o" title="Permalink to this headline">¶</a></h3>
<p>Define a shared-memory interface for LIO to pass SCSI commands and
data to userspace for processing. This is to allow backends that
are too complex for in-kernel support to be possible.</p>
<p>It uses the UIO framework to do a lot of the device-creation and
introspection work for us.</p>
<p>See the .h file for how the ring is laid out. Note that while the
command ring is defined, the particulars of the data area are
not. Offset values in the command entry point to other locations
internal to the mmap-ed area. There is separate space outside the
command ring for data buffers. This leaves maximum flexibility for
moving buffer allocations, or even page flipping or other
allocation techniques, without altering the command ring layout.</p>
<p>SECURITY:
The user process must be assumed to be malicious. There’s no way to
prevent it breaking the command ring protocol if it wants, but in
order to prevent other issues we must only ever read <em>data</em> from
the shared memory area, not offsets or sizes. This applies to
command ring entries as well as the mailbox. Extra code needed for
this may have a ‘UAM’ comment.</p>
</div>
<div class="section" id="ring-design">
<h3>Ring Design<a class="headerlink" href="#ring-design" title="Permalink to this headline">¶</a></h3>
<p>The mmaped area is divided into three parts:
1) The mailbox (struct tcmu_mailbox, below);
2) The command ring;
3) Everything beyond the command ring (data).</p>
<p>The mailbox tells userspace the offset of the command ring from the
start of the shared memory region, and how big the command ring is.</p>
<p>The kernel passes SCSI commands to userspace by putting a struct
tcmu_cmd_entry in the ring, updating mailbox-&gt;cmd_head, and poking
userspace via UIO’s interrupt mechanism.</p>
<p>tcmu_cmd_entry contains a header. If the header type is PAD,
userspace should skip hdr-&gt;length bytes (mod cmdr_size) to find the
next cmd_entry.</p>
<p>Otherwise, the entry will contain offsets into the mmaped area that
contain the cdb and data buffers – the latter accessible via the
iov array. iov addresses are also offsets into the shared area.</p>
<p>When userspace is completed handling the command, set
entry-&gt;rsp.scsi_status, fill in rsp.sense_buffer if appropriate,
and also set mailbox-&gt;cmd_tail equal to the old cmd_tail plus
hdr-&gt;length, mod cmdr_size. If cmd_tail doesn’t equal cmd_head, it
should process the next packet the same way, and so on.</p>
</div>
</div>
<div class="section" id="iscsi-helper-functions">
<h2>iSCSI helper functions<a class="headerlink" href="#iscsi-helper-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.iscsi_prep_data_out_pdu">
void <code class="descname">iscsi_prep_data_out_pdu</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em>, struct iscsi_r2t_info *<em>&nbsp;r2t</em>, struct iscsi_data *<em>&nbsp;hdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_prep_data_out_pdu" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize Data-Out</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>scsi command task</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_r2t_info</span> <span class="pre">*</span> <span class="pre">r2t</span></code></dt>
<dd>R2T info</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_data</span> <span class="pre">*</span> <span class="pre">hdr</span></code></dt>
<dd>iscsi data in pdu</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>Initialize Data-Out within this R2T sequence and finds
proper data_offset within this SCSI command.</p>
<p>This function is called with connection lock taken.</p>
</div></blockquote>
<dl class="function">
<dt id="c.iscsi_complete_scsi_task">
void <code class="descname">iscsi_complete_scsi_task</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em>, uint32_t<em>&nbsp;exp_cmdsn</em>, uint32_t<em>&nbsp;max_cmdsn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_complete_scsi_task" title="Permalink to this definition">¶</a></dt>
<dd><p>finish scsi task normally</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi task for scsi cmd</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">exp_cmdsn</span></code></dt>
<dd>expected cmd sn in cpu format</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">max_cmdsn</span></code></dt>
<dd>max cmd sn in cpu format</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used when drivers do not need or cannot perform
lower level pdu processing.</p>
<p>Called with session back_lock</p>
<dl class="function">
<dt id="c.iscsi_itt_to_task">
struct iscsi_task * <code class="descname">iscsi_itt_to_task</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em>, itt_t<em>&nbsp;itt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_itt_to_task" title="Permalink to this definition">¶</a></dt>
<dd><p>look up task by itt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi connection</dd>
<dt><code class="docutils literal"><span class="pre">itt_t</span> <span class="pre">itt</span></code></dt>
<dd>itt</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be used for mgmt tasks like login and nops, or if
the LDD’s itt space does not include the session age.</p>
<p>The session back_lock must be held.</p>
<dl class="function">
<dt id="c.__iscsi_complete_pdu">
int <code class="descname">__iscsi_complete_pdu</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em>, struct iscsi_hdr *<em>&nbsp;hdr</em>, char *<em>&nbsp;data</em>, int<em>&nbsp;datalen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__iscsi_complete_pdu" title="Permalink to this definition">¶</a></dt>
<dd><p>complete pdu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi conn</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_hdr</span> <span class="pre">*</span> <span class="pre">hdr</span></code></dt>
<dd>iscsi header</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">datalen</span></code></dt>
<dd>len of data buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Completes pdu processing by freeing any resources allocated at
queuecommand or send generic. session back_lock must be held and verify
itt must have been called.</p>
<dl class="function">
<dt id="c.iscsi_itt_to_ctask">
struct iscsi_task * <code class="descname">iscsi_itt_to_ctask</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em>, itt_t<em>&nbsp;itt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_itt_to_ctask" title="Permalink to this definition">¶</a></dt>
<dd><p>look up ctask by itt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi connection</dd>
<dt><code class="docutils literal"><span class="pre">itt_t</span> <span class="pre">itt</span></code></dt>
<dd>itt</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be used for cmd tasks.</p>
<p>The session back_lock must be held.</p>
<dl class="function">
<dt id="c.iscsi_requeue_task">
void <code class="descname">iscsi_requeue_task</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_requeue_task" title="Permalink to this definition">¶</a></dt>
<dd><p>requeue task to run from session workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task to requeue</dd>
</dl>
<p><strong>Description</strong></p>
<p>LLDs that need to run a task from the session workqueue should call
this. The session frwd_lock must be held. This should only be called
by software drivers.</p>
<dl class="function">
<dt id="c.iscsi_suspend_queue">
void <code class="descname">iscsi_suspend_queue</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_suspend_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend iscsi_queuecommand</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi conn to stop queueing IO on</dd>
</dl>
<p><strong>Description</strong></p>
<p>This grabs the session frwd_lock to make sure no one is in
xmit_task/queuecommand, and then sets suspend to prevent
new commands from being queued. This only needs to be called
by offload drivers that need to sync a path like ep disconnect
with the iscsi_queuecommand/xmit_task. To start IO again libiscsi
will call iscsi_start_tx and iscsi_unblock_session when in FFP.</p>
<dl class="function">
<dt id="c.iscsi_suspend_tx">
void <code class="descname">iscsi_suspend_tx</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_suspend_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>suspend iscsi_data_xmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi conn tp stop processing IO on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets the suspend bit to prevent iscsi_data_xmit
from sending new IO, and if work is queued on the xmit thread
it will wait for it to be completed.</p>
<dl class="function">
<dt id="c.iscsi_eh_session_reset">
int <code class="descname">iscsi_eh_session_reset</code><span class="sig-paren">(</span>struct scsi_cmnd *<em>&nbsp;sc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_eh_session_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>drop session and attempt relogin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">sc</span></code></dt>
<dd>scsi command</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will wait for a relogin, session termination from
userspace, or a recovery/replacement timeout.</p>
<dl class="function">
<dt id="c.iscsi_eh_recover_target">
int <code class="descname">iscsi_eh_recover_target</code><span class="sig-paren">(</span>struct scsi_cmnd *<em>&nbsp;sc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_eh_recover_target" title="Permalink to this definition">¶</a></dt>
<dd><p>reset target and possibly the session</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">sc</span></code></dt>
<dd>scsi command</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will attempt to send a warm target reset. If that fails,
we will escalate to ERL0 session recovery.</p>
<dl class="function">
<dt id="c.iscsi_host_add">
int <code class="descname">iscsi_host_add</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_host_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add host to system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>scsi host</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>parent device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called by partial offload and software iscsi drivers
to add a host to the system.</p>
<dl class="function">
<dt id="c.iscsi_host_alloc">
struct Scsi_Host * <code class="descname">iscsi_host_alloc</code><span class="sig-paren">(</span>struct scsi_host_template *<em>&nbsp;sht</em>, int<em>&nbsp;dd_data_size</em>, bool<em>&nbsp;xmit_can_sleep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_host_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a host and driver data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scsi_host_template</span> <span class="pre">*</span> <span class="pre">sht</span></code></dt>
<dd>scsi host template</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dd_data_size</span></code></dt>
<dd>driver host data size</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">xmit_can_sleep</span></code></dt>
<dd>bool indicating if LLD will queue IO from a work queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called by partial offload and software iscsi drivers.
To access the driver specific memory use the <code class="xref c c-func docutils literal"><span class="pre">iscsi_host_priv()</span></code> macro.</p>
<dl class="function">
<dt id="c.iscsi_host_remove">
void <code class="descname">iscsi_host_remove</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_host_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove host and sessions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>scsi host</dd>
</dl>
<p><strong>Description</strong></p>
<p>If there are any sessions left, this will initiate the removal and wait
for the completion.</p>
<dl class="function">
<dt id="c.iscsi_session_setup">
struct iscsi_cls_session * <code class="descname">iscsi_session_setup</code><span class="sig-paren">(</span>struct iscsi_transport *<em>&nbsp;iscsit</em>, struct Scsi_Host *<em>&nbsp;shost</em>, uint16_t<em>&nbsp;cmds_max</em>, int<em>&nbsp;dd_size</em>, int<em>&nbsp;cmd_task_size</em>, uint32_t<em>&nbsp;initial_cmdsn</em>, unsigned int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_session_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi cls session and host and session</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*</span> <span class="pre">iscsit</span></code></dt>
<dd>iscsi transport template</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>scsi host</dd>
<dt><code class="docutils literal"><span class="pre">uint16_t</span> <span class="pre">cmds_max</span></code></dt>
<dd>session can queue</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt>
<dd>private driver data size, added to session allocation size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cmd_task_size</span></code></dt>
<dd>LLD task private data size</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">initial_cmdsn</span></code></dt>
<dd>initial CmdSN</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>target ID to add to this session</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used by software iscsi_transports that allocate
a session per scsi host.</p>
<p>Callers should set cmds_max to the largest total numer (mgmt + scsi) of
tasks they support. The iscsi layer reserves ISCSI_MGMT_CMDS_MAX tasks
for nop handling and login/logout requests.</p>
<dl class="function">
<dt id="c.iscsi_session_teardown">
void <code class="descname">iscsi_session_teardown</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em>&nbsp;cls_session</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_session_teardown" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy session, host, and cls_session</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">cls_session</span></code></dt>
<dd>iscsi session</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_conn_setup">
struct iscsi_cls_conn * <code class="descname">iscsi_conn_setup</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em>&nbsp;cls_session</em>, int<em>&nbsp;dd_size</em>, uint32_t<em>&nbsp;conn_idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_conn_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi_cls_conn and iscsi_conn</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">cls_session</span></code></dt>
<dd>iscsi_cls_session</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt>
<dd>private driver data size</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">conn_idx</span></code></dt>
<dd>cid</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_conn_teardown">
void <code class="descname">iscsi_conn_teardown</code><span class="sig-paren">(</span>struct iscsi_cls_conn *<em>&nbsp;cls_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_conn_teardown" title="Permalink to this definition">¶</a></dt>
<dd><p>teardown iscsi connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*</span> <span class="pre">cls_conn</span></code></dt>
<dd>iscsi class connection</dd>
</dl>
<p><strong>Description</strong></p>
<p>TODO: we may need to make this into a two step process
like scsi-mls remove + put host</p>
</div>
<div class="section" id="iscsi-boot-information">
<h2>iSCSI boot information<a class="headerlink" href="#iscsi-boot-information" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.iscsi_boot_create_target">
struct iscsi_boot_kobj * <code class="descname">iscsi_boot_create_target</code><span class="sig-paren">(</span>struct iscsi_boot_kset *<em>&nbsp;boot_kset</em>, int<em>&nbsp;index</em>, void *<em>&nbsp;data</em>, ssize_t (*show) (void<em>&nbsp;*data</em>, int<em>&nbsp;type</em>, char<em>&nbsp;*buf</em>, umode_t (*is_visible) (void<em>&nbsp;*data</em>, int<em>&nbsp;type</em>, void (*release) (void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_target" title="Permalink to this definition">¶</a></dt>
<dd><p>create boot target sysfs dir</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*</span> <span class="pre">boot_kset</span></code></dt>
<dd>boot kset</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>the target id</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>driver specific data for target</dd>
<dt><code class="docutils literal"><span class="pre">ssize_t</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">char</span> <span class="pre">*buf)</span> <span class="pre">show</span></code></dt>
<dd>attr show function</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type)</span> <span class="pre">is_visible</span></code></dt>
<dd>attr visibility function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data)</span> <span class="pre">release</span></code></dt>
<dd>release function</dd>
</dl>
<p><strong>Note</strong></p>
<p>The boot sysfs lib will free the data passed in for the caller
when all refs to the target kobject have been released.</p>
<dl class="function">
<dt id="c.iscsi_boot_create_initiator">
struct iscsi_boot_kobj * <code class="descname">iscsi_boot_create_initiator</code><span class="sig-paren">(</span>struct iscsi_boot_kset *<em>&nbsp;boot_kset</em>, int<em>&nbsp;index</em>, void *<em>&nbsp;data</em>, ssize_t (*show) (void<em>&nbsp;*data</em>, int<em>&nbsp;type</em>, char<em>&nbsp;*buf</em>, umode_t (*is_visible) (void<em>&nbsp;*data</em>, int<em>&nbsp;type</em>, void (*release) (void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_initiator" title="Permalink to this definition">¶</a></dt>
<dd><p>create boot initiator sysfs dir</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*</span> <span class="pre">boot_kset</span></code></dt>
<dd>boot kset</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>the initiator id</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>driver specific data</dd>
<dt><code class="docutils literal"><span class="pre">ssize_t</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">char</span> <span class="pre">*buf)</span> <span class="pre">show</span></code></dt>
<dd>attr show function</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type)</span> <span class="pre">is_visible</span></code></dt>
<dd>attr visibility function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data)</span> <span class="pre">release</span></code></dt>
<dd>release function</dd>
</dl>
<p><strong>Note</strong></p>
<p>The boot sysfs lib will free the data passed in for the caller
when all refs to the initiator kobject have been released.</p>
<dl class="function">
<dt id="c.iscsi_boot_create_ethernet">
struct iscsi_boot_kobj * <code class="descname">iscsi_boot_create_ethernet</code><span class="sig-paren">(</span>struct iscsi_boot_kset *<em>&nbsp;boot_kset</em>, int<em>&nbsp;index</em>, void *<em>&nbsp;data</em>, ssize_t (*show) (void<em>&nbsp;*data</em>, int<em>&nbsp;type</em>, char<em>&nbsp;*buf</em>, umode_t (*is_visible) (void<em>&nbsp;*data</em>, int<em>&nbsp;type</em>, void (*release) (void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_ethernet" title="Permalink to this definition">¶</a></dt>
<dd><p>create boot ethernet sysfs dir</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*</span> <span class="pre">boot_kset</span></code></dt>
<dd>boot kset</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>the ethernet device id</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>driver specific data</dd>
<dt><code class="docutils literal"><span class="pre">ssize_t</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">char</span> <span class="pre">*buf)</span> <span class="pre">show</span></code></dt>
<dd>attr show function</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type)</span> <span class="pre">is_visible</span></code></dt>
<dd>attr visibility function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)</span> <span class="pre">(void</span> <span class="pre">*data)</span> <span class="pre">release</span></code></dt>
<dd>release function</dd>
</dl>
<p><strong>Note</strong></p>
<p>The boot sysfs lib will free the data passed in for the caller
when all refs to the ethernet kobject have been released.</p>
<dl class="function">
<dt id="c.iscsi_boot_create_acpitbl">
struct iscsi_boot_kobj * <code class="descname">iscsi_boot_create_acpitbl</code><span class="sig-paren">(</span>struct iscsi_boot_kset *<em>&nbsp;boot_kset</em>, int<em>&nbsp;index</em>, void *<em>&nbsp;data</em>, ssize_t (*show) (void<em>&nbsp;*data</em>, int<em>&nbsp;type</em>, char<em>&nbsp;*buf</em>, umode_t (*is_visible) (void<em>&nbsp;*data</em>, int<em>&nbsp;type</em>, void (*release) (void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_acpitbl" title="Permalink to this definition">¶</a></dt>
<dd><p>create boot acpi table sysfs dir</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*</span> <span class="pre">boot_kset</span></code></dt>
<dd>boot kset</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>not used</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>driver specific data</dd>
<dt><code class="docutils literal"><span class="pre">ssize_t</span> <span class="pre">(*)(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">char</span> <span class="pre">*buf)</span> <span class="pre">show</span></code></dt>
<dd>attr show function</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">(*)(void</span> <span class="pre">*data,</span> <span class="pre">int</span> <span class="pre">type)</span> <span class="pre">is_visible</span></code></dt>
<dd>attr visibility function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*data)</span> <span class="pre">release</span></code></dt>
<dd>release function</dd>
</dl>
<p><strong>Note</strong></p>
<p>The boot sysfs lib will free the data passed in for the caller
when all refs to the acpitbl kobject have been released.</p>
<dl class="function">
<dt id="c.iscsi_boot_create_kset">
struct iscsi_boot_kset * <code class="descname">iscsi_boot_create_kset</code><span class="sig-paren">(</span>const char *<em>&nbsp;set_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_kset" title="Permalink to this definition">¶</a></dt>
<dd><p>creates root sysfs tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">set_name</span></code></dt>
<dd>name of root dir</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_boot_create_host_kset">
struct iscsi_boot_kset * <code class="descname">iscsi_boot_create_host_kset</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;hostno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_create_host_kset" title="Permalink to this definition">¶</a></dt>
<dd><p>creates root sysfs tree for a scsi host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">hostno</span></code></dt>
<dd>host number of scsi host</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_boot_destroy_kset">
void <code class="descname">iscsi_boot_destroy_kset</code><span class="sig-paren">(</span>struct iscsi_boot_kset *<em>&nbsp;boot_kset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_boot_destroy_kset" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy kset and kobjects under it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_boot_kset</span> <span class="pre">*</span> <span class="pre">boot_kset</span></code></dt>
<dd>boot kset</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will remove the kset and kobjects and attrs under it.</p>
</div>
<div class="section" id="iscsi-transport-class">
<h2>iSCSI transport class<a class="headerlink" href="#iscsi-transport-class" title="Permalink to this headline">¶</a></h2>
<p>The file drivers/scsi/scsi_transport_iscsi.c defines transport
attributes for the iSCSI class, which sends SCSI packets over TCP/IP
connections.</p>
<dl class="function">
<dt id="c.iscsi_create_flashnode_sess">
struct iscsi_bus_flash_session * <code class="descname">iscsi_create_flashnode_sess</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em>, int<em>&nbsp;index</em>, struct iscsi_transport *<em>&nbsp;transport</em>, int<em>&nbsp;dd_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>Add flashnode session entry in sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>pointer to host data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of flashnode to add in sysfs</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt>
<dd>pointer to transport data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt>
<dd>total size to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a sysfs entry for the flashnode session attributes</p>
<p><strong>Return</strong></p>
<blockquote>
<div>pointer to allocated flashnode sess on success
<code class="docutils literal"><span class="pre">NULL</span></code> on failure</div></blockquote>
<dl class="function">
<dt id="c.iscsi_create_flashnode_conn">
struct iscsi_bus_flash_conn * <code class="descname">iscsi_create_flashnode_conn</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em>, struct iscsi_bus_flash_session *<em>&nbsp;fnode_sess</em>, struct iscsi_transport *<em>&nbsp;transport</em>, int<em>&nbsp;dd_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_flashnode_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>Add flashnode conn entry in sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>pointer to host data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*</span> <span class="pre">fnode_sess</span></code></dt>
<dd>pointer to the parent flashnode session entry</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt>
<dd>pointer to transport data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt>
<dd>total size to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a sysfs entry for the flashnode connection attributes</p>
<p><strong>Return</strong></p>
<blockquote>
<div>pointer to allocated flashnode conn on success
<code class="docutils literal"><span class="pre">NULL</span></code> on failure</div></blockquote>
<dl class="function">
<dt id="c.iscsi_find_flashnode_sess">
struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> * <code class="descname">iscsi_find_flashnode_sess</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_find_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>finds flashnode session entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>pointer to host data</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to data containing value to use for comparison</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt>
<dd>function pointer that does actual comparison</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the flashnode session object comparing the data passed using logic
defined in passed function pointer</p>
<p><strong>Return</strong></p>
<blockquote>
<div>pointer to found flashnode session device object on success
<code class="docutils literal"><span class="pre">NULL</span></code> on failure</div></blockquote>
<dl class="function">
<dt id="c.iscsi_find_flashnode_conn">
struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> * <code class="descname">iscsi_find_flashnode_conn</code><span class="sig-paren">(</span>struct iscsi_bus_flash_session *<em>&nbsp;fnode_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_find_flashnode_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>finds flashnode connection entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*</span> <span class="pre">fnode_sess</span></code></dt>
<dd>pointer to parent flashnode session entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the flashnode connection object comparing the data passed using logic
defined in passed function pointer</p>
<p><strong>Return</strong></p>
<blockquote>
<div>pointer to found flashnode connection device object on success
<code class="docutils literal"><span class="pre">NULL</span></code> on failure</div></blockquote>
<dl class="function">
<dt id="c.iscsi_destroy_flashnode_sess">
void <code class="descname">iscsi_destroy_flashnode_sess</code><span class="sig-paren">(</span>struct iscsi_bus_flash_session *<em>&nbsp;fnode_sess</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_flashnode_sess" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy flashnode session entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_bus_flash_session</span> <span class="pre">*</span> <span class="pre">fnode_sess</span></code></dt>
<dd>pointer to flashnode session entry to be destroyed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Deletes the flashnode session entry and all children flashnode connection
entries from sysfs</p>
<dl class="function">
<dt id="c.iscsi_destroy_all_flashnode">
void <code class="descname">iscsi_destroy_all_flashnode</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_all_flashnode" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy all flashnode session entries</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>pointer to host data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroys all the flashnode session entries and all corresponding children
flashnode connection entries from sysfs</p>
<dl class="function">
<dt id="c.iscsi_scan_finished">
int <code class="descname">iscsi_scan_finished</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em>, unsigned long<em>&nbsp;time</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_scan_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to report when running scans are done</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>scsi host</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">time</span></code></dt>
<dd>scan run time</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by drives like qla4xxx to report to the scsi
layer when the scans it kicked off at module load time are done.</p>
<dl class="function">
<dt id="c.iscsi_block_scsi_eh">
int <code class="descname">iscsi_block_scsi_eh</code><span class="sig-paren">(</span>struct scsi_cmnd *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_block_scsi_eh" title="Permalink to this definition">¶</a></dt>
<dd><p>block scsi eh until session state has transistioned</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scsi_cmnd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>scsi cmd passed to scsi eh handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the session is down this function will wait for the recovery
timer to fire or for the session to be logged back in. If the
recovery timer fires then FAST_IO_FAIL is returned. The caller
should pass this error value to the scsi eh.</p>
<dl class="function">
<dt id="c.iscsi_unblock_session">
void <code class="descname">iscsi_unblock_session</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em>&nbsp;session</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_unblock_session" title="Permalink to this definition">¶</a></dt>
<dd><p>set a session as logged in and start IO.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">session</span></code></dt>
<dd>iscsi session</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark a session as ready to accept IO.</p>
<dl class="function">
<dt id="c.iscsi_create_session">
struct iscsi_cls_session * <code class="descname">iscsi_create_session</code><span class="sig-paren">(</span>struct Scsi_Host *<em>&nbsp;shost</em>, struct iscsi_transport *<em>&nbsp;transport</em>, int<em>&nbsp;dd_size</em>, unsigned int<em>&nbsp;target_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_session" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi class session</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">Scsi_Host</span> <span class="pre">*</span> <span class="pre">shost</span></code></dt>
<dd>scsi host</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_transport</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt>
<dd>iscsi transport</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt>
<dd>private driver data size</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">target_id</span></code></dt>
<dd>which target</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called from a LLD or iscsi_transport.</p>
<dl class="function">
<dt id="c.iscsi_create_conn">
struct iscsi_cls_conn * <code class="descname">iscsi_create_conn</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em>&nbsp;session</em>, int<em>&nbsp;dd_size</em>, uint32_t<em>&nbsp;cid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_create_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>create iscsi class connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">session</span></code></dt>
<dd>iscsi cls session</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">dd_size</span></code></dt>
<dd>private driver data size</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">cid</span></code></dt>
<dd>connection id</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called from a LLD or iscsi_transport. The connection
is child of the session so cid must be unique for all connections
on the session.</p>
<p>Since we do not support MCS, cid will normally be zero. In some cases
for software iscsi we could be trying to preallocate a connection struct
in which case there could be two connection structs and cid would be
non-zero.</p>
<dl class="function">
<dt id="c.iscsi_destroy_conn">
int <code class="descname">iscsi_destroy_conn</code><span class="sig-paren">(</span>struct iscsi_cls_conn *<em>&nbsp;conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_destroy_conn" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy iscsi class connection</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_cls_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi cls session</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be called from a LLD or iscsi_transport.</p>
<dl class="function">
<dt id="c.iscsi_session_event">
int <code class="descname">iscsi_session_event</code><span class="sig-paren">(</span>struct iscsi_cls_session *<em>&nbsp;session</em>, enum iscsi_uevent_e<em>&nbsp;event</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_session_event" title="Permalink to this definition">¶</a></dt>
<dd><p>send session destr. completion event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_cls_session</span> <span class="pre">*</span> <span class="pre">session</span></code></dt>
<dd>iscsi class session</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">iscsi_uevent_e</span> <span class="pre">event</span></code></dt>
<dd>type of event</dd>
</dl>
</div>
<div class="section" id="iscsi-tcp-interfaces">
<h2>iSCSI TCP interfaces<a class="headerlink" href="#iscsi-tcp-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.iscsi_sw_tcp_recv">
int <code class="descname">iscsi_sw_tcp_recv</code><span class="sig-paren">(</span>read_descriptor_t *<em>&nbsp;rd_desc</em>, struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;offset</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>TCP receive in sendfile fashion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">read_descriptor_t</span> <span class="pre">*</span> <span class="pre">rd_desc</span></code></dt>
<dd>read descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>socket buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>offset in skb</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>skb-&gt;len - offset</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_sw_sk_state_check">
int <code class="descname">iscsi_sw_sk_state_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_sk_state_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check socket state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the socket is in CLOSE or CLOSE_WAIT we should
not close the connection if there is still some
data pending.</p>
<p>Must be called with sk_callback_lock.</p>
<dl class="function">
<dt id="c.iscsi_sw_tcp_write_space">
void <code class="descname">iscsi_sw_tcp_write_space</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_write_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when more output buffer space is available</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket space is available for</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_sw_tcp_xmit_segment">
int <code class="descname">iscsi_sw_tcp_xmit_segment</code><span class="sig-paren">(</span>struct iscsi_tcp_conn *<em>&nbsp;tcp_conn</em>, struct iscsi_segment *<em>&nbsp;segment</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_xmit_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>transmit segment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_tcp_conn</span> <span class="pre">*</span> <span class="pre">tcp_conn</span></code></dt>
<dd>the iSCSI TCP connection</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_segment</span> <span class="pre">*</span> <span class="pre">segment</span></code></dt>
<dd>the buffer to transmnit</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function transmits as much of the buffer as
the network layer will accept, and returns the number of
bytes transmitted.</p>
<p>If CRC hashing is enabled, the function will compute the
hash as it goes. When the entire segment has been transmitted,
it will retrieve the hash value and send it as well.</p>
<dl class="function">
<dt id="c.iscsi_sw_tcp_xmit">
int <code class="descname">iscsi_sw_tcp_xmit</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>TCP transmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi connection</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_sw_tcp_xmit_qlen">
int <code class="descname">iscsi_sw_tcp_xmit_qlen</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_sw_tcp_xmit_qlen" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of bytes queued for xmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi connection</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_tcp_segment_done">
int <code class="descname">iscsi_tcp_segment_done</code><span class="sig-paren">(</span>struct iscsi_tcp_conn *<em>&nbsp;tcp_conn</em>, struct iscsi_segment *<em>&nbsp;segment</em>, int<em>&nbsp;recv</em>, unsigned<em>&nbsp;copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_segment_done" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the segment is complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_tcp_conn</span> <span class="pre">*</span> <span class="pre">tcp_conn</span></code></dt>
<dd>iscsi tcp connection</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_segment</span> <span class="pre">*</span> <span class="pre">segment</span></code></dt>
<dd>iscsi segment to check</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">recv</span></code></dt>
<dd>set to one of this is called from the recv path</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">copied</span></code></dt>
<dd>number of bytes copied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if we’re done receiving this segment. If the receive
buffer is full but we expect more data, move on to the
next entry in the scatterlist.</p>
<p>If the amount of data we received isn’t a multiple of 4,
we will transparently receive the pad bytes, too.</p>
<p>This function must be re-entrant.</p>
<dl class="function">
<dt id="c.iscsi_tcp_hdr_recv_prep">
void <code class="descname">iscsi_tcp_hdr_recv_prep</code><span class="sig-paren">(</span>struct iscsi_tcp_conn *<em>&nbsp;tcp_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_hdr_recv_prep" title="Permalink to this definition">¶</a></dt>
<dd><p>prep segment for hdr reception</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_tcp_conn</span> <span class="pre">*</span> <span class="pre">tcp_conn</span></code></dt>
<dd>iscsi connection to prep for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function always passes NULL for the hash argument, because when this
function is called we do not yet know the final size of the header and want
to delay the digest processing until we know that.</p>
<dl class="function">
<dt id="c.iscsi_tcp_cleanup_task">
void <code class="descname">iscsi_tcp_cleanup_task</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_cleanup_task" title="Permalink to this definition">¶</a></dt>
<dd><p>free tcp_task resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi task</dd>
</dl>
<p><strong>Description</strong></p>
<p>must be called with session back_lock</p>
<dl class="function">
<dt id="c.iscsi_tcp_recv_segment_is_hdr">
int <code class="descname">iscsi_tcp_recv_segment_is_hdr</code><span class="sig-paren">(</span>struct iscsi_tcp_conn *<em>&nbsp;tcp_conn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_recv_segment_is_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>tests if we are reading in a header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_tcp_conn</span> <span class="pre">*</span> <span class="pre">tcp_conn</span></code></dt>
<dd>iscsi tcp conn</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns non zero if we are currently processing or setup to process
a header.</p>
<dl class="function">
<dt id="c.iscsi_tcp_recv_skb">
int <code class="descname">iscsi_tcp_recv_skb</code><span class="sig-paren">(</span>struct iscsi_conn *<em>&nbsp;conn</em>, struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;offset</em>, bool<em>&nbsp;offloaded</em>, int *<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_recv_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>Process skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_conn</span> <span class="pre">*</span> <span class="pre">conn</span></code></dt>
<dd>iscsi connection</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>network buffer with header and/or data segment</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>offset in skb</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">offloaded</span></code></dt>
<dd>bool indicating if transfer was offloaded</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">status</span></code></dt>
<dd>iscsi TCP status result</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will return status of transfer in <strong>status</strong>. And will return
number of bytes copied.</p>
<dl class="function">
<dt id="c.iscsi_tcp_task_init">
int <code class="descname">iscsi_tcp_task_init</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_task_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize iSCSI SCSI_READ or SCSI_WRITE commands</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>scsi command task</dd>
</dl>
<dl class="function">
<dt id="c.iscsi_tcp_task_xmit">
int <code class="descname">iscsi_tcp_task_xmit</code><span class="sig-paren">(</span>struct iscsi_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.iscsi_tcp_task_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>xmit normal PDU task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iscsi_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>iscsi command task</dd>
</dl>
<p><strong>Description</strong></p>
<p>We’re expected to return 0 when everything was transmitted successfully,
-EAGAIN if there’s still data in the queue, or != 0 for any other kind
of error.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mtdnand.html" class="btn btn-neutral float-right" title="MTD NAND Driver Programming Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="libata.html" class="btn btn-neutral" title="libATA Developer’s Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>