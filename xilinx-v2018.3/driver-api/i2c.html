

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>I2C and SMBus Subsystem &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="High Speed Synchronous Serial Interface (HSI)" href="hsi.html" />
    <link rel="prev" title="Serial Peripheral Interface (SPI)" href="spi.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
      <li>I<sup>2</sup>C and SMBus Subsystem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/driver-api/i2c.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="i2c-and-smbus-subsystem">
<h1>I<sup>2</sup>C and SMBus Subsystem<a class="headerlink" href="#i2c-and-smbus-subsystem" title="Permalink to this headline">¶</a></h1>
<p>I<sup>2</sup>C (or without fancy typography, “I2C”) is an acronym for
the “Inter-IC” bus, a simple bus protocol which is widely used where low
data rate communications suffice. Since it’s also a licensed trademark,
some vendors use another name (such as “Two-Wire Interface”, TWI) for
the same bus. I2C only needs two signals (SCL for clock, SDA for data),
conserving board real estate and minimizing signal quality issues. Most
I2C devices use seven bit addresses, and bus speeds of up to 400 kHz;
there’s a high speed extension (3.4 MHz) that’s not yet found wide use.
I2C is a multi-master bus; open drain signaling is used to arbitrate
between masters, as well as to handshake and to synchronize clocks from
slower clients.</p>
<p>The Linux I2C programming interfaces support the master side of bus
interactions and the slave side. The programming interface is
structured around two kinds of driver, and two kinds of device. An I2C
“Adapter Driver” abstracts the controller hardware; it binds to a
physical device (perhaps a PCI device or platform_device) and exposes a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span></code> representing each
I2C bus segment it manages. On each I2C bus segment will be I2C devices
represented by a <a class="reference internal" href="#c.i2c_client" title="i2c_client"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">i2c_client</span></code></a>.
Those devices will be bound to a <a class="reference internal" href="#c.i2c_driver" title="i2c_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">i2c_driver</span></code></a>, which should follow the standard Linux driver model. There
are functions to perform various I2C protocol operations; at this writing
all such functions are usable only from task context.</p>
<p>The System Management Bus (SMBus) is a sibling protocol. Most SMBus
systems are also I2C conformant. The electrical constraints are tighter
for SMBus, and it standardizes particular protocol messages and idioms.
Controllers that support I2C can also support most SMBus operations, but
SMBus controllers don’t support all the protocol options that an I2C
controller will. There are functions to perform various SMBus protocol
operations, either using I2C primitives or by issuing SMBus commands to
i2c_adapter devices which don’t support those I2C operations.</p>
<dl class="type">
<dt id="c.i2c_driver">
struct <code class="descname">i2c_driver</code><a class="headerlink" href="#c.i2c_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>represent an I2C device driver</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i2c_driver {
  unsigned int class;
  int (* attach_adapter) (struct i2c_adapter *);
  int (* probe) (struct i2c_client *, const struct i2c_device_id *);
  int (* remove) (struct i2c_client *);
  int (* probe_new) (struct i2c_client *);
  void (* shutdown) (struct i2c_client *);
  void (* alert) (struct i2c_client *, enum i2c_alert_protocol protocol, unsigned int data);
  int (* command) (struct i2c_client *client, unsigned int cmd, void *arg);
  struct device_driver driver;
  const struct i2c_device_id * id_table;
  int (* detect) (struct i2c_client *, struct i2c_board_info *);
  const unsigned short * address_list;
  struct list_head clients;
  bool disable_i2c_core_irq_mapping;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">class</span></code></dt>
<dd>What kind of i2c device we instantiate (for detect)</dd>
<dt><code class="docutils literal"><span class="pre">attach_adapter</span></code></dt>
<dd>Callback for bus addition (deprecated)</dd>
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>Callback for device binding - soon to be deprecated</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>Callback for device unbinding</dd>
<dt><code class="docutils literal"><span class="pre">probe_new</span></code></dt>
<dd>New callback for device binding</dd>
<dt><code class="docutils literal"><span class="pre">shutdown</span></code></dt>
<dd>Callback for device shutdown</dd>
<dt><code class="docutils literal"><span class="pre">alert</span></code></dt>
<dd>Alert callback, for example for the SMBus alert protocol</dd>
<dt><code class="docutils literal"><span class="pre">command</span></code></dt>
<dd>Callback for bus-wide signaling (optional)</dd>
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>Device driver model driver</dd>
<dt><code class="docutils literal"><span class="pre">id_table</span></code></dt>
<dd>List of I2C devices supported by this driver</dd>
<dt><code class="docutils literal"><span class="pre">detect</span></code></dt>
<dd>Callback for device detection</dd>
<dt><code class="docutils literal"><span class="pre">address_list</span></code></dt>
<dd>The I2C addresses to probe (for detect)</dd>
<dt><code class="docutils literal"><span class="pre">clients</span></code></dt>
<dd>List of detected clients we created (for i2c-core use only)</dd>
<dt><code class="docutils literal"><span class="pre">disable_i2c_core_irq_mapping</span></code></dt>
<dd>Tell the i2c-core to not do irq-mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>The driver.owner field should be set to the module owner of this driver.
The driver.name field should be set to the name of this driver.</p>
<p>For automatic device detection, both <strong>detect</strong> and <strong>address_list</strong> must
be defined. <strong>class</strong> should also be set, otherwise only devices forced
with module parameters will be created. The detect function must
fill at least the name field of the i2c_board_info structure it is
handed upon successful detection, and possibly also the flags field.</p>
<p>If <strong>detect</strong> is missing, the driver will still work fine for enumerated
devices. Detected devices simply won’t be supported. This is expected
for the many I2C/SMBus devices which can’t be detected reliably, and
the ones which can always be enumerated in practice.</p>
<p>The i2c_client structure which is handed to the <strong>detect</strong> callback is
not a real i2c_client. It is initialized just enough so that you can
call i2c_smbus_read_byte_data and friends on it. Don’t do anything
else with it. In particular, calling dev_dbg and friends on it is
not allowed.</p>
<dl class="type">
<dt id="c.i2c_client">
struct <code class="descname">i2c_client</code><a class="headerlink" href="#c.i2c_client" title="Permalink to this definition">¶</a></dt>
<dd><p>represent an I2C slave device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i2c_client {
  unsigned short flags;
  unsigned short addr;
  char name;
  struct i2c_adapter * adapter;
  struct device dev;
  int irq;
  struct list_head detected;
#if IS_ENABLED(CONFIG_I2C_SLAVE
  i2c_slave_cb_t slave_cb;
#endif
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>I2C_CLIENT_TEN indicates the device uses a ten bit chip address;
I2C_CLIENT_PEC indicates it uses SMBus Packet Error Checking</dd>
<dt><code class="docutils literal"><span class="pre">addr</span></code></dt>
<dd>Address used on the I2C bus connected to the parent adapter.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Indicates the type of the device, usually a chip name that’s
generic enough to hide second-sourcing and compatible revisions.</dd>
<dt><code class="docutils literal"><span class="pre">adapter</span></code></dt>
<dd>manages the bus segment hosting this I2C device</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Driver model device node for the slave.</dd>
<dt><code class="docutils literal"><span class="pre">irq</span></code></dt>
<dd>indicates the IRQ generated by this device (if any)</dd>
<dt><code class="docutils literal"><span class="pre">detected</span></code></dt>
<dd>member of an i2c_driver.clients list or i2c-core’s
userspace_devices list</dd>
<dt><code class="docutils literal"><span class="pre">slave_cb</span></code></dt>
<dd>Callback when I2C slave mode of an adapter is used. The adapter
calls it to pass on slave events to the slave driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>An i2c_client identifies a single device (i.e. chip) connected to an
i2c bus. The behaviour exposed to Linux is defined by the driver
managing the device.</p>
<dl class="type">
<dt id="c.i2c_board_info">
struct <code class="descname">i2c_board_info</code><a class="headerlink" href="#c.i2c_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>template for device creation</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i2c_board_info {
  char type;
  unsigned short flags;
  unsigned short addr;
  void * platform_data;
  struct dev_archdata * archdata;
  struct device_node * of_node;
  struct fwnode_handle * fwnode;
  const struct property_entry * properties;
  const struct resource * resources;
  unsigned int num_resources;
  int irq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>chip type, to initialize i2c_client.name</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>to initialize i2c_client.flags</dd>
<dt><code class="docutils literal"><span class="pre">addr</span></code></dt>
<dd>stored in i2c_client.addr</dd>
<dt><code class="docutils literal"><span class="pre">platform_data</span></code></dt>
<dd>stored in i2c_client.dev.platform_data</dd>
<dt><code class="docutils literal"><span class="pre">archdata</span></code></dt>
<dd>copied into i2c_client.dev.archdata</dd>
<dt><code class="docutils literal"><span class="pre">of_node</span></code></dt>
<dd>pointer to OpenFirmware device node</dd>
<dt><code class="docutils literal"><span class="pre">fwnode</span></code></dt>
<dd>device node supplied by the platform firmware</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>additional device properties for the device</dd>
<dt><code class="docutils literal"><span class="pre">resources</span></code></dt>
<dd>resources associated with the device</dd>
<dt><code class="docutils literal"><span class="pre">num_resources</span></code></dt>
<dd>number of resources in the <strong>resources</strong> array</dd>
<dt><code class="docutils literal"><span class="pre">irq</span></code></dt>
<dd>stored in i2c_client.irq</dd>
</dl>
<p><strong>Description</strong></p>
<p>I2C doesn’t actually support hardware probing, although controllers and
devices may be able to use I2C_SMBUS_QUICK to tell whether or not there’s
a device at a given address.  Drivers commonly need more information than
that, such as chip type, configuration, associated IRQ, and so on.</p>
<p>i2c_board_info is used to build tables of information listing I2C devices
that are present.  This information is used to grow the driver model tree.
For mainboards this is done statically using <a class="reference internal" href="#c.i2c_register_board_info" title="i2c_register_board_info"><code class="xref c c-func docutils literal"><span class="pre">i2c_register_board_info()</span></code></a>;
bus numbers identify adapters that aren’t yet available.  For add-on boards,
<a class="reference internal" href="#c.i2c_new_device" title="i2c_new_device"><code class="xref c c-func docutils literal"><span class="pre">i2c_new_device()</span></code></a> does this dynamically with the adapter already known.</p>
<dl class="function">
<dt id="c.I2C_BOARD_INFO">
<code class="descname">I2C_BOARD_INFO</code><span class="sig-paren">(</span><em>dev_type</em>, <em>dev_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.I2C_BOARD_INFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro used to list an i2c device and its address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_type</span></code></dt>
<dd>identifies the device type</dd>
<dt><code class="docutils literal"><span class="pre">dev_addr</span></code></dt>
<dd>the device’s address on the bus.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro initializes essential fields of a struct i2c_board_info,
declaring what has been provided on a particular board.  Optional
fields (such as associated irq, or device-specific platform_data)
are provided using conventional syntax.</p>
<dl class="type">
<dt id="c.i2c_algorithm">
struct <code class="descname">i2c_algorithm</code><a class="headerlink" href="#c.i2c_algorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>represent I2C transfer method</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i2c_algorithm {
  int (* master_xfer) (struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
  int (* smbus_xfer) (struct i2c_adapter *adap, u16 addr,unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data);
  u32 (* functionality) (struct i2c_adapter *);
#if IS_ENABLED(CONFIG_I2C_SLAVE
  int (* reg_slave) (struct i2c_client *client);
  int (* unreg_slave) (struct i2c_client *client);
#endif
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">master_xfer</span></code></dt>
<dd>Issue a set of i2c transactions to the given I2C adapter
defined by the msgs array, with num messages available to transfer via
the adapter specified by adap.</dd>
<dt><code class="docutils literal"><span class="pre">smbus_xfer</span></code></dt>
<dd>Issue smbus transactions to the given I2C adapter. If this
is not present, then the bus layer will try and convert the SMBus calls
into I2C transfers instead.</dd>
<dt><code class="docutils literal"><span class="pre">functionality</span></code></dt>
<dd>Return the flags that this algorithm/adapter pair supports
from the I2C_FUNC_* flags.</dd>
<dt><code class="docutils literal"><span class="pre">reg_slave</span></code></dt>
<dd>Register given client to I2C slave mode of this adapter</dd>
<dt><code class="docutils literal"><span class="pre">unreg_slave</span></code></dt>
<dd>Unregister given client from I2C slave mode of this adapter</dd>
</dl>
<p><strong>Description</strong></p>
<p>The following structs are for those who like to implement new bus drivers:
i2c_algorithm is the interface to a class of hardware solutions which can
be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584
to name two of the most common.</p>
<p>The return codes from the <strong>master_xfer</strong> field should indicate the type of
error code that occurred during the transfer, as documented in the kernel
Documentation file Documentation/i2c/fault-codes.</p>
<dl class="type">
<dt id="c.i2c_lock_operations">
struct <code class="descname">i2c_lock_operations</code><a class="headerlink" href="#c.i2c_lock_operations" title="Permalink to this definition">¶</a></dt>
<dd><p>represent I2C locking operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i2c_lock_operations {
  void (* lock_bus) (struct i2c_adapter *, unsigned int flags);
  int (* trylock_bus) (struct i2c_adapter *, unsigned int flags);
  void (* unlock_bus) (struct i2c_adapter *, unsigned int flags);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">lock_bus</span></code></dt>
<dd>Get exclusive access to an I2C bus segment</dd>
<dt><code class="docutils literal"><span class="pre">trylock_bus</span></code></dt>
<dd>Try to get exclusive access to an I2C bus segment</dd>
<dt><code class="docutils literal"><span class="pre">unlock_bus</span></code></dt>
<dd>Release exclusive access to an I2C bus segment</dd>
</dl>
<p><strong>Description</strong></p>
<p>The main operations are wrapped by i2c_lock_bus and i2c_unlock_bus.</p>
<dl class="type">
<dt id="c.i2c_timings">
struct <code class="descname">i2c_timings</code><a class="headerlink" href="#c.i2c_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C timing information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i2c_timings {
  u32 bus_freq_hz;
  u32 scl_rise_ns;
  u32 scl_fall_ns;
  u32 scl_int_delay_ns;
  u32 sda_fall_ns;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bus_freq_hz</span></code></dt>
<dd>the bus frequency in Hz</dd>
<dt><code class="docutils literal"><span class="pre">scl_rise_ns</span></code></dt>
<dd>time SCL signal takes to rise in ns; t(r) in the I2C specification</dd>
<dt><code class="docutils literal"><span class="pre">scl_fall_ns</span></code></dt>
<dd>time SCL signal takes to fall in ns; t(f) in the I2C specification</dd>
<dt><code class="docutils literal"><span class="pre">scl_int_delay_ns</span></code></dt>
<dd>time IP core additionally needs to setup SCL in ns</dd>
<dt><code class="docutils literal"><span class="pre">sda_fall_ns</span></code></dt>
<dd>time SDA signal takes to fall in ns; t(f) in the I2C specification</dd>
</dl>
<dl class="type">
<dt id="c.i2c_bus_recovery_info">
struct <code class="descname">i2c_bus_recovery_info</code><a class="headerlink" href="#c.i2c_bus_recovery_info" title="Permalink to this definition">¶</a></dt>
<dd><p>I2C bus recovery information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i2c_bus_recovery_info {
  int (* recover_bus) (struct i2c_adapter *);
  int (* get_scl) (struct i2c_adapter *);
  void (* set_scl) (struct i2c_adapter *, int val);
  int (* get_sda) (struct i2c_adapter *);
  void (* prepare_recovery) (struct i2c_adapter *);
  void (* unprepare_recovery) (struct i2c_adapter *);
  int scl_gpio;
  int sda_gpio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">recover_bus</span></code></dt>
<dd>Recover routine. Either pass driver’s <code class="xref c c-func docutils literal"><span class="pre">recover_bus()</span></code> routine, or
<code class="xref c c-func docutils literal"><span class="pre">i2c_generic_scl_recovery()</span></code> or <code class="xref c c-func docutils literal"><span class="pre">i2c_generic_gpio_recovery()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">get_scl</span></code></dt>
<dd>This gets current value of SCL line. Mandatory for generic SCL
recovery. Used internally for generic GPIO recovery.</dd>
<dt><code class="docutils literal"><span class="pre">set_scl</span></code></dt>
<dd>This sets/clears SCL line. Mandatory for generic SCL recovery. Used
internally for generic GPIO recovery.</dd>
<dt><code class="docutils literal"><span class="pre">get_sda</span></code></dt>
<dd>This gets current value of SDA line. Optional for generic SCL
recovery. Used internally, if sda_gpio is a valid GPIO, for generic GPIO
recovery.</dd>
<dt><code class="docutils literal"><span class="pre">prepare_recovery</span></code></dt>
<dd>This will be called before starting recovery. Platform may
configure padmux here for SDA/SCL line or something else they want.</dd>
<dt><code class="docutils literal"><span class="pre">unprepare_recovery</span></code></dt>
<dd>This will be called after completing recovery. Platform
may configure padmux here for SDA/SCL line or something else they want.</dd>
<dt><code class="docutils literal"><span class="pre">scl_gpio</span></code></dt>
<dd>gpio number of the SCL line. Only required for GPIO recovery.</dd>
<dt><code class="docutils literal"><span class="pre">sda_gpio</span></code></dt>
<dd>gpio number of the SDA line. Only required for GPIO recovery.</dd>
</dl>
<dl class="type">
<dt id="c.i2c_adapter_quirks">
struct <code class="descname">i2c_adapter_quirks</code><a class="headerlink" href="#c.i2c_adapter_quirks" title="Permalink to this definition">¶</a></dt>
<dd><p>describe flaws of an i2c adapter</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct i2c_adapter_quirks {
  u64 flags;
  int max_num_msgs;
  u16 max_write_len;
  u16 max_read_len;
  u16 max_comb_1st_msg_len;
  u16 max_comb_2nd_msg_len;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>see I2C_AQ_* for possible flags and read below</dd>
<dt><code class="docutils literal"><span class="pre">max_num_msgs</span></code></dt>
<dd>maximum number of messages per transfer</dd>
<dt><code class="docutils literal"><span class="pre">max_write_len</span></code></dt>
<dd>maximum length of a write message</dd>
<dt><code class="docutils literal"><span class="pre">max_read_len</span></code></dt>
<dd>maximum length of a read message</dd>
<dt><code class="docutils literal"><span class="pre">max_comb_1st_msg_len</span></code></dt>
<dd>maximum length of the first msg in a combined message</dd>
<dt><code class="docutils literal"><span class="pre">max_comb_2nd_msg_len</span></code></dt>
<dd>maximum length of the second msg in a combined message</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note about combined messages: Some I2C controllers can only send one message
per transfer, plus something called combined message or write-then-read.
This is (usually) a small write message followed by a read message and
barely enough to access register based devices like EEPROMs. There is a flag
to support this mode. It implies max_num_msg = 2 and does the length checks
with max_comb_*_len because combined message mode usually has its own
limitations. Because of HW implementations, some controllers can actually do
write-then-anything or other variants. To support that, write-then-read has
been broken out into smaller bits like write-first and read-second which can
be combined as needed.</p>
<dl class="function">
<dt id="c.i2c_lock_bus">
void <code class="descname">i2c_lock_bus</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_lock_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Get exclusive access to an I2C bus segment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>Target I2C bus segment</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>I2C_LOCK_ROOT_ADAPTER locks the root i2c adapter, I2C_LOCK_SEGMENT
locks only this branch in the adapter tree</dd>
</dl>
<dl class="function">
<dt id="c.i2c_trylock_bus">
int <code class="descname">i2c_trylock_bus</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_trylock_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to get exclusive access to an I2C bus segment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>Target I2C bus segment</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>I2C_LOCK_ROOT_ADAPTER tries to locks the root i2c adapter,
I2C_LOCK_SEGMENT tries to lock only this branch in the adapter tree</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the I2C bus segment is locked, false otherwise</p>
<dl class="function">
<dt id="c.i2c_unlock_bus">
void <code class="descname">i2c_unlock_bus</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_unlock_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Release exclusive access to an I2C bus segment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>Target I2C bus segment</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>I2C_LOCK_ROOT_ADAPTER unlocks the root i2c adapter, I2C_LOCK_SEGMENT
unlocks only this branch in the adapter tree</dd>
</dl>
<dl class="function">
<dt id="c.i2c_check_quirks">
bool <code class="descname">i2c_check_quirks</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adap</em>, u64<em>&nbsp;quirks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_check_quirks" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for checking the quirk flags in an i2c adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>i2c adapter</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">quirks</span></code></dt>
<dd>quirk flags</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the adapter has all the specified quirk flags, false if not</p>
<dl class="function">
<dt id="c.module_i2c_driver">
<code class="descname">module_i2c_driver</code><span class="sig-paren">(</span><em>__i2c_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_i2c_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a modular I2C driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__i2c_driver</span></code></dt>
<dd>i2c_driver struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for I2C drivers which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code></a></p>
<dl class="function">
<dt id="c.builtin_i2c_driver">
<code class="descname">builtin_i2c_driver</code><span class="sig-paren">(</span><em>__i2c_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.builtin_i2c_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a builtin I2C driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__i2c_driver</span></code></dt>
<dd>i2c_driver struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for I2C drivers which do not do anything special in their
init. This eliminates a lot of boilerplate. Each driver may only
use this macro once, and calling it replaces <code class="xref c c-func docutils literal"><span class="pre">device_initcall()</span></code>.</p>
<dl class="function">
<dt id="c.i2c_register_board_info">
int <code class="descname">i2c_register_board_info</code><span class="sig-paren">(</span>int<em>&nbsp;busnum</em>, struct <a class="reference internal" href="#c.i2c_board_info" title="i2c_board_info">i2c_board_info</a> const *<em>&nbsp;info</em>, unsigned<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_register_board_info" title="Permalink to this definition">¶</a></dt>
<dd><p>statically declare I2C devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">busnum</span></code></dt>
<dd>identifies the bus to which these devices belong</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_board_info</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>vector of i2c device descriptors</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">len</span></code></dt>
<dd>how many descriptors in the vector; may be zero to reserve
the specified bus number.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Systems using the Linux I2C driver stack can declare tables of board info
while they initialize.  This should be done in board-specific init code
near <code class="xref c c-func docutils literal"><span class="pre">arch_initcall()</span></code> time, or equivalent, before any I2C adapter driver is
registered.  For example, mainboard init code could define several devices,
as could the init code for each daughtercard in a board stack.</p>
<p>The I2C devices will be created later, after the adapter for the relevant
bus has been registered.  After that moment, standard driver model tools
are used to bind “new style” I2C drivers to the devices.  The bus number
for any device declared using this routine is not available for dynamic
allocation.</p>
<p>The board info passed can safely be __initdata, but be careful of embedded
pointers (for platform_data, functions, etc) since that won’t be copied.
Device properties are deep-copied though.</p>
<dl class="function">
<dt id="c.i2c_verify_client">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="descname">i2c_verify_client</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_verify_client" title="Permalink to this definition">¶</a></dt>
<dd><p>return parameter as i2c_client, or NULL</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device, probably from some driver model iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>When traversing the driver model tree, perhaps using driver model
iterators like <strong>device_for_each_child()</strong>, you can’t assume very much
about the nodes you find.  Use this function to avoid oopses caused
by wrongly treating some non-I2C device as an i2c_client.</p>
<dl class="function">
<dt id="c.i2c_new_device">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="descname">i2c_new_device</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adap</em>, struct <a class="reference internal" href="#c.i2c_board_info" title="i2c_board_info">i2c_board_info</a> const *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_new_device" title="Permalink to this definition">¶</a></dt>
<dd><p>instantiate an i2c device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>the adapter managing the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_board_info</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>describes one I2C device; bus_num is ignored</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Create an i2c device. Binding is handled through driver model
<code class="xref c c-func docutils literal"><span class="pre">probe()</span></code>/<code class="xref c c-func docutils literal"><span class="pre">remove()</span></code> methods.  A driver may be bound to this device when we
return from this function, or any later moment (e.g. maybe hotplugging will
load the driver module).  This call is not appropriate for use by mainboard
initialization logic, which usually runs during an <code class="xref c c-func docutils literal"><span class="pre">arch_initcall()</span></code> long
before any i2c_adapter could exist.</p>
<p>This returns the new i2c client, which may be saved for later use with
<a class="reference internal" href="#c.i2c_unregister_device" title="i2c_unregister_device"><code class="xref c c-func docutils literal"><span class="pre">i2c_unregister_device()</span></code></a>; or NULL to indicate an error.</p>
<dl class="function">
<dt id="c.i2c_unregister_device">
void <code class="descname">i2c_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_unregister_device" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse effect of <a class="reference internal" href="#c.i2c_new_device" title="i2c_new_device"><code class="xref c c-func docutils literal"><span class="pre">i2c_new_device()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>value returned from <a class="reference internal" href="#c.i2c_new_device" title="i2c_new_device"><code class="xref c c-func docutils literal"><span class="pre">i2c_new_device()</span></code></a></dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<dl class="function">
<dt id="c.i2c_new_dummy">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="descname">i2c_new_dummy</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u16<em>&nbsp;address</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_new_dummy" title="Permalink to this definition">¶</a></dt>
<dd><p>return a new i2c device bound to a dummy driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>the adapter managing the device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">address</span></code></dt>
<dd>seven bit address to be used</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This returns an I2C client bound to the “dummy” driver, intended for use
with devices that consume multiple addresses.  Examples of such chips
include various EEPROMS (like 24c04 and 24c08 models).</p>
<p>These dummy devices have two main uses.  First, most I2C and SMBus calls
except <a class="reference internal" href="#c.i2c_transfer" title="i2c_transfer"><code class="xref c c-func docutils literal"><span class="pre">i2c_transfer()</span></code></a> need a client handle; the dummy will be that handle.
And second, this prevents the specified address from being bound to a
different driver.</p>
<p>This returns the new i2c client, which should be saved for later use with
<a class="reference internal" href="#c.i2c_unregister_device" title="i2c_unregister_device"><code class="xref c c-func docutils literal"><span class="pre">i2c_unregister_device()</span></code></a>; or NULL to indicate an error.</p>
<dl class="function">
<dt id="c.i2c_new_secondary_device">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="descname">i2c_new_secondary_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, const char *<em>&nbsp;name</em>, u16<em>&nbsp;default_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_new_secondary_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to get the instantiated secondary address and create the associated device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to the primary client</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>Handle to specify which secondary address to get</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">default_addr</span></code></dt>
<dd>Used as a fallback if no secondary address was specified</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>I2C clients can be composed of multiple I2C slaves bound together in a single
component. The I2C client driver then binds to the master I2C slave and needs
to create I2C dummy clients to communicate with all the other slaves.</p>
<p>This function creates and returns an I2C dummy client whose I2C address is
retrieved from the platform firmware based on the given slave name. If no
address is specified by the firmware default_addr is used.</p>
<p>On DT-based platforms the address is retrieved from the “reg” property entry
cell whose “reg-names” value matches the slave name.</p>
<p>This returns the new i2c client, which should be saved for later use with
<a class="reference internal" href="#c.i2c_unregister_device" title="i2c_unregister_device"><code class="xref c c-func docutils literal"><span class="pre">i2c_unregister_device()</span></code></a>; or NULL to indicate an error.</p>
<dl class="function">
<dt id="c.i2c_verify_adapter">
struct i2c_adapter * <code class="descname">i2c_verify_adapter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_verify_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>return parameter as i2c_adapter or NULL</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device, probably from some driver model iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>When traversing the driver model tree, perhaps using driver model
iterators like <strong>device_for_each_child()</strong>, you can’t assume very much
about the nodes you find.  Use this function to avoid oopses caused
by wrongly treating some non-I2C device as an i2c_adapter.</p>
<dl class="function">
<dt id="c.i2c_handle_smbus_host_notify">
int <code class="descname">i2c_handle_smbus_host_notify</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adap</em>, unsigned short<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_handle_smbus_host_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward a Host Notify event to the correct I2C client.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>the adapter</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">addr</span></code></dt>
<dd>the I2C address of the notifying device</dd>
</dl>
<p><strong>Context</strong></p>
<p>can’t sleep</p>
<p><strong>Description</strong></p>
<p>Helper function to be called from an I2C bus driver’s interrupt
handler. It will schedule the Host Notify IRQ.</p>
<dl class="function">
<dt id="c.i2c_add_adapter">
int <code class="descname">i2c_add_adapter</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_add_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>declare i2c adapter, use dynamic bus number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>the adapter to add</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This routine is used to declare an I2C adapter when its bus number
doesn’t matter or when its bus number is specified by an dt alias.
Examples of bases when the bus number doesn’t matter: I2C adapters
dynamically added by USB links or PCI plugin cards.</p>
<p>When this returns zero, a new bus number was allocated and stored
in adap-&gt;nr, and the specified adapter became available for clients.
Otherwise, a negative errno value is returned.</p>
<dl class="function">
<dt id="c.i2c_add_numbered_adapter">
int <code class="descname">i2c_add_numbered_adapter</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_add_numbered_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>declare i2c adapter, use static bus number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>the adapter to register (with adap-&gt;nr initialized)</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This routine is used to declare an I2C adapter when its bus number
matters.  For example, use it for I2C adapters from system-on-chip CPUs,
or otherwise built in to the system’s mainboard, and where i2c_board_info
is used to properly configure I2C devices.</p>
<p>If the requested bus number is set to -1, then this function will behave
identically to i2c_add_adapter, and will dynamically assign a bus number.</p>
<p>If no devices have pre-been declared for this bus, then be sure to
register the adapter before any dynamically allocated ones.  Otherwise
the required bus ID may not be available.</p>
<p>When this returns zero, the specified adapter became available for
clients using the bus number provided in adap-&gt;nr.  Also, the table
of I2C devices pre-declared using <a class="reference internal" href="#c.i2c_register_board_info" title="i2c_register_board_info"><code class="xref c c-func docutils literal"><span class="pre">i2c_register_board_info()</span></code></a> is scanned,
and the appropriate driver model device nodes are created.  Otherwise, a
negative errno value is returned.</p>
<dl class="function">
<dt id="c.i2c_del_adapter">
void <code class="descname">i2c_del_adapter</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_del_adapter" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister I2C adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>the adapter being unregistered</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>This unregisters an I2C adapter which was previously registered
by <strong>i2c_add_adapter</strong> or <strong>i2c_add_numbered_adapter</strong>.</p>
<dl class="function">
<dt id="c.i2c_parse_fw_timings">
void <code class="descname">i2c_parse_fw_timings</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.i2c_timings" title="i2c_timings">i2c_timings</a> *<em>&nbsp;t</em>, bool<em>&nbsp;use_defaults</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_parse_fw_timings" title="Permalink to this definition">¶</a></dt>
<dd><p>get I2C related timing parameters from firmware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device to scan for I2C timing properties</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_timings</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the i2c_timings struct to be filled with values</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">use_defaults</span></code></dt>
<dd>bool to use sane defaults derived from the I2C specification
when properties are not found, otherwise use 0</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scan the device for the generic I2C properties describing timing parameters
for the signal and fill the given struct with the results. If a property was
not found and use_defaults was true, then maximum timings are assumed which
are derived from the I2C specification. If use_defaults is not used, the
results will be 0, so drivers can apply their own defaults later. The latter
is mainly intended for avoiding regressions of existing drivers which want
to switch to this function. New drivers almost always should use the defaults.</p>
<dl class="function">
<dt id="c.i2c_del_driver">
void <code class="descname">i2c_del_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_driver" title="i2c_driver">i2c_driver</a> *<em>&nbsp;driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_del_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister I2C driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_driver</span> <span class="pre">*</span> <span class="pre">driver</span></code></dt>
<dd>the driver being unregistered</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<dl class="function">
<dt id="c.i2c_use_client">
struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> * <code class="descname">i2c_use_client</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_use_client" title="Permalink to this definition">¶</a></dt>
<dd><p>increments the reference count of the i2c client structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>the client being referenced</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each live reference to a client should be refcounted. The driver model does
that automatically as part of driver binding, so that most drivers don’t
need to do this explicitly: they hold a reference until they’re unbound
from the device.</p>
<p>A pointer to the client with the incremented reference counter is returned.</p>
<dl class="function">
<dt id="c.i2c_release_client">
void <code class="descname">i2c_release_client</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_release_client" title="Permalink to this definition">¶</a></dt>
<dd><p>release a use of the i2c client structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>the client being no longer referenced</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called when a user of a client is finished with it.</p>
<dl class="function">
<dt id="c.__i2c_transfer">
int <code class="descname">__i2c_transfer</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adap</em>, struct i2c_msg *<em>&nbsp;msgs</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__i2c_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>unlocked flavor of i2c_transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>Handle to I2C bus</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_msg</span> <span class="pre">*</span> <span class="pre">msgs</span></code></dt>
<dd>One or more messages to execute before STOP is issued to
terminate the operation; each message begins with a START.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>Number of messages to be executed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, else the number of messages executed.</p>
<p>Adapter lock must be held when calling this function. No debug logging
takes place. adap-&gt;algo-&gt;master_xfer existence isn’t checked.</p>
<dl class="function">
<dt id="c.i2c_transfer">
int <code class="descname">i2c_transfer</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adap</em>, struct i2c_msg *<em>&nbsp;msgs</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>execute a single or combined I2C message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adap</span></code></dt>
<dd>Handle to I2C bus</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_msg</span> <span class="pre">*</span> <span class="pre">msgs</span></code></dt>
<dd>One or more messages to execute before STOP is issued to
terminate the operation; each message begins with a START.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>Number of messages to be executed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, else the number of messages executed.</p>
<p>Note that there is no requirement that each message be sent to
the same slave address, although that is the most common model.</p>
<dl class="function">
<dt id="c.i2c_master_send">
int <code class="descname">i2c_master_send</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, const char *<em>&nbsp;buf</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_master_send" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a single I2C message in master transmit mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Data that will be written to the slave</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>How many bytes to write, must be less than 64k since msg.len is u16</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, or else the number of bytes written.</p>
<dl class="function">
<dt id="c.i2c_master_recv">
int <code class="descname">i2c_master_recv</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, char *<em>&nbsp;buf</em>, int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_master_recv" title="Permalink to this definition">¶</a></dt>
<dd><p>issue a single I2C message in master receive mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Where to store data read from slave</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>How many bytes to read, must be less than 64k since msg.len is u16</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns negative errno, or else the number of bytes read.</p>
<dl class="function">
<dt id="c.i2c_smbus_read_byte">
s32 <code class="descname">i2c_smbus_read_byte</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “receive byte” protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “receive byte” protocol, returning negative errno
else the byte received from the device.</p>
<dl class="function">
<dt id="c.i2c_smbus_write_byte">
s32 <code class="descname">i2c_smbus_write_byte</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, u8<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_write_byte" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “send byte” protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">value</span></code></dt>
<dd>Byte to be sent</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “send byte” protocol, returning negative errno
else zero on success.</p>
<dl class="function">
<dt id="c.i2c_smbus_read_byte_data">
s32 <code class="descname">i2c_smbus_read_byte_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, u8<em>&nbsp;command</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_byte_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “read byte” protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">command</span></code></dt>
<dd>Byte interpreted by slave</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “read byte” protocol, returning negative errno
else a data byte received from the device.</p>
<dl class="function">
<dt id="c.i2c_smbus_write_byte_data">
s32 <code class="descname">i2c_smbus_write_byte_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, u8<em>&nbsp;command</em>, u8<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_write_byte_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “write byte” protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">command</span></code></dt>
<dd>Byte interpreted by slave</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">value</span></code></dt>
<dd>Byte being written</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “write byte” protocol, returning negative errno
else zero on success.</p>
<dl class="function">
<dt id="c.i2c_smbus_read_word_data">
s32 <code class="descname">i2c_smbus_read_word_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, u8<em>&nbsp;command</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_word_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “read word” protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">command</span></code></dt>
<dd>Byte interpreted by slave</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “read word” protocol, returning negative errno
else a 16-bit unsigned “word” received from the device.</p>
<dl class="function">
<dt id="c.i2c_smbus_write_word_data">
s32 <code class="descname">i2c_smbus_write_word_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, u8<em>&nbsp;command</em>, u16<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_write_word_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “write word” protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">command</span></code></dt>
<dd>Byte interpreted by slave</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">value</span></code></dt>
<dd>16-bit “word” being written</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “write word” protocol, returning negative errno
else zero on success.</p>
<dl class="function">
<dt id="c.i2c_smbus_read_block_data">
s32 <code class="descname">i2c_smbus_read_block_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, u8<em>&nbsp;command</em>, u8 *<em>&nbsp;values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_block_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “block read” protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">command</span></code></dt>
<dd>Byte interpreted by slave</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">values</span></code></dt>
<dd>Byte array into which data will be read; big enough to hold
the data returned by the slave.  SMBus allows at most 32 bytes.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “block read” protocol, returning negative errno
else the number of data bytes in the slave’s response.</p>
<p>Note that using this function requires that the client’s adapter support
the I2C_FUNC_SMBUS_READ_BLOCK_DATA functionality.  Not all adapter drivers
support this; its emulation through I2C messaging relies on a specific
mechanism (I2C_M_RECV_LEN) which may not be implemented.</p>
<dl class="function">
<dt id="c.i2c_smbus_write_block_data">
s32 <code class="descname">i2c_smbus_write_block_data</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, u8<em>&nbsp;command</em>, u8<em>&nbsp;length</em>, const u8 *<em>&nbsp;values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_write_block_data" title="Permalink to this definition">¶</a></dt>
<dd><p>SMBus “block write” protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">command</span></code></dt>
<dd>Byte interpreted by slave</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">length</span></code></dt>
<dd>Size of data block; SMBus allows at most 32 bytes</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">values</span></code></dt>
<dd>Byte array which will be written.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “block write” protocol, returning negative errno
else zero on success.</p>
<dl class="function">
<dt id="c.i2c_smbus_xfer">
s32 <code class="descname">i2c_smbus_xfer</code><span class="sig-paren">(</span>struct i2c_adapter *<em>&nbsp;adapter</em>, u16<em>&nbsp;addr</em>, unsigned short<em>&nbsp;flags</em>, char<em>&nbsp;read_write</em>, u8<em>&nbsp;command</em>, int<em>&nbsp;protocol</em>, union i2c_smbus_data *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_xfer" title="Permalink to this definition">¶</a></dt>
<dd><p>execute SMBus protocol operations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">i2c_adapter</span> <span class="pre">*</span> <span class="pre">adapter</span></code></dt>
<dd>Handle to I2C bus</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">addr</span></code></dt>
<dd>Address of SMBus slave on that bus</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">flags</span></code></dt>
<dd>I2C_CLIENT_* flags (usually zero or I2C_CLIENT_PEC)</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">read_write</span></code></dt>
<dd>I2C_SMBUS_READ or I2C_SMBUS_WRITE</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">command</span></code></dt>
<dd>Byte interpreted by slave, for protocols which use such bytes</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">protocol</span></code></dt>
<dd>SMBus protocol operation to execute, such as I2C_SMBUS_PROC_CALL</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">i2c_smbus_data</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to be read or written</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes an SMBus protocol operation, and returns a negative
errno code else zero on success.</p>
<dl class="function">
<dt id="c.i2c_smbus_read_i2c_block_data_or_emulated">
s32 <code class="descname">i2c_smbus_read_i2c_block_data_or_emulated</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.i2c_client" title="i2c_client">i2c_client</a> *<em>&nbsp;client</em>, u8<em>&nbsp;command</em>, u8<em>&nbsp;length</em>, u8 *<em>&nbsp;values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.i2c_smbus_read_i2c_block_data_or_emulated" title="Permalink to this definition">¶</a></dt>
<dd><p>read block or emulate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">i2c_client</span> <span class="pre">*</span> <span class="pre">client</span></code></dt>
<dd>Handle to slave device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">command</span></code></dt>
<dd>Byte interpreted by slave</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">length</span></code></dt>
<dd>Size of data block; SMBus allows at most I2C_SMBUS_BLOCK_MAX bytes</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">values</span></code></dt>
<dd>Byte array into which data will be read; big enough to hold
the data returned by the slave.  SMBus allows at most
I2C_SMBUS_BLOCK_MAX bytes.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This executes the SMBus “block read” protocol if supported by the adapter.
If block read is not supported, it emulates it using either word or byte
read protocols depending on availability.</p>
<p>The addresses of the I2C slave device that are accessed with this function
must be mapped to a linear region, so that a block read will have the same
effect as a byte read. Before using this function you must double-check
if the I2C slave does support exchanging a block transfer with a byte
transfer.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="hsi.html" class="btn btn-neutral float-right" title="High Speed Synchronous Serial Interface (HSI)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="spi.html" class="btn btn-neutral" title="Serial Peripheral Interface (SPI)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>