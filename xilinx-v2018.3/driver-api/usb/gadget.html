

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>USB Gadget API for Linux &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="USB Anchors" href="anchors.html" />
    <link rel="prev" title="The Linux-USB Host Side API" href="usb.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux USB API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="usb.html">The Linux-USB Host Side API</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">USB Gadget API for Linux</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structure-of-gadget-drivers">Structure of Gadget Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-mode-gadget-api">Kernel Mode Gadget API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#peripheral-controller-drivers">Peripheral Controller Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gadget-drivers">Gadget Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usb-on-the-go-otg">USB On-The-GO (OTG)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="anchors.html">USB Anchors</a></li>
<li class="toctree-l3"><a class="reference internal" href="bulk-streams.html">USB bulk streams</a></li>
<li class="toctree-l3"><a class="reference internal" href="callbacks.html">USB core callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma.html">USB DMA</a></li>
<li class="toctree-l3"><a class="reference internal" href="URB.html">USB Request Block (URB)</a></li>
<li class="toctree-l3"><a class="reference internal" href="power-management.html">Power Management for USB</a></li>
<li class="toctree-l3"><a class="reference internal" href="hotplug.html">USB hotplugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="persist.html">USB device persistence during system suspend</a></li>
<li class="toctree-l3"><a class="reference internal" href="error-codes.html">USB Error codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing_usb_driver.html">Writing USB Device Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="dwc3.html">Synopsys DesignWare Core SuperSpeed USB 3.0 Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="writing_musb_glue_layer.html">Writing a MUSB Glue Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="typec.html">USB Type-C connector class</a></li>
<li class="toctree-l3"><a class="reference internal" href="usb3-debug-port.html">USB3 debug port</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Linux USB API</a> &raquo;</li>
        
      <li>USB Gadget API for Linux</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/usb/gadget.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="usb-gadget-api-for-linux">
<h1>USB Gadget API for Linux<a class="headerlink" href="#usb-gadget-api-for-linux" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">David Brownell</td>
</tr>
<tr class="field-even field"><th class="field-name">Date:</th><td class="field-body">20 August 2004</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document presents a Linux-USB “Gadget” kernel mode API, for use
within peripherals and other USB devices that embed Linux. It provides
an overview of the API structure, and shows how that fits into a system
development project. This is the first such API released on Linux to
address a number of important problems, including:</p>
<ul class="simple">
<li>Supports USB 2.0, for high speed devices which can stream data at
several dozen megabytes per second.</li>
<li>Handles devices with dozens of endpoints just as well as ones with
just two fixed-function ones. Gadget drivers can be written so
they’re easy to port to new hardware.</li>
<li>Flexible enough to expose more complex USB device capabilities such
as multiple configurations, multiple interfaces, composite devices,
and alternate interface settings.</li>
<li>USB “On-The-Go” (OTG) support, in conjunction with updates to the
Linux-USB host side.</li>
<li>Sharing data structures and API models with the Linux-USB host side
API. This helps the OTG support, and looks forward to more-symmetric
frameworks (where the same I/O model is used by both host and device
side drivers).</li>
<li>Minimalist, so it’s easier to support new device controller hardware.
I/O processing doesn’t imply large demands for memory or CPU
resources.</li>
</ul>
<p>Most Linux developers will not be able to use this API, since they have
USB <code class="docutils literal"><span class="pre">host</span></code> hardware in a PC, workstation, or server. Linux users with
embedded systems are more likely to have USB peripheral hardware. To
distinguish drivers running inside such hardware from the more familiar
Linux “USB device drivers”, which are host side proxies for the real USB
devices, a different term is used: the drivers inside the peripherals
are “USB gadget drivers”. In USB protocol interactions, the device
driver is the master (or “client driver”) and the gadget driver is the
slave (or “function driver”).</p>
<p>The gadget API resembles the host side Linux-USB API in that both use
queues of request objects to package I/O buffers, and those requests may
be submitted or canceled. They share common definitions for the standard
USB <em>Chapter 9</em> messages, structures, and constants. Also, both APIs
bind and unbind drivers to devices. The APIs differ in detail, since the
host side’s current URB framework exposes a number of implementation
details and assumptions that are inappropriate for a gadget API. While
the model for control transfers and configuration management is
necessarily different (one side is a hardware-neutral master, the other
is a hardware-aware slave), the endpoint I/0 API used here should also
be usable for an overhead-reduced host side API.</p>
</div>
<div class="section" id="structure-of-gadget-drivers">
<h2>Structure of Gadget Drivers<a class="headerlink" href="#structure-of-gadget-drivers" title="Permalink to this headline">¶</a></h2>
<p>A system running inside a USB peripheral normally has at least three
layers inside the kernel to handle USB protocol processing, and may have
additional layers in user space code. The <code class="docutils literal"><span class="pre">gadget</span></code> API is used by the
middle layer to interact with the lowest level (which directly handles
hardware).</p>
<p>In Linux, from the bottom up, these layers are:</p>
<dl class="docutils">
<dt><em>USB Controller Driver</em></dt>
<dd><p class="first">This is the lowest software level. It is the only layer that talks
to hardware, through registers, fifos, dma, irqs, and the like. The
<code class="docutils literal"><span class="pre">&lt;linux/usb/gadget.h&gt;</span></code> API abstracts the peripheral controller
endpoint hardware. That hardware is exposed through endpoint
objects, which accept streams of IN/OUT buffers, and through
callbacks that interact with gadget drivers. Since normal USB
devices only have one upstream port, they only have one of these
drivers. The controller driver can support any number of different
gadget drivers, but only one of them can be used at a time.</p>
<p class="last">Examples of such controller hardware include the PCI-based NetChip
2280 USB 2.0 high speed controller, the SA-11x0 or PXA-25x UDC
(found within many PDAs), and a variety of other products.</p>
</dd>
<dt><em>Gadget Driver</em></dt>
<dd><p class="first">The lower boundary of this driver implements hardware-neutral USB
functions, using calls to the controller driver. Because such
hardware varies widely in capabilities and restrictions, and is used
in embedded environments where space is at a premium, the gadget
driver is often configured at compile time to work with endpoints
supported by one particular controller. Gadget drivers may be
portable to several different controllers, using conditional
compilation. (Recent kernels substantially simplify the work
involved in supporting new hardware, by <em>autoconfiguring</em> endpoints
automatically for many bulk-oriented drivers.) Gadget driver
responsibilities include:</p>
<ul class="simple">
<li>handling setup requests (ep0 protocol responses) possibly
including class-specific functionality</li>
<li>returning configuration and string descriptors</li>
<li>(re)setting configurations and interface altsettings, including
enabling and configuring endpoints</li>
<li>handling life cycle events, such as managing bindings to
hardware, USB suspend/resume, remote wakeup, and disconnection
from the USB host.</li>
<li>managing IN and OUT transfers on all currently enabled endpoints</li>
</ul>
<p class="last">Such drivers may be modules of proprietary code, although that
approach is discouraged in the Linux community.</p>
</dd>
<dt><em>Upper Level</em></dt>
<dd><p class="first">Most gadget drivers have an upper boundary that connects to some
Linux driver or framework in Linux. Through that boundary flows the
data which the gadget driver produces and/or consumes through
protocol transfers over USB. Examples include:</p>
<ul class="last simple">
<li>user mode code, using generic (gadgetfs) or application specific
files in <code class="docutils literal"><span class="pre">/dev</span></code></li>
<li>networking subsystem (for network gadgets, like the CDC Ethernet
Model gadget driver)</li>
<li>data capture drivers, perhaps video4Linux or a scanner driver; or
test and measurement hardware.</li>
<li>input subsystem (for HID gadgets)</li>
<li>sound subsystem (for audio gadgets)</li>
<li>file system (for PTP gadgets)</li>
<li>block i/o subsystem (for usb-storage gadgets)</li>
<li>… and more</li>
</ul>
</dd>
<dt><em>Additional Layers</em></dt>
<dd>Other layers may exist. These could include kernel layers, such as
network protocol stacks, as well as user mode applications building
on standard POSIX system call APIs such as <code class="docutils literal"><span class="pre">open()</span></code>, <code class="docutils literal"><span class="pre">close()</span></code>,
<code class="docutils literal"><span class="pre">read()</span></code> and <code class="docutils literal"><span class="pre">write()</span></code>. On newer systems, POSIX Async I/O calls may
be an option. Such user mode code will not necessarily be subject to
the GNU General Public License (GPL).</dd>
</dl>
<p>OTG-capable systems will also need to include a standard Linux-USB host
side stack, with <code class="docutils literal"><span class="pre">usbcore</span></code>, one or more <em>Host Controller Drivers</em>
(HCDs), <em>USB Device Drivers</em> to support the OTG “Targeted Peripheral
List”, and so forth. There will also be an <em>OTG Controller Driver</em>,
which is visible to gadget and device driver developers only indirectly.
That helps the host and device side USB controllers implement the two
new OTG protocols (HNP and SRP). Roles switch (host to peripheral, or
vice versa) using HNP during USB suspend processing, and SRP can be
viewed as a more battery-friendly kind of device wakeup protocol.</p>
<p>Over time, reusable utilities are evolving to help make some gadget
driver tasks simpler. For example, building configuration descriptors
from vectors of descriptors for the configurations interfaces and
endpoints is now automated, and many drivers now use autoconfiguration
to choose hardware endpoints and initialize their descriptors. A
potential example of particular interest is code implementing standard
USB-IF protocols for HID, networking, storage, or audio classes. Some
developers are interested in KDB or KGDB hooks, to let target hardware
be remotely debugged. Most such USB protocol code doesn’t need to be
hardware-specific, any more than network protocols like X11, HTTP, or
NFS are. Such gadget-side interface drivers should eventually be
combined, to implement composite devices.</p>
</div>
<div class="section" id="kernel-mode-gadget-api">
<h2>Kernel Mode Gadget API<a class="headerlink" href="#kernel-mode-gadget-api" title="Permalink to this headline">¶</a></h2>
<p>Gadget drivers declare themselves through a struct
<a class="reference internal" href="#c.usb_gadget_driver" title="usb_gadget_driver"><code class="xref c c-type docutils literal"><span class="pre">usb_gadget_driver</span></code></a>, which is responsible for most parts of enumeration
for a struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget"><code class="xref c c-type docutils literal"><span class="pre">usb_gadget</span></code></a>. The response to a set_configuration usually
involves enabling one or more of the struct <a class="reference internal" href="#c.usb_ep" title="usb_ep"><code class="xref c c-type docutils literal"><span class="pre">usb_ep</span></code></a> objects exposed by
the gadget, and submitting one or more struct <a class="reference internal" href="#c.usb_request" title="usb_request"><code class="xref c c-type docutils literal"><span class="pre">usb_request</span></code></a> buffers to
transfer data. Understand those four data types, and their operations,
and you will understand how this API works.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Other than the “Chapter 9” data types, most of the significant data
types and functions are described here.</p>
<p>However, some relevant information is likely omitted from what you
are reading. One example of such information is endpoint
autoconfiguration. You’ll have to read the header file, and use
example source code (such as that for “Gadget Zero”), to fully
understand the API.</p>
<p class="last">The part of the API implementing some basic driver capabilities is
specific to the version of the Linux kernel that’s in use. The 2.6
and upper kernel versions include a <em>driver model</em> framework that has
no analogue on earlier kernels; so those parts of the gadget API are
not fully portable. (They are implemented on 2.4 kernels, but in a
different way.) The driver model state is another part of this API that is
ignored by the kerneldoc tools.</p>
</div>
<p>The core API does not expose every possible hardware feature, only the
most widely available ones. There are significant hardware features,
such as device-to-device DMA (without temporary storage in a memory
buffer) that would be added using hardware-specific APIs.</p>
<p>This API allows drivers to use conditional compilation to handle
endpoint capabilities of different hardware, but doesn’t require that.
Hardware tends to have arbitrary restrictions, relating to transfer
types, addressing, packet sizes, buffering, and availability. As a rule,
such differences only matter for “endpoint zero” logic that handles
device configuration and management. The API supports limited run-time
detection of capabilities, through naming conventions for endpoints.
Many drivers will be able to at least partially autoconfigure
themselves. In particular, driver init sections will often have endpoint
autoconfiguration logic that scans the hardware’s list of endpoints to
find ones matching the driver requirements (relying on those
conventions), to eliminate some of the most common reasons for
conditional compilation.</p>
<p>Like the Linux-USB host side API, this API exposes the “chunky” nature
of USB messages: I/O requests are in terms of one or more “packets”, and
packet boundaries are visible to drivers. Compared to RS-232 serial
protocols, USB resembles synchronous protocols like HDLC (N bytes per
frame, multipoint addressing, host as the primary station and devices as
secondary stations) more than asynchronous ones (tty style: 8 data bits
per frame, no parity, one stop bit). So for example the controller
drivers won’t buffer two single byte writes into a single two-byte USB
IN packet, although gadget drivers may do so when they implement
protocols where packet boundaries (and “short packets”) are not
significant.</p>
<div class="section" id="driver-life-cycle">
<h3>Driver Life Cycle<a class="headerlink" href="#driver-life-cycle" title="Permalink to this headline">¶</a></h3>
<p>Gadget drivers make endpoint I/O requests to hardware without needing to
know many details of the hardware, but driver setup/configuration code
needs to handle some differences. Use the API like this:</p>
<ol class="arabic simple">
<li>Register a driver for the particular device side usb controller
hardware, such as the net2280 on PCI (USB 2.0), sa11x0 or pxa25x as
found in Linux PDAs, and so on. At this point the device is logically
in the USB ch9 initial state (<code class="docutils literal"><span class="pre">attached</span></code>), drawing no power and not
usable (since it does not yet support enumeration). Any host should
not see the device, since it’s not activated the data line pullup
used by the host to detect a device, even if VBUS power is available.</li>
<li>Register a gadget driver that implements some higher level device
function. That will then bind() to a <a class="reference internal" href="#c.usb_gadget" title="usb_gadget"><code class="xref c c-type docutils literal"><span class="pre">usb_gadget</span></code></a>, which activates
the data line pullup sometime after detecting VBUS.</li>
<li>The hardware driver can now start enumerating. The steps it handles
are to accept USB <code class="docutils literal"><span class="pre">power</span></code> and <code class="docutils literal"><span class="pre">set_address</span></code> requests. Other steps are
handled by the gadget driver. If the gadget driver module is unloaded
before the host starts to enumerate, steps before step 7 are skipped.</li>
<li>The gadget driver’s <code class="docutils literal"><span class="pre">setup()</span></code> call returns usb descriptors, based both
on what the bus interface hardware provides and on the functionality
being implemented. That can involve alternate settings or
configurations, unless the hardware prevents such operation. For OTG
devices, each configuration descriptor includes an OTG descriptor.</li>
<li>The gadget driver handles the last step of enumeration, when the USB
host issues a <code class="docutils literal"><span class="pre">set_configuration</span></code> call. It enables all endpoints used
in that configuration, with all interfaces in their default settings.
That involves using a list of the hardware’s endpoints, enabling each
endpoint according to its descriptor. It may also involve using
<code class="docutils literal"><span class="pre">usb_gadget_vbus_draw</span></code> to let more power be drawn from VBUS, as
allowed by that configuration. For OTG devices, setting a
configuration may also involve reporting HNP capabilities through a
user interface.</li>
<li>Do real work and perform data transfers, possibly involving changes
to interface settings or switching to new configurations, until the
device is disconnect()ed from the host. Queue any number of transfer
requests to each endpoint. It may be suspended and resumed several
times before being disconnected. On disconnect, the drivers go back
to step 3 (above).</li>
<li>When the gadget driver module is being unloaded, the driver unbind()
callback is issued. That lets the controller driver be unloaded.</li>
</ol>
<p>Drivers will normally be arranged so that just loading the gadget driver
module (or statically linking it into a Linux kernel) allows the
peripheral device to be enumerated, but some drivers will defer
enumeration until some higher level component (like a user mode daemon)
enables it. Note that at this lowest level there are no policies about
how ep0 configuration logic is implemented, except that it should obey
USB specifications. Such issues are in the domain of gadget drivers,
including knowing about implementation constraints imposed by some USB
controllers or understanding that composite devices might happen to be
built by integrating reusable components.</p>
<p>Note that the lifecycle above can be slightly different for OTG devices.
Other than providing an additional OTG descriptor in each configuration,
only the HNP-related differences are particularly visible to driver
code. They involve reporting requirements during the <code class="docutils literal"><span class="pre">SET_CONFIGURATION</span></code>
request, and the option to invoke HNP during some suspend callbacks.
Also, SRP changes the semantics of <code class="docutils literal"><span class="pre">usb_gadget_wakeup</span></code> slightly.</p>
</div>
<div class="section" id="usb-2-0-chapter-9-types-and-constants">
<h3>USB 2.0 Chapter 9 Types and Constants<a class="headerlink" href="#usb-2-0-chapter-9-types-and-constants" title="Permalink to this headline">¶</a></h3>
<p>Gadget drivers rely on common USB structures and constants defined in
the <a class="reference internal" href="usb.html#usb-chapter9"><span class="std std-ref">linux/usb/ch9.h</span></a> header file, which is standard in
Linux 2.6+ kernels. These are the same types and constants used by host side
drivers (and usbcore).</p>
</div>
<div class="section" id="core-objects-and-methods">
<h3>Core Objects and Methods<a class="headerlink" href="#core-objects-and-methods" title="Permalink to this headline">¶</a></h3>
<p>These are declared in <code class="docutils literal"><span class="pre">&lt;linux/usb/gadget.h&gt;</span></code>, and are used by gadget
drivers to interact with USB peripheral controller drivers.</p>
<dl class="type">
<dt id="c.usb_request">
struct <code class="descname">usb_request</code><a class="headerlink" href="#c.usb_request" title="Permalink to this definition">¶</a></dt>
<dd><p>describes one i/o request</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_request {
  void * buf;
  unsigned length;
  dma_addr_t dma;
  struct scatterlist * sg;
  unsigned num_sgs;
  unsigned num_mapped_sgs;
  unsigned stream_id:16;
  unsigned no_interrupt:1;
  unsigned zero:1;
  unsigned short_not_ok:1;
  unsigned dma_mapped:1;
  void (* complete) (struct usb_ep *ep, struct usb_request *req);
  void * context;
  struct list_head list;
  int status;
  unsigned actual;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>Buffer used for data.  Always provide this; some controllers
only use PIO, or don’t use DMA for some endpoints.</dd>
<dt><code class="docutils literal"><span class="pre">length</span></code></dt>
<dd>Length of that data</dd>
<dt><code class="docutils literal"><span class="pre">dma</span></code></dt>
<dd>DMA address corresponding to ‘buf’.  If you don’t set this
field, and the usb controller needs one, it is responsible
for mapping and unmapping the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">sg</span></code></dt>
<dd>a scatterlist for SG-capable controllers.</dd>
<dt><code class="docutils literal"><span class="pre">num_sgs</span></code></dt>
<dd>number of SG entries</dd>
<dt><code class="docutils literal"><span class="pre">num_mapped_sgs</span></code></dt>
<dd>number of SG entries mapped to DMA (internal)</dd>
<dt><code class="docutils literal"><span class="pre">stream_id</span></code></dt>
<dd>The stream id, when USB3.0 bulk streams are being used</dd>
<dt><code class="docutils literal"><span class="pre">no_interrupt</span></code></dt>
<dd>If true, hints that no completion irq is needed.
Helpful sometimes with deep request queues that are handled
directly by DMA controllers.</dd>
<dt><code class="docutils literal"><span class="pre">zero</span></code></dt>
<dd>If true, when writing data, makes the last packet be “short”
by adding a zero length packet as needed;</dd>
<dt><code class="docutils literal"><span class="pre">short_not_ok</span></code></dt>
<dd>When reading data, makes short packets be
treated as errors (queue stops advancing till cleanup).</dd>
<dt><code class="docutils literal"><span class="pre">dma_mapped</span></code></dt>
<dd>Indicates if request has been mapped to DMA (internal)</dd>
<dt><code class="docutils literal"><span class="pre">complete</span></code></dt>
<dd>Function called when request completes, so this request and
its buffer may be re-used.  The function will always be called with
interrupts disabled, and it must not sleep.
Reads terminate with a short packet, or when the buffer fills,
whichever comes first.  When writes terminate, some data bytes
will usually still be in flight (often in a hardware fifo).
Errors (for reads or writes) stop the queue from advancing
until the completion function returns, so that any transfers
invalidated by the error may first be dequeued.</dd>
<dt><code class="docutils literal"><span class="pre">context</span></code></dt>
<dd>For use by the completion callback</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>For use by the gadget driver.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>Reports completion code, zero or a negative errno.
Normally, faults block the transfer queue from advancing until
the completion callback returns.
Code “-ESHUTDOWN” indicates completion caused by device disconnect,
or when the driver disabled the endpoint.</dd>
<dt><code class="docutils literal"><span class="pre">actual</span></code></dt>
<dd>Reports bytes transferred to/from the buffer.  For reads (OUT
transfers) this may be less than the requested length.  If the
short_not_ok flag is set, short reads are treated as errors
even when status otherwise indicates successful completion.
Note that for writes (IN transfers) some data bytes may still
reside in a device-side FIFO when the request is reported as
complete.</dd>
</dl>
<p><strong>Description</strong></p>
<p>These are allocated/freed through the endpoint they’re used with.  The
hardware’s driver can add extra per-request data to the memory it returns,
which often avoids separate memory allocations (potential failures),
later when the request is queued.</p>
<p>Request flags affect request handling, such as whether a zero length
packet is written (the “zero” flag), whether a short read should be
treated as an error (blocking request queue advance, the “short_not_ok”
flag), or hinting that an interrupt is not required (the “no_interrupt”
flag, for use with deep request queues).</p>
<p>Bulk endpoints can use any size buffers, and can also be used for interrupt
transfers. interrupt-only endpoints can be much less functional.</p>
<p><strong>NOTE</strong></p>
<p>this is analogous to ‘struct urb’ on the host side, except that
it’s thinner and promotes more pre-allocation.</p>
<dl class="type">
<dt id="c.usb_ep_caps">
struct <code class="descname">usb_ep_caps</code><a class="headerlink" href="#c.usb_ep_caps" title="Permalink to this definition">¶</a></dt>
<dd><p>endpoint capabilities description</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_ep_caps {
  unsigned type_control:1;
  unsigned type_iso:1;
  unsigned type_bulk:1;
  unsigned type_int:1;
  unsigned dir_in:1;
  unsigned dir_out:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type_control</span></code></dt>
<dd>Endpoint supports control type (reserved for ep0).</dd>
<dt><code class="docutils literal"><span class="pre">type_iso</span></code></dt>
<dd>Endpoint supports isochronous transfers.</dd>
<dt><code class="docutils literal"><span class="pre">type_bulk</span></code></dt>
<dd>Endpoint supports bulk transfers.</dd>
<dt><code class="docutils literal"><span class="pre">type_int</span></code></dt>
<dd>Endpoint supports interrupt transfers.</dd>
<dt><code class="docutils literal"><span class="pre">dir_in</span></code></dt>
<dd>Endpoint supports IN direction.</dd>
<dt><code class="docutils literal"><span class="pre">dir_out</span></code></dt>
<dd>Endpoint supports OUT direction.</dd>
</dl>
<dl class="type">
<dt id="c.usb_ep">
struct <code class="descname">usb_ep</code><a class="headerlink" href="#c.usb_ep" title="Permalink to this definition">¶</a></dt>
<dd><p>device side representation of USB endpoint</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_ep {
  void * driver_data;
  const char * name;
  const struct usb_ep_ops * ops;
  struct list_head ep_list;
  struct usb_ep_caps caps;
  unsigned maxpacket:16;
  unsigned maxpacket_limit:16;
  unsigned max_streams:16;
  unsigned mult:2;
  unsigned maxburst:5;
  u8 address;
  const struct usb_endpoint_descriptor * desc;
  const struct usb_ss_ep_comp_descriptor * comp_desc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">driver_data</span></code></dt>
<dd>for use by the gadget driver.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>identifier for the endpoint, such as “ep-a” or “ep9in-bulk”</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>Function pointers used to access hardware-specific operations.</dd>
<dt><code class="docutils literal"><span class="pre">ep_list</span></code></dt>
<dd>the gadget’s ep_list holds all of its endpoints</dd>
<dt><code class="docutils literal"><span class="pre">caps</span></code></dt>
<dd>The structure describing types and directions supported by endoint.</dd>
<dt><code class="docutils literal"><span class="pre">maxpacket</span></code></dt>
<dd>The maximum packet size used on this endpoint.  The initial
value can sometimes be reduced (hardware allowing), according to
the endpoint descriptor used to configure the endpoint.</dd>
<dt><code class="docutils literal"><span class="pre">maxpacket_limit</span></code></dt>
<dd>The maximum packet size value which can be handled by this
endpoint. It’s set once by UDC driver when endpoint is initialized, and
should not be changed. Should not be confused with maxpacket.</dd>
<dt><code class="docutils literal"><span class="pre">max_streams</span></code></dt>
<dd>The maximum number of streams supported
by this EP (0 - 16, actual number is 2^n)</dd>
<dt><code class="docutils literal"><span class="pre">mult</span></code></dt>
<dd>multiplier, ‘mult’ value for SS Isoc EPs</dd>
<dt><code class="docutils literal"><span class="pre">maxburst</span></code></dt>
<dd>the maximum number of bursts supported by this EP (for usb3)</dd>
<dt><code class="docutils literal"><span class="pre">address</span></code></dt>
<dd>used to identify the endpoint when finding descriptor that
matches connection speed</dd>
<dt><code class="docutils literal"><span class="pre">desc</span></code></dt>
<dd>endpoint descriptor.  This pointer is set before the endpoint is
enabled and remains valid until the endpoint is disabled.</dd>
<dt><code class="docutils literal"><span class="pre">comp_desc</span></code></dt>
<dd>In case of SuperSpeed support, this is the endpoint companion
descriptor that is used to configure the endpoint</dd>
</dl>
<p><strong>Description</strong></p>
<p>the bus controller driver lists all the general purpose endpoints in
gadget-&gt;ep_list.  the control endpoint (gadget-&gt;ep0) is not in that list,
and is accessed only in response to a driver <code class="xref c c-func docutils literal"><span class="pre">setup()</span></code> callback.</p>
<dl class="type">
<dt id="c.usb_gadget">
struct <code class="descname">usb_gadget</code><a class="headerlink" href="#c.usb_gadget" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a usb slave device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_gadget {
  struct work_struct work;
  struct usb_udc * udc;
  const struct usb_gadget_ops * ops;
  struct usb_ep * ep0;
  struct list_head ep_list;
  enum usb_device_speed speed;
  enum usb_device_speed max_speed;
  enum usb_device_state state;
  const char * name;
  struct device dev;
  unsigned out_epnum;
  unsigned in_epnum;
  unsigned mA;
  struct usb_otg_caps * otg_caps;
  unsigned sg_supported:1;
  unsigned is_otg:1;
  unsigned is_a_peripheral:1;
  unsigned b_hnp_enable:1;
  unsigned a_hnp_support:1;
  unsigned a_alt_hnp_support:1;
  unsigned hnp_polling_support:1;
  unsigned host_request_flag:1;
  unsigned quirk_ep_out_aligned_size:1;
  unsigned quirk_avoids_skb_reserve:1;
  unsigned is_selfpowered:1;
  unsigned deactivated:1;
  unsigned connected:1;
  unsigned lpm_capable:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">work</span></code></dt>
<dd>(internal use) Workqueue to be used for <code class="xref c c-func docutils literal"><span class="pre">sysfs_notify()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">udc</span></code></dt>
<dd>struct usb_udc pointer for this gadget</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>Function pointers used to access hardware-specific operations.</dd>
<dt><code class="docutils literal"><span class="pre">ep0</span></code></dt>
<dd>Endpoint zero, used when reading or writing responses to
driver <code class="xref c c-func docutils literal"><span class="pre">setup()</span></code> requests</dd>
<dt><code class="docutils literal"><span class="pre">ep_list</span></code></dt>
<dd>List of other endpoints supported by the device.</dd>
<dt><code class="docutils literal"><span class="pre">speed</span></code></dt>
<dd>Speed of current connection to USB host.</dd>
<dt><code class="docutils literal"><span class="pre">max_speed</span></code></dt>
<dd>Maximal speed the UDC can handle.  UDC must support this
and all slower speeds.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>the state we are now (attached, suspended, configured, etc)</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Identifies the controller hardware type.  Used in diagnostics
and sometimes configuration.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Driver model state for this abstract device.</dd>
<dt><code class="docutils literal"><span class="pre">out_epnum</span></code></dt>
<dd>last used out ep number</dd>
<dt><code class="docutils literal"><span class="pre">in_epnum</span></code></dt>
<dd>last used in ep number</dd>
<dt><code class="docutils literal"><span class="pre">mA</span></code></dt>
<dd>last set mA value</dd>
<dt><code class="docutils literal"><span class="pre">otg_caps</span></code></dt>
<dd>OTG capabilities of this gadget.</dd>
<dt><code class="docutils literal"><span class="pre">sg_supported</span></code></dt>
<dd>true if we can handle scatter-gather</dd>
<dt><code class="docutils literal"><span class="pre">is_otg</span></code></dt>
<dd>True if the USB device port uses a Mini-AB jack, so that the
gadget driver must provide a USB OTG descriptor.</dd>
<dt><code class="docutils literal"><span class="pre">is_a_peripheral</span></code></dt>
<dd>False unless is_otg, the “A” end of a USB cable
is in the Mini-AB jack, and HNP has been used to switch roles
so that the “A” device currently acts as A-Peripheral, not A-Host.</dd>
<dt><code class="docutils literal"><span class="pre">b_hnp_enable</span></code></dt>
<dd>OTG device feature flag, indicating that the A-Host
enabled HNP support.</dd>
<dt><code class="docutils literal"><span class="pre">a_hnp_support</span></code></dt>
<dd>OTG device feature flag, indicating that the A-Host
supports HNP at this port.</dd>
<dt><code class="docutils literal"><span class="pre">a_alt_hnp_support</span></code></dt>
<dd>OTG device feature flag, indicating that the A-Host
only supports HNP on a different root port.</dd>
<dt><code class="docutils literal"><span class="pre">hnp_polling_support</span></code></dt>
<dd>OTG device feature flag, indicating if the OTG device
in peripheral mode can support HNP polling.</dd>
<dt><code class="docutils literal"><span class="pre">host_request_flag</span></code></dt>
<dd>OTG device feature flag, indicating if A-Peripheral
or B-Peripheral wants to take host role.</dd>
<dt><code class="docutils literal"><span class="pre">quirk_ep_out_aligned_size</span></code></dt>
<dd>epout requires buffer size to be aligned to
MaxPacketSize.</dd>
<dt><code class="docutils literal"><span class="pre">quirk_avoids_skb_reserve</span></code></dt>
<dd>udc/platform wants to avoid <a class="reference internal" href="../../networking/kapi.html#c.skb_reserve" title="skb_reserve"><code class="xref c c-func docutils literal"><span class="pre">skb_reserve()</span></code></a> in
u_ether.c to improve performance.</dd>
<dt><code class="docutils literal"><span class="pre">is_selfpowered</span></code></dt>
<dd>if the gadget is self-powered.</dd>
<dt><code class="docutils literal"><span class="pre">deactivated</span></code></dt>
<dd>True if gadget is deactivated - in deactivated state it cannot
be connected.</dd>
<dt><code class="docutils literal"><span class="pre">connected</span></code></dt>
<dd>True if gadget is connected.</dd>
<dt><code class="docutils literal"><span class="pre">lpm_capable</span></code></dt>
<dd>If the gadget max_speed is FULL or HIGH, this flag
indicates that it supports LPM as per the LPM ECN &amp; errata.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gadgets have a mostly-portable “gadget driver” implementing device
functions, handling all usb configurations and interfaces.  Gadget
drivers talk to hardware-specific code indirectly, through ops vectors.
That insulates the gadget driver from hardware details, and packages
the hardware endpoints through generic i/o queues.  The “usb_gadget”
and “usb_ep” interfaces provide that insulation from the hardware.</p>
<p>Except for the driver data, all fields in this structure are
read-only to the gadget driver.  That driver data is part of the
“driver model” infrastructure in 2.6 (and later) kernels, and for
earlier systems is grouped in a similar structure that’s not known
to the rest of the kernel.</p>
<p>Values of the three OTG device feature flags are updated before the
<code class="xref c c-func docutils literal"><span class="pre">setup()</span></code> call corresponding to USB_REQ_SET_CONFIGURATION, and before
driver <code class="xref c c-func docutils literal"><span class="pre">suspend()</span></code> calls.  They are valid only when is_otg, and when the
device is acting as a B-Peripheral (so is_a_peripheral is false).</p>
<dl class="function">
<dt id="c.usb_ep_align">
size_t <code class="descname">usb_ep_align</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_ep" title="usb_ep">usb_ep</a> *<em>&nbsp;ep</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_ep_align" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <strong>len</strong> aligned to ep’s maxpacketsize.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_ep</span> <span class="pre">*</span> <span class="pre">ep</span></code></dt>
<dd>the endpoint whose maxpacketsize is used to align <strong>len</strong></dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>buffer size’s length to align to <strong>ep</strong>’s maxpacketsize</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper is used to align buffer’s size to an ep’s maxpacketsize.</p>
<dl class="function">
<dt id="c.usb_ep_align_maybe">
size_t <code class="descname">usb_ep_align_maybe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em>, struct <a class="reference internal" href="#c.usb_ep" title="usb_ep">usb_ep</a> *<em>&nbsp;ep</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_ep_align_maybe" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <strong>len</strong> aligned to ep’s maxpacketsize if gadget requires quirk_ep_out_aligned_size, otherwise returns len.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller to check for quirk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_ep</span> <span class="pre">*</span> <span class="pre">ep</span></code></dt>
<dd>the endpoint whose maxpacketsize is used to align <strong>len</strong></dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>buffer size’s length to align to <strong>ep</strong>’s maxpacketsize</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper is used in case it’s required for any reason to check and maybe
align buffer’s size to an ep’s maxpacketsize.</p>
<dl class="function">
<dt id="c.gadget_is_altset_supported">
int <code class="descname">gadget_is_altset_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_altset_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware supports altsettings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller to check for quirk</dd>
</dl>
<dl class="function">
<dt id="c.gadget_is_stall_supported">
int <code class="descname">gadget_is_stall_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_stall_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware supports stalling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller to check for quirk</dd>
</dl>
<dl class="function">
<dt id="c.gadget_is_zlp_supported">
int <code class="descname">gadget_is_zlp_supported</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_zlp_supported" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware supports zlp</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller to check for quirk</dd>
</dl>
<dl class="function">
<dt id="c.gadget_avoids_skb_reserve">
int <code class="descname">gadget_avoids_skb_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_avoids_skb_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware would like to avoid skb_reserve to improve performance.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller to check for quirk</dd>
</dl>
<dl class="function">
<dt id="c.gadget_is_dualspeed">
int <code class="descname">gadget_is_dualspeed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_dualspeed" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware handles high speed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller that might support both high and full speeds</dd>
</dl>
<dl class="function">
<dt id="c.gadget_is_superspeed">
int <code class="descname">gadget_is_superspeed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_superspeed" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the hardware handles superspeed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller that might support superspeed</dd>
</dl>
<dl class="function">
<dt id="c.gadget_is_superspeed_plus">
int <code class="descname">gadget_is_superspeed_plus</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_superspeed_plus" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the hardware handles superspeed plus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller that might support superspeed plus</dd>
</dl>
<dl class="function">
<dt id="c.gadget_is_otg">
int <code class="descname">gadget_is_otg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gadget_is_otg" title="Permalink to this definition">¶</a></dt>
<dd><p>return true iff the hardware is OTG-ready</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>controller that might have a Mini-AB connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a runtime test, since kernels with a USB-OTG stack sometimes
run on boards which only have a Mini-B (or Mini-A) connector.</p>
<dl class="type">
<dt id="c.usb_gadget_driver">
struct <code class="descname">usb_gadget_driver</code><a class="headerlink" href="#c.usb_gadget_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>driver for usb ‘slave’ devices</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_gadget_driver {
  char * function;
  enum usb_device_speed max_speed;
  int (* bind) (struct usb_gadget *gadget, struct usb_gadget_driver *driver);
  void (* unbind) (struct usb_gadget *);
  int (* setup) (struct usb_gadget *, const struct usb_ctrlrequest *);
  void (* disconnect) (struct usb_gadget *);
  void (* suspend) (struct usb_gadget *);
  void (* resume) (struct usb_gadget *);
  void (* reset) (struct usb_gadget *);
  struct device_driver driver;
  char * udc_name;
  struct list_head pending;
  unsigned match_existing_only:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">function</span></code></dt>
<dd>String describing the gadget’s function</dd>
<dt><code class="docutils literal"><span class="pre">max_speed</span></code></dt>
<dd>Highest speed the driver handles.</dd>
<dt><code class="docutils literal"><span class="pre">bind</span></code></dt>
<dd>the driver’s bind callback</dd>
<dt><code class="docutils literal"><span class="pre">unbind</span></code></dt>
<dd>Invoked when the driver is unbound from a gadget,
usually from rmmod (after a disconnect is reported).
Called in a context that permits sleeping.</dd>
<dt><code class="docutils literal"><span class="pre">setup</span></code></dt>
<dd>Invoked for ep0 control requests that aren’t handled by
the hardware level driver. Most calls must be handled by
the gadget driver, including descriptor and configuration
management.  The 16 bit members of the setup data are in
USB byte order. Called in_interrupt; this may not sleep.  Driver
queues a response to ep0, or returns negative to stall.</dd>
<dt><code class="docutils literal"><span class="pre">disconnect</span></code></dt>
<dd>Invoked after all transfers have been stopped,
when the host is disconnected.  May be called in_interrupt; this
may not sleep.  Some devices can’t detect disconnect, so this might
not be called except as part of controller shutdown.</dd>
<dt><code class="docutils literal"><span class="pre">suspend</span></code></dt>
<dd>Invoked on USB suspend.  May be called in_interrupt.</dd>
<dt><code class="docutils literal"><span class="pre">resume</span></code></dt>
<dd>Invoked on USB resume.  May be called in_interrupt.</dd>
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd>Invoked on USB bus reset. It is mandatory for all gadget drivers
and should be called in_interrupt.</dd>
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>Driver model state for this driver.</dd>
<dt><code class="docutils literal"><span class="pre">udc_name</span></code></dt>
<dd>A name of UDC this driver should be bound to. If udc_name is NULL,
this driver will be bound to any available UDC.</dd>
<dt><code class="docutils literal"><span class="pre">pending</span></code></dt>
<dd>UDC core private data used for deferred probe of this driver.</dd>
<dt><code class="docutils literal"><span class="pre">match_existing_only</span></code></dt>
<dd>If udc is not found, return an error and don’t add this
gadget driver to list of pending driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Devices are disabled till a gadget driver successfully <code class="xref c c-func docutils literal"><span class="pre">bind()`s,</span> <span class="pre">which</span>
<span class="pre">means</span> <span class="pre">the</span> <span class="pre">driver</span> <span class="pre">will</span> <span class="pre">handle</span> <span class="pre">:c:func:`setup()</span></code> requests needed to enumerate (and
meet “chapter 9” requirements) then do some useful work.</p>
<p>If gadget-&gt;is_otg is true, the gadget driver must provide an OTG
descriptor during enumeration, or else fail the <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code> call.  In such
cases, no USB traffic may flow until both <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code> returns without
having called <code class="xref c c-func docutils literal"><span class="pre">usb_gadget_disconnect()</span></code>, and the USB host stack has
initialized.</p>
<p>Drivers use hardware-specific knowledge to configure the usb hardware.
endpoint addressing is only one of several hardware characteristics that
are in descriptors the ep0 implementation returns from <code class="xref c c-func docutils literal"><span class="pre">setup()</span></code> calls.</p>
<p>Except for ep0 implementation, most driver code shouldn’t need change to
run on top of different usb controllers.  It’ll use endpoints set up by
that ep0 implementation.</p>
<p>The usb controller driver handles a few standard usb requests.  Those
include set_address, and feature flags for devices, interfaces, and
endpoints (the get_status, set_feature, and clear_feature requests).</p>
<p>Accordingly, the driver’s <code class="xref c c-func docutils literal"><span class="pre">setup()</span></code> callback must always implement all
get_descriptor requests, returning at least a device descriptor and
a configuration descriptor.  Drivers must make sure the endpoint
descriptors match any hardware constraints. Some hardware also constrains
other descriptors. (The pxa250 allows only configurations 1, 2, or 3).</p>
<p>The driver’s <code class="xref c c-func docutils literal"><span class="pre">setup()</span></code> callback must also implement set_configuration,
and should also implement set_interface, get_configuration, and
get_interface.  Setting a configuration (or interface) is where
endpoints should be activated or (config 0) shut down.</p>
<p>(Note that only the default control endpoint is supported.  Neither
hosts nor devices generally support control traffic except to ep0.)</p>
<p>Most devices will ignore USB suspend/resume operations, and so will
not provide those callbacks.  However, some may need to change modes
when the host is not longer directing those activities.  For example,
local controls (buttons, dials, etc) may need to be re-enabled since
the (remote) host can’t do that any longer; or an error state might
be cleared, to make the device behave identically whether or not
power is maintained.</p>
<dl class="function">
<dt id="c.usb_gadget_probe_driver">
int <code class="descname">usb_gadget_probe_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget_driver" title="usb_gadget_driver">usb_gadget_driver</a> *<em>&nbsp;driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gadget_probe_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>probe a gadget driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget_driver</span> <span class="pre">*</span> <span class="pre">driver</span></code></dt>
<dd>the driver being registered</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Call this in your gadget driver’s module initialization function,
to tell the underlying usb controller driver about your driver.
The <strong>bind()</strong> function will be called to bind it to a gadget before this
registration call returns.  It’s expected that the <strong>bind()</strong> function will
be in init sections.</p>
<dl class="function">
<dt id="c.usb_gadget_unregister_driver">
int <code class="descname">usb_gadget_unregister_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget_driver" title="usb_gadget_driver">usb_gadget_driver</a> *<em>&nbsp;driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gadget_unregister_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a gadget driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget_driver</span> <span class="pre">*</span> <span class="pre">driver</span></code></dt>
<dd>the driver being unregistered</dd>
</dl>
<p><strong>Context</strong></p>
<p>can sleep</p>
<p><strong>Description</strong></p>
<p>Call this in your gadget driver’s module cleanup function,
to tell the underlying usb controller that your driver is
going away.  If the controller is connected to a USB host,
it will first <code class="xref c c-func docutils literal"><span class="pre">disconnect()</span></code>.  The driver is also requested
to <code class="xref c c-func docutils literal"><span class="pre">unbind()</span></code> and clean up any device state, before this procedure
finally returns.  It’s expected that the <code class="xref c c-func docutils literal"><span class="pre">unbind()</span></code> functions
will in in exit sections, so may not be linked in some kernels.</p>
<dl class="type">
<dt id="c.usb_string">
struct <code class="descname">usb_string</code><a class="headerlink" href="#c.usb_string" title="Permalink to this definition">¶</a></dt>
<dd><p>wraps a C string and its USB id</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_string {
  u8 id;
  const char * s;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>the (nonzero) ID for this string</dd>
<dt><code class="docutils literal"><span class="pre">s</span></code></dt>
<dd>the string, in UTF-8 encoding</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you’re using <a class="reference internal" href="#c.usb_gadget_get_string" title="usb_gadget_get_string"><code class="xref c c-func docutils literal"><span class="pre">usb_gadget_get_string()</span></code></a>, use this to wrap a string
together with its ID.</p>
<dl class="type">
<dt id="c.usb_gadget_strings">
struct <code class="descname">usb_gadget_strings</code><a class="headerlink" href="#c.usb_gadget_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>a set of USB strings in a given language</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_gadget_strings {
  u16 language;
  struct usb_string * strings;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">language</span></code></dt>
<dd>identifies the strings’ language (0x0409 for en-us)</dd>
<dt><code class="docutils literal"><span class="pre">strings</span></code></dt>
<dd>array of strings with their ids</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you’re using <a class="reference internal" href="#c.usb_gadget_get_string" title="usb_gadget_get_string"><code class="xref c c-func docutils literal"><span class="pre">usb_gadget_get_string()</span></code></a>, use this to wrap all the
strings for a given language.</p>
<dl class="function">
<dt id="c.usb_free_descriptors">
void <code class="descname">usb_free_descriptors</code><span class="sig-paren">(</span>struct usb_descriptor_header **<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_free_descriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>free descriptors returned by <a class="reference internal" href="#c.usb_copy_descriptors" title="usb_copy_descriptors"><code class="xref c c-func docutils literal"><span class="pre">usb_copy_descriptors()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_descriptor_header</span> <span class="pre">**</span> <span class="pre">v</span></code></dt>
<dd>vector of descriptors</dd>
</dl>
</div>
<div class="section" id="optional-utilities">
<h3>Optional Utilities<a class="headerlink" href="#optional-utilities" title="Permalink to this headline">¶</a></h3>
<p>The core API is sufficient for writing a USB Gadget Driver, but some
optional utilities are provided to simplify common tasks. These
utilities include endpoint autoconfiguration.</p>
<dl class="function">
<dt id="c.usb_gadget_get_string">
int <code class="descname">usb_gadget_get_string</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget_strings" title="usb_gadget_strings">usb_gadget_strings</a> *<em>&nbsp;table</em>, int<em>&nbsp;id</em>, u8 *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gadget_get_string" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out a string descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget_strings</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>of c strings encoded using UTF-8</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>string id, from low byte of wValue in get string descriptor</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>at least 256 bytes, must be 16-bit aligned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds the UTF-8 string matching the ID, and converts it into a
string descriptor in utf16-le.
Returns length of descriptor (always even) or negative errno</p>
<p>If your driver needs stings in multiple languages, you’ll probably
“switch (wIndex) { … }”  in your ep0 string descriptor logic,
using this routine after choosing which set of UTF-8 strings to use.
Note that US-ASCII is a strict subset of UTF-8; any string bytes with
the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
characters (which are also widely used in C strings).</p>
<dl class="function">
<dt id="c.usb_descriptor_fillbuf">
int <code class="descname">usb_descriptor_fillbuf</code><span class="sig-paren">(</span>void *<em>&nbsp;buf</em>, unsigned<em>&nbsp;buflen</em>, const struct usb_descriptor_header **<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_descriptor_fillbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>fill buffer with descriptors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Buffer to be filled</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">buflen</span></code></dt>
<dd>Size of buf</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_descriptor_header</span> <span class="pre">**</span> <span class="pre">src</span></code></dt>
<dd>Array of descriptor pointers, terminated by null pointer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies descriptors into the buffer, returning the length or a
negative error code if they can’t all be copied.  Useful when
assembling descriptors for an associated set of interfaces used
as part of configuring a composite device; or in other cases where
sets of descriptors need to be marshaled.</p>
<dl class="function">
<dt id="c.usb_gadget_config_buf">
int <code class="descname">usb_gadget_config_buf</code><span class="sig-paren">(</span>const struct usb_config_descriptor *<em>&nbsp;config</em>, void *<em>&nbsp;buf</em>, unsigned<em>&nbsp;length</em>, const struct usb_descriptor_header **<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gadget_config_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>builts a complete configuration descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_config_descriptor</span> <span class="pre">*</span> <span class="pre">config</span></code></dt>
<dd>Header for the descriptor, including characteristics such
as power requirements and number of interfaces.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>Buffer for the resulting configuration descriptor.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">length</span></code></dt>
<dd>Length of buffer.  If this is not big enough to hold the
entire configuration descriptor, an error code will be returned.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">usb_descriptor_header</span> <span class="pre">**</span> <span class="pre">desc</span></code></dt>
<dd>Null-terminated vector of pointers to the descriptors (interface,
endpoint, etc) defining all functions in this device configuration.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This copies descriptors into the response buffer, building a descriptor
for that configuration.  It returns the buffer length or a negative
status code.  The config.wTotalLength field is set to match the length
of the result, but other descriptor fields (including power usage and
interface count) must be set by the caller.</p>
<p>Gadget drivers could use this when constructing a config descriptor
in response to USB_REQ_GET_DESCRIPTOR.  They will need to patch the
resulting bDescriptorType value if USB_DT_OTHER_SPEED_CONFIG is needed.</p>
<dl class="function">
<dt id="c.usb_copy_descriptors">
struct usb_descriptor_header ** <code class="descname">usb_copy_descriptors</code><span class="sig-paren">(</span>struct usb_descriptor_header **<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_copy_descriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>copy a vector of USB descriptors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_descriptor_header</span> <span class="pre">**</span> <span class="pre">src</span></code></dt>
<dd>null-terminated vector to copy</dd>
</dl>
<p><strong>Context</strong></p>
<p>initialization code, which may sleep</p>
<p><strong>Description</strong></p>
<p>This makes a copy of a vector of USB descriptors.  Its primary use
is to support usb_function objects which can have multiple copies,
each needing different descriptors.  Functions may have static
tables of descriptors, which are used as templates and customized
with identifiers (for interfaces, strings, endpoints, and more)
as needed by a given function instance.</p>
</div>
<div class="section" id="composite-device-framework">
<h3>Composite Device Framework<a class="headerlink" href="#composite-device-framework" title="Permalink to this headline">¶</a></h3>
<p>The core API is sufficient for writing drivers for composite USB devices
(with more than one function in a given configuration), and also
multi-configuration devices (also more than one function, but not
necessarily sharing a given configuration). There is however an optional
framework which makes it easier to reuse and combine functions.</p>
<p>Devices using this framework provide a struct <a class="reference internal" href="#c.usb_composite_driver" title="usb_composite_driver"><code class="xref c c-type docutils literal"><span class="pre">usb_composite_driver</span></code></a>,
which in turn provides one or more struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration"><code class="xref c c-type docutils literal"><span class="pre">usb_configuration</span></code></a>
instances. Each such configuration includes at least one struct
<a class="reference internal" href="#c.usb_function" title="usb_function"><code class="xref c c-type docutils literal"><span class="pre">usb_function</span></code></a>, which packages a user visible role such as “network
link” or “mass storage device”. Management functions may also exist,
such as “Device Firmware Upgrade”.</p>
<dl class="type">
<dt id="c.usb_os_desc_ext_prop">
struct <code class="descname">usb_os_desc_ext_prop</code><a class="headerlink" href="#c.usb_os_desc_ext_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>describes one “Extended Property”</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_os_desc_ext_prop {
  struct list_head entry;
  u8 type;
  int name_len;
  char * name;
  int data_len;
  char * data;
  struct config_item item;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">entry</span></code></dt>
<dd>used to keep a list of extended properties</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Extended Property type</dd>
<dt><code class="docutils literal"><span class="pre">name_len</span></code></dt>
<dd>Extended Property unicode name length, including terminating ‘0’</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Extended Property name</dd>
<dt><code class="docutils literal"><span class="pre">data_len</span></code></dt>
<dd>Length of Extended Property blob (for unicode store double len)</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>Extended Property blob</dd>
<dt><code class="docutils literal"><span class="pre">item</span></code></dt>
<dd>Represents this Extended Property in configfs</dd>
</dl>
<dl class="type">
<dt id="c.usb_os_desc">
struct <code class="descname">usb_os_desc</code><a class="headerlink" href="#c.usb_os_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>describes OS descriptors associated with one interface</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_os_desc {
  char * ext_compat_id;
  struct list_head ext_prop;
  int ext_prop_len;
  int ext_prop_count;
  struct mutex * opts_mutex;
  struct config_group group;
  struct module * owner;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ext_compat_id</span></code></dt>
<dd>16 bytes of “Compatible ID” and “Subcompatible ID”</dd>
<dt><code class="docutils literal"><span class="pre">ext_prop</span></code></dt>
<dd>Extended Properties list</dd>
<dt><code class="docutils literal"><span class="pre">ext_prop_len</span></code></dt>
<dd>Total length of Extended Properties blobs</dd>
<dt><code class="docutils literal"><span class="pre">ext_prop_count</span></code></dt>
<dd>Number of Extended Properties</dd>
<dt><code class="docutils literal"><span class="pre">opts_mutex</span></code></dt>
<dd>Optional mutex protecting config data of a usb_function_instance</dd>
<dt><code class="docutils literal"><span class="pre">group</span></code></dt>
<dd>Represents OS descriptors associated with an interface in configfs</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>Module associated with this OS descriptor</dd>
</dl>
<dl class="type">
<dt id="c.usb_os_desc_table">
struct <code class="descname">usb_os_desc_table</code><a class="headerlink" href="#c.usb_os_desc_table" title="Permalink to this definition">¶</a></dt>
<dd><p>describes OS descriptors associated with one interface of a usb_function</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_os_desc_table {
  int if_id;
  struct usb_os_desc * os_desc;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">if_id</span></code></dt>
<dd>Interface id</dd>
<dt><code class="docutils literal"><span class="pre">os_desc</span></code></dt>
<dd>“Extended Compatibility ID” and “Extended Properties” of the
interface</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each interface can have at most one “Extended Compatibility ID” and a
number of “Extended Properties”.</p>
<dl class="type">
<dt id="c.usb_function">
struct <code class="descname">usb_function</code><a class="headerlink" href="#c.usb_function" title="Permalink to this definition">¶</a></dt>
<dd><p>describes one function of a configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_function {
  const char * name;
  struct usb_gadget_strings ** strings;
  struct usb_descriptor_header ** fs_descriptors;
  struct usb_descriptor_header ** hs_descriptors;
  struct usb_descriptor_header ** ss_descriptors;
  struct usb_descriptor_header ** ssp_descriptors;
  struct usb_configuration * config;
  struct usb_os_desc_table * os_desc_table;
  unsigned os_desc_n;
  int (* bind) (struct usb_configuration *, struct usb_function *);
  void (* unbind) (struct usb_configuration *, struct usb_function *);
  void (* free_func) (struct usb_function *f);
  struct module * mod;
  int (* set_alt) (struct usb_function *, unsigned interface, unsigned alt);
  int (* get_alt) (struct usb_function *, unsigned interface);
  void (* disable) (struct usb_function *);
  int (* setup) (struct usb_function *, const struct usb_ctrlrequest *);
  bool (* req_match) (struct usb_function *,const struct usb_ctrlrequest *, bool config0);
  void (* suspend) (struct usb_function *);
  void (* resume) (struct usb_function *);
  int (* get_status) (struct usb_function *);
  int (* func_suspend) (struct usb_function *, u8 suspend_opt);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>For diagnostics, identifies the function.</dd>
<dt><code class="docutils literal"><span class="pre">strings</span></code></dt>
<dd>tables of strings, keyed by identifiers assigned during <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code>
and by language IDs provided in control requests</dd>
<dt><code class="docutils literal"><span class="pre">fs_descriptors</span></code></dt>
<dd>Table of full (or low) speed descriptors, using interface and
string identifiers assigned during <strong>bind()</strong>.  If this pointer is null,
the function will not be available at full speed (or at low speed).</dd>
<dt><code class="docutils literal"><span class="pre">hs_descriptors</span></code></dt>
<dd>Table of high speed descriptors, using interface and
string identifiers assigned during <strong>bind()</strong>.  If this pointer is null,
the function will not be available at high speed.</dd>
<dt><code class="docutils literal"><span class="pre">ss_descriptors</span></code></dt>
<dd>Table of super speed descriptors, using interface and
string identifiers assigned during <strong>bind()</strong>. If this
pointer is null after initiation, the function will not
be available at super speed.</dd>
<dt><code class="docutils literal"><span class="pre">ssp_descriptors</span></code></dt>
<dd>Table of super speed plus descriptors, using
interface and string identifiers assigned during <strong>bind()</strong>. If
this pointer is null after initiation, the function will not
be available at super speed plus.</dd>
<dt><code class="docutils literal"><span class="pre">config</span></code></dt>
<dd>assigned when <strong>usb_add_function()</strong> is called; this is the
configuration with which this function is associated.</dd>
<dt><code class="docutils literal"><span class="pre">os_desc_table</span></code></dt>
<dd>Table of (interface id, os descriptors) pairs. The function
can expose more than one interface. If an interface is a member of
an IAD, only the first interface of IAD has its entry in the table.</dd>
<dt><code class="docutils literal"><span class="pre">os_desc_n</span></code></dt>
<dd>Number of entries in os_desc_table</dd>
<dt><code class="docutils literal"><span class="pre">bind</span></code></dt>
<dd>Before the gadget can register, all of its functions <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code> to the
available resources including string and interface identifiers used
in interface or class descriptors; endpoints; I/O buffers; and so on.</dd>
<dt><code class="docutils literal"><span class="pre">unbind</span></code></dt>
<dd>Reverses <strong>bind</strong>; called as a side effect of unregistering the
driver which added this function.</dd>
<dt><code class="docutils literal"><span class="pre">free_func</span></code></dt>
<dd>free the struct usb_function.</dd>
<dt><code class="docutils literal"><span class="pre">mod</span></code></dt>
<dd>(internal) points to the module that created this structure.</dd>
<dt><code class="docutils literal"><span class="pre">set_alt</span></code></dt>
<dd>(REQUIRED) Reconfigures altsettings; function drivers may
initialize usb_ep.driver data at this time (when it is used).
Note that setting an interface to its current altsetting resets
interface state, and that all interfaces have a disabled state.</dd>
<dt><code class="docutils literal"><span class="pre">get_alt</span></code></dt>
<dd>Returns the active altsetting.  If this is not provided,
then only altsetting zero is supported.</dd>
<dt><code class="docutils literal"><span class="pre">disable</span></code></dt>
<dd>(REQUIRED) Indicates the function should be disabled.  Reasons
include host resetting or reconfiguring the gadget, and disconnection.</dd>
<dt><code class="docutils literal"><span class="pre">setup</span></code></dt>
<dd>Used for interface-specific control requests.</dd>
<dt><code class="docutils literal"><span class="pre">req_match</span></code></dt>
<dd>Tests if a given class request can be handled by this function.</dd>
<dt><code class="docutils literal"><span class="pre">suspend</span></code></dt>
<dd>Notifies functions when the host stops sending USB traffic.</dd>
<dt><code class="docutils literal"><span class="pre">resume</span></code></dt>
<dd>Notifies functions when the host restarts USB traffic.</dd>
<dt><code class="docutils literal"><span class="pre">get_status</span></code></dt>
<dd>Returns function status as a reply to
<code class="xref c c-func docutils literal"><span class="pre">GetStatus()</span></code> request when the recipient is Interface.</dd>
<dt><code class="docutils literal"><span class="pre">func_suspend</span></code></dt>
<dd>callback to be called when
SetFeature(FUNCTION_SUSPEND) is reseived</dd>
</dl>
<p><strong>Description</strong></p>
<p>A single USB function uses one or more interfaces, and should in most
cases support operation at both full and high speeds.  Each function is
associated by <strong>usb_add_function()</strong> with a one configuration; that function
causes <strong>bind()</strong> to be called so resources can be allocated as part of
setting up a gadget driver.  Those resources include endpoints, which
should be allocated using <strong>usb_ep_autoconfig()</strong>.</p>
<p>To support dual speed operation, a function driver provides descriptors
for both high and full speed operation.  Except in rare cases that don’t
involve bulk endpoints, each speed needs different endpoint descriptors.</p>
<p>Function drivers choose their own strategies for managing instance data.
The simplest strategy just declares it “static’, which means the function
can only be activated once.  If the function needs to be exposed in more
than one configuration at a given speed, it needs to support multiple
usb_function structures (one for each configuration).</p>
<p>A more complex strategy might encapsulate a <strong>usb_function</strong> structure inside
a driver-specific instance structure to allows multiple activations.  An
example of multiple activations might be a CDC ACM function that supports
two or more distinct instances within the same configuration, providing
several independent logical data links to a USB host.</p>
<dl class="type">
<dt id="c.usb_configuration">
struct <code class="descname">usb_configuration</code><a class="headerlink" href="#c.usb_configuration" title="Permalink to this definition">¶</a></dt>
<dd><p>represents one gadget configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_configuration {
  const char * label;
  struct usb_gadget_strings ** strings;
  const struct usb_descriptor_header ** descriptors;
  void (* unbind) (struct usb_configuration *);
  int (* setup) (struct usb_configuration *, const struct usb_ctrlrequest *);
  u8 bConfigurationValue;
  u8 iConfiguration;
  u8 bmAttributes;
  u16 MaxPower;
  struct usb_composite_dev * cdev;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">label</span></code></dt>
<dd>For diagnostics, describes the configuration.</dd>
<dt><code class="docutils literal"><span class="pre">strings</span></code></dt>
<dd>Tables of strings, keyed by identifiers assigned during <strong>bind()</strong>
and by language IDs provided in control requests.</dd>
<dt><code class="docutils literal"><span class="pre">descriptors</span></code></dt>
<dd>Table of descriptors preceding all function descriptors.
Examples include OTG and vendor-specific descriptors.</dd>
<dt><code class="docutils literal"><span class="pre">unbind</span></code></dt>
<dd>Reverses <strong>bind</strong>; called as a side effect of unregistering the
driver which added this configuration.</dd>
<dt><code class="docutils literal"><span class="pre">setup</span></code></dt>
<dd>Used to delegate control requests that aren’t handled by standard
device infrastructure or directed at a specific interface.</dd>
<dt><code class="docutils literal"><span class="pre">bConfigurationValue</span></code></dt>
<dd>Copied into configuration descriptor.</dd>
<dt><code class="docutils literal"><span class="pre">iConfiguration</span></code></dt>
<dd>Copied into configuration descriptor.</dd>
<dt><code class="docutils literal"><span class="pre">bmAttributes</span></code></dt>
<dd>Copied into configuration descriptor.</dd>
<dt><code class="docutils literal"><span class="pre">MaxPower</span></code></dt>
<dd>Power consumtion in mA. Used to compute bMaxPower in the
configuration descriptor after considering the bus speed.</dd>
<dt><code class="docutils literal"><span class="pre">cdev</span></code></dt>
<dd>assigned by <strong>usb_add_config()</strong> before calling <strong>bind()</strong>; this is
the device associated with this configuration.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Configurations are building blocks for gadget drivers structured around
function drivers.  Simple USB gadgets require only one function and one
configuration, and handle dual-speed hardware by always providing the same
functionality.  Slightly more complex gadgets may have more than one
single-function configuration at a given speed; or have configurations
that only work at one speed.</p>
<p>Composite devices are, by definition, ones with configurations which
include more than one function.</p>
<p>The lifecycle of a usb_configuration includes allocation, initialization
of the fields described above, and calling <strong>usb_add_config()</strong> to set up
internal data and bind it to a specific device.  The configuration’s
<strong>bind()</strong> method is then used to initialize all the functions and then
call <strong>usb_add_function()</strong> for them.</p>
<p>Those functions would normally be independent of each other, but that’s
not mandatory.  CDC WMC devices are an example where functions often
depend on other functions, with some functions subsidiary to others.
Such interdependency may be managed in any way, so long as all of the
descriptors complete by the time the composite driver returns from
its <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code> routine.</p>
<dl class="type">
<dt id="c.usb_composite_driver">
struct <code class="descname">usb_composite_driver</code><a class="headerlink" href="#c.usb_composite_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>groups configurations into a gadget</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_composite_driver {
  const char * name;
  const struct usb_device_descriptor * dev;
  struct usb_gadget_strings ** strings;
  enum usb_device_speed max_speed;
  unsigned needs_serial:1;
  int (* bind) (struct usb_composite_dev *cdev);
  int (* unbind) (struct usb_composite_dev *);
  void (* disconnect) (struct usb_composite_dev *);
  void (* suspend) (struct usb_composite_dev *);
  void (* resume) (struct usb_composite_dev *);
  struct usb_gadget_driver gadget_driver;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>For diagnostics, identifies the driver.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Template descriptor for the device, including default device
identifiers.</dd>
<dt><code class="docutils literal"><span class="pre">strings</span></code></dt>
<dd>tables of strings, keyed by identifiers assigned during <strong>bind</strong>
and language IDs provided in control requests. Note: The first entries
are predefined. The first entry that may be used is
USB_GADGET_FIRST_AVAIL_IDX</dd>
<dt><code class="docutils literal"><span class="pre">max_speed</span></code></dt>
<dd>Highest speed the driver supports.</dd>
<dt><code class="docutils literal"><span class="pre">needs_serial</span></code></dt>
<dd>set to 1 if the gadget needs userspace to provide
a serial number.  If one is not provided, warning will be printed.</dd>
<dt><code class="docutils literal"><span class="pre">bind</span></code></dt>
<dd>(REQUIRED) Used to allocate resources that are shared across the
whole device, such as string IDs, and add its configurations using
<strong>usb_add_config()</strong>. This may fail by returning a negative errno
value; it should return zero on successful initialization.</dd>
<dt><code class="docutils literal"><span class="pre">unbind</span></code></dt>
<dd>Reverses <strong>bind</strong>; called as a side effect of unregistering
this driver.</dd>
<dt><code class="docutils literal"><span class="pre">disconnect</span></code></dt>
<dd>optional driver disconnect method</dd>
<dt><code class="docutils literal"><span class="pre">suspend</span></code></dt>
<dd>Notifies when the host stops sending USB traffic,
after function notifications</dd>
<dt><code class="docutils literal"><span class="pre">resume</span></code></dt>
<dd>Notifies configuration when the host restarts USB traffic,
before function notifications</dd>
<dt><code class="docutils literal"><span class="pre">gadget_driver</span></code></dt>
<dd>Gadget driver controlling this driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Devices default to reporting self powered operation.  Devices which rely
on bus powered operation should report this in their <strong>bind</strong> method.</p>
<p>Before returning from <strong>bind</strong>, various fields in the template descriptor
may be overridden.  These include the idVendor/idProduct/bcdDevice values
normally to bind the appropriate host side driver, and the three strings
(iManufacturer, iProduct, iSerialNumber) normally used to provide user
meaningful device identifiers.  (The strings will not be defined unless
they are defined in <strong>dev</strong> and <strong>strings</strong>.)  The correct ep0 maxpacket size
is also reported, as defined by the underlying controller driver.</p>
<dl class="function">
<dt id="c.module_usb_composite_driver">
<code class="descname">module_usb_composite_driver</code><span class="sig-paren">(</span><em>__usb_composite_driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_usb_composite_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a USB gadget composite driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__usb_composite_driver</span></code></dt>
<dd>usb_composite_driver struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for USB gadget composite drivers which do not do anything
special in module init/exit. This eliminates a lot of boilerplate. Each
module may only use this macro once, and calling it replaces <a class="reference internal" href="../basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal"><span class="pre">module_init()</span></code></a>
and <a class="reference internal" href="../basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code></a></p>
<dl class="type">
<dt id="c.usb_composite_dev">
struct <code class="descname">usb_composite_dev</code><a class="headerlink" href="#c.usb_composite_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>represents one composite usb gadget</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct usb_composite_dev {
  struct usb_gadget * gadget;
  struct usb_request * req;
  struct usb_request * os_desc_req;
  struct usb_configuration * config;
  u8 qw_sign;
  u8 b_vendor_code;
  struct usb_configuration * os_desc_config;
  unsigned int use_os_string:1;
  unsigned int setup_pending:1;
  unsigned int os_desc_pending:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gadget</span></code></dt>
<dd>read-only, abstracts the gadget’s usb peripheral controller</dd>
<dt><code class="docutils literal"><span class="pre">req</span></code></dt>
<dd>used for control responses; buffer is pre-allocated</dd>
<dt><code class="docutils literal"><span class="pre">os_desc_req</span></code></dt>
<dd>used for OS descriptors responses; buffer is pre-allocated</dd>
<dt><code class="docutils literal"><span class="pre">config</span></code></dt>
<dd>the currently active configuration</dd>
<dt><code class="docutils literal"><span class="pre">qw_sign</span></code></dt>
<dd>qwSignature part of the OS string</dd>
<dt><code class="docutils literal"><span class="pre">b_vendor_code</span></code></dt>
<dd>bMS_VendorCode part of the OS string</dd>
<dt><code class="docutils literal"><span class="pre">os_desc_config</span></code></dt>
<dd>the configuration to be used with OS descriptors</dd>
<dt><code class="docutils literal"><span class="pre">use_os_string</span></code></dt>
<dd>false by default, interested gadgets set it</dd>
<dt><code class="docutils literal"><span class="pre">setup_pending</span></code></dt>
<dd>true when setup request is queued but not completed</dd>
<dt><code class="docutils literal"><span class="pre">os_desc_pending</span></code></dt>
<dd>true when os_desc request is queued but not completed</dd>
</dl>
<p><strong>Description</strong></p>
<p>One of these devices is allocated and initialized before the
associated device driver’s <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code> is called.</p>
<p>OPEN ISSUE:  it appears that some WUSB devices will need to be
built by combining a normal (wired) gadget with a wireless one.
This revision of the gadget framework should probably try to make
sure doing that won’t hurt too much.</p>
<p>One notion for how to handle Wireless USB devices involves:</p>
<ol class="loweralpha simple">
<li>a second gadget here, discovery mechanism TBD, but likely
needing separate “register/unregister WUSB gadget” calls;</li>
<li>updates to usb_gadget to include flags “is it wireless”,
“is it wired”, plus (presumably in a wrapper structure)
bandgroup and PHY info;</li>
<li>presumably a wireless_ep wrapping a usb_ep, and reporting
wireless-specific parameters like maxburst and maxsequence;</li>
<li>configurations that are specific to wireless links;</li>
<li>function drivers that understand wireless configs and will
support wireless for (additional) function instances;</li>
<li>a function to support association setup (like CBAF), not
necessarily requiring a wireless adapter;</li>
<li>composite device setup that can create one or more wireless
configs, including appropriate association setup support;</li>
<li>more, TBD.</li>
</ol>
<dl class="function">
<dt id="c.config_ep_by_speed">
int <code class="descname">config_ep_by_speed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_gadget" title="usb_gadget">usb_gadget</a> *<em>&nbsp;g</em>, struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a> *<em>&nbsp;f</em>, struct <a class="reference internal" href="#c.usb_ep" title="usb_ep">usb_ep</a> *<em>&nbsp;_ep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.config_ep_by_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>configures the given endpoint according to gadget speed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget</span> <span class="pre">*</span> <span class="pre">g</span></code></dt>
<dd>pointer to the gadget</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*</span> <span class="pre">f</span></code></dt>
<dd>usb function</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_ep</span> <span class="pre">*</span> <span class="pre">_ep</span></code></dt>
<dd>the endpoint to configure</dd>
</dl>
<p><strong>Return</strong></p>
<p>error code, 0 on success</p>
<p>This function chooses the right descriptors for a given
endpoint according to gadget speed and saves it in the
endpoint desc field. If the endpoint already has a descriptor
assigned to it - overwrites it with currently corresponding
descriptor. The endpoint maxpacket field is updated according
to the chosen descriptor.</p>
<p><strong>Note</strong></p>
<p>the supplied function should hold all the descriptors
for supported speeds</p>
<dl class="function">
<dt id="c.usb_add_function">
int <code class="descname">usb_add_function</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration">usb_configuration</a> *<em>&nbsp;config</em>, struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a> *<em>&nbsp;function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_add_function" title="Permalink to this definition">¶</a></dt>
<dd><p>add a function to a configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_configuration</span> <span class="pre">*</span> <span class="pre">config</span></code></dt>
<dd>the configuration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*</span> <span class="pre">function</span></code></dt>
<dd>the function being added</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p>After initialization, each configuration must have one or more
functions added to it.  Adding a function involves calling its <strong>bind()</strong>
method to allocate resources such as interface and string identifiers
and endpoints.</p>
<p>This function returns the value of the function’s <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code>, which is
zero for success else a negative errno value.</p>
<dl class="function">
<dt id="c.usb_function_deactivate">
int <code class="descname">usb_function_deactivate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a> *<em>&nbsp;function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_function_deactivate" title="Permalink to this definition">¶</a></dt>
<dd><p>prevent function and gadget enumeration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*</span> <span class="pre">function</span></code></dt>
<dd>the function that isn’t yet ready to respond</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blocks response of the gadget driver to host enumeration by
preventing the data line pullup from being activated.  This is
normally called during <strong>bind()</strong> processing to change from the
initial “ready to respond” state, or when a required resource
becomes available.</p>
<p>For example, drivers that serve as a passthrough to a userspace
daemon can block enumeration unless that daemon (such as an OBEX,
MTP, or print server) is ready to handle host requests.</p>
<p>Not all systems support software control of their USB peripheral
data pullups.</p>
<p>Returns zero on success, else negative errno.</p>
<dl class="function">
<dt id="c.usb_function_activate">
int <code class="descname">usb_function_activate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a> *<em>&nbsp;function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_function_activate" title="Permalink to this definition">¶</a></dt>
<dd><p>allow function and gadget enumeration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*</span> <span class="pre">function</span></code></dt>
<dd>function on which <a class="reference internal" href="#c.usb_function_activate" title="usb_function_activate"><code class="xref c c-func docutils literal"><span class="pre">usb_function_activate()</span></code></a> was called</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reverses effect of <a class="reference internal" href="#c.usb_function_deactivate" title="usb_function_deactivate"><code class="xref c c-func docutils literal"><span class="pre">usb_function_deactivate()</span></code></a>.  If no more functions
are delaying their activation, the gadget driver will respond to
host enumeration procedures.</p>
<p>Returns zero on success, else negative errno.</p>
<dl class="function">
<dt id="c.usb_interface_id">
int <code class="descname">usb_interface_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration">usb_configuration</a> *<em>&nbsp;config</em>, struct <a class="reference internal" href="#c.usb_function" title="usb_function">usb_function</a> *<em>&nbsp;function</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_interface_id" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an unused interface ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_configuration</span> <span class="pre">*</span> <span class="pre">config</span></code></dt>
<dd>configuration associated with the interface</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_function</span> <span class="pre">*</span> <span class="pre">function</span></code></dt>
<dd>function handling the interface</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.usb_interface_id" title="usb_interface_id"><code class="xref c c-func docutils literal"><span class="pre">usb_interface_id()</span></code></a> is called from usb_function.:c:func:<cite>bind()</cite> callbacks to
allocate new interface IDs.  The function driver will then store that
ID in interface, association, CDC union, and other descriptors.  It
will also handle any control requests targeted at that interface,
particularly changing its altsetting via <code class="xref c c-func docutils literal"><span class="pre">set_alt()</span></code>.  There may
also be class-specific or vendor-specific requests to handle.</p>
<p>All interface identifier should be allocated using this routine, to
ensure that for example different functions don’t wrongly assign
different meanings to the same identifier.  Note that since interface
identifiers are configuration-specific, functions used in more than
one configuration (or more than once in a given configuration) need
multiple versions of the relevant descriptors.</p>
<p>Returns the interface ID which was allocated; or -ENODEV if no
more interface IDs can be allocated.</p>
<dl class="function">
<dt id="c.usb_add_config">
int <code class="descname">usb_add_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration">usb_configuration</a> *<em>&nbsp;config</em>, int (*bind) (struct <a class="reference internal" href="#c.usb_configuration" title="usb_configuration">usb_configuration</a><em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_add_config" title="Permalink to this definition">¶</a></dt>
<dd><p>add a configuration to a device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>wraps the USB gadget</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_configuration</span> <span class="pre">*</span> <span class="pre">config</span></code></dt>
<dd>the configuration, with bConfigurationValue assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">usb_configuration</span> <span class="pre">*)</span> <span class="pre">bind</span></code></dt>
<dd>the configuration’s bind function</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p>One of the main tasks of a composite <strong>bind()</strong> routine is to
add each of the configurations it supports, using this routine.</p>
<p>This function returns the value of the configuration’s <strong>bind()</strong>, which
is zero for success else a negative errno value.  Binding configurations
assigns global resources including string IDs, and per-configuration
resources such as interface IDs and endpoints.</p>
<dl class="function">
<dt id="c.usb_string_id">
int <code class="descname">usb_string_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_string_id" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an unused string ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the device whose string descriptor IDs are being allocated</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p><strong>usb_string_id()</strong> is called from <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code> callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then store that ID in the appropriate descriptors and string table.</p>
<p>All string identifier should be allocated using this,
<strong>usb_string_ids_tab()</strong> or <strong>usb_string_ids_n()</strong> routine, to ensure
that for example different functions don’t wrongly assign different
meanings to the same identifier.</p>
<dl class="function">
<dt id="c.usb_string_ids_tab">
int <code class="descname">usb_string_ids_tab</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="usb.html#c.usb_string" title="usb_string">usb_string</a> *<em>&nbsp;str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_string_ids_tab" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate unused string IDs in batch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the device whose string descriptor IDs are being allocated</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_string</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>an array of usb_string objects to assign numbers to</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p><strong>usb_string_ids()</strong> is called from <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code> callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then copy IDs from the string table to the appropriate descriptors
and string table for other languages.</p>
<p>All string identifier should be allocated using this,
<strong>usb_string_id()</strong> or <strong>usb_string_ids_n()</strong> routine, to ensure that for
example different functions don’t wrongly assign different meanings
to the same identifier.</p>
<dl class="function">
<dt id="c.usb_gstrings_attach">
struct <a class="reference internal" href="usb.html#c.usb_string" title="usb_string">usb_string</a> * <code class="descname">usb_gstrings_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a> *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="#c.usb_gadget_strings" title="usb_gadget_strings">usb_gadget_strings</a> **<em>&nbsp;sp</em>, unsigned<em>&nbsp;n_strings</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_gstrings_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach gadget strings to a cdev and assign ids</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the device whose string descriptor IDs are being allocated
and attached.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_gadget_strings</span> <span class="pre">**</span> <span class="pre">sp</span></code></dt>
<dd>an array of usb_gadget_strings to attach.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">n_strings</span></code></dt>
<dd>number of entries in each usb_strings array (sp[]-&gt;strings)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will create a deep copy of usb_gadget_strings and usb_string
and attach it to the cdev. The actual string (usb_string.s) will not be
copied but only a referenced will be made. The struct usb_gadget_strings
array may contain multiple languages and should be NULL terminated.
The -&gt;language pointer of each struct usb_gadget_strings has to contain the
same amount of entries.
For instance: sp[0] is en-US, sp[1] is es-ES. It is expected that the first
usb_string entry of es-ES contains the translation of the first usb_string
entry of en-US. Therefore both entries become the same id assign.</p>
<dl class="function">
<dt id="c.usb_string_ids_n">
int <code class="descname">usb_string_ids_n</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a> *<em>&nbsp;c</em>, unsigned<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_string_ids_n" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate unused string IDs in batch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>the device whose string descriptor IDs are being allocated</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">n</span></code></dt>
<dd>number of string IDs to allocate</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p>Returns the first requested ID.  This ID and next <strong>n</strong>-1 IDs are now
valid IDs.  At least provided that <strong>n</strong> is non-zero because if it
is, returns last requested ID which is now very useful information.</p>
<p><strong>usb_string_ids_n()</strong> is called from <code class="xref c c-func docutils literal"><span class="pre">bind()</span></code> callbacks to allocate
string IDs.  Drivers for functions, configurations, or gadgets will
then store that ID in the appropriate descriptors and string table.</p>
<p>All string identifier should be allocated using this,
<strong>usb_string_id()</strong> or <strong>usb_string_ids_n()</strong> routine, to ensure that for
example different functions don’t wrongly assign different meanings
to the same identifier.</p>
<dl class="function">
<dt id="c.usb_composite_probe">
int <code class="descname">usb_composite_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_driver" title="usb_composite_driver">usb_composite_driver</a> *<em>&nbsp;driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_composite_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>register a composite driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_composite_driver</span> <span class="pre">*</span> <span class="pre">driver</span></code></dt>
<dd>the driver to register</dd>
</dl>
<p><strong>Context</strong></p>
<p>single threaded during gadget setup</p>
<p><strong>Description</strong></p>
<p>This function is used to register drivers using the composite driver
framework.  The return value is zero, or a negative errno value.
Those values normally come from the driver’s <strong>bind</strong> method, which does
all the work of setting up the driver to match the hardware.</p>
<p>On successful return, the gadget is ready to respond to requests from
the host, unless one of its components invokes <code class="xref c c-func docutils literal"><span class="pre">usb_gadget_disconnect()</span></code>
while it was binding.  That would usually be done in order to wait for
some userspace participation.</p>
<dl class="function">
<dt id="c.usb_composite_unregister">
void <code class="descname">usb_composite_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_driver" title="usb_composite_driver">usb_composite_driver</a> *<em>&nbsp;driver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_composite_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a composite driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_composite_driver</span> <span class="pre">*</span> <span class="pre">driver</span></code></dt>
<dd>the driver to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to unregister drivers using the composite
driver framework.</p>
<dl class="function">
<dt id="c.usb_composite_setup_continue">
void <code class="descname">usb_composite_setup_continue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.usb_composite_dev" title="usb_composite_dev">usb_composite_dev</a> *<em>&nbsp;cdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usb_composite_setup_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>Continue with the control transfer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_composite_dev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the composite device who’s control transfer was kept waiting</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by the USB function driver to continue
with the control transfer’s data/status stage in case it had requested to
delay the data/status stages. A USB function’s setup handler (e.g. <code class="xref c c-func docutils literal"><span class="pre">set_alt()</span></code>)
can request the composite framework to delay the setup request’s data/status
stages by returning USB_GADGET_DELAYED_STATUS.</p>
</div>
<div class="section" id="composite-device-functions">
<h3>Composite Device Functions<a class="headerlink" href="#composite-device-functions" title="Permalink to this headline">¶</a></h3>
<p>At this writing, a few of the current gadget drivers have been converted
to this framework. Near-term plans include converting all of them,
except for <code class="docutils literal"><span class="pre">gadgetfs</span></code>.</p>
</div>
</div>
<div class="section" id="peripheral-controller-drivers">
<h2>Peripheral Controller Drivers<a class="headerlink" href="#peripheral-controller-drivers" title="Permalink to this headline">¶</a></h2>
<p>The first hardware supporting this API was the NetChip 2280 controller,
which supports USB 2.0 high speed and is based on PCI. This is the
<code class="docutils literal"><span class="pre">net2280</span></code> driver module. The driver supports Linux kernel versions 2.4
and 2.6; contact NetChip Technologies for development boards and product
information.</p>
<p>Other hardware working in the <code class="docutils literal"><span class="pre">gadget</span></code> framework includes: Intel’s PXA
25x and IXP42x series processors (<code class="docutils literal"><span class="pre">pxa2xx_udc</span></code>), Toshiba TC86c001
“Goku-S” (<code class="docutils literal"><span class="pre">goku_udc</span></code>), Renesas SH7705/7727 (<code class="docutils literal"><span class="pre">sh_udc</span></code>), MediaQ 11xx
(<code class="docutils literal"><span class="pre">mq11xx_udc</span></code>), Hynix HMS30C7202 (<code class="docutils literal"><span class="pre">h7202_udc</span></code>), National 9303/4
(<code class="docutils literal"><span class="pre">n9604_udc</span></code>), Texas Instruments OMAP (<code class="docutils literal"><span class="pre">omap_udc</span></code>), Sharp LH7A40x
(<code class="docutils literal"><span class="pre">lh7a40x_udc</span></code>), and more. Most of those are full speed controllers.</p>
<p>At this writing, there are people at work on drivers in this framework
for several other USB device controllers, with plans to make many of
them be widely available.</p>
<p>A partial USB simulator, the <code class="docutils literal"><span class="pre">dummy_hcd</span></code> driver, is available. It can
act like a net2280, a pxa25x, or an sa11x0 in terms of available
endpoints and device speeds; and it simulates control, bulk, and to some
extent interrupt transfers. That lets you develop some parts of a gadget
driver on a normal PC, without any special hardware, and perhaps with
the assistance of tools such as GDB running with User Mode Linux. At
least one person has expressed interest in adapting that approach,
hooking it up to a simulator for a microcontroller. Such simulators can
help debug subsystems where the runtime hardware is unfriendly to
software development, or is not yet available.</p>
<p>Support for other controllers is expected to be developed and
contributed over time, as this driver framework evolves.</p>
</div>
<div class="section" id="gadget-drivers">
<h2>Gadget Drivers<a class="headerlink" href="#gadget-drivers" title="Permalink to this headline">¶</a></h2>
<p>In addition to <em>Gadget Zero</em> (used primarily for testing and development
with drivers for usb controller hardware), other gadget drivers exist.</p>
<p>There’s an <code class="docutils literal"><span class="pre">ethernet</span></code> gadget driver, which implements one of the most
useful <em>Communications Device Class</em> (CDC) models. One of the standards
for cable modem interoperability even specifies the use of this ethernet
model as one of two mandatory options. Gadgets using this code look to a
USB host as if they’re an Ethernet adapter. It provides access to a
network where the gadget’s CPU is one host, which could easily be
bridging, routing, or firewalling access to other networks. Since some
hardware can’t fully implement the CDC Ethernet requirements, this
driver also implements a “good parts only” subset of CDC Ethernet. (That
subset doesn’t advertise itself as CDC Ethernet, to avoid creating
problems.)</p>
<p>Support for Microsoft’s <code class="docutils literal"><span class="pre">RNDIS</span></code> protocol has been contributed by
Pengutronix and Auerswald GmbH. This is like CDC Ethernet, but it runs
on more slightly USB hardware (but less than the CDC subset). However,
its main claim to fame is being able to connect directly to recent
versions of Windows, using drivers that Microsoft bundles and supports,
making it much simpler to network with Windows.</p>
<p>There is also support for user mode gadget drivers, using <code class="docutils literal"><span class="pre">gadgetfs</span></code>.
This provides a <em>User Mode API</em> that presents each endpoint as a single
file descriptor. I/O is done using normal <code class="docutils literal"><span class="pre">read()</span></code> and <code class="docutils literal"><span class="pre">read()</span></code> calls.
Familiar tools like GDB and pthreads can be used to develop and debug
user mode drivers, so that once a robust controller driver is available
many applications for it won’t require new kernel mode software. Linux
2.6 <em>Async I/O (AIO)</em> support is available, so that user mode software
can stream data with only slightly more overhead than a kernel driver.</p>
<p>There’s a USB Mass Storage class driver, which provides a different
solution for interoperability with systems such as MS-Windows and MacOS.
That <em>Mass Storage</em> driver uses a file or block device as backing store
for a drive, like the <code class="docutils literal"><span class="pre">loop</span></code> driver. The USB host uses the BBB, CB, or
CBI versions of the mass storage class specification, using transparent
SCSI commands to access the data from the backing store.</p>
<p>There’s a “serial line” driver, useful for TTY style operation over USB.
The latest version of that driver supports CDC ACM style operation, like
a USB modem, and so on most hardware it can interoperate easily with
MS-Windows. One interesting use of that driver is in boot firmware (like
a BIOS), which can sometimes use that model with very small systems
without real serial lines.</p>
<p>Support for other kinds of gadget is expected to be developed and
contributed over time, as this driver framework evolves.</p>
</div>
<div class="section" id="usb-on-the-go-otg">
<h2>USB On-The-GO (OTG)<a class="headerlink" href="#usb-on-the-go-otg" title="Permalink to this headline">¶</a></h2>
<p>USB OTG support on Linux 2.6 was initially developed by Texas
Instruments for <a class="reference external" href="http://www.omap.com">OMAP</a> 16xx and 17xx series
processors. Other OTG systems should work in similar ways, but the
hardware level details could be very different.</p>
<p>Systems need specialized hardware support to implement OTG, notably
including a special <em>Mini-AB</em> jack and associated transceiver to support
<em>Dual-Role</em> operation: they can act either as a host, using the standard
Linux-USB host side driver stack, or as a peripheral, using this
<code class="docutils literal"><span class="pre">gadget</span></code> framework. To do that, the system software relies on small
additions to those programming interfaces, and on a new internal
component (here called an “OTG Controller”) affecting which driver stack
connects to the OTG port. In each role, the system can re-use the
existing pool of hardware-neutral drivers, layered on top of the
controller driver interfaces (<code class="xref c c-type docutils literal"><span class="pre">usb_bus</span></code> or <a class="reference internal" href="#c.usb_gadget" title="usb_gadget"><code class="xref c c-type docutils literal"><span class="pre">usb_gadget</span></code></a>).
Such drivers need at most minor changes, and most of the calls added to
support OTG can also benefit non-OTG products.</p>
<ul>
<li><p class="first">Gadget drivers test the <code class="docutils literal"><span class="pre">is_otg</span></code> flag, and use it to determine
whether or not to include an OTG descriptor in each of their
configurations.</p>
</li>
<li><p class="first">Gadget drivers may need changes to support the two new OTG protocols,
exposed in new gadget attributes such as <code class="docutils literal"><span class="pre">b_hnp_enable</span></code> flag. HNP
support should be reported through a user interface (two LEDs could
suffice), and is triggered in some cases when the host suspends the
peripheral. SRP support can be user-initiated just like remote
wakeup, probably by pressing the same button.</p>
</li>
<li><p class="first">On the host side, USB device drivers need to be taught to trigger HNP
at appropriate moments, using <code class="docutils literal"><span class="pre">usb_suspend_device()</span></code>. That also
conserves battery power, which is useful even for non-OTG
configurations.</p>
</li>
<li><p class="first">Also on the host side, a driver must support the OTG “Targeted
Peripheral List”. That’s just a whitelist, used to reject peripherals
not supported with a given Linux OTG host. <em>This whitelist is
product-specific; each product must modify</em> <code class="docutils literal"><span class="pre">otg_whitelist.h</span></code> <em>to
match its interoperability specification.</em></p>
<p>Non-OTG Linux hosts, like PCs and workstations, normally have some
solution for adding drivers, so that peripherals that aren’t
recognized can eventually be supported. That approach is unreasonable
for consumer products that may never have their firmware upgraded,
and where it’s usually unrealistic to expect traditional
PC/workstation/server kinds of support model to work. For example,
it’s often impractical to change device firmware once the product has
been distributed, so driver bugs can’t normally be fixed if they’re
found after shipment.</p>
</li>
</ul>
<p>Additional changes are needed below those hardware-neutral <code class="xref c c-type docutils literal"><span class="pre">usb_bus</span></code>
and <a class="reference internal" href="#c.usb_gadget" title="usb_gadget"><code class="xref c c-type docutils literal"><span class="pre">usb_gadget</span></code></a> driver interfaces; those aren’t discussed here in any
detail. Those affect the hardware-specific code for each USB Host or
Peripheral controller, and how the HCD initializes (since OTG can be
active only on a single port). They also involve what may be called an
<em>OTG Controller Driver</em>, managing the OTG transceiver and the OTG state
machine logic as well as much of the root hub behavior for the OTG port.
The OTG controller driver needs to activate and deactivate USB
controllers depending on the relevant device role. Some related changes
were needed inside usbcore, so that it can identify OTG-capable devices
and respond appropriately to HNP or SRP protocols.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="anchors.html" class="btn btn-neutral float-right" title="USB Anchors" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="usb.html" class="btn btn-neutral" title="The Linux-USB Host Side API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>