

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Legacy GPIO Interfaces &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Miscellaneous Devices" href="../misc_devices.html" />
    <link rel="prev" title="Subsystem drivers using GPIO" href="drivers-on-gpio.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">General Purpose Input/Output (GPIO)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="driver.html">GPIO Descriptor Driver Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="consumer.html">GPIO Descriptor Consumer Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="board.html">GPIO Mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Legacy GPIO Interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-a-gpio">What is a GPIO?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gpio-conventions">GPIO conventions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-do-these-conventions-omit">What do these conventions omit?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gpio-implementor-s-framework-optional">GPIO implementor’s framework (OPTIONAL)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sysfs-interface-for-userspace-optional">Sysfs Interface for Userspace (OPTIONAL)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="index.html#core">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#acpi-support">ACPI support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#device-tree-support">Device tree support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#device-managed-api">Device-managed API</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sysfs-helpers">sysfs helpers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">General Purpose Input/Output (GPIO)</a> &raquo;</li>
        
      <li>Legacy GPIO Interfaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/gpio/legacy.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="legacy-gpio-interfaces">
<h1>Legacy GPIO Interfaces<a class="headerlink" href="#legacy-gpio-interfaces" title="Permalink to this headline">¶</a></h1>
<p>This provides an overview of GPIO access conventions on Linux.</p>
<p>These calls use the gpio_* naming prefix.  No other calls should use that
prefix, or the related __gpio_* prefix.</p>
<div class="section" id="what-is-a-gpio">
<h2>What is a GPIO?<a class="headerlink" href="#what-is-a-gpio" title="Permalink to this headline">¶</a></h2>
<p>A “General Purpose Input/Output” (GPIO) is a flexible software-controlled
digital signal.  They are provided from many kinds of chip, and are familiar
to Linux developers working with embedded and custom hardware.  Each GPIO
represents a bit connected to a particular pin, or “ball” on Ball Grid Array
(BGA) packages.  Board schematics show which external hardware connects to
which GPIOs.  Drivers can be written generically, so that board setup code
passes such pin configuration data to drivers.</p>
<p>System-on-Chip (SOC) processors heavily rely on GPIOs.  In some cases, every
non-dedicated pin can be configured as a GPIO; and most chips have at least
several dozen of them.  Programmable logic devices (like FPGAs) can easily
provide GPIOs; multifunction chips like power managers, and audio codecs
often have a few such pins to help with pin scarcity on SOCs; and there are
also “GPIO Expander” chips that connect using the I2C or SPI serial busses.
Most PC southbridges have a few dozen GPIO-capable pins (with only the BIOS
firmware knowing how they’re used).</p>
<p>The exact capabilities of GPIOs vary between systems.  Common options:</p>
<blockquote>
<div><ul class="simple">
<li>Output values are writable (high=1, low=0).  Some chips also have
options about how that value is driven, so that for example only one
value might be driven … supporting “wire-OR” and similar schemes
for the other value (notably, “open drain” signaling).</li>
<li>Input values are likewise readable (1, 0).  Some chips support readback
of pins configured as “output”, which is very useful in such “wire-OR”
cases (to support bidirectional signaling).  GPIO controllers may have
input de-glitch/debounce logic, sometimes with software controls.</li>
<li>Inputs can often be used as IRQ signals, often edge triggered but
sometimes level triggered.  Such IRQs may be configurable as system
wakeup events, to wake the system from a low power state.</li>
<li>Usually a GPIO will be configurable as either input or output, as needed
by different product boards; single direction ones exist too.</li>
<li>Most GPIOs can be accessed while holding spinlocks, but those accessed
through a serial bus normally can’t.  Some systems support both types.</li>
</ul>
</div></blockquote>
<p>On a given board each GPIO is used for one specific purpose like monitoring
MMC/SD card insertion/removal, detecting card writeprotect status, driving
a LED, configuring a transceiver, bitbanging a serial bus, poking a hardware
watchdog, sensing a switch, and so on.</p>
</div>
<div class="section" id="gpio-conventions">
<h2>GPIO conventions<a class="headerlink" href="#gpio-conventions" title="Permalink to this headline">¶</a></h2>
<p>Note that this is called a “convention” because you don’t need to do it this
way, and it’s no crime if you don’t.  There <strong>are</strong> cases where portability
is not the main issue; GPIOs are often used for the kind of board-specific
glue logic that may even change between board revisions, and can’t ever be
used on a board that’s wired differently.  Only least-common-denominator
functionality can be very portable.  Other features are platform-specific,
and that can be critical for glue logic.</p>
<p>Plus, this doesn’t require any implementation framework, just an interface.
One platform might implement it as simple inline functions accessing chip
registers; another might implement it by delegating through abstractions
used for several very different kinds of GPIO controller.  (There is some
optional code supporting such an implementation strategy, described later
in this document, but drivers acting as clients to the GPIO interface must
not care how it’s implemented.)</p>
<p>That said, if the convention is supported on their platform, drivers should
use it when possible.  Platforms must select GPIOLIB if GPIO functionality
is strictly required.  Drivers that can’t work without
standard GPIO calls should have Kconfig entries which depend on GPIOLIB.  The
GPIO calls are available, either as “real code” or as optimized-away stubs,
when drivers use the include file:</p>
<blockquote>
<div>#include &lt;linux/gpio.h&gt;</div></blockquote>
<p>If you stick to this convention then it’ll be easier for other developers to
see what your code is doing, and help maintain it.</p>
<p>Note that these operations include I/O barriers on platforms which need to
use them; drivers don’t need to add them explicitly.</p>
<div class="section" id="identifying-gpios">
<h3>Identifying GPIOs<a class="headerlink" href="#identifying-gpios" title="Permalink to this headline">¶</a></h3>
<p>GPIOs are identified by unsigned integers in the range 0..MAX_INT.  That
reserves “negative” numbers for other purposes like marking signals as
“not available on this board”, or indicating faults.  Code that doesn’t
touch the underlying hardware treats these integers as opaque cookies.</p>
<p>Platforms define how they use those integers, and usually #define symbols
for the GPIO lines so that board-specific setup code directly corresponds
to the relevant schematics.  In contrast, drivers should only use GPIO
numbers passed to them from that setup code, using platform_data to hold
board-specific pin configuration data (along with other board specific
data they need).  That avoids portability problems.</p>
<p>So for example one platform uses numbers 32-159 for GPIOs; while another
uses numbers 0..63 with one set of GPIO controllers, 64-79 with another
type of GPIO controller, and on one particular board 80-95 with an FPGA.
The numbers need not be contiguous; either of those platforms could also
use numbers 2000-2063 to identify GPIOs in a bank of I2C GPIO expanders.</p>
<p>If you want to initialize a structure with an invalid GPIO number, use
some negative number (perhaps “-EINVAL”); that will never be valid.  To
test if such number from such a structure could reference a GPIO, you
may use this predicate:</p>
<blockquote>
<div>int gpio_is_valid(int number);</div></blockquote>
<p>A number that’s not valid will be rejected by calls which may request
or free GPIOs (see below).  Other numbers may also be rejected; for
example, a number might be valid but temporarily unused on a given board.</p>
<p>Whether a platform supports multiple GPIO controllers is a platform-specific
implementation issue, as are whether that support can leave “holes” in the space
of GPIO numbers, and whether new controllers can be added at runtime.  Such issues
can affect things including whether adjacent GPIO numbers are both valid.</p>
</div>
<div class="section" id="using-gpios">
<h3>Using GPIOs<a class="headerlink" href="#using-gpios" title="Permalink to this headline">¶</a></h3>
<p>The first thing a system should do with a GPIO is allocate it, using
the gpio_request() call; see later.</p>
<p>One of the next things to do with a GPIO, often in board setup code when
setting up a platform_device using the GPIO, is mark its direction:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* set as input or output, returning 0 or negative errno */
int gpio_direction_input(unsigned gpio);
int gpio_direction_output(unsigned gpio, int value);
</pre></div>
</div>
<p>The return value is zero for success, else a negative errno.  It should
be checked, since the get/set calls don’t have error returns and since
misconfiguration is possible.  You should normally issue these calls from
a task context.  However, for spinlock-safe GPIOs it’s OK to use them
before tasking is enabled, as part of early board setup.</p>
<p>For output GPIOs, the value provided becomes the initial output value.
This helps avoid signal glitching during system startup.</p>
<p>For compatibility with legacy interfaces to GPIOs, setting the direction
of a GPIO implicitly requests that GPIO (see below) if it has not been
requested already.  That compatibility is being removed from the optional
gpiolib framework.</p>
<p>Setting the direction can fail if the GPIO number is invalid, or when
that particular GPIO can’t be used in that mode.  It’s generally a bad
idea to rely on boot firmware to have set the direction correctly, since
it probably wasn’t validated to do more than boot Linux.  (Similarly,
that board setup code probably needs to multiplex that pin as a GPIO,
and configure pullups/pulldowns appropriately.)</p>
</div>
<div class="section" id="spinlock-safe-gpio-access">
<h3>Spinlock-Safe GPIO access<a class="headerlink" href="#spinlock-safe-gpio-access" title="Permalink to this headline">¶</a></h3>
<p>Most GPIO controllers can be accessed with memory read/write instructions.
Those don’t need to sleep, and can safely be done from inside hard
(nonthreaded) IRQ handlers and similar contexts.</p>
<p>Use the following calls to access such GPIOs,
for which gpio_cansleep() will always return false (see below):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* GPIO INPUT:  return zero or nonzero */
int gpio_get_value(unsigned gpio);

/* GPIO OUTPUT */
void gpio_set_value(unsigned gpio, int value);
</pre></div>
</div>
<p>The values are boolean, zero for low, nonzero for high.  When reading the
value of an output pin, the value returned should be what’s seen on the
pin … that won’t always match the specified output value, because of
issues including open-drain signaling and output latencies.</p>
<p>The get/set calls have no error returns because “invalid GPIO” should have
been reported earlier from gpio_direction_*().  However, note that not all
platforms can read the value of output pins; those that can’t should always
return zero.  Also, using these calls for GPIOs that can’t safely be accessed
without sleeping (see below) is an error.</p>
<p>Platform-specific implementations are encouraged to optimize the two
calls to access the GPIO value in cases where the GPIO number (and for
output, value) are constant.  It’s normal for them to need only a couple
of instructions in such cases (reading or writing a hardware register),
and not to need spinlocks.  Such optimized calls can make bitbanging
applications a lot more efficient (in both space and time) than spending
dozens of instructions on subroutine calls.</p>
</div>
<div class="section" id="gpio-access-that-may-sleep">
<h3>GPIO access that may sleep<a class="headerlink" href="#gpio-access-that-may-sleep" title="Permalink to this headline">¶</a></h3>
<p>Some GPIO controllers must be accessed using message based busses like I2C
or SPI.  Commands to read or write those GPIO values require waiting to
get to the head of a queue to transmit a command and get its response.
This requires sleeping, which can’t be done from inside IRQ handlers.</p>
<p>Platforms that support this type of GPIO distinguish them from other GPIOs
by returning nonzero from this call (which requires a valid GPIO number,
which should have been previously allocated with gpio_request):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int gpio_cansleep(unsigned gpio);
</pre></div>
</div>
<p>To access such GPIOs, a different set of accessors is defined:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* GPIO INPUT:  return zero or nonzero, might sleep */
int gpio_get_value_cansleep(unsigned gpio);

/* GPIO OUTPUT, might sleep */
void gpio_set_value_cansleep(unsigned gpio, int value);
</pre></div>
</div>
<p>Accessing such GPIOs requires a context which may sleep,  for example
a threaded IRQ handler, and those accessors must be used instead of
spinlock-safe accessors without the cansleep() name suffix.</p>
<p>Other than the fact that these accessors might sleep, and will work
on GPIOs that can’t be accessed from hardIRQ handlers, these calls act
the same as the spinlock-safe calls.</p>
<p><strong>IN ADDITION</strong> calls to setup and configure such GPIOs must be made
from contexts which may sleep, since they may need to access the GPIO
controller chip too  (These setup calls are usually made from board
setup or driver probe/teardown code, so this is an easy constraint.):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>        gpio_direction_input()
        gpio_direction_output()
        gpio_request()

##      gpio_request_one()
##      gpio_request_array()
##      gpio_free_array()

        gpio_free()
        gpio_set_debounce()
</pre></div>
</div>
</div>
<div class="section" id="claiming-and-releasing-gpios">
<h3>Claiming and Releasing GPIOs<a class="headerlink" href="#claiming-and-releasing-gpios" title="Permalink to this headline">¶</a></h3>
<p>To help catch system configuration errors, two calls are defined:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* request GPIO, returning 0 or negative errno.
 * non-null labels may be useful for diagnostics.
 */
int gpio_request(unsigned gpio, const char *label);

/* release previously-claimed GPIO */
void gpio_free(unsigned gpio);
</pre></div>
</div>
<p>Passing invalid GPIO numbers to gpio_request() will fail, as will requesting
GPIOs that have already been claimed with that call.  The return value of
gpio_request() must be checked.  You should normally issue these calls from
a task context.  However, for spinlock-safe GPIOs it’s OK to request GPIOs
before tasking is enabled, as part of early board setup.</p>
<p>These calls serve two basic purposes.  One is marking the signals which
are actually in use as GPIOs, for better diagnostics; systems may have
several hundred potential GPIOs, but often only a dozen are used on any
given board.  Another is to catch conflicts, identifying errors when
(a) two or more drivers wrongly think they have exclusive use of that
signal, or (b) something wrongly believes it’s safe to remove drivers
needed to manage a signal that’s in active use.  That is, requesting a
GPIO can serve as a kind of lock.</p>
<p>Some platforms may also use knowledge about what GPIOs are active for
power management, such as by powering down unused chip sectors and, more
easily, gating off unused clocks.</p>
<p>For GPIOs that use pins known to the pinctrl subsystem, that subsystem should
be informed of their use; a gpiolib driver’s .request() operation may call
pinctrl_gpio_request(), and a gpiolib driver’s .free() operation may call
pinctrl_gpio_free(). The pinctrl subsystem allows a pinctrl_gpio_request()
to succeed concurrently with a pin or pingroup being “owned” by a device for
pin multiplexing.</p>
<p>Any programming of pin multiplexing hardware that is needed to route the
GPIO signal to the appropriate pin should occur within a GPIO driver’s
.direction_input() or .direction_output() operations, and occur after any
setup of an output GPIO’s value. This allows a glitch-free migration from a
pin’s special function to GPIO. This is sometimes required when using a GPIO
to implement a workaround on signals typically driven by a non-GPIO HW block.</p>
<p>Some platforms allow some or all GPIO signals to be routed to different pins.
Similarly, other aspects of the GPIO or pin may need to be configured, such as
pullup/pulldown. Platform software should arrange that any such details are
configured prior to gpio_request() being called for those GPIOs, e.g. using
the pinctrl subsystem’s mapping table, so that GPIO users need not be aware
of these details.</p>
<p>Also note that it’s your responsibility to have stopped using a GPIO
before you free it.</p>
<p>Considering in most cases GPIOs are actually configured right after they
are claimed, three additional calls are defined:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* request a single GPIO, with initial configuration specified by
 * &#39;flags&#39;, identical to gpio_request() wrt other arguments and
 * return value
 */
int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);

/* request multiple GPIOs in a single call
 */
int gpio_request_array(struct gpio *array, size_t num);

/* release multiple GPIOs in a single call
 */
void gpio_free_array(struct gpio *array, size_t num);
</pre></div>
</div>
<p>where ‘flags’ is currently defined to specify the following properties:</p>
<blockquote>
<div><ul class="simple">
<li>GPIOF_DIR_IN          - to configure direction as input</li>
<li>GPIOF_DIR_OUT         - to configure direction as output</li>
<li>GPIOF_INIT_LOW        - as output, set initial level to LOW</li>
<li>GPIOF_INIT_HIGH       - as output, set initial level to HIGH</li>
<li>GPIOF_OPEN_DRAIN      - gpio pin is open drain type.</li>
<li>GPIOF_OPEN_SOURCE     - gpio pin is open source type.</li>
<li>GPIOF_EXPORT_DIR_FIXED        - export gpio to sysfs, keep direction</li>
<li>GPIOF_EXPORT_DIR_CHANGEABLE   - also export, allow changing direction</li>
</ul>
</div></blockquote>
<p>since GPIOF_INIT_* are only valid when configured as output, so group valid
combinations as:</p>
<blockquote>
<div><ul class="simple">
<li>GPIOF_IN              - configure as input</li>
<li>GPIOF_OUT_INIT_LOW    - configured as output, initial level LOW</li>
<li>GPIOF_OUT_INIT_HIGH   - configured as output, initial level HIGH</li>
</ul>
</div></blockquote>
<p>When setting the flag as GPIOF_OPEN_DRAIN then it will assume that pins is
open drain type. Such pins will not be driven to 1 in output mode. It is
require to connect pull-up on such pins. By enabling this flag, gpio lib will
make the direction to input when it is asked to set value of 1 in output mode
to make the pin HIGH. The pin is make to LOW by driving value 0 in output mode.</p>
<p>When setting the flag as GPIOF_OPEN_SOURCE then it will assume that pins is
open source type. Such pins will not be driven to 0 in output mode. It is
require to connect pull-down on such pin. By enabling this flag, gpio lib will
make the direction to input when it is asked to set value of 0 in output mode
to make the pin LOW. The pin is make to HIGH by driving value 1 in output mode.</p>
<p>In the future, these flags can be extended to support more properties.</p>
<p>Further more, to ease the claim/release of multiple GPIOs, ‘struct gpio’ is
introduced to encapsulate all three fields as:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct gpio {
        unsigned        gpio;
        unsigned long   flags;
        const char      *label;
};
</pre></div>
</div>
<p>A typical example of usage:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static struct gpio leds_gpios[] = {
        { 32, GPIOF_OUT_INIT_HIGH, &quot;Power LED&quot; }, /* default to ON */
        { 33, GPIOF_OUT_INIT_LOW,  &quot;Green LED&quot; }, /* default to OFF */
        { 34, GPIOF_OUT_INIT_LOW,  &quot;Red LED&quot;   }, /* default to OFF */
        { 35, GPIOF_OUT_INIT_LOW,  &quot;Blue LED&quot;  }, /* default to OFF */
        { ... },
};

err = gpio_request_one(31, GPIOF_IN, &quot;Reset Button&quot;);
if (err)
        ...

err = gpio_request_array(leds_gpios, ARRAY_SIZE(leds_gpios));
if (err)
        ...

gpio_free_array(leds_gpios, ARRAY_SIZE(leds_gpios));
</pre></div>
</div>
</div>
<div class="section" id="gpios-mapped-to-irqs">
<h3>GPIOs mapped to IRQs<a class="headerlink" href="#gpios-mapped-to-irqs" title="Permalink to this headline">¶</a></h3>
<p>GPIO numbers are unsigned integers; so are IRQ numbers.  These make up
two logically distinct namespaces (GPIO 0 need not use IRQ 0).  You can
map between them using calls like:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* map GPIO numbers to IRQ numbers */
int gpio_to_irq(unsigned gpio);

/* map IRQ numbers to GPIO numbers (avoid using this) */
int irq_to_gpio(unsigned irq);
</pre></div>
</div>
<p>Those return either the corresponding number in the other namespace, or
else a negative errno code if the mapping can’t be done.  (For example,
some GPIOs can’t be used as IRQs.)  It is an unchecked error to use a GPIO
number that wasn’t set up as an input using gpio_direction_input(), or
to use an IRQ number that didn’t originally come from gpio_to_irq().</p>
<p>These two mapping calls are expected to cost on the order of a single
addition or subtraction.  They’re not allowed to sleep.</p>
<p>Non-error values returned from gpio_to_irq() can be passed to request_irq()
or free_irq().  They will often be stored into IRQ resources for platform
devices, by the board-specific initialization code.  Note that IRQ trigger
options are part of the IRQ interface, e.g. IRQF_TRIGGER_FALLING, as are
system wakeup capabilities.</p>
<p>Non-error values returned from irq_to_gpio() would most commonly be used
with gpio_get_value(), for example to initialize or update driver state
when the IRQ is edge-triggered.  Note that some platforms don’t support
this reverse mapping, so you should avoid using it.</p>
</div>
<div class="section" id="emulating-open-drain-signals">
<h3>Emulating Open Drain Signals<a class="headerlink" href="#emulating-open-drain-signals" title="Permalink to this headline">¶</a></h3>
<p>Sometimes shared signals need to use “open drain” signaling, where only the
low signal level is actually driven.  (That term applies to CMOS transistors;
“open collector” is used for TTL.)  A pullup resistor causes the high signal
level.  This is sometimes called a “wire-AND”; or more practically, from the
negative logic (low=true) perspective this is a “wire-OR”.</p>
<p>One common example of an open drain signal is a shared active-low IRQ line.
Also, bidirectional data bus signals sometimes use open drain signals.</p>
<p>Some GPIO controllers directly support open drain outputs; many don’t.  When
you need open drain signaling but your hardware doesn’t directly support it,
there’s a common idiom you can use to emulate it with any GPIO pin that can
be used as either an input or an output:</p>
<blockquote>
<div><dl class="docutils">
<dt>LOW:   gpio_direction_output(gpio, 0) … this drives the signal</dt>
<dd>and overrides the pullup.</dd>
<dt>HIGH:  gpio_direction_input(gpio) … this turns off the output,</dt>
<dd>so the pullup (or some other device) controls the signal.</dd>
</dl>
</div></blockquote>
<p>If you are “driving” the signal high but gpio_get_value(gpio) reports a low
value (after the appropriate rise time passes), you know some other component
is driving the shared signal low.  That’s not necessarily an error.  As one
common example, that’s how I2C clocks are stretched:  a slave that needs a
slower clock delays the rising edge of SCK, and the I2C master adjusts its
signaling rate accordingly.</p>
</div>
<div class="section" id="gpio-controllers-and-the-pinctrl-subsystem">
<h3>GPIO controllers and the pinctrl subsystem<a class="headerlink" href="#gpio-controllers-and-the-pinctrl-subsystem" title="Permalink to this headline">¶</a></h3>
<p>A GPIO controller on a SOC might be tightly coupled with the pinctrl
subsystem, in the sense that the pins can be used by other functions
together with an optional gpio feature. We have already covered the
case where e.g. a GPIO controller need to reserve a pin or set the
direction of a pin by calling any of:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>pinctrl_gpio_request()
pinctrl_gpio_free()
pinctrl_gpio_direction_input()
pinctrl_gpio_direction_output()
</pre></div>
</div>
<p>But how does the pin control subsystem cross-correlate the GPIO
numbers (which are a global business) to a certain pin on a certain
pin controller?</p>
<p>This is done by registering “ranges” of pins, which are essentially
cross-reference tables. These are described in
Documentation/driver-api/pinctl.rst</p>
<p>While the pin allocation is totally managed by the pinctrl subsystem,
gpio (under gpiolib) is still maintained by gpio drivers. It may happen
that different pin ranges in a SoC is managed by different gpio drivers.</p>
<p>This makes it logical to let gpio drivers announce their pin ranges to
the pin ctrl subsystem before it will call ‘pinctrl_gpio_request’ in order
to request the corresponding pin to be prepared by the pinctrl subsystem
before any gpio usage.</p>
<p>For this, the gpio controller can register its pin range with pinctrl
subsystem. There are two ways of doing it currently: with or without DT.</p>
<p>For with DT support refer to Documentation/devicetree/bindings/gpio/gpio.txt.</p>
<p>For non-DT support, user can call gpiochip_add_pin_range() with appropriate
parameters to register a range of gpio pins with a pinctrl driver. For this
exact name string of pinctrl device has to be passed as one of the
argument to this routine.</p>
</div>
</div>
<div class="section" id="what-do-these-conventions-omit">
<h2>What do these conventions omit?<a class="headerlink" href="#what-do-these-conventions-omit" title="Permalink to this headline">¶</a></h2>
<p>One of the biggest things these conventions omit is pin multiplexing, since
this is highly chip-specific and nonportable.  One platform might not need
explicit multiplexing; another might have just two options for use of any
given pin; another might have eight options per pin; another might be able
to route a given GPIO to any one of several pins.  (Yes, those examples all
come from systems that run Linux today.)</p>
<p>Related to multiplexing is configuration and enabling of the pullups or
pulldowns integrated on some platforms.  Not all platforms support them,
or support them in the same way; and any given board might use external
pullups (or pulldowns) so that the on-chip ones should not be used.
(When a circuit needs 5 kOhm, on-chip 100 kOhm resistors won’t do.)
Likewise drive strength (2 mA vs 20 mA) and voltage (1.8V vs 3.3V) is a
platform-specific issue, as are models like (not) having a one-to-one
correspondence between configurable pins and GPIOs.</p>
<p>There are other system-specific mechanisms that are not specified here,
like the aforementioned options for input de-glitching and wire-OR output.
Hardware may support reading or writing GPIOs in gangs, but that’s usually
configuration dependent:  for GPIOs sharing the same bank.  (GPIOs are
commonly grouped in banks of 16 or 32, with a given SOC having several such
banks.)  Some systems can trigger IRQs from output GPIOs, or read values
from pins not managed as GPIOs.  Code relying on such mechanisms will
necessarily be nonportable.</p>
<p>Dynamic definition of GPIOs is not currently standard; for example, as
a side effect of configuring an add-on board with some GPIO expanders.</p>
</div>
<div class="section" id="gpio-implementor-s-framework-optional">
<h2>GPIO implementor’s framework (OPTIONAL)<a class="headerlink" href="#gpio-implementor-s-framework-optional" title="Permalink to this headline">¶</a></h2>
<p>As noted earlier, there is an optional implementation framework making it
easier for platforms to support different kinds of GPIO controller using
the same programming interface.  This framework is called “gpiolib”.</p>
<p>As a debugging aid, if debugfs is available a /sys/kernel/debug/gpio file
will be found there.  That will list all the controllers registered through
this framework, and the state of the GPIOs currently in use.</p>
<div class="section" id="controller-drivers-gpio-chip">
<h3>Controller Drivers: gpio_chip<a class="headerlink" href="#controller-drivers-gpio-chip" title="Permalink to this headline">¶</a></h3>
<p>In this framework each GPIO controller is packaged as a “struct gpio_chip”
with information common to each controller of that type:</p>
<blockquote>
<div><ul class="simple">
<li>methods to establish GPIO direction</li>
<li>methods used to access GPIO values</li>
<li>flag saying whether calls to its methods may sleep</li>
<li>optional debugfs dump method (showing extra state like pullup config)</li>
<li>label for diagnostics</li>
</ul>
</div></blockquote>
<p>There is also per-instance data, which may come from device.platform_data:
the number of its first GPIO, and how many GPIOs it exposes.</p>
<p>The code implementing a gpio_chip should support multiple instances of the
controller, possibly using the driver model.  That code will configure each
gpio_chip and issue gpiochip_add().  Removing a GPIO controller should be
rare; use gpiochip_remove() when it is unavoidable.</p>
<p>Most often a gpio_chip is part of an instance-specific structure with state
not exposed by the GPIO interfaces, such as addressing, power management,
and more.  Chips such as codecs will have complex non-GPIO state.</p>
<p>Any debugfs dump method should normally ignore signals which haven’t been
requested as GPIOs.  They can use gpiochip_is_requested(), which returns
either NULL or the label associated with that GPIO when it was requested.</p>
</div>
<div class="section" id="platform-support">
<h3>Platform Support<a class="headerlink" href="#platform-support" title="Permalink to this headline">¶</a></h3>
<p>To force-enable this framework, a platform’s Kconfig will “select” GPIOLIB,
else it is up to the user to configure support for GPIO.</p>
<p>It may also provide a custom value for ARCH_NR_GPIOS, so that it better
reflects the number of GPIOs in actual use on that platform, without
wasting static table space.  (It should count both built-in/SoC GPIOs and
also ones on GPIO expanders.</p>
<p>If neither of these options are selected, the platform does not support
GPIOs through GPIO-lib and the code cannot be enabled by the user.</p>
<p>Trivial implementations of those functions can directly use framework
code, which always dispatches through the gpio_chip:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#define gpio_get_value        __gpio_get_value
#define gpio_set_value        __gpio_set_value
#define gpio_cansleep         __gpio_cansleep
</pre></div>
</div>
<p>Fancier implementations could instead define those as inline functions with
logic optimizing access to specific SOC-based GPIOs.  For example, if the
referenced GPIO is the constant “12”, getting or setting its value could
cost as little as two or three instructions, never sleeping.  When such an
optimization is not possible those calls must delegate to the framework
code, costing at least a few dozen instructions.  For bitbanged I/O, such
instruction savings can be significant.</p>
<p>For SOCs, platform-specific code defines and registers gpio_chip instances
for each bank of on-chip GPIOs.  Those GPIOs should be numbered/labeled to
match chip vendor documentation, and directly match board schematics.  They
may well start at zero and go up to a platform-specific limit.  Such GPIOs
are normally integrated into platform initialization to make them always be
available, from arch_initcall() or earlier; they can often serve as IRQs.</p>
</div>
<div class="section" id="board-support">
<h3>Board Support<a class="headerlink" href="#board-support" title="Permalink to this headline">¶</a></h3>
<p>For external GPIO controllers – such as I2C or SPI expanders, ASICs, multi
function devices, FPGAs or CPLDs – most often board-specific code handles
registering controller devices and ensures that their drivers know what GPIO
numbers to use with gpiochip_add().  Their numbers often start right after
platform-specific GPIOs.</p>
<p>For example, board setup code could create structures identifying the range
of GPIOs that chip will expose, and passes them to each GPIO expander chip
using platform_data.  Then the chip driver’s probe() routine could pass that
data to gpiochip_add().</p>
<p>Initialization order can be important.  For example, when a device relies on
an I2C-based GPIO, its probe() routine should only be called after that GPIO
becomes available.  That may mean the device should not be registered until
calls for that GPIO can work.  One way to address such dependencies is for
such gpio_chip controllers to provide setup() and teardown() callbacks to
board specific code; those board specific callbacks would register devices
once all the necessary resources are available, and remove them later when
the GPIO controller device becomes unavailable.</p>
</div>
</div>
<div class="section" id="sysfs-interface-for-userspace-optional">
<h2>Sysfs Interface for Userspace (OPTIONAL)<a class="headerlink" href="#sysfs-interface-for-userspace-optional" title="Permalink to this headline">¶</a></h2>
<p>Platforms which use the “gpiolib” implementors framework may choose to
configure a sysfs user interface to GPIOs.  This is different from the
debugfs interface, since it provides control over GPIO direction and
value instead of just showing a gpio state summary.  Plus, it could be
present on production systems without debugging support.</p>
<p>Given appropriate hardware documentation for the system, userspace could
know for example that GPIO #23 controls the write protect line used to
protect boot loader segments in flash memory.  System upgrade procedures
may need to temporarily remove that protection, first importing a GPIO,
then changing its output state, then updating the code before re-enabling
the write protection.  In normal use, GPIO #23 would never be touched,
and the kernel would have no need to know about it.</p>
<p>Again depending on appropriate hardware documentation, on some systems
userspace GPIO can be used to determine system configuration data that
standard kernels won’t know about.  And for some tasks, simple userspace
GPIO drivers could be all that the system really needs.</p>
<p>Note that standard kernel drivers exist for common “LEDs and Buttons”
GPIO tasks:  “leds-gpio” and “gpio_keys”, respectively.  Use those
instead of talking directly to the GPIOs; they integrate with kernel
frameworks better than your userspace code could.</p>
<div class="section" id="paths-in-sysfs">
<h3>Paths in Sysfs<a class="headerlink" href="#paths-in-sysfs" title="Permalink to this headline">¶</a></h3>
<p>There are three kinds of entry in /sys/class/gpio:</p>
<blockquote>
<div><ul class="simple">
<li>Control interfaces used to get userspace control over GPIOs;</li>
<li>GPIOs themselves; and</li>
<li>GPIO controllers (“gpio_chip” instances).</li>
</ul>
</div></blockquote>
<p>That’s in addition to standard files including the “device” symlink.</p>
<p>The control interfaces are write-only:</p>
<blockquote>
<div><p>/sys/class/gpio/</p>
<blockquote>
<div><dl class="docutils">
<dt>“export” … Userspace may ask the kernel to export control of</dt>
<dd><p class="first">a GPIO to userspace by writing its number to this file.</p>
<p class="last">Example:  “echo 19 &gt; export” will create a “gpio19” node
for GPIO #19, if that’s not requested by kernel code.</p>
</dd>
</dl>
<p>“unexport” … Reverses the effect of exporting to userspace.</p>
<blockquote>
<div>Example:  “echo 19 &gt; unexport” will remove a “gpio19”
node exported using the “export” file.</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>GPIO signals have paths like /sys/class/gpio/gpio42/ (for GPIO #42)
and have the following read/write attributes:</p>
<blockquote>
<div><p>/sys/class/gpio/gpioN/</p>
<blockquote>
<div><dl class="docutils">
<dt>“direction” … reads as either “in” or “out”.  This value may</dt>
<dd><p class="first">normally be written.  Writing as “out” defaults to
initializing the value as low.  To ensure glitch free
operation, values “low” and “high” may be written to
configure the GPIO as an output with that initial value.</p>
<p class="last">Note that this attribute <em>will not exist</em> if the kernel
doesn’t support changing the direction of a GPIO, or
it was exported by kernel code that didn’t explicitly
allow userspace to reconfigure this GPIO’s direction.</p>
</dd>
<dt>“value” … reads as either 0 (low) or 1 (high).  If the GPIO</dt>
<dd><p class="first">is configured as an output, this value may be written;
any nonzero value is treated as high.</p>
<p class="last">If the pin can be configured as interrupt-generating interrupt
and if it has been configured to generate interrupts (see the
description of “edge”), you can poll(2) on that file and
poll(2) will return whenever the interrupt was triggered. If
you use poll(2), set the events POLLPRI and POLLERR. If you
use select(2), set the file descriptor in exceptfds. After
poll(2) returns, either lseek(2) to the beginning of the sysfs
file and read the new value or close the file and re-open it
to read the value.</p>
</dd>
<dt>“edge” … reads as either “none”, “rising”, “falling”, or</dt>
<dd><p class="first">“both”. Write these strings to select the signal edge(s)
that will make poll(2) on the “value” file return.</p>
<p class="last">This file exists only if the pin can be configured as an
interrupt generating input pin.</p>
</dd>
<dt>“active_low” … reads as either 0 (false) or 1 (true).  Write</dt>
<dd>any nonzero value to invert the value attribute both
for reading and writing.  Existing and subsequent
poll(2) support configuration via the edge attribute
for “rising” and “falling” edges will follow this
setting.</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>GPIO controllers have paths like /sys/class/gpio/gpiochip42/ (for the
controller implementing GPIOs starting at #42) and have the following
read-only attributes:</p>
<blockquote>
<div><p>/sys/class/gpio/gpiochipN/</p>
<blockquote>
<div><p>“base” … same as N, the first GPIO managed by this chip</p>
<p>“label” … provided for diagnostics (not always unique)</p>
<p>“ngpio” … how many GPIOs this manges (N to N + ngpio - 1)</p>
</div></blockquote>
</div></blockquote>
<p>Board documentation should in most cases cover what GPIOs are used for
what purposes.  However, those numbers are not always stable; GPIOs on
a daughtercard might be different depending on the base board being used,
or other cards in the stack.  In such cases, you may need to use the
gpiochip nodes (possibly in conjunction with schematics) to determine
the correct GPIO number to use for a given signal.</p>
</div>
<div class="section" id="exporting-from-kernel-code">
<h3>Exporting from Kernel code<a class="headerlink" href="#exporting-from-kernel-code" title="Permalink to this headline">¶</a></h3>
<p>Kernel code can explicitly manage exports of GPIOs which have already been
requested using gpio_request():</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* export the GPIO to userspace */
int gpio_export(unsigned gpio, bool direction_may_change);

/* reverse gpio_export() */
void gpio_unexport();

/* create a sysfs link to an exported GPIO node */
int gpio_export_link(struct device *dev, const char *name,
        unsigned gpio)
</pre></div>
</div>
<p>After a kernel driver requests a GPIO, it may only be made available in
the sysfs interface by gpio_export().  The driver can control whether the
signal direction may change.  This helps drivers prevent userspace code
from accidentally clobbering important system state.</p>
<p>This explicit exporting can help with debugging (by making some kinds
of experiments easier), or can provide an always-there interface that’s
suitable for documenting as part of a board support package.</p>
<p>After the GPIO has been exported, gpio_export_link() allows creating
symlinks from elsewhere in sysfs to the GPIO sysfs node.  Drivers can
use this to provide the interface under their own device in sysfs with
a descriptive name.</p>
</div>
</div>
<div class="section" id="api-reference">
<h2>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<p>The functions listed in this section are deprecated. The GPIO descriptor based
API should be used in new code.</p>
<dl class="function">
<dt id="c.gpio_request_one">
int <code class="descname">gpio_request_one</code><span class="sig-paren">(</span>unsigned<em>&nbsp;gpio</em>, unsigned long<em>&nbsp;flags</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_request_one" title="Permalink to this definition">¶</a></dt>
<dd><p>request a single GPIO with initial configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt>
<dd>the GPIO number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>GPIO configuration as specified by GPIOF_*</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>a literal description string of this GPIO</dd>
</dl>
<dl class="function">
<dt id="c.gpio_request_array">
int <code class="descname">gpio_request_array</code><span class="sig-paren">(</span>const struct gpio *<em>&nbsp;array</em>, size_t<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_request_array" title="Permalink to this definition">¶</a></dt>
<dd><p>request multiple GPIOs in a single call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>array of the ‘struct gpio’</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">num</span></code></dt>
<dd>how many GPIOs in the array</dd>
</dl>
<dl class="function">
<dt id="c.gpio_free_array">
void <code class="descname">gpio_free_array</code><span class="sig-paren">(</span>const struct gpio *<em>&nbsp;array</em>, size_t<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_free_array" title="Permalink to this definition">¶</a></dt>
<dd><p>release multiple GPIOs in a single call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>array of the ‘struct gpio’</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">num</span></code></dt>
<dd>how many GPIOs in the array</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../misc_devices.html" class="btn btn-neutral float-right" title="Miscellaneous Devices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drivers-on-gpio.html" class="btn btn-neutral" title="Subsystem drivers using GPIO" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>