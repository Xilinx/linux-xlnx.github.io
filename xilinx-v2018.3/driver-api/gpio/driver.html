

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>GPIO Descriptor Driver Interface &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="GPIO Descriptor Consumer Interface" href="consumer.html" />
    <link rel="prev" title="Introduction" href="intro.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">General Purpose Input/Output (GPIO)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">GPIO Descriptor Driver Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#internal-representation-of-gpios">Internal Representation of GPIOs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#controller-drivers-gpio-chip">Controller Drivers: gpio_chip</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="consumer.html">GPIO Descriptor Consumer Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="board.html">GPIO Mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="legacy.html">Legacy GPIO Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#core">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#acpi-support">ACPI support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#device-tree-support">Device tree support</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#device-managed-api">Device-managed API</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#sysfs-helpers">sysfs helpers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">General Purpose Input/Output (GPIO)</a> &raquo;</li>
        
      <li>GPIO Descriptor Driver Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/gpio/driver.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="gpio-descriptor-driver-interface">
<h1>GPIO Descriptor Driver Interface<a class="headerlink" href="#gpio-descriptor-driver-interface" title="Permalink to this headline">¶</a></h1>
<p>This document serves as a guide for GPIO chip drivers writers. Note that it
describes the new descriptor-based interface. For a description of the
deprecated integer-based GPIO interface please refer to gpio-legacy.txt.</p>
<p>Each GPIO controller driver needs to include the following header, which defines
the structures used to define a GPIO driver:</p>
<blockquote>
<div>#include &lt;linux/gpio/driver.h&gt;</div></blockquote>
<div class="section" id="internal-representation-of-gpios">
<h2>Internal Representation of GPIOs<a class="headerlink" href="#internal-representation-of-gpios" title="Permalink to this headline">¶</a></h2>
<p>Inside a GPIO driver, individual GPIOs are identified by their hardware number,
which is a unique number between 0 and n, n being the number of GPIOs managed by
the chip. This number is purely internal: the hardware number of a particular
GPIO descriptor is never made visible outside of the driver.</p>
<p>On top of this internal number, each GPIO also need to have a global number in
the integer GPIO namespace so that it can be used with the legacy GPIO
interface. Each chip must thus have a “base” number (which can be automatically
assigned), and for each GPIO the global number will be (base + hardware number).
Although the integer representation is considered deprecated, it still has many
users and thus needs to be maintained.</p>
<p>So for example one platform could use numbers 32-159 for GPIOs, with a
controller defining 128 GPIOs at a “base” of 32 ; while another platform uses
numbers 0..63 with one set of GPIO controllers, 64-79 with another type of GPIO
controller, and on one particular board 80-95 with an FPGA. The numbers need not
be contiguous; either of those platforms could also use numbers 2000-2063 to
identify GPIOs in a bank of I2C GPIO expanders.</p>
</div>
<div class="section" id="controller-drivers-gpio-chip">
<h2>Controller Drivers: gpio_chip<a class="headerlink" href="#controller-drivers-gpio-chip" title="Permalink to this headline">¶</a></h2>
<p>In the gpiolib framework each GPIO controller is packaged as a “struct
gpio_chip” (see linux/gpio/driver.h for its complete definition) with members
common to each controller of that type:</p>
<blockquote>
<div><ul class="simple">
<li>methods to establish GPIO line direction</li>
<li>methods used to access GPIO line values</li>
<li>method to set electrical configuration for a given GPIO line</li>
<li>method to return the IRQ number associated to a given GPIO line</li>
<li>flag saying whether calls to its methods may sleep</li>
<li>optional line names array to identify lines</li>
<li>optional debugfs dump method (showing extra state like pullup config)</li>
<li>optional base number (will be automatically assigned if omitted)</li>
<li>optional label for diagnostics and GPIO chip mapping using platform data</li>
</ul>
</div></blockquote>
<p>The code implementing a gpio_chip should support multiple instances of the
controller, possibly using the driver model. That code will configure each
gpio_chip and issue <code class="docutils literal"><span class="pre">gpiochip_add[_data]()</span></code> or <code class="docutils literal"><span class="pre">devm_gpiochip_add_data()</span></code>.
Removing a GPIO controller should be rare; use <code class="docutils literal"><span class="pre">[devm_]gpiochip_remove()</span></code>
when it is unavoidable.</p>
<p>Often a gpio_chip is part of an instance-specific structure with states not
exposed by the GPIO interfaces, such as addressing, power management, and more.
Chips such as audio codecs will have complex non-GPIO states.</p>
<p>Any debugfs dump method should normally ignore signals which haven’t been
requested as GPIOs. They can use gpiochip_is_requested(), which returns either
NULL or the label associated with that GPIO when it was requested.</p>
<p>RT_FULL: the GPIO driver should not use spinlock_t or any sleepable APIs
(like PM runtime) in its gpio_chip implementation (.get/.set and direction
control callbacks) if it is expected to call GPIO APIs from atomic context
on -RT (inside hard IRQ handlers and similar contexts). Normally this should
not be required.</p>
<div class="section" id="gpio-electrical-configuration">
<h3>GPIO electrical configuration<a class="headerlink" href="#gpio-electrical-configuration" title="Permalink to this headline">¶</a></h3>
<p>GPIOs can be configured for several electrical modes of operation by using the
.set_config() callback. Currently this API supports setting debouncing and
single-ended modes (open drain/open source). These settings are described
below.</p>
<p>The .set_config() callback uses the same enumerators and configuration
semantics as the generic pin control drivers. This is not a coincidence: it is
possible to assign the .set_config() to the function gpiochip_generic_config()
which will result in pinctrl_gpio_set_config() being called and eventually
ending up in the pin control back-end “behind” the GPIO controller, usually
closer to the actual pins. This way the pin controller can manage the below
listed GPIO configurations.</p>
<p>If a pin controller back-end is used, the GPIO controller or hardware
description needs to provide “GPIO ranges” mapping the GPIO line offsets to pin
numbers on the pin controller so they can properly cross-reference each other.</p>
</div>
<div class="section" id="gpios-with-debounce-support">
<h3>GPIOs with debounce support<a class="headerlink" href="#gpios-with-debounce-support" title="Permalink to this headline">¶</a></h3>
<p>Debouncing is a configuration set to a pin indicating that it is connected to
a mechanical switch or button, or similar that may bounce. Bouncing means the
line is pulled high/low quickly at very short intervals for mechanical
reasons. This can result in the value being unstable or irqs fireing repeatedly
unless the line is debounced.</p>
<p>Debouncing in practice involves setting up a timer when something happens on
the line, wait a little while and then sample the line again, so see if it
still has the same value (low or high). This could also be repeated by a clever
state machine, waiting for a line to become stable. In either case, it sets
a certain number of milliseconds for debouncing, or just “on/off” if that time
is not configurable.</p>
</div>
<div class="section" id="gpios-with-open-drain-source-support">
<h3>GPIOs with open drain/source support<a class="headerlink" href="#gpios-with-open-drain-source-support" title="Permalink to this headline">¶</a></h3>
<p>Open drain (CMOS) or open collector (TTL) means the line is not actively driven
high: instead you provide the drain/collector as output, so when the transistor
is not open, it will present a high-impedance (tristate) to the external rail:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>CMOS CONFIGURATION      TTL CONFIGURATION

         ||--- out              +--- out
  in ----||                   |/
         ||--+         in ----|
             |                |\
            GND                 GND
</pre></div>
</div>
<p>This configuration is normally used as a way to achieve one of two things:</p>
<ul class="simple">
<li>Level-shifting: to reach a logical level higher than that of the silicon
where the output resides.</li>
<li>inverse wire-OR on an I/O line, for example a GPIO line, making it possible
for any driving stage on the line to drive it low even if any other output
to the same line is simultaneously driving it high. A special case of this
is driving the SCL and SCA lines of an I2C bus, which is by definition a
wire-OR bus.</li>
</ul>
<p>Both usecases require that the line be equipped with a pull-up resistor. This
resistor will make the line tend to high level unless one of the transistors on
the rail actively pulls it down.</p>
<p>The level on the line will go as high as the VDD on the pull-up resistor, which
may be higher than the level supported by the transistor, achieving a
level-shift to the higher VDD.</p>
<p>Integrated electronics often have an output driver stage in the form of a CMOS
“totem-pole” with one N-MOS and one P-MOS transistor where one of them drives
the line high and one of them drives the line low. This is called a push-pull
output. The “totem-pole” looks like so:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>                 VDD
                  |
        OD    ||--+
     +--/ ---o||     P-MOS-FET
     |        ||--+
IN --+            +----- out
     |        ||--+
     +--/ ----||     N-MOS-FET
        OS    ||--+
                  |
                 GND
</pre></div>
</div>
<p>The desired output signal (e.g. coming directly from some GPIO output register)
arrives at IN. The switches named “OD” and “OS” are normally closed, creating
a push-pull circuit.</p>
<p>Consider the little “switches” named “OD” and “OS” that enable/disable the
P-MOS or N-MOS transistor right after the split of the input. As you can see,
either transistor will go totally numb if this switch is open. The totem-pole
is then halved and give high impedance instead of actively driving the line
high or low respectively. That is usually how software-controlled open
drain/source works.</p>
<p>Some GPIO hardware come in open drain / open source configuration. Some are
hard-wired lines that will only support open drain or open source no matter
what: there is only one transistor there. Some are software-configurable:
by flipping a bit in a register the output can be configured as open drain
or open source, in practice by flicking open the switches labeled “OD” and “OS”
in the drawing above.</p>
<p>By disabling the P-MOS transistor, the output can be driven between GND and
high impedance (open drain), and by disabling the N-MOS transistor, the output
can be driven between VDD and high impedance (open source). In the first case,
a pull-up resistor is needed on the outgoing rail to complete the circuit, and
in the second case, a pull-down resistor is needed on the rail.</p>
<p>Hardware that supports open drain or open source or both, can implement a
special callback in the gpio_chip: .set_config() that takes a generic
pinconf packed value telling whether to configure the line as open drain,
open source or push-pull. This will happen in response to the
GPIO_OPEN_DRAIN or GPIO_OPEN_SOURCE flag set in the machine file, or coming
from other hardware descriptions.</p>
<p>If this state can not be configured in hardware, i.e. if the GPIO hardware does
not support open drain/open source in hardware, the GPIO library will instead
use a trick: when a line is set as output, if the line is flagged as open
drain, and the IN output value is low, it will be driven low as usual. But
if the IN output value is set to high, it will instead <em>NOT</em> be driven high,
instead it will be switched to input, as input mode is high impedance, thus
achieveing an “open drain emulation” of sorts: electrically the behaviour will
be identical, with the exception of possible hardware glitches when switching
the mode of the line.</p>
<p>For open source configuration the same principle is used, just that instead
of actively driving the line low, it is set to input.</p>
</div>
<div class="section" id="gpio-drivers-providing-irqs">
<h3>GPIO drivers providing IRQs<a class="headerlink" href="#gpio-drivers-providing-irqs" title="Permalink to this headline">¶</a></h3>
<p>It is custom that GPIO drivers (GPIO chips) are also providing interrupts,
most often cascaded off a parent interrupt controller, and in some special
cases the GPIO logic is melded with a SoC’s primary interrupt controller.</p>
<p>The IRQ portions of the GPIO block are implemented using an irqchip, using
the header &lt;linux/irq.h&gt;. So basically such a driver is utilizing two sub-
systems simultaneously: gpio and irq.</p>
<p>RT_FULL: a realtime compliant GPIO driver should not use spinlock_t or any
sleepable APIs (like PM runtime) as part of its irq_chip implementation.</p>
<ul class="simple">
<li>spinlock_t should be replaced with raw_spinlock_t [1].</li>
<li>If sleepable APIs have to be used, these can be done from the .irq_bus_lock()
and .irq_bus_unlock() callbacks, as these are the only slowpath callbacks
on an irqchip. Create the callbacks if needed [2].</li>
</ul>
<p>GPIO irqchips usually fall in one of two categories:</p>
<ul>
<li><p class="first">CHAINED GPIO irqchips: these are usually the type that is embedded on
an SoC. This means that there is a fast IRQ flow handler for the GPIOs that
gets called in a chain from the parent IRQ handler, most typically the
system interrupt controller. This means that the GPIO irqchip handler will
be called immediately from the parent irqchip, while holding the IRQs
disabled. The GPIO irqchip will then end up calling something like this
sequence in its interrupt handler:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static irqreturn_t foo_gpio_irq(int irq, void *data)
    chained_irq_enter(...);
    generic_handle_irq(...);
    chained_irq_exit(...);
</pre></div>
</div>
<p>Chained GPIO irqchips typically can NOT set the .can_sleep flag on
struct gpio_chip, as everything happens directly in the callbacks: no
slow bus traffic like I2C can be used.</p>
<p>RT_FULL: Note, chained IRQ handlers will not be forced threaded on -RT.
As result, spinlock_t or any sleepable APIs (like PM runtime) can’t be used
in chained IRQ handler.
If required (and if it can’t be converted to the nested threaded GPIO irqchip)
a chained IRQ handler can be converted to generic irq handler and this way
it will be a threaded IRQ handler on -RT and a hard IRQ handler on non-RT
(for example, see [3]).
Know W/A: The generic_handle_irq() is expected to be called with IRQ disabled,
so the IRQ core will complain if it is called from an IRQ handler which is
forced to a thread. The “fake?” raw lock can be used to W/A this problem:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>raw_spinlock_t wa_lock;
static irqreturn_t omap_gpio_irq_handler(int irq, void *gpiobank)
        unsigned long wa_lock_flags;
        raw_spin_lock_irqsave(&amp;bank-&gt;wa_lock, wa_lock_flags);
        generic_handle_irq(irq_find_mapping(bank-&gt;chip.irq.domain, bit));
        raw_spin_unlock_irqrestore(&amp;bank-&gt;wa_lock, wa_lock_flags);
</pre></div>
</div>
</li>
<li><p class="first">GENERIC CHAINED GPIO irqchips: these are the same as “CHAINED GPIO irqchips”,
but chained IRQ handlers are not used. Instead GPIO IRQs dispatching is
performed by generic IRQ handler which is configured using request_irq().
The GPIO irqchip will then end up calling something like this sequence in
its interrupt handler:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static irqreturn_t gpio_rcar_irq_handler(int irq, void *dev_id)
    for each detected GPIO IRQ
        generic_handle_irq(...);
</pre></div>
</div>
<p>RT_FULL: Such kind of handlers will be forced threaded on -RT, as result IRQ
core will complain that generic_handle_irq() is called with IRQ enabled and
the same W/A as for “CHAINED GPIO irqchips” can be applied.</p>
</li>
<li><p class="first">NESTED THREADED GPIO irqchips: these are off-chip GPIO expanders and any
other GPIO irqchip residing on the other side of a sleeping bus. Of course
such drivers that need slow bus traffic to read out IRQ status and similar,
traffic which may in turn incur other IRQs to happen, cannot be handled
in a quick IRQ handler with IRQs disabled. Instead they need to spawn a
thread and then mask the parent IRQ line until the interrupt is handled
by the driver. The hallmark of this driver is to call something like
this in its interrupt handler:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static irqreturn_t foo_gpio_irq(int irq, void *data)
    ...
    handle_nested_irq(irq);
</pre></div>
</div>
<p>The hallmark of threaded GPIO irqchips is that they set the .can_sleep
flag on struct gpio_chip to true, indicating that this chip may sleep
when accessing the GPIOs.</p>
</li>
</ul>
<p>To help out in handling the set-up and management of GPIO irqchips and the
associated irqdomain and resource allocation callbacks, the gpiolib has
some helpers that can be enabled by selecting the GPIOLIB_IRQCHIP Kconfig
symbol:</p>
<ul class="simple">
<li>gpiochip_irqchip_add(): adds a chained irqchip to a gpiochip. It will pass
the struct gpio_chip* for the chip to all IRQ callbacks, so the callbacks
need to embed the gpio_chip in its state container and obtain a pointer
to the container using container_of().
(See Documentation/driver-model/design-patterns.txt)</li>
<li>gpiochip_irqchip_add_nested(): adds a nested irqchip to a gpiochip.
Apart from that it works exactly like the chained irqchip.</li>
<li>gpiochip_set_chained_irqchip(): sets up a chained irq handler for a
gpio_chip from a parent IRQ and passes the struct gpio_chip* as handler
data. (Notice handler data, since the irqchip data is likely used by the
parent irqchip!).</li>
<li>gpiochip_set_nested_irqchip(): sets up a nested irq handler for a
gpio_chip from a parent IRQ. As the parent IRQ has usually been
explicitly requested by the driver, this does very little more than
mark all the child IRQs as having the other IRQ as parent.</li>
</ul>
<p>If there is a need to exclude certain GPIOs from the IRQ domain, you can
set .irq.need_valid_mask of the gpiochip before gpiochip_add_data() is
called. This allocates an .irq.valid_mask with as many bits set as there
are GPIOs in the chip. Drivers can exclude GPIOs by clearing bits from this
mask. The mask must be filled in before gpiochip_irqchip_add() or
gpiochip_irqchip_add_nested() is called.</p>
<p>To use the helpers please keep the following in mind:</p>
<ul class="simple">
<li>Make sure to assign all relevant members of the struct gpio_chip so that
the irqchip can initialize. E.g. .dev and .can_sleep shall be set up
properly.</li>
<li>Nominally set all handlers to handle_bad_irq() in the setup call and pass
handle_bad_irq() as flow handler parameter in gpiochip_irqchip_add() if it is
expected for GPIO driver that irqchip .set_type() callback have to be called
before using/enabling GPIO IRQ. Then set the handler to handle_level_irq()
and/or handle_edge_irq() in the irqchip .set_type() callback depending on
what your controller supports.</li>
</ul>
<p>It is legal for any IRQ consumer to request an IRQ from any irqchip no matter
if that is a combined GPIO+IRQ driver. The basic premise is that gpio_chip and
irq_chip are orthogonal, and offering their services independent of each
other.</p>
<p>gpiod_to_irq() is just a convenience function to figure out the IRQ for a
certain GPIO line and should not be relied upon to have been called before
the IRQ is used.</p>
<p>So always prepare the hardware and make it ready for action in respective
callbacks from the GPIO and irqchip APIs. Do not rely on gpiod_to_irq() having
been called first.</p>
<p>This orthogonality leads to ambiguities that we need to solve: if there is
competition inside the subsystem which side is using the resource (a certain
GPIO line and register for example) it needs to deny certain operations and
keep track of usage inside of the gpiolib subsystem. This is why the API
below exists.</p>
</div>
<div class="section" id="locking-irq-usage">
<h3>Locking IRQ usage<a class="headerlink" href="#locking-irq-usage" title="Permalink to this headline">¶</a></h3>
<p>Input GPIOs can be used as IRQ signals. When this happens, a driver is requested
to mark the GPIO as being used as an IRQ:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int gpiochip_lock_as_irq(struct gpio_chip *chip, unsigned int offset)
</pre></div>
</div>
<p>This will prevent the use of non-irq related GPIO APIs until the GPIO IRQ lock
is released:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void gpiochip_unlock_as_irq(struct gpio_chip *chip, unsigned int offset)
</pre></div>
</div>
<p>When implementing an irqchip inside a GPIO driver, these two functions should
typically be called in the .startup() and .shutdown() callbacks from the
irqchip.</p>
<p>When using the gpiolib irqchip helpers, these callback are automatically
assigned.</p>
</div>
<div class="section" id="real-time-compliance-for-gpio-irq-chips">
<h3>Real-Time compliance for GPIO IRQ chips<a class="headerlink" href="#real-time-compliance-for-gpio-irq-chips" title="Permalink to this headline">¶</a></h3>
<p>Any provider of irqchips needs to be carefully tailored to support Real Time
preemption. It is desirable that all irqchips in the GPIO subsystem keep this
in mind and do the proper testing to assure they are real time-enabled.
So, pay attention on above ” RT_FULL:” notes, please.
The following is a checklist to follow when preparing a driver for real
time-compliance:</p>
<ul class="simple">
<li>ensure spinlock_t is not used as part irq_chip implementation;</li>
<li>ensure that sleepable APIs are not used as part irq_chip implementation.
If sleepable APIs have to be used, these can be done from the .irq_bus_lock()
and .irq_bus_unlock() callbacks;</li>
<li>Chained GPIO irqchips: ensure spinlock_t or any sleepable APIs are not used
from chained IRQ handler;</li>
<li>Generic chained GPIO irqchips: take care about generic_handle_irq() calls and
apply corresponding W/A;</li>
<li>Chained GPIO irqchips: get rid of chained IRQ handler and use generic irq
handler if possible :)</li>
<li>regmap_mmio: Sry, but you are in trouble :( if MMIO regmap is used as for
GPIO IRQ chip implementation;</li>
<li>Test your driver with the appropriate in-kernel real time test cases for both
level and edge IRQs.</li>
</ul>
</div>
<div class="section" id="requesting-self-owned-gpio-pins">
<h3>Requesting self-owned GPIO pins<a class="headerlink" href="#requesting-self-owned-gpio-pins" title="Permalink to this headline">¶</a></h3>
<p>Sometimes it is useful to allow a GPIO chip driver to request its own GPIO
descriptors through the gpiolib API. Using gpio_request() for this purpose
does not help since it pins the module to the kernel forever (it calls
try_module_get()). A GPIO driver can use the following functions instead
to request and free descriptors without being pinned to the kernel forever:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct gpio_desc *gpiochip_request_own_desc(struct gpio_desc *desc,
                                            const char *label)

void gpiochip_free_own_desc(struct gpio_desc *desc)
</pre></div>
</div>
<p>Descriptors requested with gpiochip_request_own_desc() must be released with
gpiochip_free_own_desc().</p>
<p>These functions must be used with care since they do not affect module use
count. Do not use the functions to request gpio descriptors not owned by the
calling driver.</p>
<ul class="simple">
<li>[1] <a class="reference external" href="http://www.spinics.net/lists/linux-omap/msg120425.html">http://www.spinics.net/lists/linux-omap/msg120425.html</a></li>
<li>[2] <a class="reference external" href="https://lkml.org/lkml/2015/9/25/494">https://lkml.org/lkml/2015/9/25/494</a></li>
<li>[3] <a class="reference external" href="https://lkml.org/lkml/2015/9/25/495">https://lkml.org/lkml/2015/9/25/495</a></li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="consumer.html" class="btn btn-neutral float-right" title="GPIO Descriptor Consumer Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="intro.html" class="btn btn-neutral" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>