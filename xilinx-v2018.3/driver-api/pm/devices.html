

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Device Power Management Basics &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Suspend/Hibernation Notifiers" href="notifiers.html" />
    <link rel="prev" title="Device Power Management" href="index.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer’s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Device Power Management</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Device Power Management Basics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#two-models-for-device-power-management">Two Models for Device Power Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interfaces-for-entering-system-sleep-states">Interfaces for Entering System Sleep States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calling-drivers-to-enter-and-leave-system-sleep-states">Calling Drivers to Enter and Leave System Sleep States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#power-management-notifiers">Power Management Notifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-low-power-suspend-states">Device Low-Power (suspend) States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-power-management-domains">Device Power Management Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-power-management">Runtime Power Management</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="notifiers.html">Suspend/Hibernation Notifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="types.html">Device Power Management Data Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas’ 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer’s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">The Linux driver implementer’s API guide</a> &raquo;</li>
        
          <li><a href="index.html">Device Power Management</a> &raquo;</li>
        
      <li>Device Power Management Basics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/driver-api/pm/devices.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="device-power-management-basics">
<h1>Device Power Management Basics<a class="headerlink" href="#device-power-management-basics" title="Permalink to this headline">¶</a></h1>
<div class="highlight-none"><div class="highlight"><pre><span></span>Copyright (c) 2010-2011 Rafael J. Wysocki &lt;rjw@sisk.pl&gt;, Novell Inc.
Copyright (c) 2010 Alan Stern &lt;stern@rowland.harvard.edu&gt;
Copyright (c) 2016 Intel Corp., Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;
</pre></div>
</div>
<p>Most of the code in Linux is device drivers, so most of the Linux power
management (PM) code is also driver-specific.  Most drivers will do very
little; others, especially for platforms with small batteries (like cell
phones), will do a lot.</p>
<p>This writeup gives an overview of how drivers interact with system-wide
power management goals, emphasizing the models and interfaces that are
shared by everything that hooks up to the driver model core.  Read it as
background for the domain-specific work you’d do with any specific driver.</p>
<div class="section" id="two-models-for-device-power-management">
<h2>Two Models for Device Power Management<a class="headerlink" href="#two-models-for-device-power-management" title="Permalink to this headline">¶</a></h2>
<p>Drivers will use one or both of these models to put devices into low-power
states:</p>
<blockquote>
<div><p>System Sleep model:</p>
<blockquote>
<div><p>Drivers can enter low-power states as part of entering system-wide
low-power states like “suspend” (also known as “suspend-to-RAM”), or
(mostly for systems with disks) “hibernation” (also known as
“suspend-to-disk”).</p>
<p>This is something that device, bus, and class drivers collaborate on
by implementing various role-specific suspend and resume methods to
cleanly power down hardware and software subsystems, then reactivate
them without loss of data.</p>
<p>Some drivers can manage hardware wakeup events, which make the system
leave the low-power state.  This feature may be enabled or disabled
using the relevant <code class="file docutils literal"><span class="pre">/sys/devices/.../power/wakeup</span></code> file (for
Ethernet drivers the ioctl interface used by ethtool may also be used
for this purpose); enabling it may cost some power usage, but let the
whole system enter low-power states more often.</p>
</div></blockquote>
<p>Runtime Power Management model:</p>
<blockquote>
<div><p>Devices may also be put into low-power states while the system is
running, independently of other power management activity in principle.
However, devices are not generally independent of each other (for
example, a parent device cannot be suspended unless all of its child
devices have been suspended).  Moreover, depending on the bus type the
device is on, it may be necessary to carry out some bus-specific
operations on the device for this purpose.  Devices put into low power
states at run time may require special handling during system-wide power
transitions (suspend or hibernation).</p>
<p>For these reasons not only the device driver itself, but also the
appropriate subsystem (bus type, device type or device class) driver and
the PM core are involved in runtime power management.  As in the system
sleep power management case, they need to collaborate by implementing
various role-specific suspend and resume methods, so that the hardware
is cleanly powered down and reactivated without data or service loss.</p>
</div></blockquote>
</div></blockquote>
<p>There’s not a lot to be said about those low-power states except that they are
very system-specific, and often device-specific.  Also, that if enough devices
have been put into low-power states (at runtime), the effect may be very similar
to entering some system-wide low-power state (system sleep) … and that
synergies exist, so that several drivers using runtime PM might put the system
into a state where even deeper power saving options are available.</p>
<p>Most suspended devices will have quiesced all I/O: no more DMA or IRQs (except
for wakeup events), no more data read or written, and requests from upstream
drivers are no longer accepted.  A given bus or platform may have different
requirements though.</p>
<p>Examples of hardware wakeup events include an alarm from a real time clock,
network wake-on-LAN packets, keyboard or mouse activity, and media insertion
or removal (for PCMCIA, MMC/SD, USB, and so on).</p>
</div>
<div class="section" id="interfaces-for-entering-system-sleep-states">
<h2>Interfaces for Entering System Sleep States<a class="headerlink" href="#interfaces-for-entering-system-sleep-states" title="Permalink to this headline">¶</a></h2>
<p>There are programming interfaces provided for subsystems (bus type, device type,
device class) and device drivers to allow them to participate in the power
management of devices they are concerned with.  These interfaces cover both
system sleep and runtime power management.</p>
<div class="section" id="device-power-management-operations">
<h3>Device Power Management Operations<a class="headerlink" href="#device-power-management-operations" title="Permalink to this headline">¶</a></h3>
<p>Device power management operations, at the subsystem level as well as at the
device driver level, are implemented by defining and populating objects of type
<a class="reference internal" href="types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a> defined in <code class="file docutils literal"><span class="pre">include/linux/pm.h</span></code>.  The roles of the
methods included in it will be explained in what follows.  For now, it should be
sufficient to remember that the last three methods are specific to runtime power
management while the remaining ones are used during system-wide power
transitions.</p>
<p>There also is a deprecated “old” or “legacy” interface for power management
operations available at least for some subsystems.  This approach does not use
<a class="reference internal" href="types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a> objects and it is suitable only for implementing system
sleep power management methods in a limited way.  Therefore it is not described
in this document, so please refer directly to the source code for more
information about it.</p>
</div>
<div class="section" id="subsystem-level-methods">
<h3>Subsystem-Level Methods<a class="headerlink" href="#subsystem-level-methods" title="Permalink to this headline">¶</a></h3>
<p>The core methods to suspend and resume devices reside in
<a class="reference internal" href="types.html#c.dev_pm_ops" title="dev_pm_ops"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_ops</span></code></a> pointed to by the <code class="xref c c-member docutils literal"><span class="pre">ops</span></code> member of
<a class="reference internal" href="types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a>, or by the <code class="xref c c-member docutils literal"><span class="pre">pm</span></code> member of <a class="reference internal" href="../infrastructure.html#c.bus_type" title="bus_type"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code></a>,
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_type</span></code> and <a class="reference internal" href="../infrastructure.html#c.class" title="class"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">class</span></code></a>.  They are mostly of interest to the
people writing infrastructure for platforms and buses, like PCI or USB, or
device type and device class drivers.  They also are relevant to the writers of
device drivers whose subsystems (PM domains, device types, device classes and
bus types) don’t provide all power management methods.</p>
<p>Bus drivers implement these methods as appropriate for the hardware and the
drivers using it; PCI works differently from USB, and so on.  Not many people
write subsystem-level drivers; most driver code is a “device driver” that builds
on top of bus-specific framework code.</p>
<p>For more information on these driver calls, see the description later;
they are called in phases for every device, respecting the parent-child
sequencing in the driver model tree.</p>
</div>
<div class="section" id="sys-devices-power-wakeup-files">
<h3><code class="file docutils literal"><span class="pre">/sys/devices/.../power/wakeup</span></code> files<a class="headerlink" href="#sys-devices-power-wakeup-files" title="Permalink to this headline">¶</a></h3>
<p>All device objects in the driver model contain fields that control the handling
of system wakeup events (hardware signals that can force the system out of a
sleep state).  These fields are initialized by bus or device driver code using
<code class="xref c c-func docutils literal"><span class="pre">device_set_wakeup_capable()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">device_set_wakeup_enable()</span></code>,
defined in <code class="file docutils literal"><span class="pre">include/linux/pm_wakeup.h</span></code>.</p>
<p>The <code class="xref c c-member docutils literal"><span class="pre">power.can_wakeup</span></code> flag just records whether the device (and its
driver) can physically support wakeup events.  The
<code class="xref c c-func docutils literal"><span class="pre">device_set_wakeup_capable()</span></code> routine affects this flag.  The
<code class="xref c c-member docutils literal"><span class="pre">power.wakeup</span></code> field is a pointer to an object of type
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">wakeup_source</span></code> used for controlling whether or not the device should use
its system wakeup mechanism and for notifying the PM core of system wakeup
events signaled by the device.  This object is only present for wakeup-capable
devices (i.e. devices whose <code class="xref c c-member docutils literal"><span class="pre">can_wakeup</span></code> flags are set) and is created
(or removed) by <code class="xref c c-func docutils literal"><span class="pre">device_set_wakeup_capable()</span></code>.</p>
<p>Whether or not a device is capable of issuing wakeup events is a hardware
matter, and the kernel is responsible for keeping track of it.  By contrast,
whether or not a wakeup-capable device should issue wakeup events is a policy
decision, and it is managed by user space through a sysfs attribute: the
<code class="file docutils literal"><span class="pre">power/wakeup</span></code> file.  User space can write the “enabled” or “disabled”
strings to it to indicate whether or not, respectively, the device is supposed
to signal system wakeup.  This file is only present if the
<code class="xref c c-member docutils literal"><span class="pre">power.wakeup</span></code> object exists for the given device and is created (or
removed) along with that object, by <code class="xref c c-func docutils literal"><span class="pre">device_set_wakeup_capable()</span></code>.
Reads from the file will return the corresponding string.</p>
<p>The initial value in the <code class="file docutils literal"><span class="pre">power/wakeup</span></code> file is “disabled” for the
majority of devices; the major exceptions are power buttons, keyboards, and
Ethernet adapters whose WoL (wake-on-LAN) feature has been set up with ethtool.
It should also default to “enabled” for devices that don’t generate wakeup
requests on their own but merely forward wakeup requests from one bus to another
(like PCI Express ports).</p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">device_may_wakeup()</span></code> routine returns true only if the
<code class="xref c c-member docutils literal"><span class="pre">power.wakeup</span></code> object exists and the corresponding <code class="file docutils literal"><span class="pre">power/wakeup</span></code>
file contains the “enabled” string.  This information is used by subsystems,
like the PCI bus type code, to see whether or not to enable the devices’ wakeup
mechanisms.  If device wakeup mechanisms are enabled or disabled directly by
drivers, they also should use <code class="xref c c-func docutils literal"><span class="pre">device_may_wakeup()</span></code> to decide what to do
during a system sleep transition.  Device drivers, however, are not expected to
call <code class="xref c c-func docutils literal"><span class="pre">device_set_wakeup_enable()</span></code> directly in any case.</p>
<p>It ought to be noted that system wakeup is conceptually different from “remote
wakeup” used by runtime power management, although it may be supported by the
same physical mechanism.  Remote wakeup is a feature allowing devices in
low-power states to trigger specific interrupts to signal conditions in which
they should be put into the full-power state.  Those interrupts may or may not
be used to signal system wakeup events, depending on the hardware design.  On
some systems it is impossible to trigger them from system sleep states.  In any
case, remote wakeup should always be enabled for runtime power management for
all devices and drivers that support it.</p>
</div>
<div class="section" id="sys-devices-power-control-files">
<h3><code class="file docutils literal"><span class="pre">/sys/devices/.../power/control</span></code> files<a class="headerlink" href="#sys-devices-power-control-files" title="Permalink to this headline">¶</a></h3>
<p>Each device in the driver model has a flag to control whether it is subject to
runtime power management.  This flag, <code class="xref c c-member docutils literal"><span class="pre">runtime_auto</span></code>, is initialized
by the bus type (or generally subsystem) code using <code class="xref c c-func docutils literal"><span class="pre">pm_runtime_allow()</span></code>
or <code class="xref c c-func docutils literal"><span class="pre">pm_runtime_forbid()</span></code>; the default is to allow runtime power
management.</p>
<p>The setting can be adjusted by user space by writing either “on” or “auto” to
the device’s <code class="file docutils literal"><span class="pre">power/control</span></code> sysfs file.  Writing “auto” calls
<code class="xref c c-func docutils literal"><span class="pre">pm_runtime_allow()</span></code>, setting the flag and allowing the device to be
runtime power-managed by its driver.  Writing “on” calls
<code class="xref c c-func docutils literal"><span class="pre">pm_runtime_forbid()</span></code>, clearing the flag, returning the device to full
power if it was in a low-power state, and preventing the
device from being runtime power-managed.  User space can check the current value
of the <code class="xref c c-member docutils literal"><span class="pre">runtime_auto</span></code> flag by reading that file.</p>
<p>The device’s <code class="xref c c-member docutils literal"><span class="pre">runtime_auto</span></code> flag has no effect on the handling of
system-wide power transitions.  In particular, the device can (and in the
majority of cases should and will) be put into a low-power state during a
system-wide transition to a sleep state even though its <code class="xref c c-member docutils literal"><span class="pre">runtime_auto</span></code>
flag is clear.</p>
<p>For more information about the runtime power management framework, refer to
<code class="file docutils literal"><span class="pre">Documentation/power/runtime_pm.txt</span></code>.</p>
</div>
</div>
<div class="section" id="calling-drivers-to-enter-and-leave-system-sleep-states">
<h2>Calling Drivers to Enter and Leave System Sleep States<a class="headerlink" href="#calling-drivers-to-enter-and-leave-system-sleep-states" title="Permalink to this headline">¶</a></h2>
<p>When the system goes into a sleep state, each device’s driver is asked to
suspend the device by putting it into a state compatible with the target
system state.  That’s usually some version of “off”, but the details are
system-specific.  Also, wakeup-enabled devices will usually stay partly
functional in order to wake the system.</p>
<p>When the system leaves that low-power state, the device’s driver is asked to
resume it by returning it to full power.  The suspend and resume operations
always go together, and both are multi-phase operations.</p>
<p>For simple drivers, suspend might quiesce the device using class code
and then turn its hardware as “off” as possible during suspend_noirq.  The
matching resume calls would then completely reinitialize the hardware
before reactivating its class I/O queues.</p>
<p>More power-aware drivers might prepare the devices for triggering system wakeup
events.</p>
<div class="section" id="call-sequence-guarantees">
<h3>Call Sequence Guarantees<a class="headerlink" href="#call-sequence-guarantees" title="Permalink to this headline">¶</a></h3>
<p>To ensure that bridges and similar links needing to talk to a device are
available when the device is suspended or resumed, the device hierarchy is
walked in a bottom-up order to suspend devices.  A top-down order is
used to resume those devices.</p>
<p>The ordering of the device hierarchy is defined by the order in which devices
get registered:  a child can never be registered, probed or resumed before
its parent; and can’t be removed or suspended after that parent.</p>
<p>The policy is that the device hierarchy should match hardware bus topology.
[Or at least the control bus, for devices which use multiple busses.]
In particular, this means that a device registration may fail if the parent of
the device is suspending (i.e. has been chosen by the PM core as the next
device to suspend) or has already suspended, as well as after all of the other
devices have been suspended.  Device drivers must be prepared to cope with such
situations.</p>
</div>
<div class="section" id="system-power-management-phases">
<h3>System Power Management Phases<a class="headerlink" href="#system-power-management-phases" title="Permalink to this headline">¶</a></h3>
<p>Suspending or resuming the system is done in several phases.  Different phases
are used for suspend-to-idle, shallow (standby), and deep (“suspend-to-RAM”)
sleep states and the hibernation state (“suspend-to-disk”).  Each phase involves
executing callbacks for every device before the next phase begins.  Not all
buses or classes support all these callbacks and not all drivers use all the
callbacks.  The various phases always run after tasks have been frozen and
before they are unfrozen.  Furthermore, the <code class="docutils literal"><span class="pre">*_noirq</span> <span class="pre">phases</span></code> run at a time
when IRQ handlers have been disabled (except for those marked with the
IRQF_NO_SUSPEND flag).</p>
<p>All phases use PM domain, bus, type, class or driver callbacks (that is, methods
defined in <code class="docutils literal"><span class="pre">dev-&gt;pm_domain-&gt;ops</span></code>, <code class="docutils literal"><span class="pre">dev-&gt;bus-&gt;pm</span></code>, <code class="docutils literal"><span class="pre">dev-&gt;type-&gt;pm</span></code>,
<code class="docutils literal"><span class="pre">dev-&gt;class-&gt;pm</span></code> or <code class="docutils literal"><span class="pre">dev-&gt;driver-&gt;pm</span></code>).  These callbacks are regarded by the
PM core as mutually exclusive.  Moreover, PM domain callbacks always take
precedence over all of the other callbacks and, for example, type callbacks take
precedence over bus, class and driver callbacks.  To be precise, the following
rules are used to determine which callback to execute in the given phase:</p>
<blockquote>
<div><ol class="arabic simple">
<li>If <code class="docutils literal"><span class="pre">dev-&gt;pm_domain</span></code> is present, the PM core will choose the callback
provided by <code class="docutils literal"><span class="pre">dev-&gt;pm_domain-&gt;ops</span></code> for execution.</li>
<li>Otherwise, if both <code class="docutils literal"><span class="pre">dev-&gt;type</span></code> and <code class="docutils literal"><span class="pre">dev-&gt;type-&gt;pm</span></code> are present, the
callback provided by <code class="docutils literal"><span class="pre">dev-&gt;type-&gt;pm</span></code> will be chosen for execution.</li>
<li>Otherwise, if both <code class="docutils literal"><span class="pre">dev-&gt;class</span></code> and <code class="docutils literal"><span class="pre">dev-&gt;class-&gt;pm</span></code> are present,
the callback provided by <code class="docutils literal"><span class="pre">dev-&gt;class-&gt;pm</span></code> will be chosen for
execution.</li>
<li>Otherwise, if both <code class="docutils literal"><span class="pre">dev-&gt;bus</span></code> and <code class="docutils literal"><span class="pre">dev-&gt;bus-&gt;pm</span></code> are present, the
callback provided by <code class="docutils literal"><span class="pre">dev-&gt;bus-&gt;pm</span></code> will be chosen for execution.</li>
</ol>
</div></blockquote>
<p>This allows PM domains and device types to override callbacks provided by bus
types or device classes if necessary.</p>
<p>The PM domain, type, class and bus callbacks may in turn invoke device- or
driver-specific methods stored in <code class="docutils literal"><span class="pre">dev-&gt;driver-&gt;pm</span></code>, but they don’t have to do
that.</p>
<p>If the subsystem callback chosen for execution is not present, the PM core will
execute the corresponding method from the <code class="docutils literal"><span class="pre">dev-&gt;driver-&gt;pm</span></code> set instead if
there is one.</p>
</div>
<div class="section" id="entering-system-suspend">
<h3>Entering System Suspend<a class="headerlink" href="#entering-system-suspend" title="Permalink to this headline">¶</a></h3>
<p>When the system goes into the freeze, standby or memory sleep state,
the phases are: <code class="docutils literal"><span class="pre">prepare</span></code>, <code class="docutils literal"><span class="pre">suspend</span></code>, <code class="docutils literal"><span class="pre">suspend_late</span></code>, <code class="docutils literal"><span class="pre">suspend_noirq</span></code>.</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">The <code class="docutils literal"><span class="pre">prepare</span></code> phase is meant to prevent races by preventing new
devices from being registered; the PM core would never know that all the
children of a device had been suspended if new children could be
registered at will.  [By contrast, from the PM core’s perspective,
devices may be unregistered at any time.]  Unlike the other
suspend-related phases, during the <code class="docutils literal"><span class="pre">prepare</span></code> phase the device
hierarchy is traversed top-down.</p>
<p>After the <code class="docutils literal"><span class="pre">-&gt;prepare</span></code> callback method returns, no new children may be
registered below the device.  The method may also prepare the device or
driver in some way for the upcoming system power transition, but it
should not put the device into a low-power state.</p>
<p>For devices supporting runtime power management, the return value of the
prepare callback can be used to indicate to the PM core that it may
safely leave the device in runtime suspend (if runtime-suspended
already), provided that all of the device’s descendants are also left in
runtime suspend.  Namely, if the prepare callback returns a positive
number and that happens for all of the descendants of the device too,
and all of them (including the device itself) are runtime-suspended, the
PM core will skip the <code class="docutils literal"><span class="pre">suspend</span></code>, <code class="docutils literal"><span class="pre">suspend_late</span></code> and
<code class="docutils literal"><span class="pre">suspend_noirq</span></code> phases as well as all of the corresponding phases of
the subsequent device resume for all of these devices.  In that case,
the <code class="docutils literal"><span class="pre">-&gt;complete</span></code> callback will be invoked directly after the
<code class="docutils literal"><span class="pre">-&gt;prepare</span></code> callback and is entirely responsible for putting the
device into a consistent state as appropriate.</p>
<p>Note that this direct-complete procedure applies even if the device is
disabled for runtime PM; only the runtime-PM status matters.  It follows
that if a device has system-sleep callbacks but does not support runtime
PM, then its prepare callback must never return a positive value.  This
is because all such devices are initially set to runtime-suspended with
runtime PM disabled.</p>
</li>
<li><p class="first">The <code class="docutils literal"><span class="pre">-&gt;suspend</span></code> methods should quiesce the device to stop it from
performing I/O.  They also may save the device registers and put it into
the appropriate low-power state, depending on the bus type the device is
on, and they may enable wakeup events.</p>
</li>
<li><p class="first">For a number of devices it is convenient to split suspend into the
“quiesce device” and “save device state” phases, in which cases
<code class="docutils literal"><span class="pre">suspend_late</span></code> is meant to do the latter.  It is always executed after
runtime power management has been disabled for the device in question.</p>
</li>
<li><p class="first">The <code class="docutils literal"><span class="pre">suspend_noirq</span></code> phase occurs after IRQ handlers have been disabled,
which means that the driver’s interrupt handler will not be called while
the callback method is running.  The <code class="docutils literal"><span class="pre">-&gt;suspend_noirq</span></code> methods should
save the values of the device’s registers that weren’t saved previously
and finally put the device into the appropriate low-power state.</p>
<p>The majority of subsystems and device drivers need not implement this
callback.  However, bus types allowing devices to share interrupt
vectors, like PCI, generally need it; otherwise a driver might encounter
an error during the suspend phase by fielding a shared interrupt
generated by some other device after its own device had been set to low
power.</p>
</li>
</ol>
</div></blockquote>
<p>At the end of these phases, drivers should have stopped all I/O transactions
(DMA, IRQs), saved enough state that they can re-initialize or restore previous
state (as needed by the hardware), and placed the device into a low-power state.
On many platforms they will gate off one or more clock sources; sometimes they
will also switch off power supplies or reduce voltages.  [Drivers supporting
runtime PM may already have performed some or all of these steps.]</p>
<p>If <code class="xref c c-func docutils literal"><span class="pre">device_may_wakeup(dev)()</span></code> returns <code class="docutils literal"><span class="pre">true</span></code>, the device should be
prepared for generating hardware wakeup signals to trigger a system wakeup event
when the system is in the sleep state.  For example, <code class="xref c c-func docutils literal"><span class="pre">enable_irq_wake()</span></code>
might identify GPIO signals hooked up to a switch or other external hardware,
and <a class="reference internal" href="../pci.html#c.pci_enable_wake" title="pci_enable_wake"><code class="xref c c-func docutils literal"><span class="pre">pci_enable_wake()</span></code></a> does something similar for the PCI PME signal.</p>
<p>If any of these callbacks returns an error, the system won’t enter the desired
low-power state.  Instead, the PM core will unwind its actions by resuming all
the devices that were suspended.</p>
</div>
<div class="section" id="leaving-system-suspend">
<h3>Leaving System Suspend<a class="headerlink" href="#leaving-system-suspend" title="Permalink to this headline">¶</a></h3>
<p>When resuming from freeze, standby or memory sleep, the phases are:
<code class="docutils literal"><span class="pre">resume_noirq</span></code>, <code class="docutils literal"><span class="pre">resume_early</span></code>, <code class="docutils literal"><span class="pre">resume</span></code>, <code class="docutils literal"><span class="pre">complete</span></code>.</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">The <code class="docutils literal"><span class="pre">-&gt;resume_noirq</span></code> callback methods should perform any actions
needed before the driver’s interrupt handlers are invoked.  This
generally means undoing the actions of the <code class="docutils literal"><span class="pre">suspend_noirq</span></code> phase.  If
the bus type permits devices to share interrupt vectors, like PCI, the
method should bring the device and its driver into a state in which the
driver can recognize if the device is the source of incoming interrupts,
if any, and handle them correctly.</p>
<p>For example, the PCI bus type’s <code class="docutils literal"><span class="pre">-&gt;pm.resume_noirq()</span></code> puts the device
into the full-power state (D0 in the PCI terminology) and restores the
standard configuration registers of the device.  Then it calls the
device driver’s <code class="docutils literal"><span class="pre">-&gt;pm.resume_noirq()</span></code> method to perform device-specific
actions.</p>
</li>
<li><p class="first">The <code class="docutils literal"><span class="pre">-&gt;resume_early</span></code> methods should prepare devices for the execution
of the resume methods.  This generally involves undoing the actions of
the preceding <code class="docutils literal"><span class="pre">suspend_late</span></code> phase.</p>
</li>
<li><p class="first">The <code class="docutils literal"><span class="pre">-&gt;resume</span></code> methods should bring the device back to its operating
state, so that it can perform normal I/O.  This generally involves
undoing the actions of the <code class="docutils literal"><span class="pre">suspend</span></code> phase.</p>
</li>
<li><p class="first">The <code class="docutils literal"><span class="pre">complete</span></code> phase should undo the actions of the <code class="docutils literal"><span class="pre">prepare</span></code> phase.
For this reason, unlike the other resume-related phases, during the
<code class="docutils literal"><span class="pre">complete</span></code> phase the device hierarchy is traversed bottom-up.</p>
<p>Note, however, that new children may be registered below the device as
soon as the <code class="docutils literal"><span class="pre">-&gt;resume</span></code> callbacks occur; it’s not necessary to wait
until the <code class="docutils literal"><span class="pre">complete</span></code> phase with that.</p>
<p>Moreover, if the preceding <code class="docutils literal"><span class="pre">-&gt;prepare</span></code> callback returned a positive
number, the device may have been left in runtime suspend throughout the
whole system suspend and resume (the <code class="docutils literal"><span class="pre">suspend</span></code>, <code class="docutils literal"><span class="pre">suspend_late</span></code>,
<code class="docutils literal"><span class="pre">suspend_noirq</span></code> phases of system suspend and the <code class="docutils literal"><span class="pre">resume_noirq</span></code>,
<code class="docutils literal"><span class="pre">resume_early</span></code>, <code class="docutils literal"><span class="pre">resume</span></code> phases of system resume may have been
skipped for it).  In that case, the <code class="docutils literal"><span class="pre">-&gt;complete</span></code> callback is entirely
responsible for putting the device into a consistent state after system
suspend if necessary.  [For example, it may need to queue up a runtime
resume request for the device for this purpose.]  To check if that is
the case, the <code class="docutils literal"><span class="pre">-&gt;complete</span></code> callback can consult the device’s
<code class="docutils literal"><span class="pre">power.direct_complete</span></code> flag.  Namely, if that flag is set when the
<code class="docutils literal"><span class="pre">-&gt;complete</span></code> callback is being run, it has been called directly after
the preceding <code class="docutils literal"><span class="pre">-&gt;prepare</span></code> and special actions may be required
to make the device work correctly afterward.</p>
</li>
</ol>
</div></blockquote>
<p>At the end of these phases, drivers should be as functional as they were before
suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are
gated on.</p>
<p>However, the details here may again be platform-specific.  For example,
some systems support multiple “run” states, and the mode in effect at
the end of resume might not be the one which preceded suspension.
That means availability of certain clocks or power supplies changed,
which could easily affect how a driver works.</p>
<p>Drivers need to be able to handle hardware which has been reset since all of the
suspend methods were called, for example by complete reinitialization.
This may be the hardest part, and the one most protected by NDA’d documents
and chip errata.  It’s simplest if the hardware state hasn’t changed since
the suspend was carried out, but that can only be guaranteed if the target
system sleep entered was suspend-to-idle.  For the other system sleep states
that may not be the case (and usually isn’t for ACPI-defined system sleep
states, like S3).</p>
<p>Drivers must also be prepared to notice that the device has been removed
while the system was powered down, whenever that’s physically possible.
PCMCIA, MMC, USB, Firewire, SCSI, and even IDE are common examples of busses
where common Linux platforms will see such removal.  Details of how drivers
will notice and handle such removals are currently bus-specific, and often
involve a separate thread.</p>
<p>These callbacks may return an error value, but the PM core will ignore such
errors since there’s nothing it can do about them other than printing them in
the system log.</p>
</div>
<div class="section" id="entering-hibernation">
<h3>Entering Hibernation<a class="headerlink" href="#entering-hibernation" title="Permalink to this headline">¶</a></h3>
<p>Hibernating the system is more complicated than putting it into sleep states,
because it involves creating and saving a system image.  Therefore there are
more phases for hibernation, with a different set of callbacks.  These phases
always run after tasks have been frozen and enough memory has been freed.</p>
<p>The general procedure for hibernation is to quiesce all devices (“freeze”),
create an image of the system memory while everything is stable, reactivate all
devices (“thaw”), write the image to permanent storage, and finally shut down
the system (“power off”).  The phases used to accomplish this are: <code class="docutils literal"><span class="pre">prepare</span></code>,
<code class="docutils literal"><span class="pre">freeze</span></code>, <code class="docutils literal"><span class="pre">freeze_late</span></code>, <code class="docutils literal"><span class="pre">freeze_noirq</span></code>, <code class="docutils literal"><span class="pre">thaw_noirq</span></code>, <code class="docutils literal"><span class="pre">thaw_early</span></code>,
<code class="docutils literal"><span class="pre">thaw</span></code>, <code class="docutils literal"><span class="pre">complete</span></code>, <code class="docutils literal"><span class="pre">prepare</span></code>, <code class="docutils literal"><span class="pre">poweroff</span></code>, <code class="docutils literal"><span class="pre">poweroff_late</span></code>,
<code class="docutils literal"><span class="pre">poweroff_noirq</span></code>.</p>
<blockquote>
<div><ol class="arabic simple">
<li>The <code class="docutils literal"><span class="pre">prepare</span></code> phase is discussed in the “Entering System Suspend”
section above.</li>
<li>The <code class="docutils literal"><span class="pre">-&gt;freeze</span></code> methods should quiesce the device so that it doesn’t
generate IRQs or DMA, and they may need to save the values of device
registers.  However the device does not have to be put in a low-power
state, and to save time it’s best not to do so.  Also, the device should
not be prepared to generate wakeup events.</li>
<li>The <code class="docutils literal"><span class="pre">freeze_late</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">suspend_late</span></code> phase
described earlier, except that the device should not be put into a
low-power state and should not be allowed to generate wakeup events.</li>
<li>The <code class="docutils literal"><span class="pre">freeze_noirq</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">suspend_noirq</span></code> phase
discussed earlier, except again that the device should not be put into
a low-power state and should not be allowed to generate wakeup events.</li>
</ol>
</div></blockquote>
<p>At this point the system image is created.  All devices should be inactive and
the contents of memory should remain undisturbed while this happens, so that the
image forms an atomic snapshot of the system state.</p>
<blockquote>
<div><ol class="arabic simple" start="5">
<li>The <code class="docutils literal"><span class="pre">thaw_noirq</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">resume_noirq</span></code> phase
discussed earlier.  The main difference is that its methods can assume
the device is in the same state as at the end of the <code class="docutils literal"><span class="pre">freeze_noirq</span></code>
phase.</li>
<li>The <code class="docutils literal"><span class="pre">thaw_early</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">resume_early</span></code> phase
described above.  Its methods should undo the actions of the preceding
<code class="docutils literal"><span class="pre">freeze_late</span></code>, if necessary.</li>
<li>The <code class="docutils literal"><span class="pre">thaw</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">resume</span></code> phase discussed
earlier.  Its methods should bring the device back to an operating
state, so that it can be used for saving the image if necessary.</li>
<li>The <code class="docutils literal"><span class="pre">complete</span></code> phase is discussed in the “Leaving System Suspend”
section above.</li>
</ol>
</div></blockquote>
<p>At this point the system image is saved, and the devices then need to be
prepared for the upcoming system shutdown.  This is much like suspending them
before putting the system into the suspend-to-idle, shallow or deep sleep state,
and the phases are similar.</p>
<blockquote>
<div><ol class="arabic simple" start="9">
<li>The <code class="docutils literal"><span class="pre">prepare</span></code> phase is discussed above.</li>
<li>The <code class="docutils literal"><span class="pre">poweroff</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">suspend</span></code> phase.</li>
<li>The <code class="docutils literal"><span class="pre">poweroff_late</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">suspend_late</span></code> phase.</li>
<li>The <code class="docutils literal"><span class="pre">poweroff_noirq</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">suspend_noirq</span></code> phase.</li>
</ol>
</div></blockquote>
<p>The <code class="docutils literal"><span class="pre">-&gt;poweroff</span></code>, <code class="docutils literal"><span class="pre">-&gt;poweroff_late</span></code> and <code class="docutils literal"><span class="pre">-&gt;poweroff_noirq</span></code> callbacks
should do essentially the same things as the <code class="docutils literal"><span class="pre">-&gt;suspend</span></code>, <code class="docutils literal"><span class="pre">-&gt;suspend_late</span></code>
and <code class="docutils literal"><span class="pre">-&gt;suspend_noirq</span></code> callbacks, respectively.  The only notable difference is
that they need not store the device register values, because the registers
should already have been stored during the <code class="docutils literal"><span class="pre">freeze</span></code>, <code class="docutils literal"><span class="pre">freeze_late</span></code> or
<code class="docutils literal"><span class="pre">freeze_noirq</span></code> phases.</p>
</div>
<div class="section" id="leaving-hibernation">
<h3>Leaving Hibernation<a class="headerlink" href="#leaving-hibernation" title="Permalink to this headline">¶</a></h3>
<p>Resuming from hibernation is, again, more complicated than resuming from a sleep
state in which the contents of main memory are preserved, because it requires
a system image to be loaded into memory and the pre-hibernation memory contents
to be restored before control can be passed back to the image kernel.</p>
<p>Although in principle the image might be loaded into memory and the
pre-hibernation memory contents restored by the boot loader, in practice this
can’t be done because boot loaders aren’t smart enough and there is no
established protocol for passing the necessary information.  So instead, the
boot loader loads a fresh instance of the kernel, called “the restore kernel”,
into memory and passes control to it in the usual way.  Then the restore kernel
reads the system image, restores the pre-hibernation memory contents, and passes
control to the image kernel.  Thus two different kernel instances are involved
in resuming from hibernation.  In fact, the restore kernel may be completely
different from the image kernel: a different configuration and even a different
version.  This has important consequences for device drivers and their
subsystems.</p>
<p>To be able to load the system image into memory, the restore kernel needs to
include at least a subset of device drivers allowing it to access the storage
medium containing the image, although it doesn’t need to include all of the
drivers present in the image kernel.  After the image has been loaded, the
devices managed by the boot kernel need to be prepared for passing control back
to the image kernel.  This is very similar to the initial steps involved in
creating a system image, and it is accomplished in the same way, using
<code class="docutils literal"><span class="pre">prepare</span></code>, <code class="docutils literal"><span class="pre">freeze</span></code>, and <code class="docutils literal"><span class="pre">freeze_noirq</span></code> phases.  However, the devices
affected by these phases are only those having drivers in the restore kernel;
other devices will still be in whatever state the boot loader left them.</p>
<p>Should the restoration of the pre-hibernation memory contents fail, the restore
kernel would go through the “thawing” procedure described above, using the
<code class="docutils literal"><span class="pre">thaw_noirq</span></code>, <code class="docutils literal"><span class="pre">thaw_early</span></code>, <code class="docutils literal"><span class="pre">thaw</span></code>, and <code class="docutils literal"><span class="pre">complete</span></code> phases, and then
continue running normally.  This happens only rarely.  Most often the
pre-hibernation memory contents are restored successfully and control is passed
to the image kernel, which then becomes responsible for bringing the system back
to the working state.</p>
<p>To achieve this, the image kernel must restore the devices’ pre-hibernation
functionality.  The operation is much like waking up from a sleep state (with
the memory contents preserved), although it involves different phases:
<code class="docutils literal"><span class="pre">restore_noirq</span></code>, <code class="docutils literal"><span class="pre">restore_early</span></code>, <code class="docutils literal"><span class="pre">restore</span></code>, <code class="docutils literal"><span class="pre">complete</span></code>.</p>
<blockquote>
<div><ol class="arabic simple">
<li>The <code class="docutils literal"><span class="pre">restore_noirq</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">resume_noirq</span></code> phase.</li>
<li>The <code class="docutils literal"><span class="pre">restore_early</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">resume_early</span></code> phase.</li>
<li>The <code class="docutils literal"><span class="pre">restore</span></code> phase is analogous to the <code class="docutils literal"><span class="pre">resume</span></code> phase.</li>
<li>The <code class="docutils literal"><span class="pre">complete</span></code> phase is discussed above.</li>
</ol>
</div></blockquote>
<p>The main difference from <code class="docutils literal"><span class="pre">resume[_early|_noirq]</span></code> is that
<code class="docutils literal"><span class="pre">restore[_early|_noirq]</span></code> must assume the device has been accessed and
reconfigured by the boot loader or the restore kernel.  Consequently, the state
of the device may be different from the state remembered from the <code class="docutils literal"><span class="pre">freeze</span></code>,
<code class="docutils literal"><span class="pre">freeze_late</span></code> and <code class="docutils literal"><span class="pre">freeze_noirq</span></code> phases.  The device may even need to be
reset and completely re-initialized.  In many cases this difference doesn’t
matter, so the <code class="docutils literal"><span class="pre">-&gt;resume[_early|_noirq]</span></code> and <code class="docutils literal"><span class="pre">-&gt;restore[_early|_norq]</span></code>
method pointers can be set to the same routines.  Nevertheless, different
callback pointers are used in case there is a situation where it actually does
matter.</p>
</div>
</div>
<div class="section" id="power-management-notifiers">
<h2>Power Management Notifiers<a class="headerlink" href="#power-management-notifiers" title="Permalink to this headline">¶</a></h2>
<p>There are some operations that cannot be carried out by the power management
callbacks discussed above, because the callbacks occur too late or too early.
To handle these cases, subsystems and device drivers may register power
management notifiers that are called before tasks are frozen and after they have
been thawed.  Generally speaking, the PM notifiers are suitable for performing
actions that either require user space to be available, or at least won’t
interfere with user space.</p>
<p>For details refer to <a class="reference internal" href="notifiers.html"><span class="doc">Suspend/Hibernation Notifiers</span></a>.</p>
</div>
<div class="section" id="device-low-power-suspend-states">
<h2>Device Low-Power (suspend) States<a class="headerlink" href="#device-low-power-suspend-states" title="Permalink to this headline">¶</a></h2>
<p>Device low-power states aren’t standard.  One device might only handle
“on” and “off”, while another might support a dozen different versions of
“on” (how many engines are active?), plus a state that gets back to “on”
faster than from a full “off”.</p>
<p>Some buses define rules about what different suspend states mean.  PCI
gives one example: after the suspend sequence completes, a non-legacy
PCI device may not perform DMA or issue IRQs, and any wakeup events it
issues would be issued through the PME# bus signal.  Plus, there are
several PCI-standard device states, some of which are optional.</p>
<p>In contrast, integrated system-on-chip processors often use IRQs as the
wakeup event sources (so drivers would call <code class="xref c c-func docutils literal"><span class="pre">enable_irq_wake()</span></code>) and
might be able to treat DMA completion as a wakeup event (sometimes DMA can stay
active too, it’d only be the CPU and some peripherals that sleep).</p>
<p>Some details here may be platform-specific.  Systems may have devices that
can be fully active in certain sleep states, such as an LCD display that’s
refreshed using DMA while most of the system is sleeping lightly … and
its frame buffer might even be updated by a DSP or other non-Linux CPU while
the Linux control processor stays idle.</p>
<p>Moreover, the specific actions taken may depend on the target system state.
One target system state might allow a given device to be very operational;
another might require a hard shut down with re-initialization on resume.
And two different target systems might use the same device in different
ways; the aforementioned LCD might be active in one product’s “standby”,
but a different product using the same SOC might work differently.</p>
</div>
<div class="section" id="device-power-management-domains">
<h2>Device Power Management Domains<a class="headerlink" href="#device-power-management-domains" title="Permalink to this headline">¶</a></h2>
<p>Sometimes devices share reference clocks or other power resources.  In those
cases it generally is not possible to put devices into low-power states
individually.  Instead, a set of devices sharing a power resource can be put
into a low-power state together at the same time by turning off the shared
power resource.  Of course, they also need to be put into the full-power state
together, by turning the shared power resource on.  A set of devices with this
property is often referred to as a power domain. A power domain may also be
nested inside another power domain. The nested domain is referred to as the
sub-domain of the parent domain.</p>
<p>Support for power domains is provided through the <code class="xref c c-member docutils literal"><span class="pre">pm_domain</span></code> field of
<a class="reference internal" href="../infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a>.  This field is a pointer to an object of type
<a class="reference internal" href="types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a>, defined in <code class="file docutils literal"><span class="pre">include/linux/pm.h</span></code>, providing a set
of power management callbacks analogous to the subsystem-level and device driver
callbacks that are executed for the given device during all power transitions,
instead of the respective subsystem-level callbacks.  Specifically, if a
device’s <code class="xref c c-member docutils literal"><span class="pre">pm_domain</span></code> pointer is not NULL, the <code class="docutils literal"><span class="pre">-&gt;suspend()</span></code> callback
from the object pointed to by it will be executed instead of its subsystem’s
(e.g. bus type’s) <code class="docutils literal"><span class="pre">-&gt;suspend()</span></code> callback and analogously for all of the
remaining callbacks.  In other words, power management domain callbacks, if
defined for the given device, always take precedence over the callbacks provided
by the device’s subsystem (e.g. bus type).</p>
<p>The support for device power management domains is only relevant to platforms
needing to use the same device driver power management callbacks in many
different power domain configurations and wanting to avoid incorporating the
support for power domains into subsystem-level callbacks, for example by
modifying the platform bus type.  Other platforms need not implement it or take
it into account in any way.</p>
<p>Devices may be defined as IRQ-safe which indicates to the PM core that their
runtime PM callbacks may be invoked with disabled interrupts (see
<code class="file docutils literal"><span class="pre">Documentation/power/runtime_pm.txt</span></code> for more information).  If an
IRQ-safe device belongs to a PM domain, the runtime PM of the domain will be
disallowed, unless the domain itself is defined as IRQ-safe. However, it
makes sense to define a PM domain as IRQ-safe only if all the devices in it
are IRQ-safe. Moreover, if an IRQ-safe domain has a parent domain, the runtime
PM of the parent is only allowed if the parent itself is IRQ-safe too with the
additional restriction that all child domains of an IRQ-safe parent must also
be IRQ-safe.</p>
</div>
<div class="section" id="runtime-power-management">
<h2>Runtime Power Management<a class="headerlink" href="#runtime-power-management" title="Permalink to this headline">¶</a></h2>
<p>Many devices are able to dynamically power down while the system is still
running. This feature is useful for devices that are not being used, and
can offer significant power savings on a running system.  These devices
often support a range of runtime power states, which might use names such
as “off”, “sleep”, “idle”, “active”, and so on.  Those states will in some
cases (like PCI) be partially constrained by the bus the device uses, and will
usually include hardware states that are also used in system sleep states.</p>
<p>A system-wide power transition can be started while some devices are in low
power states due to runtime power management.  The system sleep PM callbacks
should recognize such situations and react to them appropriately, but the
necessary actions are subsystem-specific.</p>
<p>In some cases the decision may be made at the subsystem level while in other
cases the device driver may be left to decide.  In some cases it may be
desirable to leave a suspended device in that state during a system-wide power
transition, but in other cases the device must be put back into the full-power
state temporarily, for example so that its system wakeup capability can be
disabled.  This all depends on the hardware and the design of the subsystem and
device driver in question.</p>
<p>During system-wide resume from a sleep state it’s easiest to put devices into
the full-power state, as explained in <code class="file docutils literal"><span class="pre">Documentation/power/runtime_pm.txt</span></code>.
Refer to that document for more information regarding this particular issue as
well as for information on the device runtime power management framework in
general.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="notifiers.html" class="btn btn-neutral float-right" title="Suspend/Hibernation Notifiers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Device Power Management" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>