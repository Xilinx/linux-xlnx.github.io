

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>L’inaffidabile guida alla sincronizzazione &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Korean translations" href="../../ko_KR/index.html" />
    <link rel="prev" title="L’inaffidabile guida all’hacking del kernel Linux" href="hacking.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Translations</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../zh_CN/index.html">Chinese translations</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Traduzione italiana</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../index.html#la-documentazione-del-kernel-linux">La documentazione del kernel Linux</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-sulla-licenza-dei-sorgenti">Documentazione sulla licenza dei sorgenti</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-per-gli-utenti">Documentazione per gli utenti</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-per-gli-sviluppatori-di-applicazioni">Documentazione per gli sviluppatori di applicazioni</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../index.html#introduzione-allo-sviluppo-del-kernel">Introduzione allo sviluppo del kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-della-api-del-kernel">Documentazione della API del kernel</a></li>
<li class="toctree-l4"><a class="reference internal" href="../index.html#documentazione-specifica-per-architettura">Documentazione specifica per architettura</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ko_KR/index.html">Korean translations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ja_JP/index.html">Japanese translations</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Translations</a> &raquo;</li>
        
          <li><a href="../index.html">Traduzione italiana</a> &raquo;</li>
        
          <li><a href="index.html">Guida all’hacking del kernel</a> &raquo;</li>
        
      <li>L’inaffidabile guida alla sincronizzazione</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/translations/it_IT/kernel-hacking/locking.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This document is maintained by Federico Vaga &lt;<a class="reference external" href="mailto:federico&#46;vaga&#37;&#52;&#48;vaga&#46;pv&#46;it">federico<span>&#46;</span>vaga<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;.
If you find any difference between this document and the original file or a
problem with the translation, please contact the maintainer of this file.
Following people helped to translate or review:
Alessia Mantegazza &lt;<a class="reference external" href="mailto:amantegazza&#37;&#52;&#48;vaga&#46;pv&#46;it">amantegazza<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The purpose of this file is to be easier to read and understand for Italian
speakers and is not intended as a fork. So, if you have any comments or
updates for this file please try to update the original English file first.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Original:</th><td class="field-body"><a class="reference internal" href="../../../kernel-hacking/locking.html#kernel-hacking-lock"><span class="std std-ref">Documentation/kernel-hacking/locking.rst</span></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Translator:</th><td class="field-body">Federico Vaga &lt;<a class="reference external" href="mailto:federico&#46;vaga&#37;&#52;&#48;vaga&#46;pv&#46;it">federico<span>&#46;</span>vaga<span>&#64;</span>vaga<span>&#46;</span>pv<span>&#46;</span>it</a>&gt;</td>
</tr>
</tbody>
</table>
<div class="section" id="l-inaffidabile-guida-alla-sincronizzazione">
<span id="it-kernel-hacking-lock"></span><h1>L’inaffidabile guida alla sincronizzazione<a class="headerlink" href="#l-inaffidabile-guida-alla-sincronizzazione" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Rusty Russell</td>
</tr>
</tbody>
</table>
<div class="section" id="introduzione">
<h2>Introduzione<a class="headerlink" href="#introduzione" title="Permalink to this headline">¶</a></h2>
<p>Benvenuto, alla notevole ed inaffidabile guida ai problemi di sincronizzazione
(locking) nel kernel. Questo documento descrive il sistema di sincronizzazione
nel kernel Linux 2.6.</p>
<p>Dato il largo utilizzo del multi-threading e della prelazione nel kernel
Linux, chiunque voglia dilettarsi col kernel deve conoscere i concetti
fondamentali della concorrenza e della sincronizzazione nei sistemi
multi-processore.</p>
</div>
<div class="section" id="il-problema-con-la-concorrenza">
<h2>Il problema con la concorrenza<a class="headerlink" href="#il-problema-con-la-concorrenza" title="Permalink to this headline">¶</a></h2>
<p>(Saltatelo se sapete già cos’è una corsa critica).</p>
<p>In un normale programma, potete incrementare un contatore nel seguente modo:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>contatore++;
</pre></div>
</div>
<p>Questo è quello che vi aspettereste che accada sempre:</p>
<table border="1" class="docutils" id="id1">
<caption><span class="caption-text">Risultati attesi</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Istanza 1</th>
<th class="head">Istanza 2</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>leggi contatore (5)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>aggiungi 1 (6)</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>scrivi contatore (6)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>leggi contatore (6)</td>
</tr>
<tr class="row-even"><td>&#160;</td>
<td>aggiungi 1 (7)</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>scrivi contatore (7)</td>
</tr>
</tbody>
</table>
<p>Questo è quello che potrebbe succedere in realtà:</p>
<table border="1" class="docutils" id="id2">
<caption><span class="caption-text">Possibile risultato</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Istanza 1</th>
<th class="head">Istanza 2</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>leggi contatore (5)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>leggi contatore (5)</td>
</tr>
<tr class="row-even"><td>aggiungi 1 (6)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>aggiungi 1 (6)</td>
</tr>
<tr class="row-even"><td>scrivi contatore (6)</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>scrivi contatore (6)</td>
</tr>
</tbody>
</table>
<div class="section" id="corse-critiche-e-sezioni-critiche">
<h3>Corse critiche e sezioni critiche<a class="headerlink" href="#corse-critiche-e-sezioni-critiche" title="Permalink to this headline">¶</a></h3>
<p>Questa sovrapposizione, ovvero quando un risultato dipende dal tempo che
intercorre fra processi diversi, è chiamata corsa critica. La porzione
di codice che contiene questo problema è chiamata sezione critica.
In particolar modo da quando Linux ha incominciato a girare su
macchine multi-processore, le sezioni critiche sono diventate uno dei
maggiori problemi di progettazione ed implementazione del kernel.</p>
<p>La prelazione può sortire gli stessi effetti, anche se c’è una sola CPU:
interrompendo un processo nella sua sezione critica otterremo comunque
la stessa corsa critica. In questo caso, il thread che si avvicenda
nell’esecuzione potrebbe eseguire anch’esso la sezione critica.</p>
<p>La soluzione è quella di riconoscere quando avvengono questi accessi
simultanei, ed utilizzare i <em>lock</em> per accertarsi che solo un’istanza
per volta possa entrare nella sezione critica. Il kernel offre delle buone
funzioni a questo scopo. E poi ci sono quelle meno buone, ma farò finta
che non esistano.</p>
</div>
</div>
<div class="section" id="sincronizzazione-nel-kernel-linux">
<h2>Sincronizzazione nel kernel Linux<a class="headerlink" href="#sincronizzazione-nel-kernel-linux" title="Permalink to this headline">¶</a></h2>
<p>Se posso darvi un suggerimento: non dormite mai con qualcuno più pazzo di
voi. Ma se dovessi darvi un suggerimento sulla sincronizzazione:
<strong>mantenetela semplice</strong>.</p>
<p>Siate riluttanti nell’introduzione di nuovi <em>lock</em>.</p>
<p>Abbastanza strano, quest’ultimo è l’esatto opposto del mio suggerimento
su quando <strong>avete</strong> dormito con qualcuno più pazzo di voi. E dovreste
pensare a prendervi un cane bello grande.</p>
<div class="section" id="i-due-principali-tipi-di-lock-nel-kernel-spinlock-e-mutex">
<h3>I due principali tipi di <em>lock</em> nel kernel: spinlock e mutex<a class="headerlink" href="#i-due-principali-tipi-di-lock-nel-kernel-spinlock-e-mutex" title="Permalink to this headline">¶</a></h3>
<p>Ci sono due tipi principali di <em>lock</em> nel kernel. Il tipo fondamentale è lo
spinlock (<code class="docutils literal"><span class="pre">include/asm/spinlock.h</span></code>), un semplice <em>lock</em> che può essere
trattenuto solo da un processo: se non si può trattenere lo spinlock, allora
rimane in attesa attiva (in inglese <em>spinning</em>) finché non ci riesce.
Gli spinlock sono molto piccoli e rapidi, possono essere utilizzati ovunque.</p>
<p>Il secondo tipo è il mutex (<code class="docutils literal"><span class="pre">include/linux/mutex.h</span></code>): è come uno spinlock,
ma potreste bloccarvi trattenendolo. Se non potete trattenere un mutex
il vostro processo si auto-sospenderà; verrà riattivato quando il mutex
verrà rilasciato. Questo significa che il processore potrà occuparsi d’altro
mentre il vostro processo è in attesa. Esistono molti casi in cui non potete
permettervi di sospendere un processo (vedere
<a class="reference internal" href="#it-sleeping-things"><span class="std std-ref">Quali funzioni possono essere chiamate in modo sicuro dalle interruzioni?</span></a>)
e quindi dovrete utilizzare gli spinlock.</p>
<p>Nessuno di questi <em>lock</em> è ricorsivo: vedere
<a class="reference internal" href="#it-deadlock"><span class="std std-ref">Stallo: semplice ed avanzato</span></a></p>
</div>
<div class="section" id="i-lock-e-i-kernel-per-sistemi-monoprocessore">
<h3>I <em>lock</em> e i kernel per sistemi monoprocessore<a class="headerlink" href="#i-lock-e-i-kernel-per-sistemi-monoprocessore" title="Permalink to this headline">¶</a></h3>
<p>Per i kernel compilati senza <code class="docutils literal"><span class="pre">CONFIG_SMP</span></code> e senza <code class="docutils literal"><span class="pre">CONFIG_PREEMPT</span></code>
gli spinlock non esistono. Questa è un’ottima scelta di progettazione:
quando nessun altro processo può essere eseguito in simultanea, allora
non c’è la necessità di avere un <em>lock</em>.</p>
<p>Se il kernel è compilato senza <code class="docutils literal"><span class="pre">CONFIG_SMP</span></code> ma con <code class="docutils literal"><span class="pre">CONFIG_PREEMPT</span></code>,
allora gli spinlock disabilitano la prelazione; questo è sufficiente a
prevenire le corse critiche. Nella maggior parte dei casi, possiamo considerare
la prelazione equivalente ad un sistema multi-processore senza preoccuparci
di trattarla indipendentemente.</p>
<p>Dovreste verificare sempre la sincronizzazione con le opzioni <code class="docutils literal"><span class="pre">CONFIG_SMP</span></code> e
<code class="docutils literal"><span class="pre">CONFIG_PREEMPT</span></code> abilitate, anche quando non avete un sistema
multi-processore, questo vi permetterà di identificare alcuni problemi
di sincronizzazione.</p>
<p>Come vedremo di seguito, i mutex continuano ad esistere perché sono necessari
per la sincronizzazione fra processi in contesto utente.</p>
</div>
<div class="section" id="sincronizzazione-in-contesto-utente">
<h3>Sincronizzazione in contesto utente<a class="headerlink" href="#sincronizzazione-in-contesto-utente" title="Permalink to this headline">¶</a></h3>
<p>Se avete una struttura dati che verrà utilizzata solo dal contesto utente,
allora, per proteggerla, potete utilizzare un semplice mutex
(<code class="docutils literal"><span class="pre">include/linux/mutex.h</span></code>). Questo è il caso più semplice: inizializzate il
mutex; invocate <a class="reference internal" href="#c.mutex_lock_interruptible" title="mutex_lock_interruptible"><code class="xref c c-func docutils literal"><span class="pre">mutex_lock_interruptible()</span></code></a> per trattenerlo e
<a class="reference internal" href="#c.mutex_unlock" title="mutex_unlock"><code class="xref c c-func docutils literal"><span class="pre">mutex_unlock()</span></code></a> per rilasciarlo. C’è anche <a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal"><span class="pre">mutex_lock()</span></code></a>
ma questa dovrebbe essere evitata perché non ritorna in caso di segnali.</p>
<p>Per esempio: <code class="docutils literal"><span class="pre">net/netfilter/nf_sockopt.c</span></code> permette la registrazione
di nuove chiamate per <code class="xref c c-func docutils literal"><span class="pre">setsockopt()</span></code> e <code class="xref c c-func docutils literal"><span class="pre">getsockopt()</span></code>
usando la funzione <code class="xref c c-func docutils literal"><span class="pre">nf_register_sockopt()</span></code>. La registrazione e
la rimozione vengono eseguite solamente quando il modulo viene caricato
o scaricato (e durante l’avvio del sistema, qui non abbiamo concorrenza),
e la lista delle funzioni registrate viene consultata solamente quando
<code class="xref c c-func docutils literal"><span class="pre">setsockopt()</span></code> o <code class="xref c c-func docutils literal"><span class="pre">getsockopt()</span></code> sono sconosciute al sistema.
In questo caso <code class="docutils literal"><span class="pre">nf_sockopt_mutex</span></code> è perfetto allo scopo, in particolar modo
visto che setsockopt e getsockopt potrebbero dormire.</p>
</div>
<div class="section" id="sincronizzazione-fra-il-contesto-utente-e-i-softirq">
<h3>Sincronizzazione fra il contesto utente e i softirq<a class="headerlink" href="#sincronizzazione-fra-il-contesto-utente-e-i-softirq" title="Permalink to this headline">¶</a></h3>
<p>Se un softirq condivide dati col contesto utente, avete due problemi.
Primo, il contesto utente corrente potrebbe essere interroto da un softirq,
e secondo, la sezione critica potrebbe essere eseguita da un altro
processore. Questo è quando <code class="xref c c-func docutils literal"><span class="pre">spin_lock_bh()</span></code>
(<code class="docutils literal"><span class="pre">include/linux/spinlock.h</span></code>) viene utilizzato. Questo disabilita i softirq
sul processore e trattiene il <em>lock</em>. Invece, <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_bh()</span></code> fa
l’opposto. (Il suffisso ‘_bh’ è un residuo storico che fa riferimento al
“Bottom Halves”, il vecchio nome delle interruzioni software. In un mondo
perfetto questa funzione si chiamerebbe ‘spin_lock_softirq()’).</p>
<p>Da notare che in questo caso potete utilizzare anche <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code>
o <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code>, queste fermano anche le interruzioni hardware:
vedere <a class="reference internal" href="#it-hardirq-context"><span class="std std-ref">Contesto di interruzione hardware</span></a>.</p>
<p>Questo funziona alla perfezione anche sui sistemi monoprocessore: gli spinlock
svaniscono e questa macro diventa semplicemente <code class="xref c c-func docutils literal"><span class="pre">local_bh_disable()</span></code>
(<code class="docutils literal"><span class="pre">include/linux/interrupt.h</span></code>), la quale impedisce ai softirq d’essere
eseguiti.</p>
</div>
<div class="section" id="sincronizzazione-fra-contesto-utente-e-i-tasklet">
<h3>Sincronizzazione fra contesto utente e i tasklet<a class="headerlink" href="#sincronizzazione-fra-contesto-utente-e-i-tasklet" title="Permalink to this headline">¶</a></h3>
<p>Questo caso è uguale al precedente, un tasklet viene eseguito da un softirq.</p>
</div>
<div class="section" id="sincronizzazione-fra-contesto-utente-e-i-timer">
<h3>Sincronizzazione fra contesto utente e i timer<a class="headerlink" href="#sincronizzazione-fra-contesto-utente-e-i-timer" title="Permalink to this headline">¶</a></h3>
<p>Anche questo caso è uguale al precedente, un timer viene eseguito da un
softirq.
Dal punto di vista della sincronizzazione, tasklet e timer sono identici.</p>
</div>
<div class="section" id="sincronizzazione-fra-tasklet-e-timer">
<h3>Sincronizzazione fra tasklet e timer<a class="headerlink" href="#sincronizzazione-fra-tasklet-e-timer" title="Permalink to this headline">¶</a></h3>
<p>Qualche volta un tasklet od un timer potrebbero condividere i dati con
un altro tasklet o timer</p>
<div class="section" id="lo-stesso-tasklet-timer">
<h4>Lo stesso tasklet/timer<a class="headerlink" href="#lo-stesso-tasklet-timer" title="Permalink to this headline">¶</a></h4>
<p>Dato che un tasklet non viene mai eseguito contemporaneamente su due
processori, non dovete preoccuparvi che sia rientrante (ovvero eseguito
più volte in contemporanea), perfino su sistemi multi-processore.</p>
</div>
<div class="section" id="differenti-tasklet-timer">
<h4>Differenti tasklet/timer<a class="headerlink" href="#differenti-tasklet-timer" title="Permalink to this headline">¶</a></h4>
<p>Se un altro tasklet/timer vuole condividere dati col vostro tasklet o timer,
allora avrete bisogno entrambe di <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> e
<code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code>. Qui <code class="xref c c-func docutils literal"><span class="pre">spin_lock_bh()</span></code> è inutile, siete già
in un tasklet ed avete la garanzia che nessun altro verrà eseguito sullo
stesso processore.</p>
</div>
</div>
<div class="section" id="sincronizzazione-fra-softirq">
<h3>Sincronizzazione fra softirq<a class="headerlink" href="#sincronizzazione-fra-softirq" title="Permalink to this headline">¶</a></h3>
<p>Spesso un softirq potrebbe condividere dati con se stesso o un tasklet/timer.</p>
<div class="section" id="lo-stesso-softirq">
<h4>Lo stesso softirq<a class="headerlink" href="#lo-stesso-softirq" title="Permalink to this headline">¶</a></h4>
<p>Lo stesso softirq può essere eseguito su un diverso processore: allo scopo
di migliorare le prestazioni potete utilizzare dati riservati ad ogni
processore (vedere <a class="reference internal" href="#it-per-cpu"><span class="std std-ref">Dati per processore</span></a>). Se siete arrivati
fino a questo punto nell’uso dei softirq, probabilmente tenete alla scalabilità
delle prestazioni abbastanza da giustificarne la complessità aggiuntiva.</p>
<p>Dovete utilizzare <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> e <code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code> per
proteggere i dati condivisi.</p>
</div>
<div class="section" id="diversi-softirqs">
<h4>Diversi Softirqs<a class="headerlink" href="#diversi-softirqs" title="Permalink to this headline">¶</a></h4>
<p>Dovete utilizzare <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> e <code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code> per
proteggere i dati condivisi, che siano timer, tasklet, diversi softirq o
lo stesso o altri softirq: uno qualsiasi di essi potrebbe essere in esecuzione
su un diverso processore.</p>
</div>
</div>
</div>
<div class="section" id="contesto-di-interruzione-hardware">
<span id="it-hardirq-context"></span><h2>Contesto di interruzione hardware<a class="headerlink" href="#contesto-di-interruzione-hardware" title="Permalink to this headline">¶</a></h2>
<p>Solitamente le interruzioni hardware comunicano con un tasklet o un softirq.
Spesso questo si traduce nel mettere in coda qualcosa da fare che verrà
preso in carico da un softirq.</p>
<div class="section" id="sincronizzazione-fra-interruzioni-hardware-e-softirq-tasklet">
<h3>Sincronizzazione fra interruzioni hardware e softirq/tasklet<a class="headerlink" href="#sincronizzazione-fra-interruzioni-hardware-e-softirq-tasklet" title="Permalink to this headline">¶</a></h3>
<p>Se un gestore di interruzioni hardware condivide dati con un softirq, allora
avrete due preoccupazioni. Primo, il softirq può essere interrotto da
un’interruzione hardware, e secondo, la sezione critica potrebbe essere
eseguita da un’interruzione hardware su un processore diverso. Questo è il caso
dove <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code> viene utilizzato. Disabilita le interruzioni
sul processore che l’esegue, poi trattiene il lock. <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irq()</span></code>
fa l’opposto.</p>
<p>Il gestore d’interruzione hardware non usa <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code> perché
i softirq non possono essere eseguiti quando il gestore d’interruzione hardware
è in esecuzione: per questo si può usare <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code>, che è un po’
più veloce. L’unica eccezione è quando un altro gestore d’interruzioni
hardware utilizza lo stesso <em>lock</em>: <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code> impedirà a questo
secondo gestore di interrompere quello in esecuzione.</p>
<p>Questo funziona alla perfezione anche sui sistemi monoprocessore: gli spinlock
svaniscono e questa macro diventa semplicemente <code class="xref c c-func docutils literal"><span class="pre">local_irq_disable()</span></code>
(<code class="docutils literal"><span class="pre">include/asm/smp.h</span></code>), la quale impedisce a softirq/tasklet/BH d’essere
eseguiti.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> (<code class="docutils literal"><span class="pre">include/linux/spinlock.h</span></code>) è una variante che
salva lo stato delle interruzioni in una variabile, questa verrà poi passata
a <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code>. Questo significa che lo stesso codice
potrà essere utilizzato in un’interruzione hardware (dove le interruzioni sono
già disabilitate) e in un softirq (dove la disabilitazione delle interruzioni
è richiesta).</p>
<p>Da notare che i softirq (e quindi tasklet e timer) sono eseguiti al ritorno
da un’interruzione hardware, quindi <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code> interrompe
anche questi. Tenuto conto di questo si può dire che
<code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> è la funzione di sincronizzazione più generica
e potente.</p>
</div>
<div class="section" id="sincronizzazione-fra-due-gestori-d-interruzioni-hardware">
<h3>Sincronizzazione fra due gestori d’interruzioni hardware<a class="headerlink" href="#sincronizzazione-fra-due-gestori-d-interruzioni-hardware" title="Permalink to this headline">¶</a></h3>
<p>Condividere dati fra due gestori di interruzione hardware è molto raro, ma se
succede, dovreste usare <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code>: è una specificità
dell’architettura il fatto che tutte le interruzioni vengano interrotte
quando si eseguono di gestori di interruzioni.</p>
</div>
</div>
<div class="section" id="bigino-della-sincronizzazione">
<h2>Bigino della sincronizzazione<a class="headerlink" href="#bigino-della-sincronizzazione" title="Permalink to this headline">¶</a></h2>
<p>Pete Zaitcev ci offre il seguente riassunto:</p>
<ul class="simple">
<li>Se siete in un contesto utente (una qualsiasi chiamata di sistema)
e volete sincronizzarvi con altri processi, usate i mutex. Potete trattenere
il mutex e dormire (<code class="docutils literal"><span class="pre">copy_from_user*(</span></code> o <code class="docutils literal"><span class="pre">kmalloc(x,GFP_KERNEL)</span></code>).</li>
<li>Altrimenti (== i dati possono essere manipolati da un’interruzione) usate
<code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> e <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code>.</li>
<li>Evitate di trattenere uno spinlock per più di 5 righe di codice incluse
le chiamate a funzione (ad eccezione di quell per l’accesso come
<code class="xref c c-func docutils literal"><span class="pre">readb()</span></code>).</li>
</ul>
<div class="section" id="tabella-dei-requisiti-minimi">
<h3>Tabella dei requisiti minimi<a class="headerlink" href="#tabella-dei-requisiti-minimi" title="Permalink to this headline">¶</a></h3>
<p>La tabella seguente illustra i requisiti <strong>minimi</strong> per la sincronizzazione fra
diversi contesti. In alcuni casi, lo stesso contesto può essere eseguito solo
da un processore per volta, quindi non ci sono requisiti per la
sincronizzazione (per esempio, un thread può essere eseguito solo su un
processore alla volta, ma se deve condividere dati con un altro thread, allora
la sincronizzazione è necessaria).</p>
<p>Ricordatevi il suggerimento qui sopra: potete sempre usare
<code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code>, che è un sovrainsieme di tutte le altre funzioni
per spinlock.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="11%" />
<col width="11%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="6%" />
<col width="6%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">.</th>
<th class="head">IRQ Handler A</th>
<th class="head">IRQ Handler B</th>
<th class="head">Softirq A</th>
<th class="head">Softirq B</th>
<th class="head">Tasklet A</th>
<th class="head">Tasklet B</th>
<th class="head">Timer A</th>
<th class="head">Timer B</th>
<th class="head">User Context A</th>
<th class="head">User Context B</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IRQ Handler A</td>
<td>None</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>IRQ Handler B</td>
<td>SLIS</td>
<td>None</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Softirq A</td>
<td>SLI</td>
<td>SLI</td>
<td>SL</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Softirq B</td>
<td>SLI</td>
<td>SLI</td>
<td>SL</td>
<td>SL</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Tasklet A</td>
<td>SLI</td>
<td>SLI</td>
<td>SL</td>
<td>SL</td>
<td>None</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Tasklet B</td>
<td>SLI</td>
<td>SLI</td>
<td>SL</td>
<td>SL</td>
<td>SL</td>
<td>None</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>Timer A</td>
<td>SLI</td>
<td>SLI</td>
<td>SL</td>
<td>SL</td>
<td>SL</td>
<td>SL</td>
<td>None</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Timer B</td>
<td>SLI</td>
<td>SLI</td>
<td>SL</td>
<td>SL</td>
<td>SL</td>
<td>SL</td>
<td>SL</td>
<td>None</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>User Context A</td>
<td>SLI</td>
<td>SLI</td>
<td>SLBH</td>
<td>SLBH</td>
<td>SLBH</td>
<td>SLBH</td>
<td>SLBH</td>
<td>SLBH</td>
<td>None</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>User Context B</td>
<td>SLI</td>
<td>SLI</td>
<td>SLBH</td>
<td>SLBH</td>
<td>SLBH</td>
<td>SLBH</td>
<td>SLBH</td>
<td>SLBH</td>
<td>MLI</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>Table: Tabella dei requisiti per la sincronizzazione</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>SLIS</td>
<td>spin_lock_irqsave</td>
</tr>
<tr class="row-even"><td>SLI</td>
<td>spin_lock_irq</td>
</tr>
<tr class="row-odd"><td>SL</td>
<td>spin_lock</td>
</tr>
<tr class="row-even"><td>SLBH</td>
<td>spin_lock_bh</td>
</tr>
<tr class="row-odd"><td>MLI</td>
<td>mutex_lock_interruptible</td>
</tr>
</tbody>
</table>
<p>Table: Legenda per la tabella dei requisiti per la sincronizzazione</p>
</div>
</div>
<div class="section" id="le-funzioni-trylock">
<h2>Le funzioni <em>trylock</em><a class="headerlink" href="#le-funzioni-trylock" title="Permalink to this headline">¶</a></h2>
<p>Ci sono funzioni che provano a trattenere un <em>lock</em> solo una volta e
ritornano immediatamente comunicato il successo od il fallimento
dell’operazione. Posso essere usate quando non serve accedere ai dati
protetti dal <em>lock</em> quando qualche altro thread lo sta già facendo
trattenendo il <em>lock</em>. Potrete acquisire il <em>lock</em> più tardi se vi
serve accedere ai dati protetti da questo <em>lock</em>.</p>
<p>La funzione <code class="xref c c-func docutils literal"><span class="pre">spin_trylock()</span></code> non ritenta di acquisire il <em>lock</em>,
se ci riesce al primo colpo ritorna un valore diverso da zero, altrimenti
se fallisce ritorna 0. Questa funzione può essere utilizzata in un qualunque
contesto, ma come <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code>: dovete disabilitare i contesti che
potrebbero interrompervi e quindi trattenere lo spinlock.</p>
<p>La funzione <a class="reference internal" href="#c.mutex_trylock" title="mutex_trylock"><code class="xref c c-func docutils literal"><span class="pre">mutex_trylock()</span></code></a> invece di sospendere il vostro processo
ritorna un valore diverso da zero se è possibile trattenere il lock al primo
colpo, altrimenti se fallisce ritorna 0. Nonostante non dorma, questa funzione
non può essere usata in modo sicuro in contesti di interruzione hardware o
software.</p>
</div>
<div class="section" id="esempi-piu-comuni">
<h2>Esempi più comuni<a class="headerlink" href="#esempi-piu-comuni" title="Permalink to this headline">¶</a></h2>
<p>Guardiamo un semplice esempio: una memoria che associa nomi a numeri.
La memoria tiene traccia di quanto spesso viene utilizzato ogni oggetto;
quando è piena, l’oggetto meno usato viene eliminato.</p>
<div class="section" id="tutto-in-contesto-utente">
<h3>Tutto in contesto utente<a class="headerlink" href="#tutto-in-contesto-utente" title="Permalink to this headline">¶</a></h3>
<p>Nel primo esempio, supponiamo che tutte le operazioni avvengano in contesto
utente (in soldoni, da una chiamata di sistema), quindi possiamo dormire.
Questo significa che possiamo usare i mutex per proteggere la nostra memoria
e tutti gli oggetti che contiene. Ecco il codice:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#include &lt;linux/list.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;asm/errno.h&gt;

struct object
{
        struct list_head list;
        int id;
        char name[32];
        int popularity;
};

/* Protects the cache, cache_num, and the objects within it */
static DEFINE_MUTEX(cache_lock);
static LIST_HEAD(cache);
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10

/* Must be holding cache_lock */
static struct object *__cache_find(int id)
{
        struct object *i;

        list_for_each_entry(i, &amp;cache, list)
                if (i-&gt;id == id) {
                        i-&gt;popularity++;
                        return i;
                }
        return NULL;
}

/* Must be holding cache_lock */
static void __cache_delete(struct object *obj)
{
        BUG_ON(!obj);
        list_del(&amp;obj-&gt;list);
        kfree(obj);
        cache_num--;
}

/* Must be holding cache_lock */
static void __cache_add(struct object *obj)
{
        list_add(&amp;obj-&gt;list, &amp;cache);
        if (++cache_num &gt; MAX_CACHE_SIZE) {
                struct object *i, *outcast = NULL;
                list_for_each_entry(i, &amp;cache, list) {
                        if (!outcast || i-&gt;popularity &lt; outcast-&gt;popularity)
                                outcast = i;
                }
                __cache_delete(outcast);
        }
}

int cache_add(int id, const char *name)
{
        struct object *obj;

        if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                return -ENOMEM;

        strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));
        obj-&gt;id = id;
        obj-&gt;popularity = 0;

        mutex_lock(&amp;cache_lock);
        __cache_add(obj);
        mutex_unlock(&amp;cache_lock);
        return 0;
}

void cache_delete(int id)
{
        mutex_lock(&amp;cache_lock);
        __cache_delete(__cache_find(id));
        mutex_unlock(&amp;cache_lock);
}

int cache_find(int id, char *name)
{
        struct object *obj;
        int ret = -ENOENT;

        mutex_lock(&amp;cache_lock);
        obj = __cache_find(id);
        if (obj) {
                ret = 0;
                strcpy(name, obj-&gt;name);
        }
        mutex_unlock(&amp;cache_lock);
        return ret;
}
</pre></div>
</div>
<p>Da notare che ci assicuriamo sempre di trattenere cache_lock quando
aggiungiamo, rimuoviamo od ispezioniamo la memoria: sia la struttura
della memoria che il suo contenuto sono protetti dal <em>lock</em>. Questo
caso è semplice dato che copiamo i dati dall’utente e non permettiamo
mai loro di accedere direttamente agli oggetti.</p>
<p>C’è una piccola ottimizzazione qui: nella funzione <code class="xref c c-func docutils literal"><span class="pre">cache_add()</span></code>
impostiamo i campi dell’oggetto prima di acquisire il <em>lock</em>. Questo è
sicuro perché nessun altro potrà accedervi finché non lo inseriremo
nella memoria.</p>
</div>
<div class="section" id="accesso-dal-contesto-utente">
<h3>Accesso dal contesto utente<a class="headerlink" href="#accesso-dal-contesto-utente" title="Permalink to this headline">¶</a></h3>
<p>Ora consideriamo il caso in cui <code class="xref c c-func docutils literal"><span class="pre">cache_find()</span></code> può essere invocata
dal contesto d’interruzione: sia hardware che software. Un esempio potrebbe
essere un timer che elimina oggetti dalla memoria.</p>
<p>Qui di seguito troverete la modifica nel formato <em>patch</em>: le righe <code class="docutils literal"><span class="pre">-</span></code>
sono quelle rimosse, mentre quelle <code class="docutils literal"><span class="pre">+</span></code> sono quelle aggiunte.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>--- cache.c.usercontext 2003-12-09 13:58:54.000000000 +1100
+++ cache.c.interrupt   2003-12-09 14:07:49.000000000 +1100
@@ -12,7 +12,7 @@
         int popularity;
 };

-static DEFINE_MUTEX(cache_lock);
+static DEFINE_SPINLOCK(cache_lock);
 static LIST_HEAD(cache);
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10
@@ -55,6 +55,7 @@
 int cache_add(int id, const char *name)
 {
         struct object *obj;
+        unsigned long flags;

         if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                 return -ENOMEM;
@@ -63,30 +64,33 @@
         obj-&gt;id = id;
         obj-&gt;popularity = 0;

-        mutex_lock(&amp;cache_lock);
+        spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
         return 0;
 }

 void cache_delete(int id)
 {
-        mutex_lock(&amp;cache_lock);
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_delete(__cache_find(id));
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
 }

 int cache_find(int id, char *name)
 {
         struct object *obj;
         int ret = -ENOENT;
+        unsigned long flags;

-        mutex_lock(&amp;cache_lock);
+        spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
         if (obj) {
                 ret = 0;
                 strcpy(name, obj-&gt;name);
         }
-        mutex_unlock(&amp;cache_lock);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
         return ret;
 }
</pre></div>
</div>
<p>Da notare che <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> disabiliterà le interruzioni
se erano attive, altrimenti non farà niente (quando siamo già in un contesto
d’interruzione); dunque queste funzioni possono essere chiamante in
sicurezza da qualsiasi contesto.</p>
<p>Sfortunatamente, <code class="xref c c-func docutils literal"><span class="pre">cache_add()</span></code> invoca <a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> con
l’opzione <code class="docutils literal"><span class="pre">GFP_KERNEL</span></code> che è permessa solo in contesto utente. Ho supposto
che <code class="xref c c-func docutils literal"><span class="pre">cache_add()</span></code> venga chiamata dal contesto utente, altrimenti
questa opzione deve diventare un parametro di <code class="xref c c-func docutils literal"><span class="pre">cache_add()</span></code>.</p>
</div>
<div class="section" id="exposing-objects-outside-this-file">
<h3>Exposing Objects Outside This File<a class="headerlink" href="#exposing-objects-outside-this-file" title="Permalink to this headline">¶</a></h3>
<p>Se i vostri oggetti contengono più informazioni, potrebbe non essere
sufficiente copiare i dati avanti e indietro: per esempio, altre parti del
codice potrebbero avere un puntatore a questi oggetti piuttosto che cercarli
ogni volta. Questo introduce due problemi.</p>
<p>Il primo problema è che utilizziamo <code class="docutils literal"><span class="pre">cache_lock</span></code> per proteggere gli oggetti:
dobbiamo renderlo dinamico così che il resto del codice possa usarlo. Questo
rende la sincronizzazione più complicata dato che non avviene più in un unico
posto.</p>
<p>Il secondo problema è il problema del ciclo di vita: se un’altra struttura
mantiene un puntatore ad un oggetto, presumibilmente si aspetta che questo
puntatore rimanga valido. Sfortunatamente, questo è garantito solo mentre
si trattiene il <em>lock</em>, altrimenti qualcuno potrebbe chiamare
<code class="xref c c-func docutils literal"><span class="pre">cache_delete()</span></code> o peggio, aggiungere un oggetto che riutilizza lo
stesso indirizzo.</p>
<p>Dato che c’è un solo <em>lock</em>, non potete trattenerlo a vita: altrimenti
nessun altro potrà eseguire il proprio lavoro.</p>
<p>La soluzione a questo problema è l’uso di un contatore di riferimenti:
chiunque punti ad un oggetto deve incrementare il contatore, e decrementarlo
quando il puntatore non viene più usato. Quando il contatore raggiunge lo zero
significa che non è più usato e l’oggetto può essere rimosso.</p>
<p>Ecco il codice:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>--- cache.c.interrupt   2003-12-09 14:25:43.000000000 +1100
+++ cache.c.refcnt  2003-12-09 14:33:05.000000000 +1100
@@ -7,6 +7,7 @@
 struct object
 {
         struct list_head list;
+        unsigned int refcnt;
         int id;
         char name[32];
         int popularity;
@@ -17,6 +18,35 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

+static void __object_put(struct object *obj)
+{
+        if (--obj-&gt;refcnt == 0)
+                kfree(obj);
+}
+
+static void __object_get(struct object *obj)
+{
+        obj-&gt;refcnt++;
+}
+
+void object_put(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
+        __object_put(obj);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
+}
+
+void object_get(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&amp;cache_lock, flags);
+        __object_get(obj);
+        spin_unlock_irqrestore(&amp;cache_lock, flags);
+}
+
 /* Must be holding cache_lock */
 static struct object *__cache_find(int id)
 {
@@ -35,6 +65,7 @@
 {
         BUG_ON(!obj);
         list_del(&amp;obj-&gt;list);
+        __object_put(obj);
         cache_num--;
 }

@@ -63,6 +94,7 @@
         strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
+        obj-&gt;refcnt = 1; /* The cache holds a reference */

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
@@ -79,18 +111,15 @@
         spin_unlock_irqrestore(&amp;cache_lock, flags);
 }

-int cache_find(int id, char *name)
+struct object *cache_find(int id)
 {
         struct object *obj;
-        int ret = -ENOENT;
         unsigned long flags;

         spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
-        if (obj) {
-                ret = 0;
-                strcpy(name, obj-&gt;name);
-        }
+        if (obj)
+                __object_get(obj);
         spin_unlock_irqrestore(&amp;cache_lock, flags);
-        return ret;
+        return obj;
 }
</pre></div>
</div>
<p>Abbiamo incapsulato il contatore di riferimenti nelle tipiche funzioni
di ‘get’ e ‘put’. Ora possiamo ritornare l’oggetto da <code class="xref c c-func docutils literal"><span class="pre">cache_find()</span></code>
col vantaggio che l’utente può dormire trattenendo l’oggetto (per esempio,
<code class="xref c c-func docutils literal"><span class="pre">copy_to_user()</span></code> per copiare il nome verso lo spazio utente).</p>
<p>Un altro punto da notare è che ho detto che il contatore dovrebbe incrementarsi
per ogni puntatore ad un oggetto: quindi il contatore di riferimenti è 1
quando l’oggetto viene inserito nella memoria. In altre versione il framework
non trattiene un riferimento per se, ma diventa più complicato.</p>
<div class="section" id="usare-operazioni-atomiche-per-il-contatore-di-riferimenti">
<h4>Usare operazioni atomiche per il contatore di riferimenti<a class="headerlink" href="#usare-operazioni-atomiche-per-il-contatore-di-riferimenti" title="Permalink to this headline">¶</a></h4>
<p>In sostanza, <code class="xref c c-type docutils literal"><span class="pre">atomic_t</span></code> viene usato come contatore di riferimenti.
Ci sono un certo numbero di operazioni atomiche definite
in <code class="docutils literal"><span class="pre">include/asm/atomic.h</span></code>: queste sono garantite come atomiche su qualsiasi
processore del sistema, quindi non sono necessari i <em>lock</em>. In questo caso è
più semplice rispetto all’uso degli spinlock, benché l’uso degli spinlock
sia più elegante per casi non banali. Le funzioni <code class="xref c c-func docutils literal"><span class="pre">atomic_inc()</span></code> e
<code class="xref c c-func docutils literal"><span class="pre">atomic_dec_and_test()</span></code> vengono usate al posto dei tipici operatori di
incremento e decremento, e i <em>lock</em> non sono più necessari per proteggere il
contatore stesso.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>--- cache.c.refcnt  2003-12-09 15:00:35.000000000 +1100
+++ cache.c.refcnt-atomic   2003-12-11 15:49:42.000000000 +1100
@@ -7,7 +7,7 @@
 struct object
 {
         struct list_head list;
-        unsigned int refcnt;
+        atomic_t refcnt;
         int id;
         char name[32];
         int popularity;
@@ -18,33 +18,15 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

-static void __object_put(struct object *obj)
-{
-        if (--obj-&gt;refcnt == 0)
-                kfree(obj);
-}
-
-static void __object_get(struct object *obj)
-{
-        obj-&gt;refcnt++;
-}
-
 void object_put(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;cache_lock, flags);
-        __object_put(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        if (atomic_dec_and_test(&amp;obj-&gt;refcnt))
+                kfree(obj);
 }

 void object_get(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&amp;cache_lock, flags);
-        __object_get(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        atomic_inc(&amp;obj-&gt;refcnt);
 }

 /* Must be holding cache_lock */
@@ -65,7 +47,7 @@
 {
         BUG_ON(!obj);
         list_del(&amp;obj-&gt;list);
-        __object_put(obj);
+        object_put(obj);
         cache_num--;
 }

@@ -94,7 +76,7 @@
         strlcpy(obj-&gt;name, name, sizeof(obj-&gt;name));
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
-        obj-&gt;refcnt = 1; /* The cache holds a reference */
+        atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
@@ -119,7 +101,7 @@
         spin_lock_irqsave(&amp;cache_lock, flags);
         obj = __cache_find(id);
         if (obj)
-                __object_get(obj);
+                object_get(obj);
         spin_unlock_irqrestore(&amp;cache_lock, flags);
         return obj;
 }
</pre></div>
</div>
</div>
</div>
<div class="section" id="proteggere-l-oggetto-stesso">
<h3>Proteggere l’oggetto stesso<a class="headerlink" href="#proteggere-l-oggetto-stesso" title="Permalink to this headline">¶</a></h3>
<p>In questo esempio, assumiamo che gli oggetti (ad eccezione del contatore
di riferimenti) non cambino mai dopo la loro creazione. Se vogliamo permettere
al nome di cambiare abbiamo tre possibilità:</p>
<ul class="simple">
<li>Si può togliere static da <code class="docutils literal"><span class="pre">cache_lock</span></code> e dire agli utenti che devono
trattenere il <em>lock</em> prima di modificare il nome di un oggetto.</li>
<li>Si può fornire una funzione <code class="xref c c-func docutils literal"><span class="pre">cache_obj_rename()</span></code> che prende il
<em>lock</em> e cambia il nome per conto del chiamante; si dirà poi agli utenti
di usare questa funzione.</li>
<li>Si può decidere che <code class="docutils literal"><span class="pre">cache_lock</span></code> protegge solo la memoria stessa, ed
un altro <em>lock</em> è necessario per la protezione del nome.</li>
</ul>
<p>Teoricamente, possiamo avere un <em>lock</em> per ogni campo e per ogni oggetto.
In pratica, le varianti più comuni sono:</p>
<ul class="simple">
<li>un <em>lock</em> che protegge l’infrastruttura (la lista <code class="docutils literal"><span class="pre">cache</span></code> di questo
esempio) e gli oggetti. Questo è quello che abbiamo fatto finora.</li>
<li>un <em>lock</em> che protegge l’infrastruttura (inclusi i puntatori alla lista
negli oggetti), e un <em>lock</em> nell’oggetto per proteggere il resto
dell’oggetto stesso.</li>
<li><em>lock</em> multipli per proteggere l’infrastruttura (per esempio un <em>lock</em>
per ogni lista), possibilmente con un <em>lock</em> per oggetto.</li>
</ul>
<p>Qui di seguito un’implementazione con “un lock per oggetto”:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>--- cache.c.refcnt-atomic   2003-12-11 15:50:54.000000000 +1100
+++ cache.c.perobjectlock   2003-12-11 17:15:03.000000000 +1100
@@ -6,11 +6,17 @@

 struct object
 {
+        /* These two protected by cache_lock. */
         struct list_head list;
+        int popularity;
+
         atomic_t refcnt;
+
+        /* Doesn&#39;t change once created. */
         int id;
+
+        spinlock_t lock; /* Protects the name */
         char name[32];
-        int popularity;
 };

 static DEFINE_SPINLOCK(cache_lock);
@@ -77,6 +84,7 @@
         obj-&gt;id = id;
         obj-&gt;popularity = 0;
         atomic_set(&amp;obj-&gt;refcnt, 1); /* The cache holds a reference */
+        spin_lock_init(&amp;obj-&gt;lock);

         spin_lock_irqsave(&amp;cache_lock, flags);
         __cache_add(obj);
</pre></div>
</div>
<p>Da notare che ho deciso che il contatore di popolarità dovesse essere
protetto da <code class="docutils literal"><span class="pre">cache_lock</span></code> piuttosto che dal <em>lock</em> dell’oggetto; questo
perché è logicamente parte dell’infrastruttura (come
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> nell’oggetto). In questo modo,
in <code class="xref c c-func docutils literal"><span class="pre">__cache_add()</span></code>, non ho bisogno di trattenere il <em>lock</em> di ogni
oggetto mentre si cerca il meno popolare.</p>
<p>Ho anche deciso che il campo id è immutabile, quindi non ho bisogno di
trattenere il lock dell’oggetto quando si usa <code class="xref c c-func docutils literal"><span class="pre">__cache_find()</span></code>
per leggere questo campo; il <em>lock</em> dell’oggetto è usato solo dal chiamante
che vuole leggere o scrivere il campo name.</p>
<p>Inoltre, da notare che ho aggiunto un commento che descrive i dati che sono
protetti dal <em>lock</em>. Questo è estremamente importante in quanto descrive il
comportamento del codice, che altrimenti sarebbe di difficile comprensione
leggendo solamente il codice. E come dice Alan Cox: “Lock data, not code”.</p>
</div>
</div>
<div class="section" id="problemi-comuni">
<h2>Problemi comuni<a class="headerlink" href="#problemi-comuni" title="Permalink to this headline">¶</a></h2>
<div class="section" id="stallo-semplice-ed-avanzato">
<span id="it-deadlock"></span><h3>Stallo: semplice ed avanzato<a class="headerlink" href="#stallo-semplice-ed-avanzato" title="Permalink to this headline">¶</a></h3>
<p>Esiste un tipo di  baco dove un pezzo di codice tenta di trattenere uno
spinlock due volte: questo rimarrà in attesa attiva per sempre aspettando che
il <em>lock</em> venga rilasciato (in Linux spinlocks, rwlocks e mutex non sono
ricorsivi).
Questo è facile da diagnosticare: non è uno di quei problemi che ti tengono
sveglio 5 notti a parlare da solo.</p>
<p>Un caso un pochino più complesso; immaginate d’avere una spazio condiviso
fra un softirq ed il contesto utente. Se usate <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> per
proteggerlo, il contesto utente potrebbe essere interrotto da un softirq
mentre trattiene il lock, da qui il softirq rimarrà in attesa attiva provando
ad acquisire il <em>lock</em> già trattenuto nel contesto utente.</p>
<p>Questi casi sono chiamati stalli (<em>deadlock</em>), e come mostrato qui sopra,
può succedere anche con un solo processore (Ma non sui sistemi
monoprocessore perché gli spinlock spariscano quando il kernel è compilato
con <code class="docutils literal"><span class="pre">CONFIG_SMP</span></code>=n. Nonostante ciò, nel secondo caso avrete comunque
una corruzione dei dati).</p>
<p>Questi casi sono facili da diagnosticare; sui sistemi multi-processore
il supervisione (<em>watchdog</em>) o l’opzione di compilazione <code class="docutils literal"><span class="pre">DEBUG_SPINLOCK</span></code>
(<code class="docutils literal"><span class="pre">include/linux/spinlock.h</span></code>) permettono di scovare immediatamente quando
succedono.</p>
<p>Esiste un caso più complesso che è conosciuto come l’abbraccio della morte;
questo coinvolge due o più <em>lock</em>. Diciamo che avete un vettore di hash in cui
ogni elemento è uno spinlock a cui è associata una lista di elementi con lo
stesso hash. In un gestore di interruzioni software, dovete modificare un
oggetto e spostarlo su un altro hash; quindi dovrete trattenete lo spinlock
del vecchio hash e di quello nuovo, quindi rimuovere l’oggetto dal vecchio ed
inserirlo nel nuovo.</p>
<p>Qui abbiamo due problemi. Primo, se il vostro codice prova a spostare un
oggetto all’interno della stessa lista, otterrete uno stallo visto che
tenterà di trattenere lo stesso <em>lock</em> due volte. Secondo, se la stessa
interruzione software su un altro processore sta tentando di spostare
un altro oggetto nella direzione opposta, potrebbe accadere quanto segue:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">CPU 1</th>
<th class="head">CPU 2</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Trattiene <em>lock</em> A -&gt; OK</td>
<td>Trattiene <em>lock</em> B -&gt; OK</td>
</tr>
<tr class="row-odd"><td>Trattiene <em>lock</em> B -&gt; attesa</td>
<td>Trattiene <em>lock</em> A -&gt; attesa</td>
</tr>
</tbody>
</table>
<p>Table: Conseguenze</p>
<p>Entrambe i processori rimarranno in attesa attiva sul <em>lock</em> per sempre,
aspettando che l’altro lo rilasci. Sembra e puzza come un blocco totale.</p>
</div>
<div class="section" id="prevenire-gli-stalli">
<h3>Prevenire gli stalli<a class="headerlink" href="#prevenire-gli-stalli" title="Permalink to this headline">¶</a></h3>
<p>I libri di testo vi diranno che se trattenete i <em>lock</em> sempre nello stesso
ordine non avrete mai un simile stallo. La pratica vi dirà che questo
approccio non funziona all’ingrandirsi del sistema: quando creo un nuovo
<em>lock</em> non ne capisco abbastanza del kernel per dire in quale dei 5000 <em>lock</em>
si incastrerà.</p>
<p>I <em>lock</em> migliori sono quelli incapsulati: non vengono esposti nei file di
intestazione, e non vengono mai trattenuti fuori dallo stesso file. Potete
rileggere questo codice e vedere che non ci sarà mai uno stallo perché
non tenterà mai di trattenere un altro <em>lock</em> quando lo ha già.
Le persone che usano il vostro codice non devono nemmeno sapere che voi
state usando dei <em>lock</em>.</p>
<p>Un classico problema deriva dall’uso di <em>callback</em> e di <em>hook</em>: se li
chiamate mentre trattenete un <em>lock</em>, rischiate uno stallo o un abbraccio
della morte (chi lo sa cosa farà una <em>callback</em>?).</p>
<div class="section" id="ossessiva-prevenzione-degli-stalli">
<h4>Ossessiva prevenzione degli stalli<a class="headerlink" href="#ossessiva-prevenzione-degli-stalli" title="Permalink to this headline">¶</a></h4>
<p>Gli stalli sono un problema, ma non così terribile come la corruzione dei dati.
Un pezzo di codice trattiene un <em>lock</em> di lettura, cerca in una lista,
fallisce nel trovare quello che vuole, quindi rilascia il <em>lock</em> di lettura,
trattiene un <em>lock</em> di scrittura ed inserisce un oggetto; questo genere di
codice presenta una corsa critica.</p>
<p>Se non riuscite a capire il perché, per favore state alla larga dal mio
codice.</p>
</div>
</div>
<div class="section" id="corsa-fra-temporizzatori-un-passatempo-del-kernel">
<h3>corsa fra temporizzatori: un passatempo del kernel<a class="headerlink" href="#corsa-fra-temporizzatori-un-passatempo-del-kernel" title="Permalink to this headline">¶</a></h3>
<p>I temporizzatori potrebbero avere dei problemi con le corse critiche.
Considerate una collezione di oggetti (liste, hash, eccetera) dove ogni oggetto
ha un temporizzatore che sta per distruggerlo.</p>
<p>Se volete eliminare l’intera collezione (diciamo quando rimuovete un modulo),
potreste fare come segue:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* THIS CODE BAD BAD BAD BAD: IF IT WAS ANY WORSE IT WOULD USE
   HUNGARIAN NOTATION */
spin_lock_bh(&amp;list_lock);

while (list) {
        struct foo *next = list-&gt;next;
        del_timer(&amp;list-&gt;timer);
        kfree(list);
        list = next;
}

spin_unlock_bh(&amp;list_lock);
</pre></div>
</div>
<p>Primo o poi, questo esploderà su un sistema multiprocessore perché un
temporizzatore potrebbe essere già partiro prima di <code class="xref c c-func docutils literal"><span class="pre">spin_lock_bh()</span></code>,
e prenderà il <em>lock</em> solo dopo <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_bh()</span></code>, e cercherà
di eliminare il suo oggetto (che però è già stato eliminato).</p>
<p>Questo può essere evitato controllando il valore di ritorno di
<a class="reference internal" href="../../../driver-api/basics.html#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal"><span class="pre">del_timer()</span></code></a>: se ritorna 1, il temporizzatore è stato già
rimosso. Se 0, significa (in questo caso) che il temporizzatore è in
esecuzione, quindi possiamo fare come segue:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>retry:
        spin_lock_bh(&amp;list_lock);

        while (list) {
                struct foo *next = list-&gt;next;
                if (!del_timer(&amp;list-&gt;timer)) {
                        /* Give timer a chance to delete this */
                        spin_unlock_bh(&amp;list_lock);
                        goto retry;
                }
                kfree(list);
                list = next;
        }

        spin_unlock_bh(&amp;list_lock);
</pre></div>
</div>
<p>Un altro problema è l’eliminazione dei temporizzatori che si riavviano
da soli (chiamando <a class="reference internal" href="../../../driver-api/basics.html#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal"><span class="pre">add_timer()</span></code></a> alla fine della loro esecuzione).
Dato che questo è un problema abbastanza comune con una propensione
alle corse critiche, dovreste usare <a class="reference internal" href="../../../driver-api/basics.html#c.del_timer_sync" title="del_timer_sync"><code class="xref c c-func docutils literal"><span class="pre">del_timer_sync()</span></code></a>
(<code class="docutils literal"><span class="pre">include/linux/timer.h</span></code>) per gestire questo caso. Questa ritorna il
numero di volte che il temporizzatore è stato interrotto prima che
fosse in grado di fermarlo senza che si riavviasse.</p>
</div>
</div>
<div class="section" id="velocita-della-sincronizzazione">
<h2>Velocità della sincronizzazione<a class="headerlink" href="#velocita-della-sincronizzazione" title="Permalink to this headline">¶</a></h2>
<p>Ci sono tre cose importanti da tenere in considerazione quando si valuta
la velocità d’esecuzione di un pezzo di codice che necessita di
sincronizzazione. La prima è la concorrenza: quante cose rimangono in attesa
mentre qualcuno trattiene un <em>lock</em>. La seconda è il tempo necessario per
acquisire (senza contese) e rilasciare un <em>lock</em>. La terza è di usare meno
<em>lock</em> o di più furbi. Immagino che i <em>lock</em> vengano usati regolarmente,
altrimenti, non sareste interessati all’efficienza.</p>
<p>La concorrenza dipende da quanto a lungo un <em>lock</em> è trattenuto: dovreste
trattenere un <em>lock</em> solo il tempo minimo necessario ma non un istante in più.
Nella memoria dell’esempio precedente, creiamo gli oggetti senza trattenere
il <em>lock</em>, poi acquisiamo il <em>lock</em> quando siamo pronti per inserirlo nella
lista.</p>
<p>Il tempo di acquisizione di un <em>lock</em> dipende da quanto danno fa
l’operazione sulla <em>pipeline</em> (ovvero stalli della <em>pipeline</em>) e quant’è
probabile che il processore corrente sia stato anche l’ultimo ad acquisire
il <em>lock</em> (in pratica, il <em>lock</em> è nella memoria cache del processore
corrente?): su sistemi multi-processore questa probabilità precipita
rapidamente. Consideriamo un processore Intel Pentium III a 700Mhz: questo
esegue un’istruzione in 0.7ns, un incremento atomico richiede 58ns, acquisire
un <em>lock</em> che è nella memoria cache del processore richiede 160ns, e un
trasferimento dalla memoria cache di un altro processore richiede altri
170/360ns (Leggetevi l’articolo di Paul McKenney’s <a class="reference external" href="http://www.linuxjournal.com/article.php?sid=6993">Linux Journal RCU
article</a>).</p>
<p>Questi due obiettivi sono in conflitto: trattenere un <em>lock</em> per il minor
tempo possibile potrebbe richiedere la divisione in più <em>lock</em> per diverse
parti (come nel nostro ultimo esempio con un <em>lock</em> per ogni oggetto),
ma questo aumenta il numero di acquisizioni di <em>lock</em>, ed il risultato
spesso è che tutto è più lento che con un singolo <em>lock</em>. Questo è un altro
argomento in favore della semplicità quando si parla di sincronizzazione.</p>
<p>Il terzo punto è discusso di seguito: ci sono alcune tecniche per ridurre
il numero di sincronizzazioni che devono essere fatte.</p>
<div class="section" id="read-write-lock-variants">
<h3>Read/Write Lock Variants<a class="headerlink" href="#read-write-lock-variants" title="Permalink to this headline">¶</a></h3>
<p>Sia gli spinlock che i mutex hanno una variante per la lettura/scrittura
(read/write): <code class="docutils literal"><span class="pre">rwlock_t</span></code> e <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">rw_semaphore</span></code>.
Queste dividono gli utenti in due categorie: i lettori e gli scrittori.
Se state solo leggendo i dati, potete acquisire il <em>lock</em> di lettura, ma
per scrivere avrete bisogno del <em>lock</em> di scrittura. Molti possono trattenere
il <em>lock</em> di lettura, ma solo uno scrittore alla volta può trattenere
quello di scrittura.</p>
<p>Se il vostro codice si divide chiaramente in codice per lettori e codice
per scrittori (come nel nostro esempio), e il <em>lock</em> dei lettori viene
trattenuto per molto tempo, allora l’uso di questo tipo di <em>lock</em> può aiutare.
Questi sono leggermente più lenti rispetto alla loro versione normale, quindi
nella pratica l’uso di <code class="docutils literal"><span class="pre">rwlock_t</span></code> non ne vale la pena.</p>
</div>
<div class="section" id="evitare-i-lock-read-copy-update">
<h3>Evitare i <em>lock</em>: Read Copy Update<a class="headerlink" href="#evitare-i-lock-read-copy-update" title="Permalink to this headline">¶</a></h3>
<p>Esiste un metodo di sincronizzazione per letture e scritture detto
Read Copy Update. Con l’uso della tecnica RCU, i lettori possono scordarsi
completamente di trattenere i <em>lock</em>; dato che nel nostro esempio ci
aspettiamo d’avere più lettore che scrittori (altrimenti questa memoria
sarebbe uno spreco) possiamo dire che questo meccanismo permette
un’ottimizzazione.</p>
<p>Come facciamo a sbarazzarci dei <em>lock</em> di lettura? Sbarazzarsi dei <em>lock</em> di
lettura significa che uno scrittore potrebbe cambiare la lista sotto al naso
dei lettori. Questo è abbastanza semplice: possiamo leggere una lista
concatenata se lo scrittore aggiunge elementi alla fine e con certe
precauzioni. Per esempio, aggiungendo <code class="docutils literal"><span class="pre">new</span></code> ad una lista concatenata
chiamata <code class="docutils literal"><span class="pre">list</span></code>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>new-&gt;next = list-&gt;next;
wmb();
list-&gt;next = new;
</pre></div>
</div>
<p>La funzione <code class="xref c c-func docutils literal"><span class="pre">wmb()</span></code> è una barriera di sincronizzazione delle
scritture. Questa garantisce che la prima operazione (impostare l’elemento
<code class="docutils literal"><span class="pre">next</span></code> del nuovo elemento) venga completata e vista da tutti i processori
prima che venga eseguita la seconda operazione (che sarebbe quella di mettere
il nuovo elemento nella lista). Questo è importante perché i moderni
compilatori ed i moderni processori possono, entrambe, riordinare le istruzioni
se non vengono istruiti altrimenti: vogliamo che i lettori non vedano
completamente il nuovo elemento; oppure che lo vedano correttamente e quindi
il puntatore <code class="docutils literal"><span class="pre">next</span></code> deve puntare al resto della lista.</p>
<p>Fortunatamente, c’è una funzione che fa questa operazione sulle liste
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code>: <a class="reference internal" href="../../../core-api/kernel-api.html#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>
(<code class="docutils literal"><span class="pre">include/linux/list.h</span></code>).</p>
<p>Rimuovere un elemento dalla lista è anche più facile: sostituiamo il puntatore
al vecchio elemento con quello del suo successore, e i lettori vedranno
l’elemento o lo salteranno.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>list-&gt;next = old-&gt;next;
</pre></div>
</div>
<p>La funzione <a class="reference internal" href="../../../core-api/kernel-api.html#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_del_rcu()</span></code></a> (<code class="docutils literal"><span class="pre">include/linux/list.h</span></code>) fa esattamente
questo (la versione normale corrompe il vecchio oggetto, e non vogliamo che
accada).</p>
<p>Anche i lettori devono stare attenti: alcuni processori potrebbero leggere
attraverso il puntatore <code class="docutils literal"><span class="pre">next</span></code> il contenuto dell’elemento successivo
troppo presto, ma non accorgersi che il contenuto caricato è sbagliato quando
il puntatore <code class="docutils literal"><span class="pre">next</span></code> viene modificato alla loro spalle. Ancora una volta
c’è una funzione che viene in vostro aiuto <a class="reference internal" href="../../../core-api/kernel-api.html#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_rcu()</span></code></a>
(<code class="docutils literal"><span class="pre">include/linux/list.h</span></code>). Ovviamente, gli scrittori possono usare
<a class="reference internal" href="../../../core-api/kernel-api.html#c.list_for_each_entry" title="list_for_each_entry"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry()</span></code></a> dato che non ci possono essere due scrittori
in contemporanea.</p>
<p>Il nostro ultimo dilemma è il seguente: quando possiamo realmente distruggere
l’elemento rimosso? Ricordate, un lettore potrebbe aver avuto accesso a questo
elemento proprio ora: se eliminiamo questo elemento ed il puntatore <code class="docutils literal"><span class="pre">next</span></code>
cambia, il lettore salterà direttamente nella spazzatura e scoppierà. Dobbiamo
aspettare finché tutti i lettori che stanno attraversando la lista abbiano
finito. Utilizziamo <a class="reference internal" href="../../../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> per registrare una funzione di
richiamo che distrugga l’oggetto quando tutti i lettori correnti hanno
terminato. In alternative, potrebbe essere usata la funzione
<a class="reference internal" href="../../../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> che blocca l’esecuzione finché tutti i lettori
non terminano di ispezionare la lista.</p>
<p>Ma come fa l’RCU a sapere quando i lettori sono finiti? Il meccanismo è
il seguente: innanzi tutto i lettori accedono alla lista solo fra la coppia
<a class="reference internal" href="../../../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>/<a class="reference internal" href="../../../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> che disabilita la
prelazione così che i lettori non vengano sospesi mentre stanno leggendo
la lista.</p>
<p>Poi, l’RCU aspetta finché tutti i processori non abbiano dormito almeno
una volta; a questo punto, dato che i lettori non possono dormire, possiamo
dedurre che un qualsiasi lettore che abbia consultato la lista durante la
rimozione abbia già terminato, quindi la <em>callback</em> viene eseguita. Il vero
codice RCU è un po’ più ottimizzato di così, ma questa è l’idea di fondo.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>--- cache.c.perobjectlock   2003-12-11 17:15:03.000000000 +1100
+++ cache.c.rcupdate    2003-12-11 17:55:14.000000000 +1100
@@ -1,15 +1,18 @@
 #include &lt;linux/list.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/string.h&gt;
+#include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;asm/errno.h&gt;

 struct object
 {
-        /* These two protected by cache_lock. */
+        /* This is protected by RCU */
         struct list_head list;
         int popularity;

+        struct rcu_head rcu;
+
         atomic_t refcnt;

         /* Doesn&#39;t change once created. */
@@ -40,7 +43,7 @@
 {
         struct object *i;

-        list_for_each_entry(i, &amp;cache, list) {
+        list_for_each_entry_rcu(i, &amp;cache, list) {
                 if (i-&gt;id == id) {
                         i-&gt;popularity++;
                         return i;
@@ -49,19 +52,25 @@
         return NULL;
 }

+/* Final discard done once we know no readers are looking. */
+static void cache_delete_rcu(void *arg)
+{
+        object_put(arg);
+}
+
 /* Must be holding cache_lock */
 static void __cache_delete(struct object *obj)
 {
         BUG_ON(!obj);
-        list_del(&amp;obj-&gt;list);
-        object_put(obj);
+        list_del_rcu(&amp;obj-&gt;list);
         cache_num--;
+        call_rcu(&amp;obj-&gt;rcu, cache_delete_rcu);
 }

 /* Must be holding cache_lock */
 static void __cache_add(struct object *obj)
 {
-        list_add(&amp;obj-&gt;list, &amp;cache);
+        list_add_rcu(&amp;obj-&gt;list, &amp;cache);
         if (++cache_num &gt; MAX_CACHE_SIZE) {
                 struct object *i, *outcast = NULL;
                 list_for_each_entry(i, &amp;cache, list) {
@@ -104,12 +114,11 @@
 struct object *cache_find(int id)
 {
         struct object *obj;
-        unsigned long flags;

-        spin_lock_irqsave(&amp;cache_lock, flags);
+        rcu_read_lock();
         obj = __cache_find(id);
         if (obj)
                 object_get(obj);
-        spin_unlock_irqrestore(&amp;cache_lock, flags);
+        rcu_read_unlock();
         return obj;
 }
</pre></div>
</div>
<p>Da notare che i lettori modificano il campo popularity nella funzione
<code class="xref c c-func docutils literal"><span class="pre">__cache_find()</span></code>, e ora non trattiene alcun <em>lock</em>. Una soluzione
potrebbe essere quella di rendere la variabile <code class="docutils literal"><span class="pre">atomic_t</span></code>, ma per l’uso
che ne abbiamo fatto qui, non ci interessano queste corse critiche perché un
risultato approssimativo è comunque accettabile, quindi non l’ho cambiato.</p>
<p>Il risultato è che la funzione <code class="xref c c-func docutils literal"><span class="pre">cache_find()</span></code> non ha bisogno di alcuna
sincronizzazione con le altre funzioni, quindi è veloce su un sistema
multi-processore tanto quanto lo sarebbe su un sistema mono-processore.</p>
<p>Esiste un’ulteriore ottimizzazione possibile: vi ricordate il codice originale
della nostra memoria dove non c’erano contatori di riferimenti e il chiamante
semplicemente tratteneva il <em>lock</em> prima di accedere ad un oggetto? Questo è
ancora possibile: se trattenete un <em>lock</em> nessuno potrà cancellare l’oggetto,
quindi non avete bisogno di incrementare e decrementare il contatore di
riferimenti.</p>
<p>Ora, dato che il ‘<em>lock</em> di lettura’ di un RCU non fa altro che disabilitare
la prelazione, un chiamante che ha sempre la prelazione disabilitata fra le
chiamate <code class="xref c c-func docutils literal"><span class="pre">cache_find()</span></code> e <code class="xref c c-func docutils literal"><span class="pre">object_put()</span></code> non necessita
di incrementare e decrementare il contatore di riferimenti. Potremmo
esporre la funzione <code class="xref c c-func docutils literal"><span class="pre">__cache_find()</span></code> dichiarandola non-static,
e quel chiamante potrebbe usare direttamente questa funzione.</p>
<p>Il beneficio qui sta nel fatto che il contatore di riferimenti no
viene scritto: l’oggetto non viene alterato in alcun modo e quindi diventa
molto più veloce su sistemi molti-processore grazie alla loro memoria cache.</p>
</div>
<div class="section" id="dati-per-processore">
<span id="it-per-cpu"></span><h3>Dati per processore<a class="headerlink" href="#dati-per-processore" title="Permalink to this headline">¶</a></h3>
<p>Un’altra tecnica comunemente usata per evitare la sincronizzazione è quella
di duplicare le informazioni per ogni processore. Per esempio, se volete
avere un contatore di qualcosa, potreste utilizzare uno spinlock ed un
singolo contatore. Facile e pulito.</p>
<p>Se questo dovesse essere troppo lento (solitamente non lo è, ma se avete
dimostrato che lo è devvero), potreste usare un contatore per ogni processore
e quindi non sarebbe più necessaria la mutua esclusione. Vedere
<code class="xref c c-func docutils literal"><span class="pre">DEFINE_PER_CPU()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">get_cpu_var()</span></code> e <code class="xref c c-func docutils literal"><span class="pre">put_cpu_var()</span></code>
(<code class="docutils literal"><span class="pre">include/linux/percpu.h</span></code>).</p>
<p>Il tipo di dato <code class="docutils literal"><span class="pre">local_t</span></code>, la funzione <code class="xref c c-func docutils literal"><span class="pre">cpu_local_inc()</span></code> e tutte
le altre funzioni associate, sono di particolare utilità per semplici contatori
per-processore; su alcune architetture sono anche più efficienti
(<code class="docutils literal"><span class="pre">include/asm/local.h</span></code>).</p>
<p>Da notare che non esiste un modo facile ed affidabile per ottenere il valore
di un simile contatore senza introdurre altri <em>lock</em>. In alcuni casi questo
non è un problema.</p>
</div>
<div class="section" id="dati-che-sono-usati-prevalentemente-dai-gestori-d-interruzioni">
<h3>Dati che sono usati prevalentemente dai gestori d’interruzioni<a class="headerlink" href="#dati-che-sono-usati-prevalentemente-dai-gestori-d-interruzioni" title="Permalink to this headline">¶</a></h3>
<p>Se i dati vengono utilizzati sempre dallo stesso gestore d’interruzioni,
allora i <em>lock</em> non vi servono per niente: il kernel già vi garantisce che
il gestore d’interruzione non verrà eseguito in contemporanea su diversi
processori.</p>
<p>Manfred Spraul fa notare che potreste comunque comportarvi così anche
se i dati vengono occasionalmente utilizzati da un contesto utente o
da un’interruzione software. Il gestore d’interruzione non utilizza alcun
<em>lock</em>, e tutti gli altri accessi verranno fatti così:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>spin_lock(&amp;lock);
disable_irq(irq);
...
enable_irq(irq);
spin_unlock(&amp;lock);
</pre></div>
</div>
<p>La funzione <a class="reference internal" href="../../../core-api/kernel-api.html#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code></a> impedisce al gestore d’interruzioni
d’essere eseguito (e aspetta che finisca nel caso fosse in esecuzione su
un altro processore). Lo spinlock, invece, previene accessi simultanei.
Naturalmente, questo è più lento della semplice chiamata
<code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code>, quindi ha senso solo se questo genere di accesso
è estremamente raro.</p>
</div>
</div>
<div class="section" id="quali-funzioni-possono-essere-chiamate-in-modo-sicuro-dalle-interruzioni">
<span id="it-sleeping-things"></span><h2>Quali funzioni possono essere chiamate in modo sicuro dalle interruzioni?<a class="headerlink" href="#quali-funzioni-possono-essere-chiamate-in-modo-sicuro-dalle-interruzioni" title="Permalink to this headline">¶</a></h2>
<p>Molte funzioni del kernel dormono (in sostanza, chiamano <code class="docutils literal"><span class="pre">schedule()</span></code>)
direttamente od indirettamente: non potete chiamarle se trattenere uno
spinlock o avete la prelazione disabilitata, mai. Questo significa che
dovete necessariamente essere nel contesto utente: chiamarle da un
contesto d’interruzione è illegale.</p>
<div class="section" id="alcune-funzioni-che-dormono">
<h3>Alcune funzioni che dormono<a class="headerlink" href="#alcune-funzioni-che-dormono" title="Permalink to this headline">¶</a></h3>
<p>Le più comuni sono elencate qui di seguito, ma solitamente dovete leggere
il codice per scoprire se altre chiamate sono sicure. Se chiunque altro
le chiami dorme, allora dovreste poter dormire anche voi. In particolar
modo, le funzioni di registrazione e deregistrazione solitamente si
aspettano d’essere chiamante da un contesto utente e quindi che possono
dormire.</p>
<ul>
<li><p class="first">Accessi allo spazio utente:</p>
<ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">copy_from_user()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">copy_to_user()</span></code></li>
<li><a class="reference internal" href="../../../core-api/mm-api.html#c.get_user" title="get_user"><code class="xref c c-func docutils literal"><span class="pre">get_user()</span></code></a></li>
<li><a class="reference internal" href="../../../core-api/mm-api.html#c.put_user" title="put_user"><code class="xref c c-func docutils literal"><span class="pre">put_user()</span></code></a></li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="../../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc(GFP_KERNEL)</span></code></a></p>
</li>
<li><p class="first"><a class="reference internal" href="#c.mutex_lock_interruptible" title="mutex_lock_interruptible"><code class="xref c c-func docutils literal"><span class="pre">mutex_lock_interruptible()</span></code></a> and
<a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal"><span class="pre">mutex_lock()</span></code></a></p>
<p>C’è anche <a class="reference internal" href="#c.mutex_trylock" title="mutex_trylock"><code class="xref c c-func docutils literal"><span class="pre">mutex_trylock()</span></code></a> che però non dorme.
Comunque, non deve essere usata in un contesto d’interruzione dato
che la sua implementazione non è sicura in quel contesto.
Anche <a class="reference internal" href="#c.mutex_unlock" title="mutex_unlock"><code class="xref c c-func docutils literal"><span class="pre">mutex_unlock()</span></code></a> non dorme mai. Non può comunque essere
usata in un contesto d’interruzione perché un mutex deve essere rilasciato
dallo stesso processo che l’ha acquisito.</p>
</li>
</ul>
</div>
<div class="section" id="alcune-funzioni-che-non-dormono">
<h3>Alcune funzioni che non dormono<a class="headerlink" href="#alcune-funzioni-che-non-dormono" title="Permalink to this headline">¶</a></h3>
<p>Alcune funzioni possono essere chiamate tranquillamente da qualsiasi
contesto, o trattenendo un qualsiasi <em>lock</em>.</p>
<ul class="simple">
<li><a class="reference internal" href="../../../driver-api/basics.html#c.printk" title="printk"><code class="xref c c-func docutils literal"><span class="pre">printk()</span></code></a></li>
<li><a class="reference internal" href="../../../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a></li>
<li><a class="reference internal" href="../../../driver-api/basics.html#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal"><span class="pre">add_timer()</span></code></a> e <a class="reference internal" href="../../../driver-api/basics.html#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal"><span class="pre">del_timer()</span></code></a></li>
</ul>
</div>
</div>
<div class="section" id="riferimento-per-l-api-dei-mutex">
<h2>Riferimento per l’API dei Mutex<a class="headerlink" href="#riferimento-per-l-api-dei-mutex" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.mutex_init">
<code class="descname">mutex_init</code><span class="sig-paren">(</span><em>mutex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the mutex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>the mutex to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the mutex to unlocked state.</p>
<p>It is not allowed to initialize an already locked mutex.</p>
<dl class="function">
<dt id="c.mutex_is_locked">
bool <code class="descname">mutex_is_locked</code><span class="sig-paren">(</span>struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>is the mutex locked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the mutex to be queried</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the mutex is locked, false if unlocked.</p>
<dl class="function">
<dt id="c.mutex_trylock_recursive">
enum mutex_trylock_recursive_enum <code class="descname">mutex_trylock_recursive</code><span class="sig-paren">(</span>struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_trylock_recursive" title="Permalink to this definition">¶</a></dt>
<dd><p>trylock variant that allows recursive locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>mutex to be locked</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should not be used, _ever_. It is purely for hysterical GEM
raisins, and once those are gone this will be removed.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>MUTEX_TRYLOCK_FAILED    - trylock failed,</li>
<li>MUTEX_TRYLOCK_SUCCESS   - lock acquired,</li>
<li>MUTEX_TRYLOCK_RECURSIVE - we already owned the lock.</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.mutex_lock">
void <code class="descname">mutex_lock</code><span class="sig-paren">(</span>struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire the mutex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the mutex to be acquired</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex exclusively for this task. If the mutex is not
available right now, it will sleep until it can get it.</p>
<p>The mutex must later on be released by the same task that
acquired it. Recursive locking is not allowed. The task
may not exit without first unlocking the mutex. Also, kernel
memory where the mutex resides must not be freed with
the mutex still locked. The mutex must first be initialized
(or statically defined) before it can be locked. <a class="reference internal" href="../../../core-api/kernel-api.html#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a>-ing
the mutex to 0 is not allowed.</p>
<p>(The CONFIG_DEBUG_MUTEXES .config option turns on debugging
checks that will enforce the restrictions and will also do
deadlock debugging)</p>
<p>This function is similar to (but not equivalent to) <code class="xref c c-func docutils literal"><span class="pre">down()</span></code>.</p>
<dl class="function">
<dt id="c.mutex_unlock">
void <code class="descname">mutex_unlock</code><span class="sig-paren">(</span>struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the mutex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the mutex to be released</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock a mutex that has been locked by this task previously.</p>
<p>This function must not be used in interrupt context. Unlocking
of a not locked mutex is not allowed.</p>
<p>This function is similar to (but not equivalent to) <code class="xref c c-func docutils literal"><span class="pre">up()</span></code>.</p>
<dl class="function">
<dt id="c.ww_mutex_unlock">
void <code class="descname">ww_mutex_unlock</code><span class="sig-paren">(</span>struct ww_mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ww_mutex_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>release the w/w mutex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ww_mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the mutex to be released</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlock a mutex that has been locked by this task previously with any of the
ww_mutex_lock* functions (with or without an acquire context). It is
forbidden to release the locks after releasing the acquire context.</p>
<p>This function must not be used in interrupt context. Unlocking
of a unlocked mutex is not allowed.</p>
<dl class="function">
<dt id="c.mutex_lock_interruptible">
int <code class="descname">mutex_lock_interruptible</code><span class="sig-paren">(</span>struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_lock_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex, interruptible by signals.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>The mutex to be acquired.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal"><span class="pre">mutex_lock()</span></code></a>.  If a signal is delivered while the
process is sleeping, this function will return without acquiring the
mutex.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
<p><strong>Return</strong></p>
<p>0 if the lock was successfully acquired or <code class="docutils literal"><span class="pre">-EINTR</span></code> if a
signal arrived.</p>
<dl class="function">
<dt id="c.mutex_lock_killable">
int <code class="descname">mutex_lock_killable</code><span class="sig-paren">(</span>struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_lock_killable" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex, interruptible by fatal signals.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>The mutex to be acquired.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal"><span class="pre">mutex_lock()</span></code></a>.  If a signal which will be fatal to
the current process is delivered while the process is sleeping, this
function will return without acquiring the mutex.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
<p><strong>Return</strong></p>
<p>0 if the lock was successfully acquired or <code class="docutils literal"><span class="pre">-EINTR</span></code> if a
fatal signal arrived.</p>
<dl class="function">
<dt id="c.mutex_lock_io">
void <code class="descname">mutex_lock_io</code><span class="sig-paren">(</span>struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_lock_io" title="Permalink to this definition">¶</a></dt>
<dd><p>Acquire the mutex and mark the process as waiting for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>The mutex to be acquired.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock the mutex like <a class="reference internal" href="#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal"><span class="pre">mutex_lock()</span></code></a>.  While the task is waiting for this
mutex, it will be accounted as being in the IO wait state by the
scheduler.</p>
<p><strong>Context</strong></p>
<p>Process context.</p>
<dl class="function">
<dt id="c.mutex_trylock">
int <code class="descname">mutex_trylock</code><span class="sig-paren">(</span>struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mutex_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>try to acquire the mutex, without waiting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the mutex to be acquired</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to acquire the mutex atomically. Returns 1 if the mutex
has been acquired successfully, and 0 on contention.</p>
<p><strong>NOTE</strong></p>
<p>this function follows the <code class="xref c c-func docutils literal"><span class="pre">spin_trylock()</span></code> convention, so
it is negated from the <code class="xref c c-func docutils literal"><span class="pre">down_trylock()</span></code> return values! Be careful
about this when converting semaphore users to mutexes.</p>
<p>This function must not be used in interrupt context. The
mutex must be released by the same task that acquired it.</p>
<dl class="function">
<dt id="c.atomic_dec_and_mutex_lock">
int <code class="descname">atomic_dec_and_mutex_lock</code><span class="sig-paren">(</span>atomic_t *<em>&nbsp;cnt</em>, struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.atomic_dec_and_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding mutex if we dec to 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">cnt</span></code></dt>
<dd>the atomic which we are to dec</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the mutex to return holding if we dec to 0</dd>
</dl>
<p><strong>Description</strong></p>
<p>return true and hold lock if we dec to 0, return false otherwise</p>
</div>
<div class="section" id="riferimento-per-l-api-dei-futex">
<h2>Riferimento per l’API dei Futex<a class="headerlink" href="#riferimento-per-l-api-dei-futex" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.futex_q">
struct <code class="descname">futex_q</code><a class="headerlink" href="#c.futex_q" title="Permalink to this definition">¶</a></dt>
<dd><p>The hashed futex queue entry, one per waiting task</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct futex_q {
  struct plist_node list;
  struct task_struct *task;
  spinlock_t *lock_ptr;
  union futex_key key;
  struct futex_pi_state *pi_state;
  struct rt_mutex_waiter *rt_waiter;
  union futex_key *requeue_pi_key;
  u32 bitset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>priority-sorted list of tasks waiting on this futex</dd>
<dt><code class="docutils literal"><span class="pre">task</span></code></dt>
<dd>the task waiting on the futex</dd>
<dt><code class="docutils literal"><span class="pre">lock_ptr</span></code></dt>
<dd>the hash bucket lock</dd>
<dt><code class="docutils literal"><span class="pre">key</span></code></dt>
<dd>the key the futex is hashed on</dd>
<dt><code class="docutils literal"><span class="pre">pi_state</span></code></dt>
<dd>optional priority inheritance state</dd>
<dt><code class="docutils literal"><span class="pre">rt_waiter</span></code></dt>
<dd>rt_waiter storage for use with requeue_pi</dd>
<dt><code class="docutils literal"><span class="pre">requeue_pi_key</span></code></dt>
<dd>the requeue_pi target futex key</dd>
<dt><code class="docutils literal"><span class="pre">bitset</span></code></dt>
<dd>bitset for the optional bitmasked wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<p>We use this hashed waitqueue, instead of a normal wait_queue_entry_t, so
we can wake only the relevant ones (hashed queues may be shared).</p>
<p>A futex_q has a woken state, just like tasks have TASK_RUNNING.
It is considered woken when plist_node_empty(<code class="xref c c-type docutils literal"><span class="pre">q-&gt;list</span></code>) || q-&gt;lock_ptr == 0.
The order of wakeup is always to make the first condition true, then
the second.</p>
<p>PI futexes are typically woken before they are removed from the hash list via
the rt_mutex code. See <code class="xref c c-func docutils literal"><span class="pre">unqueue_me_pi()</span></code>.</p>
<dl class="function">
<dt id="c.hash_futex">
struct futex_hash_bucket * <code class="descname">hash_futex</code><span class="sig-paren">(</span>union futex_key *<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hash_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the hash bucket in the global hash</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>Pointer to the futex key for which the hash is calculated</dd>
</dl>
<p><strong>Description</strong></p>
<p>We hash on the keys returned from get_futex_key (see below) and return the
corresponding hash bucket in the global hash.</p>
<dl class="function">
<dt id="c.match_futex">
int <code class="descname">match_futex</code><span class="sig-paren">(</span>union futex_key *<em>&nbsp;key1</em>, union futex_key *<em>&nbsp;key2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.match_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether two futex keys are equal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key1</span></code></dt>
<dd>Pointer to key1</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key2</span></code></dt>
<dd>Pointer to key2</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 1 if two futex_keys are equal, 0 otherwise.</p>
<dl class="function">
<dt id="c.get_futex_key">
int <code class="descname">get_futex_key</code><span class="sig-paren">(</span>u32 __user *<em>&nbsp;uaddr</em>, int<em>&nbsp;fshared</em>, union futex_key *<em>&nbsp;key</em>, int<em>&nbsp;rw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_futex_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters which are the keys for a futex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr</span></code></dt>
<dd>virtual address of the futex</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fshared</span></code></dt>
<dd>0 for a PROCESS_PRIVATE futex, 1 for PROCESS_SHARED</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>address where result is stored.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">rw</span></code></dt>
<dd>mapping needs to be read/write (values: VERIFY_READ,
VERIFY_WRITE)</dd>
</dl>
<p><strong>Return</strong></p>
<p>a negative error code or 0</p>
<p>The key words are stored in <strong>key</strong> on success.</p>
<p>For shared mappings, it’s (page-&gt;index, file_inode(vma-&gt;vm_file),
offset_within_page).  For private mappings, it’s (uaddr, current-&gt;mm).
We can usually work out the index without swapping in the page.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">lock_page()</span></code> might sleep, the caller should not hold a spinlock.</p>
<dl class="function">
<dt id="c.fault_in_user_writeable">
int <code class="descname">fault_in_user_writeable</code><span class="sig-paren">(</span>u32 __user *<em>&nbsp;uaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fault_in_user_writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>Fault in user address and verify RW access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr</span></code></dt>
<dd>pointer to faulting user space address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Slow path to fixup the fault we just took in the atomic write
access to <strong>uaddr</strong>.</p>
<p>We have no generic implementation of a non-destructive write to the
user address. We know that we faulted in the atomic pagefault
disabled section so we can as well avoid the #PF overhead by
calling <code class="xref c c-func docutils literal"><span class="pre">get_user_pages()</span></code> right away.</p>
<dl class="function">
<dt id="c.futex_top_waiter">
struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> * <code class="descname">futex_top_waiter</code><span class="sig-paren">(</span>struct futex_hash_bucket *<em>&nbsp;hb</em>, union futex_key *<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_top_waiter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the highest priority waiter on a futex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb</span></code></dt>
<dd>the hash bucket the futex_q’s reside in</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>the futex key (to distinguish it from other futex futex_q’s)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called with the hb lock held.</p>
<dl class="function">
<dt id="c.futex_lock_pi_atomic">
int <code class="descname">futex_lock_pi_atomic</code><span class="sig-paren">(</span>u32 __user *<em>&nbsp;uaddr</em>, struct futex_hash_bucket *<em>&nbsp;hb</em>, union futex_key *<em>&nbsp;key</em>, struct futex_pi_state **<em>&nbsp;ps</em>, struct task_struct *<em>&nbsp;task</em>, int<em>&nbsp;set_waiters</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_lock_pi_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomic work required to acquire a pi aware futex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr</span></code></dt>
<dd>the pi futex user address</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb</span></code></dt>
<dd>the pi futex hash bucket</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>the futex key associated with uaddr and hb</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_pi_state</span> <span class="pre">**</span> <span class="pre">ps</span></code></dt>
<dd>the pi_state pointer where we store the result of the
lookup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>the task to perform the atomic lock work for.  This will
be “current” except in the case of requeue pi.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">set_waiters</span></code></dt>
<dd>force setting the FUTEX_WAITERS bit (1) or not (0)</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>0 - ready to wait;</li>
<li>1 - acquired the lock;</li>
<li>&lt;0 - error</li>
</ul>
</div></blockquote>
<p>The hb-&gt;lock and futex_key refs shall be held by the caller.</p>
<dl class="function">
<dt id="c.__unqueue_futex">
void <code class="descname">__unqueue_futex</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__unqueue_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the futex_q from its futex_hash_bucket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The futex_q to unqueue</dd>
</dl>
<p><strong>Description</strong></p>
<p>The q-&gt;lock_ptr must not be NULL and must be held by the caller.</p>
<dl class="function">
<dt id="c.requeue_futex">
void <code class="descname">requeue_futex</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em>, struct futex_hash_bucket *<em>&nbsp;hb1</em>, struct futex_hash_bucket *<em>&nbsp;hb2</em>, union futex_key *<em>&nbsp;key2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.requeue_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Requeue a futex_q from one hb to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the futex_q to requeue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb1</span></code></dt>
<dd>the source hash_bucket</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb2</span></code></dt>
<dd>the target hash_bucket</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key2</span></code></dt>
<dd>the new key for the requeued futex_q</dd>
</dl>
<dl class="function">
<dt id="c.requeue_pi_wake_futex">
void <code class="descname">requeue_pi_wake_futex</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em>, union futex_key *<em>&nbsp;key</em>, struct futex_hash_bucket *<em>&nbsp;hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.requeue_pi_wake_futex" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake a task that acquired the lock during requeue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the futex_q</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>the key of the requeue target futex</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb</span></code></dt>
<dd>the hash_bucket of the requeue target futex</dd>
</dl>
<p><strong>Description</strong></p>
<p>During futex_requeue, with requeue_pi=1, it is possible to acquire the
target futex if it is uncontended or via a lock steal.  Set the futex_q key
to the requeue target futex so the waiter can detect the wakeup on the right
futex, but remove it from the hb and NULL the rt_waiter so it can detect
atomic lock acquisition.  Set the q-&gt;lock_ptr to the requeue target hb-&gt;lock
to protect access to the pi_state to fixup the owner later.  Must be called
with both q-&gt;lock_ptr and hb-&gt;lock held.</p>
<dl class="function">
<dt id="c.futex_proxy_trylock_atomic">
int <code class="descname">futex_proxy_trylock_atomic</code><span class="sig-paren">(</span>u32 __user *<em>&nbsp;pifutex</em>, struct futex_hash_bucket *<em>&nbsp;hb1</em>, struct futex_hash_bucket *<em>&nbsp;hb2</em>, union futex_key *<em>&nbsp;key1</em>, union futex_key *<em>&nbsp;key2</em>, struct futex_pi_state **<em>&nbsp;ps</em>, int<em>&nbsp;set_waiters</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_proxy_trylock_atomic" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt an atomic lock for the top waiter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">pifutex</span></code></dt>
<dd>the user address of the to futex</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb1</span></code></dt>
<dd>the from futex hash bucket, must be locked by the caller</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb2</span></code></dt>
<dd>the to futex hash bucket, must be locked by the caller</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key1</span></code></dt>
<dd>the from futex key</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key2</span></code></dt>
<dd>the to futex key</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_pi_state</span> <span class="pre">**</span> <span class="pre">ps</span></code></dt>
<dd>address to store the pi_state pointer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">set_waiters</span></code></dt>
<dd>force setting the FUTEX_WAITERS bit (1) or not (0)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try and get the lock on behalf of the top waiter if we can do it atomically.
Wake the top waiter if we succeed.  If the caller specified set_waiters,
then direct <a class="reference internal" href="#c.futex_lock_pi_atomic" title="futex_lock_pi_atomic"><code class="xref c c-func docutils literal"><span class="pre">futex_lock_pi_atomic()</span></code></a> to force setting the FUTEX_WAITERS bit.
hb1 and hb2 must be held by the caller.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>0 - failed to acquire the lock atomically;</li>
<li>&gt;0 - acquired the lock, return value is vpid of the top_waiter</li>
<li>&lt;0 - error</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.futex_requeue">
int <code class="descname">futex_requeue</code><span class="sig-paren">(</span>u32 __user *<em>&nbsp;uaddr1</em>, unsigned int<em>&nbsp;flags</em>, u32 __user *<em>&nbsp;uaddr2</em>, int<em>&nbsp;nr_wake</em>, int<em>&nbsp;nr_requeue</em>, u32 *<em>&nbsp;cmpval</em>, int<em>&nbsp;requeue_pi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_requeue" title="Permalink to this definition">¶</a></dt>
<dd><p>Requeue waiters from uaddr1 to uaddr2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr1</span></code></dt>
<dd>source futex user address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>futex flags (FLAGS_SHARED, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr2</span></code></dt>
<dd>target futex user address</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_wake</span></code></dt>
<dd>number of waiters to wake (must be 1 for requeue_pi)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_requeue</span></code></dt>
<dd>number of waiters to requeue (0-INT_MAX)</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">cmpval</span></code></dt>
<dd><strong>uaddr1</strong> expected value (or <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">requeue_pi</span></code></dt>
<dd>if we are attempting to requeue from a non-pi futex to a
pi futex (pi to pi requeue is not supported)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Requeue waiters on uaddr1 to uaddr2. In the requeue_pi case, try to acquire
uaddr2 atomically on behalf of the top waiter.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>&gt;=0 - on success, the number of tasks requeued or woken;</li>
<li>&lt;0 - on error</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.queue_me">
void <code class="descname">queue_me</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em>, struct futex_hash_bucket *<em>&nbsp;hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Enqueue the futex_q on the futex_hash_bucket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The futex_q to enqueue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb</span></code></dt>
<dd>The destination hash bucket</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hb-&gt;lock must be held by the caller, and is released here. A call to
<a class="reference internal" href="#c.queue_me" title="queue_me"><code class="xref c c-func docutils literal"><span class="pre">queue_me()</span></code></a> is typically paired with exactly one call to <a class="reference internal" href="#c.unqueue_me" title="unqueue_me"><code class="xref c c-func docutils literal"><span class="pre">unqueue_me()</span></code></a>.  The
exceptions involve the PI related operations, which may use <code class="xref c c-func docutils literal"><span class="pre">unqueue_me_pi()</span></code>
or nothing if the unqueue is done as part of the wake process and the unqueue
state is implicit in the state of woken task (see <a class="reference internal" href="#c.futex_wait_requeue_pi" title="futex_wait_requeue_pi"><code class="xref c c-func docutils literal"><span class="pre">futex_wait_requeue_pi()</span></code></a> for
an example).</p>
<dl class="function">
<dt id="c.unqueue_me">
int <code class="descname">unqueue_me</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unqueue_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the futex_q from its futex_hash_bucket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The futex_q to unqueue</dd>
</dl>
<p><strong>Description</strong></p>
<p>The q-&gt;lock_ptr must not be held by the caller. A call to <a class="reference internal" href="#c.unqueue_me" title="unqueue_me"><code class="xref c c-func docutils literal"><span class="pre">unqueue_me()</span></code></a> must
be paired with exactly one earlier call to <a class="reference internal" href="#c.queue_me" title="queue_me"><code class="xref c c-func docutils literal"><span class="pre">queue_me()</span></code></a>.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>1 - if the futex_q was still queued (and we removed unqueued it);</li>
<li>0 - if the futex_q was already removed by the waking thread</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.fixup_owner">
int <code class="descname">fixup_owner</code><span class="sig-paren">(</span>u32 __user *<em>&nbsp;uaddr</em>, struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em>, int<em>&nbsp;locked</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fixup_owner" title="Permalink to this definition">¶</a></dt>
<dd><p>Post lock pi_state and corner case management</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr</span></code></dt>
<dd>user address of the futex</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>futex_q (contains pi_state and access to the rt_mutex)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">locked</span></code></dt>
<dd>if the attempt to take the rt_mutex succeeded (1) or not (0)</dd>
</dl>
<p><strong>Description</strong></p>
<p>After attempting to lock an rt_mutex, this function is called to cleanup
the pi_state owner as well as handle race conditions that may allow us to
acquire the lock. Must be called with the hb lock held.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>1 - success, lock taken;</li>
<li>0 - success, lock not taken;</li>
<li>&lt;0 - on error (-EFAULT)</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.futex_wait_queue_me">
void <code class="descname">futex_wait_queue_me</code><span class="sig-paren">(</span>struct futex_hash_bucket *<em>&nbsp;hb</em>, struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../../../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a> *<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_wait_queue_me" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#c.queue_me" title="queue_me"><code class="xref c c-func docutils literal"><span class="pre">queue_me()</span></code></a> and wait for wakeup, timeout, or signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb</span></code></dt>
<dd>the futex hash bucket, must be locked by the caller</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the futex_q to queue up on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*</span> <span class="pre">timeout</span></code></dt>
<dd>the prepared hrtimer_sleeper, or null for no timeout</dd>
</dl>
<dl class="function">
<dt id="c.futex_wait_setup">
int <code class="descname">futex_wait_setup</code><span class="sig-paren">(</span>u32 __user *<em>&nbsp;uaddr</em>, u32<em>&nbsp;val</em>, unsigned int<em>&nbsp;flags</em>, struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em>, struct futex_hash_bucket **<em>&nbsp;hb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_wait_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to wait on a futex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr</span></code></dt>
<dd>the futex userspace address</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">val</span></code></dt>
<dd>the expected value</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>futex flags (FLAGS_SHARED, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the associated futex_q</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">**</span> <span class="pre">hb</span></code></dt>
<dd>storage for hash_bucket pointer to be returned to caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the futex_q and locate the hash_bucket.  Get the futex value and
compare it with the expected value.  Handle atomic faults internally.
Return with the hb lock held and a q.key reference on success, and unlocked
with no q.key reference on failure.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>0 - uaddr contains val and hb has been locked;</li>
<li>&lt;1 - -EFAULT or -EWOULDBLOCK (uaddr does not contain val) and hb is unlocked</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.handle_early_requeue_pi_wakeup">
int <code class="descname">handle_early_requeue_pi_wakeup</code><span class="sig-paren">(</span>struct futex_hash_bucket *<em>&nbsp;hb</em>, struct <a class="reference internal" href="#c.futex_q" title="futex_q">futex_q</a> *<em>&nbsp;q</em>, union futex_key *<em>&nbsp;key2</em>, struct <a class="reference internal" href="../../../driver-api/basics.html#c.hrtimer_sleeper" title="hrtimer_sleeper">hrtimer_sleeper</a> *<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.handle_early_requeue_pi_wakeup" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect early wakeup on the initial futex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_hash_bucket</span> <span class="pre">*</span> <span class="pre">hb</span></code></dt>
<dd>the hash_bucket futex_q was original enqueued on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">futex_q</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the futex_q woken while waiting to be requeued</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">futex_key</span> <span class="pre">*</span> <span class="pre">key2</span></code></dt>
<dd>the futex_key of the requeue target futex</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer_sleeper</span> <span class="pre">*</span> <span class="pre">timeout</span></code></dt>
<dd>the timeout associated with the wait (NULL if none)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Detect if the task was woken on the initial futex as opposed to the requeue
target futex.  If so, determine if it was a timeout or a signal that caused
the wakeup and return the appropriate error code to the caller.  Must be
called with the hb lock held.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>0 = no early wakeup detected;</li>
<li>&lt;0 = -ETIMEDOUT or -ERESTARTNOINTR</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.futex_wait_requeue_pi">
int <code class="descname">futex_wait_requeue_pi</code><span class="sig-paren">(</span>u32 __user *<em>&nbsp;uaddr</em>, unsigned int<em>&nbsp;flags</em>, u32<em>&nbsp;val</em>, ktime_t *<em>&nbsp;abs_time</em>, u32<em>&nbsp;bitset</em>, u32 __user *<em>&nbsp;uaddr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.futex_wait_requeue_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait on uaddr and take uaddr2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr</span></code></dt>
<dd>the futex we initially wait on (non-pi)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>futex flags (FLAGS_SHARED, FLAGS_CLOCKRT, etc.), they must be
the same type, no requeueing from private to shared, etc.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">val</span></code></dt>
<dd>the expected value of uaddr</dd>
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">*</span> <span class="pre">abs_time</span></code></dt>
<dd>absolute timeout</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">bitset</span></code></dt>
<dd>32 bit wakeup bitset set by userspace, defaults to all</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uaddr2</span></code></dt>
<dd>the pi futex we will take prior to returning to user-space</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller will wait on uaddr and will be requeued by <a class="reference internal" href="#c.futex_requeue" title="futex_requeue"><code class="xref c c-func docutils literal"><span class="pre">futex_requeue()</span></code></a> to
uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake
on uaddr2 and complete the acquisition of the rt_mutex prior to returning to
userspace.  This ensures the rt_mutex maintains an owner when it has waiters;
without one, the pi logic would not know which task to boost/deboost, if
there was a need to.</p>
<p>We call schedule in <a class="reference internal" href="#c.futex_wait_queue_me" title="futex_wait_queue_me"><code class="xref c c-func docutils literal"><span class="pre">futex_wait_queue_me()</span></code></a> when we enqueue and return there
via the following–
1) wakeup on uaddr2 after an atomic lock acquisition by <a class="reference internal" href="#c.futex_requeue" title="futex_requeue"><code class="xref c c-func docutils literal"><span class="pre">futex_requeue()</span></code></a>
2) wakeup on uaddr2 after a requeue
3) signal
4) timeout</p>
<p>If 3, cleanup and return -ERESTARTNOINTR.</p>
<p>If 2, we may then block on trying to take the rt_mutex and return via:
5) successful lock
6) signal
7) timeout
8) other lock acquisition failure</p>
<p>If 6, return -EWOULDBLOCK (restarting the syscall would do the same).</p>
<p>If 4 or 7, we cleanup and return with -ETIMEDOUT.</p>
<p><strong>Return</strong></p>
<blockquote>
<div><ul class="simple">
<li>0 - On success;</li>
<li>&lt;0 - On error</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.sys_set_robust_list">
long <code class="descname">sys_set_robust_list</code><span class="sig-paren">(</span>struct robust_list_head __user *<em>&nbsp;head</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_set_robust_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the robust-futex list head of a task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">robust_list_head</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to the list-head</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of the list-head, as userspace expects</dd>
</dl>
<dl class="function">
<dt id="c.sys_get_robust_list">
long <code class="descname">sys_get_robust_list</code><span class="sig-paren">(</span>int<em>&nbsp;pid</em>, struct robust_list_head __user *__user *<em>&nbsp;head_ptr</em>, size_t __user *<em>&nbsp;len_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_get_robust_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the robust-futex list head of a task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">pid</span></code></dt>
<dd>pid of the process [zero for current task]</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">robust_list_head</span> <span class="pre">__user</span> <span class="pre">*__user</span> <span class="pre">*</span> <span class="pre">head_ptr</span></code></dt>
<dd>pointer to a list-head pointer, the kernel fills it in</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">len_ptr</span></code></dt>
<dd>pointer to a length field, the kernel fills in the header size</dd>
</dl>
</div>
<div class="section" id="approfondimenti">
<h2>Approfondimenti<a class="headerlink" href="#approfondimenti" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">Documentation/locking/spinlocks.txt</span></code>: la guida di Linus Torvalds agli
spinlock del kernel.</p>
</li>
<li><p class="first">Unix Systems for Modern Architectures: Symmetric Multiprocessing and
Caching for Kernel Programmers.</p>
<p>L’introduzione alla sincronizzazione a livello di kernel di Curt Schimmel
è davvero ottima (non è scritta per Linux, ma approssimativamente si adatta
a tutte le situazioni). Il libro è costoso, ma vale ogni singolo spicciolo
per capire la sincronizzazione nei sistemi multi-processore.
[ISBN: 0201633388]</p>
</li>
</ul>
</div>
<div class="section" id="ringraziamenti">
<h2>Ringraziamenti<a class="headerlink" href="#ringraziamenti" title="Permalink to this headline">¶</a></h2>
<p>Grazie a Telsa Gwynne per aver formattato questa guida in DocBook, averla
pulita e aggiunto un po’ di stile.</p>
<p>Grazie a Martin Pool, Philipp Rumpf, Stephen Rothwell, Paul Mackerras,
Ruedi Aschwanden, Alan Cox, Manfred Spraul, Tim Waugh, Pete Zaitcev,
James Morris, Robert Love, Paul McKenney, John Ashby per aver revisionato,
corretto, maledetto e commentato.</p>
<p>Grazie alla congrega per non aver avuto alcuna influenza su questo documento.</p>
</div>
<div class="section" id="glossario">
<h2>Glossario<a class="headerlink" href="#glossario" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>prelazione</dt>
<dd>Prima del kernel 2.5, o quando <code class="docutils literal"><span class="pre">CONFIG_PREEMPT</span></code> non è impostato, i processi
in contesto utente non si avvicendano nell’esecuzione (in pratica, il
processo userà il processore fino al proprio termine, a meno che non ci siano
delle interruzioni). Con l’aggiunta di <code class="docutils literal"><span class="pre">CONFIG_PREEMPT</span></code> nella versione
2.5.4 questo è cambiato: quando si è in contesto utente, processi con una
priorità maggiore possono subentrare nell’esecuzione: gli spinlock furono
cambiati per disabilitare la prelazioni, anche su sistemi monoprocessore.</dd>
<dt>bh</dt>
<dd>Bottom Half: per ragioni storiche, le funzioni che contengono ‘_bh’ nel
loro nome ora si riferiscono a qualsiasi interruzione software; per esempio,
<code class="xref c c-func docutils literal"><span class="pre">spin_lock_bh()</span></code> blocca qualsiasi interuzione software sul processore
corrente. I <em>Bottom Halves</em> sono deprecati, e probabilmente verranno
sostituiti dai tasklet. In un dato momento potrà esserci solo un
<em>bottom half</em> in esecuzione.</dd>
<dt>contesto d’interruzione</dt>
<dd>Non è il contesto utente: qui si processano le interruzioni hardware e
software. La macro <code class="xref c c-func docutils literal"><span class="pre">in_interrupt()</span></code> ritorna vero.</dd>
<dt>contesto utente</dt>
<dd>Il kernel che esegue qualcosa per conto di un particolare processo (per
esempio una chiamata di sistema) o di un thread del kernel. Potete
identificare il processo con la macro <code class="docutils literal"><span class="pre">current</span></code>. Da non confondere
con lo spazio utente. Può essere interrotto sia da interruzioni software
che hardware.</dd>
<dt>interruzione hardware</dt>
<dd>Richiesta di interruzione hardware. <code class="xref c c-func docutils literal"><span class="pre">in_irq()</span></code> ritorna vero in un
gestore d’interruzioni hardware.</dd>
<dt>interruzione software / softirq</dt>
<dd><p class="first">Gestore di interruzioni software: <code class="xref c c-func docutils literal"><span class="pre">in_irq()</span></code> ritorna falso;
<code class="xref c c-func docutils literal"><span class="pre">in_softirq()</span></code> ritorna vero. I tasklet e le softirq sono entrambi
considerati ‘interruzioni software’.</p>
<p class="last">In soldoni, un softirq è uno delle 32 interruzioni software che possono
essere eseguite su più processori in contemporanea. A volte si usa per
riferirsi anche ai tasklet (in pratica tutte le interruzioni software).</p>
</dd>
<dt>monoprocessore / UP</dt>
<dd>(Uni-Processor) un solo processore, ovvero non è SMP. (<code class="docutils literal"><span class="pre">CONFIG_SMP=n</span></code>).</dd>
<dt>multi-processore / SMP</dt>
<dd>(Symmetric Multi-Processor) kernel compilati per sistemi multi-processore
(<code class="docutils literal"><span class="pre">CONFIG_SMP=y</span></code>).</dd>
<dt>spazio utente</dt>
<dd>Un processo che esegue il proprio codice fuori dal kernel.</dd>
<dt>tasklet</dt>
<dd>Un’interruzione software registrabile dinamicamente che ha la garanzia
d’essere eseguita solo su un processore alla volta.</dd>
<dt>timer</dt>
<dd>Un’interruzione software registrabile dinamicamente che viene eseguita
(circa) in un determinato momento. Quando è in esecuzione è come un tasklet
(infatti, sono chiamati da <code class="docutils literal"><span class="pre">TIMER_SOFTIRQ</span></code>).</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../ko_KR/index.html" class="btn btn-neutral float-right" title="Korean translations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="hacking.html" class="btn btn-neutral" title="L’inaffidabile guida all’hacking del kernel Linux" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>