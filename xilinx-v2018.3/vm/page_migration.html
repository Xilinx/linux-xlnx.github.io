

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Page migration &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Page fragments" href="page_frags.html" />
    <link rel="prev" title="Overcommit Accounting" href="overcommit-accounting.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Memory Management Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#user-guides-for-mm-features">User guides for MM features</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#kernel-developers-mm-documentation">Kernel developers MM documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="active_mm.html">Active MM</a></li>
<li class="toctree-l3"><a class="reference internal" href="balance.html">Memory Balancing</a></li>
<li class="toctree-l3"><a class="reference internal" href="cleancache.html">Cleancache</a></li>
<li class="toctree-l3"><a class="reference internal" href="frontswap.html">Frontswap</a></li>
<li class="toctree-l3"><a class="reference internal" href="highmem.html">High Memory Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="hmm.html">Heterogeneous Memory Management (HMM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hwpoison.html">hwpoison</a></li>
<li class="toctree-l3"><a class="reference internal" href="hugetlbfs_reserv.html">Hugetlbfs Reservation</a></li>
<li class="toctree-l3"><a class="reference internal" href="ksm.html">Kernel Samepage Merging</a></li>
<li class="toctree-l3"><a class="reference internal" href="mmu_notifier.html">When do you need to notify inside page table lock ?</a></li>
<li class="toctree-l3"><a class="reference internal" href="numa.html">What is NUMA?</a></li>
<li class="toctree-l3"><a class="reference internal" href="overcommit-accounting.html">Overcommit Accounting</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Page migration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#in-kernel-use-of-migrate-pages">In kernel use of migrate_pages()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-migrate-pages-works">How migrate_pages() works</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-lru-page-migration">Non-LRU page migration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="page_frags.html">Page fragments</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_owner.html">page owner: Tracking about who allocated each page</a></li>
<li class="toctree-l3"><a class="reference internal" href="remap_file_pages.html">remap_file_pages() system call</a></li>
<li class="toctree-l3"><a class="reference internal" href="slub.html">Short users guide for SLUB</a></li>
<li class="toctree-l3"><a class="reference internal" href="split_page_table_lock.html">Split page table lock</a></li>
<li class="toctree-l3"><a class="reference internal" href="transhuge.html">Transparent Hugepage Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="unevictable-lru.html">Unevictable LRU Infrastructure</a></li>
<li class="toctree-l3"><a class="reference internal" href="z3fold.html">z3fold</a></li>
<li class="toctree-l3"><a class="reference internal" href="zsmalloc.html">zsmalloc</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Memory Management Documentation</a> &raquo;</li>
        
      <li>Page migration</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/vm/page_migration.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="page-migration">
<span id="id1"></span><h1>Page migration<a class="headerlink" href="#page-migration" title="Permalink to this headline">¶</a></h1>
<p>Page migration allows the moving of the physical location of pages between
nodes in a numa system while the process is running. This means that the
virtual addresses that the process sees do not change. However, the
system rearranges the physical location of those pages.</p>
<p>The main intend of page migration is to reduce the latency of memory access
by moving pages near to the processor where the process accessing that memory
is running.</p>
<p>Page migration allows a process to manually relocate the node on which its
pages are located through the MF_MOVE and MF_MOVE_ALL options while setting
a new memory policy via mbind(). The pages of process can also be relocated
from another process using the sys_migrate_pages() function call. The
migrate_pages function call takes two sets of nodes and moves pages of a
process that are located on the from nodes to the destination nodes.
Page migration functions are provided by the numactl package by Andi Kleen
(a version later than 0.9.3 is required. Get it from
<a class="reference external" href="ftp://oss.sgi.com/www/projects/libnuma/download/">ftp://oss.sgi.com/www/projects/libnuma/download/</a>). numactl provides libnuma
which provides an interface similar to other numa functionality for page
migration.  cat <code class="docutils literal"><span class="pre">/proc/&lt;pid&gt;/numa_maps</span></code> allows an easy review of where the
pages of a process are located. See also the numa_maps documentation in the
proc(5) man page.</p>
<p>Manual migration is useful if for example the scheduler has relocated
a process to a processor on a distant node. A batch scheduler or an
administrator may detect the situation and move the pages of the process
nearer to the new processor. The kernel itself does only provide
manual page migration support. Automatic page migration may be implemented
through user space processes that move pages. A special function call
“move_pages” allows the moving of individual pages within a process.
A NUMA profiler may f.e. obtain a log showing frequent off node
accesses and may use the result to move pages to more advantageous
locations.</p>
<p>Larger installations usually partition the system using cpusets into
sections of nodes. Paul Jackson has equipped cpusets with the ability to
move pages when a task is moved to another cpuset (See
Documentation/cgroup-v1/cpusets.txt).
Cpusets allows the automation of process locality. If a task is moved to
a new cpuset then also all its pages are moved with it so that the
performance of the process does not sink dramatically. Also the pages
of processes in a cpuset are moved if the allowed memory nodes of a
cpuset are changed.</p>
<p>Page migration allows the preservation of the relative location of pages
within a group of nodes for all migration techniques which will preserve a
particular memory allocation pattern generated even after migrating a
process. This is necessary in order to preserve the memory latencies.
Processes will run with similar performance after migration.</p>
<p>Page migration occurs in several steps. First a high level
description for those trying to use migrate_pages() from the kernel
(for userspace usage see the Andi Kleen’s numactl package mentioned above)
and then a low level description of how the low level details work.</p>
<div class="section" id="in-kernel-use-of-migrate-pages">
<h2>In kernel use of migrate_pages()<a class="headerlink" href="#in-kernel-use-of-migrate-pages" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">Remove pages from the LRU.</p>
<p>Lists of pages to be migrated are generated by scanning over
pages and moving them into lists. This is done by
calling isolate_lru_page().
Calling isolate_lru_page increases the references to the page
so that it cannot vanish while the page migration occurs.
It also prevents the swapper or other scans to encounter
the page.</p>
</li>
<li><p class="first">We need to have a function of type new_page_t that can be
passed to migrate_pages(). This function should figure out
how to allocate the correct new page given the old page.</p>
</li>
<li><p class="first">The migrate_pages() function is called which attempts
to do the migration. It will call the function to allocate
the new page for each page that is considered for
moving.</p>
</li>
</ol>
</div>
<div class="section" id="how-migrate-pages-works">
<h2>How migrate_pages() works<a class="headerlink" href="#how-migrate-pages-works" title="Permalink to this headline">¶</a></h2>
<p>migrate_pages() does several passes over its list of pages. A page is moved
if all references to a page are removable at the time. The page has
already been removed from the LRU via isolate_lru_page() and the refcount
is increased so that the page cannot be freed while page migration occurs.</p>
<p>Steps:</p>
<ol class="arabic simple">
<li>Lock the page to be migrated</li>
<li>Ensure that writeback is complete.</li>
<li>Lock the new page that we want to move to. It is locked so that accesses to
this (not yet uptodate) page immediately lock while the move is in progress.</li>
<li>All the page table references to the page are converted to migration
entries. This decreases the mapcount of a page. If the resulting
mapcount is not zero then we do not migrate the page. All user space
processes that attempt to access the page will now wait on the page lock.</li>
<li>The i_pages lock is taken. This will cause all processes trying
to access the page via the mapping to block on the spinlock.</li>
<li>The refcount of the page is examined and we back out if references remain
otherwise we know that we are the only one referencing this page.</li>
<li>The radix tree is checked and if it does not contain the pointer to this
page then we back out because someone else modified the radix tree.</li>
<li>The new page is prepped with some settings from the old page so that
accesses to the new page will discover a page with the correct settings.</li>
<li>The radix tree is changed to point to the new page.</li>
<li>The reference count of the old page is dropped because the address space
reference is gone. A reference to the new page is established because
the new page is referenced by the address space.</li>
<li>The i_pages lock is dropped. With that lookups in the mapping
become possible again. Processes will move from spinning on the lock
to sleeping on the locked new page.</li>
<li>The page contents are copied to the new page.</li>
<li>The remaining page flags are copied to the new page.</li>
<li>The old page flags are cleared to indicate that the page does
not provide any information anymore.</li>
<li>Queued up writeback on the new page is triggered.</li>
<li>If migration entries were page then replace them with real ptes. Doing
so will enable access for user space processes not already waiting for
the page lock.</li>
</ol>
<ol class="arabic simple" start="19">
<li>The page locks are dropped from the old and new page.
Processes waiting on the page lock will redo their page faults
and will reach the new page.</li>
<li>The new page is moved to the LRU and can be scanned by the swapper
etc again.</li>
</ol>
</div>
<div class="section" id="non-lru-page-migration">
<h2>Non-LRU page migration<a class="headerlink" href="#non-lru-page-migration" title="Permalink to this headline">¶</a></h2>
<p>Although original migration aimed for reducing the latency of memory access
for NUMA, compaction who want to create high-order page is also main customer.</p>
<p>Current problem of the implementation is that it is designed to migrate only
<em>LRU</em> pages. However, there are potential non-lru pages which can be migrated
in drivers, for example, zsmalloc, virtio-balloon pages.</p>
<p>For virtio-balloon pages, some parts of migration code path have been hooked
up and added virtio-balloon specific functions to intercept migration logics.
It’s too specific to a driver so other drivers who want to make their pages
movable would have to add own specific hooks in migration path.</p>
<p>To overclome the problem, VM supports non-LRU page migration which provides
generic functions for non-LRU movable pages without driver specific hooks
migration path.</p>
<p>If a driver want to make own pages movable, it should define three functions
which are function pointers of struct address_space_operations.</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">bool</span> <span class="pre">(*isolate_page)</span> <span class="pre">(struct</span> <span class="pre">page</span> <span class="pre">*page,</span> <span class="pre">isolate_mode_t</span> <span class="pre">mode);</span></code></p>
<p>What VM expects on isolate_page function of driver is to return <em>true</em>
if driver isolates page successfully. On returing true, VM marks the page
as PG_isolated so concurrent isolation in several CPUs skip the page
for isolation. If a driver cannot isolate the page, it should return <em>false</em>.</p>
<p>Once page is successfully isolated, VM uses page.lru fields so driver
shouldn’t expect to preserve values in that fields.</p>
</li>
</ol>
<p>2. <code class="docutils literal"><span class="pre">int</span> <span class="pre">(*migratepage)</span> <span class="pre">(struct</span> <span class="pre">address_space</span> <span class="pre">*mapping,</span></code>
|       <code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*newpage,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*oldpage,</span> <span class="pre">enum</span> <span class="pre">migrate_mode);</span></code></p>
<blockquote>
<div><p>After isolation, VM calls migratepage of driver with isolated page.
The function of migratepage is to move content of the old page to new page
and set up fields of struct page newpage. Keep in mind that you should
indicate to the VM the oldpage is no longer movable via __ClearPageMovable()
under page_lock if you migrated the oldpage successfully and returns
MIGRATEPAGE_SUCCESS. If driver cannot migrate the page at the moment, driver
can return -EAGAIN. On -EAGAIN, VM will retry page migration in a short time
because VM interprets -EAGAIN as “temporal migration failure”. On returning
any error except -EAGAIN, VM will give up the page migration without retrying
in this time.</p>
<p>Driver shouldn’t touch page.lru field VM using in the functions.</p>
</div></blockquote>
<ol class="arabic" start="3">
<li><p class="first"><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*putback_page)(struct</span> <span class="pre">page</span> <span class="pre">*);</span></code></p>
<p>If migration fails on isolated page, VM should return the isolated page
to the driver so VM calls driver’s putback_page with migration failed page.
In this function, driver should put the isolated page back to the own data
structure.</p>
</li>
<li><p class="first">non-lru movable page flags</p>
<p>There are two page flags for supporting non-lru movable page.</p>
<ul>
<li><p class="first">PG_movable</p>
<p>Driver should use the below function to make page movable under page_lock:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void __SetPageMovable(struct page *page, struct address_space *mapping)
</pre></div>
</div>
<p>It needs argument of address_space for registering migration
family functions which will be called by VM. Exactly speaking,
PG_movable is not a real flag of struct page. Rather than, VM
reuses page-&gt;mapping’s lower bits to represent it.</p>
</li>
</ul>
</li>
</ol>
<dl class="docutils">
<dt>::</dt>
<dd><blockquote class="first">
<div><blockquote>
<div>#define PAGE_MAPPING_MOVABLE 0x2
page-&gt;mapping = page-&gt;mapping | PAGE_MAPPING_MOVABLE;</div></blockquote>
<p>so driver shouldn’t access page-&gt;mapping directly. Instead, driver should
use page_mapping which mask off the low two bits of page-&gt;mapping under
page lock so it can get right struct address_space.</p>
<p>For testing of non-lru movable page, VM supports __PageMovable function.
However, it doesn’t guarantee to identify non-lru movable page because
page-&gt;mapping field is unified with other variables in struct page.
As well, if driver releases the page after isolation by VM, page-&gt;mapping
doesn’t have stable value although it has PAGE_MAPPING_MOVABLE
(Look at __ClearPageMovable). But __PageMovable is cheap to catch whether
page is LRU or non-lru movable once the page has been isolated. Because
LRU pages never can have PAGE_MAPPING_MOVABLE in page-&gt;mapping. It is also
good for just peeking to test non-lru movable pages before more expensive
checking with lock_page in pfn scanning to select victim.</p>
<p>For guaranteeing non-lru movable page, VM provides PageMovable function.
Unlike __PageMovable, PageMovable functions validates page-&gt;mapping and
mapping-&gt;a_ops-&gt;isolate_page under lock_page. The lock_page prevents sudden
destroying of page-&gt;mapping.</p>
<p>Driver using __SetPageMovable should clear the flag via __ClearMovablePage
under page_lock before the releasing the page.</p>
</div></blockquote>
<ul class="last">
<li><p class="first">PG_isolated</p>
<p>To prevent concurrent isolation among several CPUs, VM marks isolated page
as PG_isolated under lock_page. So if a CPU encounters PG_isolated non-lru
movable page, it can skip it. Driver doesn’t need to manipulate the flag
because VM will set/clear it automatically. Keep in mind that if driver
sees PG_isolated page, it means the page have been isolated by VM so it
shouldn’t touch page.lru field.
PG_isolated is alias with PG_reclaim flag so driver shouldn’t use the flag
for own purpose.</p>
</li>
</ul>
</dd>
</dl>
<p>Christoph Lameter, May 8, 2006.
Minchan Kim, Mar 28, 2016.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="page_frags.html" class="btn btn-neutral float-right" title="Page fragments" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="overcommit-accounting.html" class="btn btn-neutral" title="Overcommit Accounting" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>