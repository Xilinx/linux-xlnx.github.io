

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Linux Kernel API &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Generic Associative Array Implementation" href="assoc_array.html" />
    <link rel="prev" title="Core API Documentation" href="index.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">The Linux Kernel API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-types">Data Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-c-library-functions">Basic C Library Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-kernel-library-functions">Basic Kernel Library Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-management-in-linux">Memory Management in Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-ipc-facilities">Kernel IPC facilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fifo-buffer">FIFO Buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#relay-interface-support">relay interface support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-support">Module Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-interfaces">Hardware Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#security-framework">Security Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#audit-interfaces">Audit Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accounting-framework">Accounting Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-devices">Block Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#char-devices">Char devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clock-framework">Clock Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-primitives">Synchronization Primitives</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomic_ops.html">Semantics and Behavior of Atomic and Bitmask Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="flexible-arrays.html">Using flexible arrays in the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="genalloc.html">The genalloc/genpool subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
        
      <li>The Linux Kernel API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/kernel-api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-linux-kernel-api">
<h1>The Linux Kernel API<a class="headerlink" href="#the-linux-kernel-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="data-types">
<h2>Data Types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h2>
<div class="section" id="doubly-linked-lists">
<h3>Doubly Linked Lists<a class="headerlink" href="#doubly-linked-lists" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.list_add">
void <code class="descname">list_add</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it after</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<dl class="function">
<dt id="c.list_add_tail">
void <code class="descname">list_add_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it before</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
<dl class="function">
<dt id="c.__list_del_entry">
void <code class="descname">__list_del_entry</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__list_del_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the element to delete from the list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal"><span class="pre">list_empty()</span></code></a> on entry does not return true after this, the entry is
in an undefined state.</p>
<dl class="function">
<dt id="c.list_replace">
void <code class="descname">list_replace</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;old</em>, struct list_head *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the element to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new element to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
<dl class="function">
<dt id="c.list_del_init">
void <code class="descname">list_del_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_init" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list and reinitialize it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the element to delete from the list.</dd>
</dl>
<dl class="function">
<dt id="c.list_move">
void <code class="descname">list_move</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move" title="Permalink to this definition">¶</a></dt>
<dd><p>delete from one list and add as another’s head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to move</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head that will precede our entry</dd>
</dl>
<dl class="function">
<dt id="c.list_move_tail">
void <code class="descname">list_move_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>delete from one list and add as another’s tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to move</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head that will follow our entry</dd>
</dl>
<dl class="function">
<dt id="c.list_is_last">
int <code class="descname">list_is_last</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;list</em>, const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_last" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether <strong>list</strong> is the last entry in list <strong>head</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to test</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
</dl>
<dl class="function">
<dt id="c.list_empty">
int <code class="descname">list_empty</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test.</dd>
</dl>
<dl class="function">
<dt id="c.list_empty_careful">
int <code class="descname">list_empty_careful</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty_careful" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list is empty and not being modified</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>tests whether a list is empty _and_ checks that no other CPU might be
in the process of modifying either member (next or prev)</p>
<p><strong>NOTE</strong></p>
<p>using <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal"><span class="pre">list_empty_careful()</span></code></a> without synchronization
can only be safe if the only activity that can happen
to the list entry is <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal"><span class="pre">list_del_init()</span></code></a>. Eg. it cannot be used
if another CPU could re-<a class="reference internal" href="#c.list_add" title="list_add"><code class="xref c c-func docutils literal"><span class="pre">list_add()</span></code></a> it.</p>
<dl class="function">
<dt id="c.list_rotate_left">
void <code class="descname">list_rotate_left</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_left" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate the list to the left</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
</dl>
<dl class="function">
<dt id="c.list_is_singular">
int <code class="descname">list_is_singular</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_singular" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list has just one entry.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test.</dd>
</dl>
<dl class="function">
<dt id="c.list_cut_position">
void <code class="descname">list_cut_position</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em>, struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_position" title="Permalink to this definition">¶</a></dt>
<dd><p>cut a list into two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>a new list to add all removed entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>a list with entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>an entry within head, could be the head itself
and if so we won’t cut the list</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to and
including <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>. You should
pass on <strong>entry</strong> an element you know is on <strong>head</strong>. <strong>list</strong>
should be an empty list or a list you do not care about
losing its data.</p>
<dl class="function">
<dt id="c.list_splice">
void <code class="descname">list_splice</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists, this is designed for stacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_tail">
void <code class="descname">list_splice_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists, each list being a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_init">
void <code class="descname">list_splice_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists and reinitialise the emptied list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list at <strong>list</strong> is reinitialised</p>
<dl class="function">
<dt id="c.list_splice_tail_init">
void <code class="descname">list_splice_tail_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists and reinitialise the emptied list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</p>
<dl class="function">
<dt id="c.list_entry">
<code class="descname">list_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_first_entry">
<code class="descname">list_first_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
<dl class="function">
<dt id="c.list_last_entry">
<code class="descname">list_last_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_last_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
<dl class="function">
<dt id="c.list_first_entry_or_null">
<code class="descname">list_first_entry_or_null</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_entry_or_null" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
<dl class="function">
<dt id="c.list_next_entry">
<code class="descname">list_next_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_next_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next element in list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to cursor</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_prev_entry">
<code class="descname">list_prev_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_prev_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the prev element in list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to cursor</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each">
<code class="descname">list_for_each</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_prev">
<code class="descname">list_for_each_prev</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list backwards</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_safe">
<code class="descname">list_for_each_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_prev_safe">
<code class="descname">list_for_each_prev_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_prev_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list backwards safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry">
<code class="descname">list_for_each_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry_reverse">
<code class="descname">list_for_each_entry_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list of given type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_prepare_entry">
<code class="descname">list_prepare_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_prepare_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a pos entry for use in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_continue()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a start point</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a pos entry for use as a start point in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_continue()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue">
<code class="descname">list_for_each_entry_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue iteration over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue_reverse">
<code class="descname">list_for_each_entry_continue_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards from the given point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start to iterate over list of given type backwards, continuing after
the current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from">
<code class="descname">list_for_each_entry_from</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type from the current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing from current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from_reverse">
<code class="descname">list_for_each_entry_from_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list of given type from the current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, continuing from current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe">
<code class="descname">list_for_each_entry_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry_safe_continue">
<code class="descname">list_for_each_entry_safe_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue list iteration safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing after current point,
safe against removal of list entry.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe_from">
<code class="descname">list_for_each_entry_safe_from</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list from current point safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type from current point, safe against
removal of list entry.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe_reverse">
<code class="descname">list_for_each_entry_safe_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, safe against removal
of list entry.</p>
<dl class="function">
<dt id="c.list_safe_reset_next">
<code class="descname">list_safe_reset_next</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_safe_reset_next" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a stale list_for_each_entry_safe loop</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the loop cursor used in the list_for_each_entry_safe loop</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>temporary storage used in list_for_each_entry_safe</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>list_safe_reset_next is not safe to use in general if the list may be
modified concurrently (eg. the lock is dropped in the loop body). An
exception to this is if the cursor element (pos) is pinned in the list,
and list_safe_reset_next is called after re-taking the lock and before
completing the current iteration of the loop body.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry">
<code class="descname">hlist_for_each_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue">
<code class="descname">hlist_for_each_entry_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_from">
<code class="descname">hlist_for_each_entry_from</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_safe">
<code class="descname">hlist_for_each_entry_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
</div>
</div>
<div class="section" id="basic-c-library-functions">
<h2>Basic C Library Functions<a class="headerlink" href="#basic-c-library-functions" title="Permalink to this headline">¶</a></h2>
<p>When writing drivers, you cannot in general use routines which are from
the C Library. Some of the functions have been found generally useful
and they are listed below. The behaviour of these functions may vary
slightly from those defined by ANSI, and these deviations are noted in
the text.</p>
<div class="section" id="string-conversions">
<h3>String Conversions<a class="headerlink" href="#string-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.simple_strtoull">
unsigned long long <code class="descname">simple_strtoull</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoull" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoull instead.</p>
<dl class="function">
<dt id="c.simple_strtoul">
unsigned long <code class="descname">simple_strtoul</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoul instead.</p>
<dl class="function">
<dt id="c.simple_strtol">
long <code class="descname">simple_strtol</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a signed long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtol instead.</p>
<dl class="function">
<dt id="c.simple_strtoll">
long long <code class="descname">simple_strtoll</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoll" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a signed long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoll instead.</p>
<dl class="function">
<dt id="c.vsnprintf">
int <code class="descname">vsnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function generally follows C99 vsnprintf, but has some
extensions and a few limitations:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">``n``</span></code> is unsupported</li>
<li><code class="docutils literal"><span class="pre">``p``*</span></code> is handled by <code class="xref c c-func docutils literal"><span class="pre">pointer()</span></code></li>
</ul>
</div></blockquote>
<p>See <code class="xref c c-func docutils literal"><span class="pre">pointer()</span></code> or Documentation/printk-formats.txt for more
extensive description.</p>
<p><strong>Please update the documentation in both places when making changes</strong></p>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
‘0’, as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing ‘0’), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<p>If you’re not already dealing with a va_list consider using <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal"><span class="pre">snprintf()</span></code></a>.</p>
<dl class="function">
<dt id="c.vscnprintf">
int <code class="descname">vscnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vscnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which have been written into
the <strong>buf</strong> not including the trailing ‘0’. If <strong>size</strong> is == 0 the function
returns 0.</p>
<p>If you’re not already dealing with a va_list consider using <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal"><span class="pre">scnprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.snprintf">
int <code class="descname">snprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.snprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which would be
generated for the given input, excluding the trailing null,
as per ISO C99.  If the return is greater than or equal to
<strong>size</strong>, the resulting string is truncated.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.scnprintf">
int <code class="descname">scnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.scnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters written into <strong>buf</strong> not including
the trailing ‘0’. If <strong>size</strong> is == 0 the function returns 0.</p>
<dl class="function">
<dt id="c.vsprintf">
int <code class="descname">vsprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> or <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>If you’re not already dealing with a va_list consider using <a class="reference internal" href="#c.sprintf" title="sprintf"><code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.sprintf">
int <code class="descname">sprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal"><span class="pre">snprintf()</span></code></a> or <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal"><span class="pre">scnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.vbin_printf">
int <code class="descname">vbin_printf</code><span class="sig-paren">(</span>u32 *<em>&nbsp;bin_buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vbin_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a format string and place args’ binary value in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>The buffer to place args’ binary value</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer(by words(32bits), not characters)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format follows C99 vsnprintf, except <code class="docutils literal"><span class="pre">n</span></code> is ignored, and its argument
is skipped.</p>
<p>The return value is the number of words(32bits) which would be generated for
the given input.</p>
<p><strong>NOTE</strong></p>
<p>If the return value is greater than <strong>size</strong>, the resulting bin_buf is NOT
valid for <a class="reference internal" href="#c.bstr_printf" title="bstr_printf"><code class="xref c c-func docutils literal"><span class="pre">bstr_printf()</span></code></a>.</p>
<dl class="function">
<dt id="c.bstr_printf">
int <code class="descname">bstr_printf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, const u32 *<em>&nbsp;bin_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bstr_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string from binary arguments and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>Binary arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function like C99 vsnprintf, but the difference is that vsnprintf gets
arguments from stack, and bstr_printf gets arguments from <strong>bin_buf</strong> which is
a binary buffer that generated by vbin_printf.</p>
<dl class="docutils">
<dt>The format follows C99 vsnprintf, but has some extensions:</dt>
<dd>see vsnprintf comment for details.</dd>
</dl>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
‘0’, as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing ‘0’), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<dl class="function">
<dt id="c.bprintf">
int <code class="descname">bprintf</code><span class="sig-paren">(</span>u32 *<em>&nbsp;bin_buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.bprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a format string and place args’ binary value in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>The buffer to place args’ binary value</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer(by words(32bits), not characters)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of words(u32) written
into <strong>bin_buf</strong>.</p>
<dl class="function">
<dt id="c.vsscanf">
int <code class="descname">vsscanf</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>input buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format of buffer</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>arguments</dd>
</dl>
<dl class="function">
<dt id="c.sscanf">
int <code class="descname">sscanf</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>input buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>formatting of buffer</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>resulting arguments</dd>
</dl>
<dl class="function">
<dt id="c.kstrtol">
int <code class="descname">kstrtol</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoul">
int <code class="descname">kstrtoul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoull">
int <code class="descname">kstrtoull</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned long long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoull" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoll">
int <code class="descname">kstrtoll</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, long long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoll" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtouint">
int <code class="descname">kstrtouint</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned int *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtouint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoint">
int <code class="descname">kstrtoint</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, int *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtobool">
int <code class="descname">kstrtobool</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, bool *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtobool" title="Permalink to this definition">¶</a></dt>
<dd><p>convert common user inputs into boolean values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>input string</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>result</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns 0 iff the first character is one of ‘Yy1Nn0’, or
[oO][NnFf] for “on” and “off”. Otherwise it will return -EINVAL.  Value
pointed to by res is updated upon finding a match.</p>
</div>
<div class="section" id="string-manipulation">
<h3>String Manipulation<a class="headerlink" href="#string-manipulation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.strncasecmp">
int <code class="descname">strncasecmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncasecmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Case insensitive, length-limited string comparison</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The other string</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>the maximum number of characters to compare</dd>
</dl>
<dl class="function">
<dt id="c.strcpy">
char * <code class="descname">strcpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a <code class="docutils literal"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
</dl>
<dl class="function">
<dt id="c.strncpy">
char * <code class="descname">strncpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a length-limited, C-string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>The result is not <code class="docutils literal"><span class="pre">NUL-terminated</span></code> if the source exceeds
<strong>count</strong> bytes.</p>
<p>In the case where the length of <strong>src</strong> is less than  that  of
count, the remainder of <strong>dest</strong> will be padded with <code class="docutils literal"><span class="pre">NUL</span></code>.</p>
<dl class="function">
<dt id="c.strlcpy">
size_t <code class="descname">strlcpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of destination buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatible with <code class="docutils literal"><span class="pre">*BSD</span></code>: the result is always a valid
NUL-terminated string that fits in the buffer (unless,
of course, the buffer size is zero). It does not pad
out the result like <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a> does.</p>
<dl class="function">
<dt id="c.strscpy">
ssize_t <code class="descname">strscpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strscpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>Size of destination buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the string, or as much of it as fits, into the dest buffer.
The routine returns the number of characters copied (not including
the trailing NUL) or -E2BIG if the destination buffer wasn’t big enough.
The behavior is undefined if the string buffers overlap.
The destination buffer is always NUL terminated, unless it’s zero-sized.</p>
<p>Preferred to <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a> since the API doesn’t require reading memory
from the src string beyond the specified “count” bytes, and since
the return value is easier to error-check than <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a>’s.
In addition, the implementation is robust to the string changing out
from underneath it, unlike the current <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a> implementation.</p>
<p>Preferred to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a> since it always returns a valid string, and
doesn’t unnecessarily force the tail of the destination buffer to be
zeroed.  If the zeroing is desired, it’s likely cleaner to use <a class="reference internal" href="#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal"><span class="pre">strscpy()</span></code></a>
with an overflow test, then just <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> the tail of the dest buffer.</p>
<dl class="function">
<dt id="c.strcat">
char * <code class="descname">strcat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append one <code class="docutils literal"><span class="pre">NUL-terminated</span></code> string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
</dl>
<dl class="function">
<dt id="c.strncat">
char * <code class="descname">strncat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a length-limited, C-string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum numbers of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that in contrast to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a>, <a class="reference internal" href="#c.strncat" title="strncat"><code class="xref c c-func docutils literal"><span class="pre">strncat()</span></code></a> ensures the result is
terminated.</p>
<dl class="function">
<dt id="c.strlcat">
size_t <code class="descname">strlcat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a length-limited, C-string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the destination buffer.</dd>
</dl>
<dl class="function">
<dt id="c.strcmp">
int <code class="descname">strcmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another string</dd>
</dl>
<dl class="function">
<dt id="c.strncmp">
int <code class="descname">strncmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two length-limited strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another string</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to compare</dd>
</dl>
<dl class="function">
<dt id="c.strchr">
char * <code class="descname">strchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first occurrence of a character in a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.strchrnul">
char * <code class="descname">strchrnul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strchrnul" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return a character in a string, or end of string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to first occurrence of ‘c’ in s. If c is not found, then
return a pointer to the null byte at the end of s.</p>
<dl class="function">
<dt id="c.strrchr">
char * <code class="descname">strrchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strrchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the last occurrence of a character in a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.strnchr">
char * <code class="descname">strnchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in a length limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of characters to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.skip_spaces">
char * <code class="descname">skip_spaces</code><span class="sig-paren">(</span>const char *<em>&nbsp;str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skip_spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading whitespace from <strong>str</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>The string to be stripped.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the first non-whitespace character in <strong>str</strong>.</p>
<dl class="function">
<dt id="c.strim">
char * <code class="descname">strim</code><span class="sig-paren">(</span>char *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strim" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading and trailing whitespace from <strong>s</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be stripped.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the first trailing whitespace is replaced with a <code class="docutils literal"><span class="pre">NUL-terminator</span></code>
in the given string <strong>s</strong>. Returns a pointer to the first non-whitespace
character in <strong>s</strong>.</p>
<dl class="function">
<dt id="c.strlen">
size_t <code class="descname">strlen</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the length of a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be sized</dd>
</dl>
<dl class="function">
<dt id="c.strnlen">
size_t <code class="descname">strnlen</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the length of a length-limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be sized</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to search</dd>
</dl>
<dl class="function">
<dt id="c.strspn">
size_t <code class="descname">strspn</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, const char *<em>&nbsp;accept</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strspn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which only contain letters in <strong>accept</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">accept</span></code></dt>
<dd>The string to search for</dd>
</dl>
<dl class="function">
<dt id="c.strcspn">
size_t <code class="descname">strcspn</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, const char *<em>&nbsp;reject</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcspn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which does not contain letters in <strong>reject</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">reject</span></code></dt>
<dd>The string to avoid</dd>
</dl>
<dl class="function">
<dt id="c.strpbrk">
char * <code class="descname">strpbrk</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strpbrk" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first occurrence of a set of characters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>The characters to search for</dd>
</dl>
<dl class="function">
<dt id="c.strsep">
char * <code class="descname">strsep</code><span class="sig-paren">(</span>char **<em>&nbsp;s</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strsep" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a string into tokens</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>The characters to search for</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.strsep" title="strsep"><code class="xref c c-func docutils literal"><span class="pre">strsep()</span></code></a> updates <strong>s</strong> to point after the token, ready for the next call.</p>
<p>It returns empty tokens, too, behaving exactly like the libc function
of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
Same semantics, slimmer shape. ;)</p>
<dl class="function">
<dt id="c.sysfs_streq">
bool <code class="descname">sysfs_streq</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_streq" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if strings are equal, modulo trailing newline</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>one string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>another string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns true iff two strings are equal, treating both
NUL and newline-then-NUL as equivalent string terminations.  It’s
geared for use with sysfs input strings, which generally terminate
with newlines but are compared against values without newlines.</p>
<dl class="function">
<dt id="c.match_string">
int <code class="descname">match_string</code><span class="sig-paren">(</span>const char *const *<em>&nbsp;array</em>, size_t<em>&nbsp;n</em>, const char *<em>&nbsp;string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>array of strings</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of strings in the array or -1 for NULL terminated arrays</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">string</span></code></dt>
<dd>string to match with</dd>
</dl>
<p><strong>Return</strong></p>
<p>index of a <strong>string</strong> in the <strong>array</strong> if matches, or <code class="docutils literal"><span class="pre">-EINVAL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.__sysfs_match_string">
int <code class="descname">__sysfs_match_string</code><span class="sig-paren">(</span>const char *const *<em>&nbsp;array</em>, size_t<em>&nbsp;n</em>, const char *<em>&nbsp;str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sysfs_match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>array of strings</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of strings in the array or -1 for NULL terminated arrays</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>string to match with</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns index of <strong>str</strong> in the <strong>array</strong> or -EINVAL, just like <a class="reference internal" href="#c.match_string" title="match_string"><code class="xref c c-func docutils literal"><span class="pre">match_string()</span></code></a>.
Uses sysfs_streq instead of strcmp for matching.</p>
<dl class="function">
<dt id="c.memset">
void * <code class="descname">memset</code><span class="sig-paren">(</span>void *<em>&nbsp;s</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of memory with the given value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not use <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> to access IO space, use <code class="xref c c-func docutils literal"><span class="pre">memset_io()</span></code> instead.</p>
<dl class="function">
<dt id="c.memzero_explicit">
void <code class="descname">memzero_explicit</code><span class="sig-paren">(</span>void *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memzero_explicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of memory (e.g. sensitive keying data) with 0s.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Note</strong></p>
<p>usually using <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> is just fine (!), but in cases
where clearing out _local_ data at the end of a scope is
necessary, <a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal"><span class="pre">memzero_explicit()</span></code></a> should be used instead in
order to prevent the compiler from optimising away zeroing.</p>
<p><a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal"><span class="pre">memzero_explicit()</span></code></a> doesn’t need an arch-specific version as
it just invokes the one of <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> implicitly.</p>
<dl class="function">
<dt id="c.memset16">
void * <code class="descname">memset16</code><span class="sig-paren">(</span>uint16_t *<em>&nbsp;s</em>, uint16_t<em>&nbsp;v</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset16" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint16_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint16_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">uint16_t</span> <span class="pre">v</span></code></dt>
<dd>The value to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of values to store</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> in that it fills with a uint16_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint16_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memset32">
void * <code class="descname">memset32</code><span class="sig-paren">(</span>uint32_t *<em>&nbsp;s</em>, uint32_t<em>&nbsp;v</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset32" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint32_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">v</span></code></dt>
<dd>The value to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of values to store</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> in that it fills with a uint32_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint32_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memset64">
void * <code class="descname">memset64</code><span class="sig-paren">(</span>uint64_t *<em>&nbsp;s</em>, uint64_t<em>&nbsp;v</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset64" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint64_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">v</span></code></dt>
<dd>The value to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of values to store</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> in that it fills with a uint64_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint64_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memcpy">
void * <code class="descname">memcpy</code><span class="sig-paren">(</span>void *<em>&nbsp;dest</em>, const void *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>You should not use this function to access IO space, use <code class="xref c c-func docutils literal"><span class="pre">memcpy_toio()</span></code>
or <code class="xref c c-func docutils literal"><span class="pre">memcpy_fromio()</span></code> instead.</p>
<dl class="function">
<dt id="c.memmove">
void * <code class="descname">memmove</code><span class="sig-paren">(</span>void *<em>&nbsp;dest</em>, const void *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memmove" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal"><span class="pre">memcpy()</span></code></a>, <a class="reference internal" href="#c.memmove" title="memmove"><code class="xref c c-func docutils literal"><span class="pre">memmove()</span></code></a> copes with overlapping areas.</p>
<dl class="function">
<dt id="c.memcmp">
__visible int <code class="descname">memcmp</code><span class="sig-paren">(</span>const void *<em>&nbsp;cs</em>, const void *<em>&nbsp;ct</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two areas of memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One area of memory</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another area of memory</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<dl class="function">
<dt id="c.memscan">
void * <code class="descname">memscan</code><span class="sig-paren">(</span>void *<em>&nbsp;addr</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memscan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or 1 byte past
the area if <strong>c</strong> is not found</p>
<dl class="function">
<dt id="c.strstr">
char * <code class="descname">strstr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first substring in a <code class="docutils literal"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The string to search for</dd>
</dl>
<dl class="function">
<dt id="c.strnstr">
char * <code class="descname">strnstr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first substring in a length-limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The string to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>the maximum number of characters to search</dd>
</dl>
<dl class="function">
<dt id="c.memchr">
void * <code class="descname">memchr</code><span class="sig-paren">(</span>const void *<em>&nbsp;s</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or <code class="docutils literal"><span class="pre">NULL</span></code>
if <strong>c</strong> is not found</p>
<dl class="function">
<dt id="c.memchr_inv">
void * <code class="descname">memchr_inv</code><span class="sig-paren">(</span>const void *<em>&nbsp;start</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an unmatching character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>Find a character other than c</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">bytes</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first character other than <strong>c</strong>, or <code class="docutils literal"><span class="pre">NULL</span></code>
if the whole buffer contains just <strong>c</strong>.</p>
<dl class="function">
<dt id="c.strreplace">
char * <code class="descname">strreplace</code><span class="sig-paren">(</span>char *<em>&nbsp;s</em>, char<em>&nbsp;old</em>, char<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all occurrences of character in string.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to operate on.</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">old</span></code></dt>
<dd>The character being replaced.</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">new</span></code></dt>
<dd>The character <strong>old</strong> is replaced with.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to the nul byte at the end of <strong>s</strong>.</p>
</div>
<div class="section" id="bit-operations">
<h3>Bit Operations<a class="headerlink" href="#bit-operations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.set_bit">
void <code class="descname">set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically set a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is atomic and may not be reordered.  See <a class="reference internal" href="#c.__set_bit" title="__set_bit"><code class="xref c c-func docutils literal"><span class="pre">__set_bit()</span></code></a>
if you do not require the atomic guarantees.</p>
<p><strong>Note</strong></p>
<p>there are no guarantees that this function will not be reordered
on non x86 architectures, so if you are writing portable code,
make sure not to rely on its reordering guarantees.</p>
<p>Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
<dl class="function">
<dt id="c.__set_bit">
void <code class="descname">__set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.set_bit" title="set_bit"><code class="xref c c-func docutils literal"><span class="pre">set_bit()</span></code></a>, this function is non-atomic and may be reordered.
If it’s called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.</p>
<dl class="function">
<dt id="c.clear_bit">
void <code class="descname">clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.clear_bit" title="clear_bit"><code class="xref c c-func docutils literal"><span class="pre">clear_bit()</span></code></a> is atomic and may not be reordered.  However, it does
not contain a memory barrier, so if it is used for locking purposes,
you should call <code class="xref c c-func docutils literal"><span class="pre">smp_mb__before_atomic()</span></code> and/or <code class="xref c c-func docutils literal"><span class="pre">smp_mb__after_atomic()</span></code>
in order to ensure changes are visible on other processors.</p>
<dl class="function">
<dt id="c.__change_bit">
void <code class="descname">__change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal"><span class="pre">change_bit()</span></code></a>, this function is non-atomic and may be reordered.
If it’s called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.</p>
<dl class="function">
<dt id="c.change_bit">
void <code class="descname">change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal"><span class="pre">change_bit()</span></code></a> is atomic and may not be reordered.
Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
<dl class="function">
<dt id="c.test_and_set_bit">
bool <code class="descname">test_and_set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.test_and_set_bit_lock">
bool <code class="descname">test_and_set_bit_lock</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value for lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as test_and_set_bit on x86.</p>
<dl class="function">
<dt id="c.__test_and_set_bit">
bool <code class="descname">__test_and_set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic and can be reordered.
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.</p>
<dl class="function">
<dt id="c.test_and_clear_bit">
bool <code class="descname">test_and_clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.__test_and_clear_bit">
bool <code class="descname">__test_and_clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic and can be reordered.
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.</p>
<p><strong>Note</strong></p>
<p>the operation is performed atomically with respect to
the local CPU, but not other CPUs. Portable code should not
rely on this behaviour.
KVM relies on this behaviour on x86 for modifying memory that is also
accessed from a hypervisor on the same CPU if running in a VM: don’t change
this without also updating arch/x86/kernel/kvm.c</p>
<dl class="function">
<dt id="c.test_and_change_bit">
bool <code class="descname">test_and_change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.test_bit">
bool <code class="descname">test_bit</code><span class="sig-paren">(</span>int<em>&nbsp;nr</em>, const volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a bit is set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>bit number to test</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<dl class="function">
<dt id="c.__ffs">
unsigned long <code class="descname">__ffs</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;word</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__ffs" title="Permalink to this definition">¶</a></dt>
<dd><p>find first set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">word</span></code></dt>
<dd>The word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undefined if no bit exists, so code should check against 0 first.</p>
<dl class="function">
<dt id="c.ffz">
unsigned long <code class="descname">ffz</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;word</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ffz" title="Permalink to this definition">¶</a></dt>
<dd><p>find first zero bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">word</span></code></dt>
<dd>The word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undefined if no zero exists, so code should check against ~0UL first.</p>
<dl class="function">
<dt id="c.ffs">
int <code class="descname">ffs</code><span class="sig-paren">(</span>int<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ffs" title="Permalink to this definition">¶</a></dt>
<dd><p>find first set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined the same way as the libc and compiler builtin ffs
routines, therefore differs in spirit from the other bitops.</p>
<p>ffs(value) returns 0 if value is 0 or the position of the first
set bit if value is nonzero. The first (least significant) bit
is at position 1.</p>
<dl class="function">
<dt id="c.fls">
int <code class="descname">fls</code><span class="sig-paren">(</span>int<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fls" title="Permalink to this definition">¶</a></dt>
<dd><p>find last set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined in a similar way as the libc and compiler builtin
ffs, but returns the position of the most significant set bit.</p>
<p>fls(value) returns 0 if value is 0 or the position of the last
set bit if value is nonzero. The last (most significant) bit is
at position 32.</p>
<dl class="function">
<dt id="c.fls64">
int <code class="descname">fls64</code><span class="sig-paren">(</span>__u64<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fls64" title="Permalink to this definition">¶</a></dt>
<dd><p>find last set bit in a 64-bit word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__u64</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined in a similar way as the libc and compiler builtin
ffsll, but returns the position of the most significant set bit.</p>
<p>fls64(value) returns 0 if value is 0 or the position of the last
set bit if value is nonzero. The last (most significant) bit is
at position 64.</p>
</div>
</div>
<div class="section" id="basic-kernel-library-functions">
<h2>Basic Kernel Library Functions<a class="headerlink" href="#basic-kernel-library-functions" title="Permalink to this headline">¶</a></h2>
<p>The Linux kernel provides more basic utility functions.</p>
<div class="section" id="bitmap-operations">
<h3>Bitmap Operations<a class="headerlink" href="#bitmap-operations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__bitmap_shift_right">
void <code class="descname">__bitmap_shift_right</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned<em>&nbsp;shift</em>, unsigned<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_right" title="Permalink to this definition">¶</a></dt>
<dd><p>logical right shift of the bits in a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">shift</span></code></dt>
<dd>shift by this many bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">nbits</span></code></dt>
<dd>bitmap size, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting right (dividing) means moving bits in the MS -&gt; LS bit
direction.  Zeros are fed into the vacated MS positions and the
LS bits shifted off the bottom are lost.</p>
<dl class="function">
<dt id="c.__bitmap_shift_left">
void <code class="descname">__bitmap_shift_left</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned int<em>&nbsp;shift</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_left" title="Permalink to this definition">¶</a></dt>
<dd><p>logical left shift of the bits in a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">shift</span></code></dt>
<dd>shift by this many bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>bitmap size, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting left (multiplying) means moving bits in the LS -&gt; MS
direction.  Zeros are fed into the vacated LS bit positions
and those MS bits shifted off the top are lost.</p>
<dl class="function">
<dt id="c.bitmap_find_next_zero_area_off">
unsigned long <code class="descname">bitmap_find_next_zero_area_off</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;map</em>, unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;start</em>, unsigned int<em>&nbsp;nr</em>, unsigned long<em>&nbsp;align_mask</em>, unsigned long<em>&nbsp;align_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_next_zero_area_off" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned zero area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">map</span></code></dt>
<dd>The address to base the search on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>The bitmap size in bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>The bitnumber to start searching at</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>The number of zeroed bits we’re looking for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_mask</span></code></dt>
<dd>Alignment mask for zero area</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_offset</span></code></dt>
<dd>Alignment offset for zero area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>align_mask</strong> should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds plus <strong>align_offset</strong>
is multiple of that power of 2.</p>
<dl class="function">
<dt id="c.__bitmap_parse">
int <code class="descname">__bitmap_parse</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;buflen</em>, int<em>&nbsp;is_user</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an ASCII hex string into a bitmap.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">is_user</span></code></dt>
<dd>location of buffer, 0 indicates kernel space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Commas group hex digits into chunks.  Each chunk defines exactly 32
bits of the resultant bitmask.  No chunk may specify a value larger
than 32 bits (<code class="docutils literal"><span class="pre">-EOVERFLOW</span></code>), and if a chunk specifies a smaller value
then leading 0-bits are prepended.  <code class="docutils literal"><span class="pre">-EINVAL</span></code> is returned for illegal
characters and for grouping errors such as “1,,5”, “,44”, “,” and “”.
Leading and trailing whitespace accepted, but not embedded whitespace.</p>
<dl class="function">
<dt id="c.bitmap_parse_user">
int <code class="descname">bitmap_parse_user</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;ubuf</em>, unsigned int<em>&nbsp;ulen</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parse_user" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an ASCII hex string in a user buffer into a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">ubuf</span></code></dt>
<dd>pointer to user buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper for <a class="reference internal" href="#c.__bitmap_parse" title="__bitmap_parse"><code class="xref c c-func docutils literal"><span class="pre">__bitmap_parse()</span></code></a>, providing it with user buffer.</p>
<p>We cannot have this as an inline function in bitmap.h because it needs
linux/uaccess.h to get the <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> declaration and this causes
cyclic dependencies.</p>
<dl class="function">
<dt id="c.bitmap_print_to_pagebuf">
int <code class="descname">bitmap_print_to_pagebuf</code><span class="sig-paren">(</span>bool<em>&nbsp;list</em>, char *<em>&nbsp;buf</em>, const unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_print_to_pagebuf" title="Permalink to this definition">¶</a></dt>
<dd><p>convert bitmap to list or hex format ASCII string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">list</span></code></dt>
<dd>indicates whether the bitmap must be list</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>page aligned buffer into which string is placed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap to convert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Output format is a comma-separated list of decimal numbers and
ranges if list is specified or hex digits grouped into comma-separated
sets of 8 digits/set. Returns the number of characters written to buf.</p>
<p>It is assumed that <strong>buf</strong> is a pointer into a PAGE_SIZE area and that
sufficient storage remains at <strong>buf</strong> to accommodate the
<a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal"><span class="pre">bitmap_print_to_pagebuf()</span></code></a> output.</p>
<dl class="function">
<dt id="c.bitmap_parselist_user">
int <code class="descname">bitmap_parselist_user</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;ubuf</em>, unsigned int<em>&nbsp;ulen</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parselist_user" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">ubuf</span></code></dt>
<dd>pointer to user buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper for <code class="xref c c-func docutils literal"><span class="pre">bitmap_parselist()</span></code>, providing it with user buffer.</p>
<p>We cannot have this as an inline function in bitmap.h because it needs
linux/uaccess.h to get the <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> declaration and this causes
cyclic dependencies.</p>
<dl class="function">
<dt id="c.bitmap_remap">
void <code class="descname">bitmap_remap</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, const unsigned long *<em>&nbsp;old</em>, const unsigned long *<em>&nbsp;new</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply map defined by a pair of bitmaps to another bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>remapped result</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>subset to be remapped</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>defines domain of map</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>defines range of map</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight ‘w’ of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>If either of the <strong>old</strong> and <strong>new</strong> bitmaps are empty, or if <strong>src</strong> and
<strong>dst</strong> point to the same location, then this routine copies <strong>src</strong>
to <strong>dst</strong>.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to <strong>src</strong>, placing the result in
<strong>dst</strong>, clearing any bits previously set in <strong>dst</strong>.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>src</strong> comes into this routine
with bits 1, 5 and 7 set, then <strong>dst</strong> should leave with bits 1,
13 and 15 set.</p>
<dl class="function">
<dt id="c.bitmap_bitremap">
int <code class="descname">bitmap_bitremap</code><span class="sig-paren">(</span>int<em>&nbsp;oldbit</em>, const unsigned long *<em>&nbsp;old</em>, const unsigned long *<em>&nbsp;new</em>, int<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_bitremap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply map defined by a pair of bitmaps to a single bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oldbit</span></code></dt>
<dd>bit position to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>defines domain of map</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>defines range of map</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight ‘w’ of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to bit position <strong>oldbit</strong>, returning
the new bit position.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>oldbit</strong> is 5, then this routine
returns 13.</p>
<dl class="function">
<dt id="c.bitmap_onto">
void <code class="descname">bitmap_onto</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;orig</em>, const unsigned long *<em>&nbsp;relmap</em>, unsigned int<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_onto" title="Permalink to this definition">¶</a></dt>
<dd><p>translate one bitmap relative to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>resulting translated bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">orig</span></code></dt>
<dd>original untranslated bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">relmap</span></code></dt>
<dd>bitmap relative to which translated</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the n-th bit of <strong>dst</strong> iff there exists some m such that the
n-th bit of <strong>relmap</strong> is set, the m-th bit of <strong>orig</strong> is set, and
the n-th bit of <strong>relmap</strong> is also the m-th _set_ bit of <strong>relmap</strong>.
(If you understood the previous sentence the first time your
read it, you’re overqualified for your current job.)</p>
<p>In other words, <strong>orig</strong> is mapped onto (surjectively) <strong>dst</strong>,
using the map { &lt;n, m&gt; | the n-th bit of <strong>relmap</strong> is the
m-th set bit of <strong>relmap</strong> }.</p>
<p>Any set bits in <strong>orig</strong> above bit number W, where W is the
weight of (number of set bits in) <strong>relmap</strong> are mapped nowhere.
In particular, if for all bits m set in <strong>orig</strong>, m &gt;= W, then
<strong>dst</strong> will end up empty.  In situations where the possibility
of such an empty result is not desired, one way to avoid it is
to use the <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> operator, below, to first fold the
<strong>orig</strong> bitmap over itself so that all its set bits x are in the
range 0 &lt;= x &lt; W.  The <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> operator does this by
setting the bit (m % W) in <strong>dst</strong>, for each bit (m) set in <strong>orig</strong>.</p>
<dl class="docutils">
<dt>Example [1] for <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a>:</dt>
<dd><p class="first">Let’s say <strong>relmap</strong> has bits 30-39 set, and <strong>orig</strong> has bits
1, 3, 5, 7, 9 and 11 set.  Then on return from this routine,
<strong>dst</strong> will have bits 31, 33, 35, 37 and 39 set.</p>
<p>When bit 0 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the first bit (if any)
that is turned on in <strong>relmap</strong>.  Since bit 0 was off in the
above example, we leave off that bit (bit 30) in <strong>dst</strong>.</p>
<p>When bit 1 is set in <strong>orig</strong> (as in the above example), it
means turn on the bit in <strong>dst</strong> corresponding to whatever
is the second bit that is turned on in <strong>relmap</strong>.  The second
bit in <strong>relmap</strong> that was turned on in the above example was
bit 31, so we turned on bit 31 in <strong>dst</strong>.</p>
<p>Similarly, we turned on bits 33, 35, 37 and 39 in <strong>dst</strong>,
because they were the 4th, 6th, 8th and 10th set bits
set in <strong>relmap</strong>, and the 4th, 6th, 8th and 10th bits of
<strong>orig</strong> (i.e. bits 3, 5, 7 and 9) were also set.</p>
<p class="last">When bit 11 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the twelfth bit that is
turned on in <strong>relmap</strong>.  In the above example, there were
only ten bits turned on in <strong>relmap</strong> (30..39), so that bit
11 was set in <strong>orig</strong> had no affect on <strong>dst</strong>.</p>
</dd>
<dt>Example [2] for <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> + <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a>:</dt>
<dd><p class="first">Let’s say <strong>relmap</strong> has these ten bits set:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>40 41 42 43 45 48 53 61 74 95
</pre></div>
</div>
<p>(for the curious, that’s 40 plus the first ten terms of the
Fibonacci sequence.)</p>
<p>Further lets say we use the following code, invoking
<a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> then bitmap_onto, as suggested above to
avoid the possibility of an empty <strong>dst</strong> result:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>unsigned long *tmp;     // a temporary bitmap&#39;s bits

bitmap_fold(tmp, orig, bitmap_weight(relmap, bits), bits);
bitmap_onto(dst, tmp, relmap, bits);
</pre></div>
</div>
<p>Then this table shows what various values of <strong>dst</strong> would be, for
various <strong>orig</strong>’s.  I list the zero-based positions of each set bit.
The tmp column shows the intermediate result, as computed by
using <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> to fold the <strong>orig</strong> bitmap modulo ten
(the weight of <strong>relmap</strong>):</p>
<blockquote class="last">
<div><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="30%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>orig</strong></td>
<td>tmp</td>
<td><strong>dst</strong></td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>40</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>41</td>
</tr>
<tr class="row-even"><td>9</td>
<td>9</td>
<td>95</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>0</td>
<td>40 <a class="footnote-reference" href="#f1" id="id1">[1]</a></td>
</tr>
<tr class="row-even"><td>1 3 5 7</td>
<td>1 3 5 7</td>
<td>41 43 48 61</td>
</tr>
<tr class="row-odd"><td>0 1 2 3 4</td>
<td>0 1 2 3 4</td>
<td>40 41 42 43 45</td>
</tr>
<tr class="row-even"><td>0 9 18 27</td>
<td>0 9 8 7</td>
<td>40 61 74 95</td>
</tr>
<tr class="row-odd"><td>0 10 20 30</td>
<td>0</td>
<td>40</td>
</tr>
<tr class="row-even"><td>0 11 22 33</td>
<td>0 1 2 3</td>
<td>40 41 42 43</td>
</tr>
<tr class="row-odd"><td>0 12 24 36</td>
<td>0 2 4 6</td>
<td>40 42 45 53</td>
</tr>
<tr class="row-even"><td>78 102 211</td>
<td>1 2 8</td>
<td>41 42 74 <a class="footnote-reference" href="#f1" id="id2">[1]</a></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
</dl>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> For these marked lines, if we hadn’t first done <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a>
into tmp, then the <strong>dst</strong> result would have been empty.</td></tr>
</tbody>
</table>
<p>If either of <strong>orig</strong> or <strong>relmap</strong> is empty (no set bits), then <strong>dst</strong>
will be returned empty.</p>
<p>If (as explained above) the only set bits in <strong>orig</strong> are in positions
m where m &gt;= W, (where W is the weight of <strong>relmap</strong>) then <strong>dst</strong> will
once again be returned empty.</p>
<p>All bits in <strong>dst</strong> not set by the above rule are cleared.</p>
<dl class="function">
<dt id="c.bitmap_fold">
void <code class="descname">bitmap_fold</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;orig</em>, unsigned int<em>&nbsp;sz</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_fold" title="Permalink to this definition">¶</a></dt>
<dd><p>fold larger bitmap into smaller, modulo specified size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>resulting smaller bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">orig</span></code></dt>
<dd>original larger bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz</span></code></dt>
<dd>specified size</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each bit oldbit in <strong>orig</strong>, set bit oldbit mod <strong>sz</strong> in <strong>dst</strong>.
Clear all other bits in <strong>dst</strong>.  See further the comment and
Example [2] for <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a> for why and how to use this.</p>
<dl class="function">
<dt id="c.bitmap_find_free_region">
int <code class="descname">bitmap_find_free_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;bits</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_free_region" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned mem region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a region of free (zero) bits in a <strong>bitmap</strong> of <strong>bits</strong> bits and
allocate them (set them to one).  Only consider regions of length
a power (<strong>order</strong>) of two, aligned to that power of two, which
makes the search algorithm much faster.</p>
<p>Return the bit offset in bitmap of the allocated region,
or -errno on failure.</p>
<dl class="function">
<dt id="c.bitmap_release_region">
void <code class="descname">bitmap_release_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;pos</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>release allocated bitmap region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>beginning of bit region to release</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the complement to <code class="xref c c-func docutils literal"><span class="pre">__bitmap_find_free_region()</span></code> and releases
the found region (by clearing it in the bitmap).</p>
<p>No return value.</p>
<dl class="function">
<dt id="c.bitmap_allocate_region">
int <code class="descname">bitmap_allocate_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;pos</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_allocate_region" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate bitmap region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>beginning of bit region to allocate</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate (set bits in) a specified region of a bitmap.</p>
<p>Return 0 on success, or <code class="docutils literal"><span class="pre">-EBUSY</span></code> if specified region wasn’t
free (not all bits were zero).</p>
<dl class="function">
<dt id="c.bitmap_from_u32array">
unsigned int <code class="descname">bitmap_from_u32array</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;nbits</em>, const u32 *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;nwords</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_u32array" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the contents of a u32 array of bits to bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs, the destination bitmap, non NULL</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in <strong>bitmap</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>array of u32 (in host byte order), the source bitmap, non NULL</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nwords</span></code></dt>
<dd>number of u32 words in <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>copy min(nbits, 32*nwords) bits from <strong>buf</strong> to <strong>bitmap</strong>, remaining
bits between nword and nbits in <strong>bitmap</strong> (if any) are cleared. In
last word of <strong>bitmap</strong>, the bits beyond nbits (if any) are kept
unchanged.</p>
<p>Return the number of bits effectively copied.</p>
<dl class="function">
<dt id="c.bitmap_to_u32array">
unsigned int <code class="descname">bitmap_to_u32array</code><span class="sig-paren">(</span>u32 *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;nwords</em>, const unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_to_u32array" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the contents of bitmap to a u32 array of bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>array of u32 (in host byte order), the dest bitmap, non NULL</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nwords</span></code></dt>
<dd>number of u32 words in <strong>buf</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs, the source bitmap, non NULL</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in <strong>bitmap</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>copy min(nbits, 32*nwords) bits from <strong>bitmap</strong> to <strong>buf</strong>. Remaining
bits after nbits in <strong>buf</strong> (if any) are cleared.</p>
<p>Return the number of bits effectively copied.</p>
<dl class="function">
<dt id="c.bitmap_copy_le">
void <code class="descname">bitmap_copy_le</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_copy_le" title="Permalink to this definition">¶</a></dt>
<dd><p>copy a bitmap, putting the bits into little-endian order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>bitmap to copy</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in the bitmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Require nbits % BITS_PER_LONG == 0.</p>
<dl class="function">
<dt id="c.__bitmap_parselist">
int <code class="descname">__bitmap_parselist</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;buflen</em>, int<em>&nbsp;is_user</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_parselist" title="Permalink to this definition">¶</a></dt>
<dd><p>convert list format ASCII string to bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>read nul-terminated user string from this buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">is_user</span></code></dt>
<dd>location of buffer, 0 indicates kernel space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>write resulting mask here</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>number of bits in mask to be written</dd>
</dl>
<p><strong>Description</strong></p>
<p>Input format is a comma-separated list of decimal numbers and
ranges.  Consecutively set bits are shown as two hyphen-separated
decimal numbers, the smallest and largest bit numbers set in
the range.
Optionally each range can be postfixed to denote that only parts of it
should be set. The range will divided to groups of specific size.
From each group will be used only defined amount of bits.
Syntax: range:used_size/group_size</p>
<p><strong>Example</strong></p>
<p>0-1023:2/256 ==&gt; 0,1,256,257,512,513,768,769</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on invalid input strings. Error values:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: second number in range smaller than first</li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: invalid character in string</li>
<li><code class="docutils literal"><span class="pre">-ERANGE</span></code>: bit number specified too large for mask</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.bitmap_pos_to_ord">
int <code class="descname">bitmap_pos_to_ord</code><span class="sig-paren">(</span>const unsigned long *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;pos</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_pos_to_ord" title="Permalink to this definition">¶</a></dt>
<dd><p>find ordinal of set bit at given position in bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to a bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>a bit position in <strong>buf</strong> (0 &lt;= <strong>pos</strong> &lt; <strong>nbits</strong>)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of valid bit positions in <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the bit at position <strong>pos</strong> in <strong>buf</strong> (of length <strong>nbits</strong>) to the
ordinal of which set bit it is.  If it is not set or if <strong>pos</strong>
is not a valid bit position, map to -1.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>pos</strong>
values 4 through 7 will get mapped to 0 through 3, respectively,
and other <strong>pos</strong> values will get mapped to -1.  When <strong>pos</strong> value 7
gets mapped to (returns) <strong>ord</strong> value 3 in this example, that means
that bit 7 is the 3rd (starting with 0th) set bit in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>bits</strong> are valid positions in <strong>buf</strong>.</p>
<dl class="function">
<dt id="c.bitmap_ord_to_pos">
unsigned int <code class="descname">bitmap_ord_to_pos</code><span class="sig-paren">(</span>const unsigned long *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;ord</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_ord_to_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find position of n-th set bit in bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ord</span></code></dt>
<dd>ordinal bit position (n-th set bit, n &gt;= 0)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of valid bit positions in <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the ordinal offset of bit <strong>ord</strong> in <strong>buf</strong> to its position in <strong>buf</strong>.
Value of <strong>ord</strong> should be in range 0 &lt;= <strong>ord</strong> &lt; weight(buf). If <strong>ord</strong>
&gt;= weight(buf), returns <strong>nbits</strong>.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>ord</strong>
values 0 through 3 will get mapped to 4 through 7, respectively,
and all other <strong>ord</strong> values returns <strong>nbits</strong>.  When <strong>ord</strong> value 3
gets mapped to (returns) <strong>pos</strong> value 7 in this example, that means
that the 3rd set bit (starting with 0th) is at position 7 in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>nbits</strong>-1 are valid positions in <strong>buf</strong>.</p>
</div>
<div class="section" id="command-line-parsing">
<h3>Command-line Parsing<a class="headerlink" href="#command-line-parsing" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.get_option">
int <code class="descname">get_option</code><span class="sig-paren">(</span>char **<em>&nbsp;str</em>, int *<em>&nbsp;pint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse integer from an option string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">str</span></code></dt>
<dd>option string</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">pint</span></code></dt>
<dd>(output) integer value parsed from <strong>str</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Read an int from an option string; if available accept a subsequent
comma as well.</p>
<p>Return values:
0 - no int in string
1 - int found, no subsequent comma
2 - int found including a subsequent comma
3 - hyphen found to denote a range</p>
</div></blockquote>
<dl class="function">
<dt id="c.get_options">
char * <code class="descname">get_options</code><span class="sig-paren">(</span>const char *<em>&nbsp;str</em>, int<em>&nbsp;nints</em>, int *<em>&nbsp;ints</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a string into a list of integers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>String to be parsed</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nints</span></code></dt>
<dd>size of integer array</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">ints</span></code></dt>
<dd>integer array</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function parses a string containing a comma-separated
list of integers, a hyphen-separated range of _positive_ integers,
or a combination of both.  The parse halts when the array is
full, or when no more numbers can be retrieved from the
string.</p>
<p>Return value is the character in the string which caused
the parse to end (typically a null terminator, if <strong>str</strong> is
completely parseable).</p>
</div></blockquote>
<dl class="function">
<dt id="c.memparse">
unsigned long long <code class="descname">memparse</code><span class="sig-paren">(</span>const char *<em>&nbsp;ptr</em>, char **<em>&nbsp;retptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memparse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a string with mem suffixes into a number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>Where parse begins</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">retptr</span></code></dt>
<dd>(output) Optional pointer to next char after parse completes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Parses a string into a number.  The number stored at <strong>ptr</strong> is
potentially suffixed with K, M, G, T, P, E.</div></blockquote>
</div>
<div class="section" id="crc-functions">
<h3>CRC Functions<a class="headerlink" href="#crc-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.crc7_be">
u8 <code class="descname">crc7_be</code><span class="sig-paren">(</span>u8<em>&nbsp;crc</em>, const u8 *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc7_be" title="Permalink to this definition">¶</a></dt>
<dd><p>update the CRC7 for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC7 value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Context</strong></p>
<p>any</p>
<p><strong>Description</strong></p>
<p>Returns the updated CRC7 value.
The CRC7 is left-aligned in the byte (the lsbit is always 0), as that
makes the computation easier, and all callers want it in that form.</p>
<dl class="function">
<dt id="c.crc16">
u16 <code class="descname">crc16</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, u8 const *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc16" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the CRC-16 for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value.</p>
<dl class="function">
<dt id="c.crc_itu_t">
u16 <code class="descname">crc_itu_t</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, const u8 *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_itu_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the CRC-ITU-T for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value</p>
<dl class="function">
<dt id="c.crc32_le_generic">
u32 __pure <code class="descname">crc32_le_generic</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, unsigned char const *<em>&nbsp;p</em>, size_t<em>&nbsp;len</em>, const u32 ( *<em>&nbsp;tab</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_le_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bitwise little-endian Ethernet AUTODIN II CRC32/CRC32C</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>seed value for computation.  ~0 for Ethernet, sometimes 0 for other
uses, or the previous crc32/crc32c value if computing incrementally.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to buffer over which CRC32/CRC32C is run</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of buffer <strong>p</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(</span> <span class="pre">*</span> <span class="pre">tab</span></code></dt>
<dd>little-endian Ethernet table</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>CRC32/CRC32c LE polynomial</dd>
</dl>
<dl class="function">
<dt id="c.crc32_generic_shift">
u32 __attribute_const__ <code class="descname">crc32_generic_shift</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, size_t<em>&nbsp;len</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_generic_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Append len 0 bytes to crc, in logarithmic time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>The original little-endian CRC (i.e. lsbit is x^31 coefficient)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>The number of bytes. <strong>crc</strong> is multiplied by x^(8***len**)</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>The modulus used to reduce the result to 32 bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It’s possible to parallelize CRC computations by computing a CRC
over separate ranges of a buffer, then summing them.
This shifts the given CRC by 8*len bits (i.e. produces the same effect
as appending len bytes of zero to the data), in time proportional
to log(len).</p>
<dl class="function">
<dt id="c.crc32_be_generic">
u32 __pure <code class="descname">crc32_be_generic</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, unsigned char const *<em>&nbsp;p</em>, size_t<em>&nbsp;len</em>, const u32 ( *<em>&nbsp;tab</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_be_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bitwise big-endian Ethernet AUTODIN II CRC32</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to buffer over which CRC32 is run</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of buffer <strong>p</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(</span> <span class="pre">*</span> <span class="pre">tab</span></code></dt>
<dd>big-endian Ethernet table</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>CRC32 BE polynomial</dd>
</dl>
<dl class="function">
<dt id="c.crc_ccitt">
u16 <code class="descname">crc_ccitt</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, u8 const *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_ccitt" title="Permalink to this definition">¶</a></dt>
<dd><p>recompute the CRC for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
</div>
<div class="section" id="idr-ida-functions">
<h3>idr/ida Functions<a class="headerlink" href="#idr-ida-functions" title="Permalink to this headline">¶</a></h3>
<p>idr synchronization (stolen from radix-tree.h)</p>
<p><code class="xref c c-func docutils literal"><span class="pre">idr_find()</span></code> is able to be called locklessly, using RCU. The caller must
ensure calls to this function are made within <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> regions.
Other readers (lock-free or otherwise) and modifications may be running
concurrently.</p>
<p>It is still required that the caller manage the synchronization and
lifetimes of the items. So if RCU lock-free lookups are used, typically
this would mean that the items have their own locks, or are amenable to
lock-free access; and that the items are freed by RCU (or only freed after
having been deleted from the idr tree <em>and</em> a <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> grace
period).</p>
<p>The IDA is an ID allocator which does not provide the ability to
associate an ID with a pointer.  As such, it only needs to store one
bit per ID, and so is more space efficient than an IDR.  To use an IDA,
define it using <code class="xref c c-func docutils literal"><span class="pre">DEFINE_IDA()</span></code> (or embed a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">ida</span></code> in a data structure,
then initialise it using <code class="xref c c-func docutils literal"><span class="pre">ida_init()</span></code>).  To allocate a new ID, call
<a class="reference internal" href="#c.ida_simple_get" title="ida_simple_get"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_get()</span></code></a>.  To free an ID, call <a class="reference internal" href="#c.ida_simple_remove" title="ida_simple_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_remove()</span></code></a>.</p>
<p>If you have more complex locking requirements, use a loop around
<code class="xref c c-func docutils literal"><span class="pre">ida_pre_get()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">ida_get_new()</span></code> to allocate a new ID.  Then use
<a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> to free an ID.  You must make sure that <code class="xref c c-func docutils literal"><span class="pre">ida_get_new()</span></code> and
<a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> cannot be called at the same time as each other for the
same IDA.</p>
<p>You can also use <a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a> if you need an ID to be allocated
above a particular number.  <a class="reference internal" href="#c.ida_destroy" title="ida_destroy"><code class="xref c c-func docutils literal"><span class="pre">ida_destroy()</span></code></a> can be used to dispose of an
IDA without needing to free the individual IDs in it.  You can use
<code class="xref c c-func docutils literal"><span class="pre">ida_is_empty()</span></code> to find out whether the IDA has any IDs currently allocated.</p>
<p>IDs are currently limited to the range [0-INT_MAX].  If this is an awkward
limitation, it should be quite straightforward to raise the maximum.</p>
<dl class="function">
<dt id="c.idr_alloc_cyclic">
int <code class="descname">idr_alloc_cyclic</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, int<em>&nbsp;start</em>, int<em>&nbsp;end</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_alloc_cyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate new idr entry in a cyclical fashion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>pointer to be associated with the new id</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>the minimum id (inclusive)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">end</span></code></dt>
<dd>the maximum id (exclusive)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an ID larger than the last ID allocated if one is available.
If not, it will attempt to allocate the smallest ID that is larger or
equal to <strong>start</strong>.</p>
<dl class="function">
<dt id="c.idr_for_each">
int <code class="descname">idr_for_each</code><span class="sig-paren">(</span>const struct idr *<em>&nbsp;idr</em>, int (*fn) (int<em>&nbsp;id</em>, void<em>&nbsp;*p</em>, void<em>&nbsp;*data</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate through all stored pointers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(int</span> <span class="pre">id,</span> <span class="pre">void</span> <span class="pre">*p,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each pointer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data passed to callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be called for each entry in <strong>idr</strong>, passing
the id, the pointer and the data pointer passed to this function.</p>
<p>If <strong>fn</strong> returns anything other than <code class="docutils literal"><span class="pre">0</span></code>, the iteration stops and that
value is returned from this function.</p>
<p><a class="reference internal" href="#c.idr_for_each" title="idr_for_each"><code class="xref c c-func docutils literal"><span class="pre">idr_for_each()</span></code></a> can be called concurrently with <code class="xref c c-func docutils literal"><span class="pre">idr_alloc()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">idr_remove()</span></code> if protected by RCU.  Newly added entries may not be
seen and deleted entries may be seen, but adding and removing entries
will not cause other entries to be skipped, nor spurious ones to be seen.</p>
<dl class="function">
<dt id="c.idr_get_next">
void * <code class="descname">idr_get_next</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, int *<em>&nbsp;nextid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_get_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Find next populated entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">nextid</span></code></dt>
<dd>Pointer to lowest possible ID to return</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next populated entry in the tree with an ID greater than
or equal to the value pointed to by <strong>nextid</strong>.  On exit, <strong>nextid</strong> is updated
to the ID of the found value.  To use in a loop, the value pointed to by
nextid must be incremented by the user.</p>
<dl class="function">
<dt id="c.idr_replace">
void * <code class="descname">idr_replace</code><span class="sig-paren">(</span>struct idr *<em>&nbsp;idr</em>, void *<em>&nbsp;ptr</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.idr_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace pointer for given id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">idr</span> <span class="pre">*</span> <span class="pre">idr</span></code></dt>
<dd>idr handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>New pointer to associate with the ID</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>Lookup key</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace the pointer registered with an ID and return the old value.
This function can be called under the RCU read lock concurrently with
<code class="xref c c-func docutils literal"><span class="pre">idr_alloc()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">idr_remove()</span></code> (as long as the ID being removed is not
the one being replaced!).</p>
<p><strong>Return</strong></p>
<p>the old value on success.  <code class="docutils literal"><span class="pre">-ENOENT</span></code> indicates that <strong>id</strong> was not
found.  <code class="docutils literal"><span class="pre">-EINVAL</span></code> indicates that <strong>id</strong> or <strong>ptr</strong> were not valid.</p>
<dl class="function">
<dt id="c.ida_get_new_above">
int <code class="descname">ida_get_new_above</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, int<em>&nbsp;start</em>, int *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_get_new_above" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate new ID above or equal to a start id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>ida handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>id to start search at</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>pointer to the allocated handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate new ID above or equal to <strong>start</strong>.  It should be called
with any required locks to ensure that concurrent calls to
<a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a> / <code class="xref c c-func docutils literal"><span class="pre">ida_get_new()</span></code> / <a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> are not allowed.
Consider using <a class="reference internal" href="#c.ida_simple_get" title="ida_simple_get"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_get()</span></code></a> if you do not have complex locking
requirements.</p>
<p>If memory is required, it will return <code class="docutils literal"><span class="pre">-EAGAIN</span></code>, you should unlock
and go back to the <code class="xref c c-func docutils literal"><span class="pre">ida_pre_get()</span></code> call.  If the ida is full, it will
return <code class="docutils literal"><span class="pre">-ENOSPC</span></code>.  On success, it will return 0.</p>
<p><strong>id</strong> returns a value in the range <strong>start</strong> … <code class="docutils literal"><span class="pre">0x7fffffff</span></code>.</p>
<dl class="function">
<dt id="c.ida_remove">
void <code class="descname">ida_remove</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the given ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>ida handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ID to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should not be called at the same time as <a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a>.</p>
<dl class="function">
<dt id="c.ida_destroy">
void <code class="descname">ida_destroy</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the contents of an ida</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>ida handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function releases all resources associated with an IDA.  When
this call returns, the IDA is empty and can be reused or freed.  The caller
should not allow <a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> or <a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a> to be called at the
same time.</p>
<dl class="function">
<dt id="c.ida_simple_get">
int <code class="descname">ida_simple_get</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, unsigned int<em>&nbsp;start</em>, unsigned int<em>&nbsp;end</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_simple_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a new id.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>the (initialized) ida.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">start</span></code></dt>
<dd>the minimum id (inclusive, &lt; 0x8000000)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">end</span></code></dt>
<dd>the maximum id (exclusive, &lt; 0x8000000 or 0)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an id in the range start &lt;= id &lt; end, or returns -ENOSPC.
On memory allocation failure, returns -ENOMEM.</p>
<p>Compared to <a class="reference internal" href="#c.ida_get_new_above" title="ida_get_new_above"><code class="xref c c-func docutils literal"><span class="pre">ida_get_new_above()</span></code></a> this function does its own locking, and
should be used unless there are special requirements.</p>
<p>Use <a class="reference internal" href="#c.ida_simple_remove" title="ida_simple_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_remove()</span></code></a> to get rid of an id.</p>
<dl class="function">
<dt id="c.ida_simple_remove">
void <code class="descname">ida_simple_remove</code><span class="sig-paren">(</span>struct ida *<em>&nbsp;ida</em>, unsigned int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ida_simple_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an allocated id.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ida</span> <span class="pre">*</span> <span class="pre">ida</span></code></dt>
<dd>the (initialized) ida.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>the id returned by ida_simple_get.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use to release an id allocated with <a class="reference internal" href="#c.ida_simple_get" title="ida_simple_get"><code class="xref c c-func docutils literal"><span class="pre">ida_simple_get()</span></code></a>.</p>
<p>Compared to <a class="reference internal" href="#c.ida_remove" title="ida_remove"><code class="xref c c-func docutils literal"><span class="pre">ida_remove()</span></code></a> this function does its own locking, and should be
used unless there are special requirements.</p>
</div>
</div>
<div class="section" id="memory-management-in-linux">
<h2>Memory Management in Linux<a class="headerlink" href="#memory-management-in-linux" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-slab-cache">
<h3>The Slab Cache<a class="headerlink" href="#the-slab-cache" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.kmalloc">
void * <code class="descname">kmalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate.</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc is the normal method of allocating memory
for objects smaller than page size in the kernel.</p>
<p>The <strong>flags</strong> argument may be one of:</p>
<p><code class="docutils literal"><span class="pre">GFP_USER</span></code> - Allocate memory on behalf of user.  May sleep.</p>
<p><code class="docutils literal"><span class="pre">GFP_KERNEL</span></code> - Allocate normal kernel ram.  May sleep.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code> - Allocation will not sleep.  May use emergency pools.</dt>
<dd>For example, use this inside interrupt handlers.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">GFP_HIGHUSER</span></code> - Allocate pages from high memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOIO</span></code> - Do not do any I/O at all while trying to get memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOFS</span></code> - Do not make any fs calls while trying to get memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOWAIT</span></code> - Allocation will not sleep.</p>
<p><code class="docutils literal"><span class="pre">__GFP_THISNODE</span></code> - Allocate node-local memory only.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">GFP_DMA</span></code> - Allocation suitable for DMA.</dt>
<dd>Should only be used for <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> caches. Otherwise, use a
slab created with SLAB_DMA.</dd>
</dl>
<p>Also it is possible to set different flags by OR’ing
in one or more of the following additional <strong>flags</strong>:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__GFP_COLD</span></code> - Request cache-cold pages instead of</dt>
<dd>trying to return cache-warm pages.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">__GFP_HIGH</span></code> - This allocation has high priority and may use emergency pools.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__GFP_NOFAIL</span></code> - Indicate that this allocation is in no way allowed to fail</dt>
<dd>(think twice before using).</dd>
<dt><code class="docutils literal"><span class="pre">__GFP_NORETRY</span></code> - If memory is not immediately available,</dt>
<dd>then give up at once.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">__GFP_NOWARN</span></code> - If allocation fails, don’t issue any warnings.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__GFP_RETRY_MAYFAIL</span></code> - Try really hard to succeed the allocation but fail</dt>
<dd>eventually.</dd>
</dl>
<p>There are other flags available as well, but these are not intended
for general use, and so are not documented here. For a full list of
potential flags, always refer to linux/gfp.h.</p>
<dl class="function">
<dt id="c.kmalloc_array">
void * <code class="descname">kmalloc_array</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc_array" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory for an array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of elements.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>element size.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kcalloc">
void * <code class="descname">kcalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kcalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory for an array. The memory is set to zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of elements.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>element size.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kzalloc">
void * <code class="descname">kzalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory. The memory is set to zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kzalloc_node">
void * <code class="descname">kzalloc_node</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed memory from a particular memory node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>memory node from which to allocate</dd>
</dl>
<dl class="function">
<dt id="c.kmem_cache_alloc">
void * <code class="descname">kmem_cache_alloc</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache to allocate from.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an object from this cache.  The flags are only relevant
if the cache has no available objects.</p>
<dl class="function">
<dt id="c.kmem_cache_alloc_node">
void * <code class="descname">kmem_cache_alloc_node</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;nodeid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an object on the specified node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache to allocate from.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nodeid</span></code></dt>
<dd>node number of the target node.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Identical to kmem_cache_alloc but it will allocate memory on the given
node, which can improve the performance for cpu bound structures.</p>
<p>Fallback to other node is possible if __GFP_THISNODE is not set.</p>
<dl class="function">
<dt id="c.kmem_cache_free">
void <code class="descname">kmem_cache_free</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocate an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache the allocation was from.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>The previously allocated object.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free an object which was previously allocated from this
cache.</p>
<dl class="function">
<dt id="c.kfree">
void <code class="descname">kfree</code><span class="sig-paren">(</span>const void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree" title="Permalink to this definition">¶</a></dt>
<dd><p>free previously allocated memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>pointer returned by kmalloc.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>objp</strong> is NULL, no operation is performed.</p>
<p>Don’t free memory not originally allocated by <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>
or you will run into trouble.</p>
<dl class="function">
<dt id="c.ksize">
size_t <code class="descname">ksize</code><span class="sig-paren">(</span>const void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ksize" title="Permalink to this definition">¶</a></dt>
<dd><p>get the actual amount of memory allocated for a given object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>Pointer to the object</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc may internally round up allocations and return more memory
than requested. <a class="reference internal" href="#c.ksize" title="ksize"><code class="xref c c-func docutils literal"><span class="pre">ksize()</span></code></a> can be used to determine the actual amount of
memory allocated. The caller may use this additional memory, even though
a smaller amount of memory was initially specified with the kmalloc call.
The caller must guarantee that objp points to a valid object previously
allocated with either <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal"><span class="pre">kmem_cache_alloc()</span></code></a>. The object
must not be freed during the duration of the call.</p>
<dl class="function">
<dt id="c.kfree_const">
void <code class="descname">kfree_const</code><span class="sig-paren">(</span>const void *<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_const" title="Permalink to this definition">¶</a></dt>
<dd><p>conditionally free memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">x</span></code></dt>
<dd>pointer to the memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function calls kfree only if <strong>x</strong> is not in .rodata section.</p>
<dl class="function">
<dt id="c.kstrdup">
char * <code class="descname">kstrdup</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<dl class="function">
<dt id="c.kstrdup_const">
const char * <code class="descname">kstrdup_const</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup_const" title="Permalink to this definition">¶</a></dt>
<dd><p>conditionally duplicate an existing const string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns source string if it is in .rodata section otherwise it
fallbacks to kstrdup.
Strings allocated by kstrdup_const should be freed by kfree_const.</p>
<dl class="function">
<dt id="c.kstrndup">
char * <code class="descname">kstrndup</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;max</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrndup" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">max</span></code></dt>
<dd>read at most <strong>max</strong> chars from <strong>s</strong></dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<p><strong>Note</strong></p>
<p>Use <a class="reference internal" href="#c.kmemdup_nul" title="kmemdup_nul"><code class="xref c c-func docutils literal"><span class="pre">kmemdup_nul()</span></code></a> instead if the size is known exactly.</p>
<dl class="function">
<dt id="c.kmemdup">
void * <code class="descname">kmemdup</code><span class="sig-paren">(</span>const void *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate region of memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>memory region to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>memory region length</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>GFP mask to use</dd>
</dl>
<dl class="function">
<dt id="c.kmemdup_nul">
char * <code class="descname">kmemdup_nul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup_nul" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a NUL-terminated string from unterminated data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The data to stringify</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>The size of the data</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<dl class="function">
<dt id="c.memdup_user">
void * <code class="descname">memdup_user</code><span class="sig-paren">(</span>const void __user *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source address in user space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure.</p>
<dl class="function">
<dt id="c.memdup_user_nul">
void * <code class="descname">memdup_user_nul</code><span class="sig-paren">(</span>const void __user *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user_nul" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space and NUL-terminate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source address in user space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure.</p>
<dl class="function">
<dt id="c.get_user_pages_fast">
int <code class="descname">get_user_pages_fast</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start</em>, int<em>&nbsp;nr_pages</em>, int<em>&nbsp;write</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_user_pages_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>pin user pages in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>starting user address</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>number of pages from start to pin</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd>whether pages will be written to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>array that receives pointers to the pages pinned.
Should be at least nr_pages long.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of pages pinned. This may be fewer than the number
requested. If nr_pages is 0 or negative, returns 0. If no pages
were pinned, returns -errno.</p>
<p>get_user_pages_fast provides equivalent functionality to get_user_pages,
operating on current and current-&gt;mm, with force=0 and vma=NULL. However
unlike get_user_pages, it must be called without mmap_sem held.</p>
<p>get_user_pages_fast may take mmap_sem and page table locks, so no
assumptions can be made about lack of locking. get_user_pages_fast is to be
implemented in a way that is advantageous (vs <code class="xref c c-func docutils literal"><span class="pre">get_user_pages()</span></code>) when the
user memory area is already faulted in and present in ptes. However if the
pages have to be faulted in, it may turn out to be slightly slower so
callers need to carefully consider what to use. On many architectures,
get_user_pages_fast simply falls back to get_user_pages.</p>
<dl class="function">
<dt id="c.kvmalloc_node">
void * <code class="descname">kvmalloc_node</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kvmalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the request.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>gfp mask for the allocation - must be compatible (superset) with GFP_KERNEL.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node to allocate from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses kmalloc to get the memory but if the allocation fails then falls back
to the vmalloc allocator. Use kvfree for freeing the memory.</p>
<p>Reclaim modifiers - __GFP_NORETRY and __GFP_NOFAIL are not supported.
__GFP_RETRY_MAYFAIL is supported, and it should be used only if kmalloc is
preferable to the vmalloc fallback, due to visible performance drawbacks.</p>
<p>Any use of gfp flags outside of GFP_KERNEL should be consulted with mm people.</p>
</div>
<div class="section" id="user-space-memory-access">
<h3>User Space Memory Access<a class="headerlink" href="#user-space-memory-access" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.access_ok">
<code class="descname">access_ok</code><span class="sig-paren">(</span><em>type</em>, <em>addr</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.access_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a user space pointer is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Type of access: <code class="docutils literal"><span class="pre">VERIFY_READ</span></code> or <code class="docutils literal"><span class="pre">VERIFY_WRITE</span></code>.  Note that
<code class="docutils literal"><span class="pre">VERIFY_WRITE</span></code> is a superset of <code class="docutils literal"><span class="pre">VERIFY_READ</span></code> - if it is safe
to write to a block, it is always safe to read from it.</dd>
<dt><code class="docutils literal"><span class="pre">addr</span></code></dt>
<dd>User space pointer to start of block to check</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>Size of block to check</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>Checks if a pointer to a block of memory in user space is valid.</p>
<p>Returns true (nonzero) if the memory block may be valid, false (zero)
if it is definitely invalid.</p>
<p>Note that, depending on architecture, this function probably just
checks that the pointer is in the user space range - after calling
this function, memory access functions may still return -EFAULT.</p>
<dl class="function">
<dt id="c.get_user">
<code class="descname">get_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a simple variable from user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Variable to store result.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Source address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p>Returns zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
<dl class="function">
<dt id="c.put_user">
<code class="descname">put_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.put_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a simple value into user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Value to copy to user space.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Destination address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p>Returns zero on success, or -EFAULT on error.</p>
<dl class="function">
<dt id="c.__get_user">
<code class="descname">__get_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a simple variable from user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Variable to store result.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Source address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p>Caller must check the pointer with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this
function.</p>
<p>Returns zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
<dl class="function">
<dt id="c.__put_user">
<code class="descname">__put_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__put_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a simple value into user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Value to copy to user space.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Destination address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p>Caller must check the pointer with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this
function.</p>
<p>Returns zero on success, or -EFAULT on error.</p>
<dl class="function">
<dt id="c.clear_user">
unsigned long <code class="descname">clear_user</code><span class="sig-paren">(</span>void __user *<em>&nbsp;to</em>, unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero a block of memory in user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>Destination address, in user space.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>Number of bytes to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.</p>
<p>Returns number of bytes that could not be cleared.
On success, this will be zero.</p>
<dl class="function">
<dt id="c.__clear_user">
unsigned long <code class="descname">__clear_user</code><span class="sig-paren">(</span>void __user *<em>&nbsp;to</em>, unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__clear_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero a block of memory in user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>Destination address, in user space.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>Number of bytes to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.  Caller must check
the specified block with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this function.</p>
<p>Returns number of bytes that could not be cleared.
On success, this will be zero.</p>
</div>
<div class="section" id="more-memory-management-functions">
<h3>More Memory Management Functions<a class="headerlink" href="#more-memory-management-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.read_cache_pages">
int <code class="descname">read_cache_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct list_head *<em>&nbsp;pages</em>, int (*filler) (void<em>&nbsp;*</em>, struct page<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>populate an address space with some pages &amp; start reads against them</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">pages</span></code></dt>
<dd>The address of a list_head which contains the target pages.  These
pages have their -&gt;index populated and are otherwise uninitialised.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*)</span> <span class="pre">filler</span></code></dt>
<dd>callback routine for filling a single page.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private data for the callback routine.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hides the details of the LRU cache etc from the filesystems.</p>
<dl class="function">
<dt id="c.page_cache_sync_readahead">
void <code class="descname">page_cache_sync_readahead</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct file_ra_state *<em>&nbsp;ra</em>, struct file *<em>&nbsp;filp</em>, pgoff_t<em>&nbsp;offset</em>, unsigned long<em>&nbsp;req_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_sync_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>generic file readahead</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which holds the pagecache and I/O vectors</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*</span> <span class="pre">ra</span></code></dt>
<dd>file_ra_state which holds the readahead state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>passed on to -&gt;:c:func:<cite>readpage()</cite> and -&gt;:c:func:<cite>readpages()</cite></dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>start offset into <strong>mapping</strong>, in pagecache page-sized units</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_size</span></code></dt>
<dd>hint: total size of the read which the caller is performing in
pagecache pages</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_sync_readahead" title="page_cache_sync_readahead"><code class="xref c c-func docutils literal"><span class="pre">page_cache_sync_readahead()</span></code></a> should be called when a cache miss happened:
it will submit the read.  The readahead logic may decide to piggyback more
pages onto the read request if access patterns suggest it will improve
performance.</p>
<dl class="function">
<dt id="c.page_cache_async_readahead">
void <code class="descname">page_cache_async_readahead</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct file_ra_state *<em>&nbsp;ra</em>, struct file *<em>&nbsp;filp</em>, struct page *<em>&nbsp;page</em>, pgoff_t<em>&nbsp;offset</em>, unsigned long<em>&nbsp;req_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_async_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>file readahead for marked pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which holds the pagecache and I/O vectors</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*</span> <span class="pre">ra</span></code></dt>
<dd>file_ra_state which holds the readahead state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>passed on to -&gt;:c:func:<cite>readpage()</cite> and -&gt;:c:func:<cite>readpages()</cite></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page at <strong>offset</strong> which has the PG_readahead flag set</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>start offset into <strong>mapping</strong>, in pagecache page-sized units</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_size</span></code></dt>
<dd>hint: total size of the read which the caller is performing in
pagecache pages</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_async_readahead" title="page_cache_async_readahead"><code class="xref c c-func docutils literal"><span class="pre">page_cache_async_readahead()</span></code></a> should be called when a page is used which
has the PG_readahead flag; this is a marker to suggest that the application
has used up enough of the readahead window that we should start pulling in
more pages.</p>
<dl class="function">
<dt id="c.delete_from_page_cache">
void <code class="descname">delete_from_page_cache</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.delete_from_page_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>delete page from page cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page which the kernel is trying to remove from page cache</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called only on pages that have been verified to be in the page
cache and locked.  It will never put the page into the free list, the caller
has a reference on the page.</p>
<dl class="function">
<dt id="c.filemap_flush">
int <code class="descname">filemap_flush</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>mostly a non-blocking flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>target address_space</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a mostly non-blocking flush.  Not suitable for data-integrity
purposes - I/O may not be started against all dirty pages.</p>
<dl class="function">
<dt id="c.filemap_range_has_page">
bool <code class="descname">filemap_range_has_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;start_byte</em>, loff_t<em>&nbsp;end_byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_range_has_page" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a page exists in range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space within which to check</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find at least one page in the range supplied, usually used to check if
direct writing in this range will trigger a writeback.</p>
<dl class="function">
<dt id="c.filemap_fdatawait_range">
int <code class="descname">filemap_fdatawait_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;start_byte</em>, loff_t<em>&nbsp;end_byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to wait for</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
in the given range and wait for all of them.  Check error status of
the address space and return it.</p>
<p>Since the error status of the address space is cleared by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<dl class="function">
<dt id="c.file_fdatawait_range">
int <code class="descname">file_fdatawait_range</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;start_byte</em>, loff_t<em>&nbsp;end_byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_fdatawait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file pointing to address space structure to wait for</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the address space that file
refers to, in the given range and wait for all of them.  Check error
status of the address space vs. the file-&gt;f_wb_err cursor and return it.</p>
<p>Since the error status of the file is advanced by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<dl class="function">
<dt id="c.filemap_fdatawait_keep_errors">
int <code class="descname">filemap_fdatawait_keep_errors</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_keep_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback without clearing errors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
and wait for all of them.  Unlike <code class="xref c c-func docutils literal"><span class="pre">filemap_fdatawait()</span></code>, this function
does not clear error status of the address space.</p>
<p>Use this function if callers don’t handle errors themselves.  Expected
call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
fsfreeze(8)</p>
<dl class="function">
<dt id="c.filemap_write_and_wait_range">
int <code class="descname">filemap_write_and_wait_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_write_and_wait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space for the pages</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<dl class="function">
<dt id="c.file_check_and_advance_wb_err">
int <code class="descname">file_check_and_advance_wb_err</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_check_and_advance_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>report wb error (if any) that was previously and advance wb_err to current one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>struct file on which the error is being reported</dd>
</dl>
<p><strong>Description</strong></p>
<p>When userland calls fsync (or something like nfsd does the equivalent), we
want to report any writeback errors that occurred since the last fsync (or
since the file was opened if there haven’t been any).</p>
<p>Grab the wb_err from the mapping. If it matches what we have in the file,
then just quickly return 0. The file is all caught up.</p>
<p>If it doesn’t match, then take the mapping value, set the “seen” flag in
it and try to swap it into place. If it works, or another task beat us
to it with the new value, then update the f_wb_err and return the error
portion. The error at this point must be reported via proper channels
(a’la fsync, or NFS COMMIT operation, etc.).</p>
<p>While we handle mapping-&gt;wb_err with atomic operations, the f_wb_err
value is protected by the f_lock since we must ensure that it reflects
the latest value swapped in for this file descriptor.</p>
<dl class="function">
<dt id="c.file_write_and_wait_range">
int <code class="descname">file_write_and_wait_range</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_write_and_wait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file pointing to address_space with pages</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<p>After writing out and waiting on the data, we check and advance the
f_wb_err cursor to the latest value, and return any errors detected there.</p>
<dl class="function">
<dt id="c.replace_page_cache_page">
int <code class="descname">replace_page_cache_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;old</em>, struct page *<em>&nbsp;new</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.replace_page_cache_page" title="Permalink to this definition">¶</a></dt>
<dd><p>replace a pagecache page with a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>page to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>page to replace with</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function replaces a page in the pagecache with a new one.  On
success it acquires the pagecache reference for the new page and
drops it for the old page.  Both the old and new pages must be
locked.  This function does not add the new page to the LRU, the
caller must do that.</p>
<p>The remove + add is atomic.  The only way this function can fail is
memory allocation failure.</p>
<dl class="function">
<dt id="c.add_to_page_cache_locked">
int <code class="descname">add_to_page_cache_locked</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_to_page_cache_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>add a locked page to the pagecache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page’s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>page index</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>page allocation mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to add a page to the pagecache. It must be locked.
This function does not add the page to the LRU.  The caller must do that.</p>
<dl class="function">
<dt id="c.add_page_wait_queue">
void <code class="descname">add_page_wait_queue</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, wait_queue_entry_t *<em>&nbsp;waiter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_page_wait_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an arbitrary waiter to a page’s wait queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>Page defining the wait queue of interest</dd>
<dt><code class="docutils literal"><span class="pre">wait_queue_entry_t</span> <span class="pre">*</span> <span class="pre">waiter</span></code></dt>
<dd>Waiter to add to the queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an arbitrary <strong>waiter</strong> to the wait queue for the nominated <strong>page</strong>.</p>
<dl class="function">
<dt id="c.unlock_page">
void <code class="descname">unlock_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_page" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock a locked page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the page and wakes up sleepers in <code class="xref c c-func docutils literal"><span class="pre">___wait_on_page_locked()</span></code>.
Also wakes sleepers in <code class="xref c c-func docutils literal"><span class="pre">wait_on_page_writeback()</span></code> because the wakeup
mechanism between PageLocked pages and PageWriteback pages is shared.
But that’s OK - sleepers in <code class="xref c c-func docutils literal"><span class="pre">wait_on_page_writeback()</span></code> just go back to sleep.</p>
<p>Note that this depends on PG_waiters being the sign bit in the byte
that contains PG_locked - thus the <code class="xref c c-func docutils literal"><span class="pre">BUILD_BUG_ON()</span></code>. That allows us to
clear the PG_locked bit and test PG_waiters at the same time fairly
portably (architectures that do LL/SC can test any bit, while x86 can
test the sign bit).</p>
<dl class="function">
<dt id="c.end_page_writeback">
void <code class="descname">end_page_writeback</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.end_page_writeback" title="Permalink to this definition">¶</a></dt>
<dd><p>end writeback against a page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page</dd>
</dl>
<dl class="function">
<dt id="c.__lock_page">
void <code class="descname">__lock_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;__page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__lock_page" title="Permalink to this definition">¶</a></dt>
<dd><p>get a lock on the page, assuming we need to sleep to get it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">__page</span></code></dt>
<dd>the page to lock</dd>
</dl>
<dl class="function">
<dt id="c.page_cache_next_hole">
pgoff_t <code class="descname">page_cache_next_hole</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned long<em>&nbsp;max_scan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_next_hole" title="Permalink to this definition">¶</a></dt>
<dd><p>find the next hole (not-present entry)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt>
<dd>maximum range to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the set [index, min(index+max_scan-1, MAX_INDEX)] for the
lowest indexed hole.</p>
<p><strong>Return</strong></p>
<p>the index of the hole if found, otherwise returns an index
outside of the set specified (in which case ‘return - index &gt;=
max_scan’ will be true). In rare cases of index wrap-around, 0 will
be returned.</p>
<p>page_cache_next_hole may be called under rcu_read_lock. However,
like radix_tree_gang_lookup, this will not atomically search a
snapshot of the tree at a single point in time. For example, if a
hole is created at index 5, then subsequently a hole is created at
index 10, page_cache_next_hole covering both indexes may return 10
if called under rcu_read_lock.</p>
<dl class="function">
<dt id="c.page_cache_prev_hole">
pgoff_t <code class="descname">page_cache_prev_hole</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned long<em>&nbsp;max_scan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_prev_hole" title="Permalink to this definition">¶</a></dt>
<dd><p>find the prev hole (not-present entry)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt>
<dd>maximum range to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search backwards in the range [max(index-max_scan+1, 0), index] for
the first hole.</p>
<p><strong>Return</strong></p>
<p>the index of the hole if found, otherwise returns an index
outside of the set specified (in which case ‘index - return &gt;=
max_scan’ will be true). In rare cases of wrap-around, ULONG_MAX
will be returned.</p>
<p>page_cache_prev_hole may be called under rcu_read_lock. However,
like radix_tree_gang_lookup, this will not atomically search a
snapshot of the tree at a single point in time. For example, if a
hole is created at index 10, then subsequently a hole is created at
index 5, page_cache_prev_hole covering both indexes may return 5 if
called under rcu_read_lock.</p>
<dl class="function">
<dt id="c.find_get_entry">
struct page * <code class="descname">find_get_entry</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>find and get a page cache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page cache index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned with an increased refcount.</p>
<p>If the slot holds a shadow entry of a previously evicted page, or a
swap entry from shmem/tmpfs, it is returned.</p>
<p>Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.find_lock_entry">
struct page * <code class="descname">find_lock_entry</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_lock_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>locate, pin and lock a page cache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page cache index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned locked and with an increased
refcount.</p>
<p>If the slot holds a shadow entry of a previously evicted page, or a
swap entry from shmem/tmpfs, it is returned.</p>
<p>Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<p><a class="reference internal" href="#c.find_lock_entry" title="find_lock_entry"><code class="xref c c-func docutils literal"><span class="pre">find_lock_entry()</span></code></a> may sleep.</p>
<dl class="function">
<dt id="c.pagecache_get_page">
struct page * <code class="descname">pagecache_get_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em>, int<em>&nbsp;fgp_flags</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pagecache_get_page" title="Permalink to this definition">¶</a></dt>
<dd><p>find and get a page reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fgp_flags</span></code></dt>
<dd>PCG flags</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>gfp mask to use for the page cache data page allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.</p>
<p>PCG flags modify how the page is returned.</p>
<p><strong>fgp_flags</strong> can be:</p>
<ul class="simple">
<li>FGP_ACCESSED: the page will be marked accessed</li>
<li>FGP_LOCK: Page is return locked</li>
<li>FGP_CREAT: If page is not present then a new page is allocated using
<strong>gfp_mask</strong> and added to the page cache and the VM’s LRU
list. The page is returned locked and with an increased
refcount. Otherwise, NULL is returned.</li>
</ul>
<p>If FGP_LOCK or FGP_CREAT are specified then the function may sleep even
if the GFP flags specified for FGP_CREAT are atomic.</p>
<p>If there is a page cache page, it is returned with an increased refcount.</p>
<dl class="function">
<dt id="c.find_get_pages_contig">
unsigned <code class="descname">find_get_pages_contig</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned int<em>&nbsp;nr_pages</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_pages_contig" title="Permalink to this definition">¶</a></dt>
<dd><p>gang contiguous pagecache lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>The address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>The starting page index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>The maximum number of pages</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>Where the resulting pages are placed</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.find_get_pages_contig" title="find_get_pages_contig"><code class="xref c c-func docutils literal"><span class="pre">find_get_pages_contig()</span></code></a> works exactly like <code class="xref c c-func docutils literal"><span class="pre">find_get_pages()</span></code>, except
that the returned number of pages are guaranteed to be contiguous.</p>
<p><a class="reference internal" href="#c.find_get_pages_contig" title="find_get_pages_contig"><code class="xref c c-func docutils literal"><span class="pre">find_get_pages_contig()</span></code></a> returns the number of pages which were found.</p>
<dl class="function">
<dt id="c.find_get_pages_tag">
unsigned <code class="descname">find_get_pages_tag</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t *<em>&nbsp;index</em>, int<em>&nbsp;tag</em>, unsigned int<em>&nbsp;nr_pages</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_pages_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find and return pages that match <strong>tag</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">*</span> <span class="pre">index</span></code></dt>
<dd>the starting page index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>the tag index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>the maximum number of pages</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>where the resulting pages are placed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like find_get_pages, except we only return pages which are tagged with
<strong>tag</strong>.   We update <strong>index</strong> to index the next page for the traversal.</p>
<dl class="function">
<dt id="c.find_get_entries_tag">
unsigned <code class="descname">find_get_entries_tag</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, int<em>&nbsp;tag</em>, unsigned int<em>&nbsp;nr_entries</em>, struct page **<em>&nbsp;entries</em>, pgoff_t *<em>&nbsp;indices</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_entries_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find and return entries that match <strong>tag</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the starting page cache index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>the tag index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_entries</span></code></dt>
<dd>the maximum number of entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">entries</span></code></dt>
<dd>where the resulting entries are placed</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">*</span> <span class="pre">indices</span></code></dt>
<dd>the cache indices corresponding to the entries in <strong>entries</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Like find_get_entries, except we only return entries which are tagged with
<strong>tag</strong>.</p>
<dl class="function">
<dt id="c.generic_file_read_iter">
ssize_t <code class="descname">generic_file_read_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_read_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>generic filesystem read routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>kernel I/O control block</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>destination for the data read</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the “<code class="xref c c-func docutils literal"><span class="pre">read_iter()</span></code>” routine for all filesystems
that can use the page cache directly.</p>
<dl class="function">
<dt id="c.filemap_fault">
int <code class="descname">filemap_fault</code><span class="sig-paren">(</span>struct vm_fault *<em>&nbsp;vmf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>read in file data for page fault handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*</span> <span class="pre">vmf</span></code></dt>
<dd>struct vm_fault containing details of the fault</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.filemap_fault" title="filemap_fault"><code class="xref c c-func docutils literal"><span class="pre">filemap_fault()</span></code></a> is invoked via the vma operations vector for a
mapped memory region to read in file data during a page fault.</p>
<p>The goto’s are kind of ugly, but this streamlines the normal case of having
it in the page cache, and handles the special cases reasonably without
having a lot of duplicated code.</p>
<p>vma-&gt;vm_mm-&gt;mmap_sem must be held on entry.</p>
<p>If our return value has VM_FAULT_RETRY set, it’s because
<code class="xref c c-func docutils literal"><span class="pre">lock_page_or_retry()</span></code> returned 0.
The mmap_sem has usually been released in this case.
See <code class="xref c c-func docutils literal"><span class="pre">__lock_page_or_retry()</span></code> for the exception.</p>
<p>If our return value does not have VM_FAULT_RETRY set, the mmap_sem
has not been released.</p>
<p>We never return with VM_FAULT_RETRY and a bit from VM_FAULT_ERROR set.</p>
<dl class="function">
<dt id="c.read_cache_page">
struct page * <code class="descname">read_cache_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, int (*filler) (void<em>&nbsp;*</em>, struct page<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page" title="Permalink to this definition">¶</a></dt>
<dd><p>read into page cache, fill it if needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page’s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*)</span> <span class="pre">filler</span></code></dt>
<dd>function to perform the read</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>first arg to filler(data, page) function, often left as NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read into the page cache. If a page already exists, and <code class="xref c c-func docutils literal"><span class="pre">PageUptodate()</span></code> is
not set, try to fill the page and wait for it to become unlocked.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<dl class="function">
<dt id="c.read_cache_page_gfp">
struct page * <code class="descname">read_cache_page_gfp</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page_gfp" title="Permalink to this definition">¶</a></dt>
<dd><p>read into page cache, using specified page allocation flags.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page’s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the page allocator flags to use if allocating</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as “read_mapping_page(mapping, index, NULL)”, but with
any new page allocations done using the specified allocation flags.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<dl class="function">
<dt id="c.__generic_file_write_iter">
ssize_t <code class="descname">__generic_file_write_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__generic_file_write_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>IO state structure (file, offset, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>iov_iter with data to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does all the work needed for actually writing data to a
file. It does all basic checks, removes SUID from the file, updates
modification times and calls proper subroutines depending on whether we
do direct IO or a standard buffered write.</p>
<p>It expects i_mutex to be grabbed unless we work on a block device or similar
object which does not need locking at all.</p>
<p>This function does <em>not</em> take care of syncing data in case of O_SYNC write.
A caller has to handle it. This is mainly due to the fact that we want to
avoid syncing under i_mutex.</p>
<dl class="function">
<dt id="c.generic_file_write_iter">
ssize_t <code class="descname">generic_file_write_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_write_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>IO state structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>iov_iter with data to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a wrapper around <a class="reference internal" href="#c.__generic_file_write_iter" title="__generic_file_write_iter"><code class="xref c c-func docutils literal"><span class="pre">__generic_file_write_iter()</span></code></a> to be used by most
filesystems. It takes care of syncing the file in case of O_SYNC file
and acquires i_mutex as needed.</p>
<dl class="function">
<dt id="c.try_to_release_page">
int <code class="descname">try_to_release_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_release_page" title="Permalink to this definition">¶</a></dt>
<dd><p>release old fs-specific metadata on a page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page which the kernel is trying to free</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (and I/O mode)</dd>
</dl>
<p><strong>Description</strong></p>
<p>The address_space is to try to release any data against the page
(presumably at page-&gt;private).  If the release was successful, return ‘1’.
Otherwise return zero.</p>
<p>This may also be called if PG_fscache is set on a page, indicating that the
page is known to the local caching routines.</p>
<p>The <strong>gfp_mask</strong> argument specifies whether I/O may be performed to release
this page (__GFP_IO), and whether the call may block (__GFP_RECLAIM &amp; __GFP_FS).</p>
<dl class="function">
<dt id="c.zap_vma_ptes">
int <code class="descname">zap_vma_ptes</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;address</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.zap_vma_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ptes mapping the vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vm_area_struct holding ptes to be zapped</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt>
<dd>starting address of pages to zap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>number of bytes to zap</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only unmaps ptes assigned to VM_PFNMAP vmas.</p>
<p>The entire address range must be fully contained within the vma.</p>
<p>Returns 0 if successful.</p>
<dl class="function">
<dt id="c.vm_insert_page">
int <code class="descname">vm_insert_page</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_page" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single page into user vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>source kernel page</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allows drivers to insert individual pages they’ve allocated
into a user vma.</p>
<p>The page has to be a nice clean _individual_ kernel allocation.
If you allocate a compound page, you need to have marked it as
such (__GFP_COMP), or manually just split the page up yourself
(see <code class="xref c c-func docutils literal"><span class="pre">split_page()</span></code>).</p>
<p>NOTE! Traditionally this was done with “<a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a>” which
took an arbitrary page protection parameter. This doesn’t allow
that. Your vma protection will have to be set up correctly, which
means that if you want a shared writable mapping, you’d better
ask for a shared writable mapping!</p>
<p>The page does not need to be reserved.</p>
<p>Usually this function is called from f_op-&gt;:c:func:<cite>mmap()</cite> handler
under mm-&gt;mmap_sem write-lock, so it can change vma-&gt;vm_flags.
Caller must set VM_MIXEDMAP on vma if it wants to call this
function from other places, for example from page-fault handler.</p>
<dl class="function">
<dt id="c.vm_insert_pfn">
int <code class="descname">vm_insert_pfn</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single pfn into user vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>source kernel pfn</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to vm_insert_page, this allows drivers to insert individual pages
they’ve allocated into a user vma. Same comments apply.</p>
<p>This function should only be called from a vm_ops-&gt;fault handler, and
in that case the handler should return NULL.</p>
<p>vma cannot be a COW mapping.</p>
<p>As this is called only for pages that do not currently exist, we
do not need to flush old virtual caches or the TLB.</p>
<dl class="function">
<dt id="c.vm_insert_pfn_prot">
int <code class="descname">vm_insert_pfn_prot</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em>, pgprot_t<em>&nbsp;pgprot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_pfn_prot" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single pfn into user vma with specified pgprot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>source kernel pfn</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">pgprot</span></code></dt>
<dd>pgprot flags for the inserted page</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is exactly like vm_insert_pfn, except that it allows drivers to
to override pgprot on a per-page basis.</p>
<p>This only makes sense for IO mappings, and it makes no sense for
cow mappings.  In general, using multiple vmas is preferable;
vm_insert_pfn_prot should only be used if using multiple VMAs is
impractical.</p>
<dl class="function">
<dt id="c.remap_pfn_range">
int <code class="descname">remap_pfn_range</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;size</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_pfn_range" title="Permalink to this definition">¶</a></dt>
<dd><p>remap kernel memory to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address to start at</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>physical address of kernel memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of map area</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>page protection flags for this mapping</dd>
</dl>
<p><strong>Note</strong></p>
<p>this is only safe if the mm semaphore is held when called.</p>
<dl class="function">
<dt id="c.vm_iomap_memory">
int <code class="descname">vm_iomap_memory</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, phys_addr_t<em>&nbsp;start</em>, unsigned long<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_iomap_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>remap memory to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">phys_addr_t</span> <span class="pre">start</span></code></dt>
<dd>start of area</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt>
<dd>size of area</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified <code class="xref c c-func docutils literal"><span class="pre">io_remap_pfn_range()</span></code> for common driver use. The
driver just needs to give us the physical memory range to be mapped,
we’ll figure out the rest from the vma information.</p>
<p>NOTE! Some drivers might want to tweak vma-&gt;vm_page_prot first to get
whatever write-combining details or similar.</p>
<dl class="function">
<dt id="c.unmap_mapping_range">
void <code class="descname">unmap_mapping_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t const<em>&nbsp;holebegin</em>, loff_t const<em>&nbsp;holelen</em>, int<em>&nbsp;even_cows</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_mapping_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap the portion of all mmaps in the specified address_space corresponding to the specified page range in the underlying file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address space containing mmaps to be unmapped.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holebegin</span></code></dt>
<dd>byte in first page to unmap, relative to the start of
the underlying file.  This will be rounded down to a PAGE_SIZE
boundary.  Note that this is different from <a class="reference internal" href="#c.truncate_pagecache" title="truncate_pagecache"><code class="xref c c-func docutils literal"><span class="pre">truncate_pagecache()</span></code></a>, which
must keep the partial page.  In contrast, we must get rid of
partial pages.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holelen</span></code></dt>
<dd>size of prospective hole in bytes.  This will be rounded
up to a PAGE_SIZE boundary.  A holelen of zero truncates to the
end of the file.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">even_cows</span></code></dt>
<dd>1 when truncating a file, unmap even private COWed pages;
but 0 when invalidating pagecache, don’t throw away private data.</dd>
</dl>
<dl class="function">
<dt id="c.follow_pfn">
int <code class="descname">follow_pfn</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;address</em>, unsigned long *<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.follow_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>look up PFN at a user virtual address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>memory mapping</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt>
<dd>user virtual address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">pfn</span></code></dt>
<dd>location to store found PFN</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only IO mappings and raw PFN mappings are allowed.</p>
<p>Returns zero and the pfn at <strong>pfn</strong> on success, -ve otherwise.</p>
<dl class="function">
<dt id="c.vm_unmap_aliases">
void <code class="descname">vm_unmap_aliases</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_aliases" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap outstanding lazy aliases in the vmap layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vmap/vmalloc layer lazily flushes kernel virtual mappings primarily
to amortize TLB flushing overheads. What this means is that any page you
have now, may, in a former life, have been mapped into kernel virtual
address by the vmap layer and so there might be some CPUs with TLB entries
still referencing that page (additional to the regular 1:1 kernel mapping).</p>
<p>vm_unmap_aliases flushes all such lazy mappings. After it returns, we can
be sure that none of the pages we have control over will have any aliases
from the vmap layer.</p>
<dl class="function">
<dt id="c.vm_unmap_ram">
void <code class="descname">vm_unmap_ram</code><span class="sig-paren">(</span>const void *<em>&nbsp;mem</em>, unsigned int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_ram" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap linear kernel address space set up by vm_map_ram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">mem</span></code></dt>
<dd>the pointer returned by vm_map_ram</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the count passed to that vm_map_ram call (cannot unmap partial)</dd>
</dl>
<dl class="function">
<dt id="c.vm_map_ram">
void * <code class="descname">vm_map_ram</code><span class="sig-paren">(</span>struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;count</em>, int<em>&nbsp;node</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_ram" title="Permalink to this definition">¶</a></dt>
<dd><p>map pages linearly into kernel virtual address (vmalloc space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>an array of pointers to the pages to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pages</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>prefer to allocate data structures on this node</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>memory protection to use. PAGE_KERNEL for regular RAM</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you use this function for less than VMAP_MAX_ALLOC pages, it could be
faster than vmap so it’s good.  But if you mix long-life and short-life
objects with <a class="reference internal" href="#c.vm_map_ram" title="vm_map_ram"><code class="xref c c-func docutils literal"><span class="pre">vm_map_ram()</span></code></a>, it could consume lots of address space through
fragmentation (especially on a 32bit machine).  You could see failures in
the end.  Please use this function for short-lived objects.</p>
<p><strong>Return</strong></p>
<p>a pointer to the address that has been mapped, or <code class="docutils literal"><span class="pre">NULL</span></code> on failure</p>
<dl class="function">
<dt id="c.unmap_kernel_range_noflush">
void <code class="descname">unmap_kernel_range_noflush</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_kernel_range_noflush" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap kernel VM area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>start of the VM area to unmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the VM area to unmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap PFN_UP(<strong>size</strong>) pages at <strong>addr</strong>.  The VM area <strong>addr</strong> and <strong>size</strong>
specify should have been allocated using <code class="xref c c-func docutils literal"><span class="pre">get_vm_area()</span></code> and its
friends.</p>
<p><strong>NOTE</strong></p>
<p>This function does NOT do any cache flushing.  The caller is
responsible for calling <code class="xref c c-func docutils literal"><span class="pre">flush_cache_vunmap()</span></code> on to-be-mapped areas
before calling this function and <code class="xref c c-func docutils literal"><span class="pre">flush_tlb_kernel_range()</span></code> after.</p>
<dl class="function">
<dt id="c.unmap_kernel_range">
void <code class="descname">unmap_kernel_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_kernel_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap kernel VM area and flush cache and TLB</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>start of the VM area to unmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the VM area to unmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.unmap_kernel_range_noflush" title="unmap_kernel_range_noflush"><code class="xref c c-func docutils literal"><span class="pre">unmap_kernel_range_noflush()</span></code></a> but flushes vcache before
the unmapping and tlb after.</p>
<dl class="function">
<dt id="c.vfree">
void <code class="descname">vfree</code><span class="sig-paren">(</span>const void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfree" title="Permalink to this definition">¶</a></dt>
<dd><p>release memory allocated by <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>memory base address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Free the virtually continuous memory area starting at <strong>addr</strong>, as
obtained from <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code></a>, <a class="reference internal" href="#c.vmalloc_32" title="vmalloc_32"><code class="xref c c-func docutils literal"><span class="pre">vmalloc_32()</span></code></a> or <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code>. If <strong>addr</strong> is
NULL, no operation is performed.</p>
<p>Must not be called in NMI context (strictly speaking, only if we don’t
have CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG, but making the calling
conventions for <a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal"><span class="pre">vfree()</span></code></a> arch-depenedent would be a really bad idea)</p>
</div></blockquote>
<p><strong>NOTE</strong></p>
<p>assumes that the object at <strong>addr</strong> has a size &gt;= sizeof(llist_node)</p>
<dl class="function">
<dt id="c.vunmap">
void <code class="descname">vunmap</code><span class="sig-paren">(</span>const void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>release virtual mapping obtained by <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal"><span class="pre">vmap()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>memory base address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Free the virtually contiguous memory area starting at <strong>addr</strong>,
which was created from the page array passed to <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal"><span class="pre">vmap()</span></code></a>.</p>
<p>Must not be called in interrupt context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.vmap">
void * <code class="descname">vmap</code><span class="sig-paren">(</span>struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;count</em>, unsigned long<em>&nbsp;flags</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map an array of pages into virtually contiguous space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>array of page pointers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pages to map</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>vm_area-&gt;flags</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>page protection for the mapping</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Maps <strong>count</strong> pages from <strong>pages</strong> into contiguous kernel virtual
space.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc">
void * <code class="descname">vmalloc</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size
Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</div></blockquote>
<dl class="function">
<dt id="c.vzalloc">
void * <code class="descname">vzalloc</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vzalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory with zero fill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size
Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.
The memory allocated is set to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc_user">
void * <code class="descname">vmalloc_user</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_user" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed virtually contiguous memory for userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The resulting memory area is zeroed so it can be mapped to userspace
without leaking data.</p>
<dl class="function">
<dt id="c.vmalloc_node">
void * <code class="descname">vmalloc_node</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory on a specific node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</p>
<p>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</p>
</div></blockquote>
<dl class="function">
<dt id="c.vzalloc_node">
void * <code class="descname">vzalloc_node</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vzalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory on a specific node with zero fill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.
The memory allocated is set to zero.</p>
<p>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc_node()</span></code> instead.</p>
<dl class="function">
<dt id="c.vmalloc_32">
void * <code class="descname">vmalloc_32</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_32" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory (32bit addressable)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Allocate enough 32bit PA addressable pages to cover <strong>size</strong> from the
page level allocator and map them into contiguous kernel virtual space.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc_32_user">
void * <code class="descname">vmalloc_32_user</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_32_user" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed virtually contiguous 32bit memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The resulting memory area is 32bit addressable and zeroed so it can be
mapped to userspace without leaking data.</p>
<dl class="function">
<dt id="c.remap_vmalloc_range_partial">
int <code class="descname">remap_vmalloc_range_partial</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;uaddr</em>, void *<em>&nbsp;kaddr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_vmalloc_range_partial" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc pages to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma to cover</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">uaddr</span></code></dt>
<dd>target user address to start at</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">kaddr</span></code></dt>
<dd>virtual address of vmalloc kernel memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of map area</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -Exxx on failure</p>
<blockquote>
<div><p>This function checks that <strong>kaddr</strong> is a valid vmalloc’ed area,
and that it is big enough to cover the range starting at
<strong>uaddr</strong> in <strong>vma</strong>. Will return failure if that criteria isn’t
met.</p>
<p>Similar to <a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a> (see mm/memory.c)</p>
</div></blockquote>
<dl class="function">
<dt id="c.remap_vmalloc_range">
int <code class="descname">remap_vmalloc_range</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, void *<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pgoff</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_vmalloc_range" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc pages to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma to cover (map full range of vma)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>vmalloc memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt>
<dd>number of pages into addr before first page to map</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -Exxx on failure</p>
<blockquote>
<div><p>This function checks that addr is a valid vmalloc’ed area, and
that it is big enough to cover the vma. Will return failure if
that criteria isn’t met.</p>
<p>Similar to <a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a> (see mm/memory.c)</p>
</div></blockquote>
<dl class="function">
<dt id="c.alloc_vm_area">
struct vm_struct * <code class="descname">alloc_vm_area</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, pte_t **<em>&nbsp;ptes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_vm_area" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a range of kernel address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the area</dd>
<dt><code class="docutils literal"><span class="pre">pte_t</span> <span class="pre">**</span> <span class="pre">ptes</span></code></dt>
<dd>returns the PTEs for the address space</dd>
</dl>
<p><strong>Return</strong></p>
<p>NULL on failure, vm_struct on success</p>
<blockquote>
<div><p>This function reserves a range of kernel address space, and
allocates pagetables to map that range.  No actual mappings
are created.</p>
<p>If <strong>ptes</strong> is non-NULL, pointers to the PTEs (in init_mm)
allocated for the VM area are returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__get_pfnblock_flags_mask">
unsigned long <code class="descname">__get_pfnblock_flags_mask</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;end_bitidx</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_pfnblock_flags_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the requested group of flags for the pageblock_nr_pages block of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page within the block of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>The target page frame number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_bitidx</span></code></dt>
<dd>The last bit of interest to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>mask of bits that the caller is interested in</dd>
</dl>
<p><strong>Return</strong></p>
<p>pageblock_bits flags</p>
<dl class="function">
<dt id="c.set_pfnblock_flags_mask">
void <code class="descname">set_pfnblock_flags_mask</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, unsigned long<em>&nbsp;flags</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;end_bitidx</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_pfnblock_flags_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the requested group of flags for a pageblock_nr_pages block of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page within the block of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>The flags to set</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>The target page frame number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_bitidx</span></code></dt>
<dd>The last bit of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>mask of bits that the caller is interested in</dd>
</dl>
<dl class="function">
<dt id="c.alloc_pages_exact_nid">
void * <code class="descname">alloc_pages_exact_nid</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_exact_nid" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an exact number of physically-contiguous pages on a node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>the preferred node ID where memory should be allocated</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the number of bytes to allocate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP flags for the allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <code class="xref c c-func docutils literal"><span class="pre">alloc_pages_exact()</span></code>, but try to allocate on node nid first before falling
back.</p>
<dl class="function">
<dt id="c.nr_free_zone_pages">
unsigned long <code class="descname">nr_free_zone_pages</code><span class="sig-paren">(</span>int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_zone_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>The zone index of the highest zone</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_zone_pages" title="nr_free_zone_pages"><code class="xref c c-func docutils literal"><span class="pre">nr_free_zone_pages()</span></code></a> counts the number of counts pages which are beyond the
high watermark within all zones at or below a given zone index.  For each
zone, the number of pages is calculated as:</p>
<blockquote>
<div>nr_free_zone_pages = managed_pages - high_pages</div></blockquote>
<dl class="function">
<dt id="c.nr_free_pagecache_pages">
unsigned long <code class="descname">nr_free_pagecache_pages</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_pagecache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_pagecache_pages" title="nr_free_pagecache_pages"><code class="xref c c-func docutils literal"><span class="pre">nr_free_pagecache_pages()</span></code></a> counts the number of pages which are beyond the
high watermark within all zones.</p>
<dl class="function">
<dt id="c.find_next_best_node">
int <code class="descname">find_next_best_node</code><span class="sig-paren">(</span>int<em>&nbsp;node</em>, nodemask_t *<em>&nbsp;used_node_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_next_best_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the next node that should appear in a given node’s fallback list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>node whose fallback list we’re appending</dd>
<dt><code class="docutils literal"><span class="pre">nodemask_t</span> <span class="pre">*</span> <span class="pre">used_node_mask</span></code></dt>
<dd>nodemask_t of already used nodes</dd>
</dl>
<p><strong>Description</strong></p>
<p>We use a number of factors to determine which is the next node that should
appear on a given node’s fallback list.  The node should not have appeared
already in <strong>node</strong>’s fallback list, and it should be the next closest node
according to the distance array (which contains arbitrary distance values
from each node to each node in the system), and should also prefer nodes
with no CPUs, since presumably they’ll have very little allocation pressure
on them otherwise.
It returns -1 if no node is found.</p>
<dl class="function">
<dt id="c.free_bootmem_with_active_regions">
void <code class="descname">free_bootmem_with_active_regions</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em>, unsigned long<em>&nbsp;max_low_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_bootmem_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Call memblock_free_early_nid for each active range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The node to free memory on. If MAX_NUMNODES, all nodes are freed.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_low_pfn</span></code></dt>
<dd>The highest PFN that will be passed to memblock_free_early_nid</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an architecture guarantees that all ranges registered contain no holes
and may be freed, this this function may be used instead of calling
<code class="xref c c-func docutils literal"><span class="pre">memblock_free_early_nid()</span></code> manually.</p>
<dl class="function">
<dt id="c.sparse_memory_present_with_active_regions">
void <code class="descname">sparse_memory_present_with_active_regions</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_memory_present_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Call memory_present for each active range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The node to call memory_present for. If MAX_NUMNODES, all nodes will be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an architecture guarantees that all ranges registered contain no holes and may
be freed, this function may be used instead of calling <code class="xref c c-func docutils literal"><span class="pre">memory_present()</span></code> manually.</p>
<dl class="function">
<dt id="c.get_pfn_range_for_nid">
void <code class="descname">get_pfn_range_for_nid</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;nid</em>, unsigned long *<em>&nbsp;start_pfn</em>, unsigned long *<em>&nbsp;end_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_pfn_range_for_nid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the start and end page frames for a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The nid to return the range for. If MAX_NUMNODES, the min and max PFN are returned.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">start_pfn</span></code></dt>
<dd>Passed by reference. On return, it will have the node start_pfn.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">end_pfn</span></code></dt>
<dd>Passed by reference. On return, it will have the node end_pfn.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the start and end page frame of a node based on information
provided by <code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>. If called for a node
with no available memory, a warning is printed and the start and end
PFNs will be 0.</p>
<dl class="function">
<dt id="c.absent_pages_in_range">
unsigned long <code class="descname">absent_pages_in_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start_pfn</em>, unsigned long<em>&nbsp;end_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.absent_pages_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of page frames in holes within a range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start_pfn</span></code></dt>
<dd>The start PFN to start searching for holes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_pfn</span></code></dt>
<dd>The end PFN to stop searching for holes</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the number of pages frames in memory holes within a range.</p>
<dl class="function">
<dt id="c.node_map_pfn_alignment">
unsigned long <code class="descname">node_map_pfn_alignment</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.node_map_pfn_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the maximum internode alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called after node map is populated and sorted.
It calculates the maximum power of two alignment which can distinguish
all the nodes.</p>
<p>For example, if all nodes are 1GiB and aligned to 1GiB, the return value
would indicate 1GiB alignment with (1 &lt;&lt; (30 - PAGE_SHIFT)).  If the
nodes are shifted by 256MiB, 256MiB.  Note that if only the last node is
shifted, 1GiB is enough and this function will indicate so.</p>
<p>This is used to test whether pfn -&gt; nid mapping of the chosen memory
model has fine enough granularity to avoid incorrect mapping for the
populated node map.</p>
<p>Returns the determined alignment in pfn’s.  0 if there is no alignment
requirement (single node).</p>
<dl class="function">
<dt id="c.find_min_pfn_with_active_regions">
unsigned long <code class="descname">find_min_pfn_with_active_regions</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.find_min_pfn_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum PFN registered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the minimum PFN based on information provided via
<code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>.</p>
<dl class="function">
<dt id="c.free_area_init_nodes">
void <code class="descname">free_area_init_nodes</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;max_zone_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_area_init_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise all pg_data_t and zone data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">max_zone_pfn</span></code></dt>
<dd>an array of max PFNs for each zone</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will call <code class="xref c c-func docutils literal"><span class="pre">free_area_init_node()</span></code> for each active node in the system.
Using the page ranges provided by <code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>, the size of each
zone in each node and their holes is calculated. If the maximum PFN
between two adjacent zones match, it is assumed that the zone is empty.
For example, if arch_max_dma_pfn == arch_max_dma32_pfn, it is assumed
that arch_max_dma32_pfn has no pages. It is also assumed that a zone
starts where the previous one ended. For example, ZONE_DMA32 starts
at arch_max_dma_pfn.</p>
<dl class="function">
<dt id="c.set_dma_reserve">
void <code class="descname">set_dma_reserve</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;new_dma_reserve</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_dma_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>set the specified number of pages reserved in the first zone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">new_dma_reserve</span></code></dt>
<dd>The number of pages to mark reserved</dd>
</dl>
<p><strong>Description</strong></p>
<p>The per-cpu batchsize and zone watermarks are determined by managed_pages.
In the DMA zone, a significant percentage may be consumed by kernel image
and other unfreeable allocations which can skew the watermarks badly. This
function may optionally be used to account for unfreeable pages in the
first zone (e.g., ZONE_DMA). The effect will be lower watermarks and
smaller per-cpu batchsize.</p>
<dl class="function">
<dt id="c.setup_per_zone_wmarks">
void <code class="descname">setup_per_zone_wmarks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.setup_per_zone_wmarks" title="Permalink to this definition">¶</a></dt>
<dd><p>called when min_free_kbytes changes or when memory is hot-{added|removed}</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures that the watermark[min,low,high] values for each zone are set
correctly with respect to min_free_kbytes.</p>
<dl class="function">
<dt id="c.alloc_contig_range">
int <code class="descname">alloc_contig_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em>, unsigned<em>&nbsp;migratetype</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_contig_range" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>tries to allocate given range of pages</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>start PFN to allocate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>one-past-the-last PFN to allocate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">migratetype</span></code></dt>
<dd>migratetype of the underlaying pageblocks (either
#MIGRATE_MOVABLE or #MIGRATE_CMA).  All pageblocks
in range must have the same migratetype and it must
be either of the two.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP mask to use during compaction</dd>
</dl>
<p><strong>Description</strong></p>
<p>The PFN range does not have to be pageblock or MAX_ORDER_NR_PAGES
aligned, however it’s the caller’s responsibility to guarantee that
we are the only thread that changes migrate type of pageblocks the
pages fall in.</p>
<p>The PFN range must belong to a single zone.</p>
<p>Returns zero on success or negative error code.  On success all
pages which PFN is in [start, end) are allocated for the caller and
need to be freed with <code class="xref c c-func docutils literal"><span class="pre">free_contig_range()</span></code>.</p>
<dl class="function">
<dt id="c.mempool_destroy">
void <code class="descname">mempool_destroy</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all reserved elements in <strong>pool</strong> and <strong>pool</strong> itself.  This function
only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code> function sleeps.</p>
<dl class="function">
<dt id="c.mempool_create">
mempool_t * <code class="descname">mempool_create</code><span class="sig-paren">(</span>int<em>&nbsp;min_nr</em>, mempool_alloc_t *<em>&nbsp;alloc_fn</em>, mempool_free_t *<em>&nbsp;free_fn</em>, void *<em>&nbsp;pool_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_nr</span></code></dt>
<dd>the minimum number of elements guaranteed to be
allocated for this pool.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_alloc_t</span> <span class="pre">*</span> <span class="pre">alloc_fn</span></code></dt>
<dd>user-defined element-allocation function.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_free_t</span> <span class="pre">*</span> <span class="pre">free_fn</span></code></dt>
<dd>user-defined element-freeing function.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pool_data</span></code></dt>
<dd>optional private data available to the user-defined functions.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function creates and allocates a guaranteed size, preallocated
memory pool. The pool can be used from the <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> and <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a>
functions. This function might sleep. Both the <code class="xref c c-func docutils literal"><span class="pre">alloc_fn()</span></code> and the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code>
functions might sleep - as long as the <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> function is not called
from IRQ contexts.</p>
<dl class="function">
<dt id="c.mempool_resize">
int <code class="descname">mempool_resize</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em>, int<em>&nbsp;new_min_nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_resize" title="Permalink to this definition">¶</a></dt>
<dd><p>resize an existing memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_min_nr</span></code></dt>
<dd>the new minimum number of elements guaranteed to be
allocated for this pool.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function shrinks/grows the pool. In the case of growing,
it cannot be guaranteed that the pool will be grown to the new
size immediately, but new <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a> calls will refill it.
This function may sleep.</p>
<p>Note, the caller must guarantee that no mempool_destroy is called
while this function is running. <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> &amp; <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a>
might be called (eg. from IRQ contexts) while this function executes.</p>
<dl class="function">
<dt id="c.mempool_alloc">
void * <code class="descname">mempool_alloc</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an element from a specific memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>the usual allocation bitmask.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">alloc_fn()</span></code> function sleeps or
returns NULL. Note that due to preallocation, this function
<em>never</em> fails when called from process contexts. (it might
fail if called from an IRQ context.)</p>
<p><strong>Note</strong></p>
<p>using __GFP_ZERO is not supported.</p>
<dl class="function">
<dt id="c.mempool_free">
void <code class="descname">mempool_free</code><span class="sig-paren">(</span>void *<em>&nbsp;element</em>, mempool_t *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_free" title="Permalink to this definition">¶</a></dt>
<dd><p>return an element to the pool.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">element</span></code></dt>
<dd>pool element pointer.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code> function sleeps.</p>
<dl class="function">
<dt id="c.dma_pool_create">
struct dma_pool * <code class="descname">dma_pool_create</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;align</em>, size_t<em>&nbsp;boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a pool of consistent memory blocks, for dma.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of pool, for diagnostics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that will be doing the DMA</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the blocks in this pool.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requirement for blocks; must be a power of two</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">boundary</span></code></dt>
<dd>returned blocks won’t cross this power of two boundary</dd>
</dl>
<p><strong>Context</strong></p>
<p>!:c:func:<cite>in_interrupt()</cite></p>
<p><strong>Description</strong></p>
<p>Returns a dma allocation pool with the requested characteristics, or
null if one can’t be created.  Given one of these pools, <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_alloc()</span></code></a>
may be used to allocate memory.  Such memory will all have “consistent”
DMA mappings, accessible by the device and its driver without using
cache flushing primitives.  The actual size of blocks allocated may be
larger than requested because of alignment.</p>
<p>If <strong>boundary</strong> is nonzero, objects returned from <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_alloc()</span></code></a> won’t
cross that size boundary.  This is useful for devices which have
addressing restrictions on individual DMA transfers, such as not crossing
boundaries of 4KBytes.</p>
<dl class="function">
<dt id="c.dma_pool_destroy">
void <code class="descname">dma_pool_destroy</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroys a pool of dma memory blocks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will be destroyed</dd>
</dl>
<p><strong>Context</strong></p>
<p>!:c:func:<cite>in_interrupt()</cite></p>
<p><strong>Description</strong></p>
<p>Caller guarantees that no more memory from the pool is in use,
and that nothing will try to use the pool after this call.</p>
<dl class="function">
<dt id="c.dma_pool_alloc">
void * <code class="descname">dma_pool_alloc</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em>, gfp_t<em>&nbsp;mem_flags</em>, dma_addr_t *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>get a block of consistent memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will produce the block</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt>
<dd>GFP_* bitmask</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>pointer to dma address of block</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the kernel virtual address of a currently unused block,
and reports its dma address through the handle.
If such a memory block can’t be allocated, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.dma_pool_free">
void <code class="descname">dma_pool_free</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em>, void *<em>&nbsp;vaddr</em>, dma_addr_t<em>&nbsp;dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_free" title="Permalink to this definition">¶</a></dt>
<dd><p>put block back into dma pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>the dma pool holding the block</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>virtual address of block</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">dma</span></code></dt>
<dd>dma address of block</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller promises neither device nor driver will again touch this block
unless it is first re-allocated.</p>
<dl class="function">
<dt id="c.dmam_pool_create">
struct dma_pool * <code class="descname">dmam_pool_create</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;align</em>, size_t<em>&nbsp;allocation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_create" title="dma_pool_create"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_create()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of pool, for diagnostics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that will be doing the DMA</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the blocks in this pool.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requirement for blocks; must be a power of two</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">allocation</span></code></dt>
<dd>returned blocks won’t cross this boundary (or zero)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_create" title="dma_pool_create"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_create()</span></code></a>.  DMA pool created with this function is
automatically destroyed on driver detach.</p>
<dl class="function">
<dt id="c.dmam_pool_destroy">
void <code class="descname">dmam_pool_destroy</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_destroy()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will be destroyed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_destroy()</span></code></a>.</p>
<dl class="function">
<dt id="c.balance_dirty_pages_ratelimited">
void <code class="descname">balance_dirty_pages_ratelimited</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.balance_dirty_pages_ratelimited" title="Permalink to this definition">¶</a></dt>
<dd><p>balance dirty memory state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which was dirtied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes which are dirtying memory should call in here once for each page
which was newly dirtied.  The function will periodically check the system’s
dirty state and will initiate writeback if needed.</p>
<p>On really big machines, get_writeback_state is expensive, so try to avoid
calling it too often (ratelimiting).  But once we’re over the dirty memory
limit we decrease the ratelimiting by a lot, to prevent individual processes
from overshooting the limit by (ratelimit_pages) each.</p>
<dl class="function">
<dt id="c.tag_pages_for_writeback">
void <code class="descname">tag_pages_for_writeback</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tag_pages_for_writeback" title="Permalink to this definition">¶</a></dt>
<dd><p>tag pages to be written by write_cache_pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>starting page index</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>ending page index (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function scans the page range from <strong>start</strong> to <strong>end</strong> (inclusive) and tags
all pages that have DIRTY tag set with a special TOWRITE tag. The idea is
that write_cache_pages (or whoever calls this function) will then use
TOWRITE tag to identify pages eligible for writeback.  This mechanism is
used to avoid livelocking of writeback by a process steadily creating new
dirty pages in the file (thus it is important for this function to be quick
so that it can tag pages faster than a dirtying process can create them).</p>
<dl class="function">
<dt id="c.write_cache_pages">
int <code class="descname">write_cache_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct writeback_control *<em>&nbsp;wbc</em>, writepage_t<em>&nbsp;writepage</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_cache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space and write all of them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>subtract the number of written pages from <strong>*wbc</strong>-&gt;nr_to_write</dd>
<dt><code class="docutils literal"><span class="pre">writepage_t</span> <span class="pre">writepage</span></code></dt>
<dd>function called for each page</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data passed to writepage function</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a page is already under I/O, <a class="reference internal" href="#c.write_cache_pages" title="write_cache_pages"><code class="xref c c-func docutils literal"><span class="pre">write_cache_pages()</span></code></a> skips it, even
if it’s dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>.  <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">msync()</span></code> need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.</p>
<p>To avoid livelocks (when other process dirties new pages), we first tag
pages which should be written back with TOWRITE tag and only then start
writing them. For data-integrity sync we have to be careful so that we do
not miss some pages (e.g., because some other process has cleared TOWRITE
tag we set). The rule we follow is that TOWRITE tag can be cleared only
by the process clearing the DIRTY tag (and submitting the page for IO).</p>
<dl class="function">
<dt id="c.generic_writepages">
int <code class="descname">generic_writepages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct writeback_control *<em>&nbsp;wbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_writepages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space and <code class="xref c c-func docutils literal"><span class="pre">writepage()</span></code> all of them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>subtract the number of written pages from <strong>*wbc</strong>-&gt;nr_to_write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a library function, which implements the <code class="xref c c-func docutils literal"><span class="pre">writepages()</span></code>
address_space_operation.</p>
<dl class="function">
<dt id="c.write_one_page">
int <code class="descname">write_one_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_one_page" title="Permalink to this definition">¶</a></dt>
<dd><p>write out a single page and wait on I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page must be locked by the caller and will be unlocked upon return.</p>
<p>Note that the mapping’s AS_EIO/AS_ENOSPC flags will be cleared when this
function returns.</p>
<dl class="function">
<dt id="c.wait_for_stable_page">
void <code class="descname">wait_for_stable_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_for_stable_page" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback to finish, if necessary.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page to wait on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function determines if the given page is related to a backing device
that requires page contents to be held stable during writeback.  If so, then
it will wait for any pending writeback to complete.</p>
<dl class="function">
<dt id="c.truncate_inode_pages_range">
void <code class="descname">truncate_inode_pages_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_range" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate range of pages specified by start &amp; end byte offsets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset from which to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset to which to truncate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncate the page cache, removing the pages that are between
specified offsets (and zeroing out partial pages
if lstart or lend + 1 is not page aligned).</p>
<p>Truncate takes two passes - the first pass is nonblocking.  It will not
block on page locks and it will not block on writeback.  The second pass
will wait.  This is to prevent as much IO as possible in the affected region.
The first pass will remove most pages, so the search cost of the second pass
is low.</p>
<p>We pass down the cache-hot hint to the page freeing code.  Even if the
mapping is large, it is probably the case that the final pages are the most
recently touched, and freeing happens in ascending file offset order.</p>
<p>Note that since -&gt;:c:func:<cite>invalidatepage()</cite> accepts range to invalidate
truncate_inode_pages_range is able to handle cases where lend + 1 is not
page aligned properly.</p>
<dl class="function">
<dt id="c.truncate_inode_pages">
void <code class="descname">truncate_inode_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate <em>all</em> the pages from an offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset from which to truncate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialised by) inode-&gt;i_mutex.</p>
<p><strong>Note</strong></p>
<p>When this function returns, there can be a page in the process of
deletion (inside <code class="xref c c-func docutils literal"><span class="pre">__delete_from_page_cache()</span></code>) in the specified range.  Thus
mapping-&gt;nrpages can be non-zero when this function returns even after
truncation of the whole mapping.</p>
<dl class="function">
<dt id="c.truncate_inode_pages_final">
void <code class="descname">truncate_inode_pages_final</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_final" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate <em>all</em> pages before inode dies</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialized by) inode-&gt;i_mutex.</p>
<p>Filesystems have to use this in the .evict_inode path to inform the
VM that this is the final truncate and the inode is going away.</p>
<dl class="function">
<dt id="c.invalidate_mapping_pages">
unsigned long <code class="descname">invalidate_mapping_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_mapping_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate all the unlocked pages of one inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space which holds the pages to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the offset ‘from’ which to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>the offset ‘to’ which to invalidate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only removes the unlocked pages, if you want to
remove all the pages of one inode, you must call truncate_inode_pages.</p>
<p><a class="reference internal" href="#c.invalidate_mapping_pages" title="invalidate_mapping_pages"><code class="xref c c-func docutils literal"><span class="pre">invalidate_mapping_pages()</span></code></a> will not block on IO activity. It will not
invalidate pages which are dirty, locked, under writeback or mapped into
pagetables.</p>
<dl class="function">
<dt id="c.invalidate_inode_pages2_range">
int <code class="descname">invalidate_inode_pages2_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2_range" title="Permalink to this definition">¶</a></dt>
<dd><p>remove range of pages from an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the page offset ‘from’ which to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>the page offset ‘to’ which to invalidate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p>Returns -EBUSY if any pages could not be invalidated.</p>
<dl class="function">
<dt id="c.invalidate_inode_pages2">
int <code class="descname">invalidate_inode_pages2</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all pages from an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p>Returns -EBUSY if any pages could not be invalidated.</p>
<dl class="function">
<dt id="c.truncate_pagecache">
void <code class="descname">truncate_pagecache</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;newsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap and remove pagecache that has been truncated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt>
<dd>new file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>inode’s new i_size must already be written before truncate_pagecache
is called.</p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
<dl class="function">
<dt id="c.truncate_setsize">
void <code class="descname">truncate_setsize</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;newsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_setsize" title="Permalink to this definition">¶</a></dt>
<dd><p>update inode and pagecache for a new file size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt>
<dd>new file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>truncate_setsize updates i_size and performs pagecache truncation (if
necessary) to <strong>newsize</strong>. It will be typically be called from the filesystem’s
setattr function when ATTR_SIZE is passed in.</p>
<p>Must be called with a lock serializing truncates and writes (generally
i_mutex but e.g. xfs uses a different lock) and before all filesystem
specific block truncation has been performed.</p>
<dl class="function">
<dt id="c.pagecache_isize_extended">
void <code class="descname">pagecache_isize_extended</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;from</em>, loff_t<em>&nbsp;to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pagecache_isize_extended" title="Permalink to this definition">¶</a></dt>
<dd><p>update pagecache after extension of i_size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode for which i_size was extended</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt>
<dd>original inode size</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt>
<dd>new inode size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle extension of inode size either caused by extending truncate or by
write starting after current i_size. We mark the page straddling current
i_size RO so that <code class="xref c c-func docutils literal"><span class="pre">page_mkwrite()</span></code> is called on the nearest write access to
the page.  This way filesystem can be sure that <code class="xref c c-func docutils literal"><span class="pre">page_mkwrite()</span></code> is called on
the page before user writes to the page via mmap after the i_size has been
changed.</p>
<p>The function must be called after i_size is updated so that page fault
coming after we unlock the page will already see the new i_size.
The function must be called while we still hold i_mutex - this not only
makes sure i_size is stable but also that userspace cannot observe new
i_size value before we are prepared to store mmap writes at new inode size.</p>
<dl class="function">
<dt id="c.truncate_pagecache_range">
void <code class="descname">truncate_pagecache_range</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap and remove pagecache that is hole-punched</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset of beginning of hole</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset of last byte of hole</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
</div>
</div>
<div class="section" id="kernel-ipc-facilities">
<h2>Kernel IPC facilities<a class="headerlink" href="#kernel-ipc-facilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ipc-utilities">
<h3>IPC utilities<a class="headerlink" href="#ipc-utilities" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.ipc_init">
int <code class="descname">ipc_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise ipc subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The various sysv ipc resources (semaphores, messages and shared
memory) are initialised.</p>
<p>A callback routine is registered into the memory hotplug notifier
chain: since msgmni scales to lowmem this callback routine will be
called upon successful memory add / remove to recompute msmgni.</p>
<dl class="function">
<dt id="c.ipc_init_ids">
int <code class="descname">ipc_init_ids</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise ipc identifiers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up the sequence range to use for the ipc identifier range (limited
below IPCMNI) then initialise the keys hashtable and ids idr.</p>
<dl class="function">
<dt id="c.ipc_init_proc_interface">
void <code class="descname">ipc_init_proc_interface</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, const char *<em>&nbsp;header</em>, int<em>&nbsp;ids</em>, int (*show) (struct seq_file<em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_proc_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>create a proc interface for sysipc types using a seq_file interface.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>Path in procfs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">header</span></code></dt>
<dd>Banner to be printed at the beginning of the file.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ids</span></code></dt>
<dd>ipc id table to iterate.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">seq_file</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">show</span></code></dt>
<dd>show routine.</dd>
</dl>
<dl class="function">
<dt id="c.ipc_findkey">
struct kern_ipc_perm * <code class="descname">ipc_findkey</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, key_t<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_findkey" title="Permalink to this definition">¶</a></dt>
<dd><p>find a key in an ipc identifier set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">key_t</span> <span class="pre">key</span></code></dt>
<dd>key to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the locked pointer to the ipc structure if found or NULL
otherwise. If key is found ipc points to the owning ipc structure</p>
<p>Called with writer ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipc_get_maxid">
int <code class="descname">ipc_get_maxid</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_get_maxid" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last assigned id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called with ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipc_addid">
int <code class="descname">ipc_addid</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;new</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_addid" title="Permalink to this definition">¶</a></dt>
<dd><p>add an ipc identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>limit for the number of used ids</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an entry ‘new’ to the ipc ids idr. The permissions object is
initialised and the first free entry is set up and the id assigned
is returned. The ‘new’ entry is returned in a locked state on success.
On failure the entry is not locked and a negative err-code is returned.</p>
<p>Called with writer ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipcget_new">
int <code class="descname">ipcget_new</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual creation routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is IPC_PRIVATE.</p>
<dl class="function">
<dt id="c.ipc_check_perms">
int <code class="descname">ipc_check_perms</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_check_perms" title="Permalink to this definition">¶</a></dt>
<dd><p>check security and permissions for an ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual security routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by <code class="xref c c-func docutils literal"><span class="pre">sys_msgget()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is not IPC_PRIVATE and that key already exists in the
ds IDR.</p>
<p>On success, the ipc id is returned.</p>
<p>It is called with ipc_ids.rwsem and ipcp-&gt;lock held.</p>
<dl class="function">
<dt id="c.ipcget_public">
int <code class="descname">ipcget_public</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_public" title="Permalink to this definition">¶</a></dt>
<dd><p>get an ipc object or create a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual creation routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is not IPC_PRIVATE.
It adds a new entry if the key is not found and does some permission
/ security checkings if the key is found.</p>
<p>On success, the ipc id is returned.</p>
<dl class="function">
<dt id="c.ipc_kht_remove">
void <code class="descname">ipc_kht_remove</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_kht_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an ipc from the key hashtable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc perm structure containing the key to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipc_rmid">
void <code class="descname">ipc_rmid</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an ipc identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc perm structure containing the identifier to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipc_set_key_private">
void <code class="descname">ipc_set_key_private</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_set_key_private" title="Permalink to this definition">¶</a></dt>
<dd><p>switch the key of an existing ipc to IPC_PRIVATE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc perm structure containing the key to modify</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipcperms">
int <code class="descname">ipcperms</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em>, short<em>&nbsp;flag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcperms" title="Permalink to this definition">¶</a></dt>
<dd><p>check ipc permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">short</span> <span class="pre">flag</span></code></dt>
<dd>desired permission set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check user, group, other permissions for access
to ipc resources. return 0 if allowed</p>
<p><strong>flag</strong> will most probably be 0 or <code class="docutils literal"><span class="pre">S_...UGO</span></code> from &lt;linux/stat.h&gt;</p>
<dl class="function">
<dt id="c.kernel_to_ipc64_perm">
void <code class="descname">kernel_to_ipc64_perm</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em>&nbsp;in</em>, struct ipc64_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_to_ipc64_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>convert kernel ipc permissions to user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>kernel permissions</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>new style ipc permissions</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the kernel object <strong>in</strong> into a set of permissions descriptions
for returning to userspace (<strong>out</strong>).</p>
<dl class="function">
<dt id="c.ipc64_perm_to_ipc_perm">
void <code class="descname">ipc64_perm_to_ipc_perm</code><span class="sig-paren">(</span>struct ipc64_perm *<em>&nbsp;in</em>, struct ipc_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc64_perm_to_ipc_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>convert new ipc permissions to old</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>new style ipc permissions</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>old style ipc permissions</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the new style permissions object <strong>in</strong> into a compatibility
object and store it into the <strong>out</strong> pointer.</p>
<dl class="function">
<dt id="c.ipc_obtain_object_idr">
struct kern_ipc_perm * <code class="descname">ipc_obtain_object_idr</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_idr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ipc id to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for an id in the ipc ids idr and return associated ipc object.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
<dl class="function">
<dt id="c.ipc_lock">
struct kern_ipc_perm * <code class="descname">ipc_lock</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>lock an ipc structure without rwsem held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ipc id to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for an id in the ipc ids idr and lock the associated ipc object.</p>
<p>The ipc object is locked on successful exit.</p>
<dl class="function">
<dt id="c.ipc_obtain_object_check">
struct kern_ipc_perm * <code class="descname">ipc_obtain_object_check</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_check" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ipc id to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.ipc_obtain_object_idr" title="ipc_obtain_object_idr"><code class="xref c c-func docutils literal"><span class="pre">ipc_obtain_object_idr()</span></code></a> but also checks
the ipc object reference counter.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
<dl class="function">
<dt id="c.ipcget">
int <code class="descname">ipcget</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget" title="Permalink to this definition">¶</a></dt>
<dd><p>Common sys_*:c:func:<cite>get()</cite> code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>operations to be called on ipc object creation, permission checks
and further checks</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>the parameters needed by the previous operations.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Common routine called by <code class="xref c c-func docutils literal"><span class="pre">sys_msgget()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>.</p>
<dl class="function">
<dt id="c.ipc_update_perm">
int <code class="descname">ipc_update_perm</code><span class="sig-paren">(</span>struct ipc64_perm *<em>&nbsp;in</em>, struct kern_ipc_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_update_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>update the permissions of an ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>the permission given as input.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>the permission of the ipc to set.</dd>
</dl>
<dl class="function">
<dt id="c.ipcctl_pre_down_nolock">
struct kern_ipc_perm * <code class="descname">ipcctl_pre_down_nolock</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em>, int<em>&nbsp;cmd</em>, struct ipc64_perm *<em>&nbsp;perm</em>, int<em>&nbsp;extra_perm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcctl_pre_down_nolock" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve an ipc and check permissions for some IPC_XXX cmd</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>the table of ids where to look for the ipc</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>the id of the ipc to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>the cmd to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">perm</span></code></dt>
<dd>the permission to set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">extra_perm</span></code></dt>
<dd>one extra permission parameter used by msq</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does some common audit and permissions check for some IPC_XXX
cmd and is called from semctl_down, shmctl_down and msgctl_down.
It must be called without any lock held and:</p>
<blockquote>
<div><ul class="simple">
<li>retrieves the ipc with the given id in the given table.</li>
<li>performs some audit and permission check, depending on the given cmd</li>
<li>returns a pointer to the ipc object or otherwise, the corresponding
error.</li>
</ul>
</div></blockquote>
<p>Call holding the both the rwsem and the rcu read lock.</p>
<dl class="function">
<dt id="c.ipc_parse_version">
int <code class="descname">ipc_parse_version</code><span class="sig-paren">(</span>int *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_parse_version" title="Permalink to this definition">¶</a></dt>
<dd><p>ipc call version</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>pointer to command</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return IPC_64 for new style IPC and IPC_OLD for old style IPC.
The <strong>cmd</strong> value is turned from an encoding command and version into
just the command code.</p>
</div>
</div>
<div class="section" id="fifo-buffer">
<h2>FIFO Buffer<a class="headerlink" href="#fifo-buffer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="kfifo-interface">
<h3>kfifo interface<a class="headerlink" href="#kfifo-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.DECLARE_KFIFO_PTR">
<code class="descname">DECLARE_KFIFO_PTR</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_KFIFO_PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to declare a fifo pointer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
</dl>
<dl class="function">
<dt id="c.DECLARE_KFIFO">
<code class="descname">DECLARE_KFIFO</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to declare a fifo object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
</dl>
<dl class="function">
<dt id="c.INIT_KFIFO">
<code class="descname">INIT_KFIFO</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.INIT_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a fifo declared by DECLARE_KFIFO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo datatype</dd>
</dl>
<dl class="function">
<dt id="c.DEFINE_KFIFO">
<code class="descname">DEFINE_KFIFO</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to define and initialize a fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo datatype</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
</dl>
<p><strong>Note</strong></p>
<p>the macro can be used for global and local fifo data type variables.</p>
<dl class="function">
<dt id="c.kfifo_initialized">
<code class="descname">kfifo_initialized</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the fifo is initialized</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return <code class="docutils literal"><span class="pre">true</span></code> if fifo is initialized, otherwise <code class="docutils literal"><span class="pre">false</span></code>.
Assumes the fifo was 0 before.</p>
<dl class="function">
<dt id="c.kfifo_esize">
<code class="descname">kfifo_esize</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_esize" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the element managed by the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_recsize">
<code class="descname">kfifo_recsize</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_recsize" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the record length field</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_size">
<code class="descname">kfifo_size</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_size" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the fifo in elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_reset">
<code class="descname">kfifo_reset</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>removes the entire fifo content</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Note</strong></p>
<p>usage of <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset()</span></code></a> is dangerous. It should be only called when the
fifo is exclusived locked or when it is secured that no other thread is
accessing the fifo.</p>
<dl class="function">
<dt id="c.kfifo_reset_out">
<code class="descname">kfifo_reset_out</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_reset_out" title="Permalink to this definition">¶</a></dt>
<dd><p>skip fifo content</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Note</strong></p>
<p>The usage of <a class="reference internal" href="#c.kfifo_reset_out" title="kfifo_reset_out"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset_out()</span></code></a> is safe until it will be only called
from the reader thread and there is only one concurrent reader. Otherwise
it is dangerous and must be handled in the same way as <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset()</span></code></a>.</p>
<dl class="function">
<dt id="c.kfifo_len">
<code class="descname">kfifo_len</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_len" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of used elements in the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_empty">
<code class="descname">kfifo_is_empty</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_full">
<code class="descname">kfifo_is_full</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is full</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_avail">
<code class="descname">kfifo_avail</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of unused elements in the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_skip">
<code class="descname">kfifo_skip</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_skip" title="Permalink to this definition">¶</a></dt>
<dd><p>skip output data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_peek_len">
<code class="descname">kfifo_peek_len</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_peek_len" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the size of the next fifo record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the size of the next fifo record in number of bytes.</p>
<dl class="function">
<dt id="c.kfifo_alloc">
<code class="descname">kfifo_alloc</code><span class="sig-paren">(</span><em>fifo</em>, <em>size</em>, <em>gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>dynamically allocates a new fifo buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>pointer to the fifo</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
<dt><code class="docutils literal"><span class="pre">gfp_mask</span></code></dt>
<dd>get_free_pages mask, passed to <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro dynamically allocates a new fifo buffer.</p>
<p>The numer of elements will be rounded-up to a power of 2.
The fifo will be release with <a class="reference internal" href="#c.kfifo_free" title="kfifo_free"><code class="xref c c-func docutils literal"><span class="pre">kfifo_free()</span></code></a>.
Return 0 if no error, otherwise an error code.</p>
<dl class="function">
<dt id="c.kfifo_free">
<code class="descname">kfifo_free</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_free" title="Permalink to this definition">¶</a></dt>
<dd><p>frees the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>the fifo to be freed</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_init">
<code class="descname">kfifo_init</code><span class="sig-paren">(</span><em>fifo</em>, <em>buffer</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a fifo using a preallocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>the fifo to assign the buffer</dd>
<dt><code class="docutils literal"><span class="pre">buffer</span></code></dt>
<dd>the preallocated buffer to be used</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the size of the internal buffer, this have to be a power of 2</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro initialize a fifo using a preallocated buffer.</p>
<p>The numer of elements will be rounded-up to a power of 2.
Return 0 if no error, otherwise an error code.</p>
<dl class="function">
<dt id="c.kfifo_put">
<code class="descname">kfifo_put</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>the data to be added</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given value into the fifo.
It returns 0 if the fifo was full. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_get">
<code class="descname">kfifo_get</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>address where to store the data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro reads the data from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_peek">
<code class="descname">kfifo_peek</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo without removing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>address where to store the data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reads the data from the fifo without removing it from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_in">
<code class="descname">kfifo_in</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>number of elements to be added</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given buffer into the fifo and returns the
number of copied elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_in_spinlocked">
<code class="descname">kfifo_in_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>number of elements to be added</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to the spinlock to use for locking</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given values buffer into the fifo and returns the
number of copied elements.</p>
<dl class="function">
<dt id="c.kfifo_out">
<code class="descname">kfifo_out</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get some data from the fifo and return the numbers of elements
copied.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_out_spinlocked">
<code class="descname">kfifo_out_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to the spinlock to use for locking</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied.</p>
<dl class="function">
<dt id="c.kfifo_from_user">
<code class="descname">kfifo_from_user</code><span class="sig-paren">(</span><em>fifo</em>, <em>from</em>, <em>len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_from_user" title="Permalink to this definition">¶</a></dt>
<dd><p>puts some data from user space into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">from</span></code></dt>
<dd>pointer to the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>the length of the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">copied</span></code></dt>
<dd>pointer to output variable to store the number of copied bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the <strong>from</strong> into the
fifo, depending of the available space and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_to_user">
<code class="descname">kfifo_to_user</code><span class="sig-paren">(</span><em>fifo</em>, <em>to</em>, <em>len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_to_user" title="Permalink to this definition">¶</a></dt>
<dd><p>copies data from the fifo into user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">to</span></code></dt>
<dd>where the data must be copied</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>the size of the destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">copied</span></code></dt>
<dd>pointer to output variable to store the number of copied bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the fifo into the
<strong>to</strong> buffer and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_dma_in_prepare">
<code class="descname">kfifo_dma_in_prepare</code><span class="sig-paren">(</span><em>fifo</em>, <em>sgl</em>, <em>nents</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_in_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a scatterlist for DMA input</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">sgl</span></code></dt>
<dd>pointer to the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">nents</span></code></dt>
<dd>number of entries in the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of elements to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA input.
It returns the number entries in the scatterlist array.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_in_finish">
<code class="descname">kfifo_dma_in_finish</code><span class="sig-paren">(</span><em>fifo</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_in_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a DMA IN operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of bytes to received</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA IN operation. The in counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_out_prepare">
<code class="descname">kfifo_dma_out_prepare</code><span class="sig-paren">(</span><em>fifo</em>, <em>sgl</em>, <em>nents</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_out_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a scatterlist for DMA output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">sgl</span></code></dt>
<dd>pointer to the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">nents</span></code></dt>
<dd>number of entries in the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of elements to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA output which at most <strong>len</strong> bytes
to transfer.
It returns the number entries in the scatterlist array.
A zero means there is no space available and the scatterlist is not filled.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_out_finish">
<code class="descname">kfifo_dma_out_finish</code><span class="sig-paren">(</span><em>fifo</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_out_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a DMA OUT operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of bytes transferred</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA OUT operation. The out counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_out_peek">
<code class="descname">kfifo_out_peek</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>gets some data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied. The data is not removed from the fifo.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don’t need extra locking to use these macro.</p>
</div>
</div>
<div class="section" id="relay-interface-support">
<h2>relay interface support<a class="headerlink" href="#relay-interface-support" title="Permalink to this headline">¶</a></h2>
<p>Relay interface support is designed to provide an efficient mechanism
for tools and facilities to relay large amounts of data from kernel
space to user space.</p>
<div class="section" id="relay-interface">
<h3>relay interface<a class="headerlink" href="#relay-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.relay_buf_full">
int <code class="descname">relay_buf_full</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_full" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean, is the channel buffer full?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns 1 if the buffer is full, 0 otherwise.</div></blockquote>
<dl class="function">
<dt id="c.relay_reset">
void <code class="descname">relay_reset</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This has the effect of erasing all data from all channel buffers
and restarting the channel in its initial state.  The buffers
are not freed, so any mappings are still in effect.</p>
<p>NOTE. Care should be taken that the channel isn’t actually
being used by anything when this call is made.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_open">
struct rchan * <code class="descname">relay_open</code><span class="sig-paren">(</span>const char *<em>&nbsp;base_filename</em>, struct dentry *<em>&nbsp;parent</em>, size_t<em>&nbsp;subbuf_size</em>, size_t<em>&nbsp;n_subbufs</em>, struct rchan_callbacks *<em>&nbsp;cb</em>, void *<em>&nbsp;private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_open" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new relay channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">base_filename</span></code></dt>
<dd>base name of files to create, <code class="docutils literal"><span class="pre">NULL</span></code> for buffering only</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>dentry of parent directory, <code class="docutils literal"><span class="pre">NULL</span></code> for root directory or buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">subbuf_size</span></code></dt>
<dd>size of sub-buffers</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n_subbufs</span></code></dt>
<dd>number of sub-buffers</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_callbacks</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt>
<dd>client callback functions</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt>
<dd>user-defined data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns channel pointer if successful, <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</p>
<p>Creates a channel buffer for each cpu using the sizes and
attributes specified.  The created channel buffer files
will be named base_filename0…base_filenameN-1.  File
permissions will be <code class="docutils literal"><span class="pre">S_IRUSR</span></code>.</p>
<p>If opening a buffer (<strong>parent</strong> = NULL) that you later wish to register
in a filesystem, call <a class="reference internal" href="#c.relay_late_setup_files" title="relay_late_setup_files"><code class="xref c c-func docutils literal"><span class="pre">relay_late_setup_files()</span></code></a> once the <strong>parent</strong> dentry
is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_late_setup_files">
int <code class="descname">relay_late_setup_files</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em>, const char *<em>&nbsp;base_filename</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_late_setup_files" title="Permalink to this definition">¶</a></dt>
<dd><p>triggers file creation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>channel to operate on</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">base_filename</span></code></dt>
<dd>base name of files to create</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>dentry of parent directory, <code class="docutils literal"><span class="pre">NULL</span></code> for root directory</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if successful, non-zero otherwise.</p>
<p>Use to setup files for a previously buffer-only channel created
by <a class="reference internal" href="#c.relay_open" title="relay_open"><code class="xref c c-func docutils literal"><span class="pre">relay_open()</span></code></a> with a NULL parent dentry.</p>
<p>For example, this is useful for perfomring early tracing in kernel,
before VFS is up and then exposing the early results once the dentry
is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_switch_subbuf">
size_t <code class="descname">relay_switch_subbuf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_switch_subbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>switch to a new sub-buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">length</span></code></dt>
<dd>size of current event</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns either the length passed in or 0 if full.</p>
<p>Performs sub-buffer-switch tasks such as invoking callbacks,
updating padding counts, waking up readers, etc.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_subbufs_consumed">
void <code class="descname">relay_subbufs_consumed</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em>, unsigned int<em>&nbsp;cpu</em>, size_t<em>&nbsp;subbufs_consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_subbufs_consumed" title="Permalink to this definition">¶</a></dt>
<dd><p>update the buffer’s sub-buffers-consumed count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the cpu associated with the channel buffer to update</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">subbufs_consumed</span></code></dt>
<dd>number of sub-buffers to add to current buf’s count</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Adds to the channel buffer’s consumed sub-buffer count.
subbufs_consumed should be the number of sub-buffers newly consumed,
not the total consumed.</p>
<p>NOTE. Kernel clients don’t need to call this function if the channel
mode is ‘overwrite’.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_close">
void <code class="descname">relay_close</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Closes all channel buffers and frees the channel.</div></blockquote>
<dl class="function">
<dt id="c.relay_flush">
void <code class="descname">relay_flush</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Flushes all channel buffers, i.e. forces buffer switch.</div></blockquote>
<dl class="function">
<dt id="c.relay_mmap_buf">
int <code class="descname">relay_mmap_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_mmap_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap channel buffer to process address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vm_area_struct describing memory to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if ok, negative on error</p>
<p>Caller should already have grabbed mmap_sem.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_alloc_buf">
void * <code class="descname">relay_alloc_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t *<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_alloc_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer struct</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt>
<dd>total size of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a pointer to the resulting buffer, <code class="docutils literal"><span class="pre">NULL</span></code> if unsuccessful. The
passed in size will get page aligned, if it isn’t already.</div></blockquote>
<dl class="function">
<dt id="c.relay_create_buf">
struct rchan_buf * <code class="descname">relay_create_buf</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_create_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and initialize a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the relay channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns channel buffer if successful, <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</div></blockquote>
<dl class="function">
<dt id="c.relay_destroy_channel">
void <code class="descname">relay_destroy_channel</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>free the channel struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>target kernel reference that contains the relay channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Should only be called from <code class="xref c c-func docutils literal"><span class="pre">kref_put()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.relay_destroy_buf">
void <code class="descname">relay_destroy_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy an rchan_buf struct and associated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer struct</dd>
</dl>
<dl class="function">
<dt id="c.relay_remove_buf">
void <code class="descname">relay_remove_buf</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_remove_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>target kernel reference that contains the relay buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Removes the file from the filesystem, which also frees the
rchan_buf_struct and the channel buffer.  Should only be called from
<code class="xref c c-func docutils literal"><span class="pre">kref_put()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.relay_buf_empty">
int <code class="descname">relay_buf_empty</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean, is the channel buffer empty?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns 1 if the buffer is empty, 0 otherwise.</div></blockquote>
<dl class="function">
<dt id="c.wakeup_readers">
void <code class="descname">wakeup_readers</code><span class="sig-paren">(</span>struct irq_work *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeup_readers" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up readers waiting on a channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>contains the channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is the function used to defer reader waking</div></blockquote>
<dl class="function">
<dt id="c.__relay_reset">
void <code class="descname">__relay_reset</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;init</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__relay_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">init</span></code></dt>
<dd>1 if this is a first-time initialization</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>See <a class="reference internal" href="#c.relay_reset" title="relay_reset"><code class="xref c c-func docutils literal"><span class="pre">relay_reset()</span></code></a> for description of effect.</div></blockquote>
<dl class="function">
<dt id="c.relay_close_buf">
void <code class="descname">relay_close_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>close a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Marks the buffer finalized and restores the default callbacks.
The channel buffer and channel buffer data structure are then freed
automatically when the last reference is given up.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_open">
int <code class="descname">relay_file_open</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_open" title="Permalink to this definition">¶</a></dt>
<dd><p>open file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Increments the channel buffer refcount.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_mmap">
int <code class="descname">relay_file_mmap</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>the vma describing what to map</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Calls upon <a class="reference internal" href="#c.relay_mmap_buf" title="relay_mmap_buf"><code class="xref c c-func docutils literal"><span class="pre">relay_mmap_buf()</span></code></a> to map the file into user space.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_poll">
unsigned int <code class="descname">relay_file_poll</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>poll file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>poll table</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Poll implemention.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_release">
int <code class="descname">relay_file_release</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Decrements the channel refcount, as the filesystem is
no longer using it.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_read_subbuf_avail">
size_t <code class="descname">relay_file_read_subbuf_avail</code><span class="sig-paren">(</span>size_t<em>&nbsp;read_pos</em>, struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_subbuf_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>return bytes available in sub-buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
</dl>
<dl class="function">
<dt id="c.relay_file_read_start_pos">
size_t <code class="descname">relay_file_read_start_pos</code><span class="sig-paren">(</span>size_t<em>&nbsp;read_pos</em>, struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_start_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find the first available byte to read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If the <strong>read_pos</strong> is in the middle of padding, return the
position of the first actually available byte, otherwise
return the original value.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_read_end_pos">
size_t <code class="descname">relay_file_read_end_pos</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t<em>&nbsp;read_pos</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_end_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>return the new read position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to be read</dd>
</dl>
</div>
</div>
<div class="section" id="module-support">
<h2>Module Support<a class="headerlink" href="#module-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-loading">
<h3>Module Loading<a class="headerlink" href="#module-loading" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__request_module">
int <code class="descname">__request_module</code><span class="sig-paren">(</span>bool<em>&nbsp;wait</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.__request_module" title="Permalink to this definition">¶</a></dt>
<dd><p>try to load a kernel module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">wait</span></code></dt>
<dd>wait (or not) for the operation to complete</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>printf style format string for the name of the module</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>arguments as specified in the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>Load a module using the user mode module loader. The function returns
zero on success or a negative errno code or positive exit code from
“modprobe” on failure. Note that a successful module load does not mean
the module did not then unload and exit on an error of its own. Callers
must check that the service they requested is now available not blindly
invoke it.</p>
<p>If module auto-loading support is disabled then this function
becomes a no-operation.</p>
</div>
<div class="section" id="inter-module-support">
<h3>Inter Module support<a class="headerlink" href="#inter-module-support" title="Permalink to this headline">¶</a></h3>
<p>Refer to the file kernel/module.c for more information.</p>
</div>
</div>
<div class="section" id="hardware-interfaces">
<h2>Hardware Interfaces<a class="headerlink" href="#hardware-interfaces" title="Permalink to this headline">¶</a></h2>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.synchronize_hardirq">
bool <code class="descname">synchronize_hardirq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending hard IRQ handlers (on other CPUs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this
function while holding a resource the IRQ handler may need you
will deadlock. It does not take associated threaded handlers
into account.</p>
<p>Do not use this for shutdown scenarios where you must be sure
that all parts (hardirq and threaded handler) have completed.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div>This function may be called - with care - from IRQ context.</div></blockquote>
<dl class="function">
<dt id="c.synchronize_irq">
void <code class="descname">synchronize_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending IRQ handlers (on other CPUs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_affinity_notifier">
int <code class="descname">irq_set_affinity_notifier</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irq_affinity_notify" title="irq_affinity_notify">irq_affinity_notify</a> *<em>&nbsp;notify</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_affinity_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>control notification of IRQ affinity changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt for which to enable/disable notification</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_affinity_notify</span> <span class="pre">*</span> <span class="pre">notify</span></code></dt>
<dd>Context for notification, or <code class="docutils literal"><span class="pre">NULL</span></code> to disable
notification.  Function pointers must be initialised;
the other fields will be initialised by this function.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Must be called in process context.  Notification may only be enabled
after the IRQ is allocated and must be disabled before the IRQ is
freed using <a class="reference internal" href="#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal"><span class="pre">free_irq()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.irq_set_vcpu_affinity">
int <code class="descname">irq_set_vcpu_affinity</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;vcpu_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_vcpu_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set vcpu affinity for the interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to set affinity</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vcpu_info</span></code></dt>
<dd>vCPU specific data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function uses the vCPU specific data to set the vCPU
affinity for an irq. The vCPU specific data is passed from
outside, such as KVM. One example code path is as below:
KVM -&gt; IOMMU -&gt; <a class="reference internal" href="#c.irq_set_vcpu_affinity" title="irq_set_vcpu_affinity"><code class="xref c c-func docutils literal"><span class="pre">irq_set_vcpu_affinity()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.disable_irq_nosync">
void <code class="descname">disable_irq_nosync</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq_nosync" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq without waiting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Disables and Enables are
nested.
Unlike <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code></a>, this function does not ensure existing
instances of the IRQ handler have completed before returning.</p>
<p>This function may be called from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_irq">
void <code class="descname">disable_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq and wait for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_hardirq">
bool <code class="descname">disable_hardirq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>disables an irq and waits for hardirq completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this function while
holding a resource the hard IRQ handler may need you will deadlock.</p>
<p>When used to optimistically disable an interrupt from atomic context
the return value must be checked.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div>This function may be called - with care - from IRQ context.</div></blockquote>
<dl class="function">
<dt id="c.enable_irq">
void <code class="descname">enable_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>enable handling of an irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to enable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Undoes the effect of one call to <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code></a>.  If this
matches the last disable, processing of interrupts on this
IRQ line is re-enabled.</p>
<p>This function may be called from IRQ context only when
desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_irq_wake">
int <code class="descname">irq_set_irq_wake</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, unsigned int<em>&nbsp;on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irq_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>control irq power management wakeup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt to control</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">on</span></code></dt>
<dd>enable/disable power management wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enable/disable power management wakeup mode, which is
disabled by default.  Enables and disables must match,
just as they match for non-wakeup mode support.</p>
<p>Wakeup mode lets this IRQ wake the system from sleep
states like “suspend to RAM”.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_wake_thread">
void <code class="descname">irq_wake_thread</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_wake_thread" title="Permalink to this definition">¶</a></dt>
<dd><p>wake the irq thread for the action identified by dev_id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity for which the thread should be woken</dd>
</dl>
<dl class="function">
<dt id="c.setup_irq">
int <code class="descname">setup_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irqaction" title="irqaction">irqaction</a> *<em>&nbsp;act</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setup_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>setup an interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to setup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irqaction</span> <span class="pre">*</span> <span class="pre">act</span></code></dt>
<dd>irqaction for the interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to statically setup interrupts in the early boot process.</p>
<dl class="function">
<dt id="c.remove_irq">
void <code class="descname">remove_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irqaction" title="irqaction">irqaction</a> *<em>&nbsp;act</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irqaction</span> <span class="pre">*</span> <span class="pre">act</span></code></dt>
<dd>irqaction for the interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to remove interrupts statically setup by the early boot process.</p>
<dl class="function">
<dt id="c.free_irq">
const void * <code class="descname">free_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function. The function
does not return until any executing interrupts for this IRQ
have completed.</p>
<p>This function must not be called from interrupt context.</p>
<p>Returns the devname argument passed to request_irq.</p>
</div></blockquote>
<dl class="function">
<dt id="c.request_threaded_irq">
int <code class="descname">request_threaded_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, irq_handler_t<em>&nbsp;thread_fn</em>, unsigned long<em>&nbsp;irqflags</em>, const char *<em>&nbsp;devname</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_threaded_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts
If NULL and thread_fn != NULL the default
primary handler is installed</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">thread_fn</span></code></dt>
<dd>Function called from the irq handler thread
If NULL, no irq thread is created</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">irqflags</span></code></dt>
<dd>Interrupt type flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">devname</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.</p>
<p>If you want to set up a threaded irq handler for your device
then you need to supply <strong>handler</strong> and <strong>thread_fn</strong>. <strong>handler</strong> is
still called in hard interrupt context and has to check
whether the interrupt originates from the device. If yes it
needs to disable the interrupt on the device and return
IRQ_WAKE_THREAD which will wake up the handler thread and run
<strong>thread_fn</strong>. This split handler design is necessary to support
shared interrupts.</p>
<p>Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.</p>
<p>If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.</p>
<p>Flags:</p>
<p>IRQF_SHARED             Interrupt is shared
IRQF_TRIGGER_*          Specify active edge(s) or level</p>
</div></blockquote>
<dl class="function">
<dt id="c.request_any_context_irq">
int <code class="descname">request_any_context_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, unsigned long<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_any_context_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.
Threaded handler for threaded interrupts.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>Interrupt type flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. It selects either a
hardirq or threaded handling method depending on the
context.</p>
<p>On failure, it returns a negative value. On success,
it returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_percpu_is_enabled">
bool <code class="descname">irq_percpu_is_enabled</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_percpu_is_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the per cpu irq is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Linux irq number to check for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called from a non migratable context. Returns the enable
state of a per cpu interrupt on the current cpu.</p>
<dl class="function">
<dt id="c.free_percpu_irq">
void <code class="descname">free_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void __percpu *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_percpu_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a percpu interrupt handler. The handler is removed, but
the interrupt line is not disabled. This must be done on each
CPU before calling this function. The function does not return
until any executing interrupts for this IRQ have completed.</p>
<p>This function must not be called from interrupt context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__request_percpu_irq">
int <code class="descname">__request_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, unsigned long<em>&nbsp;flags</em>, const char *<em>&nbsp;devname</em>, void __percpu *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a percpu interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>Interrupt type flags (IRQF_TIMER only)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">devname</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A percpu cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt on the local CPU. If the interrupt is supposed to be
enabled on other CPUs, it has to be done on each CPU using
<code class="xref c c-func docutils literal"><span class="pre">enable_percpu_irq()</span></code>.</p>
<p>Dev_id must be globally unique. It is a per-cpu variable, and
the handler gets called with the interrupted CPU’s instance of
that variable.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_get_irqchip_state">
int <code class="descname">irq_get_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, enum irqchip_irq_state<em>&nbsp;which</em>, bool *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the irqchip state of a interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line that is forwarded to a VM</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt>
<dd>One of IRQCHIP_STATE_* the caller wants to know about</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>a pointer to a boolean where the state is to be storeed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call snapshots the internal irqchip state of an
interrupt, returning into <strong>state</strong> the bit corresponding to
stage <strong>which</strong></p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_irqchip_state">
int <code class="descname">irq_set_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, enum irqchip_irq_state<em>&nbsp;which</em>, bool<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set the state of a forwarded interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line that is forwarded to a VM</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt>
<dd>State to be restored (one of IRQCHIP_STATE_*)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">val</span></code></dt>
<dd>Value corresponding to <strong>which</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call sets the internal irqchip state of an interrupt,
depending on the value of <strong>which</strong>.</p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</div></blockquote>
</div>
<div class="section" id="dma-channels">
<h3>DMA Channels<a class="headerlink" href="#dma-channels" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_dma">
int <code class="descname">request_dma</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;dmanr</em>, const char *<em>&nbsp;device_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve a system DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt>
<dd>DMA channel number</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">device_id</span></code></dt>
<dd>reserving device ID string, used in /proc/dma</dd>
</dl>
<dl class="function">
<dt id="c.free_dma">
void <code class="descname">free_dma</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;dmanr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>free a reserved system DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt>
<dd>DMA channel number</dd>
</dl>
</div>
<div class="section" id="resources-management">
<h3>Resources Management<a class="headerlink" href="#resources-management" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_resource_conflict">
struct resource * <code class="descname">request_resource_conflict</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, conflict resource on error.</p>
<dl class="function">
<dt id="c.reallocate_resource">
int <code class="descname">reallocate_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;old</em>, resource_size_t<em>&nbsp;newsize</em>, struct resource_constraint *<em>&nbsp;constraint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reallocate_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a slot in the resource tree given range &amp; alignment. The resource will be relocated if the new size cannot be reallocated in the current location.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource descriptor desired by caller</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">newsize</span></code></dt>
<dd>new size of the resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource_constraint</span> <span class="pre">*</span> <span class="pre">constraint</span></code></dt>
<dd>the size and alignment constraints to be met.</dd>
</dl>
<dl class="function">
<dt id="c.lookup_resource">
struct resource * <code class="descname">lookup_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, resource_size_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>find an existing resource by a resource start address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the resource if found, NULL otherwise</p>
<dl class="function">
<dt id="c.insert_resource_conflict">
struct resource * <code class="descname">insert_resource_conflict</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of the new resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, conflict resource if the resource can’t be inserted.</p>
<p>This function is equivalent to request_resource_conflict when no conflict
happens. If a conflict happens, and the conflicting resources
entirely fit within the range of the new resource, then the new
resource is inserted and the conflicting resources become children of
the new resource.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
<dl class="function">
<dt id="c.insert_resource_expand_to_fit">
void <code class="descname">insert_resource_expand_to_fit</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_expand_to_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a resource into the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a resource into the resource tree, possibly expanding it in order
to make it encompass any conflicting resources.</p>
<dl class="function">
<dt id="c.resource_alignment">
resource_size_t <code class="descname">resource_alignment</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.resource_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate resource’s alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>resource pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns alignment on success, 0 (invalid alignment) on failure.</p>
<dl class="function">
<dt id="c.release_mem_region_adjustable">
int <code class="descname">release_mem_region_adjustable</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_mem_region_adjustable" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>resource region size</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface is intended for memory hot-delete.  The requested region
is released from a currently busy memory resource.  The requested region
must either match exactly or fit into a single busy resource entry.  In
the latter case, the remaining resource is adjusted accordingly.
Existing children of the busy memory resource must be immutable in the
request.</p>
<p><strong>Note</strong></p>
<ul class="simple">
<li>Additional release conditions, such as overlapping region, can be
supported after they are confirmed as valid cases.</li>
<li>When a busy memory resource gets split into two entries, the code
assumes that all children remain in the lower address entry for
simplicity.  Enhance this logic when necessary.</li>
</ul>
<dl class="function">
<dt id="c.request_resource">
int <code class="descname">request_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, negative error code on error.</p>
<dl class="function">
<dt id="c.release_resource">
int <code class="descname">release_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource pointer</dd>
</dl>
<dl class="function">
<dt id="c.region_intersects">
int <code class="descname">region_intersects</code><span class="sig-paren">(</span>resource_size_t<em>&nbsp;start</em>, size_t<em>&nbsp;size</em>, unsigned long<em>&nbsp;flags</em>, unsigned long<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.region_intersects" title="Permalink to this definition">¶</a></dt>
<dd><p>determine intersection of region with known resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>region start address</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of region</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>flags of resource (in iomem_resource)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt>
<dd>descriptor of resource (in iomem_resource) or IORES_DESC_NONE</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the specified region partially overlaps or fully eclipses a
resource identified by <strong>flags</strong> and <strong>desc</strong> (optional with IORES_DESC_NONE).
Return REGION_DISJOINT if the region does not overlap <strong>flags</strong>/<strong>desc</strong>,
return REGION_MIXED if the region overlaps <strong>flags</strong>/<strong>desc</strong> and another
resource, and return REGION_INTERSECTS if the region overlaps <strong>flags</strong>/<strong>desc</strong>
and no other defined resource. Note that REGION_INTERSECTS is also
returned in the case when the specified region overlaps RAM and undefined
memory holes.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">region_intersect()</span></code> is used by memory remapping functions to ensure
the user is not remapping RAM and is a vast speed up over walking
through the resource table page by page.</p>
<dl class="function">
<dt id="c.allocate_resource">
int <code class="descname">allocate_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em>, resource_size_t<em>&nbsp;size</em>, resource_size_t<em>&nbsp;min</em>, resource_size_t<em>&nbsp;max</em>, resource_size_t<em>&nbsp;align</em>, resource_size_t (*alignf) (void<em>&nbsp;*</em>, const struct resource<em>&nbsp;*</em>, resource_size_t, resource_size_t, void *<em>&nbsp;alignf_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.allocate_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate empty slot in the resource tree given range &amp; alignment. The resource will be reallocated with a new size if it was already allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>requested resource region size</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">min</span></code></dt>
<dd>minimum boundary to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">max</span></code></dt>
<dd>maximum boundary to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requested, in bytes</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">resource_size_t,</span> <span class="pre">resource_size_t)</span> <span class="pre">alignf</span></code></dt>
<dd>alignment function, optional, called if not NULL</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">alignf_data</span></code></dt>
<dd>arbitrary data to pass to the <strong>alignf</strong> function</dd>
</dl>
<dl class="function">
<dt id="c.insert_resource">
int <code class="descname">insert_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts a resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of the new resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EBUSY if the resource can’t be inserted.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
<dl class="function">
<dt id="c.remove_resource">
int <code class="descname">remove_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EINVAL if the resource is not valid.</p>
<p>This function removes a resource previously inserted by <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a>
or <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a>, and moves the children (if any) up to
where they were before.  <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a> and <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a>
insert a new resource, and move any conflicting resources down to the
children of the new resource.</p>
<p><a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a>, <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a> and <a class="reference internal" href="#c.remove_resource" title="remove_resource"><code class="xref c c-func docutils literal"><span class="pre">remove_resource()</span></code></a> are
intended for producers of resources, such as FW modules and bus drivers.</p>
<dl class="function">
<dt id="c.adjust_resource">
int <code class="descname">adjust_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;res</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.adjust_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>modify a resource’s start and size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>resource to modify</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>new start value</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>new size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given an existing resource, change its start and size to match the
arguments.  Returns 0 on success, -EBUSY if it can’t fit.
Existing children of the resource are assumed to be immutable.</p>
<dl class="function">
<dt id="c.__request_region">
struct resource * <code class="descname">__request_region</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;n</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_region" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new busy resource region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt>
<dd>resource region size</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>reserving caller’s ID string</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>IO resource flags</dd>
</dl>
<dl class="function">
<dt id="c.__release_region">
void <code class="descname">__release_region</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved resource region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt>
<dd>resource region size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The described resource region must match a currently busy region.</p>
<dl class="function">
<dt id="c.devm_request_resource">
int <code class="descname">devm_request_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_request_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for which to request the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root of the resource tree from which to request the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>descriptor of the resource to request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a device-managed version of <a class="reference internal" href="#c.request_resource" title="request_resource"><code class="xref c c-func docutils literal"><span class="pre">request_resource()</span></code></a>. There is usually
no need to release resources requested by this function explicitly since
that will be taken care of when the device is unbound from its driver.
If for some reason the resource needs to be released explicitly, because
of ordering issues for example, drivers must call <a class="reference internal" href="#c.devm_release_resource" title="devm_release_resource"><code class="xref c c-func docutils literal"><span class="pre">devm_release_resource()</span></code></a>
rather than the regular <a class="reference internal" href="#c.release_resource" title="release_resource"><code class="xref c c-func docutils literal"><span class="pre">release_resource()</span></code></a>.</p>
<p>When a conflict is detected between any existing resources and the newly
requested resource, an error message will be printed.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.devm_release_resource">
void <code class="descname">devm_release_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_release_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously requested resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for which to release the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>descriptor of the resource to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a resource previously requested using <a class="reference internal" href="#c.devm_request_resource" title="devm_request_resource"><code class="xref c c-func docutils literal"><span class="pre">devm_request_resource()</span></code></a>.</p>
</div>
<div class="section" id="mtrr-handling">
<h3>MTRR Handling<a class="headerlink" href="#mtrr-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.arch_phys_wc_add">
int <code class="descname">arch_phys_wc_add</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;base</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_phys_wc_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a WC MTRR and handle errors if PAT is unavailable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt>
<dd>Physical base address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>Size of region</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PAT is available, this does nothing.  If PAT is unavailable, it
attempts to add a WC MTRR covering size bytes starting at base and
logs an error if this fails.</p>
<p>The called should provide a power of two size on an equivalent
power of two boundary.</p>
<p>Drivers must store the return value to pass to mtrr_del_wc_if_needed,
but drivers should not try to interpret that return value.</p>
</div>
</div>
<div class="section" id="security-framework">
<h2>Security Framework<a class="headerlink" href="#security-framework" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.security_init">
int <code class="descname">security_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.security_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes the security framework</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called early in the kernel initialization sequence.</p>
<dl class="function">
<dt id="c.security_module_enable">
int <code class="descname">security_module_enable</code><span class="sig-paren">(</span>const char *<em>&nbsp;module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.security_module_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Load given security module on boot ?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>the name of the module</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each LSM must pass this method before registering its own operations
to avoid security registration races. This method may also be used
to check if your LSM is currently loaded during kernel initialization.</p>
<p><strong>Return</strong></p>
<p>true if:</p>
<ul class="simple">
<li>The passed LSM is the one chosen by user at boot time,</li>
<li>or the passed LSM is configured as the default and the user did not
choose an alternate LSM at boot time.</li>
</ul>
<p>Otherwise, return false.</p>
<dl class="function">
<dt id="c.security_add_hooks">
void <code class="descname">security_add_hooks</code><span class="sig-paren">(</span>struct security_hook_list *<em>&nbsp;hooks</em>, int<em>&nbsp;count</em>, char *<em>&nbsp;lsm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.security_add_hooks" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a modules hooks to the hook lists.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">security_hook_list</span> <span class="pre">*</span> <span class="pre">hooks</span></code></dt>
<dd>the hooks to add</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of hooks to add</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">lsm</span></code></dt>
<dd>the name of the security module</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each LSM has to register its hooks with the infrastructure.</p>
<dl class="function">
<dt id="c.securityfs_create_file">
struct dentry * <code class="descname">securityfs_create_file</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the securityfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> call.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_create_dir">
struct dentry * <code class="descname">securityfs_create_dir</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>create a directory in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the directory to
create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a directory in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_create_symlink">
struct dentry * <code class="descname">securityfs_create_symlink</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, const char *<em>&nbsp;target</em>, const struct inode_operations *<em>&nbsp;iops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>create a symlink in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the symlink to
create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for the symlink.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>a pointer to a string containing the name of the symlink’s target.
If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the <strong>iops</strong> parameter needs to be
setup to handle .readlink and .get_link inode_operations.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode_operations</span> <span class="pre">*</span> <span class="pre">iops</span></code></dt>
<dd>a pointer to the struct inode_operations to use for the symlink. If
this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the default simple_symlink_inode
operations will be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a symlink in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_remove">
void <code class="descname">securityfs_remove</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a file or directory from the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>a pointer to a the dentry of the file or directory to be removed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a file or directory in securityfs that was previously
created with a call to another securityfs function (like
<a class="reference internal" href="#c.securityfs_create_file" title="securityfs_create_file"><code class="xref c c-func docutils literal"><span class="pre">securityfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed. No automatic cleanup of files will happen when a module is
removed; you are responsible here.</p>
</div>
<div class="section" id="audit-interfaces">
<h2>Audit Interfaces<a class="headerlink" href="#audit-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.audit_log_start">
struct audit_buffer * <code class="descname">audit_log_start</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_start" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an audit buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit_context (may be NULL)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>type of allocation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns audit_buffer pointer on success or NULL on error.</p>
<p>Obtain an audit buffer.  This routine does locking to obtain the
audit buffer, but then no locking is required for calls to
audit_log_*format.  If the task (ctx) is a task that is currently in a
syscall, then the syscall is marked as auditable and an audit record
will be written at syscall exit.  If there is no associated task, then
task context (ctx) should be NULL.</p>
<dl class="function">
<dt id="c.audit_log_format">
void <code class="descname">audit_log_format</code><span class="sig-paren">(</span>struct audit_buffer *<em>&nbsp;ab</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_format" title="Permalink to this definition">¶</a></dt>
<dd><p>format a message into the audit buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt>
<dd>audit_buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>optional parameters matching <strong>fmt</strong> string</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the work is done in audit_log_vformat.</p>
<dl class="function">
<dt id="c.audit_log_end">
void <code class="descname">audit_log_end</code><span class="sig-paren">(</span>struct audit_buffer *<em>&nbsp;ab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_end" title="Permalink to this definition">¶</a></dt>
<dd><p>end one audit record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt>
<dd>the audit_buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>We can not do a netlink send inside an irq context because it blocks (last
arg, flags, is not set to MSG_DONTWAIT), so the audit buffer is placed on a
queue and a tasklet is scheduled to remove them from the queue outside the
irq context.  May be called in any context.</p>
<dl class="function">
<dt id="c.audit_log">
void <code class="descname">audit_log</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;type</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Log an audit record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit context</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>type of allocation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable parameters matching the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a convenience function that calls audit_log_start,
audit_log_vformat, and audit_log_end.  It may be called
in any context.</p>
<dl class="function">
<dt id="c.audit_log_secctx">
void <code class="descname">audit_log_secctx</code><span class="sig-paren">(</span>struct audit_buffer *<em>&nbsp;ab</em>, u32<em>&nbsp;secid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_secctx" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts and logs SELinux context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt>
<dd>audit_buffer</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">secid</span></code></dt>
<dd>security number</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper function that calls security_secid_to_secctx to convert
secid to secctx and then adds the (converted) SELinux context to the audit
log by calling audit_log_format, thus also preventing leak of internal secid
to userspace. If secid cannot be converted audit_panic is called.</p>
<dl class="function">
<dt id="c.audit_alloc">
int <code class="descname">audit_alloc</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an audit context block for a task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt>
<dd>task</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filter on the task information and allocate a per-task audit context
if necessary.  Doing so turns on system call auditing for the
specified task.  This is called from copy_process, so no lock is
needed.</p>
<dl class="function">
<dt id="c.__audit_free">
void <code class="descname">__audit_free</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a per-task audit context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt>
<dd>task whose audit context block to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from copy_process and do_exit</p>
<dl class="function">
<dt id="c.__audit_syscall_entry">
void <code class="descname">__audit_syscall_entry</code><span class="sig-paren">(</span>int<em>&nbsp;major</em>, unsigned long<em>&nbsp;a1</em>, unsigned long<em>&nbsp;a2</em>, unsigned long<em>&nbsp;a3</em>, unsigned long<em>&nbsp;a4</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in an audit record at syscall entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major syscall type (function)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a1</span></code></dt>
<dd>additional syscall register 1</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a2</span></code></dt>
<dd>additional syscall register 2</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a3</span></code></dt>
<dd>additional syscall register 3</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a4</span></code></dt>
<dd>additional syscall register 4</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in audit context at syscall entry.  This only happens if the
audit context was created when the task was created and the state or
filters demand the audit context be built.  If the state from the
per-task filter or from the per-syscall filter is AUDIT_RECORD_CONTEXT,
then the record will be written at syscall exit time (otherwise, it
will only be written if another part of the kernel requests that it
be written).</p>
<dl class="function">
<dt id="c.__audit_syscall_exit">
void <code class="descname">__audit_syscall_exit</code><span class="sig-paren">(</span>int<em>&nbsp;success</em>, long<em>&nbsp;return_code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate audit context after a system call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">success</span></code></dt>
<dd>success value of the syscall</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">return_code</span></code></dt>
<dd>return value of the syscall</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down after system call.  If the audit context has been marked as
auditable (either because of the AUDIT_RECORD_CONTEXT state from
filtering, or because some other part of the kernel wrote an audit
message), then write out the syscall information.  In call cases,
free the names stored from <code class="xref c c-func docutils literal"><span class="pre">getname()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_reusename">
struct filename * <code class="descname">__audit_reusename</code><span class="sig-paren">(</span>const __user char *<em>&nbsp;uptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_reusename" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out filename with info from existing entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">__user</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">uptr</span></code></dt>
<dd>userland ptr to pathname</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the audit_names list for the current audit context. If there is an
existing entry with a matching “uptr” then return the filename
associated with that audit_name. If not, return NULL.</p>
<dl class="function">
<dt id="c.__audit_getname">
void <code class="descname">__audit_getname</code><span class="sig-paren">(</span>struct filename *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_getname" title="Permalink to this definition">¶</a></dt>
<dd><p>add a name to the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a name to the list of audit names for this context.
Called from fs/namei.c:<code class="xref c c-func docutils literal"><span class="pre">getname()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_inode">
void <code class="descname">__audit_inode</code><span class="sig-paren">(</span>struct filename *<em>&nbsp;name</em>, const struct dentry *<em>&nbsp;dentry</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>store the inode and device from a lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name being audited</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry being audited</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>attributes for this particular entry</dd>
</dl>
<dl class="function">
<dt id="c.auditsc_get_stamp">
int <code class="descname">auditsc_get_stamp</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, struct timespec64 *<em>&nbsp;t</em>, unsigned int *<em>&nbsp;serial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.auditsc_get_stamp" title="Permalink to this definition">¶</a></dt>
<dd><p>get local copies of audit_context values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit_context for the task</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>timespec64 to store time recorded in the audit_context</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">serial</span></code></dt>
<dd>serial value that is recorded in the audit_context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also sets the context as auditable.</p>
<dl class="function">
<dt id="c.audit_set_loginuid">
int <code class="descname">audit_set_loginuid</code><span class="sig-paren">(</span>kuid_t<em>&nbsp;loginuid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_set_loginuid" title="Permalink to this definition">¶</a></dt>
<dd><p>set current task’s audit_context loginuid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">kuid_t</span> <span class="pre">loginuid</span></code></dt>
<dd>loginuid value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0.</p>
<p>Called (set) from fs/proc/base.c::<code class="xref c c-func docutils literal"><span class="pre">proc_loginuid_write()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_mq_open">
void <code class="descname">__audit_mq_open</code><span class="sig-paren">(</span>int<em>&nbsp;oflag</em>, umode_t<em>&nbsp;mode</em>, struct mq_attr *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_open" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ open</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oflag</span></code></dt>
<dd>open flag</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>mode bits</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>queue attributes</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_sendrecv">
void <code class="descname">__audit_mq_sendrecv</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, size_t<em>&nbsp;msg_len</em>, unsigned int<em>&nbsp;msg_prio</em>, const struct timespec64 *<em>&nbsp;abs_timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_sendrecv" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ timed send/receive</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">msg_len</span></code></dt>
<dd>Message length</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msg_prio</span></code></dt>
<dd>Message priority</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">abs_timeout</span></code></dt>
<dd>Message timeout in absolute time</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_notify">
void <code class="descname">__audit_mq_notify</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, const struct sigevent *<em>&nbsp;notification</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ notify</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigevent</span> <span class="pre">*</span> <span class="pre">notification</span></code></dt>
<dd>Notification event</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_getsetattr">
void <code class="descname">__audit_mq_getsetattr</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, struct mq_attr *<em>&nbsp;mqstat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_getsetattr" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ get/set attribute</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*</span> <span class="pre">mqstat</span></code></dt>
<dd>MQ flags</dd>
</dl>
<dl class="function">
<dt id="c.__audit_ipc_obj">
void <code class="descname">__audit_ipc_obj</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permissions</dd>
</dl>
<dl class="function">
<dt id="c.__audit_ipc_set_perm">
void <code class="descname">__audit_ipc_set_perm</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;qbytes</em>, uid_t<em>&nbsp;uid</em>, gid_t<em>&nbsp;gid</em>, umode_t<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_set_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for new ipc permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">qbytes</span></code></dt>
<dd>msgq bytes</dd>
<dt><code class="docutils literal"><span class="pre">uid_t</span> <span class="pre">uid</span></code></dt>
<dd>msgq user id</dd>
<dt><code class="docutils literal"><span class="pre">gid_t</span> <span class="pre">gid</span></code></dt>
<dd>msgq group id</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>msgq mode (permissions)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called only after <code class="xref c c-func docutils literal"><span class="pre">audit_ipc_obj()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_socketcall">
int <code class="descname">__audit_socketcall</code><span class="sig-paren">(</span>int<em>&nbsp;nargs</em>, unsigned long *<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_socketcall" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for sys_socketcall</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nargs</span></code></dt>
<dd>number of args, which should not be more than AUDITSC_ARGS.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">args</span></code></dt>
<dd>args array</dd>
</dl>
<dl class="function">
<dt id="c.__audit_fd_pair">
void <code class="descname">__audit_fd_pair</code><span class="sig-paren">(</span>int<em>&nbsp;fd1</em>, int<em>&nbsp;fd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_fd_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for pipe and socketpair</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd1</span></code></dt>
<dd>the first file descriptor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd2</span></code></dt>
<dd>the second file descriptor</dd>
</dl>
<dl class="function">
<dt id="c.__audit_sockaddr">
int <code class="descname">__audit_sockaddr</code><span class="sig-paren">(</span>int<em>&nbsp;len</em>, void *<em>&nbsp;a</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_sockaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for sys_bind, sys_connect, sys_sendto</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>data length in user space</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">a</span></code></dt>
<dd>data address in kernel space</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or NULL context or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.audit_signal_info">
int <code class="descname">audit_signal_info</code><span class="sig-paren">(</span>int<em>&nbsp;sig</em>, struct task_struct *<em>&nbsp;t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_signal_info" title="Permalink to this definition">¶</a></dt>
<dd><p>record signal info for shutting down audit subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig</span></code></dt>
<dd>signal value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>task being signaled</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the audit subsystem is being terminated, record the task (pid)
and uid that is doing that.</p>
<dl class="function">
<dt id="c.__audit_log_bprm_fcaps">
int <code class="descname">__audit_log_bprm_fcaps</code><span class="sig-paren">(</span>struct linux_binprm *<em>&nbsp;bprm</em>, const struct cred *<em>&nbsp;new</em>, const struct cred *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_bprm_fcaps" title="Permalink to this definition">¶</a></dt>
<dd><p>store information about a loading bprm and relevant fcaps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*</span> <span class="pre">bprm</span></code></dt>
<dd>pointer to the bprm being processed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the proposed new credentials</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the old credentials</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simply check if the proc already has the caps given by the file and if not
store the priv escalation info for later auditing at the end of the syscall</p>
<p>-Eric</p>
<dl class="function">
<dt id="c.__audit_log_capset">
void <code class="descname">__audit_log_capset</code><span class="sig-paren">(</span>const struct cred *<em>&nbsp;new</em>, const struct cred *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_capset" title="Permalink to this definition">¶</a></dt>
<dd><p>store information about the arguments to the capset syscall</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new credentials</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the old (current) credentials</dd>
</dl>
<p><strong>Description</strong></p>
<p>Record the arguments userspace sent to sys_capset for later printing by the
audit system if applicable</p>
<dl class="function">
<dt id="c.audit_core_dumps">
void <code class="descname">audit_core_dumps</code><span class="sig-paren">(</span>long<em>&nbsp;signr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_core_dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>record information about processes that end abnormally</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">signr</span></code></dt>
<dd>signal value</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a process ends with a core dump, something fishy is going on and we
should record the event for investigation.</p>
<dl class="function">
<dt id="c.audit_rule_change">
int <code class="descname">audit_rule_change</code><span class="sig-paren">(</span>int<em>&nbsp;type</em>, int<em>&nbsp;seq</em>, void *<em>&nbsp;data</em>, size_t<em>&nbsp;datasz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_rule_change" title="Permalink to this definition">¶</a></dt>
<dd><p>apply all rules to the specified message type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">seq</span></code></dt>
<dd>netlink audit message sequence (serial) number</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>payload data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">datasz</span></code></dt>
<dd>size of payload data</dd>
</dl>
<dl class="function">
<dt id="c.audit_list_rules_send">
int <code class="descname">audit_list_rules_send</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;request_skb</em>, int<em>&nbsp;seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_list_rules_send" title="Permalink to this definition">¶</a></dt>
<dd><p>list the audit rules</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">request_skb</span></code></dt>
<dd>skb of request we are replying to (used to target the reply)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">seq</span></code></dt>
<dd>netlink audit message sequence (serial) number</dd>
</dl>
<dl class="function">
<dt id="c.parent_len">
int <code class="descname">parent_len</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parent_len" title="Permalink to this definition">¶</a></dt>
<dd><p>find the length of the parent portion of a pathname</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>pathname of which to determine length</dd>
</dl>
<dl class="function">
<dt id="c.audit_compare_dname_path">
int <code class="descname">audit_compare_dname_path</code><span class="sig-paren">(</span>const char *<em>&nbsp;dname</em>, const char *<em>&nbsp;path</em>, int<em>&nbsp;parentlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_compare_dname_path" title="Permalink to this definition">¶</a></dt>
<dd><p>compare given dentry name with last component in given path. Return of 0 indicates a match.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">dname</span></code></dt>
<dd>dentry name that we’re comparing</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>full pathname that we’re comparing</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">parentlen</span></code></dt>
<dd>length of the parent if known. Passing in AUDIT_NAME_FULL
here indicates that we must compute this value.</dd>
</dl>
</div>
<div class="section" id="accounting-framework">
<h2>Accounting Framework<a class="headerlink" href="#accounting-framework" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.sys_acct">
long <code class="descname">sys_acct</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_acct" title="Permalink to this definition">¶</a></dt>
<dd><p>enable/disable process accounting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>file name for accounting records or NULL to shutdown accounting</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or negative errno values for failure.</p>
<p><a class="reference internal" href="#c.sys_acct" title="sys_acct"><code class="xref c c-func docutils literal"><span class="pre">sys_acct()</span></code></a> is the only system call needed to implement process
accounting. It takes the name of the file where accounting records
should be written. If the filename is NULL, accounting will be
shutdown.</p>
<dl class="function">
<dt id="c.acct_collect">
void <code class="descname">acct_collect</code><span class="sig-paren">(</span>long<em>&nbsp;exitcode</em>, int<em>&nbsp;group_dead</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acct_collect" title="Permalink to this definition">¶</a></dt>
<dd><p>collect accounting information into pacct_struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">exitcode</span></code></dt>
<dd>task exit code</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">group_dead</span></code></dt>
<dd>not 0, if this thread is the last one in the process.</dd>
</dl>
<dl class="function">
<dt id="c.acct_process">
void <code class="descname">acct_process</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.acct_process" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>handles process accounting for an exiting task</p>
</div>
<div class="section" id="block-devices">
<h2>Block Devices<a class="headerlink" href="#block-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.blk_delay_queue">
void <code class="descname">blk_delay_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_delay_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart queueing after defined interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">msecs</span></code></dt>
<dd>Delay in msecs</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Sometimes queueing needs to be postponed for a little while, to allow
resources to come back. This function will make sure that queueing is
restarted around the specified time.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_queue_async">
void <code class="descname">blk_start_queue_async</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_queue_async" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronously restart a previously stopped queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_start_queue_async" title="blk_start_queue_async"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue_async()</span></code></a> will clear the stop flag on the queue, and
ensure that the request_fn for the queue is run from an async
context.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_queue">
void <code class="descname">blk_start_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart a previously stopped queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_start_queue" title="blk_start_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue()</span></code></a> will clear the stop flag on the queue, and call
the request_fn for the queue if it was in a stopped state when
entered. Also see <a class="reference internal" href="#c.blk_stop_queue" title="blk_stop_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_stop_queue()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.blk_stop_queue">
void <code class="descname">blk_stop_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_stop_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The Linux block layer assumes that a block driver will consume all
entries on the request queue when the request_fn strategy is called.
Often this will not happen, because of hardware limitations (queue
depth settings). If a device driver gets a ‘queue full’ response,
or if it simply chooses not to queue more I/O at one point, it can
call this function to prevent the request_fn from being called until
the driver has signalled it’s ready to go again. This happens by calling
<a class="reference internal" href="#c.blk_start_queue" title="blk_start_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue()</span></code></a> to restart queue operations.</div></blockquote>
<dl class="function">
<dt id="c.blk_sync_queue">
void <code class="descname">blk_sync_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_sync_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel any pending callbacks on a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The block layer may perform asynchronous callback activity
on a queue, such as calling the unplug function after a timeout.
A block device may call blk_sync_queue to ensure that any
such activity is cancelled, thus allowing it to release resources
that the callbacks might use. The caller must already have made sure
that its -&gt;make_request_fn will not re-add plugging prior to calling
this function.</p>
<p>This function does not cancel any asynchronous activity arising
out of elevator or throttling code. That would require <code class="xref c c-func docutils literal"><span class="pre">elevator_exit()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">blkcg_exit_queue()</span></code> to be called with queue lock initialized.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__blk_run_queue_uncond">
void <code class="descname">__blk_run_queue_uncond</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_run_queue_uncond" title="Permalink to this definition">¶</a></dt>
<dd><p>run a queue whether or not it has been stopped</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Invoke request handling on a queue if there are any pending requests.
May be used to restart request handling after a request has completed.
This variant runs the queue whether or not the queue has been
stopped. Must be called with the queue lock held and interrupts
disabled. See also <strong>blk_run_queue</strong>.</div></blockquote>
<dl class="function">
<dt id="c.__blk_run_queue">
void <code class="descname">__blk_run_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_run_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>See <strong>blk_run_queue</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_run_queue_async">
void <code class="descname">blk_run_queue_async</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_run_queue_async" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue in workqueue context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Tells kblockd to perform the equivalent of <strong>blk_run_queue</strong> on behalf
of us.</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div>Since it is not allowed to run q-&gt;delay_work after <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a>
has canceled q-&gt;delay_work, callers must hold the queue lock to avoid
race conditions between <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> and <a class="reference internal" href="#c.blk_run_queue_async" title="blk_run_queue_async"><code class="xref c c-func docutils literal"><span class="pre">blk_run_queue_async()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.blk_run_queue">
void <code class="descname">blk_run_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_run_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Invoke request handling on this queue, if it has pending work to do.
May be used to restart queueing when a request has completed.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_bypass_start">
void <code class="descname">blk_queue_bypass_start</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bypass_start" title="Permalink to this definition">¶</a></dt>
<dd><p>enter queue bypass mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>In bypass mode, only the dispatch FIFO queue of <strong>q</strong> is used.  This
function makes <strong>q</strong> enter bypass mode and drains all requests which were
throttled or issued before.  On return, it’s guaranteed that no request
is being throttled or has ELVPRIV set and <code class="xref c c-func docutils literal"><span class="pre">blk_queue_bypass()</span></code> <code class="docutils literal"><span class="pre">true</span></code>
inside queue or RCU read lock.</p>
<dl class="function">
<dt id="c.blk_queue_bypass_end">
void <code class="descname">blk_queue_bypass_end</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bypass_end" title="Permalink to this definition">¶</a></dt>
<dd><p>leave queue bypass mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Leave bypass mode and restore the normal queueing behavior.</p>
<p><strong>Note</strong></p>
<p>although <a class="reference internal" href="#c.blk_queue_bypass_start" title="blk_queue_bypass_start"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_bypass_start()</span></code></a> is only called for blk-sq queues,
this function is called for both blk-sq and blk-mq queues.</p>
<dl class="function">
<dt id="c.blk_cleanup_queue">
void <code class="descname">blk_cleanup_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_cleanup_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to shutdown</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark <strong>q</strong> DYING, drain all pending requests, mark <strong>q</strong> DEAD, destroy and
put it.  All future requests will be failed immediately with -ENODEV.</p>
<dl class="function">
<dt id="c.blk_init_queue">
struct request_queue * <code class="descname">blk_init_queue</code><span class="sig-paren">(</span>request_fn_proc *<em>&nbsp;rfn</em>, spinlock_t *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_init_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a request queue for use with a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">request_fn_proc</span> <span class="pre">*</span> <span class="pre">rfn</span></code></dt>
<dd>The function to be called to process requests that have been
placed on the queue.</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>Request queue spin lock</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If a block device wishes to use the standard request handling procedures,
which sorts requests and coalesces adjacent requests, then it must
call <a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a>.  The function <strong>rfn</strong> will be called when there
are requests on the queue that need to be processed.  If the device
supports plugging, then <strong>rfn</strong> may not be called immediately when requests
are available on the queue, but may be called at some time later instead.
Plugged queues are generally unplugged when a buffer belonging to one
of the requests on the queue is needed, or due to memory pressure.</p>
<p><strong>rfn</strong> is not required, or even expected, to remove all requests off the
queue, but only as many as it can handle at a time.  If it does leave
requests on the queue, it is responsible for arranging that the requests
get dealt with eventually.</p>
<p>The queue spin lock must be held while manipulating the requests on the
request queue; this lock will be taken also from interrupt context, so irq
disabling is needed for it.</p>
<p>Function returns a pointer to the initialized request queue, or <code class="docutils literal"><span class="pre">NULL</span></code> if
it didn’t succeed.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a> must be paired with a <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> call
when the block device is deactivated (such as at module unload).</div></blockquote>
<dl class="function">
<dt id="c.blk_requeue_request">
void <code class="descname">blk_requeue_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_requeue_request" title="Permalink to this definition">¶</a></dt>
<dd><p>put a request back on queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to be inserted</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Drivers often keep queueing requests until the hardware cannot accept
more, when that condition happens we need to put the request back
on the queue. Must be called with queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.part_round_stats">
void <code class="descname">part_round_stats</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;cpu</em>, struct hd_struct *<em>&nbsp;part</em><span class="sig-paren">)</span><a class="headerlink" href="#c.part_round_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Round off the performance stats on a struct disk_stats.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>target block queue</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>cpu number for stats access</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hd_struct</span> <span class="pre">*</span> <span class="pre">part</span></code></dt>
<dd>target partition</dd>
</dl>
<p><strong>Description</strong></p>
<p>The average IO queue length and utilisation statistics are maintained
by observing the current state of the queue length and the amount of
time it has been in this state for.</p>
<p>Normally, that accounting is done on IO completion, but that can result
in more than a second’s worth of IO being accounted for within any one
second, leading to &gt;100% utilisation.  To deal with that, we call this
function to do a round-off before returning the results when reading
/proc/diskstats.  This accounts immediately for all queue usage up to
the current jiffies and restarts the counters again.</p>
<dl class="function">
<dt id="c.generic_make_request">
blk_qc_t <code class="descname">generic_make_request</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>hand a buffer to its device driver for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The bio describing the location in memory and on the device.</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> is used to make I/O requests of block
devices. It is passed a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>, which describes the I/O that needs
to be done.</p>
<p><a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> does not return any status.  The
success/failure status of the request, along with notification of
completion, is delivered asynchronously through the bio-&gt;bi_end_io
function described (one day) else where.</p>
<p>The caller of generic_make_request must make sure that bi_io_vec
are set to describe the memory buffer, and that bi_dev and bi_sector are
set to describe the device address, and the
bi_end_io and optionally bi_private are set to describe how
completion notification should be signaled.</p>
<p>generic_make_request and the drivers it calls may use bi_next if this
bio happens to be merged with someone else, and may resubmit the bio to
a lower device by calling into generic_make_request recursively, which
means the bio should NOT be touched after the call to -&gt;make_request_fn.</p>
<dl class="function">
<dt id="c.submit_bio">
blk_qc_t <code class="descname">submit_bio</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio" title="Permalink to this definition">¶</a></dt>
<dd><p>submit a bio to the block device layer for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> which describes the I/O</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code></a> is very similar in purpose to <a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a>, and
uses that function to do most of the work. Both are fairly rough
interfaces; <strong>bio</strong> must be presetup and ready for I/O.</p>
<dl class="function">
<dt id="c.blk_insert_cloned_request">
blk_status_t <code class="descname">blk_insert_cloned_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_insert_cloned_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for stacking drivers to submit a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue to submit the request</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being queued</dd>
</dl>
<dl class="function">
<dt id="c.blk_rq_err_bytes">
unsigned int <code class="descname">blk_rq_err_bytes</code><span class="sig-paren">(</span>const struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_err_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>determine number of bytes till the next failure boundary</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to examine</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>A request could be merge of IOs which require different failure
handling.  This function determines the number of bytes which
can be failed from the beginning of the request without
crossing into area which need to be retried further.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>The number of bytes to fail.</div></blockquote>
<dl class="function">
<dt id="c.blk_peek_request">
struct request * <code class="descname">blk_peek_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_peek_request" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the top of a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to peek at</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the request at the top of <strong>q</strong>.  The returned request
should be started using <a class="reference internal" href="#c.blk_start_request" title="blk_start_request"><code class="xref c c-func docutils literal"><span class="pre">blk_start_request()</span></code></a> before LLD starts
processing it.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to the request at the top of <strong>q</strong> if available.  Null
otherwise.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_request">
void <code class="descname">blk_start_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_request" title="Permalink to this definition">¶</a></dt>
<dd><p>start request processing on the driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request to dequeue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Dequeue <strong>req</strong> and start timeout timer on it.  This hands off the
request to the driver.</div></blockquote>
<dl class="function">
<dt id="c.blk_fetch_request">
struct request * <code class="descname">blk_fetch_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_fetch_request" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a request from a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to fetch a request from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the request at the top of <strong>q</strong>.  The request is started on
return and LLD can start processing it immediately.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to the request at the top of <strong>q</strong> if available.  Null
otherwise.</div></blockquote>
<dl class="function">
<dt id="c.blk_update_request">
bool <code class="descname">blk_update_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_update_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Special helper function for request stacking drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>req</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Ends I/O on a number of bytes attached to <strong>req</strong>, but doesn’t complete
the request structure even if <strong>req</strong> doesn’t have leftover.
If <strong>req</strong> has leftover, sets it up for the next range of segments.</p>
<p>This special helper function is only for request stacking drivers
(e.g. request-based dm) so that they can handle partial completion.
Actual device drivers should use blk_end_request instead.</p>
<p>Passing the result of <code class="xref c c-func docutils literal"><span class="pre">blk_rq_bytes()</span></code> as <strong>nr_bytes</strong> guarantees
<code class="docutils literal"><span class="pre">false</span></code> return from this function.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - this request doesn’t have any more data
<code class="docutils literal"><span class="pre">true</span></code>  - this request has more data</div></blockquote>
<dl class="function">
<dt id="c.blk_unprep_request">
void <code class="descname">blk_unprep_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_unprep_request" title="Permalink to this definition">¶</a></dt>
<dd><p>unprepare a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>the request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function makes a request ready for complete resubmission (or
completion).  It happens only after all error handling is complete,
so represents the appropriate moment to deallocate any resources
that were allocated to the request in the prep_rq_fn.  The queue
lock is held when calling this.</p>
<dl class="function">
<dt id="c.blk_end_request">
bool <code class="descname">blk_end_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drivers to complete the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ends I/O on a number of bytes attached to <strong>rq</strong>.
If <strong>rq</strong> has leftover, sets it up for the next range of segments.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.blk_end_request_all">
void <code class="descname">blk_end_request_all</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_request_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drives to finish the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Completely finish <strong>rq</strong>.</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request">
bool <code class="descname">__blk_end_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drivers to complete the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Must be called with queue lock held unlike <a class="reference internal" href="#c.blk_end_request" title="blk_end_request"><code class="xref c c-func docutils literal"><span class="pre">blk_end_request()</span></code></a>.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request_all">
void <code class="descname">__blk_end_request_all</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drives to finish the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Completely finish <strong>rq</strong>.  Must be called with queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request_cur">
bool <code class="descname">__blk_end_request_cur</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request_cur" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to finish the current request chunk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish the current chunk for</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Complete the current consecutively mapped chunk from <strong>rq</strong>.  Must
be called with queue lock held.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.rq_flush_dcache_pages">
void <code class="descname">rq_flush_dcache_pages</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rq_flush_dcache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to flush all pages in a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to be flushed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Flush all pages in <strong>rq</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_lld_busy">
int <code class="descname">blk_lld_busy</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_lld_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if underlying low-level drivers of a device are busy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device being checked</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check if underlying low-level drivers of a device are busy.
If the drivers want to export their busy state, they must set own
exporting function using <code class="xref c c-func docutils literal"><span class="pre">blk_queue_lld_busy()</span></code> first.</p>
<p>Basically, this function is used only by request stacking drivers
to stop dispatching requests to underlying devices when underlying
devices are busy.  This behavior helps more I/O merging on the queue
of the request stacking driver and prevents I/O throughput regression
on burst I/O load.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>0 - Not busy (The request stacking driver should dispatch request)
1 - Busy (The request stacking driver should stop dispatching request)</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_unprep_clone">
void <code class="descname">blk_rq_unprep_clone</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unprep_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to free all bios in a cloned request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the clone request to be cleaned up</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Free all bios in <strong>rq</strong> for a cloned request.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_prep_clone">
int <code class="descname">blk_rq_prep_clone</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, struct request *<em>&nbsp;rq_src</em>, struct bio_set *<em>&nbsp;bs</em>, gfp_t<em>&nbsp;gfp_mask</em>, int (*bio_ctr) (struct bio<em>&nbsp;*</em>, struct bio<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_prep_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to setup clone request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to be setup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq_src</span></code></dt>
<dd>original request to be cloned</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>bio_set that bios for clone are allocated from</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation mask for bio</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">bio</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">bio_ctr</span></code></dt>
<dd>setup function to be called for each clone bio.
Returns <code class="docutils literal"><span class="pre">0</span></code> for success, non <code class="docutils literal"><span class="pre">0</span></code> for failure.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private data to be passed to <strong>bio_ctr</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Clones bios in <strong>rq_src</strong> to <strong>rq</strong>, and copies attributes of <strong>rq_src</strong> to <strong>rq</strong>.
The actual data parts of <strong>rq_src</strong> (e.g. -&gt;cmd, -&gt;sense)
are not copied, and copying such parts is the caller’s responsibility.
Also, pages which the original bios are pointing to are not copied
and the cloned bios just point same pages.
So cloned bios must be completed before original bios, which means
the caller must complete <strong>rq</strong> before <strong>rq_src</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_plug">
void <code class="descname">blk_start_plug</code><span class="sig-paren">(</span>struct blk_plug *<em>&nbsp;plug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_plug" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize blk_plug and track it inside the task_struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_plug</span> <span class="pre">*</span> <span class="pre">plug</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_plug</span></code> that needs to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Tracking blk_plug inside the task_struct will help with auto-flushing the
pending I/O should the task end up blocking between <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal"><span class="pre">blk_start_plug()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">blk_finish_plug()</span></code>. This is important from a performance perspective, but
also ensures that we don’t deadlock. For instance, if the task is blocking
for a memory allocation, memory reclaim could end up wanting to free a
page belonging to that request that is currently residing in our private
plug. By flushing the pending I/O when the process goes to sleep, we avoid
this kind of deadlock.</div></blockquote>
<dl class="function">
<dt id="c.blk_pm_runtime_init">
void <code class="descname">blk_pm_runtime_init</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pm_runtime_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Block layer runtime PM initialization routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device the queue belongs to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize runtime-PM-related fields for <strong>q</strong> and start auto suspend for
<strong>dev</strong>. Drivers that want to take advantage of request-based runtime PM
should call this function after <strong>dev</strong> has been initialized, and its
request queue <strong>q</strong> has been allocated, and runtime PM for it can not happen
yet(either due to disabled/forbidden or its usage_count &gt; 0). In most
cases, driver should call this function before any I/O has taken place.</p>
<p>This function takes care of setting up using auto suspend for the device,
the autosuspend delay is set to -1 to make runtime suspend impossible
until an updated value is either set by user or by driver. Drivers do
not need to touch other autosuspend settings.</p>
<p>The block layer runtime PM is request based, so only works for drivers
that use request as their IO unit instead of those directly use bio’s.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_pre_runtime_suspend">
int <code class="descname">blk_pre_runtime_suspend</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pre_runtime_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre runtime suspend check</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function will check if runtime suspend is allowed for the device
by examining if there are any requests pending in the queue. If there
are requests pending, the device can not be runtime suspended; otherwise,
the queue’s status will be updated to SUSPENDING and the driver can
proceed to suspend the device.</p>
<p>For the not allowed case, we mark last busy for the device so that
runtime PM core will try to autosuspend it some time later.</p>
<p>This function should be called near the start of the device’s
runtime_suspend callback.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>0            - OK to runtime suspend the device
-EBUSY       - Device should not be runtime suspended</div></blockquote>
<dl class="function">
<dt id="c.blk_post_runtime_suspend">
void <code class="descname">blk_post_runtime_suspend</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_post_runtime_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Post runtime suspend processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>return value of the device’s runtime_suspend function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue’s runtime status according to the return value of the
device’s runtime suspend function and mark last busy for the device so
that PM core will try to auto suspend the device at a later time.</p>
<p>This function should be called near the end of the device’s
runtime_suspend callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_pre_runtime_resume">
void <code class="descname">blk_pre_runtime_resume</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pre_runtime_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre runtime resume processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue’s runtime status to RESUMING in preparation for the
runtime resume of the device.</p>
<p>This function should be called near the start of the device’s
runtime_resume callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_post_runtime_resume">
void <code class="descname">blk_post_runtime_resume</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_post_runtime_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Post runtime resume processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>return value of the device’s runtime_resume function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue’s runtime status according to the return value of the
device’s runtime_resume function. If it is successfully resumed, process
the requests that are queued into the device’s queue when it is resuming
and then mark last busy and initiate autosuspend for it.</p>
<p>This function should be called near the end of the device’s
runtime_resume callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_set_runtime_active">
void <code class="descname">blk_set_runtime_active</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_runtime_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Force runtime status of the queue to be active</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the device is left runtime suspended during system suspend the resume
hook typically resumes the device and corrects runtime status
accordingly. However, that does not affect the queue runtime PM status
which is still “suspended”. This prevents processing requests from the
queue.</p>
<p>This function can be used in driver’s resume hook to correct queue
runtime PM status and re-enable peeking requests from the queue. It
should be called before first request is added to the queue.</p>
<dl class="function">
<dt id="c.__blk_drain_queue">
void <code class="descname">__blk_drain_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, bool<em>&nbsp;drain_all</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_drain_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>drain requests from request_queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to drain</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">drain_all</span></code></dt>
<dd>whether to drain all requests or only the ones w/ ELVPRIV</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drain requests from <strong>q</strong>.  If <strong>drain_all</strong> is set, all requests are drained.
If not, only ELVPRIV requests are drained.  The caller is responsible
for ensuring that no new requests which need to be drained are queued.</p>
<dl class="function">
<dt id="c.__get_request">
struct request * <code class="descname">__get_request</code><span class="sig-paren">(</span>struct request_list *<em>&nbsp;rl</em>, unsigned int<em>&nbsp;op</em>, struct bio *<em>&nbsp;bio</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_request" title="Permalink to this definition">¶</a></dt>
<dd><p>get a free request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_list</span> <span class="pre">*</span> <span class="pre">rl</span></code></dt>
<dd>request list to allocate from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>operation and flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to allocate request for (can be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a free request from <strong>q</strong>.  This function may fail under memory
pressure or if <strong>q</strong> is dead.</p>
<p>Must be called with <strong>q</strong>-&gt;queue_lock held and,
Returns ERR_PTR on failure, with <strong>q</strong>-&gt;queue_lock held.
Returns request pointer on success, with <strong>q</strong>-&gt;queue_lock <em>not held</em>.</p>
<dl class="function">
<dt id="c.get_request">
struct request * <code class="descname">get_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;op</em>, struct bio *<em>&nbsp;bio</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_request" title="Permalink to this definition">¶</a></dt>
<dd><p>get a free request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request_queue to allocate request from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>operation and flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to allocate request for (can be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a free request from <strong>q</strong>.  If <code class="docutils literal"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> is set in <strong>gfp_mask</strong>,
this function keeps retrying under memory pressure and fails iff <strong>q</strong> is dead.</p>
<p>Must be called with <strong>q</strong>-&gt;queue_lock held and,
Returns ERR_PTR on failure, with <strong>q</strong>-&gt;queue_lock held.
Returns request pointer on success, with <strong>q</strong>-&gt;queue_lock <em>not held</em>.</p>
<dl class="function">
<dt id="c.blk_attempt_plug_merge">
bool <code class="descname">blk_attempt_plug_merge</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, unsigned int *<em>&nbsp;request_count</em>, struct request **<em>&nbsp;same_queue_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_attempt_plug_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>try to merge with <code class="docutils literal"><span class="pre">current</span></code>’s plugged list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request_queue new bio is being queued at</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>new bio being queued</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">request_count</span></code></dt>
<dd>out parameter for number of traversed plugged requests</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">**</span> <span class="pre">same_queue_rq</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> that gets filled in when
another request associated with <strong>q</strong> is found on the plug list
(optional, may be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether <strong>bio</strong> being queued on <strong>q</strong> can be merged with a request
on <code class="docutils literal"><span class="pre">current</span></code>’s plugged list.  Returns <code class="docutils literal"><span class="pre">true</span></code> if merge was successful,
otherwise <code class="docutils literal"><span class="pre">false</span></code>.</p>
<p>Plugging coalesces IOs from the same issuer for the same purpose without
going through <strong>q</strong>-&gt;queue_lock.  As such it’s more of an issuing mechanism
than scheduling, and the request, while may have elvpriv data, is not
added on the elevator at this point.  In addition, we don’t have
reliable access to the elevator outside queue lock.  Only check basic
merging parameters without querying the elevator.</p>
<p>Caller must ensure !blk_queue_nomerges(q) beforehand.</p>
<dl class="function">
<dt id="c.blk_cloned_rq_check_limits">
int <code class="descname">blk_cloned_rq_check_limits</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_cloned_rq_check_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to check a cloned request for new the queue limits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being checked</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>rq</strong> may have been made based on weaker limitations of upper-level queues
in request stacking drivers, and it may violate the limitation of <strong>q</strong>.
Since the block layer and the underlying device driver trust <strong>rq</strong>
after it is inserted to <strong>q</strong>, it should be checked against <strong>q</strong> before
the insertion using this generic function.</p>
<p>Request stacking drivers like request-based dm may change the queue
limits when retrying requests on other queues. Those requests need
to be checked against the new queue limits again during dispatch.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_end_bidi_request">
bool <code class="descname">blk_end_bidi_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, unsigned int<em>&nbsp;bidi_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_bidi_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete a bidi request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to complete</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong></dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bidi_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong>-&gt;next_rq</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ends I/O on a number of bytes attached to <strong>rq</strong> and <strong>rq</strong>-&gt;next_rq.
Drivers that supports bidi can safely call this member for any
type of request, bidi or uni.  In the later case <strong>bidi_bytes</strong> is
just ignored.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_bidi_request">
bool <code class="descname">__blk_end_bidi_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, unsigned int<em>&nbsp;bidi_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_bidi_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete a bidi request with queue lock held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to complete</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong></dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bidi_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong>-&gt;next_rq</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Identical to <a class="reference internal" href="#c.blk_end_bidi_request" title="blk_end_bidi_request"><code class="xref c c-func docutils literal"><span class="pre">blk_end_bidi_request()</span></code></a> except that queue lock is
assumed to be locked on entry and remains so on return.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_map_user_iov">
int <code class="descname">blk_rq_map_user_iov</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, struct rq_map_data *<em>&nbsp;map_data</em>, const struct iov_iter *<em>&nbsp;iter</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_user_iov" title="Permalink to this definition">¶</a></dt>
<dd><p>map user data to a request, for passthrough requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to map data to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rq_map_data</span> <span class="pre">*</span> <span class="pre">map_data</span></code></dt>
<dd>pointer to the rq_map_data holding pages (if necessary)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>iovec iterator</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Data will be mapped directly for zero copy I/O, if possible. Otherwise
a kernel bounce buffer is used.</p>
<p>A matching <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_unmap_user()</span></code></a> must be issued at the end of I/O, while
still in process context.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>The mapped bio may need to be bounced through <code class="xref c c-func docutils literal"><span class="pre">blk_queue_bounce()</span></code></dt>
<dd>before being submitted to the device, as pages mapped may be out of
reach. It’s the callers responsibility to make sure this happens. The
original bio must be passed back in to <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_unmap_user()</span></code></a> for proper
unmapping.</dd>
</dl>
<dl class="function">
<dt id="c.blk_rq_unmap_user">
int <code class="descname">blk_rq_unmap_user</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unmap_user" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap a request with user data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>start of bio list</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Unmap a rq previously mapped by <code class="xref c c-func docutils literal"><span class="pre">blk_rq_map_user()</span></code>. The caller must
supply the original rq-&gt;bio from the <code class="xref c c-func docutils literal"><span class="pre">blk_rq_map_user()</span></code> return, since
the I/O completion may have changed rq-&gt;bio.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_map_kern">
int <code class="descname">blk_rq_map_kern</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, void *<em>&nbsp;kbuf</em>, unsigned int<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_kern" title="Permalink to this definition">¶</a></dt>
<dd><p>map kernel data to a request, for passthrough requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to fill</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">kbuf</span></code></dt>
<dd>the kernel buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of user data</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Data will be mapped directly if possible. Otherwise a bounce
buffer is used. Can be called multiple times to append multiple
buffers.</div></blockquote>
<dl class="function">
<dt id="c.__blk_release_queue">
void <code class="descname">__blk_release_queue</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_release_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>release a request queue when it is no longer needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>pointer to the release_work member of the request queue to be released</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>blk_release_queue is the counterpart of <a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a>. It should be
called when a request queue is being released; typically when a block
device is being de-registered. Its primary task it to free the queue
itself.</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>The low level driver must have finished any outstanding requests first
via <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a>.</p>
<p>Although <code class="xref c c-func docutils literal"><span class="pre">blk_release_queue()</span></code> may be called with preemption disabled,
<a class="reference internal" href="#c.__blk_release_queue" title="__blk_release_queue"><code class="xref c c-func docutils literal"><span class="pre">__blk_release_queue()</span></code></a> may sleep.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_prep_rq">
void <code class="descname">blk_queue_prep_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, prep_rq_fn *<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_prep_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>set a prepare_request function for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue</dd>
<dt><code class="docutils literal"><span class="pre">prep_rq_fn</span> <span class="pre">*</span> <span class="pre">pfn</span></code></dt>
<dd>prepare_request function</dd>
</dl>
<p><strong>Description</strong></p>
<p>It’s possible for a queue to register a prepare_request callback which
is invoked before the request is handed to the request_fn. The goal of
the function is to prepare a request for I/O, it can be used to build a
cdb from the request data for instance.</p>
<dl class="function">
<dt id="c.blk_queue_unprep_rq">
void <code class="descname">blk_queue_unprep_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unprep_rq_fn *<em>&nbsp;ufn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_unprep_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>set an unprepare_request function for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue</dd>
<dt><code class="docutils literal"><span class="pre">unprep_rq_fn</span> <span class="pre">*</span> <span class="pre">ufn</span></code></dt>
<dd>unprepare_request function</dd>
</dl>
<p><strong>Description</strong></p>
<p>It’s possible for a queue to register an unprepare_request callback
which is invoked before the request is finally completed. The goal
of the function is to deallocate any data that was allocated in the
prepare_request callback.</p>
<dl class="function">
<dt id="c.blk_set_default_limits">
void <code class="descname">blk_set_default_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;lim</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_default_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>reset limits to default values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">lim</span></code></dt>
<dd>the queue_limits structure to reset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a queue_limit struct to its default state.</div></blockquote>
<dl class="function">
<dt id="c.blk_set_stacking_limits">
void <code class="descname">blk_set_stacking_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;lim</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_stacking_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>set default limits for stacking devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">lim</span></code></dt>
<dd>the queue_limits structure to reset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a queue_limit struct to its default state. Should be used
by stacking drivers like DM that have no internal limits.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_make_request">
void <code class="descname">blk_queue_make_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, make_request_fn *<em>&nbsp;mfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>define an alternate make_request function for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device to be affected</dd>
<dt><code class="docutils literal"><span class="pre">make_request_fn</span> <span class="pre">*</span> <span class="pre">mfn</span></code></dt>
<dd>the alternate make_request function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The normal way for <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bios</span></code> to be passed to a device
driver is for them to be collected into requests on a request
queue, and then to allow the device driver to select requests
off that queue when it is ready.  This works well for many block
devices. However some block devices (typically virtual devices
such as md or lvm) do not benefit from the processing on the
request queue, and are served best by having the requests passed
directly to them.  This can be achieved by providing a function
to <a class="reference internal" href="#c.blk_queue_make_request" title="blk_queue_make_request"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_make_request()</span></code></a>.</div></blockquote>
<dl class="docutils">
<dt>Caveat:</dt>
<dd>The driver that does this <em>must</em> be able to deal appropriately
with buffers in “highmemory”. This can be accomplished by either calling
<code class="xref c c-func docutils literal"><span class="pre">__bio_kmap_atomic()</span></code> to get a temporary kernel mapping, or by calling
<code class="xref c c-func docutils literal"><span class="pre">blk_queue_bounce()</span></code> to create a buffer in normal memory.</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_bounce_limit">
void <code class="descname">blk_queue_bounce_limit</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, u64<em>&nbsp;max_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bounce_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>set bounce buffer limit for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">max_addr</span></code></dt>
<dd>the maximum address the device can handle</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Different hardware can have different requirements as to what pages
it can do I/O directly to. A low level driver can call
blk_queue_bounce_limit to have lower memory pages allocated as bounce
buffers for doing I/O to pages residing above <strong>max_addr</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_hw_sectors">
void <code class="descname">blk_queue_max_hw_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_hw_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_hw_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a request for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_hw_sectors</span></code></dt>
<dd>max hardware sectors in the usual 512b unit</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set a hard upper limit,
max_hw_sectors, on the size of requests.  max_hw_sectors is set by
the device driver based upon the capabilities of the I/O
controller.</p>
<p>max_dev_sectors is a hard limit imposed by the storage device for
READ/WRITE requests. It is set by the disk driver.</p>
<p>max_sectors is a soft limit imposed by the block layer for
filesystem type requests.  This value can be overridden on a
per-device basis in /sys/block/&lt;device&gt;/queue/max_sectors_kb.
The soft limit can not exceed max_hw_sectors.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_chunk_sectors">
void <code class="descname">blk_queue_chunk_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;chunk_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_chunk_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set size of the chunk for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">chunk_sectors</span></code></dt>
<dd>chunk sectors in the usual 512b unit</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If a driver doesn’t want IOs to cross a given chunk size, it can set
this limit and prevent merging across chunks. Note that the chunk size
must currently be a power-of-2 in sectors. Also note that the block
layer must accept a page worth of data at any offset. So if the
crossing of chunks is a hard limitation in the driver, it must still be
prepared to split single page bios.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_discard_sectors">
void <code class="descname">blk_queue_max_discard_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_discard_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single discard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_discard_sectors</span></code></dt>
<dd>maximum number of sectors to discard</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_write_same_sectors">
void <code class="descname">blk_queue_max_write_same_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_write_same_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_same_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single write same</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_same_sectors</span></code></dt>
<dd>maximum number of sectors to write per command</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_write_zeroes_sectors">
void <code class="descname">blk_queue_max_write_zeroes_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_write_zeroes_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_zeroes_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single write zeroes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_zeroes_sectors</span></code></dt>
<dd>maximum number of sectors to write per command</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_segments">
void <code class="descname">blk_queue_max_segments</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;max_segments</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>set max hw segments for a request for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt>
<dd>max number of segments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the number of
hw data segments in a request.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_discard_segments">
void <code class="descname">blk_queue_max_discard_segments</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;max_segments</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>set max segments for discard requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt>
<dd>max number of segments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the number of
segments in a discard request.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_segment_size">
void <code class="descname">blk_queue_max_segment_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segment_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set max segment size for blk_rq_map_sg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_size</span></code></dt>
<dd>max size of segment in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the size of a
coalesced segment</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_logical_block_size">
void <code class="descname">blk_queue_logical_block_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_logical_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set logical block size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">size</span></code></dt>
<dd>the logical block size, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This should be set to the lowest possible block size that the
storage device can address.  The default of 512 covers most
hardware.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_physical_block_size">
void <code class="descname">blk_queue_physical_block_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_physical_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set physical block size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>the physical block size, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This should be set to the lowest possible sector size that the
hardware can operate on without reverting to read-modify-write
operations.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_alignment_offset">
void <code class="descname">blk_queue_alignment_offset</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_alignment_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>set physical block alignment offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>alignment offset in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Some devices are naturally misaligned to compensate for things like
the legacy DOS partition table 63-sector offset.  Low-level drivers
should call this function for devices whose first sector is not
naturally aligned.</div></blockquote>
<dl class="function">
<dt id="c.blk_limits_io_min">
void <code class="descname">blk_limits_io_min</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;limits</em>, unsigned int<em>&nbsp;min</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_min" title="Permalink to this definition">¶</a></dt>
<dd><p>set minimum request size for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">limits</span></code></dt>
<dd>the queue limits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Some devices have an internal block size bigger than the reported
hardware sector size.  This function can be used to signal the
smallest I/O the device can perform without incurring a performance
penalty.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_io_min">
void <code class="descname">blk_queue_io_min</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;min</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_min" title="Permalink to this definition">¶</a></dt>
<dd><p>set minimum request size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report a granularity or preferred minimum I/O
size which is the smallest request the device can perform without
incurring a performance penalty.  For disk drives this is often the
physical block size.  For RAID arrays it is often the stripe chunk
size.  A properly aligned multiple of minimum_io_size is the
preferred request size for workloads where a high number of I/O
operations is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_limits_io_opt">
void <code class="descname">blk_limits_io_opt</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;limits</em>, unsigned int<em>&nbsp;opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>set optimal request size for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">limits</span></code></dt>
<dd>the queue limits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report an optimal I/O size, which is the
device’s preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_io_opt">
void <code class="descname">blk_queue_io_opt</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>set optimal request size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt>
<dd>optimal request size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report an optimal I/O size, which is the
device’s preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_stack_limits">
void <code class="descname">blk_queue_stack_limits</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;t</em>, struct request_queue *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>inherit underlying queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver (top)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>the underlying device (bottom)</dd>
</dl>
<dl class="function">
<dt id="c.blk_stack_limits">
int <code class="descname">blk_stack_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;t</em>, struct queue_limits *<em>&nbsp;b</em>, sector_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue_limits for stacked devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver limits (top device)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>the underlying queue limits (bottom, component device)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt>
<dd>first data sector within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is used by stacking drivers like MD and DM to ensure
that all component devices have compatible block sizes and
alignments.  The stacking driver must provide a queue_limits
struct (top) and then iteratively call the stacking function for
all component (bottom) devices.  The stacking function will
attempt to combine the values and ensure proper alignment.</p>
<p>Returns 0 if the top and bottom queue_limits are compatible.  The
top device’s block sizes and alignment offsets may be adjusted to
ensure alignment with the bottom device. If no compatible sizes
and alignments exist, -1 is returned and the resulting top
queue_limits will have the misaligned flag set to indicate that
the alignment_offset is undefined.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bdev_stack_limits">
int <code class="descname">bdev_stack_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;t</em>, struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdev_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver limits (top device)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the component block_device (bottom)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt>
<dd>first data sector within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Merges queue limits for a top device and a block_device.  Returns
0 if alignment didn’t change.  Returns -1 if adding the bottom
device caused misalignment.</div></blockquote>
<dl class="function">
<dt id="c.disk_stack_limits">
void <code class="descname">disk_stack_limits</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>MD/DM gendisk (top)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the underlying block device (bottom)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">offset</span></code></dt>
<dd>offset to beginning of data within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Merges the limits for a top level gendisk and a bottom level
block_device.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_dma_pad">
void <code class="descname">blk_queue_dma_pad</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>set pad mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>pad mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set dma pad mask.</p>
<p>Appending pad buffer to a request modifies the last entry of a
scatter list such that it includes the pad buffer.</p>
<dl class="function">
<dt id="c.blk_queue_update_dma_pad">
void <code class="descname">blk_queue_update_dma_pad</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>update pad mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>pad mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update dma pad mask.</p>
<p>Appending pad buffer to a request modifies the last entry of a
scatter list such that it includes the pad buffer.</p>
<dl class="function">
<dt id="c.blk_queue_dma_drain">
int <code class="descname">blk_queue_dma_drain</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, dma_drain_needed_fn *<em>&nbsp;dma_drain_needed</em>, void *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_drain" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up a drain buffer for excess dma.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">dma_drain_needed_fn</span> <span class="pre">*</span> <span class="pre">dma_drain_needed</span></code></dt>
<dd>fn which returns non-zero if drain is necessary</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>physically contiguous buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>size of the buffer in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices have excess DMA problems and can’t simply discard (or
zero fill) the unwanted piece of the transfer.  They have to have a
real area of memory to transfer it into.  The use case for this is
ATAPI devices in DMA mode.  If the packet command causes a transfer
bigger than the transfer size some HBAs will lock up if there
aren’t DMA elements to contain the excess transfer.  What this API
does is adjust the queue so that the buf is always appended
silently to the scatterlist.</p>
<p><strong>Note</strong></p>
<p>This routine adjusts max_hw_segments to make room for appending
the drain buffer.  If you call <a class="reference internal" href="#c.blk_queue_max_segments" title="blk_queue_max_segments"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_max_segments()</span></code></a> after calling
this routine, you must set the limit to one fewer than your device
can support otherwise there won’t be room for the drain buffer.</p>
<dl class="function">
<dt id="c.blk_queue_segment_boundary">
void <code class="descname">blk_queue_segment_boundary</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_segment_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>set boundary rules for segment merging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>the memory boundary mask</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_virt_boundary">
void <code class="descname">blk_queue_virt_boundary</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_virt_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>set boundary rules for bio merging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>the memory boundary mask</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_dma_alignment">
void <code class="descname">blk_queue_dma_alignment</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>set dma length and memory alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>alignment mask</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>set required memory and length alignment for direct dma transactions.
this is used when building direct io requests for the queue.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_update_dma_alignment">
void <code class="descname">blk_queue_update_dma_alignment</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>update dma length and memory alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>alignment mask</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>update required memory and length alignment for direct dma transactions.
If the requested alignment is larger than the current alignment, then
the current queue alignment is updated to the new value, otherwise it
is left alone.  The design of this is to allow multiple objects
(driver, device, transport etc) to set their respective
alignments without having them interfere.</div></blockquote>
<dl class="function">
<dt id="c.blk_set_queue_depth">
void <code class="descname">blk_set_queue_depth</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_queue_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>tell the block layer about the device queue depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>queue depth</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_write_cache">
void <code class="descname">blk_queue_write_cache</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, bool<em>&nbsp;wc</em>, bool<em>&nbsp;fua</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_write_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>configure queue’s write cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">wc</span></code></dt>
<dd>write back cache on or off</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">fua</span></code></dt>
<dd>device supports FUA writes, if true</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer about the write cache of <strong>q</strong>.</p>
<dl class="function">
<dt id="c.blk_execute_rq_nowait">
void <code class="descname">blk_execute_rq_nowait</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct gendisk *<em>&nbsp;bd_disk</em>, struct request *<em>&nbsp;rq</em>, int<em>&nbsp;at_head</em>, rq_end_io_fn *<em>&nbsp;done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_execute_rq_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a request into queue for execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to insert the request in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">bd_disk</span></code></dt>
<dd>matching gendisk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to insert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">at_head</span></code></dt>
<dd>insert request at head or tail of queue</dd>
<dt><code class="docutils literal"><span class="pre">rq_end_io_fn</span> <span class="pre">*</span> <span class="pre">done</span></code></dt>
<dd>I/O completion handler</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Insert a fully prepared request at the back of the I/O scheduler queue
for execution.  Don’t wait for completion.</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div>This function will invoke <strong>done</strong> directly if the queue is dead.</div></blockquote>
<dl class="function">
<dt id="c.blk_execute_rq">
void <code class="descname">blk_execute_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct gendisk *<em>&nbsp;bd_disk</em>, struct request *<em>&nbsp;rq</em>, int<em>&nbsp;at_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_execute_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a request into queue for execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to insert the request in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">bd_disk</span></code></dt>
<dd>matching gendisk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to insert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">at_head</span></code></dt>
<dd>insert request at head or tail of queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Insert a fully prepared request at the back of the I/O scheduler queue
for execution and wait for completion.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_flush">
int <code class="descname">blkdev_issue_flush</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, gfp_t<em>&nbsp;gfp_mask</em>, sector_t *<em>&nbsp;error_sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue flush for</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">*</span> <span class="pre">error_sector</span></code></dt>
<dd>error sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a flush for the block device in question. Caller can supply
room for storing the error offset in case of a flush error, if they
wish to.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_discard">
int <code class="descname">blkdev_issue_discard</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_discard" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a discard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue discard for</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to discard</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>BLKDEV_DISCARD_* flags to control behaviour</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a discard request for the sectors in question.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_write_same">
int <code class="descname">blkdev_issue_write_same</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_write_same" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a write same operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>target blockdev</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page containing data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a write same request for the sectors in question.</div></blockquote>
<dl class="function">
<dt id="c.__blkdev_issue_zeroout">
int <code class="descname">__blkdev_issue_zeroout</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct bio **<em>&nbsp;biop</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blkdev_issue_zeroout" title="Permalink to this definition">¶</a></dt>
<dd><p>generate number of zero filed write bios</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">**</span> <span class="pre">biop</span></code></dt>
<dd>pointer to anchor bio</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt>
<dd>controls detailed behavior</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.</p>
<p>Note that this function may fail with -EOPNOTSUPP if the driver signals
zeroing offload support, but the device fails to process the command (for
some devices there is no non-destructive way to verify whether this
operation is actually supported).  In this case the caller should call
retry the call to <a class="reference internal" href="#c.blkdev_issue_zeroout" title="blkdev_issue_zeroout"><code class="xref c c-func docutils literal"><span class="pre">blkdev_issue_zeroout()</span></code></a> and the fallback path will be used.</p>
<p>If a device is using logical block provisioning, the underlying space will
not be released if <code class="docutils literal"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOUNMAP.</p>
<p>If <code class="docutils literal"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOFALLBACK, the function will return
-EOPNOTSUPP if no explicit hardware offload for zeroing is provided.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_zeroout">
int <code class="descname">blkdev_issue_zeroout</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_zeroout" title="Permalink to this definition">¶</a></dt>
<dd><p>zero-fill a block range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to write</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt>
<dd>controls detailed behavior</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.  See <a class="reference internal" href="#c.__blkdev_issue_zeroout" title="__blkdev_issue_zeroout"><code class="xref c c-func docutils literal"><span class="pre">__blkdev_issue_zeroout()</span></code></a> for the
valid values for <code class="docutils literal"><span class="pre">flags</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_find_tag">
struct request * <code class="descname">blk_queue_find_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_find_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find a request by its tag and queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>The tag of the request</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>Should be used when a device returns a tag and you want to match
it with a request.</p>
<p>no locks need be held.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_free_tags">
void <code class="descname">blk_free_tags</code><span class="sig-paren">(</span>struct blk_queue_tag *<em>&nbsp;bqt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release a given set of tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_queue_tag</span> <span class="pre">*</span> <span class="pre">bqt</span></code></dt>
<dd>the tag map to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop the reference count on <strong>bqt</strong> and frees it when the last reference
is dropped.</p>
<dl class="function">
<dt id="c.blk_queue_free_tags">
void <code class="descname">blk_queue_free_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div>This is used to disable tagged queuing to a device, yet leave
queue in function.</div></blockquote>
<dl class="function">
<dt id="c.blk_init_tags">
struct blk_queue_tag * <code class="descname">blk_init_tags</code><span class="sig-paren">(</span>int<em>&nbsp;depth</em>, int<em>&nbsp;alloc_policy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_init_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the tag info for an external tag map</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>the maximum queue depth supported</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">alloc_policy</span></code></dt>
<dd>tag allocation policy</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_init_tags">
int <code class="descname">blk_queue_init_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;depth</em>, struct blk_queue_tag *<em>&nbsp;tags</em>, int<em>&nbsp;alloc_policy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_init_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the queue tag info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>the maximum queue depth supported</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_queue_tag</span> <span class="pre">*</span> <span class="pre">tags</span></code></dt>
<dd>the tag to use</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">alloc_policy</span></code></dt>
<dd>tag allocation policy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue lock must be held here if the function is called to resize an
existing map.</p>
<dl class="function">
<dt id="c.blk_queue_resize_tags">
int <code class="descname">blk_queue_resize_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;new_depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_resize_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>change the queueing depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_depth</span></code></dt>
<dd>the new max command queueing depth</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div>Must be called with the queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_start_tag">
int <code class="descname">blk_queue_start_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_start_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find a free tag and assign it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the block request that needs tagging</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This can either be used as a stand-alone helper, or possibly be
assigned as the queue <code class="xref c c-type docutils literal"><span class="pre">prep_rq_fn</span></code> (in which case <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code>
automagically gets a tag assigned). Note that this function
assumes that any type of request can be queued! if this is not
true for your device, you must check the request type before
calling this function.  The request will also be removed from
the request queue, so it’s the drivers responsibility to readd
it if it should need to be restarted for some reason.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_invalidate_tags">
void <code class="descname">blk_queue_invalidate_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_invalidate_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>invalidate all pending tags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Hardware conditions may dictate a need to stop all pending requests.
In this case, we will safely clear the block side of the tag queue and
readd all requests to the request queue in the right order.</div></blockquote>
<dl class="function">
<dt id="c.__blk_queue_free_tags">
void <code class="descname">__blk_queue_free_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_queue_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> will take care of calling this function, if tagging
has been used. So there’s no need to call this directly.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_end_tag">
void <code class="descname">blk_queue_end_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_end_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>end tag operations for a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request that has completed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Typically called when <code class="xref c c-func docutils literal"><span class="pre">end_that_request_first()</span></code> returns <code class="docutils literal"><span class="pre">0</span></code>, meaning
all transfers have been done for a request. It’s important to call
this function before <code class="xref c c-func docutils literal"><span class="pre">end_that_request_last()</span></code>, as that will put the
request back on the free list thus corrupting the internal tag list.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_count_integrity_sg">
int <code class="descname">blk_rq_count_integrity_sg</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_count_integrity_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Count number of integrity scatterlist elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio with integrity metadata attached</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of elements required in a
scatterlist corresponding to the integrity metadata in a bio.</p>
<dl class="function">
<dt id="c.blk_rq_map_integrity_sg">
int <code class="descname">blk_rq_map_integrity_sg</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, struct scatterlist *<em>&nbsp;sglist</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_integrity_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Map integrity metadata into a scatterlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio with integrity metadata attached</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sglist</span></code></dt>
<dd>target scatterlist</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the integrity vectors in request into a
scatterlist.  The scatterlist must be big enough to hold all
elements.  I.e. sized using <a class="reference internal" href="#c.blk_rq_count_integrity_sg" title="blk_rq_count_integrity_sg"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_count_integrity_sg()</span></code></a>.</p>
<dl class="function">
<dt id="c.blk_integrity_compare">
int <code class="descname">blk_integrity_compare</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;gd1</em>, struct gendisk *<em>&nbsp;gd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare integrity profile of two disks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">gd1</span></code></dt>
<dd>Disk to compare</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">gd2</span></code></dt>
<dd>Disk to compare</dd>
</dl>
<p><strong>Description</strong></p>
<p>Meta-devices like DM and MD need to verify that all
sub-devices use the same integrity format before advertising to
upper layers that they can send/receive integrity metadata.  This
function can be used to check whether two gendisk devices have
compatible integrity formats.</p>
<dl class="function">
<dt id="c.blk_integrity_register">
void <code class="descname">blk_integrity_register</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct blk_integrity *<em>&nbsp;template</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a gendisk as being integrity-capable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>struct gendisk pointer to make integrity-aware</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_integrity</span> <span class="pre">*</span> <span class="pre">template</span></code></dt>
<dd>block integrity profile to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device needs to advertise itself as being able to
send/receive integrity metadata it must use this function to register
the capability with the block layer. The template is a blk_integrity
struct with values appropriate for the underlying hardware. See
Documentation/block/data-integrity.txt.</p>
<dl class="function">
<dt id="c.blk_integrity_unregister">
void <code class="descname">blk_integrity_unregister</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister block integrity profile</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk whose integrity profile to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters the integrity capability from
a block device.</p>
<dl class="function">
<dt id="c.blk_trace_ioctl">
int <code class="descname">blk_trace_ioctl</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, unsigned<em>&nbsp;cmd</em>, char __user *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>handle the ioctls associated with tracing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the block device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">cmd</span></code></dt>
<dd>the ioctl cmd</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>the argument data, if any</dd>
</dl>
<dl class="function">
<dt id="c.blk_trace_shutdown">
void <code class="descname">blk_trace_shutdown</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>stop and cleanup trace structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue associated with the device</dd>
</dl>
<dl class="function">
<dt id="c.blk_add_trace_rq">
void <code class="descname">blk_add_trace_rq</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, int<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, u32<em>&nbsp;what</em>, union kernfs_node_id *<em>&nbsp;cgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a request oriented action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the source request</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">error</span></code></dt>
<dd>return status to log</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of completed bytes</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">what</span></code></dt>
<dd>the action</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">kernfs_node_id</span> <span class="pre">*</span> <span class="pre">cgid</span></code></dt>
<dd>the cgroup info</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Records an action against a request. Will log the bio offset + size.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_bio">
void <code class="descname">blk_add_trace_bio</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, u32<em>&nbsp;what</em>, int<em>&nbsp;error</em>, union kernfs_node_id *<em>&nbsp;cgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a bio oriented action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>the source bio</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">what</span></code></dt>
<dd>the action</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">error</span></code></dt>
<dd>error, if any</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">kernfs_node_id</span> <span class="pre">*</span> <span class="pre">cgid</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Records an action against a bio. Will log the bio offset + size.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_bio_remap">
void <code class="descname">blk_add_trace_bio_remap</code><span class="sig-paren">(</span>void *<em>&nbsp;ignore</em>, struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, dev_t<em>&nbsp;dev</em>, sector_t<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a bio-remap operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ignore</span></code></dt>
<dd>trace callback data parameter (not used)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>the source bio</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>target device</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt>
<dd>source sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Device mapper or raid target sometimes need to split a bio because
it spans a stripe (or similar). Add a trace for that action.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_rq_remap">
void <code class="descname">blk_add_trace_rq_remap</code><span class="sig-paren">(</span>void *<em>&nbsp;ignore</em>, struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, dev_t<em>&nbsp;dev</em>, sector_t<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a request-remap operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ignore</span></code></dt>
<dd>trace callback data parameter (not used)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the source request</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>target device</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt>
<dd>source sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Device mapper remaps request to other devices.
Add a trace for that action.</div></blockquote>
<dl class="function">
<dt id="c.blk_mangle_minor">
int <code class="descname">blk_mangle_minor</code><span class="sig-paren">(</span>int<em>&nbsp;minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_mangle_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>scatter minor numbers apart</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">minor</span></code></dt>
<dd>minor number to mangle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scatter consecutively allocated <strong>minor</strong> number apart if MANGLE_DEVT
is enabled.  Mangling twice gives the original value.</p>
<p><strong>Return</strong></p>
<p>Mangled value.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<dl class="function">
<dt id="c.blk_alloc_devt">
int <code class="descname">blk_alloc_devt</code><span class="sig-paren">(</span>struct hd_struct *<em>&nbsp;part</em>, dev_t *<em>&nbsp;devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_alloc_devt" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a dev_t for a partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hd_struct</span> <span class="pre">*</span> <span class="pre">part</span></code></dt>
<dd>partition to allocate dev_t for</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">devt</span></code></dt>
<dd>out parameter for resulting dev_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a dev_t for block device.</p>
<p><strong>Return</strong></p>
<p>0 on success, allocated dev_t is returned in <strong>*devt</strong>.  -errno on
failure.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.blk_free_devt">
void <code class="descname">blk_free_devt</code><span class="sig-paren">(</span>dev_t<em>&nbsp;devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_free_devt" title="Permalink to this definition">¶</a></dt>
<dd><p>free a dev_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>dev_t to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free <strong>devt</strong> which was allocated using <a class="reference internal" href="#c.blk_alloc_devt" title="blk_alloc_devt"><code class="xref c c-func docutils literal"><span class="pre">blk_alloc_devt()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_replace_part_tbl">
void <code class="descname">disk_replace_part_tbl</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct disk_part_tbl *<em>&nbsp;new_ptbl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_replace_part_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>replace disk-&gt;part_tbl in RCU-safe way</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to replace part_tbl for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_tbl</span> <span class="pre">*</span> <span class="pre">new_ptbl</span></code></dt>
<dd>new part_tbl to install</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace disk-&gt;part_tbl with <strong>new_ptbl</strong> in RCU-safe way.  The
original ptbl is freed using RCU callback.</p>
<p>LOCKING:
Matching bd_mutex locked or the caller is the only user of <strong>disk</strong>.</p>
<dl class="function">
<dt id="c.disk_expand_part_tbl">
int <code class="descname">disk_expand_part_tbl</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_expand_part_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>expand disk-&gt;part_tbl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to expand part_tbl for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>expand such that this partno can fit in</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expand disk-&gt;part_tbl such that <strong>partno</strong> can fit in.  disk-&gt;part_tbl
uses RCU to allow unlocked dereferencing for stats and other stuff.</p>
<p>LOCKING:
Matching bd_mutex locked or the caller is the only user of <strong>disk</strong>.
Might sleep.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.disk_block_events">
void <code class="descname">disk_block_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_block_events" title="Permalink to this definition">¶</a></dt>
<dd><p>block and flush disk event checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to block events for</dd>
</dl>
<p><strong>Description</strong></p>
<p>On return from this function, it is guaranteed that event checking
isn’t in progress and won’t happen until unblocked by
<a class="reference internal" href="#c.disk_unblock_events" title="disk_unblock_events"><code class="xref c c-func docutils literal"><span class="pre">disk_unblock_events()</span></code></a>.  Events blocking is counted and the actual
unblocking happens after the matching number of unblocks are done.</p>
<p>Note that this intentionally does not block event checking from
<a class="reference internal" href="#c.disk_clear_events" title="disk_clear_events"><code class="xref c c-func docutils literal"><span class="pre">disk_clear_events()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_unblock_events">
void <code class="descname">disk_unblock_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_unblock_events" title="Permalink to this definition">¶</a></dt>
<dd><p>unblock disk event checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to unblock events for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo <a class="reference internal" href="#c.disk_block_events" title="disk_block_events"><code class="xref c c-func docutils literal"><span class="pre">disk_block_events()</span></code></a>.  When the block count reaches zero, it
starts events polling if configured.</p>
<p><strong>Context</strong></p>
<p>Don’t care.  Safe to call from irq context.</p>
<dl class="function">
<dt id="c.disk_flush_events">
void <code class="descname">disk_flush_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_flush_events" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule immediate event checking and flushing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to check and flush events for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>events to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule immediate event checking on <strong>disk</strong> if not blocked.  Events in
<strong>mask</strong> are scheduled to be cleared from the driver.  Note that this
doesn’t clear the events from <strong>disk</strong>-&gt;ev.</p>
<p><strong>Context</strong></p>
<p>If <strong>mask</strong> is non-zero must be called with bdev-&gt;bd_mutex held.</p>
<dl class="function">
<dt id="c.disk_clear_events">
unsigned int <code class="descname">disk_clear_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_clear_events" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronously check, clear and return pending events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to fetch and clear events from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>mask of events to be fetched and cleared</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disk events are synchronously checked and pending events in <strong>mask</strong>
are cleared and returned.  This ignores the block count.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_get_part">
struct hd_struct * <code class="descname">disk_get_part</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_get_part" title="Permalink to this definition">¶</a></dt>
<dd><p>get partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to look partition from</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>partition number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for partition <strong>partno</strong> from <strong>disk</strong>.  If found, increment
reference count and return it.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<p><strong>Return</strong></p>
<p>Pointer to the found partition on success, NULL if not found.</p>
<dl class="function">
<dt id="c.disk_part_iter_init">
void <code class="descname">disk_part_iter_init</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em>, struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize partition iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iterator to initialize</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to iterate over</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>DISK_PITER_* flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize <strong>piter</strong> so that it iterates over partitions of <strong>disk</strong>.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<dl class="function">
<dt id="c.disk_part_iter_next">
struct hd_struct * <code class="descname">disk_part_iter_next</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>proceed iterator to the next partition and return it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iterator of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>piter</strong> to the next partition and return it.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<dl class="function">
<dt id="c.disk_part_iter_exit">
void <code class="descname">disk_part_iter_exit</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>finish up partition iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iter of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when iteration is over.  Cleans up <strong>piter</strong>.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<dl class="function">
<dt id="c.disk_map_sector_rcu">
struct hd_struct * <code class="descname">disk_map_sector_rcu</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, sector_t<em>&nbsp;sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_map_sector_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>map sector to partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>gendisk of interest</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>sector to map</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out which partition <strong>sector</strong> maps to on <strong>disk</strong>.  This is
primarily used for stats accounting.</p>
<p><strong>Context</strong></p>
<p>RCU read locked.  The returned partition pointer is valid only
while preemption is disabled.</p>
<p><strong>Return</strong></p>
<p>Found partition on success, part0 is returned if no partition matches</p>
<dl class="function">
<dt id="c.register_blkdev">
int <code class="descname">register_blkdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_blkdev" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>the requested major device number [1..255]. If <strong>major</strong> = 0, try to
allocate any unused major number.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the new block device as a zero terminated string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>name</strong> must be unique within the system.</p>
<p>The return value depends on the <strong>major</strong> input parameter:</p>
<blockquote>
<div><ul class="simple">
<li>if a major device number was requested in range [1..255] then the
function returns zero on success, or a negative error code</li>
<li>if any unused major number was requested with <strong>major</strong> = 0 parameter
then the return value is the allocated major number in range
[1..255] or a negative error code otherwise</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.device_add_disk">
void <code class="descname">device_add_disk</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em>, struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_add_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>add partitioning information to kernel list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device for the disk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>per-device partitioning information</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers the partitioning information in <strong>disk</strong>
with the kernel.</p>
<p>FIXME: error handling</p>
<dl class="function">
<dt id="c.get_gendisk">
struct gendisk * <code class="descname">get_gendisk</code><span class="sig-paren">(</span>dev_t<em>&nbsp;devt</em>, int *<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_gendisk" title="Permalink to this definition">¶</a></dt>
<dd><p>get partitioning information for a given device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>device to get partitioning information for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">partno</span></code></dt>
<dd>returned partition index</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets the structure containing partitioning
information for the given device <strong>devt</strong>.</p>
<dl class="function">
<dt id="c.bdget_disk">
struct block_device * <code class="descname">bdget_disk</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdget_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>do <code class="xref c c-func docutils literal"><span class="pre">bdget()</span></code> by gendisk and partition number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>gendisk of interest</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>partition number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find partition <strong>partno</strong> from <strong>disk</strong>, do <code class="xref c c-func docutils literal"><span class="pre">bdget()</span></code> on it.</p>
<p><strong>Context</strong></p>
<p>Don’t care.</p>
<p><strong>Return</strong></p>
<p>Resulting block_device on success, NULL on failure.</p>
</div>
<div class="section" id="char-devices">
<h2>Char devices<a class="headerlink" href="#char-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.register_chrdev_region">
int <code class="descname">register_chrdev_region</code><span class="sig-paren">(</span>dev_t<em>&nbsp;from</em>, unsigned<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>register a range of device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt>
<dd>the first in the desired range of device numbers; must include
the major number.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of consecutive device numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the device or driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return value is zero on success, a negative error code on failure.</p>
<dl class="function">
<dt id="c.alloc_chrdev_region">
int <code class="descname">alloc_chrdev_region</code><span class="sig-paren">(</span>dev_t *<em>&nbsp;dev</em>, unsigned<em>&nbsp;baseminor</em>, unsigned<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>register a range of char device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>output parameter for first assigned number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the requested range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the associated device or driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a range of char device numbers.  The major number will be
chosen dynamically, and returned (along with the first minor number)
in <strong>dev</strong>.  Returns zero or a negative error code.</p>
<dl class="function">
<dt id="c.__register_chrdev">
int <code class="descname">__register_chrdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, unsigned int<em>&nbsp;baseminor</em>, unsigned int<em>&nbsp;count</em>, const char *<em>&nbsp;name</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__register_chrdev" title="Permalink to this definition">¶</a></dt>
<dd><p>create and register a cdev occupying a range of minors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major device number or 0 for dynamic allocation</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the requested range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of this range of devices</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>file operations associated with this devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>major</strong> == 0 this functions will dynamically allocate a major and return
its number.</p>
<p>If <strong>major</strong> &gt; 0 this function will attempt to reserve a device with the given
major number and will return zero on success.</p>
<p>Returns a -ve errno on failure.</p>
<p>The name of this device has nothing to do with the name of the device in
/dev. It only helps to keep track of the different owners of devices. If
your module name has only one type of devices it’s ok to use e.g. the name
of the module here.</p>
<dl class="function">
<dt id="c.unregister_chrdev_region">
void <code class="descname">unregister_chrdev_region</code><span class="sig-paren">(</span>dev_t<em>&nbsp;from</em>, unsigned<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a range of device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt>
<dd>the first in the range of numbers to unregister</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of device numbers to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will unregister a range of <strong>count</strong> device numbers,
starting with <strong>from</strong>.  The caller should normally be the one who
allocated those numbers in the first place…</p>
<dl class="function">
<dt id="c.__unregister_chrdev">
void <code class="descname">__unregister_chrdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, unsigned int<em>&nbsp;baseminor</em>, unsigned int<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__unregister_chrdev" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister and destroy a cdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major device number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers this cdev is occupying</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of this range of devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister and destroy the cdev occupying the region described by
<strong>major</strong>, <strong>baseminor</strong> and <strong>count</strong>.  This function undoes what
<a class="reference internal" href="#c.__register_chrdev" title="__register_chrdev"><code class="xref c c-func docutils literal"><span class="pre">__register_chrdev()</span></code></a> did.</p>
<dl class="function">
<dt id="c.cdev_add">
int <code class="descname">cdev_add</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em>, dev_t<em>&nbsp;dev</em>, unsigned<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a char device to the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure for the device</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>the first device number for which this device is responsible</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of consecutive minor numbers corresponding to this
device</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_add()</span></code></a> adds the device represented by <strong>p</strong> to the system, making it
live immediately.  A negative error code is returned on failure.</p>
<dl class="function">
<dt id="c.cdev_set_parent">
void <code class="descname">cdev_set_parent</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em>, struct kobject *<em>&nbsp;kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>set the parent kobject for a char device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>the kobject to take a reference to</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_set_parent" title="cdev_set_parent"><code class="xref c c-func docutils literal"><span class="pre">cdev_set_parent()</span></code></a> sets a parent kobject which will be referenced
appropriately so the parent is not freed before the cdev. This
should be called before cdev_add.</p>
<dl class="function">
<dt id="c.cdev_device_add">
int <code class="descname">cdev_device_add</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a char device and it’s corresponding struct device, linkink</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_add" title="cdev_device_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_device_add()</span></code></a> adds the char device represented by <strong>cdev</strong> to the system,
just as cdev_add does. It then adds <strong>dev</strong> to the system using device_add
The dev_t for the char device will be taken from the struct device which
needs to be initialized first. This helper function correctly takes a
reference to the parent device so the parent will not get released until
all references to the cdev are released.</p>
<p>This helper uses dev-&gt;devt for the device number. If it is not set
it will not add the cdev and it will be equivalent to device_add.</p>
<p>This function should be used whenever the struct cdev and the
struct device are members of the same structure whose lifetime is
managed by the struct device.</p>
<p><strong>NOTE</strong></p>
<p>Callers must assume that userspace was able to open the cdev and
can call cdev fops callbacks at any time, even if this function fails.</p>
<dl class="function">
<dt id="c.cdev_device_del">
void <code class="descname">cdev_device_del</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_del" title="Permalink to this definition">¶</a></dt>
<dd><p>inverse of cdev_device_add</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_del" title="cdev_device_del"><code class="xref c c-func docutils literal"><span class="pre">cdev_device_del()</span></code></a> is a helper function to call cdev_del and device_del.
It should be used whenever cdev_device_add is used.</p>
<p>If dev-&gt;devt is not set it will not remove the cdev and will be equivalent
to device_del.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that associated sysfs callbacks are not running
or runnable, however any cdevs already open will remain and their fops
will still be callable even after this function returns.</p>
<dl class="function">
<dt id="c.cdev_del">
void <code class="descname">cdev_del</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a cdev from the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure to be removed</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_del" title="cdev_del"><code class="xref c c-func docutils literal"><span class="pre">cdev_del()</span></code></a> removes <strong>p</strong> from the system, possibly freeing the structure
itself.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that cdev device will no longer be able to be
opened, however any cdevs already open will remain and their fops will
still be callable even after cdev_del returns.</p>
<dl class="function">
<dt id="c.cdev_alloc">
struct cdev * <code class="descname">cdev_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a cdev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a cdev structure, or NULL on failure.</p>
<dl class="function">
<dt id="c.cdev_init">
void <code class="descname">cdev_init</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a cdev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the structure to initialize</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>the file_operations for this device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes <strong>cdev</strong>, remembering <strong>fops</strong>, making it ready to add to the
system with <a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_add()</span></code></a>.</p>
</div>
<div class="section" id="clock-framework">
<h2>Clock Framework<a class="headerlink" href="#clock-framework" title="Permalink to this headline">¶</a></h2>
<p>The clock framework defines programming interfaces to support software
management of the system clock tree. This framework is widely used with
System-On-Chip (SOC) platforms to support power management and various
devices which may need custom clock rates. Note that these “clocks”
don’t relate to timekeeping or real time clocks (RTCs), each of which
have separate frameworks. These <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">clk</span></code>
instances may be used to manage for example a 96 MHz signal that is used
to shift bits into and out of peripherals or busses, or otherwise
trigger synchronous state machine transitions in system hardware.</p>
<p>Power management is supported by explicit software clock gating: unused
clocks are disabled, so the system doesn’t waste power changing the
state of transistors that aren’t in active use. On some systems this may
be backed by hardware clock gating, where clocks are gated without being
disabled in software. Sections of chips that are powered but not clocked
may be able to retain their last state. This low power state is often
called a <em>retention mode</em>. This mode still incurs leakage currents,
especially with finer circuit geometries, but for CMOS circuits power is
mostly used by clocked state changes.</p>
<p>Power-aware drivers only enable their clocks when the device they manage
is in active use. Also, system sleep states often differ according to
which clock domains are active: while a “standby” state may allow wakeup
from several active domains, a “mem” (suspend-to-RAM) state may require
a more wholesale shutdown of clocks derived from higher speed PLLs and
oscillators, limiting the number of possible wakeup event sources. A
driver’s suspend method may need to be aware of system-specific clock
constraints on the target sleep state.</p>
<p>Some platforms support programmable clock generators. These can be used
by external chips of various kinds, such as other CPUs, multimedia
codecs, and devices with strict requirements for interface clocking.</p>
<dl class="type">
<dt id="c.clk_notifier">
struct <code class="descname">clk_notifier</code><a class="headerlink" href="#c.clk_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a clk with a notifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct clk_notifier {
  struct clk * clk;
  struct srcu_notifier_head notifier_head;
  struct list_head node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * to associate the notifier with</dd>
<dt><code class="docutils literal"><span class="pre">notifier_head</span></code></dt>
<dd>a blocking_notifier_head for this clk</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>linked list pointers</dd>
</dl>
<p><strong>Description</strong></p>
<p>A list of struct clk_notifier is maintained by the notifier code.
An entry is created whenever code registers the first notifier on a
particular <strong>clk</strong>.  Future notifiers on that <strong>clk</strong> are added to the
<strong>notifier_head</strong>.</p>
<dl class="type">
<dt id="c.clk_notifier_data">
struct <code class="descname">clk_notifier_data</code><a class="headerlink" href="#c.clk_notifier_data" title="Permalink to this definition">¶</a></dt>
<dd><p>rate data to pass to the notifier callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct clk_notifier_data {
  struct clk * clk;
  unsigned long old_rate;
  unsigned long new_rate;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * being changed</dd>
<dt><code class="docutils literal"><span class="pre">old_rate</span></code></dt>
<dd>previous rate of this clk</dd>
<dt><code class="docutils literal"><span class="pre">new_rate</span></code></dt>
<dd>new rate of this clk</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a pre-notifier, old_rate is the clk’s rate before this rate
change, and new_rate is what the rate will be in the future.  For a
post-notifier, old_rate and new_rate are both set to the clk’s
current rate (this was done to optimize the implementation).</p>
<dl class="type">
<dt id="c.clk_bulk_data">
struct <code class="descname">clk_bulk_data</code><a class="headerlink" href="#c.clk_bulk_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data used for bulk clk operations.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct clk_bulk_data {
  const char * id;
  struct clk * clk;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * to store the associated clock</dd>
</dl>
<p><strong>Description</strong></p>
<p>The CLK APIs provide a series of <code class="xref c c-func docutils literal"><span class="pre">clk_bulk_()</span></code> API calls as
a convenience to consumers which require multiple clks.  This
structure is used to manage data for these calls.</p>
<dl class="function">
<dt id="c.clk_notifier_register">
int <code class="descname">clk_notifier_register</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>change notifier callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock whose rate we are interested in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>notifier block with callback function pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>ProTip: debugging across notifier chains can be frustrating. Make sure that
your notifier callback function prints a nice big warning in case of
failure.</p>
<dl class="function">
<dt id="c.clk_notifier_unregister">
int <code class="descname">clk_notifier_unregister</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>change notifier callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock whose rate we are no longer interested in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>notifier block which will be unregistered</dd>
</dl>
<dl class="function">
<dt id="c.clk_get_accuracy">
long <code class="descname">clk_get_accuracy</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the clock accuracy in ppb (parts per billion) for a clock source.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This gets the clock source accuracy expressed in ppb.
A perfect clock returns 0.</p>
<dl class="function">
<dt id="c.clk_set_phase">
int <code class="descname">clk_set_phase</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, int<em>&nbsp;degrees</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the phase shift of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock signal source</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">degrees</span></code></dt>
<dd>number of degrees the signal is shifted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifts the phase of a clock signal by the specified degrees. Returns 0 on
success, -EERROR otherwise.</p>
<dl class="function">
<dt id="c.clk_get_phase">
int <code class="descname">clk_get_phase</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>return the phase shift of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock signal source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the phase shift of a clock node in degrees, otherwise returns
-EERROR.</p>
<dl class="function">
<dt id="c.clk_is_match">
bool <code class="descname">clk_is_match</code><span class="sig-paren">(</span>const struct clk *<em>&nbsp;p</em>, const struct clk *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_is_match" title="Permalink to this definition">¶</a></dt>
<dd><p>check if two clk’s point to the same hardware clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>clk compared against q</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>clk compared against p</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the two struct clk pointers both point to the same hardware
clock node. Put differently, returns true if <strong>p</strong> and <strong>q</strong>
share the same <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">clk_core</span></code> object.</p>
<p>Returns false otherwise. Note that two NULL clks are treated as matching.</p>
<dl class="function">
<dt id="c.clk_prepare">
int <code class="descname">clk_prepare</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the clock source for use.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_unprepare">
void <code class="descname">clk_unprepare</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>undo preparation of a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This undoes a previously prepared clock.  The caller must balance
the number of prepare and unprepare calls.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_get">
struct clk * <code class="descname">clk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a reference to a clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock “consumer”</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_get">
int <code class="descname">clk_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a number of references to clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock “consumer”</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to get several clk consumers in one
operation. If any of the clk cannot be acquired then any clks
that were obtained will be freed before returning to the caller.</p>
<p>Returns 0 if all clocks specified in clk_bulk_data table are obtained
successfully, or valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.
The implementation uses <strong>dev</strong> and <strong>clk_bulk_data</strong>.id to determine the
clock consumer, and thereby the clock producer.
The clock returned is stored in each <strong>clk_bulk_data</strong>.clk field.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.devm_clk_bulk_get">
int <code class="descname">devm_clk_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>managed get multiple clk consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock “consumer”</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to get several clk
consumers in one operation with management, the clks will
automatically be freed when the device is unbound.</p>
<dl class="function">
<dt id="c.devm_clk_get">
struct clk * <code class="descname">devm_clk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to a clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock “consumer”</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>devm_clk_get should not be called from within interrupt context.</p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
<dl class="function">
<dt id="c.devm_get_clk_from_child">
struct clk * <code class="descname">devm_get_clk_from_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct device_node *<em>&nbsp;np</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_clk_from_child" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to a clock producer from child node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock “consumer”</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>pointer to clock consumer node</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function parses the clocks, and uses them to look up the
struct clk from the registered list of clock providers by using
<strong>np</strong> and <strong>con_id</strong></p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
<dl class="function">
<dt id="c.clk_enable">
int <code class="descname">clk_enable</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the clock source should be running.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the clock can not be enabled/disabled, this should return success.</p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_bulk_enable">
int <code class="descname">clk_bulk_enable</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, const struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the set of clks should be running.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_disable">
void <code class="descname">clk_disable</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the clock source is no longer required.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a clock source is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the clock source is shared between
multiple drivers, <a class="reference internal" href="#c.clk_enable" title="clk_enable"><code class="xref c c-func docutils literal"><span class="pre">clk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_disable" title="clk_disable"><code class="xref c c-func docutils literal"><span class="pre">clk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
<dl class="function">
<dt id="c.clk_bulk_disable">
void <code class="descname">clk_bulk_disable</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, const struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the set of clks is no longer required.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a set of clks is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the set of clks is shared between
multiple drivers, <a class="reference internal" href="#c.clk_bulk_enable" title="clk_bulk_enable"><code class="xref c c-func docutils literal"><span class="pre">clk_bulk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_bulk_disable" title="clk_bulk_disable"><code class="xref c c-func docutils literal"><span class="pre">clk_bulk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
<dl class="function">
<dt id="c.clk_get_rate">
unsigned long <code class="descname">clk_get_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the current clock rate (in Hz) for a clock source. This is only valid once the clock source has been enabled.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<dl class="function">
<dt id="c.clk_put">
void <code class="descname">clk_put</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p>clk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_put">
void <code class="descname">clk_bulk_put</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_bulk_enable calls made on this
clock source are balanced by clk_bulk_disable calls prior to calling
this function.</p>
<p>clk_bulk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.devm_clk_put">
void <code class="descname">devm_clk_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>“free” a managed clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device used to acquire the clock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source acquired with <a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal"><span class="pre">devm_clk_get()</span></code></a></dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p>clk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_round_rate">
long <code class="descname">clk_round_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_round_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust a rate to the exact rate a clock can provide</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired clock rate in Hz</dd>
</dl>
<p><strong>Description</strong></p>
<p>This answers the question “if I were to pass <strong>rate</strong> to <a class="reference internal" href="#c.clk_set_rate" title="clk_set_rate"><code class="xref c c-func docutils literal"><span class="pre">clk_set_rate()</span></code></a>,
what clock rate would I end up with?” without changing the hardware
in any way.  In other words:</p>
<blockquote>
<div>rate = clk_round_rate(clk, r);</div></blockquote>
<p>and:</p>
<blockquote>
<div>clk_set_rate(clk, r);
rate = clk_get_rate(clk);</div></blockquote>
<p>are equivalent except the former does not modify the clock hardware
in any way.</p>
<p>Returns rounded clock rate in Hz, or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_rate">
int <code class="descname">clk_set_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set the clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired clock rate in Hz</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_has_parent">
bool <code class="descname">clk_has_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct clk *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_has_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a clock is a possible parent for another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers that need to check that a clock can be
the parent of another without actually changing the parent.</p>
<p>Returns true if <strong>parent</strong> is a possible parent for <strong>clk</strong>, false otherwise.</p>
<dl class="function">
<dt id="c.clk_set_rate_range">
int <code class="descname">clk_set_rate_range</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;min</em>, unsigned long<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate_range" title="Permalink to this definition">¶</a></dt>
<dd><p>set a rate range for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt>
<dd>desired minimum clock rate in Hz, inclusive</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt>
<dd>desired maximum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_min_rate">
int <code class="descname">clk_set_min_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_min_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set a minimum clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired minimum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_max_rate">
int <code class="descname">clk_set_max_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_max_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set a maximum clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired maximum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_parent">
int <code class="descname">clk_set_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct clk *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>set the parent clock source for this clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_get_parent">
struct clk * <code class="descname">clk_get_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parent clock source for this clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns struct clk corresponding to parent clock source, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.</p>
<dl class="function">
<dt id="c.clk_get_sys">
struct clk * <code class="descname">clk_get_sys</code><span class="sig-paren">(</span>const char *<em>&nbsp;dev_id</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_sys" title="Permalink to this definition">¶</a></dt>
<dd><p>get a clock based upon the device name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>device name</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>connection ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev_id</strong> and <strong>con_id</strong> to determine the clock consumer, and
thereby the clock producer. In contrast to <a class="reference internal" href="#c.clk_get" title="clk_get"><code class="xref c c-func docutils literal"><span class="pre">clk_get()</span></code></a> this function
takes the device name instead of the device itself for identification.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get_sys should not be called from within interrupt context.</p>
</div>
<div class="section" id="synchronization-primitives">
<h2>Synchronization Primitives<a class="headerlink" href="#synchronization-primitives" title="Permalink to this headline">¶</a></h2>
<div class="section" id="read-copy-update-rcu">
<h3>Read-Copy Update (RCU)<a class="headerlink" href="#read-copy-update-rcu" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.RCU_NONIDLE">
<code class="descname">RCU_NONIDLE</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_NONIDLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate idle-loop code that needs RCU readers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">a</span></code></dt>
<dd>Code that RCU needs to pay attention to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>RCU, RCU-bh, and RCU-sched read-side critical sections are forbidden
in the inner idle loop, that is, between the <a class="reference internal" href="#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_enter()</span></code></a> and
the <a class="reference internal" href="#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_exit()</span></code></a> – RCU will happily ignore any such read-side
critical sections.  However, things like powertop need tracepoints
in the inner idle loop.</p>
<p>This macro provides the way out:  RCU_NONIDLE(<code class="xref c c-func docutils literal"><span class="pre">do_something_with_RCU()</span></code>)
will tell RCU that it needs to pay attention, invoke its argument
(in this example, calling the <code class="xref c c-func docutils literal"><span class="pre">do_something_with_RCU()</span></code> function),
and then tell RCU to go back to ignoring this CPU.  It is permissible
to nest <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal"><span class="pre">RCU_NONIDLE()</span></code></a> wrappers, but not indefinitely (but the limit is
on the order of a million or so, even on 32-bit systems).  It is
not legal to block within <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal"><span class="pre">RCU_NONIDLE()</span></code></a>, nor is it permissible to
transfer control either into or out of <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal"><span class="pre">RCU_NONIDLE()</span></code></a>’s statement.</p>
<dl class="function">
<dt id="c.cond_resched_rcu_qs">
<code class="descname">cond_resched_rcu_qs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_resched_rcu_qs" title="Permalink to this definition">¶</a></dt>
<dd><p>Report potential quiescent states to RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro resembles <code class="xref c c-func docutils literal"><span class="pre">cond_resched()</span></code>, except that it is defined to
report potential quiescent states to RCU-tasks even if the <code class="xref c c-func docutils literal"><span class="pre">cond_resched()</span></code>
machinery were to be shut off, as some advocate for PREEMPT kernels.</p>
<dl class="function">
<dt id="c.RCU_LOCKDEP_WARN">
<code class="descname">RCU_LOCKDEP_WARN</code><span class="sig-paren">(</span><em>c</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_LOCKDEP_WARN" title="Permalink to this definition">¶</a></dt>
<dd><p>emit lockdep splat if specified condition is met</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>condition to check</dd>
<dt><code class="docutils literal"><span class="pre">s</span></code></dt>
<dd>informative message</dd>
</dl>
<dl class="function">
<dt id="c.RCU_INITIALIZER">
<code class="descname">RCU_INITIALIZER</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd><p>statically initialize an RCU-protected global variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">v</span></code></dt>
<dd>The value to statically initialize with.</dd>
</dl>
<dl class="function">
<dt id="c.rcu_assign_pointer">
<code class="descname">rcu_assign_pointer</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_assign_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>assign to RCU-protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>pointer to assign to</dd>
<dt><code class="docutils literal"><span class="pre">v</span></code></dt>
<dd>value to assign (publish)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assigns the specified value to the specified RCU-protected
pointer, ensuring that any concurrent RCU readers will see
any prior initialization.</p>
<p>Inserts memory barriers on architectures that require them
(which is most of them), and also prevents the compiler from
reordering the code that initializes the structure after the pointer
assignment.  More importantly, this call documents which pointers
will be dereferenced by RCU read-side code.</p>
<p>In some special cases, you may use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> instead
of <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a>.  <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> is a bit faster due
to the fact that it does not constrain either the CPU or the compiler.
That said, using <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> when you should have used
<a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> is a very bad thing that results in
impossible-to-diagnose memory corruption.  So please be careful.
See the <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> comment header for details.</p>
<p>Note that <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> evaluates each of its arguments only
once, appearances notwithstanding.  One of the “extra” evaluations
is in <code class="xref c c-func docutils literal"><span class="pre">typeof()</span></code> and the other visible only to sparse (__CHECKER__),
neither of which actually execute the argument.  As with most cpp
macros, this execute-arguments-only-once property is important, so
please be careful when making changes to <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> and the
other macros that it invokes.</p>
<dl class="function">
<dt id="c.rcu_swap_protected">
<code class="descname">rcu_swap_protected</code><span class="sig-paren">(</span><em>rcu_ptr</em>, <em>ptr</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_swap_protected" title="Permalink to this definition">¶</a></dt>
<dd><p>swap an RCU and a regular pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">rcu_ptr</span></code></dt>
<dd>RCU pointer</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>regular pointer</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>the conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform swap(<strong>rcu_ptr</strong>, <strong>ptr</strong>) where <strong>rcu_ptr</strong> is an RCU-annotated pointer and
<strong>c</strong> is the argument that is passed to the <a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_protected()</span></code></a> call
used to read that pointer.</p>
<dl class="function">
<dt id="c.rcu_access_pointer">
<code class="descname">rcu_access_pointer</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_access_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU pointer with no dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the value of the specified RCU-protected pointer, but omit the
<code class="xref c c-func docutils literal"><span class="pre">smp_read_barrier_depends()</span></code> and keep the <code class="xref c c-func docutils literal"><span class="pre">READ_ONCE()</span></code>.  This is useful
when the value of this pointer is accessed, but the pointer is not
dereferenced, for example, when testing an RCU-protected pointer against
NULL.  Although <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_access_pointer()</span></code></a> may also be used in cases where
update-side locks prevent the value of the pointer from changing, you
should instead use <a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_protected()</span></code></a> for this use case.</p>
<p>It is also permissible to use <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_access_pointer()</span></code></a> when read-side
access to the pointer was removed at least one grace period ago, as
is the case in the context of the RCU callback that is freeing up
the data, or after a <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> returns.  This can be useful
when tearing down multi-linked structures after a grace period
has elapsed.</p>
<dl class="function">
<dt id="c.rcu_dereference_check">
<code class="descname">rcu_dereference_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>The conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do an <a class="reference internal" href="#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference()</span></code></a>, but check that the conditions under which the
dereference will take place are correct.  Typically the conditions
indicate the various locking conditions that should be held at that
point.  The check should return true if the conditions are satisfied.
An implicit check for being in an RCU read-side critical section
(<a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>) is included.</p>
<p>For example:</p>
<blockquote>
<div>bar = rcu_dereference_check(foo-&gt;bar, lockdep_is_held(<code class="xref c c-type docutils literal"><span class="pre">foo-&gt;lock</span></code>));</div></blockquote>
<p>could be used to indicate to lockdep that foo-&gt;bar may only be dereferenced
if either <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> is held, or that the lock required to replace
the bar struct at foo-&gt;bar is held.</p>
<p>Note that the list of conditions may also include indications of when a lock
need not be held, for example during initialisation or destruction of the
target struct:</p>
<blockquote>
<div><dl class="docutils">
<dt>bar = rcu_dereference_check(foo-&gt;bar, lockdep_is_held(<code class="xref c c-type docutils literal"><span class="pre">foo-&gt;lock</span></code>) ||</dt>
<dd>atomic_read(<code class="xref c c-type docutils literal"><span class="pre">foo-&gt;usage</span></code>) == 0);</dd>
</dl>
</div></blockquote>
<p>Inserts memory barriers on architectures that require them
(currently only the Alpha), prevents the compiler from refetching
(and from merging fetches), and, more importantly, documents exactly
which pointers are protected by RCU and checks that the pointer is
annotated as __rcu.</p>
<dl class="function">
<dt id="c.rcu_dereference_bh_check">
<code class="descname">rcu_dereference_bh_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_bh_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference_bh with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>The conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the RCU-bh counterpart to <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_sched_check">
<code class="descname">rcu_dereference_sched_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_sched_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference_sched with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>The conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the RCU-sched counterpart to <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_protected">
<code class="descname">rcu_dereference_protected</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_protected" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU pointer when updates prevented</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>The conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the value of the specified RCU-protected pointer, but omit
both the <code class="xref c c-func docutils literal"><span class="pre">smp_read_barrier_depends()</span></code> and the <code class="xref c c-func docutils literal"><span class="pre">READ_ONCE()</span></code>.  This
is useful in cases where update-side locks prevent the value of the
pointer from changing.  Please note that this primitive does <em>not</em>
prevent the compiler from repeating this reference or combining it
with other references, so it should not be used without protection
of appropriate locks.</p>
<p>This function is only for update-side use.  Using this function
when protected only by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> will result in infrequent
but very ugly failures.</p>
<dl class="function">
<dt id="c.rcu_dereference">
<code class="descname">rcu_dereference</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simple wrapper around <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_bh">
<code class="descname">rcu_dereference_bh</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch an RCU-bh-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.</p>
<dl class="function">
<dt id="c.rcu_dereference_sched">
<code class="descname">rcu_dereference_sched</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU-sched-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.</p>
<dl class="function">
<dt id="c.rcu_pointer_handoff">
<code class="descname">rcu_pointer_handoff</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_pointer_handoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hand off a pointer from RCU to other mechanism</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to hand off</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is simply an identity function, but it documents where a pointer
is handed off from RCU to some other synchronization mechanism, for
example, reference counting or locking.  In C11, it would map to
<code class="xref c c-func docutils literal"><span class="pre">kill_dependency()</span></code>.  It could be used as follows:
``</p>
<blockquote>
<div><p><a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>;
p = rcu_dereference(gp);
long_lived = is_long_lived(p);
if (long_lived) {</p>
<blockquote>
<div><dl class="docutils">
<dt>if (!atomic_inc_not_zero(p-&gt;refcnt))</dt>
<dd>long_lived = false;</dd>
<dt>else</dt>
<dd>p = rcu_pointer_handoff(p);</dd>
</dl>
</div></blockquote>
<p>}
<a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>;</p>
</div></blockquote>
<p><a href="#id3"><span class="problematic" id="id4">``</span></a></p>
<dl class="function">
<dt id="c.rcu_read_lock">
void <code class="descname">rcu_read_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of an RCU read-side critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is invoked on one CPU while other CPUs
are within RCU read-side critical sections, then the
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is guaranteed to block until after all the other
CPUs exit their critical sections.  Similarly, if <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> is invoked
on one CPU while other CPUs are within RCU read-side critical
sections, invocation of the corresponding RCU callback is deferred
until after the all the other CPUs exit their critical sections.</p>
<p>Note, however, that RCU callbacks are permitted to run concurrently
with new RCU read-side critical sections.  One way that this can happen
is via the following sequence of events: (1) CPU 0 enters an RCU
read-side critical section, (2) CPU 1 invokes <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> to register
an RCU callback, (3) CPU 0 exits the RCU read-side critical section,
(4) CPU 2 enters a RCU read-side critical section, (5) the RCU
callback is invoked.  This is legal, because the RCU read-side critical
section that was running concurrently with the <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> (and which
therefore might be referencing something that the corresponding RCU
callback would free up) has completed before the corresponding
RCU callback is invoked.</p>
<p>RCU read-side critical sections may be nested.  Any deferred actions
will be deferred until the outermost RCU read-side critical section
completes.</p>
<p>You can avoid reading and understanding the next paragraph by
following this rule: don’t put anything in an <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> RCU
read-side critical section that would block in a !PREEMPT kernel.
But if you want the full story, read on!</p>
<p>In non-preemptible RCU implementations (TREE_RCU and TINY_RCU),
it is illegal to block while in an RCU read-side critical section.
In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPT
kernel builds, RCU read-side critical sections may be preempted,
but explicit blocking is illegal.  Finally, in preemptible RCU
implementations in real-time (with -rt patchset) kernel builds, RCU
read-side critical sections may be preempted and they may also block, but
only when acquiring spinlocks that are subject to priority inheritance.</p>
<dl class="function">
<dt id="c.rcu_read_unlock">
void <code class="descname">rcu_read_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>marks the end of an RCU read-side critical section.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>In most situations, <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> is immune from deadlock.
However, in kernels built with CONFIG_RCU_BOOST, <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>
is responsible for deboosting, which it does via <code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code>.
Unfortunately, this function acquires the scheduler’s runqueue and
priority-inheritance spinlocks.  This means that deadlock could result
if the caller of <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> already holds one of these locks or
any lock that is ever acquired while holding them; or any lock which
can be taken from interrupt context because <code class="xref c c-func docutils literal"><span class="pre">rcu_boost()</span></code>-&gt;:c:func:<cite>rt_mutex_lock()</cite>
does not disable irqs while taking -&gt;wait_lock.</p>
<p>That said, RCU readers are never priority boosted unless they were
preempted.  Therefore, one way to avoid deadlock is to make sure
that preemption never happens within any RCU read-side critical
section whose outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> is called with one of
<code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code>’s locks held.  Such preemption can be avoided in
a number of ways, for example, by invoking <code class="xref c c-func docutils literal"><span class="pre">preempt_disable()</span></code> before
critical section’s outermost <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<p>Given that the set of locks acquired by <code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code> might change
at any time, a somewhat more future-proofed approach is to make sure
that that preemption never happens within any RCU read-side critical
section whose outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> is called with irqs disabled.
This approach relies on the fact that <code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code> currently only
acquires irq-disabled locks.</p>
<p>The second of these two approaches is best in most situations,
however, the first approach can also be useful, at least to those
developers willing to keep abreast of the set of locks acquired by
<code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code>.</p>
<p>See <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> for more information.</p>
<dl class="function">
<dt id="c.rcu_read_lock_bh">
void <code class="descname">rcu_read_lock_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of an RCU-bh critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent of <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>, but to be used when updates
are being done using <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> or <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_bh" title="synchronize_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_bh()</span></code></a>. Since
both <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> and <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_bh" title="synchronize_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_bh()</span></code></a> consider completion of a
softirq handler to be a quiescent state, a process in RCU read-side
critical section must be protected by disabling softirqs. Read-side
critical sections in interrupt context can use just <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>,
though this should at least be commented to avoid confusing people
reading the code.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a> and the matching <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code>
must occur in the same context, for example, it is illegal to invoke
<code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code> from one task if the matching <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a>
was invoked from some other task.</p>
<dl class="function">
<dt id="c.rcu_read_lock_sched">
void <code class="descname">rcu_read_lock_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of a RCU-sched critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent of <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>, but to be used when updates
are being done using <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a> or <code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_sched()</span></code>.
Read-side critical sections can also be introduced by anything that
disables preemption, including <code class="xref c c-func docutils literal"><span class="pre">local_irq_disable()</span></code> and friends.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> and the matching <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code>
must occur in the same context, for example, it is illegal to invoke
<code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code> from process context if the matching
<a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> was invoked from an NMI handler.</p>
<dl class="function">
<dt id="c.RCU_INIT_POINTER">
<code class="descname">RCU_INIT_POINTER</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_INIT_POINTER" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an RCU protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to be initialized.</dd>
<dt><code class="docutils literal"><span class="pre">v</span></code></dt>
<dd>The value to initialized the pointer to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an RCU-protected pointer in special cases where readers
do not need ordering constraints on the CPU or the compiler.  These
special cases are:</p>
<ol class="arabic simple">
<li>This use of <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> is NULLing out the pointer <em>or</em></li>
<li>The caller has taken whatever steps are required to prevent
RCU readers from concurrently accessing this pointer <em>or</em></li>
<li>The referenced data structure has already been exposed to
readers either at compile time or via <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> <em>and</em><ol class="loweralpha">
<li>You have not made <em>any</em> reader-visible changes to
this structure since then <em>or</em></li>
<li>It is OK for readers accessing this structure from its
new location to see the old state of the structure.  (For
example, the changes were to statistical counters or to
other state where exact synchronization is not required.)</li>
</ol>
</li>
</ol>
<p>Failure to follow these rules governing use of <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> will
result in impossible-to-diagnose memory corruption.  As in the structures
will look OK in crash dumps, but any concurrent RCU readers might
see pre-initialized values of the referenced data structure.  So
please be very careful how you use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a>!!!</p>
<p>If you are creating an RCU-protected linked structure that is accessed
by a single external-to-structure RCU-protected pointer, then you may
use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> to initialize the internal RCU-protected
pointers, but you must use <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> to initialize the
external-to-structure pointer <em>after</em> you have completely initialized
the reader-accessible portions of the linked structure.</p>
<p>Note that unlike <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a>, <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> provides no
ordering guarantees for either the CPU or the compiler.</p>
<dl class="function">
<dt id="c.RCU_POINTER_INITIALIZER">
<code class="descname">RCU_POINTER_INITIALIZER</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_POINTER_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd><p>statically initialize an RCU protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to be initialized.</dd>
<dt><code class="docutils literal"><span class="pre">v</span></code></dt>
<dd>The value to initialized the pointer to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>GCC-style initialization for an RCU-protected pointer in a structure field.</p>
<dl class="function">
<dt id="c.kfree_rcu">
<code class="descname">kfree_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>rcu_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>kfree an object after a grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>pointer to kfree</dd>
<dt><code class="docutils literal"><span class="pre">rcu_head</span></code></dt>
<dd>the name of the struct rcu_head within the type of <strong>ptr</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many rcu callbacks functions just call <a class="reference internal" href="#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a> on the base structure.
These functions are trivial, but their size adds up, and furthermore
when they are used in a kernel module, that module must invoke the
high-latency <a class="reference internal" href="../driver-api/basics.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal"><span class="pre">rcu_barrier()</span></code></a> function at module-unload time.</p>
<p>The <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal"><span class="pre">kfree_rcu()</span></code></a> function handles this issue.  Rather than encoding a
function address in the embedded rcu_head structure, <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal"><span class="pre">kfree_rcu()</span></code></a> instead
encodes the offset of the rcu_head structure within the base structure.
Because the functions are not allowed in the low-order 4096 bytes of
kernel virtual memory, offsets up to 4095 bytes can be accommodated.
If the offset is larger than 4095 bytes, a compile-time error will
be generated in <code class="xref c c-func docutils literal"><span class="pre">__kfree_rcu()</span></code>.  If this error is triggered, you can
either fall back to use of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> or rearrange the structure to
position the rcu_head structure into the first 4096 bytes.</p>
<p>Note that the allowable offset might decrease in the future, for example,
to allow something like <code class="xref c c-func docutils literal"><span class="pre">kmem_cache_free_rcu()</span></code>.</p>
<p>The BUILD_BUG_ON check must not involve any function calls, hence the
checks are done in macros here.</p>
<dl class="function">
<dt id="c.synchronize_rcu_mult">
<code class="descname">synchronize_rcu_mult</code><span class="sig-paren">(</span><em>…</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait concurrently for multiple grace periods</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>List of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> functions for the flavors to wait on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro waits concurrently for multiple flavors of RCU grace periods.
For example, synchronize_rcu_mult(call_rcu, call_rcu_bh) would wait
on concurrent RCU and RCU-bh grace periods.  Waiting on a give SRCU
domain requires you to write a wrapper function for that SRCU domain’s
<a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal"><span class="pre">call_srcu()</span></code></a> function, supplying the corresponding srcu_struct.</p>
<p>If Tiny RCU, tell <code class="xref c c-func docutils literal"><span class="pre">_wait_rcu_gp()</span></code> not to bother waiting for RCU
or RCU-bh, given that anywhere <a class="reference internal" href="#c.synchronize_rcu_mult" title="synchronize_rcu_mult"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_mult()</span></code></a> can be called
is automatically a grace period.</p>
<dl class="function">
<dt id="c.synchronize_rcu_bh_expedited">
void <code class="descname">synchronize_rcu_bh_expedited</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_bh_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force RCU-bh grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an RCU-bh grace period to elapse, but use a “big hammer”
approach to force the grace period to end quickly.  This consumes
significant time on all CPUs and is unfriendly to real-time workloads,
so is thus not recommended for any sort of common-case code.  In fact,
if you are using <a class="reference internal" href="#c.synchronize_rcu_bh_expedited" title="synchronize_rcu_bh_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_bh_expedited()</span></code></a> in a loop, please
restructure your code to batch your updates, and then use a single
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_bh" title="synchronize_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_bh()</span></code></a> instead.</p>
<p>Note that it is illegal to call this function while holding any lock
that is acquired by a CPU-hotplug notifier.  And yes, it is also illegal
to call this function from a CPU-hotplug notifier.  Failing to observe
these restriction will result in deadlock.</p>
<dl class="function">
<dt id="c.rcu_idle_enter">
void <code class="descname">rcu_idle_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_idle_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is entering idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter idle mode, in other words, -leave- the mode in which RCU
read-side critical sections can occur.  (Though RCU read-side
critical sections can occur in irq handlers in idle, a possibility
handled by <code class="xref c c-func docutils literal"><span class="pre">irq_enter()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">irq_exit()</span></code>.)</p>
<p>We crowbar the -&gt;dynticks_nesting field to zero to allow for
the possibility of usermode upcalls having messed up our count
of interrupt nesting level during the prior busy period.</p>
<dl class="function">
<dt id="c.rcu_user_enter">
void <code class="descname">rcu_user_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_user_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that we are resuming userspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter RCU idle mode right before resuming userspace.  No use of RCU
is permitted between this call and <a class="reference internal" href="#c.rcu_user_exit" title="rcu_user_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_user_exit()</span></code></a>. This way the
CPU doesn’t need to maintain the tick for RCU maintenance purposes
when the CPU runs in userspace.</p>
<dl class="function">
<dt id="c.rcu_irq_exit">
void <code class="descname">rcu_irq_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_irq_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is exiting irq towards idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit from an interrupt handler, which might possibly result in entering
idle mode, in other words, leaving the mode in which read-side critical
sections can occur.  The caller must have disabled interrupts.</p>
<p>This code assumes that the idle loop never does anything that might
result in unbalanced calls to <code class="xref c c-func docutils literal"><span class="pre">irq_enter()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">irq_exit()</span></code>.  If your
architecture violates this assumption, RCU will give you what you
deserve, good and hard.  But very infrequently and irreproducibly.</p>
<p>Use things like work queues to work around this limitation.</p>
<p>You have been warned.</p>
<dl class="function">
<dt id="c.rcu_idle_exit">
void <code class="descname">rcu_idle_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_idle_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is leaving idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit idle mode, in other words, -enter- the mode in which RCU
read-side critical sections can occur.</p>
<p>We crowbar the -&gt;dynticks_nesting field to DYNTICK_TASK_NEST to
allow for the possibility of usermode upcalls messing up our count
of interrupt nesting level during the busy period that is just
now starting.</p>
<dl class="function">
<dt id="c.rcu_user_exit">
void <code class="descname">rcu_user_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_user_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that we are exiting userspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit RCU idle mode while entering the kernel because it can
run a RCU read side critical section anytime.</p>
<dl class="function">
<dt id="c.rcu_irq_enter">
void <code class="descname">rcu_irq_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_irq_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is entering irq away from idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter an interrupt handler, which might possibly result in exiting
idle mode, in other words, entering the mode in which read-side critical
sections can occur.  The caller must have disabled interrupts.</p>
<p>Note that the Linux kernel is fully capable of entering an interrupt
handler that it never exits, for example when doing upcalls to
user mode!  This code assumes that the idle loop never does upcalls to
user mode.  If your architecture does do upcalls from the idle loop (or
does anything else that results in unbalanced calls to the <code class="xref c c-func docutils literal"><span class="pre">irq_enter()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">irq_exit()</span></code> functions), RCU will give you what you deserve, good
and hard.  But very infrequently and irreproducibly.</p>
<p>Use things like work queues to work around this limitation.</p>
<p>You have been warned.</p>
<dl class="function">
<dt id="c.rcu_nmi_enter">
void <code class="descname">rcu_nmi_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_nmi_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU of entry to NMI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the CPU was idle from RCU’s viewpoint, update rdtp-&gt;dynticks and
rdtp-&gt;dynticks_nmi_nesting to let the RCU grace-period handling know
that the CPU is active.  This implementation permits nested NMIs, as
long as the nesting level does not overflow an int.  (You will probably
run out of stack space first.)</p>
<dl class="function">
<dt id="c.rcu_nmi_exit">
void <code class="descname">rcu_nmi_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_nmi_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU of exit from NMI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If we are returning from the outermost NMI handler that interrupted an
RCU-idle period, update rdtp-&gt;dynticks and rdtp-&gt;dynticks_nmi_nesting
to let the RCU grace-period handling know that the CPU is back to
being RCU-idle.</p>
<dl class="function">
<dt id="c.rcu_is_watching">
bool notrace <code class="descname">rcu_is_watching</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_watching" title="Permalink to this definition">¶</a></dt>
<dd><p>see if RCU thinks that the current CPU is idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if RCU is watching the running CPU, which means that this
CPU can safely enter RCU read-side critical sections.  In other words,
if the current CPU is in its idle loop and is neither in an interrupt
or NMI handler, return true.</p>
<dl class="function">
<dt id="c.rcu_is_cpu_rrupt_from_idle">
int <code class="descname">rcu_is_cpu_rrupt_from_idle</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_cpu_rrupt_from_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>see if idle or immediately interrupted from idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the current CPU is idle or running at a first-level (not nested)
interrupt from idle, return true.  The caller must have at least
disabled preemption.</p>
<dl class="function">
<dt id="c.rcu_cpu_stall_reset">
void <code class="descname">rcu_cpu_stall_reset</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_cpu_stall_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>prevent further stall warnings in current grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the stall-warning timeout way off into the future, thus preventing
any RCU CPU stall-warning messages from appearing in the current set of
RCU grace periods.</p>
<p>The caller must disable hard irqs.</p>
<dl class="function">
<dt id="c.call_rcu_sched">
void <code class="descname">call_rcu_sched</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation after sched grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a> assumes
that the read-side critical sections end on enabling of preemption
or on voluntary preemption.
RCU read-side critical sections are delimited by:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code>, OR</li>
<li>anything that disables preemption.</li>
</ul>
<blockquote>
<div>These may be nested.</div></blockquote>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.call_rcu_bh">
void <code class="descname">call_rcu_bh</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation after a quicker grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> assumes
that the read-side critical sections end on completion of a softirq
handler. This means that read-side critical sections in process
context must not be interrupted by softirqs. This interface is to be
used when most of the read-side critical sections are in softirq context.
RCU read-side critical sections are delimited by:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and  <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>, if in interrupt context, OR</li>
<li><a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code>, if in process context.</li>
</ul>
<p>These may be nested.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.synchronize_sched">
void <code class="descname">synchronize_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu-sched grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu-sched
grace period has elapsed, in other words after all currently executing
rcu-sched read-side critical sections have completed.   These read-side
critical sections are delimited by <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code>, and may be nested.  Note that <code class="xref c c-func docutils literal"><span class="pre">preempt_disable()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">local_irq_disable()</span></code>, and so on may be used in place of
<a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a>.</p>
<p>This means that all preempt_disable code sequences, including NMI and
non-threaded hardware-interrupt handlers, in progress on entry will
have completed before this primitive returns.  However, this does not
guarantee that softirq handlers will have completed, since in some
kernels, these handlers can run in process context, and can block.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-sched read-side critical section whose beginning
preceded the call to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>.  In addition, each CPU having
an RCU read-side critical section that extends beyond the return from
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> is guaranteed to have executed a full memory barrier
after the beginning of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> and before the beginning of
that RCU read-side critical section.  Note that these guarantees include
CPUs that are offline, idle, or executing in user mode, as well as CPUs
that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> – even if CPU A and CPU B are the same CPU (but
again only if the system has more than one CPU).</p>
<dl class="function">
<dt id="c.synchronize_rcu_bh">
void <code class="descname">synchronize_rcu_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu_bh grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu_bh grace
period has elapsed, in other words after all currently executing rcu_bh
read-side critical sections have completed.  RCU read-side critical
sections are delimited by <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code>,
and may be nested.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> for more detailed information
on memory ordering guarantees.</p>
<dl class="function">
<dt id="c.get_state_synchronize_rcu">
unsigned long <code class="descname">get_state_synchronize_rcu</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Snapshot current RCU state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="../driver-api/basics.html#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">cond_synchronize_rcu()</span></code></a>
to determine whether or not a full grace period has elapsed in the
meantime.</p>
<dl class="function">
<dt id="c.cond_synchronize_rcu">
void <code class="descname">cond_synchronize_rcu</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;oldstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally wait for an RCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt>
<dd>return value from earlier call to <a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_rcu()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the earlier call to
<a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_rcu()</span></code></a>, just return.  Otherwise, invoke
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.</p>
<dl class="function">
<dt id="c.get_state_synchronize_sched">
unsigned long <code class="descname">get_state_synchronize_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Snapshot current RCU-sched state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="../driver-api/basics.html#c.cond_synchronize_sched" title="cond_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">cond_synchronize_sched()</span></code></a>
to determine whether or not a full grace period has elapsed in the
meantime.</p>
<dl class="function">
<dt id="c.cond_synchronize_sched">
void <code class="descname">cond_synchronize_sched</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;oldstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally wait for an RCU-sched grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt>
<dd>return value from earlier call to <a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_sched" title="get_state_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_sched()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU-sched grace period has elapsed since the earlier call to
<a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_sched" title="get_state_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_sched()</span></code></a>, just return.  Otherwise, invoke
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.</p>
<dl class="function">
<dt id="c.rcu_barrier_bh">
void <code class="descname">rcu_barrier_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.rcu_barrier_sched">
void <code class="descname">rcu_barrier_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a> callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.call_rcu">
void <code class="descname">call_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU callback for invocation after a grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all pre-existing RCU read-side
critical sections have completed.  However, the callback function
might well execute concurrently with RCU read-side critical sections
that started after <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> was invoked.  RCU read-side critical
sections are delimited by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>,
and may be nested.</p>
<p>Note that all CPUs must agree that the grace period extended beyond
all pre-existing RCU read-side critical section.  On systems with more
than one CPU, this means that when “<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>” is invoked, each CPU is
guaranteed to have executed a full memory barrier since the end of its
last RCU read-side critical section whose beginning preceded the call
to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a>.  It also means that each CPU executing an RCU read-side
critical section that continues beyond the start of “<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>” must have
executed a memory barrier after the <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> but before the beginning
of that RCU read-side critical section.  Note that these guarantees
include CPUs that are offline, idle, or executing in user mode, as
well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> and CPU B invoked the
resulting RCU callback function “<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>”, then both CPU A and CPU B are
guaranteed to execute a full memory barrier during the time interval
between the call to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> and the invocation of “<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>” – even
if CPU A and CPU B are the same CPU (but again only if the system has
more than one CPU).</p>
<dl class="function">
<dt id="c.synchronize_rcu">
void <code class="descname">synchronize_rcu</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until a grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full grace
period has elapsed, in other words after all currently executing RCU
read-side critical sections have completed.  Note, however, that
upon return from <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, the caller might well be executing
concurrently with new RCU read-side critical sections that began while
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> was waiting.  RCU read-side critical sections are
delimited by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>, and may be nested.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> for more detailed
information on memory-ordering guarantees.  However, please note
that -only- the memory-ordering guarantees apply.  For example,
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is -not- guaranteed to wait on things like code
protected by <code class="xref c c-func docutils literal"><span class="pre">preempt_disable()</span></code>, instead, <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is -only-
guaranteed to wait on RCU read-side critical sections, that is, sections
of code protected by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_barrier">
void <code class="descname">rcu_barrier</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this primitive does not necessarily wait for an RCU grace period
to complete.  For example, if there are no RCU callbacks queued anywhere
in the system, then <a class="reference internal" href="../driver-api/basics.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal"><span class="pre">rcu_barrier()</span></code></a> is within its rights to return
immediately, without waiting for anything, much less an RCU grace period.</p>
<dl class="function">
<dt id="c.synchronize_sched_expedited">
void <code class="descname">synchronize_sched_expedited</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_sched_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force RCU-sched grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an RCU-sched grace period to elapse, but use a “big hammer”
approach to force the grace period to end quickly.  This consumes
significant time on all CPUs and is unfriendly to real-time workloads,
so is thus not recommended for any sort of common-case code.  In fact,
if you are using <a class="reference internal" href="#c.synchronize_sched_expedited" title="synchronize_sched_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched_expedited()</span></code></a> in a loop, please
restructure your code to batch your updates, and then use a single
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> instead.</p>
<p>This implementation can be thought of as an application of sequence
locking to expedited grace periods, but using the sequence counter to
determine when someone else has already done the work instead of for
retrying readers.</p>
<dl class="function">
<dt id="c.synchronize_rcu_expedited">
void <code class="descname">synchronize_rcu_expedited</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force RCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an RCU-preempt grace period, but expedite it.  The basic
idea is to IPI all non-idle non-nohz online CPUs.  The IPI handler
checks whether the CPU is in an RCU-preempt critical section, and
if so, it sets a flag that causes the outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>
to report the quiescent state.  On the other hand, if the CPU is
not in an RCU read-side critical section, the IPI handler reports
the quiescent state immediately.</p>
<p>Although this is a greate improvement over previous expedited
implementations, it is still unfriendly to real-time workloads, so is
thus not recommended for any sort of common-case code.  In fact, if
you are using <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_expedited()</span></code></a> in a loop, please restructure
your code to batch your updates, and then Use a single <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>
instead.</p>
<dl class="function">
<dt id="c.rcu_read_lock_sched_held">
int <code class="descname">rcu_read_lock_sched_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_sched_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU-sched read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an
RCU-sched read-side critical section.  In absence of
CONFIG_DEBUG_LOCK_ALLOC, this assumes we are in an RCU-sched read-side
critical section unless it can prove otherwise.  Note that disabling
of preemption (including disabling irqs) counts as an RCU-sched
read-side critical section.  This is useful for debug checks in functions
that required that they be called within an RCU-sched read-side
critical section.</p>
<p>Check <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that if the CPU is in the idle loop from an RCU point of
view (ie: that we are in the section between <a class="reference internal" href="#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_enter()</span></code></a> and
<a class="reference internal" href="#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_exit()</span></code></a>) then <a class="reference internal" href="../driver-api/basics.html#c.rcu_read_lock_held" title="rcu_read_lock_held"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_held()</span></code></a> returns false even if the CPU
did an <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.  The reason for this is that RCU ignores CPUs
that are in such a section, considering these as in extended quiescent
state, so such a CPU is effectively never in an RCU read-side critical
section regardless of what RCU primitives it invokes.  This state of
affairs is required — we need to keep an RCU-free window in idle
where the CPU may possibly enter into low power mode. This way we can
notice an extended quiescent state to other CPUs that started a grace
period. Otherwise we would delay any grace period as long as we run in
the idle task.</p>
<p>Similarly, we avoid claiming an SRCU read lock held if the current
CPU is offline.</p>
<dl class="function">
<dt id="c.rcu_expedite_gp">
void <code class="descname">rcu_expedite_gp</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_expedite_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Expedite future RCU grace periods</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>After a call to this function, future calls to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> and
friends act as the corresponding <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_expedited()</span></code></a> function
had instead been called.</p>
<dl class="function">
<dt id="c.rcu_unexpedite_gp">
void <code class="descname">rcu_unexpedite_gp</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_unexpedite_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel prior <a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a> invocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo a prior call to <a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a>.  If all prior calls to
<a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a> are undone by a subsequent call to <a class="reference internal" href="../driver-api/basics.html#c.rcu_unexpedite_gp" title="rcu_unexpedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_unexpedite_gp()</span></code></a>,
and if the rcu_expedited sysfs/boot parameter is not set, then all
subsequent calls to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> and friends will return to
their normal non-expedited behavior.</p>
<dl class="function">
<dt id="c.rcu_read_lock_held">
int <code class="descname">rcu_read_lock_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an RCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an RCU read-side critical section unless it can
prove otherwise.  This is useful for debug checks in functions that
require that they be called within an RCU read-side critical section.</p>
<p>Checks <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> in process context if the matching <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>
was invoked from within an irq handler.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
<dl class="function">
<dt id="c.rcu_read_lock_bh_held">
int <code class="descname">rcu_read_lock_bh_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU-bh read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for bottom half being disabled, which covers both the
CONFIG_PROVE_RCU and not cases.  Note that if someone uses
<a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a>, but then later enables BH, lockdep (if enabled)
will show the situation.  This is useful for debug checks in functions
that require that they be called within an RCU read-side critical
section.</p>
<p>Check <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
<dl class="function">
<dt id="c.wakeme_after_rcu">
void <code class="descname">wakeme_after_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeme_after_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback function to awaken a task after grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>Pointer to rcu_head member within rcu_synchronize structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Awaken the corresponding task now that a grace period has elapsed.</p>
<dl class="function">
<dt id="c.init_rcu_head_on_stack">
void <code class="descname">init_rcu_head_on_stack</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_rcu_head_on_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize on-stack rcu_head for debugobjects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to rcu_head structure to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects of a new rcu_head structure that
has been allocated as an auto variable on the stack.  This function
is not required for rcu_head structures that are statically defined or
that are dynamically allocated on the heap.  This function has no
effect for !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
<dl class="function">
<dt id="c.destroy_rcu_head_on_stack">
void <code class="descname">destroy_rcu_head_on_stack</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.destroy_rcu_head_on_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy on-stack rcu_head for debugobjects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to rcu_head structure to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects that an on-stack rcu_head structure
is about to go out of scope.  As with <a class="reference internal" href="../driver-api/basics.html#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this
function is not required for rcu_head structures that are statically
defined or that are dynamically allocated on the heap.  Also as with
<a class="reference internal" href="../driver-api/basics.html#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this function has no effect for
!CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
<dl class="function">
<dt id="c.call_rcu_tasks">
void <code class="descname">call_rcu_tasks</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;rhp</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation task-based grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_tasks()</span></code></a> assumes
that the read-side critical sections end at a voluntary context
switch (not a preemption!), entry into idle, or transition to usermode
execution.  As such, there are no read-side primitives analogous to
<a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> because this primitive is intended
to determine that all tasks have passed through a safe state, not so
much for data-strcuture synchronization.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.synchronize_rcu_tasks">
void <code class="descname">synchronize_rcu_tasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu-tasks grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu-tasks
grace period has elapsed, in other words after all currently
executing rcu-tasks read-side critical sections have elapsed.  These
read-side critical sections are delimited by calls to <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code>,
<a class="reference internal" href="#c.cond_resched_rcu_qs" title="cond_resched_rcu_qs"><code class="xref c c-func docutils literal"><span class="pre">cond_resched_rcu_qs()</span></code></a>, idle execution, userspace execution, calls
to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>, and (in theory, anyway) <code class="xref c c-func docutils literal"><span class="pre">cond_resched()</span></code>.</p>
<p>This is a very specialized primitive, intended only for a few uses in
tracing and other situations requiring manipulation of function
preambles and profiling hooks.  The <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> function
is not (yet) intended for heavy use from multiple CPUs.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-tasks read-side critical section whose beginning
preceded the call to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>.  In addition, each CPU
having an RCU-tasks read-side critical section that extends beyond
the return from <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> is guaranteed to have executed
a full memory barrier after the beginning of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>
and before the beginning of that RCU-tasks read-side critical section.
Note that these guarantees include CPUs that are offline, idle, or
executing in user mode, as well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> – even if CPU A and CPU B are the same CPU
(but again only if the system has more than one CPU).</p>
<dl class="function">
<dt id="c.rcu_barrier_tasks">
void <code class="descname">rcu_barrier_tasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_tasks()</span></code></a> callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Although the current implementation is guaranteed to wait, it is not
obligated to, for example, if there are no pending callbacks.</p>
<dl class="function">
<dt id="c.srcu_read_lock_held">
int <code class="descname">srcu_read_lock_held</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in SRCU read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>The srcu_struct structure to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an SRCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an SRCU read-side critical section unless it can
prove otherwise.</p>
<p>Checks <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that SRCU is based on its own statemachine and it doesn’t
relies on normal RCU, it can be called from the CPU which
is in the idle loop from an RCU point of view or offline.</p>
<dl class="function">
<dt id="c.srcu_dereference_check">
<code class="descname">srcu_dereference_check</code><span class="sig-paren">(</span><em>p</em>, <em>sp</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_dereference_check" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch SRCU-protected pointer for later dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>the pointer to fetch and protect for later dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">sp</span></code></dt>
<dd>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>condition to check for update-side use</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PROVE_RCU is enabled, invoking this outside of an RCU read-side
critical section will result in an RCU-lockdep splat, unless <strong>c</strong> evaluates
to 1.  The <strong>c</strong> argument will normally be a logical expression containing
<code class="xref c c-func docutils literal"><span class="pre">lockdep_is_held()</span></code> calls.</p>
<dl class="function">
<dt id="c.srcu_dereference">
<code class="descname">srcu_dereference</code><span class="sig-paren">(</span><em>p</em>, <em>sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_dereference" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch SRCU-protected pointer for later dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>the pointer to fetch and protect for later dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">sp</span></code></dt>
<dd>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.  If PROVE_RCU
is enabled, invoking this outside of an RCU read-side critical
section will result in an RCU-lockdep splat.</p>
<dl class="function">
<dt id="c.srcu_read_lock">
int <code class="descname">srcu_read_lock</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new reader for an SRCU-protected structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct in which to register the new reader.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter an SRCU read-side critical section.  Note that SRCU read-side
critical sections may be nested.  However, it is illegal to
call anything that waits on an SRCU grace period for the same
srcu_struct, whether directly or indirectly.  Please note that
one way to indirectly wait on an SRCU grace period is to acquire
a mutex that is held elsewhere while calling <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> or
<a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu_expedited()</span></code></a>.</p>
<p>Note that <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_unlock()</span></code></a> in an irq handler if the matching <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a>
was invoked in process context.</p>
<dl class="function">
<dt id="c.srcu_read_unlock">
void <code class="descname">srcu_read_unlock</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em>, int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a old reader from an SRCU-protected structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct in which to unregister the old reader.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>return value from corresponding <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit an SRCU read-side critical section.</p>
<dl class="function">
<dt id="c.smp_mb__after_srcu_read_unlock">
void <code class="descname">smp_mb__after_srcu_read_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.smp_mb__after_srcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>ensure full ordering after srcu_read_unlock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts the preceding srcu_read_unlock into a two-way memory barrier.</p>
<p>Call this after srcu_read_unlock, to guarantee that all memory operations
that occur after smp_mb__after_srcu_read_unlock will appear to happen after
the preceding srcu_read_unlock.</p>
<dl class="function">
<dt id="c.init_srcu_struct">
int <code class="descname">init_srcu_struct</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_srcu_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a sleep-RCU structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>structure to initialize.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this on a given srcu_struct before passing that srcu_struct
to any other function.  Each srcu_struct represents a separate domain
of SRCU protection.</p>
<dl class="function">
<dt id="c.srcu_readers_active">
bool <code class="descname">srcu_readers_active</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_readers_active" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if there are readers. and false otherwise</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>which srcu_struct to count active readers (holding srcu_read_lock).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this is not an atomic primitive, and can therefore suffer
severe errors when invoked on an active srcu_struct.  That said, it
can be useful as an error check at cleanup time.</p>
<dl class="function">
<dt id="c.cleanup_srcu_struct">
void <code class="descname">cleanup_srcu_struct</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cleanup_srcu_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>deconstruct a sleep-RCU structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>structure to clean up.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this after you are finished using a given srcu_struct that
was initialized via <a class="reference internal" href="#c.init_srcu_struct" title="init_srcu_struct"><code class="xref c c-func docutils literal"><span class="pre">init_srcu_struct()</span></code></a>, else you leak memory.</p>
<dl class="function">
<dt id="c.call_srcu">
void <code class="descname">call_srcu</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em>, struct rcu_head *<em>&nbsp;rhp</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_srcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a callback for invocation after an SRCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct in queue the callback</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt>
<dd>structure to be used for queueing the SRCU callback.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>function to be invoked after the SRCU grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full SRCU
grace period elapses, in other words after all pre-existing SRCU
read-side critical sections have completed.  However, the callback
function might well execute concurrently with other SRCU read-side
critical sections that started after <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal"><span class="pre">call_srcu()</span></code></a> was invoked.  SRCU
read-side critical sections are delimited by <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a> and
<a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_unlock()</span></code></a>, and may be nested.</p>
<p>The callback will be invoked from process context, but must nevertheless
be fast and must not block.</p>
<dl class="function">
<dt id="c.synchronize_srcu_expedited">
void <code class="descname">synchronize_srcu_expedited</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_srcu_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force SRCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct with which to synchronize.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an SRCU grace period to elapse, but be more aggressive about
spinning rather than blocking when waiting.</p>
<p>Note that <a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu_expedited()</span></code></a> has the same deadlock and
memory-ordering properties as does <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.synchronize_srcu">
void <code class="descname">synchronize_srcu</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_srcu" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for prior SRCU read-side critical-section completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct with which to synchronize.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for the count to drain to zero of both indexes. To avoid the
possible starvation of <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>, it waits for the count of
the index=((-&gt;srcu_idx &amp; 1) ^ 1) to drain to zero at first,
and then flip the srcu_idx and wait for the count of the other index.</p>
<p>Can block; must be called from process context.</p>
<p>Note that it is illegal to call <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> from the corresponding
SRCU read-side critical section; doing so will result in deadlock.
However, it is perfectly legal to call <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> on one
srcu_struct from some other srcu_struct’s read-side critical section,
as long as the resulting graph of srcu_structs is acyclic.</p>
<p>There are memory-ordering constraints implied by <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>.
On systems with more than one CPU, when <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since
the end of its last corresponding SRCU-sched read-side critical section
whose beginning preceded the call to <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>.  In addition,
each CPU having an SRCU read-side critical section that extends beyond
the return from <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> is guaranteed to have executed a
full memory barrier after the beginning of <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> and before
the beginning of that SRCU read-side critical section.  Note that these
guarantees include CPUs that are offline, idle, or executing in user mode,
as well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>.  This guarantee applies even if CPU A and CPU B
are the same CPU, but again only if the system has more than one CPU.</p>
<p>Of course, these memory-ordering guarantees apply only when
<a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>, <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a>, and <a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_unlock()</span></code></a> are
passed the same srcu_struct structure.</p>
<p>If SRCU is likely idle, expedite the first request.  This semantic
was provided by Classic SRCU, and is relied upon by its users, so TREE
SRCU must also provide it.  Note that detecting idleness is heuristic
and subject to both false positives and negatives.</p>
<dl class="function">
<dt id="c.srcu_barrier">
void <code class="descname">srcu_barrier</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal"><span class="pre">call_srcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct on which to wait for in-flight callbacks.</dd>
</dl>
<dl class="function">
<dt id="c.srcu_batches_completed">
unsigned long <code class="descname">srcu_batches_completed</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_batches_completed" title="Permalink to this definition">¶</a></dt>
<dd><p>return batches completed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct on which to report batch completion.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Report the number of batches, correlated with, but not necessarily
precisely the same as, the number of grace periods that have elapsed.</p>
<dl class="function">
<dt id="c.hlist_bl_del_init_rcu">
void <code class="descname">hlist_bl_del_init_rcu</code><span class="sig-paren">(</span>struct hlist_bl_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_del_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_unhashed()</span></code> on the node returns true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so <code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_bl_for_each_entry_rcu" title="hlist_bl_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_bl_del_rcu">
void <code class="descname">hlist_bl_del_rcu</code><span class="sig-paren">(</span>struct hlist_bl_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_unhashed()</span></code> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<code class="xref c c-func docutils literal"><span class="pre">hlist_bl_for_each_entry()</span></code>.</p>
<dl class="function">
<dt id="c.hlist_bl_add_head_rcu">
void <code class="descname">hlist_bl_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_bl_node *<em>&nbsp;n</em>, struct hlist_bl_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_bl,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_bl_for_each_entry_rcu" title="hlist_bl_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_bl_for_each_entry_rcu">
<code class="descname">hlist_bl_for_each_entry_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tpos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_bl_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_add_rcu">
void <code class="descname">list_add_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry to rcu-protected list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it after</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_add_tail_rcu">
void <code class="descname">list_add_tail_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry to rcu-protected list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it before</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_add_tail_rcu" title="list_add_tail_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_tail_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_del_rcu">
void <code class="descname">list_del_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the element to delete from the list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal"><span class="pre">list_empty()</span></code></a> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_del_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<p>Note that the caller is not permitted to immediately free
the newly deleted entry.  Instead, either <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>
or <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> must be used to defer freeing until an RCU
grace period has elapsed.</p>
<dl class="function">
<dt id="c.hlist_del_init_rcu">
void <code class="descname">hlist_del_init_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> on the node return true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so <code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_replace_rcu">
void <code class="descname">list_replace_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;old</em>, struct list_head *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the element to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new element to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>old</strong> entry will be replaced with the <strong>new</strong> entry atomically.</p>
<p><strong>Note</strong></p>
<p><strong>old</strong> should not be empty.</p>
<dl class="function">
<dt id="c.__list_splice_init_rcu">
void <code class="descname">__list_splice_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;prev</em>, struct list_head *<em>&nbsp;next</em>, void (*sync)<em>&nbsp;(void</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__list_splice_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>join an RCU-protected list into an existing list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the RCU-protected list to splice</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt>
<dd>points to the last element of the existing list</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">next</span></code></dt>
<dd>points to the first element of the existing list</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt>
<dd>function to sync: <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, …</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list pointed to by <strong>prev</strong> and <strong>next</strong> can be RCU-read traversed
concurrently with this function.</p>
<p>Note that this function blocks.</p>
<p>Important note: the caller must take whatever action is necessary to prevent
any other updates to the existing list.  In principle, it is possible to
modify the list as soon as <code class="xref c c-func docutils literal"><span class="pre">sync()</span></code> begins execution. If this sort of thing
becomes necessary, an alternative version based on <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> could be
created.  But only if -really- needed – there is no shortage of RCU API
members.</p>
<dl class="function">
<dt id="c.list_splice_init_rcu">
void <code class="descname">list_splice_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em>, void (*sync)<em>&nbsp;(void</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>splice an RCU-protected list into an existing list, designed for stacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the RCU-protected list to splice</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place in the existing list to splice the first list into</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt>
<dd>function to sync: <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, …</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_tail_init_rcu">
void <code class="descname">list_splice_tail_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em>, void (*sync)<em>&nbsp;(void</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>splice an RCU-protected list into an existing list, designed for queues.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the RCU-protected list to splice</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place in the existing list to splice the first list into</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt>
<dd>function to sync: <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, …</dd>
</dl>
<dl class="function">
<dt id="c.list_entry_rcu">
<code class="descname">list_entry_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a> as long as it’s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_first_or_null_rcu">
<code class="descname">list_first_or_null_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_or_null_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a> as long as it’s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_next_or_null_rcu">
<code class="descname">list_next_or_null_rcu</code><span class="sig-paren">(</span><em>head</em>, <em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_next_or_null_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for the list.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the next element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the ptr is at the end of the list, NULL is returned.</p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a> as long as it’s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_for_each_entry_rcu">
<code class="descname">list_for_each_entry_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_entry_lockless">
<code class="descname">list_entry_lockless</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>, but requires some implicit RCU
read-side guarding.  One example is running within a special
exception-time environment where preemption is disabled and where
lockdep cannot be invoked (in which case updaters must use RCU-sched,
as in <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a>, and friends).  Another
example is when items are added to the list, but never deleted.</p>
<dl class="function">
<dt id="c.list_for_each_entry_lockless">
<code class="descname">list_for_each_entry_lockless</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_struct within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>, but requires some implicit RCU
read-side guarding.  One example is running within a special
exception-time environment where preemption is disabled and where
lockdep cannot be invoked (in which case updaters must use RCU-sched,
as in <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a>, and friends).  Another
example is when items are added to the list, but never deleted.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue_rcu">
<code class="descname">list_for_each_entry_continue_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>continue iteration over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position.</p>
<dl class="function">
<dt id="c.hlist_del_rcu">
void <code class="descname">hlist_del_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry" title="hlist_for_each_entry"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_replace_rcu">
void <code class="descname">hlist_replace_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;old</em>, struct hlist_node *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_replace_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the element to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new element to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>old</strong> entry will be replaced with the <strong>new</strong> entry atomically.</p>
<dl class="function">
<dt id="c.hlist_add_head_rcu">
void <code class="descname">hlist_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em>, struct hlist_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_add_tail_rcu">
void <code class="descname">hlist_add_tail_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em>, struct hlist_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_add_before_rcu">
void <code class="descname">hlist_add_before_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em>, struct hlist_node *<em>&nbsp;next</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_before_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the new element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">next</span></code></dt>
<dd>the existing element to add the new element before.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist
before the specified node while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.</p>
<dl class="function">
<dt id="c.hlist_add_behind_rcu">
void <code class="descname">hlist_add_behind_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em>, struct hlist_node *<em>&nbsp;prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_behind_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the new element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt>
<dd>the existing element to add the new element after.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist
after the specified node while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu">
<code class="descname">hlist_for_each_entry_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu_notrace">
<code class="descname">hlist_for_each_entry_rcu_notrace</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu_notrace" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type (for tracing)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<p>This is the same as <a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a> except that it does
not do any RCU debugging or tracing.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu_bh">
<code class="descname">hlist_for_each_entry_rcu_bh</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue_rcu">
<code class="descname">hlist_for_each_entry_continue_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue_rcu_bh">
<code class="descname">hlist_for_each_entry_continue_rcu_bh</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_from_rcu">
<code class="descname">hlist_for_each_entry_from_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_from_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_nulls_del_init_rcu">
void <code class="descname">hlist_nulls_del_init_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_del_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_unhashed()</span></code> on the node return true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so <code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_nulls_del_rcu">
void <code class="descname">hlist_nulls_del_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_unhashed()</span></code> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_for_each_entry()</span></code>.</p>
<dl class="function">
<dt id="c.hlist_nulls_add_head_rcu">
void <code class="descname">hlist_nulls_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em>&nbsp;n</em>, struct hlist_nulls_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_nulls,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_nulls_add_tail_rcu">
void <code class="descname">hlist_nulls_add_tail_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em>&nbsp;n</em>, struct hlist_nulls_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_add_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the end of the specified hlist_nulls,
while permitting racing traversals.  NOTE: tail insertion requires
list traversal.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_nulls_for_each_entry_rcu">
<code class="descname">hlist_nulls_for_each_entry_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tpos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_nulls_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">barrier()</span></code> is needed to make sure compiler doesn’t cache first element [1],
as this loop can be restarted [2]
[1] Documentation/atomic_ops.txt around line 114
[2] Documentation/RCU/rculist_nulls.txt around line 146</p>
<dl class="function">
<dt id="c.hlist_nulls_for_each_entry_safe">
<code class="descname">hlist_nulls_for_each_entry_safe</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tpos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_nulls_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.rcu_sync_is_idle">
bool <code class="descname">rcu_sync_is_idle</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_is_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>Are readers permitted to use their fastpaths?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if readers are permitted to use their fastpaths.
Must be invoked within an RCU read-side critical section whose
flavor matches that of the rcu_sync struture.</p>
<dl class="function">
<dt id="c.rcu_sync_init">
void <code class="descname">rcu_sync_init</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em>, enum rcu_sync_type<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an rcu_sync structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to be initialized</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">rcu_sync_type</span> <span class="pre">type</span></code></dt>
<dd>Flavor of RCU with which to synchronize rcu_sync structure</dd>
</dl>
<dl class="function">
<dt id="c.rcu_sync_enter_start">
void <code class="descname">rcu_sync_enter_start</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_enter_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Force readers onto slow path for multiple updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called after <a class="reference internal" href="#c.rcu_sync_init" title="rcu_sync_init"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_init()</span></code></a> and before first use.</p>
<p>Ensures <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_is_idle()</span></code></a> returns false and rcu_sync_{enter,exit}()
pairs turn into NO-OPs.</p>
<dl class="function">
<dt id="c.rcu_sync_enter">
void <code class="descname">rcu_sync_enter</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>Force readers onto slowpath</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by updaters who need readers to make use of
a slowpath during the update.  After this function returns, all
subsequent calls to <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_is_idle()</span></code></a> will return false, which
tells readers to stay off their fastpaths.  A later call to
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a> re-enables reader slowpaths.</p>
<p>When called in isolation, <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a> must wait for a grace
period, however, closely spaced calls to <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a> can
optimize away the grace-period wait via a state machine implemented
by <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a>, <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a>, and <a class="reference internal" href="#c.rcu_sync_func" title="rcu_sync_func"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_func()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_sync_func">
void <code class="descname">rcu_sync_func</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;rhp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback function managing reader access to fastpath</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt>
<dd>Pointer to rcu_head in rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is passed to one of the <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> functions by
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a>, so that it is invoked after a grace period following the
that invocation of <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a>.  It takes action based on events that
have taken place in the meantime, so that closely spaced <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a>
and <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a> pairs need not wait for a grace period.</p>
<p>If another <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a> is invoked before the grace period
ended, reset state to allow the next <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a> to let the
readers back onto their fastpaths (after a grace period).  If both
another <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a> and its matching <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a> are invoked
before the grace period ended, re-invoke <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> on behalf of that
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a>.  Otherwise, set all state back to idle so that readers
can again use their fastpaths.</p>
<dl class="function">
<dt id="c.rcu_sync_exit">
void <code class="descname">rcu_sync_exit</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow readers back onto fast patch after grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by updaters who have completed, and can therefore
now allow readers to make use of their fastpaths after a grace period
has elapsed.  After this grace period has completed, all subsequent
calls to <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_is_idle()</span></code></a> will return true, which tells readers that
they can once again use their fastpaths.</p>
<dl class="function">
<dt id="c.rcu_sync_dtor">
void <code class="descname">rcu_sync_dtor</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_dtor" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up an rcu_sync structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to be cleaned up</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="assoc_array.html" class="btn btn-neutral float-right" title="Generic Associative Array Implementation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Core API Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>