

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>CPU hotplug in the Kernel &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Semantics and Behavior of Local Atomic Operations" href="local_ops.html" />
    <link rel="prev" title="Semantics and Behavior of Atomic and Bitmask Operations" href="atomic_ops.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kernel-api.html">The Linux Kernel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomic_ops.html">Semantics and Behavior of Atomic and Bitmask Operations</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">CPU hotplug in the Kernel</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#command-line-switches">Command Line Switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-maps">CPU maps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-cpu-hotplug">Using CPU hotplug</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-cpu-hotplug-coordination">The CPU hotplug coordination</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testing-of-hotplug-states">Testing of hotplug states</a></li>
<li class="toctree-l4"><a class="reference internal" href="#architecture-s-requirements">Architecture’s requirements</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-space-notification">User Space Notification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-inline-documentations-reference">Kernel Inline Documentations Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="flexible-arrays.html">Using flexible arrays in the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="genalloc.html">The genalloc/genpool subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
        
      <li>CPU hotplug in the Kernel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/cpu_hotplug.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cpu-hotplug-in-the-kernel">
<h1>CPU hotplug in the Kernel<a class="headerlink" href="#cpu-hotplug-in-the-kernel" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Date:</th><td class="field-body">December, 2016</td>
</tr>
<tr class="field-even field"><th class="field-name">Author:</th><td class="field-body">Sebastian Andrzej Siewior &lt;<a class="reference external" href="mailto:bigeasy&#37;&#52;&#48;linutronix&#46;de">bigeasy<span>&#64;</span>linutronix<span>&#46;</span>de</a>&gt;,
Rusty Russell &lt;<a class="reference external" href="mailto:rusty&#37;&#52;&#48;rustcorp&#46;com&#46;au">rusty<span>&#64;</span>rustcorp<span>&#46;</span>com<span>&#46;</span>au</a>&gt;,
Srivatsa Vaddagiri &lt;<a class="reference external" href="mailto:vatsa&#37;&#52;&#48;in&#46;ibm&#46;com">vatsa<span>&#64;</span>in<span>&#46;</span>ibm<span>&#46;</span>com</a>&gt;,
Ashok Raj &lt;<a class="reference external" href="mailto:ashok&#46;raj&#37;&#52;&#48;intel&#46;com">ashok<span>&#46;</span>raj<span>&#64;</span>intel<span>&#46;</span>com</a>&gt;,
Joel Schopp &lt;<a class="reference external" href="mailto:jschopp&#37;&#52;&#48;austin&#46;ibm&#46;com">jschopp<span>&#64;</span>austin<span>&#46;</span>ibm<span>&#46;</span>com</a>&gt;</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Modern advances in system architectures have introduced advanced error
reporting and correction capabilities in processors. There are couple OEMS that
support NUMA hardware which are hot pluggable as well, where physical node
insertion and removal require support for CPU hotplug.</p>
<p>Such advances require CPUs available to a kernel to be removed either for
provisioning reasons, or for RAS purposes to keep an offending CPU off
system execution path. Hence the need for CPU hotplug support in the
Linux kernel.</p>
<p>A more novel use of CPU-hotplug support is its use today in suspend resume
support for SMP. Dual-core and HT support makes even a laptop run SMP kernels
which didn’t support these methods.</p>
</div>
<div class="section" id="command-line-switches">
<h2>Command Line Switches<a class="headerlink" href="#command-line-switches" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">maxcpus=n</span></code></dt>
<dd>Restrict boot time CPUs to <em>n</em>. Say if you have fourV CPUs, using
<code class="docutils literal"><span class="pre">maxcpus=2</span></code> will only boot two. You can choose to bring the
other CPUs later online.</dd>
<dt><code class="docutils literal"><span class="pre">nr_cpus=n</span></code></dt>
<dd>Restrict the total amount CPUs the kernel will support. If the number
supplied here is lower than the number of physically available CPUs than
those CPUs can not be brought online later.</dd>
<dt><code class="docutils literal"><span class="pre">additional_cpus=n</span></code></dt>
<dd><p class="first">Use this to limit hotpluggable CPUs. This option sets
<code class="docutils literal"><span class="pre">cpu_possible_mask</span> <span class="pre">=</span> <span class="pre">cpu_present_mask</span> <span class="pre">+</span> <span class="pre">additional_cpus</span></code></p>
<p class="last">This option is limited to the IA64 architecture.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">possible_cpus=n</span></code></dt>
<dd><p class="first">This option sets <code class="docutils literal"><span class="pre">possible_cpus</span></code> bits in <code class="docutils literal"><span class="pre">cpu_possible_mask</span></code>.</p>
<p class="last">This option is limited to the X86 and S390 architecture.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cede_offline={&quot;off&quot;,&quot;on&quot;}</span></code></dt>
<dd><p class="first">Use this option to disable/enable putting offlined processors to an extended
<code class="docutils literal"><span class="pre">H_CEDE</span></code> state on supported pseries platforms. If nothing is specified,
<code class="docutils literal"><span class="pre">cede_offline</span></code> is set to “on”.</p>
<p class="last">This option is limited to the PowerPC architecture.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cpu0_hotplug</span></code></dt>
<dd><p class="first">Allow to shutdown CPU0.</p>
<p class="last">This option is limited to the X86 architecture.</p>
</dd>
</dl>
</div>
<div class="section" id="cpu-maps">
<h2>CPU maps<a class="headerlink" href="#cpu-maps" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cpu_possible_mask</span></code></dt>
<dd>Bitmap of possible CPUs that can ever be available in the
system. This is used to allocate some boot time memory for per_cpu variables
that aren’t designed to grow/shrink as CPUs are made available or removed.
Once set during boot time discovery phase, the map is static, i.e no bits
are added or removed anytime. Trimming it accurately for your system needs
upfront can save some boot time memory.</dd>
<dt><code class="docutils literal"><span class="pre">cpu_online_mask</span></code></dt>
<dd>Bitmap of all CPUs currently online. Its set in <code class="docutils literal"><span class="pre">__cpu_up()</span></code>
after a CPU is available for kernel scheduling and ready to receive
interrupts from devices. Its cleared when a CPU is brought down using
<code class="docutils literal"><span class="pre">__cpu_disable()</span></code>, before which all OS services including interrupts are
migrated to another target CPU.</dd>
<dt><code class="docutils literal"><span class="pre">cpu_present_mask</span></code></dt>
<dd>Bitmap of CPUs currently present in the system. Not all
of them may be online. When physical hotplug is processed by the relevant
subsystem (e.g ACPI) can change and new bit either be added or removed
from the map depending on the event is hot-add/hot-remove. There are currently
no locking rules as of now. Typical usage is to init topology during boot,
at which time hotplug is disabled.</dd>
</dl>
<p>You really don’t need to manipulate any of the system CPU maps. They should
be read-only for most use. When setting up per-cpu resources almost always use
<code class="docutils literal"><span class="pre">cpu_possible_mask</span></code> or <code class="docutils literal"><span class="pre">for_each_possible_cpu()</span></code> to iterate. To macro
<code class="docutils literal"><span class="pre">for_each_cpu()</span></code> can be used to iterate over a custom CPU mask.</p>
<p>Never use anything other than <code class="docutils literal"><span class="pre">cpumask_t</span></code> to represent bitmap of CPUs.</p>
</div>
<div class="section" id="using-cpu-hotplug">
<h2>Using CPU hotplug<a class="headerlink" href="#using-cpu-hotplug" title="Permalink to this headline">¶</a></h2>
<p>The kernel option <em>CONFIG_HOTPLUG_CPU</em> needs to be enabled. It is currently
available on multiple architectures including ARM, MIPS, PowerPC and X86. The
configuration is done via the sysfs interface:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ls -lh /sys/devices/system/cpu
total 0
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu0
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu1
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu2
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu3
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu4
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu5
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu6
drwxr-xr-x  9 root root    0 Dec 21 16:33 cpu7
drwxr-xr-x  2 root root    0 Dec 21 16:33 hotplug
-r--r--r--  1 root root 4.0K Dec 21 16:33 offline
-r--r--r--  1 root root 4.0K Dec 21 16:33 online
-r--r--r--  1 root root 4.0K Dec 21 16:33 possible
-r--r--r--  1 root root 4.0K Dec 21 16:33 present
</pre></div>
</div>
<p>The files <em>offline</em>, <em>online</em>, <em>possible</em>, <em>present</em> represent the CPU masks.
Each CPU folder contains an <em>online</em> file which controls the logical on (1) and
off (0) state. To logically shutdown CPU4:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ echo 0 &gt; /sys/devices/system/cpu/cpu4/online
 smpboot: CPU 4 is now offline
</pre></div>
</div>
<p>Once the CPU is shutdown, it will be removed from <em>/proc/interrupts</em>,
<em>/proc/cpuinfo</em> and should also not be shown visible by the <em>top</em> command. To
bring CPU4 back online:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ echo 1 &gt; /sys/devices/system/cpu/cpu4/online
smpboot: Booting Node 0 Processor 4 APIC 0x1
</pre></div>
</div>
<p>The CPU is usable again. This should work on all CPUs. CPU0 is often special
and excluded from CPU hotplug. On X86 the kernel option
<em>CONFIG_BOOTPARAM_HOTPLUG_CPU0</em> has to be enabled in order to be able to
shutdown CPU0. Alternatively the kernel command option <em>cpu0_hotplug</em> can be
used. Some known dependencies of CPU0:</p>
<ul class="simple">
<li>Resume from hibernate/suspend. Hibernate/suspend will fail if CPU0 is offline.</li>
<li>PIC interrupts. CPU0 can’t be removed if a PIC interrupt is detected.</li>
</ul>
<p>Please let Fenghua Yu &lt;<a class="reference external" href="mailto:fenghua&#46;yu&#37;&#52;&#48;intel&#46;com">fenghua<span>&#46;</span>yu<span>&#64;</span>intel<span>&#46;</span>com</a>&gt; know if you find any dependencies
on CPU0.</p>
</div>
<div class="section" id="the-cpu-hotplug-coordination">
<h2>The CPU hotplug coordination<a class="headerlink" href="#the-cpu-hotplug-coordination" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-offline-case">
<h3>The offline case<a class="headerlink" href="#the-offline-case" title="Permalink to this headline">¶</a></h3>
<p>Once a CPU has been logically shutdown the teardown callbacks of registered
hotplug states will be invoked, starting with <code class="docutils literal"><span class="pre">CPUHP_ONLINE</span></code> and terminating
at state <code class="docutils literal"><span class="pre">CPUHP_OFFLINE</span></code>. This includes:</p>
<ul class="simple">
<li>If tasks are frozen due to a suspend operation then <em>cpuhp_tasks_frozen</em>
will be set to true.</li>
<li>All processes are migrated away from this outgoing CPU to new CPUs.
The new CPU is chosen from each process’ current cpuset, which may be
a subset of all online CPUs.</li>
<li>All interrupts targeted to this CPU are migrated to a new CPU</li>
<li>timers are also migrated to a new CPU</li>
<li>Once all services are migrated, kernel calls an arch specific routine
<code class="docutils literal"><span class="pre">__cpu_disable()</span></code> to perform arch specific cleanup.</li>
</ul>
</div>
<div class="section" id="using-the-hotplug-api">
<h3>Using the hotplug API<a class="headerlink" href="#using-the-hotplug-api" title="Permalink to this headline">¶</a></h3>
<p>It is possible to receive notifications once a CPU is offline or onlined. This
might be important to certain drivers which need to perform some kind of setup
or clean up functions based on the number of available CPUs:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#include &lt;linux/cpuhotplug.h&gt;

ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, &quot;X/Y:online&quot;,
                        Y_online, Y_prepare_down);
</pre></div>
</div>
<p><em>X</em> is the subsystem and <em>Y</em> the particular driver. The <em>Y_online</em> callback
will be invoked during registration on all online CPUs. If an error
occurs during the online callback the <em>Y_prepare_down</em> callback will be
invoked on all CPUs on which the online callback was previously invoked.
After registration completed, the <em>Y_online</em> callback will be invoked
once a CPU is brought online and <em>Y_prepare_down</em> will be invoked when a
CPU is shutdown. All resources which were previously allocated in
<em>Y_online</em> should be released in <em>Y_prepare_down</em>.
The return value <em>ret</em> is negative if an error occurred during the
registration process. Otherwise a positive value is returned which
contains the allocated hotplug for dynamically allocated states
(<em>CPUHP_AP_ONLINE_DYN</em>). It will return zero for predefined states.</p>
<p>The callback can be remove by invoking <code class="docutils literal"><span class="pre">cpuhp_remove_state()</span></code>. In case of a
dynamically allocated state (<em>CPUHP_AP_ONLINE_DYN</em>) use the returned state.
During the removal of a hotplug state the teardown callback will be invoked.</p>
<div class="section" id="multiple-instances">
<h4>Multiple instances<a class="headerlink" href="#multiple-instances" title="Permalink to this headline">¶</a></h4>
<p>If a driver has multiple instances and each instance needs to perform the
callback independently then it is likely that a ‘’multi-state’’ should be used.
First a multi-state state needs to be registered:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, &quot;X/Y:online,
                              Y_online, Y_prepare_down);
Y_hp_online = ret;
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">cpuhp_setup_state_multi()</span></code> behaves similar to <code class="docutils literal"><span class="pre">cpuhp_setup_state()</span></code>
except it prepares the callbacks for a multi state and does not invoke
the callbacks. This is a one time setup.
Once a new instance is allocated, you need to register this new instance:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>ret = cpuhp_state_add_instance(Y_hp_online, &amp;d-&gt;node);
</pre></div>
</div>
<p>This function will add this instance to your previously allocated
<em>Y_hp_online</em> state and invoke the previously registered callback
(<em>Y_online</em>) on all online CPUs. The <em>node</em> element is a <code class="docutils literal"><span class="pre">struct</span>
<span class="pre">hlist_node</span></code> member of your per-instance data structure.</p>
<dl class="docutils">
<dt>On removal of the instance: ::</dt>
<dd>cpuhp_state_remove_instance(Y_hp_online, &amp;d-&gt;node)</dd>
</dl>
<p>should be invoked which will invoke the teardown callback on all online
CPUs.</p>
</div>
<div class="section" id="manual-setup">
<h4>Manual setup<a class="headerlink" href="#manual-setup" title="Permalink to this headline">¶</a></h4>
<p>Usually it is handy to invoke setup and teardown callbacks on registration or
removal of a state because usually the operation needs to performed once a CPU
goes online (offline) and during initial setup (shutdown) of the driver. However
each registration and removal function is also available with a <code class="docutils literal"><span class="pre">_nocalls</span></code>
suffix which does not invoke the provided callbacks if the invocation of the
callbacks is not desired. During the manual setup (or teardown) the functions
<code class="docutils literal"><span class="pre">get_online_cpus()</span></code> and <code class="docutils literal"><span class="pre">put_online_cpus()</span></code> should be used to inhibit CPU
hotplug operations.</p>
</div>
</div>
<div class="section" id="the-ordering-of-the-events">
<h3>The ordering of the events<a class="headerlink" href="#the-ordering-of-the-events" title="Permalink to this headline">¶</a></h3>
<p>The hotplug states are defined in <code class="docutils literal"><span class="pre">include/linux/cpuhotplug.h</span></code>:</p>
<ul class="simple">
<li>The states <em>CPUHP_OFFLINE</em> … <em>CPUHP_AP_OFFLINE</em> are invoked before the
CPU is up.</li>
<li>The states <em>CPUHP_AP_OFFLINE</em> … <em>CPUHP_AP_ONLINE</em> are invoked
just the after the CPU has been brought up. The interrupts are off and
the scheduler is not yet active on this CPU. Starting with <em>CPUHP_AP_OFFLINE</em>
the callbacks are invoked on the target CPU.</li>
<li>The states between <em>CPUHP_AP_ONLINE_DYN</em> and <em>CPUHP_AP_ONLINE_DYN_END</em> are
reserved for the dynamic allocation.</li>
<li>The states are invoked in the reverse order on CPU shutdown starting with
<em>CPUHP_ONLINE</em> and stopping at <em>CPUHP_OFFLINE</em>. Here the callbacks are
invoked on the CPU that will be shutdown until <em>CPUHP_AP_OFFLINE</em>.</li>
</ul>
<p>A dynamically allocated state via <em>CPUHP_AP_ONLINE_DYN</em> is often enough.
However if an earlier invocation during the bring up or shutdown is required
then an explicit state should be acquired. An explicit state might also be
required if the hotplug event requires specific ordering in respect to
another hotplug event.</p>
</div>
</div>
<div class="section" id="testing-of-hotplug-states">
<h2>Testing of hotplug states<a class="headerlink" href="#testing-of-hotplug-states" title="Permalink to this headline">¶</a></h2>
<p>One way to verify whether a custom state is working as expected or not is to
shutdown a CPU and then put it online again. It is also possible to put the CPU
to certain state (for instance <em>CPUHP_AP_ONLINE</em>) and then go back to
<em>CPUHP_ONLINE</em>. This would simulate an error one state after <em>CPUHP_AP_ONLINE</em>
which would lead to rollback to the online state.</p>
<p>All registered states are enumerated in <code class="docutils literal"><span class="pre">/sys/devices/system/cpu/hotplug/states</span></code>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ tail /sys/devices/system/cpu/hotplug/states
138: mm/vmscan:online
139: mm/vmstat:online
140: lib/percpu_cnt:online
141: acpi/cpu-drv:online
142: base/cacheinfo:online
143: virtio/net:online
144: x86/mce:online
145: printk:online
168: sched:active
169: online
</pre></div>
</div>
<p>To rollback CPU4 to <code class="docutils literal"><span class="pre">lib/percpu_cnt:online</span></code> and back online just issue:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ cat /sys/devices/system/cpu/cpu4/hotplug/state
169
$ echo 140 &gt; /sys/devices/system/cpu/cpu4/hotplug/target
$ cat /sys/devices/system/cpu/cpu4/hotplug/state
140
</pre></div>
</div>
<p>It is important to note that the teardown callbac of state 140 have been
invoked. And now get back online:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ echo 169 &gt; /sys/devices/system/cpu/cpu4/hotplug/target
$ cat /sys/devices/system/cpu/cpu4/hotplug/state
169
</pre></div>
</div>
<p>With trace events enabled, the individual steps are visible, too:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#  TASK-PID   CPU#    TIMESTAMP  FUNCTION
#     | |       |        |         |
    bash-394  [001]  22.976: cpuhp_enter: cpu: 0004 target: 140 step: 169 (cpuhp_kick_ap_work)
 cpuhp/4-31   [004]  22.977: cpuhp_enter: cpu: 0004 target: 140 step: 168 (sched_cpu_deactivate)
 cpuhp/4-31   [004]  22.990: cpuhp_exit:  cpu: 0004  state: 168 step: 168 ret: 0
 cpuhp/4-31   [004]  22.991: cpuhp_enter: cpu: 0004 target: 140 step: 144 (mce_cpu_pre_down)
 cpuhp/4-31   [004]  22.992: cpuhp_exit:  cpu: 0004  state: 144 step: 144 ret: 0
 cpuhp/4-31   [004]  22.993: cpuhp_multi_enter: cpu: 0004 target: 140 step: 143 (virtnet_cpu_down_prep)
 cpuhp/4-31   [004]  22.994: cpuhp_exit:  cpu: 0004  state: 143 step: 143 ret: 0
 cpuhp/4-31   [004]  22.995: cpuhp_enter: cpu: 0004 target: 140 step: 142 (cacheinfo_cpu_pre_down)
 cpuhp/4-31   [004]  22.996: cpuhp_exit:  cpu: 0004  state: 142 step: 142 ret: 0
    bash-394  [001]  22.997: cpuhp_exit:  cpu: 0004  state: 140 step: 169 ret: 0
    bash-394  [005]  95.540: cpuhp_enter: cpu: 0004 target: 169 step: 140 (cpuhp_kick_ap_work)
 cpuhp/4-31   [004]  95.541: cpuhp_enter: cpu: 0004 target: 169 step: 141 (acpi_soft_cpu_online)
 cpuhp/4-31   [004]  95.542: cpuhp_exit:  cpu: 0004  state: 141 step: 141 ret: 0
 cpuhp/4-31   [004]  95.543: cpuhp_enter: cpu: 0004 target: 169 step: 142 (cacheinfo_cpu_online)
 cpuhp/4-31   [004]  95.544: cpuhp_exit:  cpu: 0004  state: 142 step: 142 ret: 0
 cpuhp/4-31   [004]  95.545: cpuhp_multi_enter: cpu: 0004 target: 169 step: 143 (virtnet_cpu_online)
 cpuhp/4-31   [004]  95.546: cpuhp_exit:  cpu: 0004  state: 143 step: 143 ret: 0
 cpuhp/4-31   [004]  95.547: cpuhp_enter: cpu: 0004 target: 169 step: 144 (mce_cpu_online)
 cpuhp/4-31   [004]  95.548: cpuhp_exit:  cpu: 0004  state: 144 step: 144 ret: 0
 cpuhp/4-31   [004]  95.549: cpuhp_enter: cpu: 0004 target: 169 step: 145 (console_cpu_notify)
 cpuhp/4-31   [004]  95.550: cpuhp_exit:  cpu: 0004  state: 145 step: 145 ret: 0
 cpuhp/4-31   [004]  95.551: cpuhp_enter: cpu: 0004 target: 169 step: 168 (sched_cpu_activate)
 cpuhp/4-31   [004]  95.552: cpuhp_exit:  cpu: 0004  state: 168 step: 168 ret: 0
    bash-394  [005]  95.553: cpuhp_exit:  cpu: 0004  state: 169 step: 140 ret: 0
</pre></div>
</div>
<p>As it an be seen, CPU4 went down until timestamp 22.996 and then back up until
95.552. All invoked callbacks including their return codes are visible in the
trace.</p>
</div>
<div class="section" id="architecture-s-requirements">
<h2>Architecture’s requirements<a class="headerlink" href="#architecture-s-requirements" title="Permalink to this headline">¶</a></h2>
<p>The following functions and configurations are required:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">CONFIG_HOTPLUG_CPU</span></code></dt>
<dd>This entry needs to be enabled in Kconfig</dd>
<dt><code class="docutils literal"><span class="pre">__cpu_up()</span></code></dt>
<dd>Arch interface to bring up a CPU</dd>
<dt><code class="docutils literal"><span class="pre">__cpu_disable()</span></code></dt>
<dd>Arch interface to shutdown a CPU, no more interrupts can be handled by the
kernel after the routine returns. This includes the shutdown of the timer.</dd>
<dt><code class="docutils literal"><span class="pre">__cpu_die()</span></code></dt>
<dd>This actually supposed to ensure death of the CPU. Actually look at some
example code in other arch that implement CPU hotplug. The processor is taken
down from the <code class="docutils literal"><span class="pre">idle()</span></code> loop for that specific architecture. <code class="docutils literal"><span class="pre">__cpu_die()</span></code>
typically waits for some per_cpu state to be set, to ensure the processor dead
routine is called to be sure positively.</dd>
</dl>
</div>
<div class="section" id="user-space-notification">
<h2>User Space Notification<a class="headerlink" href="#user-space-notification" title="Permalink to this headline">¶</a></h2>
<p>After CPU successfully onlined or offline udev events are sent. A udev rule like:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>SUBSYSTEM==&quot;cpu&quot;, DRIVERS==&quot;processor&quot;, DEVPATH==&quot;/devices/system/cpu/*&quot;, RUN+=&quot;the_hotplug_receiver.sh&quot;
</pre></div>
</div>
<p>will receive all events. A script like:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#!/bin/sh

if [ &quot;${ACTION}&quot; = &quot;offline&quot; ]
then
    echo &quot;CPU ${DEVPATH##*/} offline&quot;

elif [ &quot;${ACTION}&quot; = &quot;online&quot; ]
then
    echo &quot;CPU ${DEVPATH##*/} online&quot;

fi
</pre></div>
</div>
<p>can process the event further.</p>
</div>
<div class="section" id="kernel-inline-documentations-reference">
<h2>Kernel Inline Documentations Reference<a class="headerlink" href="#kernel-inline-documentations-reference" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.cpuhp_setup_state">
int <code class="descname">cpuhp_setup_state</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em>, const char *<em>&nbsp;name</em>, int (*startup) (unsigned int<em>&nbsp;cpu</em>, int (*teardown) (unsigned int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_setup_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup hotplug state callbacks with calling the callbacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state for which the calls are installed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>Name of the callback (will be used in debug output)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span> <span class="pre">startup</span></code></dt>
<dd>startup callback function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span> <span class="pre">teardown</span></code></dt>
<dd>teardown callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the callback functions and invokes the startup callback on
the present cpus which have already reached the <strong>state</strong>.</p>
<dl class="function">
<dt id="c.cpuhp_setup_state_nocalls">
int <code class="descname">cpuhp_setup_state_nocalls</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em>, const char *<em>&nbsp;name</em>, int (*startup) (unsigned int<em>&nbsp;cpu</em>, int (*teardown) (unsigned int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_setup_state_nocalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup hotplug state callbacks without calling the callbacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state for which the calls are installed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>Name of the callback.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span> <span class="pre">startup</span></code></dt>
<dd>startup callback function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu)</span> <span class="pre">teardown</span></code></dt>
<dd>teardown callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <strong>cpuhp_setup_state</strong> except that no calls are executed are invoked
during installation of this callback. NOP if SMP=n or HOTPLUG_CPU=n.</p>
<dl class="function">
<dt id="c.cpuhp_setup_state_multi">
int <code class="descname">cpuhp_setup_state_multi</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em>, const char *<em>&nbsp;name</em>, int (*startup) (unsigned int<em>&nbsp;cpu</em>, struct hlist_node<em>&nbsp;*node</em>, int (*teardown) (unsigned int<em>&nbsp;cpu</em>, struct hlist_node<em>&nbsp;*node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_setup_state_multi" title="Permalink to this definition">¶</a></dt>
<dd><p>Add callbacks for multi state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state for which the calls are installed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>Name of the callback.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu,</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node)</span> <span class="pre">startup</span></code></dt>
<dd>startup callback function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(unsigned</span> <span class="pre">int</span> <span class="pre">cpu,</span> <span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*node)</span> <span class="pre">teardown</span></code></dt>
<dd>teardown callback function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the internal multi_instance flag and prepares a state to work as a multi
instance callback. No callbacks are invoked at this point. The callbacks are
invoked once an instance for this state are registered via
<strong>cpuhp_state_add_instance</strong> or <strong>cpuhp_state_add_instance_nocalls</strong>.</p>
<dl class="function">
<dt id="c.cpuhp_state_add_instance">
int <code class="descname">cpuhp_state_add_instance</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em>, struct hlist_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_add_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an instance for a state and invoke startup callback.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state for which the instance is installed</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>The node for this individual state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the instance for the <strong>state</strong> and invokes the startup callback on
the present cpus which have already reached the <strong>state</strong>. The <strong>state</strong> must have
been earlier marked as multi-instance by <strong>cpuhp_setup_state_multi</strong>.</p>
<dl class="function">
<dt id="c.cpuhp_state_add_instance_nocalls">
int <code class="descname">cpuhp_state_add_instance_nocalls</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em>, struct hlist_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_add_instance_nocalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an instance for a state without invoking the startup callback.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state for which the instance is installed</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>The node for this individual state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Installs the instance for the <strong>state</strong> The <strong>state</strong> must have been earlier
marked as multi-instance by <strong>cpuhp_setup_state_multi</strong>.</p>
<dl class="function">
<dt id="c.cpuhp_remove_state">
void <code class="descname">cpuhp_remove_state</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_remove_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug state callbacks and invoke the teardown</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state for which the calls are removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the callback functions and invokes the teardown callback on
the present cpus which have already reached the <strong>state</strong>.</p>
<dl class="function">
<dt id="c.cpuhp_remove_state_nocalls">
void <code class="descname">cpuhp_remove_state_nocalls</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_remove_state_nocalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug state callbacks without invoking teardown</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state for which the calls are removed</dd>
</dl>
<dl class="function">
<dt id="c.cpuhp_remove_multi_state">
void <code class="descname">cpuhp_remove_multi_state</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_remove_multi_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug multi state callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state for which the calls are removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the callback functions from a multi state. This is the reverse of
<a class="reference internal" href="#c.cpuhp_setup_state_multi" title="cpuhp_setup_state_multi"><code class="xref c c-func docutils literal"><span class="pre">cpuhp_setup_state_multi()</span></code></a>. All instances should have been removed before
invoking this function.</p>
<dl class="function">
<dt id="c.cpuhp_state_remove_instance">
int <code class="descname">cpuhp_state_remove_instance</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em>, struct hlist_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_remove_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug instance from state and invoke the teardown callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state from which the instance is removed</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>The node for this individual state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the instance and invokes the teardown callback on the present cpus
which have already reached the <strong>state</strong>.</p>
<dl class="function">
<dt id="c.cpuhp_state_remove_instance_nocalls">
int <code class="descname">cpuhp_state_remove_instance_nocalls</code><span class="sig-paren">(</span>enum cpuhp_state<em>&nbsp;state</em>, struct hlist_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpuhp_state_remove_instance_nocalls" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove hotplug instance from state without invoking the reatdown callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpuhp_state</span> <span class="pre">state</span></code></dt>
<dd>The state from which the instance is removed</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>The node for this individual state.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the instance without invoking the teardown callback.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="local_ops.html" class="btn btn-neutral float-right" title="Semantics and Behavior of Local Atomic Operations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="atomic_ops.html" class="btn btn-neutral" title="Semantics and Behavior of Atomic and Bitmask Operations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>