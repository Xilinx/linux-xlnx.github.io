

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Semantics and Behavior of Atomic and Bitmask Operations &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="CPU hotplug in the Kernel" href="cpu_hotplug.html" />
    <link rel="prev" title="Generic Associative Array Implementation" href="assoc_array.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kernel-api.html">The Linux Kernel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Semantics and Behavior of Atomic and Bitmask Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#atomic-type-and-operations">Atomic Type And Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-bitmask">Atomic Bitmask</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="flexible-arrays.html">Using flexible arrays in the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="genalloc.html">The genalloc/genpool subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
        
      <li>Semantics and Behavior of Atomic and Bitmask Operations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/core-api/atomic_ops.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="semantics-and-behavior-of-atomic-and-bitmask-operations">
<h1>Semantics and Behavior of Atomic and Bitmask Operations<a class="headerlink" href="#semantics-and-behavior-of-atomic-and-bitmask-operations" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">David S. Miller</td>
</tr>
</tbody>
</table>
<p>This document is intended to serve as a guide to Linux port
maintainers on how to implement atomic counter, bitops, and spinlock
interfaces properly.</p>
<div class="section" id="atomic-type-and-operations">
<h2>Atomic Type And Operations<a class="headerlink" href="#atomic-type-and-operations" title="Permalink to this headline">¶</a></h2>
<p>The atomic_t type should be defined as a signed integer and
the atomic_long_t type as a signed long integer.  Also, they should
be made opaque such that any kind of cast to a normal C integer type
will fail.  Something like the following should suffice:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>typedef struct { int counter; } atomic_t;
typedef struct { long counter; } atomic_long_t;
</pre></div>
</div>
<p>Historically, counter has been declared volatile.  This is now discouraged.
See <a class="reference internal" href="../process/volatile-considered-harmful.html#volatile-considered-harmful"><span class="std std-ref">Documentation/process/volatile-considered-harmful.rst</span></a> for the complete rationale.</p>
<p>local_t is very similar to atomic_t. If the counter is per CPU and only
updated by one CPU, local_t is probably more appropriate. Please see
<a class="reference internal" href="local_ops.html#local-ops"><span class="std std-ref">Documentation/core-api/local_ops.rst</span></a> for the semantics of
local_t.</p>
<p>The first operations to implement for atomic_t’s are the initializers and
plain reads.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#define ATOMIC_INIT(i)          { (i) }
#define atomic_set(v, i)        ((v)-&gt;counter = (i))
</pre></div>
</div>
<p>The first macro is used in definitions, such as:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static atomic_t my_counter = ATOMIC_INIT(1);
</pre></div>
</div>
<p>The initializer is atomic in that the return values of the atomic operations
are guaranteed to be correct reflecting the initialized value if the
initializer is used before runtime.  If the initializer is used at runtime, a
proper implicit or explicit read memory barrier is needed before reading the
value with atomic_read from another thread.</p>
<p>As with all of the <code class="docutils literal"><span class="pre">atomic_</span></code> interfaces, replace the leading <code class="docutils literal"><span class="pre">atomic_</span></code>
with <code class="docutils literal"><span class="pre">atomic_long_</span></code> to operate on atomic_long_t.</p>
<p>The second interface can be used at runtime, as in:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct foo { atomic_t counter; };
...

struct foo *k;

k = kmalloc(sizeof(*k), GFP_KERNEL);
if (!k)
        return -ENOMEM;
atomic_set(&amp;k-&gt;counter, 0);
</pre></div>
</div>
<p>The setting is atomic in that the return values of the atomic operations by
all threads are guaranteed to be correct reflecting either the value that has
been set with this operation or set with another operation.  A proper implicit
or explicit memory barrier is needed before the value set with the operation
is guaranteed to be readable with atomic_read from another thread.</p>
<p>Next, we have:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>#define atomic_read(v)  ((v)-&gt;counter)
</pre></div>
</div>
<p>which simply reads the counter value currently visible to the calling thread.
The read is atomic in that the return value is guaranteed to be one of the
values initialized or modified with the interface operations if a proper
implicit or explicit memory barrier is used after possible runtime
initialization by any other thread and the value is modified only with the
interface operations.  atomic_read does not guarantee that the runtime
initialization by any other thread is visible yet, so the user of the
interface must take care of that with a proper implicit or explicit memory
barrier.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><code class="docutils literal"><span class="pre">atomic_read()</span></code> and <code class="docutils literal"><span class="pre">atomic_set()</span></code> DO NOT IMPLY BARRIERS!</p>
<p class="last">Some architectures may choose to use the volatile keyword, barriers, or
inline assembly to guarantee some degree of immediacy for atomic_read()
and atomic_set().  This is not uniformly guaranteed, and may change in
the future, so all users of atomic_t should treat atomic_read() and
atomic_set() as simple C statements that may be reordered or optimized
away entirely by the compiler or processor, and explicitly invoke the
appropriate compiler and/or memory barrier for each use case.  Failure
to do so will result in code that may suddenly break when used with
different architectures or compiler optimizations, or even changes in
unrelated code which changes how the compiler optimizes the section
accessing atomic_t variables.</p>
</div>
<p>Properly aligned pointers, longs, ints, and chars (and unsigned
equivalents) may be atomically loaded from and stored to in the same
sense as described for atomic_read() and atomic_set().  The READ_ONCE()
and WRITE_ONCE() macros should be used to prevent the compiler from using
optimizations that might otherwise optimize accesses out of existence on
the one hand, or that might create unsolicited accesses on the other.</p>
<p>For example consider the following code:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>while (a &gt; 0)
        do_something();
</pre></div>
</div>
<p>If the compiler can prove that do_something() does not store to the
variable a, then the compiler is within its rights transforming this to
the following:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>tmp = a;
if (a &gt; 0)
        for (;;)
                do_something();
</pre></div>
</div>
<p>If you don’t want the compiler to do this (and you probably don’t), then
you should use something like the following:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>while (READ_ONCE(a) &lt; 0)
        do_something();
</pre></div>
</div>
<p>Alternatively, you could place a barrier() call in the loop.</p>
<p>For another example, consider the following code:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>tmp_a = a;
do_something_with(tmp_a);
do_something_else_with(tmp_a);
</pre></div>
</div>
<p>If the compiler can prove that do_something_with() does not store to the
variable a, then the compiler is within its rights to manufacture an
additional load as follows:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>tmp_a = a;
do_something_with(tmp_a);
tmp_a = a;
do_something_else_with(tmp_a);
</pre></div>
</div>
<p>This could fatally confuse your code if it expected the same value
to be passed to do_something_with() and do_something_else_with().</p>
<p>The compiler would be likely to manufacture this additional load if
do_something_with() was an inline function that made very heavy use
of registers: reloading from variable a could save a flush to the
stack and later reload.  To prevent the compiler from attacking your
code in this manner, write the following:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>tmp_a = READ_ONCE(a);
do_something_with(tmp_a);
do_something_else_with(tmp_a);
</pre></div>
</div>
<p>For a final example, consider the following code, assuming that the
variable a is set at boot time before the second CPU is brought online
and never changed later, so that memory barriers are not needed:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>if (a)
        b = 9;
else
        b = 42;
</pre></div>
</div>
<p>The compiler is within its rights to manufacture an additional store
by transforming the above code into the following:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>b = 42;
if (a)
        b = 9;
</pre></div>
</div>
<p>This could come as a fatal surprise to other code running concurrently
that expected b to never have the value 42 if a was zero.  To prevent
the compiler from doing this, write something like:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>if (a)
        WRITE_ONCE(b, 9);
else
        WRITE_ONCE(b, 42);
</pre></div>
</div>
<p>Don’t even -think- about doing this without proper use of memory barriers,
locks, or atomic operations if variable a can change at runtime!</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal"><span class="pre">READ_ONCE()</span></code> OR <code class="docutils literal"><span class="pre">WRITE_ONCE()</span></code> DO NOT IMPLY A BARRIER!</p>
</div>
<p>Now, we move onto the atomic operation interfaces typically implemented with
the help of assembly code.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void atomic_add(int i, atomic_t *v);
void atomic_sub(int i, atomic_t *v);
void atomic_inc(atomic_t *v);
void atomic_dec(atomic_t *v);
</pre></div>
</div>
<p>These four routines add and subtract integral values to/from the given
atomic_t value.  The first two routines pass explicit integers by
which to make the adjustment, whereas the latter two use an implicit
adjustment value of “1”.</p>
<p>One very important aspect of these two routines is that they DO NOT
require any explicit memory barriers.  They need only perform the
atomic_t counter update in an SMP safe manner.</p>
<p>Next, we have:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int atomic_inc_return(atomic_t *v);
int atomic_dec_return(atomic_t *v);
</pre></div>
</div>
<p>These routines add 1 and subtract 1, respectively, from the given
atomic_t and return the new counter value after the operation is
performed.</p>
<p>Unlike the above routines, it is required that these primitives
include explicit memory barriers that are performed before and after
the operation.  It must be done such that all memory operations before
and after the atomic operation calls are strongly ordered with respect
to the atomic operation itself.</p>
<p>For example, it should behave as if a smp_mb() call existed both
before and after the atomic operation.</p>
<p>If the atomic instructions used in an implementation provide explicit
memory barrier semantics which satisfy the above requirements, that is
fine as well.</p>
<p>Let’s move on:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int atomic_add_return(int i, atomic_t *v);
int atomic_sub_return(int i, atomic_t *v);
</pre></div>
</div>
<p>These behave just like atomic_{inc,dec}_return() except that an
explicit counter adjustment is given instead of the implicit “1”.
This means that like atomic_{inc,dec}_return(), the memory barrier
semantics are required.</p>
<p>Next:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int atomic_inc_and_test(atomic_t *v);
int atomic_dec_and_test(atomic_t *v);
</pre></div>
</div>
<p>These two routines increment and decrement by 1, respectively, the
given atomic counter.  They return a boolean indicating whether the
resulting counter value was zero or not.</p>
<p>Again, these primitives provide explicit memory barrier semantics around
the atomic operation:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int atomic_sub_and_test(int i, atomic_t *v);
</pre></div>
</div>
<p>This is identical to atomic_dec_and_test() except that an explicit
decrement is given instead of the implicit “1”.  This primitive must
provide explicit memory barrier semantics around the operation:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int atomic_add_negative(int i, atomic_t *v);
</pre></div>
</div>
<p>The given increment is added to the given atomic counter value.  A boolean
is return which indicates whether the resulting counter value is negative.
This primitive must provide explicit memory barrier semantics around
the operation.</p>
<p>Then:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int atomic_xchg(atomic_t *v, int new);
</pre></div>
</div>
<p>This performs an atomic exchange operation on the atomic variable v, setting
the given new value.  It returns the old value that the atomic variable v had
just before the operation.</p>
<p>atomic_xchg must provide explicit memory barriers around the operation.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int atomic_cmpxchg(atomic_t *v, int old, int new);
</pre></div>
</div>
<p>This performs an atomic compare exchange operation on the atomic value v,
with the given old and new values. Like all atomic_xxx operations,
atomic_cmpxchg will only satisfy its atomicity semantics as long as all
other accesses of *v are performed through atomic_xxx operations.</p>
<p>atomic_cmpxchg must provide explicit memory barriers around the operation,
although if the comparison fails then no memory ordering guarantees are
required.</p>
<p>The semantics for atomic_cmpxchg are the same as those defined for ‘cas’
below.</p>
<p>Finally:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int atomic_add_unless(atomic_t *v, int a, int u);
</pre></div>
</div>
<p>If the atomic value v is not equal to u, this function adds a to v, and
returns non zero. If v is equal to u then it returns zero. This is done as
an atomic operation.</p>
<p>atomic_add_unless must provide explicit memory barriers around the
operation unless it fails (returns 0).</p>
<p>atomic_inc_not_zero, equivalent to atomic_add_unless(v, 1, 0)</p>
<p>If a caller requires memory barrier semantics around an atomic_t
operation which does not return a value, a set of interfaces are
defined which accomplish this:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void smp_mb__before_atomic(void);
void smp_mb__after_atomic(void);
</pre></div>
</div>
<p>Preceding a non-value-returning read-modify-write atomic operation with
smp_mb__before_atomic() and following it with smp_mb__after_atomic()
provides the same full ordering that is provided by value-returning
read-modify-write atomic operations.</p>
<p>For example, smp_mb__before_atomic() can be used like so:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>obj-&gt;dead = 1;
smp_mb__before_atomic();
atomic_dec(&amp;obj-&gt;ref_count);
</pre></div>
</div>
<p>It makes sure that all memory operations preceding the atomic_dec()
call are strongly ordered with respect to the atomic counter
operation.  In the above example, it guarantees that the assignment of
“1” to obj-&gt;dead will be globally visible to other cpus before the
atomic counter decrement.</p>
<p>Without the explicit smp_mb__before_atomic() call, the
implementation could legally allow the atomic counter update visible
to other cpus before the “obj-&gt;dead = 1;” assignment.</p>
<p>A missing memory barrier in the cases where they are required by the
atomic_t implementation above can have disastrous results.  Here is
an example, which follows a pattern occurring frequently in the Linux
kernel.  It is the use of atomic counters to implement reference
counting, and it works such that once the counter falls to zero it can
be guaranteed that no other entity can be accessing the object:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static void obj_list_add(struct obj *obj, struct list_head *head)
{
        obj-&gt;active = 1;
        list_add(&amp;obj-&gt;list, head);
}

static void obj_list_del(struct obj *obj)
{
        list_del(&amp;obj-&gt;list);
        obj-&gt;active = 0;
}

static void obj_destroy(struct obj *obj)
{
        BUG_ON(obj-&gt;active);
        kfree(obj);
}

struct obj *obj_list_peek(struct list_head *head)
{
        if (!list_empty(head)) {
                struct obj *obj;

                obj = list_entry(head-&gt;next, struct obj, list);
                atomic_inc(&amp;obj-&gt;refcnt);
                return obj;
        }
        return NULL;
}

void obj_poke(void)
{
        struct obj *obj;

        spin_lock(&amp;global_list_lock);
        obj = obj_list_peek(&amp;global_list);
        spin_unlock(&amp;global_list_lock);

        if (obj) {
                obj-&gt;ops-&gt;poke(obj);
                if (atomic_dec_and_test(&amp;obj-&gt;refcnt))
                        obj_destroy(obj);
        }
}

void obj_timeout(struct obj *obj)
{
        spin_lock(&amp;global_list_lock);
        obj_list_del(obj);
        spin_unlock(&amp;global_list_lock);

        if (atomic_dec_and_test(&amp;obj-&gt;refcnt))
                obj_destroy(obj);
}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a simplification of the ARP queue management in the generic
neighbour discover code of the networking.  Olaf Kirch found a bug wrt.
memory barriers in kfree_skb() that exposed the atomic_t memory barrier
requirements quite clearly.</p>
</div>
<p>Given the above scheme, it must be the case that the obj-&gt;active
update done by the obj list deletion be visible to other processors
before the atomic counter decrement is performed.</p>
<p>Otherwise, the counter could fall to zero, yet obj-&gt;active would still
be set, thus triggering the assertion in obj_destroy().  The error
sequence looks like this:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>cpu 0                           cpu 1
obj_poke()                      obj_timeout()
obj = obj_list_peek();
... gains ref to obj, refcnt=2
                                obj_list_del(obj);
                                obj-&gt;active = 0 ...
                                ... visibility delayed ...
                                atomic_dec_and_test()
                                ... refcnt drops to 1 ...
atomic_dec_and_test()
... refcount drops to 0 ...
obj_destroy()
BUG() triggers since obj-&gt;active
still seen as one
                                obj-&gt;active update visibility occurs
</pre></div>
</div>
<p>With the memory barrier semantics required of the atomic_t operations
which return values, the above sequence of memory visibility can never
happen.  Specifically, in the above case the atomic_dec_and_test()
counter decrement would not become globally visible until the
obj-&gt;active update does.</p>
<p>As a historical note, 32-bit Sparc used to only allow usage of
24-bits of its atomic_t type.  This was because it used 8 bits
as a spinlock for SMP safety.  Sparc32 lacked a “compare and swap”
type instruction.  However, 32-bit Sparc has since been moved over
to a “hash table of spinlocks” scheme, that allows the full 32-bit
counter to be realized.  Essentially, an array of spinlocks are
indexed into based upon the address of the atomic_t being operated
on, and that lock protects the atomic operation.  Parisc uses the
same scheme.</p>
<p>Another note is that the atomic_t operations returning values are
extremely slow on an old 386.</p>
</div>
<div class="section" id="atomic-bitmask">
<h2>Atomic Bitmask<a class="headerlink" href="#atomic-bitmask" title="Permalink to this headline">¶</a></h2>
<p>We will now cover the atomic bitmask operations.  You will find that
their SMP and memory barrier semantics are similar in shape and scope
to the atomic_t ops above.</p>
<p>Native atomic bit operations are defined to operate on objects aligned
to the size of an “unsigned long” C data type, and are least of that
size.  The endianness of the bits within each “unsigned long” are the
native endianness of the cpu.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void set_bit(unsigned long nr, volatile unsigned long *addr);
void clear_bit(unsigned long nr, volatile unsigned long *addr);
void change_bit(unsigned long nr, volatile unsigned long *addr);
</pre></div>
</div>
<p>These routines set, clear, and change, respectively, the bit number
indicated by “nr” on the bit mask pointed to by “ADDR”.</p>
<p>They must execute atomically, yet there are no implicit memory barrier
semantics required of these interfaces.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int test_and_set_bit(unsigned long nr, volatile unsigned long *addr);
int test_and_clear_bit(unsigned long nr, volatile unsigned long *addr);
int test_and_change_bit(unsigned long nr, volatile unsigned long *addr);
</pre></div>
</div>
<p>Like the above, except that these routines return a boolean which
indicates whether the changed bit was set _BEFORE_ the atomic bit
operation.</p>
<p>WARNING! It is incredibly important that the value be a boolean,
ie. “0” or “1”.  Do not try to be fancy and save a few instructions by
declaring the above to return “long” and just returning something like
“old_val &amp; mask” because that will not work.</p>
<p>For one thing, this return value gets truncated to int in many code
paths using these interfaces, so on 64-bit if the bit is set in the
upper 32-bits then testers will never see that.</p>
<p>One great example of where this problem crops up are the thread_info
flag operations.  Routines such as test_and_set_ti_thread_flag() chop
the return value into an int.  There are other places where things
like this occur as well.</p>
<p>These routines, like the atomic_t counter operations returning values,
must provide explicit memory barrier semantics around their execution.
All memory operations before the atomic bit operation call must be
made visible globally before the atomic bit operation is made visible.
Likewise, the atomic bit operation must be visible globally before any
subsequent memory operation is made visible.  For example:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>obj-&gt;dead = 1;
if (test_and_set_bit(0, &amp;obj-&gt;flags))
        /* ... */;
obj-&gt;killed = 1;
</pre></div>
</div>
<p>The implementation of test_and_set_bit() must guarantee that
“obj-&gt;dead = 1;” is visible to cpus before the atomic memory operation
done by test_and_set_bit() becomes visible.  Likewise, the atomic
memory operation done by test_and_set_bit() must become visible before
“obj-&gt;killed = 1;” is visible.</p>
<p>Finally there is the basic operation:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int test_bit(unsigned long nr, __const__ volatile unsigned long *addr);
</pre></div>
</div>
<p>Which returns a boolean indicating if bit “nr” is set in the bitmask
pointed to by “addr”.</p>
<p>If explicit memory barriers are required around {set,clear}_bit() (which do
not return a value, and thus does not need to provide memory barrier
semantics), two interfaces are provided:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void smp_mb__before_atomic(void);
void smp_mb__after_atomic(void);
</pre></div>
</div>
<p>They are used as follows, and are akin to their atomic_t operation
brothers:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>/* All memory operations before this call will
 * be globally visible before the clear_bit().
 */
smp_mb__before_atomic();
clear_bit( ... );

/* The clear_bit() will be visible before all
 * subsequent memory operations.
 */
 smp_mb__after_atomic();
</pre></div>
</div>
<p>There are two special bitops with lock barrier semantics (acquire/release,
same as spinlocks). These operate in the same way as their non-_lock/unlock
postfixed variants, except that they are to provide acquire/release semantics,
respectively. This means they can be used for bit_spin_trylock and
bit_spin_unlock type operations without specifying any more barriers.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int test_and_set_bit_lock(unsigned long nr, unsigned long *addr);
void clear_bit_unlock(unsigned long nr, unsigned long *addr);
void __clear_bit_unlock(unsigned long nr, unsigned long *addr);
</pre></div>
</div>
<p>The __clear_bit_unlock version is non-atomic, however it still implements
unlock barrier semantics. This can be useful if the lock itself is protecting
the other bits in the word.</p>
<p>Finally, there are non-atomic versions of the bitmask operations
provided.  They are used in contexts where some other higher-level SMP
locking scheme is being used to protect the bitmask, and thus less
expensive non-atomic operations may be used in the implementation.
They have names similar to the above bitmask operation interfaces,
except that two underscores are prefixed to the interface name.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void __set_bit(unsigned long nr, volatile unsigned long *addr);
void __clear_bit(unsigned long nr, volatile unsigned long *addr);
void __change_bit(unsigned long nr, volatile unsigned long *addr);
int __test_and_set_bit(unsigned long nr, volatile unsigned long *addr);
int __test_and_clear_bit(unsigned long nr, volatile unsigned long *addr);
int __test_and_change_bit(unsigned long nr, volatile unsigned long *addr);
</pre></div>
</div>
<p>These non-atomic variants also do not require any special memory
barrier semantics.</p>
<p>The routines xchg() and cmpxchg() must provide the same exact
memory-barrier semantics as the atomic and bit operations returning
values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If someone wants to use xchg(), cmpxchg() and their variants,
linux/atomic.h should be included rather than asm/cmpxchg.h, unless the
code is in arch/* and can take care of itself.</p>
</div>
<p>Spinlocks and rwlocks have memory barrier expectations as well.
The rule to follow is simple:</p>
<ol class="arabic simple">
<li>When acquiring a lock, the implementation must make it globally
visible before any subsequent memory operation.</li>
<li>When releasing a lock, the implementation must make it such that
all previous memory operations are globally visible before the
lock release.</li>
</ol>
<p>Which finally brings us to _atomic_dec_and_lock().  There is an
architecture-neutral version implemented in lib/dec_and_lock.c,
but most platforms will wish to optimize this in assembler.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock);
</pre></div>
</div>
<p>Atomically decrement the given counter, and if will drop to zero
atomically acquire the given spinlock and perform the decrement
of the counter to zero.  If it does not drop to zero, do nothing
with the spinlock.</p>
<p>It is actually pretty simple to get the memory barrier correct.
Simply satisfy the spinlock grab requirements, which is make
sure the spinlock operation is globally visible before any
subsequent memory operation.</p>
<p>We can demonstrate this operation more clearly if we define
an abstract atomic operation:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>long cas(long *mem, long old, long new);
</pre></div>
</div>
<p>“cas” stands for “compare and swap”.  It atomically:</p>
<ol class="arabic simple">
<li>Compares “old” with the value currently at “mem”.</li>
<li>If they are equal, “new” is written to “mem”.</li>
<li>Regardless, the current value at “mem” is returned.</li>
</ol>
<p>As an example usage, here is what an atomic counter update
might look like:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void example_atomic_inc(long *counter)
{
        long old, new, ret;

        while (1) {
                old = *counter;
                new = old + 1;

                ret = cas(counter, old, new);
                if (ret == old)
                        break;
        }
}
</pre></div>
</div>
<p>Let’s use cas() in order to build a pseudo-C atomic_dec_and_lock():</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>int _atomic_dec_and_lock(atomic_t *atomic, spinlock_t *lock)
{
        long old, new, ret;
        int went_to_zero;

        went_to_zero = 0;
        while (1) {
                old = atomic_read(atomic);
                new = old - 1;
                if (new == 0) {
                        went_to_zero = 1;
                        spin_lock(lock);
                }
                ret = cas(atomic, old, new);
                if (ret == old)
                        break;
                if (went_to_zero) {
                        spin_unlock(lock);
                        went_to_zero = 0;
                }
        }

        return went_to_zero;
}
</pre></div>
</div>
<p>Now, as far as memory barriers go, as long as spin_lock()
strictly orders all subsequent memory operations (including
the cas()) with respect to itself, things will be fine.</p>
<p>Said another way, _atomic_dec_and_lock() must guarantee that
a counter dropping to zero is never made visible before the
spinlock being acquired.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that this also means that for the case where the counter is not
dropping to zero, there are no memory ordering requirements.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cpu_hotplug.html" class="btn btn-neutral float-right" title="CPU hotplug in the Kernel" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="assoc_array.html" class="btn btn-neutral" title="Generic Associative Array Implementation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>