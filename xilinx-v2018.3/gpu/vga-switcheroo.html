

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>VGA Switcheroo &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="VGA Arbiter" href="vgaarbiter.html" />
    <link rel="prev" title="drm/vc4 Broadcom VC4 Graphics Driver" href="vc4.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">VGA Switcheroo</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modes-of-use">Modes of Use</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#manual-switching-and-manual-power-control">Manual switching and manual power control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-power-control">Driver power control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#api">API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#public-functions">Public functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#public-structures">Public structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#public-constants">Public constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#private-structures">Private structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#handlers">Handlers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#apple-gmux-handler">apple-gmux Handler</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
      <li>VGA Switcheroo</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/vga-switcheroo.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="vga-switcheroo">
<span id="id1"></span><h1>VGA Switcheroo<a class="headerlink" href="#vga-switcheroo" title="Permalink to this headline">¶</a></h1>
<p>vga_switcheroo is the Linux subsystem for laptop hybrid graphics.
These come in two flavors:</p>
<ul class="simple">
<li>muxed: Dual GPUs with a multiplexer chip to switch outputs between GPUs.</li>
<li>muxless: Dual GPUs but only one of them is connected to outputs.
The other one is merely used to offload rendering, its results
are copied over PCIe into the framebuffer. On Linux this is
supported with DRI PRIME.</li>
</ul>
<p>Hybrid graphics started to appear in the late Naughties and were initially
all muxed. Newer laptops moved to a muxless architecture for cost reasons.
A notable exception is the MacBook Pro which continues to use a mux.
Muxes come with varying capabilities: Some switch only the panel, others
can also switch external displays. Some switch all display pins at once
while others can switch just the DDC lines. (To allow EDID probing
for the inactive GPU.) Also, muxes are often used to cut power to the
discrete GPU while it is not used.</p>
<p>DRM drivers register GPUs with vga_switcheroo, these are henceforth called
clients. The mux is called the handler. Muxless machines also register a
handler to control the power state of the discrete GPU, its -&gt;switchto
callback is a no-op for obvious reasons. The discrete GPU is often equipped
with an HDA controller for the HDMI/DP audio signal, this will also
register as a client so that vga_switcheroo can take care of the correct
suspend/resume order when changing the discrete GPU’s power state. In total
there can thus be up to three clients: Two vga clients (GPUs) and one audio
client (on the discrete GPU). The code is mostly prepared to support
machines with more than two GPUs should they become available.</p>
<p>The GPU to which the outputs are currently switched is called the
active client in vga_switcheroo parlance. The GPU not in use is the
inactive client. When the inactive client’s DRM driver is loaded,
it will be unable to probe the panel’s EDID and hence depends on
VBIOS to provide its display modes. If the VBIOS modes are bogus or
if there is no VBIOS at all (which is common on the MacBook Pro),
a client may alternatively request that the DDC lines are temporarily
switched to it, provided that the handler supports this. Switching
only the DDC lines and not the entire output avoids unnecessary
flickering.</p>
<div class="section" id="modes-of-use">
<h2>Modes of Use<a class="headerlink" href="#modes-of-use" title="Permalink to this headline">¶</a></h2>
<div class="section" id="manual-switching-and-manual-power-control">
<h3>Manual switching and manual power control<a class="headerlink" href="#manual-switching-and-manual-power-control" title="Permalink to this headline">¶</a></h3>
<p>In this mode of use, the file /sys/kernel/debug/vgaswitcheroo/switch
can be read to retrieve the current vga_switcheroo state and commands
can be written to it to change the state. The file appears as soon as
two GPU drivers and one handler have registered with vga_switcheroo.
The following commands are understood:</p>
<ul class="simple">
<li>OFF: Power off the device not in use.</li>
<li>ON: Power on the device not in use.</li>
<li>IGD: Switch to the integrated graphics device.
Power on the integrated GPU if necessary, power off the discrete GPU.
Prerequisite is that no user space processes (e.g. Xorg, alsactl)
have opened device files of the GPUs or the audio client. If the
switch fails, the user may invoke lsof(8) or fuser(1) on /dev/dri/
and /dev/snd/controlC1 to identify processes blocking the switch.</li>
<li>DIS: Switch to the discrete graphics device.</li>
<li>DIGD: Delayed switch to the integrated graphics device.
This will perform the switch once the last user space process has
closed the device files of the GPUs and the audio client.</li>
<li>DDIS: Delayed switch to the discrete graphics device.</li>
<li>MIGD: Mux-only switch to the integrated graphics device.
Does not remap console or change the power state of either gpu.
If the integrated GPU is currently off, the screen will turn black.
If it is on, the screen will show whatever happens to be in VRAM.
Either way, the user has to blindly enter the command to switch back.</li>
<li>MDIS: Mux-only switch to the discrete graphics device.</li>
</ul>
<p>For GPUs whose power state is controlled by the driver’s runtime pm,
the ON and OFF commands are a no-op (see next section).</p>
<p>For muxless machines, the IGD/DIS, DIGD/DDIS and MIGD/MDIS commands
should not be used.</p>
</div>
<div class="section" id="driver-power-control">
<h3>Driver power control<a class="headerlink" href="#driver-power-control" title="Permalink to this headline">¶</a></h3>
<p>In this mode of use, the discrete GPU automatically powers up and down at
the discretion of the driver’s runtime pm. On muxed machines, the user may
still influence the muxer state by way of the debugfs interface, however
the ON and OFF commands become a no-op for the discrete GPU.</p>
<p>This mode is the default on Nvidia HybridPower/Optimus and ATI PowerXpress.
Specifying nouveau.runpm=0, radeon.runpm=0 or amdgpu.runpm=0 on the kernel
command line disables it.</p>
<p>When the driver decides to power up or down, it notifies vga_switcheroo
thereof so that it can (a) power the audio device on the GPU up or down,
and (b) update its internal power state representation for the device.
This is achieved by <a class="reference internal" href="#c.vga_switcheroo_set_dynamic_switch" title="vga_switcheroo_set_dynamic_switch"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_set_dynamic_switch()</span></code></a>.</p>
<p>After the GPU has been suspended, the handler needs to be called to cut
power to the GPU. Likewise it needs to reinstate power before the GPU
can resume. This is achieved by <a class="reference internal" href="#c.vga_switcheroo_init_domain_pm_ops" title="vga_switcheroo_init_domain_pm_ops"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_init_domain_pm_ops()</span></code></a>,
which augments the GPU’s suspend/resume functions by the requisite
calls to the handler.</p>
<p>When the audio device resumes, the GPU needs to be woken. This is achieved
by <a class="reference internal" href="#c.vga_switcheroo_init_domain_pm_optimus_hdmi_audio" title="vga_switcheroo_init_domain_pm_optimus_hdmi_audio"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_init_domain_pm_optimus_hdmi_audio()</span></code></a>, which augments the
audio device’s resume function.</p>
<p>On muxed machines, if the mux is initially switched to the discrete GPU,
the user ends up with a black screen when the GPU powers down after boot.
As a workaround, the mux is forced to the integrated GPU on runtime suspend,
cf. <a class="reference external" href="https://bugs.freedesktop.org/show_bug.cgi?id=75917">https://bugs.freedesktop.org/show_bug.cgi?id=75917</a></p>
</div>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="public-functions">
<h3>Public functions<a class="headerlink" href="#public-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.vga_switcheroo_register_handler">
int <code class="descname">vga_switcheroo_register_handler</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.vga_switcheroo_handler" title="vga_switcheroo_handler">vga_switcheroo_handler</a> *<em>&nbsp;handler</em>, enum <a class="reference internal" href="#c.vga_switcheroo_handler_flags_t" title="vga_switcheroo_handler_flags_t">vga_switcheroo_handler_flags_t</a><em>&nbsp;handler_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_register_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>register handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vga_switcheroo_handler</span> <span class="pre">*</span> <span class="pre">handler</span></code></dt>
<dd>handler callbacks</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vga_switcheroo_handler_flags_t</span> <span class="pre">handler_flags</span></code></dt>
<dd>handler flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register handler. Enable vga_switcheroo if two vga clients have already
registered.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if a handler was already registered.</p>
<dl class="function">
<dt id="c.vga_switcheroo_unregister_handler">
void <code class="descname">vga_switcheroo_unregister_handler</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_unregister_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister handler. Disable vga_switcheroo.</p>
<dl class="function">
<dt id="c.vga_switcheroo_handler_flags">
enum <a class="reference internal" href="#c.vga_switcheroo_handler_flags_t" title="vga_switcheroo_handler_flags_t">vga_switcheroo_handler_flags_t</a> <code class="descname">vga_switcheroo_handler_flags</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_handler_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain handler flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for clients to obtain the handler flags bitmask.</p>
<p><strong>Return</strong></p>
<p>Handler flags. A value of 0 means that no handler is registered
or that the handler has no special capabilities.</p>
<dl class="function">
<dt id="c.vga_switcheroo_register_client">
int <code class="descname">vga_switcheroo_register_client</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, const struct <a class="reference internal" href="#c.vga_switcheroo_client_ops" title="vga_switcheroo_client_ops">vga_switcheroo_client_ops</a> *<em>&nbsp;ops</em>, bool<em>&nbsp;driver_power_control</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_register_client" title="Permalink to this definition">¶</a></dt>
<dd><p>register vga client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vga_switcheroo_client_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>client callbacks</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">driver_power_control</span></code></dt>
<dd>whether power state is controlled by the driver’s
runtime pm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register vga client (GPU). Enable vga_switcheroo if another GPU and a
handler have already registered. The power state of the client is assumed
to be ON. Beforehand, <a class="reference internal" href="#c.vga_switcheroo_client_probe_defer" title="vga_switcheroo_client_probe_defer"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_client_probe_defer()</span></code></a> shall be called
to ensure that all prerequisites are met.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM on memory allocation error.</p>
<dl class="function">
<dt id="c.vga_switcheroo_register_audio_client">
int <code class="descname">vga_switcheroo_register_audio_client</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, const struct <a class="reference internal" href="#c.vga_switcheroo_client_ops" title="vga_switcheroo_client_ops">vga_switcheroo_client_ops</a> *<em>&nbsp;ops</em>, enum <a class="reference internal" href="#c.vga_switcheroo_client_id" title="vga_switcheroo_client_id">vga_switcheroo_client_id</a><em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_register_audio_client" title="Permalink to this definition">¶</a></dt>
<dd><p>register audio client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">vga_switcheroo_client_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>client callbacks</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vga_switcheroo_client_id</span> <span class="pre">id</span></code></dt>
<dd>client identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register audio client (audio device on a GPU). The power state of the
client is assumed to be ON. Beforehand, <a class="reference internal" href="#c.vga_switcheroo_client_probe_defer" title="vga_switcheroo_client_probe_defer"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_client_probe_defer()</span></code></a>
shall be called to ensure that all prerequisites are met.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOMEM on memory allocation error.</p>
<dl class="function">
<dt id="c.vga_switcheroo_client_probe_defer">
bool <code class="descname">vga_switcheroo_client_probe_defer</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_client_probe_defer" title="Permalink to this definition">¶</a></dt>
<dd><p>whether to defer probing a given client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether any prerequisites are not fulfilled to probe a given
client. Drivers shall invoke this early on in their -&gt;probe callback
and return <code class="docutils literal"><span class="pre">-EPROBE_DEFER</span></code> if it evaluates to <code class="docutils literal"><span class="pre">true</span></code>. Thou shalt not
register the client ere thou hast called this.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if probing should be deferred, otherwise <code class="docutils literal"><span class="pre">false</span></code>.</p>
<dl class="function">
<dt id="c.vga_switcheroo_get_client_state">
enum <a class="reference internal" href="#c.vga_switcheroo_state" title="vga_switcheroo_state">vga_switcheroo_state</a> <code class="descname">vga_switcheroo_get_client_state</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_get_client_state" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain power state of a given client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Obtain power state of a given client as seen from vga_switcheroo.
The function is only called from hda_intel.c.</p>
<p><strong>Return</strong></p>
<p>Power state.</p>
<dl class="function">
<dt id="c.vga_switcheroo_unregister_client">
void <code class="descname">vga_switcheroo_unregister_client</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_unregister_client" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister client. Disable vga_switcheroo if this is a vga client (GPU).</p>
<dl class="function">
<dt id="c.vga_switcheroo_client_fb_set">
void <code class="descname">vga_switcheroo_client_fb_set</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, struct fb_info *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_client_fb_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set framebuffer of a given client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fb_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set framebuffer of a given client. The console will be remapped to this
on switching.</p>
<dl class="function">
<dt id="c.vga_switcheroo_lock_ddc">
int <code class="descname">vga_switcheroo_lock_ddc</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_lock_ddc" title="Permalink to this definition">¶</a></dt>
<dd><p>temporarily switch DDC lines to a given client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Temporarily switch DDC lines to the client identified by <strong>pdev</strong>
(but leave the outputs otherwise switched to where they are).
This allows the inactive client to probe EDID. The DDC lines must
afterwards be switched back by calling <a class="reference internal" href="#c.vga_switcheroo_unlock_ddc" title="vga_switcheroo_unlock_ddc"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_unlock_ddc()</span></code></a>,
even if this function returns an error.</p>
<p><strong>Return</strong></p>
<p>Previous DDC owner on success or a negative int on error.
Specifically, <code class="docutils literal"><span class="pre">-ENODEV</span></code> if no handler has registered or if the handler
does not support switching the DDC lines. Also, a negative value
returned by the handler is propagated back to the caller.
The return value has merely an informational purpose for any caller
which might be interested in it. It is acceptable to ignore the return
value and simply rely on the result of the subsequent EDID probe,
which will be <code class="docutils literal"><span class="pre">NULL</span></code> if DDC switching failed.</p>
<dl class="function">
<dt id="c.vga_switcheroo_unlock_ddc">
int <code class="descname">vga_switcheroo_unlock_ddc</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_unlock_ddc" title="Permalink to this definition">¶</a></dt>
<dd><p>switch DDC lines back to previous owner</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Switch DDC lines back to the previous owner after calling
<a class="reference internal" href="#c.vga_switcheroo_lock_ddc" title="vga_switcheroo_lock_ddc"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_lock_ddc()</span></code></a>. This must be called even if
<a class="reference internal" href="#c.vga_switcheroo_lock_ddc" title="vga_switcheroo_lock_ddc"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_lock_ddc()</span></code></a> returned an error.</p>
<p><strong>Return</strong></p>
<p>Previous DDC owner on success (i.e. the client identifier of <strong>pdev</strong>)
or a negative int on error.
Specifically, <code class="docutils literal"><span class="pre">-ENODEV</span></code> if no handler has registered or if the handler
does not support switching the DDC lines. Also, a negative value
returned by the handler is propagated back to the caller.
Finally, invoking this function without calling <a class="reference internal" href="#c.vga_switcheroo_lock_ddc" title="vga_switcheroo_lock_ddc"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_lock_ddc()</span></code></a>
first is not allowed and will result in <code class="docutils literal"><span class="pre">-EINVAL</span></code>.</p>
<dl class="function">
<dt id="c.vga_switcheroo_process_delayed_switch">
int <code class="descname">vga_switcheroo_process_delayed_switch</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_process_delayed_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for delayed switching</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Process a delayed switch if one is pending. DRM drivers should call this
from their -&gt;lastclose callback.</p>
<p><strong>Return</strong></p>
<p>0 on success. -EINVAL if no delayed switch is pending, if the client
has unregistered in the meantime or if there are other clients blocking the
switch. If the actual switch fails, an error is reported and 0 is returned.</p>
<dl class="function">
<dt id="c.vga_switcheroo_set_dynamic_switch">
void <code class="descname">vga_switcheroo_set_dynamic_switch</code><span class="sig-paren">(</span>struct pci_dev *<em>&nbsp;pdev</em>, enum <a class="reference internal" href="#c.vga_switcheroo_state" title="vga_switcheroo_state">vga_switcheroo_state</a><em>&nbsp;dynamic</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_set_dynamic_switch" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for driver power control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vga_switcheroo_state</span> <span class="pre">dynamic</span></code></dt>
<dd>new power state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for GPUs whose power state is controlled by the driver’s runtime pm.
When the driver decides to power up or down, it notifies vga_switcheroo
thereof using this helper so that it can (a) power the audio device on
the GPU up or down, and (b) update its internal power state representation
for the device.</p>
<dl class="function">
<dt id="c.vga_switcheroo_init_domain_pm_ops">
int <code class="descname">vga_switcheroo_init_domain_pm_ops</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/pm/types.html#c.dev_pm_domain" title="dev_pm_domain">dev_pm_domain</a> *<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_init_domain_pm_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for driver power control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>vga client device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span> <span class="pre">*</span> <span class="pre">domain</span></code></dt>
<dd>power domain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for GPUs whose power state is controlled by the driver’s runtime pm.
After the GPU has been suspended, the handler needs to be called to cut
power to the GPU. Likewise it needs to reinstate power before the GPU
can resume. To this end, this helper augments the suspend/resume functions
by the requisite calls to the handler. It needs only be called on platforms
where the power switch is separate to the device being powered down.</p>
<dl class="function">
<dt id="c.vga_switcheroo_init_domain_pm_optimus_hdmi_audio">
int <code class="descname">vga_switcheroo_init_domain_pm_optimus_hdmi_audio</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/pm/types.html#c.dev_pm_domain" title="dev_pm_domain">dev_pm_domain</a> *<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vga_switcheroo_init_domain_pm_optimus_hdmi_audio" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for driver power control</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>audio client device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span> <span class="pre">*</span> <span class="pre">domain</span></code></dt>
<dd>power domain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper for GPUs whose power state is controlled by the driver’s runtime pm.
When the audio device resumes, the GPU needs to be woken. This helper
augments the audio device’s resume function to do that.</p>
<p><strong>Return</strong></p>
<p>0 on success, -EINVAL if no power management operations are
defined for this device.</p>
</div>
<div class="section" id="public-structures">
<h3>Public structures<a class="headerlink" href="#public-structures" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.vga_switcheroo_handler">
struct <code class="descname">vga_switcheroo_handler</code><a class="headerlink" href="#c.vga_switcheroo_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>handler callbacks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vga_switcheroo_handler {
  int (* init) (void);
  int (* switchto) (enum vga_switcheroo_client_id id);
  int (* switch_ddc) (enum vga_switcheroo_client_id id);
  int (* power_state) (enum vga_switcheroo_client_id id, enum vga_switcheroo_state state);
  enum vga_switcheroo_client_id (* get_client_id) (struct pci_dev *pdev);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">init</span></code></dt>
<dd>initialize handler.
Optional. This gets called when vga_switcheroo is enabled, i.e. when
two vga clients have registered. It allows the handler to perform
some delayed initialization that depends on the existence of the
vga clients. Currently only the radeon and amdgpu drivers use this.
The return value is ignored</dd>
<dt><code class="docutils literal"><span class="pre">switchto</span></code></dt>
<dd>switch outputs to given client.
Mandatory. For muxless machines this should be a no-op. Returning 0
denotes success, anything else failure (in which case the switch is
aborted)</dd>
<dt><code class="docutils literal"><span class="pre">switch_ddc</span></code></dt>
<dd>switch DDC lines to given client.
Optional. Should return the previous DDC owner on success or a
negative int on failure</dd>
<dt><code class="docutils literal"><span class="pre">power_state</span></code></dt>
<dd>cut or reinstate power of given client.
Optional. The return value is ignored</dd>
<dt><code class="docutils literal"><span class="pre">get_client_id</span></code></dt>
<dd>determine if given pci device is integrated or discrete GPU.
Mandatory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handler callbacks. The multiplexer itself. The <strong>switchto</strong> and <strong>get_client_id</strong>
methods are mandatory, all others may be set to NULL.</p>
<dl class="type">
<dt id="c.vga_switcheroo_client_ops">
struct <code class="descname">vga_switcheroo_client_ops</code><a class="headerlink" href="#c.vga_switcheroo_client_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>client callbacks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vga_switcheroo_client_ops {
  void (* set_gpu_state) (struct pci_dev *dev, enum vga_switcheroo_state);
  void (* reprobe) (struct pci_dev *dev);
  bool (* can_switch) (struct pci_dev *dev);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">set_gpu_state</span></code></dt>
<dd>do the equivalent of suspend/resume for the card.
Mandatory. This should not cut power to the discrete GPU,
which is the job of the handler</dd>
<dt><code class="docutils literal"><span class="pre">reprobe</span></code></dt>
<dd>poll outputs.
Optional. This gets called after waking the GPU and switching
the outputs to it</dd>
<dt><code class="docutils literal"><span class="pre">can_switch</span></code></dt>
<dd>check if the device is in a position to switch now.
Mandatory. The client should return false if a user space process
has one of its device files open</dd>
</dl>
<p><strong>Description</strong></p>
<p>Client callbacks. A client can be either a GPU or an audio device on a GPU.
The <strong>set_gpu_state</strong> and <strong>can_switch</strong> methods are mandatory, <strong>reprobe</strong> may be
set to NULL. For audio clients, the <strong>reprobe</strong> member is bogus.</p>
</div>
<div class="section" id="public-constants">
<h3>Public constants<a class="headerlink" href="#public-constants" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.vga_switcheroo_handler_flags_t">
enum <code class="descname">vga_switcheroo_handler_flags_t</code><a class="headerlink" href="#c.vga_switcheroo_handler_flags_t" title="Permalink to this definition">¶</a></dt>
<dd><p>handler flags bitmask</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_CAN_SWITCH_DDC</span></code></dt>
<dd>whether the handler is able to switch the
DDC lines separately. This signals to clients that they should call
<a class="reference internal" href="drm-kms-helpers.html#c.drm_get_edid_switcheroo" title="drm_get_edid_switcheroo"><code class="xref c c-func docutils literal"><span class="pre">drm_get_edid_switcheroo()</span></code></a> to probe the EDID</dd>
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_NEEDS_EDP_CONFIG</span></code></dt>
<dd>whether the handler is unable to switch
the AUX channel separately. This signals to clients that the active
GPU needs to train the link and communicate the link parameters to the
inactive GPU (mediated by vga_switcheroo). The inactive GPU may then
skip the AUX handshake and set up its output with these pre-calibrated
values (DisplayPort specification v1.1a, section 2.5.3.3)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handler flags bitmask. Used by handlers to declare their capabilities upon
registering with vga_switcheroo.</p>
<dl class="type">
<dt id="c.vga_switcheroo_client_id">
enum <code class="descname">vga_switcheroo_client_id</code><a class="headerlink" href="#c.vga_switcheroo_client_id" title="Permalink to this definition">¶</a></dt>
<dd><p>client identifier</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_UNKNOWN_ID</span></code></dt>
<dd>initial identifier assigned to vga clients.
Determining the id requires the handler, so GPUs are given their
true id in a delayed fashion in <code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_enable()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_IGD</span></code></dt>
<dd>integrated graphics device</dd>
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_DIS</span></code></dt>
<dd>discrete graphics device</dd>
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_MAX_CLIENTS</span></code></dt>
<dd>currently no more than two GPUs are supported</dd>
</dl>
<p><strong>Description</strong></p>
<p>Client identifier. Audio clients use the same identifier &amp; 0x100.</p>
<dl class="type">
<dt id="c.vga_switcheroo_state">
enum <code class="descname">vga_switcheroo_state</code><a class="headerlink" href="#c.vga_switcheroo_state" title="Permalink to this definition">¶</a></dt>
<dd><p>client power state</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_OFF</span></code></dt>
<dd>off</dd>
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_ON</span></code></dt>
<dd>on</dd>
<dt><code class="docutils literal"><span class="pre">VGA_SWITCHEROO_NOT_FOUND</span></code></dt>
<dd>client has not registered with vga_switcheroo.
Only used in <a class="reference internal" href="#c.vga_switcheroo_get_client_state" title="vga_switcheroo_get_client_state"><code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_get_client_state()</span></code></a> which in turn is only
called from hda_intel.c</dd>
</dl>
<p><strong>Description</strong></p>
<p>Client power state.</p>
</div>
<div class="section" id="private-structures">
<h3>Private structures<a class="headerlink" href="#private-structures" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.vgasr_priv">
struct <code class="descname">vgasr_priv</code><a class="headerlink" href="#c.vgasr_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>vga_switcheroo private data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vgasr_priv {
  bool active;
  bool delayed_switch_active;
  enum vga_switcheroo_client_id delayed_client_id;
  struct dentry * debugfs_root;
  struct dentry * switch_file;
  int registered_clients;
  struct list_head clients;
  const struct vga_switcheroo_handler * handler;
  enum vga_switcheroo_handler_flags_t handler_flags;
  struct mutex mux_hw_lock;
  int old_ddc_owner;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">active</span></code></dt>
<dd>whether vga_switcheroo is enabled.
Prerequisite is the registration of two GPUs and a handler</dd>
<dt><code class="docutils literal"><span class="pre">delayed_switch_active</span></code></dt>
<dd>whether a delayed switch is pending</dd>
<dt><code class="docutils literal"><span class="pre">delayed_client_id</span></code></dt>
<dd>client to which a delayed switch is pending</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_root</span></code></dt>
<dd>directory for vga_switcheroo debugfs interface</dd>
<dt><code class="docutils literal"><span class="pre">switch_file</span></code></dt>
<dd>file for vga_switcheroo debugfs interface</dd>
<dt><code class="docutils literal"><span class="pre">registered_clients</span></code></dt>
<dd>number of registered GPUs
(counting only vga clients, not audio clients)</dd>
<dt><code class="docutils literal"><span class="pre">clients</span></code></dt>
<dd>list of registered clients</dd>
<dt><code class="docutils literal"><span class="pre">handler</span></code></dt>
<dd>registered handler</dd>
<dt><code class="docutils literal"><span class="pre">handler_flags</span></code></dt>
<dd>flags of registered handler</dd>
<dt><code class="docutils literal"><span class="pre">mux_hw_lock</span></code></dt>
<dd>protects mux state
(in particular while DDC lines are temporarily switched)</dd>
<dt><code class="docutils literal"><span class="pre">old_ddc_owner</span></code></dt>
<dd>client to which DDC lines will be switched back on unlock</dd>
</dl>
<p><strong>Description</strong></p>
<p>vga_switcheroo private data. Currently only one vga_switcheroo instance
per system is supported.</p>
<dl class="type">
<dt id="c.vga_switcheroo_client">
struct <code class="descname">vga_switcheroo_client</code><a class="headerlink" href="#c.vga_switcheroo_client" title="Permalink to this definition">¶</a></dt>
<dd><p>registered client</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct vga_switcheroo_client {
  struct pci_dev * pdev;
  struct fb_info * fb_info;
  enum vga_switcheroo_state pwr_state;
  const struct vga_switcheroo_client_ops * ops;
  enum vga_switcheroo_client_id id;
  bool active;
  bool driver_power_control;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pdev</span></code></dt>
<dd>client pci device</dd>
<dt><code class="docutils literal"><span class="pre">fb_info</span></code></dt>
<dd>framebuffer to which console is remapped on switching</dd>
<dt><code class="docutils literal"><span class="pre">pwr_state</span></code></dt>
<dd>current power state</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>client callbacks</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>client identifier. Determining the id requires the handler,
so gpus are initially assigned VGA_SWITCHEROO_UNKNOWN_ID
and later given their true id in <code class="xref c c-func docutils literal"><span class="pre">vga_switcheroo_enable()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">active</span></code></dt>
<dd>whether the outputs are currently switched to this client</dd>
<dt><code class="docutils literal"><span class="pre">driver_power_control</span></code></dt>
<dd>whether power state is controlled by the driver’s
runtime pm. If true, writing ON and OFF to the vga_switcheroo debugfs
interface is a no-op so as not to interfere with runtime pm</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>client list</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registered client. A client can be either a GPU or an audio device on a GPU.
For audio clients, the <strong>fb_info</strong>, <strong>active</strong> and <strong>driver_power_control</strong> members
are bogus.</p>
</div>
</div>
<div class="section" id="handlers">
<h2>Handlers<a class="headerlink" href="#handlers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="apple-gmux-handler">
<h3>apple-gmux Handler<a class="headerlink" href="#apple-gmux-handler" title="Permalink to this headline">¶</a></h3>
<p>gmux is a microcontroller built into the MacBook Pro to support dual GPUs:
A <a class="reference external" href="http://www.latticesemi.com/en/Products/FPGAandCPLD/LatticeXP2.aspx">Lattice XP2</a> on pre-retinas, a <a class="reference external" href="http://www.renesas.com/products/mpumcu/h8s/h8s2100/h8s2113/index.jsp">Renesas R4F2113</a> on retinas.</p>
<p>(The MacPro6,1 2013 also has a gmux, however it is unclear why since it has
dual GPUs but no built-in display.)</p>
<p>gmux is connected to the LPC bus of the southbridge. Its I/O ports are
accessed differently depending on the microcontroller: Driver functions
to access a pre-retina gmux are infixed <code class="docutils literal"><span class="pre">_pio_</span></code>, those for a retina gmux
are infixed <code class="docutils literal"><span class="pre">_index_</span></code>.</p>
<p>gmux is also connected to a GPIO pin of the southbridge and thereby is able
to trigger an ACPI GPE. On the MBP5 2008/09 it’s GPIO pin 22 of the Nvidia
MCP79, on all following generations it’s GPIO pin 6 of the Intel PCH.
The GPE merely signals that an interrupt occurred, the actual type of event
is identified by reading a gmux register.</p>
<div class="section" id="graphics-mux">
<h4>Graphics mux<a class="headerlink" href="#graphics-mux" title="Permalink to this headline">¶</a></h4>
<p>On pre-retinas, the LVDS outputs of both GPUs feed into gmux which muxes
either of them to the panel. One of the tricks gmux has up its sleeve is
to lengthen the blanking interval of its output during a switch to
synchronize it with the GPU switched to. This allows for a flicker-free
switch that is imperceptible by the user (<a class="reference external" href="http://pimg-fpiw.uspto.gov/fdd/07/870/086/0.pdf">US 8,687,007 B2</a>).</p>
<p>On retinas, muxing is no longer done by gmux itself, but by a separate
chip which is controlled by gmux. The chip is triple sourced, it is
either an <a class="reference external" href="http://www.nxp.com/documents/data_sheet/CBTL06141.pdf">NXP CBTL06142</a>, <a class="reference external" href="http://www.ti.com/lit/ds/symlink/hd3ss212.pdf">TI HD3SS212</a> or <a class="reference external" href="https://www.pericom.com/assets/Datasheets/PI3VDP12412.pdf">Pericom PI3VDP12412</a>.
The panel is driven with eDP instead of LVDS since the pixel clock
required for retina resolution exceeds LVDS’ limits.</p>
<p>Pre-retinas are able to switch the panel’s DDC pins separately.
This is handled by a <a class="reference external" href="http://www.ti.com/lit/ds/symlink/sn74lv4066a.pdf">TI SN74LV4066A</a> which is controlled by gmux.
The inactive GPU can thus probe the panel’s EDID without switching over
the entire panel. Retinas lack this functionality as the chips used for
eDP muxing are incapable of switching the AUX channel separately (see
the linked data sheets, Pericom would be capable but this is unused).
However the retina panel has the NO_AUX_HANDSHAKE_LINK_TRAINING bit set
in its DPCD, allowing the inactive GPU to skip the AUX handshake and
set up the output with link parameters pre-calibrated by the active GPU.</p>
<p>The external DP port is only fully switchable on the first two unibody
MacBook Pro generations, MBP5 2008/09 and MBP6 2010. This is done by an
<a class="reference external" href="http://www.nxp.com/documents/data_sheet/CBTL06141.pdf">NXP CBTL06141</a> which is controlled by gmux. It’s the predecessor of the
eDP mux on retinas, the difference being support for 2.7 versus 5.4 Gbit/s.</p>
<p>The following MacBook Pro generations replaced the external DP port with a
combined DP/Thunderbolt port and lost the ability to switch it between GPUs,
connecting it either to the discrete GPU or the Thunderbolt controller.
Oddly enough, while the full port is no longer switchable, AUX and HPD
are still switchable by way of an <a class="reference external" href="http://pdf.datasheetarchive.com/indexerfiles/Datasheets-SW16/DSASW00308511.pdf">NXP CBTL03062</a> (on pre-retinas
MBP8 2011 and MBP9 2012) or two <a class="reference external" href="http://www.ti.com/lit/ds/symlink/ts3ds10224.pdf">TI TS3DS10224</a> (on retinas) under the
control of gmux. Since the integrated GPU is missing the main link,
external displays appear to it as phantoms which fail to link-train.</p>
<p>gmux receives the HPD signal of all display connectors and sends an
interrupt on hotplug. On generations which cannot switch external ports,
the discrete GPU can then be woken to drive the newly connected display.
The ability to switch AUX on these generations could be used to improve
reliability of hotplug detection by having the integrated GPU poll the
ports while the discrete GPU is asleep, but currently we do not make use
of this feature.</p>
<p>Our switching policy for the external port is that on those generations
which are able to switch it fully, the port is switched together with the
panel when IGD / DIS commands are issued to vga_switcheroo. It is thus
possible to drive e.g. a beamer on battery power with the integrated GPU.
The user may manually switch to the discrete GPU if more performance is
needed.</p>
<p>On all newer generations, the external port can only be driven by the
discrete GPU. If a display is plugged in while the panel is switched to
the integrated GPU, <em>both</em> GPUs will be in use for maximum performance.
To decrease power consumption, the user may manually switch to the
discrete GPU, thereby suspending the integrated GPU.</p>
<p>gmux’ initial switch state on bootup is user configurable via the EFI
variable <code class="docutils literal"><span class="pre">gpu-power-prefs-fa4ce28d-b62f-4c99-9cc3-6815686e30f9</span></code> (5th byte,
1 = IGD, 0 = DIS). Based on this setting, the EFI firmware tells gmux to
switch the panel and the external DP connector and allocates a framebuffer
for the selected GPU.</p>
</div>
<div class="section" id="power-control">
<h4>Power control<a class="headerlink" href="#power-control" title="Permalink to this headline">¶</a></h4>
<p>gmux is able to cut power to the discrete GPU. It automatically takes care
of the correct sequence to tear down and bring up the power rails for
core voltage, VRAM and PCIe.</p>
</div>
<div class="section" id="backlight-control">
<h4>Backlight control<a class="headerlink" href="#backlight-control" title="Permalink to this headline">¶</a></h4>
<p>On single GPU MacBooks, the PWM signal for the backlight is generated by
the GPU. On dual GPU MacBook Pros by contrast, either GPU may be suspended
to conserve energy. Hence the PWM signal needs to be generated by a separate
backlight driver which is controlled by gmux. The earliest generation
MBP5 2008/09 uses a <a class="reference external" href="http://www.ti.com/lit/ds/symlink/lp8543.pdf">TI LP8543</a> backlight driver. All newer models
use a <a class="reference external" href="http://www.ti.com/lit/ds/symlink/lp8545.pdf">TI LP8545</a>.</p>
</div>
<div class="section" id="id2">
<h4>Public functions<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="c.apple_gmux_present">
bool <code class="descname">apple_gmux_present</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.apple_gmux_present" title="Permalink to this definition">¶</a></dt>
<dd><p>detect if gmux is built into the machine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers may use this to activate quirks specific to dual GPU MacBook Pros
and Mac Pros, e.g. for deferred probing, runtime pm and backlight.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if gmux is present and the kernel was configured
with CONFIG_APPLE_GMUX, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="vgaarbiter.html" class="btn btn-neutral float-right" title="VGA Arbiter" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="vc4.html" class="btn btn-neutral" title="drm/vc4 Broadcom VC4 Graphics Driver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>