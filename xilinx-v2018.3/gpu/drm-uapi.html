

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Userland interfaces &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="drm/i915 Intel GFX Driver" href="i915.html" />
    <link rel="prev" title="Mode Setting Helper Functions" href="drm-kms-helpers.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Userland interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#libdrm-device-lookup">libdrm Device Lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#primary-nodes-drm-master-and-authentication">Primary Nodes, DRM Master and Authentication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#open-source-userspace-requirements">Open-Source Userspace Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#render-nodes">Render nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ioctl-support-on-device-nodes">IOCTL Support on Device Nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-and-validation">Testing and validation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#validating-changes-with-igt">Validating changes with IGT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#display-crc-support">Display CRC Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debugfs-support">Debugfs Support</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sysfs-support">Sysfs Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vblank-event-handling">VBlank event handling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l2"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux GPU Driver Developer’s Guide</a> &raquo;</li>
        
      <li>Userland interfaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/gpu/drm-uapi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="userland-interfaces">
<h1>Userland interfaces<a class="headerlink" href="#userland-interfaces" title="Permalink to this headline">¶</a></h1>
<p>The DRM core exports several interfaces to applications, generally
intended to be used through corresponding libdrm wrapper functions. In
addition, drivers export device-specific interfaces for use by userspace
drivers &amp; device-aware applications through ioctls and sysfs files.</p>
<p>External interfaces include: memory mapping, context management, DMA
operations, AGP management, vblank control, fence management, memory
management, and output management.</p>
<p>Cover generic ioctls and sysfs layout here. We only need high-level
info, since man pages should cover the rest.</p>
<div class="section" id="libdrm-device-lookup">
<h2>libdrm Device Lookup<a class="headerlink" href="#libdrm-device-lookup" title="Permalink to this headline">¶</a></h2>
<p>BEWARE THE DRAGONS! MIND THE TRAPDOORS!</p>
<p>In an attempt to warn anyone else who’s trying to figure out what’s going
on here, I’ll try to summarize the story. First things first, let’s clear up
the names, because the kernel internals, libdrm and the ioctls are all named
differently:</p>
<blockquote>
<div><ul class="simple">
<li>GET_UNIQUE ioctl, implemented by drm_getunique is wrapped up in libdrm
through the drmGetBusid function.</li>
<li>The libdrm drmSetBusid function is backed by the SET_UNIQUE ioctl. All
that code is nerved in the kernel with <a class="reference internal" href="#c.drm_invalid_op" title="drm_invalid_op"><code class="xref c c-func docutils literal"><span class="pre">drm_invalid_op()</span></code></a>.</li>
<li>The internal set_busid kernel functions and driver callbacks are
exclusively use by the SET_VERSION ioctl, because only drm 1.0 (which is
nerved) allowed userspace to set the busid through the above ioctl.</li>
<li>Other ioctls and functions involved are named consistently.</li>
</ul>
</div></blockquote>
<p>For anyone wondering what’s the difference between drm 1.1 and 1.4: Correctly
handling pci domains in the busid on ppc. Doing this correctly was only
implemented in libdrm in 2010, hence can’t be nerved yet. No one knows what’s
special with drm 1.2 and 1.3.</p>
<p>Now the actual horror story of how device lookup in drm works. At large,
there’s 2 different ways, either by busid, or by device driver name.</p>
<p>Opening by busid is fairly simple:</p>
<ol class="arabic simple">
<li>First call SET_VERSION to make sure pci domains are handled properly. As a
side-effect this fills out the unique name in the master structure.</li>
<li>Call GET_UNIQUE to read out the unique name from the master structure,
which matches the busid thanks to step 1. If it doesn’t, proceed to try
the next device node.</li>
</ol>
<p>Opening by name is slightly different:</p>
<ol class="arabic simple">
<li>Directly call VERSION to get the version and to match against the driver
name returned by that ioctl. Note that SET_VERSION is not called, which
means the the unique name for the master node just opening is _not_ filled
out. This despite that with current drm device nodes are always bound to
one device, and can’t be runtime assigned like with drm 1.0.</li>
<li>Match driver name. If it mismatches, proceed to the next device node.</li>
<li>Call GET_UNIQUE, and check whether the unique name has length zero (by
checking that the first byte in the string is 0). If that’s not the case
libdrm skips and proceeds to the next device node. Probably this is just
copypasta from drm 1.0 times where a set unique name meant that the driver
was in use already, but that’s just conjecture.</li>
</ol>
<p>Long story short: To keep the open by name logic working, GET_UNIQUE must
_not_ return a unique string when SET_VERSION hasn’t been called yet,
otherwise libdrm breaks. Even when that unique string can’t ever change, and
is totally irrelevant for actually opening the device because runtime
assignable device instances were only support in drm 1.0, which is long dead.
But the libdrm code in drmOpenByName somehow survived, hence this can’t be
broken.</p>
</div>
<div class="section" id="primary-nodes-drm-master-and-authentication">
<span id="drm-primary-node"></span><h2>Primary Nodes, DRM Master and Authentication<a class="headerlink" href="#primary-nodes-drm-master-and-authentication" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a> is used to track groups of clients with open
primary/legacy device nodes. For every <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> which has had at
least once successfully became the device master (either through the
SET_MASTER IOCTL, or implicitly through opening the primary device node when
no one else is the current master that time) there exists one <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a>.
This is noted in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.is_master</span></code></a>. All other clients have just a pointer
to the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a> they are associated with.</p>
<p>In addition only one <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a> can be the current master for a <code class="xref c c-type docutils literal"><span class="pre">drm_device</span></code>.
It can be switched through the DROP_MASTER and SET_MASTER IOCTL, or
implicitly through closing/openeing the primary device node. See also
<a class="reference internal" href="#c.drm_is_current_master" title="drm_is_current_master"><code class="xref c c-func docutils literal"><span class="pre">drm_is_current_master()</span></code></a>.</p>
<p>Clients can authenticate against the current master (if it matches their own)
using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging masters,
this allows controlled access to the device for an entire group of mutually
trusted clients.</p>
<dl class="function">
<dt id="c.drm_is_current_master">
bool <code class="descname">drm_is_current_master</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;fpriv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_is_current_master" title="Permalink to this definition">¶</a></dt>
<dd><p>checks whether <strong>priv</strong> is the current master</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">fpriv</span></code></dt>
<dd>DRM file private</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether <strong>fpriv</strong> is current master on its device. This decides whether a
client is allowed to run DRM_MASTER IOCTLs.</p>
<p>Most of the modern IOCTL which require DRM_MASTER are for kernel modesetting
- the current master is assumed to own the non-shareable display hardware.</p>
<dl class="function">
<dt id="c.drm_master_get">
struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> * <code class="descname">drm_master_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> *<em>&nbsp;master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_master_get" title="Permalink to this definition">¶</a></dt>
<dd><p>reference a master pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_master</span> <span class="pre">*</span> <span class="pre">master</span></code></dt>
<dd><a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Increments the reference count of <strong>master</strong> and returns a pointer to <strong>master</strong>.</p>
<dl class="function">
<dt id="c.drm_master_put">
void <code class="descname">drm_master_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_master" title="drm_master">drm_master</a> **<em>&nbsp;master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_master_put" title="Permalink to this definition">¶</a></dt>
<dd><p>unreference and clear a master pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_master</span> <span class="pre">**</span> <span class="pre">master</span></code></dt>
<dd>pointer to a pointer of <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_master</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This decrements the <a class="reference internal" href="#c.drm_master" title="drm_master"><code class="xref c c-type docutils literal"><span class="pre">drm_master</span></code></a> behind <strong>master</strong> and sets it to NULL.</p>
<dl class="type">
<dt id="c.drm_master">
struct <code class="descname">drm_master</code><a class="headerlink" href="#c.drm_master" title="Permalink to this definition">¶</a></dt>
<dd><p>drm master structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_master {
  struct kref refcount;
  struct drm_device * dev;
  char * unique;
  int unique_len;
  struct idr magic_map;
  struct drm_lock_data lock;
  void * driver_priv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>Refcount for this master object.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Link back to the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unique</span></code></dt>
<dd>Unique identifier: e.g. busid. Protected by
<code class="xref c c-type docutils literal"><span class="pre">drm_device.master_mutex</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">unique_len</span></code></dt>
<dd>Length of unique field. Protected by
<code class="xref c c-type docutils literal"><span class="pre">drm_device.master_mutex</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">magic_map</span></code></dt>
<dd>Map of used authentication tokens. Protected by
<code class="xref c c-type docutils literal"><span class="pre">drm_device.master_mutex</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>DRI1 lock information.</dd>
<dt><code class="docutils literal"><span class="pre">driver_priv</span></code></dt>
<dd>Pointer to driver-private information.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that master structures are only relevant for the legacy/primary device
nodes, hence there can only be one per device, not one per drm_minor.</p>
</div>
<div class="section" id="open-source-userspace-requirements">
<h2>Open-Source Userspace Requirements<a class="headerlink" href="#open-source-userspace-requirements" title="Permalink to this headline">¶</a></h2>
<p>The DRM subsystem has stricter requirements than most other kernel subsystems on
what the userspace side for new uAPI needs to look like. This section here
explains what exactly those requirements are, and why they exist.</p>
<p>The short summary is that any addition of DRM uAPI requires corresponding
open-sourced userspace patches, and those patches must be reviewed and ready for
merging into a suitable and canonical upstream project.</p>
<p>GFX devices (both display and render/GPU side) are really complex bits of
hardware, with userspace and kernel by necessity having to work together really
closely.  The interfaces, for rendering and modesetting, must be extremely wide
and flexible, and therefore it is almost always impossible to precisely define
them for every possible corner case. This in turn makes it really practically
infeasible to differentiate between behaviour that’s required by userspace, and
which must not be changed to avoid regressions, and behaviour which is only an
accidental artifact of the current implementation.</p>
<p>Without access to the full source code of all userspace users that means it
becomes impossible to change the implementation details, since userspace could
depend upon the accidental behaviour of the current implementation in minute
details. And debugging such regressions without access to source code is pretty
much impossible. As a consequence this means:</p>
<ul class="simple">
<li>The Linux kernel’s “no regression” policy holds in practice only for
open-source userspace of the DRM subsystem. DRM developers are perfectly fine
if closed-source blob drivers in userspace use the same uAPI as the open
drivers, but they must do so in the exact same way as the open drivers.
Creative (ab)use of the interfaces will, and in the past routinely has, lead
to breakage.</li>
<li>Any new userspace interface must have an open-source implementation as
demonstration vehicle.</li>
</ul>
<p>The other reason for requiring open-source userspace is uAPI review. Since the
kernel and userspace parts of a GFX stack must work together so closely, code
review can only assess whether a new interface achieves its goals by looking at
both sides. Making sure that the interface indeed covers the use-case fully
leads to a few additional requirements:</p>
<ul class="simple">
<li>The open-source userspace must not be a toy/test application, but the real
thing. Specifically it needs to handle all the usual error and corner cases.
These are often the places where new uAPI falls apart and hence essential to
assess the fitness of a proposed interface.</li>
<li>The userspace side must be fully reviewed and tested to the standards of that
userspace project. For e.g. mesa this means piglit testcases and review on the
mailing list. This is again to ensure that the new interface actually gets the
job done.</li>
<li>The userspace patches must be against the canonical upstream, not some vendor
fork. This is to make sure that no one cheats on the review and testing
requirements by doing a quick fork.</li>
<li>The kernel patch can only be merged after all the above requirements are met,
but it <strong>must</strong> be merged <strong>before</strong> the userspace patches land. uAPI always flows
from the kernel, doing things the other way round risks divergence of the uAPI
definitions and header files.</li>
</ul>
<p>These are fairly steep requirements, but have grown out from years of shared
pain and experience with uAPI added hastily, and almost always regretted about
just as fast. GFX devices change really fast, requiring a paradigm shift and
entire new set of uAPI interfaces every few years at least. Together with the
Linux kernel’s guarantee to keep existing userspace running for 10+ years this
is already rather painful for the DRM subsystem, with multiple different uAPIs
for the same thing co-existing. If we add a few more complete mistakes into the
mix every year it would be entirely unmanageable.</p>
</div>
<div class="section" id="render-nodes">
<span id="drm-render-node"></span><h2>Render nodes<a class="headerlink" href="#render-nodes" title="Permalink to this headline">¶</a></h2>
<p>DRM core provides multiple character-devices for user-space to use.
Depending on which device is opened, user-space can perform a different
set of operations (mainly ioctls). The primary node is always created
and called card&lt;num&gt;. Additionally, a currently unused control node,
called controlD&lt;num&gt; is also created. The primary node provides all
legacy operations and historically was the only interface used by
userspace. With KMS, the control node was introduced. However, the
planned KMS control interface has never been written and so the control
node stays unused to date.</p>
<p>With the increased use of offscreen renderers and GPGPU applications,
clients no longer require running compositors or graphics servers to
make use of a GPU. But the DRM API required unprivileged clients to
authenticate to a DRM-Master prior to getting GPU access. To avoid this
step and to grant clients GPU access without authenticating, render
nodes were introduced. Render nodes solely serve render clients, that
is, no modesetting or privileged ioctls can be issued on render nodes.
Only non-global rendering commands are allowed. If a driver supports
render nodes, it must advertise it via the DRIVER_RENDER DRM driver
capability. If not supported, the primary node must be used for render
clients together with the legacy drmAuth authentication procedure.</p>
<p>If a driver advertises render node support, DRM core will create a
separate render node called renderD&lt;num&gt;. There will be one render node
per device. No ioctls except PRIME-related ioctls will be allowed on
this node. Especially GEM_OPEN will be explicitly prohibited. Render
nodes are designed to avoid the buffer-leaks, which occur if clients
guess the flink names or mmap offsets on the legacy interface.
Additionally to this basic interface, drivers must mark their
driver-dependent render-only ioctls as DRM_RENDER_ALLOW so render
clients can use them. Driver authors must be careful not to allow any
privileged ioctls on render nodes.</p>
<p>With render nodes, user-space can now control access to the render node
via basic file-system access-modes. A running graphics server which
authenticates clients on the privileged primary/legacy node is no longer
required. Instead, a client can open the render node and is immediately
granted GPU access. Communication between clients (or servers) is done
via PRIME. FLINK from render node to legacy node is not supported. New
clients must not use the insecure FLINK interface.</p>
<p>Besides dropping all modeset/global ioctls, render nodes also drop the
DRM-Master concept. There is no reason to associate render clients with
a DRM-Master as they are independent of any graphics server. Besides,
they must work without any running master, anyway. Drivers must be able
to run without a master object if they support render nodes. If, on the
other hand, a driver requires shared state between clients which is
visible to user-space and accessible beyond open-file boundaries, they
cannot support render nodes.</p>
</div>
<div class="section" id="ioctl-support-on-device-nodes">
<span id="drm-driver-ioctl"></span><h2>IOCTL Support on Device Nodes<a class="headerlink" href="#ioctl-support-on-device-nodes" title="Permalink to this headline">¶</a></h2>
<p>First things first, driver private IOCTLs should only be needed for drivers
supporting rendering. Kernel modesetting is all standardized, and extended
through properties. There are a few exceptions in some existing drivers,
which define IOCTL for use by the display DRM master, but they all predate
properties.</p>
<p>Now if you do have a render driver you always have to support it through
driver private properties. There’s a few steps needed to wire all the things
up.</p>
<p>First you need to define the structure for your IOCTL in your driver private
UAPI header in <code class="docutils literal"><span class="pre">include/uapi/drm/my_driver_drm.h</span></code>:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct my_driver_operation {
        u32 some_thing;
        u32 another_thing;
};
</pre></div>
</div>
<p>Please make sure that you follow all the best practices from
<code class="docutils literal"><span class="pre">Documentation/ioctl/botching-up-ioctls.txt</span></code>. Note that <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal"><span class="pre">drm_ioctl()</span></code></a>
automatically zero-extends structures, hence make sure you can add more stuff
at the end, i.e. don’t put a variable sized array there.</p>
<p>Then you need to define your IOCTL number, using one of <code class="xref c c-func docutils literal"><span class="pre">DRM_IO()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">DRM_IOR()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">DRM_IOW()</span></code> or <code class="xref c c-func docutils literal"><span class="pre">DRM_IOWR()</span></code>. It must start with the DRM_IOCTL_ prefix:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>##define DRM_IOCTL_MY_DRIVER_OPERATION  *         DRM_IOW(DRM_COMMAND_BASE, struct my_driver_operation)
</pre></div>
</div>
<p>DRM driver private IOCTL must be in the range from DRM_COMMAND_BASE to
DRM_COMMAND_END. Finally you need an array of <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a> to wire
up the handlers and set the access rights:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>static const struct drm_ioctl_desc my_driver_ioctls[] = {
    DRM_IOCTL_DEF_DRV(MY_DRIVER_OPERATION, my_driver_operation,
            DRM_AUTH|DRM_RENDER_ALLOW),
};
</pre></div>
</div>
<p>And then assign this to the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.ioctls</span></code></a> field in your driver
structure.</p>
<p>See the separate chapter on <a class="reference internal" href="drm-internals.html#drm-driver-fops"><span class="std std-ref">file operations</span></a> for how
the driver-specific IOCTLs are wired up.</p>
<dl class="function">
<dt id="c.drm_ioctl_t">
typedef int <code class="descname">drm_ioctl_t</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl_t" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM ioctl function type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device inode</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private pointer of the ioctl call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file this ioctl was made on</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the DRM ioctl typedef. Note that <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal"><span class="pre">drm_ioctl()</span></code></a> has alrady copied <strong>data</strong>
into kernel-space, and will also copy it back, depending upon the read/write
settings in the ioctl command code.</p>
<dl class="function">
<dt id="c.drm_ioctl_compat_t">
typedef int <code class="descname">drm_ioctl_compat_t</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, unsigned int<em>&nbsp;cmd</em>, unsigned long<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl_compat_t" title="Permalink to this definition">¶</a></dt>
<dd><p>compatibility DRM ioctl function type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>ioctl command code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>DRM file this ioctl was made on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just a typedef to make declaring an array of compatibility handlers easier.
New drivers shouldn’t screw up the structure layout for their ioctl
structures and hence never need this.</p>
<dl class="type">
<dt id="c.drm_ioctl_flags">
enum <code class="descname">drm_ioctl_flags</code><a class="headerlink" href="#c.drm_ioctl_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM ioctl flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_AUTH</span></code></dt>
<dd>This is for ioctl which are used for rendering, and require that the
file descriptor is either for a render node, or if it’s a
legacy/primary node, then it must be authenticated.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MASTER</span></code></dt>
<dd><p class="first">This must be set for any ioctl which can change the modeset or
display state. Userspace must call the ioctl through a primary node,
while it is the active master.</p>
<p class="last">Note that read-only modeset ioctl can also be called by
unauthenticated clients, or when a master is not the currently active
one.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_ROOT_ONLY</span></code></dt>
<dd><p class="first">Anything that could potentially wreak a master file descriptor needs
to have this flag set. Current that’s only for the SETMASTER and
DROPMASTER ioctl, which e.g. logind can call to force a non-behaving
master (display compositor) into compliance.</p>
<p class="last">This is equivalent to callers with the SYSADMIN capability.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_CONTROL_ALLOW</span></code></dt>
<dd>Deprecated, do not use. Control nodes are in the process of getting
removed.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_UNLOCKED</span></code></dt>
<dd>Whether <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">drm_ioctl_desc.func</span></code></a> should be called with the DRM BKL held
or not. Enforced as the default for all modern drivers, hence there
should never be a need to set this flag.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_RENDER_ALLOW</span></code></dt>
<dd>This is used for all ioctl needed for rendering only, for drivers
which support render nodes. This should be all new render drivers,
and hence it should be always set for any ioctl with DRM_AUTH set.
Note though that read-only query ioctl might have this set, but have
not set DRM_AUTH because they do not require authentication.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Various flags that can be set in <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">drm_ioctl_desc.flags</span></code></a> to control how
userspace can use a given ioctl.</p>
<dl class="type">
<dt id="c.drm_ioctl_desc">
struct <code class="descname">drm_ioctl_desc</code><a class="headerlink" href="#c.drm_ioctl_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM driver ioctl entry</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_ioctl_desc {
  unsigned int cmd;
  enum drm_ioctl_flags flags;
  drm_ioctl_t * func;
  const char * name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cmd</span></code></dt>
<dd>ioctl command number, without flags</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>a bitmask of <a class="reference internal" href="#c.drm_ioctl_flags" title="drm_ioctl_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">drm_ioctl_flags</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">func</span></code></dt>
<dd>handler for this ioctl</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>user-readable name for debug output</dd>
</dl>
<p><strong>Description</strong></p>
<p>For convenience it’s easier to create these using the <a class="reference internal" href="#c.DRM_IOCTL_DEF_DRV" title="DRM_IOCTL_DEF_DRV"><code class="xref c c-func docutils literal"><span class="pre">DRM_IOCTL_DEF_DRV()</span></code></a>
macro.</p>
<dl class="function">
<dt id="c.DRM_IOCTL_DEF_DRV">
<code class="descname">DRM_IOCTL_DEF_DRV</code><span class="sig-paren">(</span><em>ioctl</em>, <em>_func</em>, <em>_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_IOCTL_DEF_DRV" title="Permalink to this definition">¶</a></dt>
<dd><p>helper macro to fill out a <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ioctl</span></code></dt>
<dd>ioctl command suffix</dd>
<dt><code class="docutils literal"><span class="pre">_func</span></code></dt>
<dd>handler for the ioctl</dd>
<dt><code class="docutils literal"><span class="pre">_flags</span></code></dt>
<dd>a bitmask of <a class="reference internal" href="#c.drm_ioctl_flags" title="drm_ioctl_flags"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">drm_ioctl_flags</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Small helper macro to create a <a class="reference internal" href="#c.drm_ioctl_desc" title="drm_ioctl_desc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_ioctl_desc</span></code></a> entry. The ioctl
command number is constructed by prepending <code class="docutils literal"><span class="pre">DRM_IOCTL\_</span></code> and passing that
to <code class="xref c c-func docutils literal"><span class="pre">DRM_IOCTL_NR()</span></code>.</p>
<dl class="function">
<dt id="c.drm_noop">
int <code class="descname">drm_noop</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_noop" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM no-op ioctl implemntation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device for the ioctl</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data pointer for the ioctl</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file for the ioctl call</dd>
</dl>
<p><strong>Description</strong></p>
<p>This no-op implementation for drm ioctls is useful for deprecated
functionality where we can’t return a failure code because existing userspace
checks the result of the ioctl, but doesn’t care about the action.</p>
<p>Always returns successfully with 0.</p>
<dl class="function">
<dt id="c.drm_invalid_op">
int <code class="descname">drm_invalid_op</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_invalid_op" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM invalid ioctl implemntation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device for the ioctl</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data pointer for the ioctl</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file for the ioctl call</dd>
</dl>
<p><strong>Description</strong></p>
<p>This no-op implementation for drm ioctls is useful for deprecated
functionality where we really don’t want to allow userspace to call the ioctl
any more. This is the case for old ums interfaces for drivers that
transitioned to kms gradually and so kept the old legacy tables around. This
only applies to radeon and i915 kms drivers, other drivers shouldn’t need to
use this function.</p>
<p>Always fails with a return value of -EINVAL.</p>
<dl class="function">
<dt id="c.drm_ioctl_permit">
int <code class="descname">drm_ioctl_permit</code><span class="sig-paren">(</span>u32<em>&nbsp;flags</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl_permit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check ioctl permissions against caller</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>ioctl permission flags.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>Pointer to struct drm_file identifying the caller.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the caller is allowed to run an ioctl with the
indicated permissions.</p>
<p><strong>Return</strong></p>
<p>Zero if allowed, -EACCES otherwise.</p>
<dl class="function">
<dt id="c.drm_ioctl">
long <code class="descname">drm_ioctl</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, unsigned int<em>&nbsp;cmd</em>, unsigned long<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>ioctl callback implementation for DRM drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file this ioctl is called on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>ioctl cmd number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>user argument</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the ioctl function in the DRM core and the driver dispatch table,
stored in <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.ioctls</span></code></a>. It checks for necessary permission by calling
<a class="reference internal" href="#c.drm_ioctl_permit" title="drm_ioctl_permit"><code class="xref c c-func docutils literal"><span class="pre">drm_ioctl_permit()</span></code></a>, and dispatches to the respective function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
<dl class="function">
<dt>
bool <code class="descname">drm_ioctl_flags</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;nr</em>, unsigned int *<em>&nbsp;flags</em><span class="sig-paren">)</span></dt>
<dd><p>Check for core ioctl and return ioctl permission flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>ioctl number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">flags</span></code></dt>
<dd>where to return the ioctl permission flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This ioctl is only used by the vmwgfx driver to augment the access checks
done by the drm core and insofar a pretty decent layering violation. This
shouldn’t be used by any drivers.</p>
<p><strong>Return</strong></p>
<p>True if the <strong>nr</strong> corresponds to a DRM core ioctl number, false otherwise.</p>
<dl class="function">
<dt id="c.drm_compat_ioctl">
long <code class="descname">drm_compat_ioctl</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, unsigned int<em>&nbsp;cmd</em>, unsigned long<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_compat_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>32bit IOCTL compatibility handler for DRM drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file this ioctl is called on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>ioctl cmd number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">arg</span></code></dt>
<dd>user argument</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatibility handler for 32 bit userspace running on 64 kernels. All actual
IOCTL handling is forwarded to <a class="reference internal" href="#c.drm_ioctl" title="drm_ioctl"><code class="xref c c-func docutils literal"><span class="pre">drm_ioctl()</span></code></a>, while marshalling structures as
appropriate. Note that this only handles DRM core IOCTLs, if the driver has
botched IOCTL itself, it must handle those by wrapping this function.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative error code on failure.</p>
</div>
<div class="section" id="testing-and-validation">
<h2>Testing and validation<a class="headerlink" href="#testing-and-validation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="validating-changes-with-igt">
<h3>Validating changes with IGT<a class="headerlink" href="#validating-changes-with-igt" title="Permalink to this headline">¶</a></h3>
<p>There’s a collection of tests that aims to cover the whole functionality of
DRM drivers and that can be used to check that changes to DRM drivers or the
core don’t regress existing functionality. This test suite is called IGT and
its code can be found in <a class="reference external" href="https://cgit.freedesktop.org/drm/igt-gpu-tools/">https://cgit.freedesktop.org/drm/igt-gpu-tools/</a>.</p>
<p>To build IGT, start by installing its build dependencies. In Debian-based
systems:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># apt-get build-dep intel-gpu-tools
</pre></div>
</div>
<p>And in Fedora-based systems:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span># dnf builddep intel-gpu-tools
</pre></div>
</div>
<p>Then clone the repository:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ git clone git://anongit.freedesktop.org/drm/igt-gpu-tools
</pre></div>
</div>
<p>Configure the build system and start the build:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ cd igt-gpu-tools &amp;&amp; ./autogen.sh &amp;&amp; make -j6
</pre></div>
</div>
<p>Download the piglit dependency:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ./scripts/run-tests.sh -d
</pre></div>
</div>
<p>And run the tests:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ ./scripts/run-tests.sh -t kms -t core -s
</pre></div>
</div>
<p>run-tests.sh is a wrapper around piglit that will execute the tests matching
the -t options. A report in HTML format will be available in
./results/html/index.html. Results can be compared with piglit.</p>
</div>
<div class="section" id="display-crc-support">
<h3>Display CRC Support<a class="headerlink" href="#display-crc-support" title="Permalink to this headline">¶</a></h3>
<p>DRM device drivers can provide to userspace CRC information of each frame as
it reached a given hardware component (a CRC sampling “source”).</p>
<p>Userspace can control generation of CRCs in a given CRTC by writing to the
file dri/0/crtc-N/crc/control in debugfs, with N being the index of the CRTC.
Accepted values are source names (which are driver-specific) and the “auto”
keyword, which will let the driver select a default source of frame CRCs
for this CRTC.</p>
<p>Once frame CRC generation is enabled, userspace can capture them by reading
the dri/0/crtc-N/crc/data file. Each line in that file contains the frame
number in the first field and then a number of unsigned integer fields
containing the CRC data. Fields are separated by a single space and the number
of CRC fields is source-specific.</p>
<p>Note that though in some cases the CRC is computed in a specified way and on
the frame contents as supplied by userspace (eDP 1.3), in general the CRC
computation is performed in an unspecified way and on frame contents that have
been already processed in also an unspecified way and thus userspace cannot
rely on being able to generate matching CRC values for the frame contents that
it submits. In this general case, the maximum userspace can do is to compare
the reported CRCs of frames that should have the same contents.</p>
<p>On the driver side the implementation effort is minimal, drivers only need to
implement <a class="reference internal" href="drm-kms.html#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.set_crc_source</span></code></a>. The debugfs files are automatically
set up if that vfunc is set. CRC samples need to be captured in the driver by
calling <a class="reference internal" href="#c.drm_crtc_add_crc_entry" title="drm_crtc_add_crc_entry"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_add_crc_entry()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_add_crc_entry">
int <code class="descname">drm_crtc_add_crc_entry</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-kms.html#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, bool<em>&nbsp;has_frame</em>, uint32_t<em>&nbsp;frame</em>, uint32_t *<em>&nbsp;crcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_add_crc_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Add entry with CRC information for a frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to which the frame belongs</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">has_frame</span></code></dt>
<dd>whether this entry has a frame number to go with</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">frame</span></code></dt>
<dd>number of the frame these CRCs are about</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">crcs</span></code></dt>
<dd>array of CRC values, with length matching #drm_crtc_crc.values_cnt</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each frame, the driver polls the source of CRCs for new data and calls
this function to add them to the buffer from where userspace reads.</p>
</div>
<div class="section" id="debugfs-support">
<h3>Debugfs Support<a class="headerlink" href="#debugfs-support" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_info_list">
struct <code class="descname">drm_info_list</code><a class="headerlink" href="#c.drm_info_list" title="Permalink to this definition">¶</a></dt>
<dd><p>debugfs info list entry</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_info_list {
  const char * name;
  int (* show) (struct seq_file*, void*);
  u32 driver_features;
  void * data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>file name</dd>
<dt><code class="docutils literal"><span class="pre">show</span></code></dt>
<dd>Show callback. <code class="xref c c-type docutils literal"><span class="pre">seq_file-&gt;private</span></code> will be set to the <a class="reference internal" href="#c.drm_info_node" title="drm_info_node"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_info_node</span></code></a> corresponding to the instance of this info on a given
<a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">driver_features</span></code></dt>
<dd>Required driver features for this entry</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>Driver-private data, should not be device-specific.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents a debugfs file to be created by the drm
core.</p>
<dl class="type">
<dt id="c.drm_info_node">
struct <code class="descname">drm_info_node</code><a class="headerlink" href="#c.drm_info_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Per-minor debugfs node structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct drm_info_node {
  struct drm_minor * minor;
  const struct drm_info_list * info_ent;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">minor</span></code></dt>
<dd><a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a> for this node.</dd>
<dt><code class="docutils literal"><span class="pre">info_ent</span></code></dt>
<dd>template for this node.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents a debugfs file, as an instantiation of a <a class="reference internal" href="#c.drm_info_list" title="drm_info_list"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_info_list</span></code></a> on a <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_minor</span></code></a>.</p>
<p>FIXME:</p>
<p>No it doesn’t make a hole lot of sense that we duplicate debugfs entries for
both the render and the primary nodes, but that’s how this has organically
grown. It should probably be fixed, with a compatibility link, if needed.</p>
<dl class="function">
<dt id="c.drm_debugfs_create_files">
int <code class="descname">drm_debugfs_create_files</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_info_list" title="drm_info_list">drm_info_list</a> *<em>&nbsp;files</em>, int<em>&nbsp;count</em>, struct dentry *<em>&nbsp;root</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_minor" title="drm_minor">drm_minor</a> *<em>&nbsp;minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_debugfs_create_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a given set of debugfs files for DRM minor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_info_list</span> <span class="pre">*</span> <span class="pre">files</span></code></dt>
<dd>The array of files to create</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>The number of files given</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>DRI debugfs dir entry.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_minor</span> <span class="pre">*</span> <span class="pre">minor</span></code></dt>
<dd>device minor number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a given set of debugfs files represented by an array of
<a class="reference internal" href="#c.drm_info_list" title="drm_info_list"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_info_list</span></code></a> in the given root directory. These files will be removed
automatically on <code class="xref c c-func docutils literal"><span class="pre">drm_debugfs_cleanup()</span></code>.</p>
</div>
</div>
<div class="section" id="sysfs-support">
<h2>Sysfs Support<a class="headerlink" href="#sysfs-support" title="Permalink to this headline">¶</a></h2>
<p>DRM provides very little additional support to drivers for sysfs
interactions, beyond just all the standard stuff. Drivers who want to expose
additional sysfs properties and property groups can attach them at either
<code class="xref c c-type docutils literal"><span class="pre">drm_device.dev</span></code> or <a class="reference internal" href="drm-kms.html#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.kdev</span></code></a>.</p>
<p>Registration is automatically handled when calling <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code></a>, or
<a class="reference internal" href="drm-kms.html#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_register()</span></code></a> in case of hot-plugged connectors. Unregistration is
also automatically handled by <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code></a> and
<a class="reference internal" href="drm-kms.html#c.drm_connector_unregister" title="drm_connector_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_unregister()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_sysfs_hotplug_event">
void <code class="descname">drm_sysfs_hotplug_event</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sysfs_hotplug_event" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a DRM uevent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send a uevent for the DRM device specified by <strong>dev</strong>.  Currently we only
set HOTPLUG=1 in the uevent environment, but this could be expanded to
deal with other types of events.</p>
<dl class="function">
<dt id="c.drm_class_device_register">
int <code class="descname">drm_class_device_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_class_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register new device with the DRM sysfs class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers a new <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a> within the DRM sysfs class. Essentially only
used by ttm to have a place for its global settings. Drivers should never use
this.</p>
<dl class="function">
<dt id="c.drm_class_device_unregister">
void <code class="descname">drm_class_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_class_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister device with the DRM sysfs class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a> from the DRM sysfs class. Essentially only used
by ttm to have a place for its global settings. Drivers should never use
this.</p>
</div>
<div class="section" id="vblank-event-handling">
<h2>VBlank event handling<a class="headerlink" href="#vblank-event-handling" title="Permalink to this headline">¶</a></h2>
<p>The DRM core exposes two vertical blank related ioctls:</p>
<dl class="docutils">
<dt>DRM_IOCTL_WAIT_VBLANK</dt>
<dd>This takes a struct drm_wait_vblank structure as its argument, and
it is used to block or request a signal when a specified vblank
event occurs.</dd>
<dt>DRM_IOCTL_MODESET_CTL</dt>
<dd>This was only used for user-mode-settind drivers around modesetting
changes to allow the kernel to update the vblank interrupt after
mode setting, since on many devices the vertical blank counter is
reset to 0 at some point during modeset. Modern drivers should not
call this any more since with kernel mode setting it is a no-op.</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="i915.html" class="btn btn-neutral float-right" title="drm/i915 Intel GFX Driver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-kms-helpers.html" class="btn btn-neutral" title="Mode Setting Helper Functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>