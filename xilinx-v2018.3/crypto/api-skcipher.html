

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Block Cipher Algorithm Definitions &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Authenticated Encryption With Associated Data (AEAD) Algorithm Definitions" href="api-aead.html" />
    <link rel="prev" title="Programming Interface" href="api.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Kernel Crypto API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Kernel Crypto API Interface Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="architecture.html">Kernel Crypto API Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="devel-algos.html">Developing Cipher Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="userspace-if.html">User Space Interface</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="api.html">Programming Interface</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Block Cipher Algorithm Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetric-key-cipher-api">Symmetric Key Cipher API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetric-key-cipher-request-handle">Symmetric Key Cipher Request Handle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#single-block-cipher-api">Single Block Cipher API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynchronous-block-cipher-api-deprecated">Asynchronous Block Cipher API - Deprecated</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynchronous-cipher-request-handle-deprecated">Asynchronous Cipher Request Handle - Deprecated</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synchronous-block-cipher-api-deprecated">Synchronous Block Cipher API - Deprecated</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-aead.html">Authenticated Encryption With Associated Data (AEAD) Algorithm Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-aead.html#authenticated-encryption-with-associated-data-aead-cipher-api">Authenticated Encryption With Associated Data (AEAD) Cipher API</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-aead.html#asynchronous-aead-request-handle">Asynchronous AEAD Request Handle</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-digest.html">Message Digest Algorithm Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-digest.html#asynchronous-message-digest-api">Asynchronous Message Digest API</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-digest.html#asynchronous-hash-request-handle">Asynchronous Hash Request Handle</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-digest.html#synchronous-message-digest-api">Synchronous Message Digest API</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-rng.html">Random Number Algorithm Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-rng.html#crypto-api-random-number-api">Crypto API Random Number API</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-akcipher.html">Asymmetric Cipher Algorithm Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-akcipher.html#asymmetric-cipher-api">Asymmetric Cipher API</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-akcipher.html#asymmetric-cipher-request-handle">Asymmetric Cipher Request Handle</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-kpp.html">Key-agreement Protocol Primitives (KPP) Cipher Algorithm Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-kpp.html#key-agreement-protocol-primitives-kpp-cipher-api">Key-agreement Protocol Primitives (KPP) Cipher API</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-kpp.html#key-agreement-protocol-primitives-kpp-cipher-request-handle">Key-agreement Protocol Primitives (KPP) Cipher Request Handle</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-kpp.html#ecdh-helper-functions">ECDH Helper Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="api-kpp.html#dh-helper-functions">DH Helper Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="api-samples.html">Code Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Kernel Crypto API</a> &raquo;</li>
        
          <li><a href="api.html">Programming Interface</a> &raquo;</li>
        
      <li>Block Cipher Algorithm Definitions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/crypto/api-skcipher.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="block-cipher-algorithm-definitions">
<h1>Block Cipher Algorithm Definitions<a class="headerlink" href="#block-cipher-algorithm-definitions" title="Permalink to this headline">¶</a></h1>
<p>These data structures define modular crypto algorithm implementations,
managed via <code class="xref c c-func docutils literal"><span class="pre">crypto_register_alg()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">crypto_unregister_alg()</span></code>.</p>
<dl class="type">
<dt id="c.ablkcipher_alg">
struct <code class="descname">ablkcipher_alg</code><a class="headerlink" href="#c.ablkcipher_alg" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous block cipher definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct ablkcipher_alg {
  int (* setkey) (struct crypto_ablkcipher *tfm, const u8 *key, unsigned int keylen);
  int (* encrypt) (struct ablkcipher_request *req);
  int (* decrypt) (struct ablkcipher_request *req);
  int (* givencrypt) (struct skcipher_givcrypt_request *req);
  int (* givdecrypt) (struct skcipher_givcrypt_request *req);
  const char * geniv;
  unsigned int min_keysize;
  unsigned int max_keysize;
  unsigned int ivsize;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">setkey</span></code></dt>
<dd>Set key for the transformation. This function is used to either
program a supplied key into the hardware or store the key in the
transformation context for programming it later. Note that this
function does modify the transformation context. This function can
be called multiple times during the existence of the transformation
object, so one must make sure the key is properly reprogrammed into
the hardware. This function is also responsible for checking the key
length for validity. In case a software fallback was put in place in
the <strong>cra_init</strong> call, this function might need to use the fallback if
the algorithm doesn’t support all of the key sizes.</dd>
<dt><code class="docutils literal"><span class="pre">encrypt</span></code></dt>
<dd>Encrypt a scatterlist of blocks. This function is used to encrypt
the supplied scatterlist containing the blocks of data. The crypto
API consumer is responsible for aligning the entries of the
scatterlist properly and making sure the chunks are correctly
sized. In case a software fallback was put in place in the
<strong>cra_init</strong> call, this function might need to use the fallback if
the algorithm doesn’t support all of the key sizes. In case the
key was stored in transformation context, the key might need to be
re-programmed into the hardware in this function. This function
shall not modify the transformation context, as this function may
be called in parallel with the same transformation object.</dd>
<dt><code class="docutils literal"><span class="pre">decrypt</span></code></dt>
<dd>Decrypt a single block. This is a reverse counterpart to <strong>encrypt</strong>
and the conditions are exactly the same.</dd>
<dt><code class="docutils literal"><span class="pre">givencrypt</span></code></dt>
<dd>Update the IV for encryption. With this function, a cipher
implementation may provide the function on how to update the IV
for encryption.</dd>
<dt><code class="docutils literal"><span class="pre">givdecrypt</span></code></dt>
<dd>Update the IV for decryption. This is the reverse of
<strong>givencrypt</strong> .</dd>
<dt><code class="docutils literal"><span class="pre">geniv</span></code></dt>
<dd>The transformation implementation may use an “IV generator” provided
by the kernel crypto API. Several use cases have a predefined
approach how IVs are to be updated. For such use cases, the kernel
crypto API provides ready-to-use implementations that can be
referenced with this variable.</dd>
<dt><code class="docutils literal"><span class="pre">min_keysize</span></code></dt>
<dd>Minimum key size supported by the transformation. This is the
smallest key length supported by this transformation algorithm.
This must be set to one of the pre-defined values as this is
not hardware specific. Possible values for this field can be
found via git grep “_MIN_KEY_SIZE” include/crypto/</dd>
<dt><code class="docutils literal"><span class="pre">max_keysize</span></code></dt>
<dd>Maximum key size supported by the transformation. This is the
largest key length supported by this transformation algorithm.
This must be set to one of the pre-defined values as this is
not hardware specific. Possible values for this field can be
found via git grep “_MAX_KEY_SIZE” include/crypto/</dd>
<dt><code class="docutils literal"><span class="pre">ivsize</span></code></dt>
<dd>IV size applicable for transformation. The consumer must provide an
IV of exactly that size to perform the encrypt or decrypt operation.</dd>
</dl>
<p><strong>Description</strong></p>
<p>All fields except <strong>givencrypt</strong> , <strong>givdecrypt</strong> , <strong>geniv</strong> and <strong>ivsize</strong> are
mandatory and must be filled.</p>
<dl class="type">
<dt id="c.blkcipher_alg">
struct <code class="descname">blkcipher_alg</code><a class="headerlink" href="#c.blkcipher_alg" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronous block cipher definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct blkcipher_alg {
  int (* setkey) (struct crypto_tfm *tfm, const u8 *key, unsigned int keylen);
  int (* encrypt) (struct blkcipher_desc *desc,struct scatterlist *dst, struct scatterlist *src, unsigned int nbytes);
  int (* decrypt) (struct blkcipher_desc *desc,struct scatterlist *dst, struct scatterlist *src, unsigned int nbytes);
  const char * geniv;
  unsigned int min_keysize;
  unsigned int max_keysize;
  unsigned int ivsize;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">setkey</span></code></dt>
<dd>see struct ablkcipher_alg</dd>
<dt><code class="docutils literal"><span class="pre">encrypt</span></code></dt>
<dd>see struct ablkcipher_alg</dd>
<dt><code class="docutils literal"><span class="pre">decrypt</span></code></dt>
<dd>see struct ablkcipher_alg</dd>
<dt><code class="docutils literal"><span class="pre">geniv</span></code></dt>
<dd>see struct ablkcipher_alg</dd>
<dt><code class="docutils literal"><span class="pre">min_keysize</span></code></dt>
<dd>see struct ablkcipher_alg</dd>
<dt><code class="docutils literal"><span class="pre">max_keysize</span></code></dt>
<dd>see struct ablkcipher_alg</dd>
<dt><code class="docutils literal"><span class="pre">ivsize</span></code></dt>
<dd>see struct ablkcipher_alg</dd>
</dl>
<p><strong>Description</strong></p>
<p>All fields except <strong>geniv</strong> and <strong>ivsize</strong> are mandatory and must be filled.</p>
<dl class="type">
<dt id="c.cipher_alg">
struct <code class="descname">cipher_alg</code><a class="headerlink" href="#c.cipher_alg" title="Permalink to this definition">¶</a></dt>
<dd><p>single-block symmetric ciphers definition</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct cipher_alg {
  unsigned int cia_min_keysize;
  unsigned int cia_max_keysize;
  int (* cia_setkey) (struct crypto_tfm *tfm, const u8 *key, unsigned int keylen);
  void (* cia_encrypt) (struct crypto_tfm *tfm, u8 *dst, const u8 *src);
  void (* cia_decrypt) (struct crypto_tfm *tfm, u8 *dst, const u8 *src);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cia_min_keysize</span></code></dt>
<dd>Minimum key size supported by the transformation. This is
the smallest key length supported by this transformation
algorithm. This must be set to one of the pre-defined
values as this is not hardware specific. Possible values
for this field can be found via git grep “_MIN_KEY_SIZE”
include/crypto/</dd>
<dt><code class="docutils literal"><span class="pre">cia_max_keysize</span></code></dt>
<dd>Maximum key size supported by the transformation. This is
the largest key length supported by this transformation
algorithm. This must be set to one of the pre-defined values
as this is not hardware specific. Possible values for this
field can be found via git grep “_MAX_KEY_SIZE”
include/crypto/</dd>
<dt><code class="docutils literal"><span class="pre">cia_setkey</span></code></dt>
<dd>Set key for the transformation. This function is used to either
program a supplied key into the hardware or store the key in the
transformation context for programming it later. Note that this
function does modify the transformation context. This function
can be called multiple times during the existence of the
transformation object, so one must make sure the key is properly
reprogrammed into the hardware. This function is also
responsible for checking the key length for validity.</dd>
<dt><code class="docutils literal"><span class="pre">cia_encrypt</span></code></dt>
<dd>Encrypt a single block. This function is used to encrypt a
single block of data, which must be <strong>cra_blocksize</strong> big. This
always operates on a full <strong>cra_blocksize</strong> and it is not possible
to encrypt a block of smaller size. The supplied buffers must
therefore also be at least of <strong>cra_blocksize</strong> size. Both the
input and output buffers are always aligned to <strong>cra_alignmask</strong>.
In case either of the input or output buffer supplied by user
of the crypto API is not aligned to <strong>cra_alignmask</strong>, the crypto
API will re-align the buffers. The re-alignment means that a
new buffer will be allocated, the data will be copied into the
new buffer, then the processing will happen on the new buffer,
then the data will be copied back into the original buffer and
finally the new buffer will be freed. In case a software
fallback was put in place in the <strong>cra_init</strong> call, this function
might need to use the fallback if the algorithm doesn’t support
all of the key sizes. In case the key was stored in
transformation context, the key might need to be re-programmed
into the hardware in this function. This function shall not
modify the transformation context, as this function may be
called in parallel with the same transformation object.</dd>
<dt><code class="docutils literal"><span class="pre">cia_decrypt</span></code></dt>
<dd>Decrypt a single block. This is a reverse counterpart to
<strong>cia_encrypt</strong>, and the conditions are exactly the same.</dd>
</dl>
<p><strong>Description</strong></p>
<p>All fields are mandatory and must be filled.</p>
<dl class="type">
<dt id="c.crypto_alg">
struct <code class="descname">crypto_alg</code><a class="headerlink" href="#c.crypto_alg" title="Permalink to this definition">¶</a></dt>
<dd><p>definition of a cryptograpic cipher algorithm</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct crypto_alg {
  struct list_head cra_list;
  struct list_head cra_users;
  u32 cra_flags;
  unsigned int cra_blocksize;
  unsigned int cra_ctxsize;
  unsigned int cra_alignmask;
  int cra_priority;
  atomic_t cra_refcnt;
  char cra_name;
  char cra_driver_name;
  const struct crypto_type * cra_type;
  union cra_u;
  int (* cra_init) (struct crypto_tfm *tfm);
  void (* cra_exit) (struct crypto_tfm *tfm);
  void (* cra_destroy) (struct crypto_alg *alg);
  struct module * cra_module;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cra_list</span></code></dt>
<dd>internally used</dd>
<dt><code class="docutils literal"><span class="pre">cra_users</span></code></dt>
<dd>internally used</dd>
<dt><code class="docutils literal"><span class="pre">cra_flags</span></code></dt>
<dd>Flags describing this transformation. See include/linux/crypto.h
CRYPTO_ALG_* flags for the flags which go in here. Those are
used for fine-tuning the description of the transformation
algorithm.</dd>
<dt><code class="docutils literal"><span class="pre">cra_blocksize</span></code></dt>
<dd>Minimum block size of this transformation. The size in bytes
of the smallest possible unit which can be transformed with
this algorithm. The users must respect this value.
In case of HASH transformation, it is possible for a smaller
block than <strong>cra_blocksize</strong> to be passed to the crypto API for
transformation, in case of any other transformation type, an
error will be returned upon any attempt to transform smaller
than <strong>cra_blocksize</strong> chunks.</dd>
<dt><code class="docutils literal"><span class="pre">cra_ctxsize</span></code></dt>
<dd>Size of the operational context of the transformation. This
value informs the kernel crypto API about the memory size
needed to be allocated for the transformation context.</dd>
<dt><code class="docutils literal"><span class="pre">cra_alignmask</span></code></dt>
<dd>Alignment mask for the input and output data buffer. The data
buffer containing the input data for the algorithm must be
aligned to this alignment mask. The data buffer for the
output data must be aligned to this alignment mask. Note that
the Crypto API will do the re-alignment in software, but
only under special conditions and there is a performance hit.
The re-alignment happens at these occasions for different
<strong>cra_u</strong> types: cipher – For both input data and output data
buffer; ahash – For output hash destination buf; shash –
For output hash destination buf.
This is needed on hardware which is flawed by design and
cannot pick data from arbitrary addresses.</dd>
<dt><code class="docutils literal"><span class="pre">cra_priority</span></code></dt>
<dd>Priority of this transformation implementation. In case
multiple transformations with same <strong>cra_name</strong> are available to
the Crypto API, the kernel will use the one with highest
<strong>cra_priority</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">cra_refcnt</span></code></dt>
<dd>internally used</dd>
<dt><code class="docutils literal"><span class="pre">cra_name</span></code></dt>
<dd>Generic name (usable by multiple implementations) of the
transformation algorithm. This is the name of the transformation
itself. This field is used by the kernel when looking up the
providers of particular transformation.</dd>
<dt><code class="docutils literal"><span class="pre">cra_driver_name</span></code></dt>
<dd>Unique name of the transformation provider. This is the
name of the provider of the transformation. This can be any
arbitrary value, but in the usual case, this contains the
name of the chip or provider and the name of the
transformation algorithm.</dd>
<dt><code class="docutils literal"><span class="pre">cra_type</span></code></dt>
<dd>Type of the cryptographic transformation. This is a pointer to
struct crypto_type, which implements callbacks common for all
transformation types. There are multiple options:
<code class="xref c c-type docutils literal"><span class="pre">crypto_blkcipher_type</span></code>, <code class="xref c c-type docutils literal"><span class="pre">crypto_ablkcipher_type</span></code>,
<code class="xref c c-type docutils literal"><span class="pre">crypto_ahash_type</span></code>, <code class="xref c c-type docutils literal"><span class="pre">crypto_rng_type</span></code>.
This field might be empty. In that case, there are no common
callbacks. This is the case for: cipher, compress, shash.</dd>
<dt><code class="docutils literal"><span class="pre">cra_u</span></code></dt>
<dd>Callbacks implementing the transformation. This is a union of
multiple structures. Depending on the type of transformation selected
by <strong>cra_type</strong> and <strong>cra_flags</strong> above, the associated structure must be
filled with callbacks. This field might be empty. This is the case
for ahash, shash.</dd>
<dt><code class="docutils literal"><span class="pre">cra_init</span></code></dt>
<dd>Initialize the cryptographic transformation object. This function
is used to initialize the cryptographic transformation object.
This function is called only once at the instantiation time, right
after the transformation context was allocated. In case the
cryptographic hardware has some special requirements which need to
be handled by software, this function shall check for the precise
requirement of the transformation and put any software fallbacks
in place.</dd>
<dt><code class="docutils literal"><span class="pre">cra_exit</span></code></dt>
<dd>Deinitialize the cryptographic transformation object. This is a
counterpart to <strong>cra_init</strong>, used to remove various changes set in
<strong>cra_init</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">cra_destroy</span></code></dt>
<dd>internally used</dd>
<dt><code class="docutils literal"><span class="pre">cra_module</span></code></dt>
<dd>Owner of this transformation implementation. Set to THIS_MODULE</dd>
</dl>
<p><strong>Description</strong></p>
<p>The struct crypto_alg describes a generic Crypto API algorithm and is common
for all of the transformations. Any variable not documented here shall not
be used by a cipher implementation as it is internal to the Crypto API.</p>
</div>
<div class="section" id="symmetric-key-cipher-api">
<h1>Symmetric Key Cipher API<a class="headerlink" href="#symmetric-key-cipher-api" title="Permalink to this headline">¶</a></h1>
<p>Symmetric key cipher API is used with the ciphers of type
CRYPTO_ALG_TYPE_SKCIPHER (listed as type “skcipher” in /proc/crypto).</p>
<p>Asynchronous cipher operations imply that the function invocation for a
cipher request returns immediately before the completion of the operation.
The cipher request is scheduled as a separate kernel thread and therefore
load-balanced on the different CPUs via the process scheduler. To allow
the kernel crypto API to inform the caller about the completion of a cipher
request, the caller must provide a callback function. That function is
invoked with the cipher handle when the request completes.</p>
<p>To support the asynchronous operation, additional information than just the
cipher handle must be supplied to the kernel crypto API. That additional
information is given by filling in the skcipher_request data structure.</p>
<p>For the symmetric key cipher API, the state is maintained with the tfm
cipher handle. A single tfm can be used across multiple calls and in
parallel. For asynchronous block cipher calls, context data supplied and
only used by the caller can be referenced the request data structure in
addition to the IV used for the cipher request. The maintenance of such
state information would be important for a crypto driver implementer to
have, because when calling the callback function upon completion of the
cipher operation, that callback function may need some information about
which operation just finished if it invoked multiple in parallel. This
state information is unused by the kernel crypto API.</p>
<dl class="function">
<dt id="c.crypto_alloc_skcipher">
struct crypto_skcipher * <code class="descname">crypto_alloc_skcipher</code><span class="sig-paren">(</span>const char *<em>&nbsp;alg_name</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_alloc_skcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate symmetric key cipher handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alg_name</span></code></dt>
<dd>is the cra_name / name or cra_driver_name / driver name of the
skcipher cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>specifies the type of the cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>specifies the mask for the cipher</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a cipher handle for an skcipher. The returned struct
crypto_skcipher is the cipher handle that is required for any subsequent
API invocation for that skcipher.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>allocated cipher handle in case of success; <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> is true in case</dt>
<dd>of an error, <code class="xref c c-func docutils literal"><span class="pre">PTR_ERR()</span></code> returns the error code.</dd>
</dl>
<dl class="function">
<dt id="c.crypto_free_skcipher">
void <code class="descname">crypto_free_skcipher</code><span class="sig-paren">(</span>struct crypto_skcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_free_skcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free cipher handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle to be freed</dd>
</dl>
<dl class="function">
<dt id="c.crypto_has_skcipher">
int <code class="descname">crypto_has_skcipher</code><span class="sig-paren">(</span>const char *<em>&nbsp;alg_name</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_has_skcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the availability of an skcipher.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alg_name</span></code></dt>
<dd>is the cra_name / name or cra_driver_name / driver name of the
skcipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>specifies the type of the cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>specifies the mask for the cipher</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>true when the skcipher is known to the kernel crypto API; false</dt>
<dd>otherwise</dd>
</dl>
<dl class="function">
<dt id="c.crypto_skcipher_ivsize">
unsigned int <code class="descname">crypto_skcipher_ivsize</code><span class="sig-paren">(</span>struct crypto_skcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_ivsize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain IV size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>The size of the IV for the skcipher referenced by the cipher handle is
returned. This IV size may be zero if the cipher does not need an IV.</p>
<p><strong>Return</strong></p>
<p>IV size in bytes</p>
<dl class="function">
<dt id="c.crypto_skcipher_blocksize">
unsigned int <code class="descname">crypto_skcipher_blocksize</code><span class="sig-paren">(</span>struct crypto_skcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain block size of cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>The block size for the skcipher referenced with the cipher handle is
returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation</p>
<p><strong>Return</strong></p>
<p>block size of cipher</p>
<dl class="function">
<dt id="c.crypto_skcipher_setkey">
int <code class="descname">crypto_skcipher_setkey</code><span class="sig-paren">(</span>struct crypto_skcipher *<em>&nbsp;tfm</em>, const u8 *<em>&nbsp;key</em>, unsigned int<em>&nbsp;keylen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_setkey" title="Permalink to this definition">¶</a></dt>
<dd><p>set key for cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>buffer holding the key</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">keylen</span></code></dt>
<dd>length of the key in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller provided key is set for the skcipher referenced by the cipher
handle.</p>
<p>Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.</p>
<p><strong>Return</strong></p>
<p>0 if the setting of the key was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_skcipher_reqtfm">
struct crypto_skcipher * <code class="descname">crypto_skcipher_reqtfm</code><span class="sig-paren">(</span>struct skcipher_request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_reqtfm" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain cipher handle from request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>skcipher_request out of which the cipher handle is to be obtained</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the crypto_skcipher handle when furnishing an skcipher_request
data structure.</p>
<p><strong>Return</strong></p>
<p>crypto_skcipher handle</p>
<dl class="function">
<dt id="c.crypto_skcipher_encrypt">
int <code class="descname">crypto_skcipher_encrypt</code><span class="sig-paren">(</span>struct skcipher_request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_encrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>encrypt plaintext</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>reference to the skcipher_request handle that holds all information
needed to perform the cipher operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encrypt plaintext data using the skcipher_request handle. That data
structure and how it is filled with data is discussed with the
skcipher_request_* functions.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_skcipher_decrypt">
int <code class="descname">crypto_skcipher_decrypt</code><span class="sig-paren">(</span>struct skcipher_request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_decrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>decrypt ciphertext</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>reference to the skcipher_request handle that holds all information
needed to perform the cipher operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrypt ciphertext data using the skcipher_request handle. That data
structure and how it is filled with data is discussed with the
skcipher_request_* functions.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
</div>
<div class="section" id="symmetric-key-cipher-request-handle">
<h1>Symmetric Key Cipher Request Handle<a class="headerlink" href="#symmetric-key-cipher-request-handle" title="Permalink to this headline">¶</a></h1>
<p>The skcipher_request data structure contains all pointers to data
required for the symmetric key cipher operation. This includes the cipher
handle (which can be used by multiple skcipher_request instances), pointer
to plaintext and ciphertext, asynchronous callback function, etc. It acts
as a handle to the skcipher_request_* API calls in a similar way as
skcipher handle to the crypto_skcipher_* API calls.</p>
<dl class="function">
<dt id="c.crypto_skcipher_reqsize">
unsigned int <code class="descname">crypto_skcipher_reqsize</code><span class="sig-paren">(</span>struct crypto_skcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_skcipher_reqsize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain size of the request data structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of bytes</p>
<dl class="function">
<dt id="c.skcipher_request_set_tfm">
void <code class="descname">skcipher_request_set_tfm</code><span class="sig-paren">(</span>struct skcipher_request *<em>&nbsp;req</em>, struct crypto_skcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_set_tfm" title="Permalink to this definition">¶</a></dt>
<dd><p>update cipher handle reference in request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request handle to be modified</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle that shall be added to the request handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow the caller to replace the existing skcipher handle in the request
data structure with a different one.</p>
<dl class="function">
<dt id="c.skcipher_request_alloc">
struct skcipher_request * <code class="descname">skcipher_request_alloc</code><span class="sig-paren">(</span>struct crypto_skcipher *<em>&nbsp;tfm</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate request data structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_skcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle to be registered with the request</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>memory allocation flag that is handed to kmalloc by the API call.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the request data structure that must be used with the skcipher
encrypt and decrypt API calls. During the allocation, the provided skcipher
handle is registered in the request data structure.</p>
<p><strong>Return</strong></p>
<p>allocated request handle in case of success, or NULL if out of memory</p>
<dl class="function">
<dt id="c.skcipher_request_free">
void <code class="descname">skcipher_request_free</code><span class="sig-paren">(</span>struct skcipher_request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_free" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free request data structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request data structure cipher handle to be freed</dd>
</dl>
<dl class="function">
<dt id="c.skcipher_request_set_callback">
void <code class="descname">skcipher_request_set_callback</code><span class="sig-paren">(</span>struct skcipher_request *<em>&nbsp;req</em>, u32<em>&nbsp;flags</em>, crypto_completion_t<em>&nbsp;compl</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_set_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>set asynchronous callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request handle</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>specify zero or an ORing of the flags
CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and
increase the wait queue beyond the initial maximum size;
CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep</dd>
<dt><code class="docutils literal"><span class="pre">crypto_completion_t</span> <span class="pre">compl</span></code></dt>
<dd>callback function pointer to be registered with the request handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>The data pointer refers to memory that is not used by the kernel
crypto API, but provided to the callback function for it to use. Here,
the caller can provide a reference to memory the callback function can
operate on. As the callback function is invoked asynchronously to the
related functionality, it may need to access data structures of the
related functionality which can be referenced using this pointer. The
callback function can access the memory via the “data” field in the
crypto_async_request data structure provided to the callback function.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows setting the callback function that is triggered once the
cipher operation completes.</p>
<p>The callback function is registered with the skcipher_request handle and
must comply with the following template:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void callback_function(struct crypto_async_request *req, int error)
</pre></div>
</div>
<dl class="function">
<dt id="c.skcipher_request_set_crypt">
void <code class="descname">skcipher_request_set_crypt</code><span class="sig-paren">(</span>struct skcipher_request *<em>&nbsp;req</em>, struct scatterlist *<em>&nbsp;src</em>, struct scatterlist *<em>&nbsp;dst</em>, unsigned int<em>&nbsp;cryptlen</em>, void *<em>&nbsp;iv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skcipher_request_set_crypt" title="Permalink to this definition">¶</a></dt>
<dd><p>set data buffers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source scatter / gather list</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination scatter / gather list</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cryptlen</span></code></dt>
<dd>number of bytes to process from <strong>src</strong></dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">iv</span></code></dt>
<dd>IV for the cipher operation which must comply with the IV size defined
by crypto_skcipher_ivsize</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows setting of the source data and destination data
scatter / gather lists.</p>
<p>For encryption, the source is treated as the plaintext and the
destination is the ciphertext. For a decryption operation, the use is
reversed - the source is the ciphertext and the destination is the plaintext.</p>
</div>
<div class="section" id="single-block-cipher-api">
<h1>Single Block Cipher API<a class="headerlink" href="#single-block-cipher-api" title="Permalink to this headline">¶</a></h1>
<p>The single block cipher API is used with the ciphers of type
CRYPTO_ALG_TYPE_CIPHER (listed as type “cipher” in /proc/crypto).</p>
<p>Using the single block cipher API calls, operations with the basic cipher
primitive can be implemented. These cipher primitives exclude any block
chaining operations including IV handling.</p>
<p>The purpose of this single block cipher API is to support the implementation
of templates or other concepts that only need to perform the cipher operation
on one block at a time. Templates invoke the underlying cipher primitive
block-wise and process either the input or the output data of these cipher
operations.</p>
<dl class="function">
<dt id="c.crypto_alloc_cipher">
struct crypto_cipher * <code class="descname">crypto_alloc_cipher</code><span class="sig-paren">(</span>const char *<em>&nbsp;alg_name</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_alloc_cipher" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate single block cipher handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alg_name</span></code></dt>
<dd>is the cra_name / name or cra_driver_name / driver name of the
single block cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>specifies the type of the cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>specifies the mask for the cipher</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a cipher handle for a single block cipher. The returned struct
crypto_cipher is the cipher handle that is required for any subsequent API
invocation for that single block cipher.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>allocated cipher handle in case of success; <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> is true in case</dt>
<dd>of an error, <code class="xref c c-func docutils literal"><span class="pre">PTR_ERR()</span></code> returns the error code.</dd>
</dl>
<dl class="function">
<dt id="c.crypto_free_cipher">
void <code class="descname">crypto_free_cipher</code><span class="sig-paren">(</span>struct crypto_cipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_free_cipher" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free the single block cipher handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle to be freed</dd>
</dl>
<dl class="function">
<dt id="c.crypto_has_cipher">
int <code class="descname">crypto_has_cipher</code><span class="sig-paren">(</span>const char *<em>&nbsp;alg_name</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_has_cipher" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the availability of a single block cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alg_name</span></code></dt>
<dd>is the cra_name / name or cra_driver_name / driver name of the
single block cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>specifies the type of the cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>specifies the mask for the cipher</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>true when the single block cipher is known to the kernel crypto API;</dt>
<dd>false otherwise</dd>
</dl>
<dl class="function">
<dt id="c.crypto_cipher_blocksize">
unsigned int <code class="descname">crypto_cipher_blocksize</code><span class="sig-paren">(</span>struct crypto_cipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_cipher_blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain block size for cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>The block size for the single block cipher referenced with the cipher handle
tfm is returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation</p>
<p><strong>Return</strong></p>
<p>block size of cipher</p>
<dl class="function">
<dt id="c.crypto_cipher_setkey">
int <code class="descname">crypto_cipher_setkey</code><span class="sig-paren">(</span>struct crypto_cipher *<em>&nbsp;tfm</em>, const u8 *<em>&nbsp;key</em>, unsigned int<em>&nbsp;keylen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_cipher_setkey" title="Permalink to this definition">¶</a></dt>
<dd><p>set key for cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>buffer holding the key</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">keylen</span></code></dt>
<dd>length of the key in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller provided key is set for the single block cipher referenced by the
cipher handle.</p>
<p>Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.</p>
<p><strong>Return</strong></p>
<p>0 if the setting of the key was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_cipher_encrypt_one">
void <code class="descname">crypto_cipher_encrypt_one</code><span class="sig-paren">(</span>struct crypto_cipher *<em>&nbsp;tfm</em>, u8 *<em>&nbsp;dst</em>, const u8 *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_cipher_encrypt_one" title="Permalink to this definition">¶</a></dt>
<dd><p>encrypt one block of plaintext</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>points to the buffer that will be filled with the ciphertext</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>buffer holding the plaintext to be encrypted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoke the encryption operation of one block. The caller must ensure that
the plaintext and ciphertext buffers are at least one block in size.</p>
<dl class="function">
<dt id="c.crypto_cipher_decrypt_one">
void <code class="descname">crypto_cipher_decrypt_one</code><span class="sig-paren">(</span>struct crypto_cipher *<em>&nbsp;tfm</em>, u8 *<em>&nbsp;dst</em>, const u8 *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_cipher_decrypt_one" title="Permalink to this definition">¶</a></dt>
<dd><p>decrypt one block of ciphertext</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_cipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>points to the buffer that will be filled with the plaintext</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>buffer holding the ciphertext to be decrypted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Invoke the decryption operation of one block. The caller must ensure that
the plaintext and ciphertext buffers are at least one block in size.</p>
</div>
<div class="section" id="asynchronous-block-cipher-api-deprecated">
<h1>Asynchronous Block Cipher API - Deprecated<a class="headerlink" href="#asynchronous-block-cipher-api-deprecated" title="Permalink to this headline">¶</a></h1>
<p>Asynchronous block cipher API is used with the ciphers of type
CRYPTO_ALG_TYPE_ABLKCIPHER (listed as type “ablkcipher” in /proc/crypto).</p>
<p>Asynchronous cipher operations imply that the function invocation for a
cipher request returns immediately before the completion of the operation.
The cipher request is scheduled as a separate kernel thread and therefore
load-balanced on the different CPUs via the process scheduler. To allow
the kernel crypto API to inform the caller about the completion of a cipher
request, the caller must provide a callback function. That function is
invoked with the cipher handle when the request completes.</p>
<p>To support the asynchronous operation, additional information than just the
cipher handle must be supplied to the kernel crypto API. That additional
information is given by filling in the ablkcipher_request data structure.</p>
<p>For the asynchronous block cipher API, the state is maintained with the tfm
cipher handle. A single tfm can be used across multiple calls and in
parallel. For asynchronous block cipher calls, context data supplied and
only used by the caller can be referenced the request data structure in
addition to the IV used for the cipher request. The maintenance of such
state information would be important for a crypto driver implementer to
have, because when calling the callback function upon completion of the
cipher operation, that callback function may need some information about
which operation just finished if it invoked multiple in parallel. This
state information is unused by the kernel crypto API.</p>
<dl class="function">
<dt id="c.crypto_free_ablkcipher">
void <code class="descname">crypto_free_ablkcipher</code><span class="sig-paren">(</span>struct crypto_ablkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_free_ablkcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free cipher handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_ablkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle to be freed</dd>
</dl>
<dl class="function">
<dt id="c.crypto_has_ablkcipher">
int <code class="descname">crypto_has_ablkcipher</code><span class="sig-paren">(</span>const char *<em>&nbsp;alg_name</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_has_ablkcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the availability of an ablkcipher.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alg_name</span></code></dt>
<dd>is the cra_name / name or cra_driver_name / driver name of the
ablkcipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>specifies the type of the cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>specifies the mask for the cipher</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>true when the ablkcipher is known to the kernel crypto API; false</dt>
<dd>otherwise</dd>
</dl>
<dl class="function">
<dt id="c.crypto_ablkcipher_ivsize">
unsigned int <code class="descname">crypto_ablkcipher_ivsize</code><span class="sig-paren">(</span>struct crypto_ablkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ablkcipher_ivsize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain IV size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_ablkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>The size of the IV for the ablkcipher referenced by the cipher handle is
returned. This IV size may be zero if the cipher does not need an IV.</p>
<p><strong>Return</strong></p>
<p>IV size in bytes</p>
<dl class="function">
<dt id="c.crypto_ablkcipher_blocksize">
unsigned int <code class="descname">crypto_ablkcipher_blocksize</code><span class="sig-paren">(</span>struct crypto_ablkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ablkcipher_blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain block size of cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_ablkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>The block size for the ablkcipher referenced with the cipher handle is
returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation</p>
<p><strong>Return</strong></p>
<p>block size of cipher</p>
<dl class="function">
<dt id="c.crypto_ablkcipher_setkey">
int <code class="descname">crypto_ablkcipher_setkey</code><span class="sig-paren">(</span>struct crypto_ablkcipher *<em>&nbsp;tfm</em>, const u8 *<em>&nbsp;key</em>, unsigned int<em>&nbsp;keylen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ablkcipher_setkey" title="Permalink to this definition">¶</a></dt>
<dd><p>set key for cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_ablkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>buffer holding the key</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">keylen</span></code></dt>
<dd>length of the key in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller provided key is set for the ablkcipher referenced by the cipher
handle.</p>
<p>Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.</p>
<p><strong>Return</strong></p>
<p>0 if the setting of the key was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_ablkcipher_reqtfm">
struct crypto_ablkcipher * <code class="descname">crypto_ablkcipher_reqtfm</code><span class="sig-paren">(</span>struct ablkcipher_request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ablkcipher_reqtfm" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain cipher handle from request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ablkcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>ablkcipher_request out of which the cipher handle is to be obtained</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the crypto_ablkcipher handle when furnishing an ablkcipher_request
data structure.</p>
<p><strong>Return</strong></p>
<p>crypto_ablkcipher handle</p>
<dl class="function">
<dt id="c.crypto_ablkcipher_encrypt">
int <code class="descname">crypto_ablkcipher_encrypt</code><span class="sig-paren">(</span>struct ablkcipher_request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ablkcipher_encrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>encrypt plaintext</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ablkcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>reference to the ablkcipher_request handle that holds all information
needed to perform the cipher operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encrypt plaintext data using the ablkcipher_request handle. That data
structure and how it is filled with data is discussed with the
ablkcipher_request_* functions.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_ablkcipher_decrypt">
int <code class="descname">crypto_ablkcipher_decrypt</code><span class="sig-paren">(</span>struct ablkcipher_request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ablkcipher_decrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>decrypt ciphertext</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ablkcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>reference to the ablkcipher_request handle that holds all information
needed to perform the cipher operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrypt ciphertext data using the ablkcipher_request handle. That data
structure and how it is filled with data is discussed with the
ablkcipher_request_* functions.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
</div>
<div class="section" id="asynchronous-cipher-request-handle-deprecated">
<h1>Asynchronous Cipher Request Handle - Deprecated<a class="headerlink" href="#asynchronous-cipher-request-handle-deprecated" title="Permalink to this headline">¶</a></h1>
<p>The ablkcipher_request data structure contains all pointers to data
required for the asynchronous cipher operation. This includes the cipher
handle (which can be used by multiple ablkcipher_request instances), pointer
to plaintext and ciphertext, asynchronous callback function, etc. It acts
as a handle to the ablkcipher_request_* API calls in a similar way as
ablkcipher handle to the crypto_ablkcipher_* API calls.</p>
<dl class="function">
<dt id="c.crypto_ablkcipher_reqsize">
unsigned int <code class="descname">crypto_ablkcipher_reqsize</code><span class="sig-paren">(</span>struct crypto_ablkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_ablkcipher_reqsize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain size of the request data structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_ablkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Return</strong></p>
<p>number of bytes</p>
<dl class="function">
<dt id="c.ablkcipher_request_set_tfm">
void <code class="descname">ablkcipher_request_set_tfm</code><span class="sig-paren">(</span>struct ablkcipher_request *<em>&nbsp;req</em>, struct crypto_ablkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ablkcipher_request_set_tfm" title="Permalink to this definition">¶</a></dt>
<dd><p>update cipher handle reference in request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ablkcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request handle to be modified</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_ablkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle that shall be added to the request handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow the caller to replace the existing ablkcipher handle in the request
data structure with a different one.</p>
<dl class="function">
<dt id="c.ablkcipher_request_alloc">
struct ablkcipher_request * <code class="descname">ablkcipher_request_alloc</code><span class="sig-paren">(</span>struct crypto_ablkcipher *<em>&nbsp;tfm</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ablkcipher_request_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate request data structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_ablkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle to be registered with the request</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>memory allocation flag that is handed to kmalloc by the API call.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate the request data structure that must be used with the ablkcipher
encrypt and decrypt API calls. During the allocation, the provided ablkcipher
handle is registered in the request data structure.</p>
<p><strong>Return</strong></p>
<p>allocated request handle in case of success, or NULL if out of memory</p>
<dl class="function">
<dt id="c.ablkcipher_request_free">
void <code class="descname">ablkcipher_request_free</code><span class="sig-paren">(</span>struct ablkcipher_request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ablkcipher_request_free" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free request data structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ablkcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request data structure cipher handle to be freed</dd>
</dl>
<dl class="function">
<dt id="c.ablkcipher_request_set_callback">
void <code class="descname">ablkcipher_request_set_callback</code><span class="sig-paren">(</span>struct ablkcipher_request *<em>&nbsp;req</em>, u32<em>&nbsp;flags</em>, crypto_completion_t<em>&nbsp;compl</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ablkcipher_request_set_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>set asynchronous callback function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ablkcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request handle</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>specify zero or an ORing of the flags
CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and
increase the wait queue beyond the initial maximum size;
CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep</dd>
<dt><code class="docutils literal"><span class="pre">crypto_completion_t</span> <span class="pre">compl</span></code></dt>
<dd>callback function pointer to be registered with the request handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>The data pointer refers to memory that is not used by the kernel
crypto API, but provided to the callback function for it to use. Here,
the caller can provide a reference to memory the callback function can
operate on. As the callback function is invoked asynchronously to the
related functionality, it may need to access data structures of the
related functionality which can be referenced using this pointer. The
callback function can access the memory via the “data” field in the
crypto_async_request data structure provided to the callback function.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows setting the callback function that is triggered once the
cipher operation completes.</p>
<p>The callback function is registered with the ablkcipher_request handle and
must comply with the following template:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>void callback_function(struct crypto_async_request *req, int error)
</pre></div>
</div>
<dl class="function">
<dt id="c.ablkcipher_request_set_crypt">
void <code class="descname">ablkcipher_request_set_crypt</code><span class="sig-paren">(</span>struct ablkcipher_request *<em>&nbsp;req</em>, struct scatterlist *<em>&nbsp;src</em>, struct scatterlist *<em>&nbsp;dst</em>, unsigned int<em>&nbsp;nbytes</em>, void *<em>&nbsp;iv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ablkcipher_request_set_crypt" title="Permalink to this definition">¶</a></dt>
<dd><p>set data buffers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ablkcipher_request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source scatter / gather list</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination scatter / gather list</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt>
<dd>number of bytes to process from <strong>src</strong></dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">iv</span></code></dt>
<dd>IV for the cipher operation which must comply with the IV size defined
by crypto_ablkcipher_ivsize</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows setting of the source data and destination data
scatter / gather lists.</p>
<p>For encryption, the source is treated as the plaintext and the
destination is the ciphertext. For a decryption operation, the use is
reversed - the source is the ciphertext and the destination is the plaintext.</p>
</div>
<div class="section" id="synchronous-block-cipher-api-deprecated">
<h1>Synchronous Block Cipher API - Deprecated<a class="headerlink" href="#synchronous-block-cipher-api-deprecated" title="Permalink to this headline">¶</a></h1>
<p>The synchronous block cipher API is used with the ciphers of type
CRYPTO_ALG_TYPE_BLKCIPHER (listed as type “blkcipher” in /proc/crypto)</p>
<p>Synchronous calls, have a context in the tfm. But since a single tfm can be
used in multiple calls and in parallel, this info should not be changeable
(unless a lock is used). This applies, for example, to the symmetric key.
However, the IV is changeable, so there is an iv field in blkcipher_tfm
structure for synchronous blkcipher api. So, its the only state info that can
be kept for synchronous calls without using a big lock across a tfm.</p>
<p>The block cipher API allows the use of a complete cipher, i.e. a cipher
consisting of a template (a block chaining mode) and a single block cipher
primitive (e.g. AES).</p>
<p>The plaintext data buffer and the ciphertext data buffer are pointed to
by using scatter/gather lists. The cipher operation is performed
on all segments of the provided scatter/gather lists.</p>
<p>The kernel crypto API supports a cipher operation “in-place” which means that
the caller may provide the same scatter/gather list for the plaintext and
cipher text. After the completion of the cipher operation, the plaintext
data is replaced with the ciphertext data in case of an encryption and vice
versa for a decryption. The caller must ensure that the scatter/gather lists
for the output data point to sufficiently large buffers, i.e. multiples of
the block size of the cipher.</p>
<dl class="function">
<dt id="c.crypto_alloc_blkcipher">
struct crypto_blkcipher * <code class="descname">crypto_alloc_blkcipher</code><span class="sig-paren">(</span>const char *<em>&nbsp;alg_name</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_alloc_blkcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate synchronous block cipher handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alg_name</span></code></dt>
<dd>is the cra_name / name or cra_driver_name / driver name of the
blkcipher cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>specifies the type of the cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>specifies the mask for the cipher</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a cipher handle for a block cipher. The returned struct
crypto_blkcipher is the cipher handle that is required for any subsequent
API invocation for that block cipher.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>allocated cipher handle in case of success; <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> is true in case</dt>
<dd>of an error, <code class="xref c c-func docutils literal"><span class="pre">PTR_ERR()</span></code> returns the error code.</dd>
</dl>
<dl class="function">
<dt id="c.crypto_free_blkcipher">
void <code class="descname">crypto_free_blkcipher</code><span class="sig-paren">(</span>struct crypto_blkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_free_blkcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>zeroize and free the block cipher handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_blkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle to be freed</dd>
</dl>
<dl class="function">
<dt id="c.crypto_has_blkcipher">
int <code class="descname">crypto_has_blkcipher</code><span class="sig-paren">(</span>const char *<em>&nbsp;alg_name</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_has_blkcipher" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the availability of a block cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">alg_name</span></code></dt>
<dd>is the cra_name / name or cra_driver_name / driver name of the
block cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>specifies the type of the cipher</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">mask</span></code></dt>
<dd>specifies the mask for the cipher</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>true when the block cipher is known to the kernel crypto API; false</dt>
<dd>otherwise</dd>
</dl>
<dl class="function">
<dt id="c.crypto_blkcipher_name">
const char * <code class="descname">crypto_blkcipher_name</code><span class="sig-paren">(</span>struct crypto_blkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_name" title="Permalink to this definition">¶</a></dt>
<dd><p>return the name / cra_name from the cipher handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_blkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Return</strong></p>
<p>The character string holding the name of the cipher</p>
<dl class="function">
<dt id="c.crypto_blkcipher_ivsize">
unsigned int <code class="descname">crypto_blkcipher_ivsize</code><span class="sig-paren">(</span>struct crypto_blkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_ivsize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain IV size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_blkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>The size of the IV for the block cipher referenced by the cipher handle is
returned. This IV size may be zero if the cipher does not need an IV.</p>
<p><strong>Return</strong></p>
<p>IV size in bytes</p>
<dl class="function">
<dt id="c.crypto_blkcipher_blocksize">
unsigned int <code class="descname">crypto_blkcipher_blocksize</code><span class="sig-paren">(</span>struct crypto_blkcipher *<em>&nbsp;tfm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_blocksize" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain block size of cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_blkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>The block size for the block cipher referenced with the cipher handle is
returned. The caller may use that information to allocate appropriate
memory for the data returned by the encryption or decryption operation.</p>
<p><strong>Return</strong></p>
<p>block size of cipher</p>
<dl class="function">
<dt id="c.crypto_blkcipher_setkey">
int <code class="descname">crypto_blkcipher_setkey</code><span class="sig-paren">(</span>struct crypto_blkcipher *<em>&nbsp;tfm</em>, const u8 *<em>&nbsp;key</em>, unsigned int<em>&nbsp;keylen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_setkey" title="Permalink to this definition">¶</a></dt>
<dd><p>set key for cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_blkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>buffer holding the key</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">keylen</span></code></dt>
<dd>length of the key in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller provided key is set for the block cipher referenced by the cipher
handle.</p>
<p>Note, the key length determines the cipher type. Many block ciphers implement
different cipher modes depending on the key size, such as AES-128 vs AES-192
vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128
is performed.</p>
<p><strong>Return</strong></p>
<p>0 if the setting of the key was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_blkcipher_encrypt">
int <code class="descname">crypto_blkcipher_encrypt</code><span class="sig-paren">(</span>struct blkcipher_desc *<em>&nbsp;desc</em>, struct scatterlist *<em>&nbsp;dst</em>, struct scatterlist *<em>&nbsp;src</em>, unsigned int<em>&nbsp;nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_encrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>encrypt plaintext</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blkcipher_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>reference to the block cipher handle with meta data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>scatter/gather list that is filled by the cipher operation with the
ciphertext</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>scatter/gather list that holds the plaintext</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt>
<dd>number of bytes of the plaintext to encrypt.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encrypt plaintext data using the IV set by the caller with a preceding
call of crypto_blkcipher_set_iv.</p>
<p>The blkcipher_desc data structure must be filled by the caller and can
reside on the stack. The caller must fill desc as follows: desc.tfm is filled
with the block cipher handle; desc.flags is filled with either
CRYPTO_TFM_REQ_MAY_SLEEP or 0.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_blkcipher_encrypt_iv">
int <code class="descname">crypto_blkcipher_encrypt_iv</code><span class="sig-paren">(</span>struct blkcipher_desc *<em>&nbsp;desc</em>, struct scatterlist *<em>&nbsp;dst</em>, struct scatterlist *<em>&nbsp;src</em>, unsigned int<em>&nbsp;nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_encrypt_iv" title="Permalink to this definition">¶</a></dt>
<dd><p>encrypt plaintext with dedicated IV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blkcipher_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>reference to the block cipher handle with meta data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>scatter/gather list that is filled by the cipher operation with the
ciphertext</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>scatter/gather list that holds the plaintext</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt>
<dd>number of bytes of the plaintext to encrypt.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encrypt plaintext data with the use of an IV that is solely used for this
cipher operation. Any previously set IV is not used.</p>
<p>The blkcipher_desc data structure must be filled by the caller and can
reside on the stack. The caller must fill desc as follows: desc.tfm is filled
with the block cipher handle; desc.info is filled with the IV to be used for
the current operation; desc.flags is filled with either
CRYPTO_TFM_REQ_MAY_SLEEP or 0.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_blkcipher_decrypt">
int <code class="descname">crypto_blkcipher_decrypt</code><span class="sig-paren">(</span>struct blkcipher_desc *<em>&nbsp;desc</em>, struct scatterlist *<em>&nbsp;dst</em>, struct scatterlist *<em>&nbsp;src</em>, unsigned int<em>&nbsp;nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_decrypt" title="Permalink to this definition">¶</a></dt>
<dd><p>decrypt ciphertext</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blkcipher_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>reference to the block cipher handle with meta data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>scatter/gather list that is filled by the cipher operation with the
plaintext</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>scatter/gather list that holds the ciphertext</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt>
<dd>number of bytes of the ciphertext to decrypt.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrypt ciphertext data using the IV set by the caller with a preceding
call of crypto_blkcipher_set_iv.</p>
<p>The blkcipher_desc data structure must be filled by the caller as documented
for the crypto_blkcipher_encrypt call above.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_blkcipher_decrypt_iv">
int <code class="descname">crypto_blkcipher_decrypt_iv</code><span class="sig-paren">(</span>struct blkcipher_desc *<em>&nbsp;desc</em>, struct scatterlist *<em>&nbsp;dst</em>, struct scatterlist *<em>&nbsp;src</em>, unsigned int<em>&nbsp;nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_decrypt_iv" title="Permalink to this definition">¶</a></dt>
<dd><p>decrypt ciphertext with dedicated IV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blkcipher_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>reference to the block cipher handle with meta data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>scatter/gather list that is filled by the cipher operation with the
plaintext</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>scatter/gather list that holds the ciphertext</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt>
<dd>number of bytes of the ciphertext to decrypt.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrypt ciphertext data with the use of an IV that is solely used for this
cipher operation. Any previously set IV is not used.</p>
<p>The blkcipher_desc data structure must be filled by the caller as documented
for the crypto_blkcipher_encrypt_iv call above.</p>
<p><strong>Return</strong></p>
<p>0 if the cipher operation was successful; &lt; 0 if an error occurred</p>
<dl class="function">
<dt id="c.crypto_blkcipher_set_iv">
void <code class="descname">crypto_blkcipher_set_iv</code><span class="sig-paren">(</span>struct crypto_blkcipher *<em>&nbsp;tfm</em>, const u8 *<em>&nbsp;src</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_set_iv" title="Permalink to this definition">¶</a></dt>
<dd><p>set IV for cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_blkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>buffer holding the IV</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of the IV in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller provided IV is set for the block cipher referenced by the cipher
handle.</p>
<dl class="function">
<dt id="c.crypto_blkcipher_get_iv">
void <code class="descname">crypto_blkcipher_get_iv</code><span class="sig-paren">(</span>struct crypto_blkcipher *<em>&nbsp;tfm</em>, u8 *<em>&nbsp;dst</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crypto_blkcipher_get_iv" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain IV from cipher</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">crypto_blkcipher</span> <span class="pre">*</span> <span class="pre">tfm</span></code></dt>
<dd>cipher handle</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>buffer filled with the IV</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of the buffer dst</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller can obtain the IV set for the block cipher referenced by the
cipher handle and store it into the user-provided buffer. If the buffer
has an insufficient space, the IV is truncated to fit the buffer.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api-aead.html" class="btn btn-neutral float-right" title="Authenticated Encryption With Associated Data (AEAD) Algorithm Definitions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="api.html" class="btn btn-neutral" title="Programming Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>