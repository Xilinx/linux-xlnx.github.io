

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux Networking and Network Devices APIs &mdash; The Linux Kernel  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Z8530 Programming Guide" href="z8530book.html" />
    <link rel="prev" title="batman-adv" href="batman-adv.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.14.0-xilinx-v2018.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user’s and administrator’s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer’s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Linux Networking and Network Devices APIs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#linux-networking">Linux Networking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#networking-base-types">Networking Base Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#socket-buffer-functions">Socket Buffer Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#socket-filter">Socket Filter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-network-statistics">Generic Network Statistics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sun-rpc-subsystem">SUN RPC subsystem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wimax">WiMAX</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#network-device-support">Network device support</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#driver-support">Driver Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#phy-support">PHY Support</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="z8530book.html">Z8530 Programming Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ko_KR/index.html">Korean translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/zh_CN/index.html">Chinese translations</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/ja_JP/index.html">Japanese translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
        
      <li>Linux Networking and Network Devices APIs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/networking/kapi.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux-networking-and-network-devices-apis">
<h1>Linux Networking and Network Devices APIs<a class="headerlink" href="#linux-networking-and-network-devices-apis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="linux-networking">
<h2>Linux Networking<a class="headerlink" href="#linux-networking" title="Permalink to this headline">¶</a></h2>
<div class="section" id="networking-base-types">
<h3>Networking Base Types<a class="headerlink" href="#networking-base-types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.sock_type">
enum <code class="descname">sock_type</code><a class="headerlink" href="#c.sock_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Socket types</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">SOCK_STREAM</span></code></dt>
<dd>stream (connection) socket</dd>
<dt><code class="docutils literal"><span class="pre">SOCK_DGRAM</span></code></dt>
<dd>datagram (conn.less) socket</dd>
<dt><code class="docutils literal"><span class="pre">SOCK_RAW</span></code></dt>
<dd>raw socket</dd>
<dt><code class="docutils literal"><span class="pre">SOCK_RDM</span></code></dt>
<dd>reliably-delivered message</dd>
<dt><code class="docutils literal"><span class="pre">SOCK_SEQPACKET</span></code></dt>
<dd>sequential packet socket</dd>
<dt><code class="docutils literal"><span class="pre">SOCK_DCCP</span></code></dt>
<dd>Datagram Congestion Control Protocol socket</dd>
<dt><code class="docutils literal"><span class="pre">SOCK_PACKET</span></code></dt>
<dd>linux specific way of getting packets at the dev level.
For writing rarp and other similar things on the user level.</dd>
</dl>
<p><strong>Description</strong></p>
<p>When adding some new socket type please
grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS
overrides this enum for binary compat reasons.</p>
<dl class="type">
<dt id="c.socket">
struct <code class="descname">socket</code><a class="headerlink" href="#c.socket" title="Permalink to this definition">¶</a></dt>
<dd><p>general BSD socket</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct socket {
  socket_state state;
  short type;
  unsigned long flags;
  struct socket_wq __rcu * wq;
  struct file * file;
  struct sock * sk;
  const struct proto_ops * ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>socket state (<code class="docutils literal"><span class="pre">SS_CONNECTED</span></code>, etc)</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>socket type (<code class="docutils literal"><span class="pre">SOCK_STREAM</span></code>, etc)</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>socket flags (<code class="docutils literal"><span class="pre">SOCK_NOSPACE</span></code>, etc)</dd>
<dt><code class="docutils literal"><span class="pre">wq</span></code></dt>
<dd>wait queue for several uses</dd>
<dt><code class="docutils literal"><span class="pre">file</span></code></dt>
<dd>File back pointer for gc</dd>
<dt><code class="docutils literal"><span class="pre">sk</span></code></dt>
<dd>internal networking protocol agnostic socket representation</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>protocol specific socket operations</dd>
</dl>
</div>
<div class="section" id="socket-buffer-functions">
<h3>Socket Buffer Functions<a class="headerlink" href="#socket-buffer-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.skb_frag_foreach_page">
<code class="descname">skb_frag_foreach_page</code><span class="sig-paren">(</span><em>f</em>, <em>f_off</em>, <em>f_len</em>, <em>p</em>, <em>p_off</em>, <em>p_len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_foreach_page" title="Permalink to this definition">¶</a></dt>
<dd><p>loop over pages in a fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">f</span></code></dt>
<dd>skb frag to operate on</dd>
<dt><code class="docutils literal"><span class="pre">f_off</span></code></dt>
<dd>offset from start of f-&gt;page.p</dd>
<dt><code class="docutils literal"><span class="pre">f_len</span></code></dt>
<dd>length from f_off to loop over</dd>
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>(temp var) current page</dd>
<dt><code class="docutils literal"><span class="pre">p_off</span></code></dt>
<dd>(temp var) offset from start of current page,
non-zero only on first page.</dd>
<dt><code class="docutils literal"><span class="pre">p_len</span></code></dt>
<dd>(temp var) length in current page,
&lt; PAGE_SIZE only on first and last page.</dd>
<dt><code class="docutils literal"><span class="pre">copied</span></code></dt>
<dd>(temp var) length so far, excluding current p_len.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>A fragment can hold a compound page, in which case per-page
operations, notably kmap_atomic, must be called for each
regular page.</div></blockquote>
<dl class="type">
<dt id="c.skb_shared_hwtstamps">
struct <code class="descname">skb_shared_hwtstamps</code><a class="headerlink" href="#c.skb_shared_hwtstamps" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware time stamps</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct skb_shared_hwtstamps {
  ktime_t hwtstamp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">hwtstamp</span></code></dt>
<dd>hardware time stamp transformed into duration
since arbitrary point in time</dd>
</dl>
<p><strong>Description</strong></p>
<p>Software time stamps generated by <code class="xref c c-func docutils literal"><span class="pre">ktime_get_real()</span></code> are stored in
skb-&gt;tstamp.</p>
<p>hwtstamps can only be compared against other hwtstamps from
the same device.</p>
<p>This structure is attached to packets as part of the
<code class="xref c c-type docutils literal"><span class="pre">skb_shared_info</span></code>. Use <code class="xref c c-func docutils literal"><span class="pre">skb_hwtstamps()</span></code> to get a pointer.</p>
<dl class="type">
<dt id="c.sk_buff">
struct <code class="descname">sk_buff</code><a class="headerlink" href="#c.sk_buff" title="Permalink to this definition">¶</a></dt>
<dd><p>socket buffer</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct sk_buff {
  union {unnamed_union};
  __u16 inner_transport_header;
  __u16 inner_network_header;
  __u16 inner_mac_header;
  __be16 protocol;
  __u16 transport_header;
  __u16 network_header;
  __u16 mac_header;
  sk_buff_data_t tail;
  sk_buff_data_t end;
  unsigned char * head;
  unsigned char * data;
  unsigned int truesize;
  refcount_t users;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal"><span class="pre">inner_transport_header</span></code></dt>
<dd>Inner transport layer header (encapsulation)</dd>
<dt><code class="docutils literal"><span class="pre">inner_network_header</span></code></dt>
<dd>Network layer header (encapsulation)</dd>
<dt><code class="docutils literal"><span class="pre">inner_mac_header</span></code></dt>
<dd>Link layer header (encapsulation)</dd>
<dt><code class="docutils literal"><span class="pre">protocol</span></code></dt>
<dd>Packet protocol from driver</dd>
<dt><code class="docutils literal"><span class="pre">transport_header</span></code></dt>
<dd>Transport layer header</dd>
<dt><code class="docutils literal"><span class="pre">network_header</span></code></dt>
<dd>Network layer header</dd>
<dt><code class="docutils literal"><span class="pre">mac_header</span></code></dt>
<dd>Link layer header</dd>
<dt><code class="docutils literal"><span class="pre">tail</span></code></dt>
<dd>Tail pointer</dd>
<dt><code class="docutils literal"><span class="pre">end</span></code></dt>
<dd>End pointer</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>Head of buffer</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>Data head pointer</dd>
<dt><code class="docutils literal"><span class="pre">truesize</span></code></dt>
<dd>Buffer size</dd>
<dt><code class="docutils literal"><span class="pre">users</span></code></dt>
<dd>User count - see {datagram,tcp}.c</dd>
</dl>
<dl class="function">
<dt id="c.skb_dst">
struct dst_entry * <code class="descname">skb_dst</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst" title="Permalink to this definition">¶</a></dt>
<dd><p>returns skb dst_entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns skb dst_entry, regardless of reference taken or not.</p>
<dl class="function">
<dt id="c.skb_dst_set">
void <code class="descname">skb_dst_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct dst_entry *<em>&nbsp;dst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_set" title="Permalink to this definition">¶</a></dt>
<dd><p>sets skb dst</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dst_entry</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>dst entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets skb dst, assuming a reference was taken on dst and should
be released by <code class="xref c c-func docutils literal"><span class="pre">skb_dst_drop()</span></code></p>
<dl class="function">
<dt id="c.skb_dst_set_noref">
void <code class="descname">skb_dst_set_noref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct dst_entry *<em>&nbsp;dst</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_set_noref" title="Permalink to this definition">¶</a></dt>
<dd><p>sets skb dst, hopefully, without taking reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dst_entry</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>dst entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets skb dst, assuming a reference was not taken on dst.
If dst entry is cached, we do not take reference and dst_release
will be avoided by refdst_drop. If dst entry is not cached, we take
reference, so that last dst_release can destroy the dst immediately.</p>
<dl class="function">
<dt id="c.skb_dst_is_noref">
bool <code class="descname">skb_dst_is_noref</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dst_is_noref" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if skb dst isn’t refcounted</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer</dd>
</dl>
<dl class="function">
<dt id="c.skb_fclone_busy">
bool <code class="descname">skb_fclone_busy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_fclone_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if fclone is busy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if skb is a fast clone, and its clone is not freed.
Some drivers call <a class="reference internal" href="#c.skb_orphan" title="skb_orphan"><code class="xref c c-func docutils literal"><span class="pre">skb_orphan()</span></code></a> in their <code class="xref c c-func docutils literal"><span class="pre">ndo_start_xmit()</span></code>,
so we also check that this didnt happen.</p>
<dl class="function">
<dt id="c.skb_pad">
int <code class="descname">skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>zero pad the tail of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to pad</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">pad</span></code></dt>
<dd>space to pad</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.</p>
<p>May return error in out of memory cases. The skb is freed on error.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_empty">
int <code class="descname">skb_queue_empty</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a queue is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>queue head</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if the queue is empty, false otherwise.</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_is_last">
bool <code class="descname">skb_queue_is_last</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_is_last" title="Permalink to this definition">¶</a></dt>
<dd><p>check if skb is the last entry in the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>queue head</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if <strong>skb</strong> is the last buffer on the list.</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_is_first">
bool <code class="descname">skb_queue_is_first</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_is_first" title="Permalink to this definition">¶</a></dt>
<dd><p>check if skb is the first entry in the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>queue head</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if <strong>skb</strong> is the first buffer on the list.</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_next">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_queue_next</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_next" title="Permalink to this definition">¶</a></dt>
<dd><p>return the next packet in the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>queue head</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>current buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the next packet in <strong>list</strong> after <strong>skb</strong>.  It is only valid to
call this if <a class="reference internal" href="#c.skb_queue_is_last" title="skb_queue_is_last"><code class="xref c c-func docutils literal"><span class="pre">skb_queue_is_last()</span></code></a> evaluates to false.</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_prev">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_queue_prev</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>return the prev packet in the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>queue head</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>current buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the prev packet in <strong>list</strong> before <strong>skb</strong>.  It is only valid to
call this if <a class="reference internal" href="#c.skb_queue_is_first" title="skb_queue_is_first"><code class="xref c c-func docutils literal"><span class="pre">skb_queue_is_first()</span></code></a> evaluates to false.</div></blockquote>
<dl class="function">
<dt id="c.skb_get">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_get" title="Permalink to this definition">¶</a></dt>
<dd><p>reference buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to reference</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Makes another reference to a socket buffer and returns a pointer
to the buffer.</div></blockquote>
<dl class="function">
<dt id="c.skb_cloned">
int <code class="descname">skb_cloned</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cloned" title="Permalink to this definition">¶</a></dt>
<dd><p>is the buffer a clone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if the buffer was generated with <a class="reference internal" href="#c.skb_clone" title="skb_clone"><code class="xref c c-func docutils literal"><span class="pre">skb_clone()</span></code></a> and is
one of multiple shared copies of the buffer. Cloned buffers are
shared data so must not be written to under normal circumstances.</div></blockquote>
<dl class="function">
<dt id="c.skb_header_cloned">
int <code class="descname">skb_header_cloned</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_header_cloned" title="Permalink to this definition">¶</a></dt>
<dd><p>is the header a clone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if modifying the header part of the buffer requires
the data to be copied.</div></blockquote>
<dl class="function">
<dt id="c.skb_header_release">
void <code class="descname">skb_header_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_header_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release reference to header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Drop a reference to the header part of the buffer.  This is done
by acquiring a payload reference.  You must not read from the header
part of skb-&gt;data after this.</div></blockquote>
<p><strong>Note</strong></p>
<p>Check if you can use <a class="reference internal" href="#c.__skb_header_release" title="__skb_header_release"><code class="xref c c-func docutils literal"><span class="pre">__skb_header_release()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.__skb_header_release">
void <code class="descname">__skb_header_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_header_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release reference to header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to operate on</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Variant of <a class="reference internal" href="#c.skb_header_release" title="skb_header_release"><code class="xref c c-func docutils literal"><span class="pre">skb_header_release()</span></code></a> assuming skb is private to caller.
We can avoid one atomic operation.</div></blockquote>
<dl class="function">
<dt id="c.skb_shared">
int <code class="descname">skb_shared</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_shared" title="Permalink to this definition">¶</a></dt>
<dd><p>is the buffer shared</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if more than one person has a reference to this
buffer.</div></blockquote>
<dl class="function">
<dt id="c.skb_share_check">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_share_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, gfp_t<em>&nbsp;pri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_share_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check if buffer is shared and if so clone it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">pri</span></code></dt>
<dd>priority for memory allocation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If the buffer is shared the buffer is cloned and the old copy
drops a reference. A new clone with a single reference is returned.
If the buffer is not shared the original buffer is returned. When
being called from interrupt status or with spinlocks held pri must
be GFP_ATOMIC.</p>
<p>NULL is returned on a memory allocation failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_unshare">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_unshare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, gfp_t<em>&nbsp;pri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_unshare" title="Permalink to this definition">¶</a></dt>
<dd><p>make a copy of a shared buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">pri</span></code></dt>
<dd>priority for memory allocation</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If the socket buffer is a clone then this function creates a new
copy of the data, drops a reference count on the old copy and returns
the new copy with the reference count at 1. If the buffer is not a clone
the original buffer is returned. When called with a spinlock held or
from interrupt state <strong>pri</strong> must be <code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code></p>
<p><code class="docutils literal"><span class="pre">NULL</span></code> is returned on a memory allocation failure.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_peek">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_peek</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the head of an <code class="xref c c-type docutils literal"><span class="pre">sk_buff_head</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt>
<dd>list to peek at</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Peek an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a>. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.</p>
<p>Returns <code class="docutils literal"><span class="pre">NULL</span></code> for an empty list or a pointer to the head element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_peek_next">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_peek_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, const struct sk_buff_head *<em>&nbsp;list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek_next" title="Permalink to this definition">¶</a></dt>
<dd><p>peek skb following the given one from a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>skb to start from</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt>
<dd>list to peek at</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns <code class="docutils literal"><span class="pre">NULL</span></code> when the end of the list is met or a pointer to the
next element. The reference count is not incremented and the
reference is therefore volatile. Use with caution.</div></blockquote>
<dl class="function">
<dt id="c.skb_peek_tail">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_peek_tail</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_peek_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the tail of an <code class="xref c c-type docutils literal"><span class="pre">sk_buff_head</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt>
<dd>list to peek at</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Peek an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a>. Unlike most other operations you _MUST_
be careful with this one. A peek leaves the buffer on the
list and someone else may run off with it. You must hold
the appropriate locks or have a private queue to do this.</p>
<p>Returns <code class="docutils literal"><span class="pre">NULL</span></code> for an empty list or a pointer to the tail element.
The reference count is not incremented and the reference is therefore
volatile. Use with caution.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_len">
__u32 <code class="descname">skb_queue_len</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list_</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_len" title="Permalink to this definition">¶</a></dt>
<dd><p>get queue length</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list_</span></code></dt>
<dd>list to measure</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the length of an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> queue.</div></blockquote>
<dl class="function">
<dt id="c.__skb_queue_head_init">
void <code class="descname">__skb_queue_head_init</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_head_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize non-spinlock portions of sk_buff_head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>queue to initialize</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This initializes only the list and queue length aspects of
an sk_buff_head object.  This allows to initialize the list
aspects of an sk_buff_head without reinitializing things like
the spinlock.  It can also be used for on-stack sk_buff_head
objects where the spinlock is known to not be used.</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_splice">
void <code class="descname">skb_queue_splice</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list</em>, struct sk_buff_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists, this is designed for stacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list</dd>
</dl>
<dl class="function">
<dt id="c.skb_queue_splice_init">
void <code class="descname">skb_queue_splice_init</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em>, struct sk_buff_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists and reinitialise the emptied list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The list at <strong>list</strong> is reinitialised</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_splice_tail">
void <code class="descname">skb_queue_splice_tail</code><span class="sig-paren">(</span>const struct sk_buff_head *<em>&nbsp;list</em>, struct sk_buff_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists, each list being a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list</dd>
</dl>
<dl class="function">
<dt id="c.skb_queue_splice_tail_init">
void <code class="descname">skb_queue_splice_tail_init</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em>, struct sk_buff_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_splice_tail_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two skb lists and reinitialise the emptied list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</div></blockquote>
<dl class="function">
<dt id="c.__skb_queue_after">
void <code class="descname">__skb_queue_after</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;prev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_queue_after" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt>
<dd>place after this buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt>
<dd>buffer to queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer int the middle of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_head">
void <code class="descname">skb_queue_head</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_head" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt>
<dd>buffer to queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer at the start of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_tail">
void <code class="descname">skb_queue_tail</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;newsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a buffer at the list tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt>
<dd>buffer to queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer at the end of a list. This function takes no locks
and you must therefore hold required locks before calling it.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_dequeue">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_dequeue</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dequeue" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the head of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to dequeue from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove the head of the list. This function does not take any locks
so must be used with appropriate locks held only. The head item is
returned or <code class="docutils literal"><span class="pre">NULL</span></code> if the list is empty.</div></blockquote>
<dl class="function">
<dt id="c.skb_dequeue_tail">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_dequeue_tail</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_dequeue_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>remove from the tail of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to dequeue from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove the tail of the list. This function does not take any locks
so must be used with appropriate locks held only. The tail item is
returned or <code class="docutils literal"><span class="pre">NULL</span></code> if the list is empty.</div></blockquote>
<dl class="function">
<dt id="c.__skb_fill_page_desc">
void <code class="descname">__skb_fill_page_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;i</em>, struct page *<em>&nbsp;page</em>, int<em>&nbsp;off</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_fill_page_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a paged fragment in an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer containing fragment to be initialised</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>paged fragment index to initialise</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page to use for this fragment</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">off</span></code></dt>
<dd>the offset to the data with <strong>page</strong></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>the length of the data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises the <strong>i</strong>’th fragment of <strong>skb</strong> to point to <code class="xref c c-type docutils literal"><span class="pre">size</span></code> bytes at
offset <strong>off</strong> within <strong>page</strong>.</p>
<p>Does not take any additional reference on the fragment.</p>
<dl class="function">
<dt id="c.skb_fill_page_desc">
void <code class="descname">skb_fill_page_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;i</em>, struct page *<em>&nbsp;page</em>, int<em>&nbsp;off</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_fill_page_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a paged fragment in an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer containing fragment to be initialised</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>paged fragment index to initialise</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page to use for this fragment</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">off</span></code></dt>
<dd>the offset to the data with <strong>page</strong></dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>the length of the data</dd>
</dl>
<p><strong>Description</strong></p>
<p>As per <a class="reference internal" href="#c.__skb_fill_page_desc" title="__skb_fill_page_desc"><code class="xref c c-func docutils literal"><span class="pre">__skb_fill_page_desc()</span></code></a> – initialises the <strong>i</strong>’th fragment of
<strong>skb</strong> to point to <strong>size</strong> bytes at offset <strong>off</strong> within <strong>page</strong>. In
addition updates <strong>skb</strong> such that <strong>i</strong> is the last fragment.</p>
<p>Does not take any additional reference on the fragment.</p>
<dl class="function">
<dt id="c.skb_headroom">
unsigned int <code class="descname">skb_headroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_headroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the number of bytes of free space at the head of an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.skb_tailroom">
int <code class="descname">skb_tailroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tailroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer end</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the number of bytes of free space at the tail of an sk_buff</div></blockquote>
<dl class="function">
<dt id="c.skb_availroom">
int <code class="descname">skb_availroom</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_availroom" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes at buffer end</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the number of bytes of free space at the tail of an sk_buff
allocated by <code class="xref c c-func docutils literal"><span class="pre">sk_stream_alloc()</span></code></div></blockquote>
<dl class="function">
<dt id="c.skb_reserve">
void <code class="descname">skb_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust headroom</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to alter</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>bytes to move</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Increase the headroom of an empty <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> by reducing the tail
room. This is only allowed for an empty buffer.</div></blockquote>
<dl class="function">
<dt id="c.skb_tailroom_reserve">
void <code class="descname">skb_tailroom_reserve</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;mtu</em>, unsigned int<em>&nbsp;needed_tailroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tailroom_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust reserved_tailroom</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to alter</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mtu</span></code></dt>
<dd>maximum amount of headlen permitted</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">needed_tailroom</span></code></dt>
<dd>minimum amount of reserved_tailroom</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Set reserved_tailroom so that headlen can be as large as possible but
not larger than mtu and tailroom cannot be smaller than
needed_tailroom.
The required headroom should already have been reserved before using
this function.</div></blockquote>
<dl class="function">
<dt id="c.pskb_trim_unique">
void <code class="descname">pskb_trim_unique</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_trim_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>remove end from a paged unique (not cloned) buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to alter</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>new length</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is identical to pskb_trim except that the caller knows that
the skb is not cloned so we should never get an error due to out-
of-memory.</div></blockquote>
<dl class="function">
<dt id="c.skb_orphan">
void <code class="descname">skb_orphan</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_orphan" title="Permalink to this definition">¶</a></dt>
<dd><p>orphan a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to orphan</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If a buffer currently has an owner then we call the owner’s
destructor function and make the <strong>skb</strong> unowned. The buffer continues
to exist but is no longer charged to its former owner.</div></blockquote>
<dl class="function">
<dt id="c.skb_orphan_frags">
int <code class="descname">skb_orphan_frags</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_orphan_frags" title="Permalink to this definition">¶</a></dt>
<dd><p>orphan the frags contained in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to orphan frags from</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mask for replacement pages</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For each frag in the SKB which needs a destructor (i.e. has an
owner) create a copy of that frag and release the original
page by calling the destructor.</div></blockquote>
<dl class="function">
<dt id="c.skb_queue_purge">
void <code class="descname">skb_queue_purge</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_queue_purge" title="Permalink to this definition">¶</a></dt>
<dd><p>empty a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to empty</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Delete all buffers on an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> list. Each buffer is removed from
the list and one reference dropped. This function does not take the
list lock and the caller must hold the relevant locks to use it.</div></blockquote>
<dl class="function">
<dt id="c.netdev_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">netdev_alloc_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an skbuff for rx on a specific device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device to receive on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">length</span></code></dt>
<dd>length to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> and assign it a usage count of one. The
buffer has unspecified headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.</p>
<p><code class="docutils literal"><span class="pre">NULL</span></code> is returned if there is no free memory. Although this function
allocates memory it can be called from an interrupt.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_alloc_pages">
struct page * <code class="descname">__dev_alloc_pages</code><span class="sig-paren">(</span>gfp_t<em>&nbsp;gfp_mask</em>, unsigned int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_alloc_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate page for network Rx</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority. Set __GFP_NOMEMALLOC if not for network Rx</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>size of the allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new page.</p>
<p><code class="docutils literal"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
<dl class="function">
<dt id="c.__dev_alloc_page">
struct page * <code class="descname">__dev_alloc_page</code><span class="sig-paren">(</span>gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_alloc_page" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a page for network Rx</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority. Set __GFP_NOMEMALLOC if not for network Rx</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a new page.</p>
<p><code class="docutils literal"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
<dl class="function">
<dt id="c.skb_propagate_pfmemalloc">
void <code class="descname">skb_propagate_pfmemalloc</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_propagate_pfmemalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate pfmemalloc if skb is allocated after RX page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page that was allocated from skb_alloc_page</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The skb that may need pfmemalloc set</dd>
</dl>
<dl class="function">
<dt id="c.skb_frag_page">
struct page * <code class="descname">skb_frag_page</code><span class="sig-paren">(</span>const skb_frag_t *<em>&nbsp;frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_page" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the page referred to by a paged fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt>
<dd>the paged fragment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code> associated with <strong>frag</strong>.</p>
<dl class="function">
<dt id="c.__skb_frag_ref">
void <code class="descname">__skb_frag_ref</code><span class="sig-paren">(</span>skb_frag_t *<em>&nbsp;frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>take an addition reference on a paged fragment.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt>
<dd>the paged fragment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes an additional reference on the paged fragment <strong>frag</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_ref">
void <code class="descname">skb_frag_ref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>take an addition reference on a paged fragment of an skb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">f</span></code></dt>
<dd>the fragment offset.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes an additional reference on the <strong>f</strong>’th paged fragment of <strong>skb</strong>.</p>
<dl class="function">
<dt id="c.__skb_frag_unref">
void <code class="descname">__skb_frag_unref</code><span class="sig-paren">(</span>skb_frag_t *<em>&nbsp;frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference on a paged fragment.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt>
<dd>the paged fragment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference on the paged fragment <strong>frag</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_unref">
void <code class="descname">skb_frag_unref</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference on a paged fragment of an skb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">f</span></code></dt>
<dd>the fragment offset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference on the <strong>f</strong>’th paged fragment of <strong>skb</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_address">
void * <code class="descname">skb_frag_address</code><span class="sig-paren">(</span>const skb_frag_t *<em>&nbsp;frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_address" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the address of the data contained in a paged fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt>
<dd>the paged fragment buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the data within <strong>frag</strong>. The page must already
be mapped.</p>
<dl class="function">
<dt id="c.skb_frag_address_safe">
void * <code class="descname">skb_frag_address_safe</code><span class="sig-paren">(</span>const skb_frag_t *<em>&nbsp;frag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_address_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the address of the data contained in a paged fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt>
<dd>the paged fragment buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the address of the data within <strong>frag</strong>. Checks that the page
is mapped and returns <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.__skb_frag_set_page">
void <code class="descname">__skb_frag_set_page</code><span class="sig-paren">(</span>skb_frag_t *<em>&nbsp;frag</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_frag_set_page" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the page contained in a paged fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt>
<dd>the paged fragment</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the fragment <strong>frag</strong> to contain <strong>page</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_set_page">
void <code class="descname">skb_frag_set_page</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;f</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_set_page" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the page contained in a paged fragment of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">f</span></code></dt>
<dd>the fragment offset</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the <strong>f</strong>’th fragment of <strong>skb</strong> to contain <strong>page</strong>.</p>
<dl class="function">
<dt id="c.skb_frag_dma_map">
dma_addr_t <code class="descname">skb_frag_dma_map</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const skb_frag_t *<em>&nbsp;frag</em>, size_t<em>&nbsp;offset</em>, size_t<em>&nbsp;size</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_frag_dma_map" title="Permalink to this definition">¶</a></dt>
<dd><p>maps a paged fragment via the DMA API</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device to map the fragment to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">skb_frag_t</span> <span class="pre">*</span> <span class="pre">frag</span></code></dt>
<dd>the paged fragment to map</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt>
<dd>the offset within the fragment (starting at the
fragment’s own offset)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the number of bytes to map</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>the direction of the mapping (<code class="docutils literal"><span class="pre">PCI_DMA_*</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Maps the page associated with <strong>frag</strong> to <strong>device</strong>.</p>
<dl class="function">
<dt id="c.skb_clone_writable">
int <code class="descname">skb_clone_writable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone_writable" title="Permalink to this definition">¶</a></dt>
<dd><p>is the header of a clone writable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to check</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length up to which to write</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if modifying the header part of the cloned buffer
does not requires the data to be copied.</div></blockquote>
<dl class="function">
<dt id="c.skb_cow">
int <code class="descname">skb_cow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;headroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow" title="Permalink to this definition">¶</a></dt>
<dd><p>copy header of skb when it is required</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to cow</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">headroom</span></code></dt>
<dd>needed headroom</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If the skb passed lacks sufficient headroom or its data part
is shared, data is reallocated. If reallocation fails, an error
is returned and original skb is not changed.</p>
<p>The result is skb with writable area skb-&gt;head…skb-&gt;tail
and at least <strong>headroom</strong> of space at head.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_cow_head">
int <code class="descname">skb_cow_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;headroom</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow_head" title="Permalink to this definition">¶</a></dt>
<dd><p>skb_cow but only making the head writable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to cow</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">headroom</span></code></dt>
<dd>needed headroom</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function is identical to skb_cow except that we replace the
skb_cloned check by skb_header_cloned.  It should be used when
you only need to push on some header and do not need to modify
the data.</div></blockquote>
<dl class="function">
<dt id="c.skb_padto">
int <code class="descname">skb_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>pad an skbuff up to a minimal size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to pad</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>minimal length</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.</div></blockquote>
<dl class="function">
<dt id="c.__skb_put_padto">
int <code class="descname">__skb_put_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em>, bool<em>&nbsp;free_on_error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_put_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>increase size and pad an skbuff up to a minimal size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to pad</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>minimal length</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">free_on_error</span></code></dt>
<dd>free buffer on error</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error if <strong>free_on_error</strong> is true.</div></blockquote>
<dl class="function">
<dt id="c.skb_put_padto">
int <code class="descname">skb_put_padto</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_put_padto" title="Permalink to this definition">¶</a></dt>
<dd><p>increase size and pad an skbuff up to a minimal size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to pad</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>minimal length</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Pads up a buffer to ensure the trailing bytes exist and are
blanked. If the buffer already contains sufficient data it
is untouched. Otherwise it is extended. Returns zero on
success. The skb is freed on error.</div></blockquote>
<dl class="function">
<dt id="c.skb_linearize">
int <code class="descname">skb_linearize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>convert paged skb to linear one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to linarize</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.</div></blockquote>
<dl class="function">
<dt id="c.skb_has_shared_frag">
bool <code class="descname">skb_has_shared_frag</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_has_shared_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>can any frag be overwritten</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the skb has at least one frag that might be modified
by an external entity (as in <code class="xref c c-func docutils literal"><span class="pre">vmsplice()</span></code>/<code class="xref c c-func docutils literal"><span class="pre">sendfile()</span></code>)</p>
<dl class="function">
<dt id="c.skb_linearize_cow">
int <code class="descname">skb_linearize_cow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_linearize_cow" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure skb is linear and writable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to process</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If there is no free memory -ENOMEM is returned, otherwise zero
is returned and the old skb data released.</div></blockquote>
<dl class="function">
<dt id="c.skb_postpull_rcsum">
void <code class="descname">skb_postpull_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, const void *<em>&nbsp;start</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_postpull_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>update checksum for received skb after pull</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to update</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>start of data before pull</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of data pulled</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>After doing a pull on a received packet, you need to call this to
update the CHECKSUM_COMPLETE checksum, or set ip_summed to
CHECKSUM_NONE so that it can be recomputed from scratch.</div></blockquote>
<dl class="function">
<dt id="c.skb_postpush_rcsum">
void <code class="descname">skb_postpush_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, const void *<em>&nbsp;start</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_postpush_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>update checksum for received skb after push</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to update</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>start of data after push</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of data pushed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>After doing a push on a received packet, you need to call this to
update the CHECKSUM_COMPLETE checksum.</div></blockquote>
<dl class="function">
<dt id="c.skb_push_rcsum">
void * <code class="descname">skb_push_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_push_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>push skb and update receive checksum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to update</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of data pulled</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function performs an skb_push on the packet and updates
the CHECKSUM_COMPLETE checksum.  It should be used on
receive path processing instead of skb_push unless you know
that the checksum difference is zero (e.g., a valid IP header)
or you are setting ip_summed to CHECKSUM_NONE.</div></blockquote>
<dl class="function">
<dt id="c.pskb_trim_rcsum">
int <code class="descname">pskb_trim_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_trim_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>trim received skb and update checksum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to trim</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>new length</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is exactly the same as pskb_trim except that it ensures the
checksum of received packets are still valid after the operation.</div></blockquote>
<dl class="function">
<dt id="c.skb_needs_linearize">
bool <code class="descname">skb_needs_linearize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, netdev_features_t<em>&nbsp;features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_needs_linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>check if we need to linearize a given skb depending on the given device features.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>socket buffer to check</dd>
<dt><code class="docutils literal"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt>
<dd>net device features</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if either:
1. skb has frag_list and the device doesn’t support FRAGLIST, or
2. skb is fragmented and the device does not support SG.</div></blockquote>
<dl class="function">
<dt id="c.skb_get_timestamp">
void <code class="descname">skb_get_timestamp</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct timeval *<em>&nbsp;stamp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_get_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>get timestamp from a skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>skb to get stamp from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timeval</span> <span class="pre">*</span> <span class="pre">stamp</span></code></dt>
<dd>pointer to struct timeval to store stamp in</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Timestamps are stored in the skb as offsets to a base timestamp.
This function converts the offset back to a struct timeval and stores
it in stamp.</div></blockquote>
<dl class="function">
<dt id="c.skb_complete_tx_timestamp">
void <code class="descname">skb_complete_tx_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct <a class="reference internal" href="#c.skb_shared_hwtstamps" title="skb_shared_hwtstamps">skb_shared_hwtstamps</a> *<em>&nbsp;hwtstamps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_complete_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>deliver cloned skb with tx timestamps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>clone of the the original outgoing packet</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skb_shared_hwtstamps</span> <span class="pre">*</span> <span class="pre">hwtstamps</span></code></dt>
<dd>hardware time stamps</dd>
</dl>
<p><strong>Description</strong></p>
<p>PHY drivers may accept clones of transmitted packets for
timestamping via their phy_driver.txtstamp method. These drivers
must call this function to return the skb back to the stack with a
timestamp.</p>
<dl class="function">
<dt id="c.skb_tstamp_tx">
void <code class="descname">skb_tstamp_tx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;orig_skb</em>, struct <a class="reference internal" href="#c.skb_shared_hwtstamps" title="skb_shared_hwtstamps">skb_shared_hwtstamps</a> *<em>&nbsp;hwtstamps</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tstamp_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>queue clone of skb with send time stamps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">orig_skb</span></code></dt>
<dd>the original outgoing packet</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skb_shared_hwtstamps</span> <span class="pre">*</span> <span class="pre">hwtstamps</span></code></dt>
<dd>hardware time stamps, may be NULL if not available</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the skb has a socket associated, then this function clones the
skb (thus sharing the actual data and optional structures), stores
the optional hardware time stamping information (if non NULL) or
generates a software time stamp (otherwise), then queues the clone
to the error queue of the socket.  Errors are silently ignored.</p>
<dl class="function">
<dt id="c.skb_tx_timestamp">
void <code class="descname">skb_tx_timestamp</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Driver hook for transmit timestamping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>A socket buffer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ethernet MAC Drivers should call this function in their <code class="xref c c-func docutils literal"><span class="pre">hard_xmit()</span></code>
function immediately before giving the sk_buff to the MAC hardware.</p>
<p>Specifically, one should make absolutely sure that this function is
called before TX completion of this packet can trigger.  Otherwise
the packet could potentially already be freed.</p>
<dl class="function">
<dt id="c.skb_complete_wifi_ack">
void <code class="descname">skb_complete_wifi_ack</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, bool<em>&nbsp;acked</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_complete_wifi_ack" title="Permalink to this definition">¶</a></dt>
<dd><p>deliver skb with wifi status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the original outgoing packet</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">acked</span></code></dt>
<dd>ack status</dd>
</dl>
<dl class="function">
<dt id="c.skb_checksum_complete">
__sum16 <code class="descname">skb_checksum_complete</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate checksum of an entire packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>packet to process</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function calculates the checksum over the entire packet plus
the value of skb-&gt;csum.  The latter can be used to supply the
checksum of a pseudo header as used by TCP/UDP.  It returns the
checksum.</p>
<p>For protocols that contain complete checksums such as ICMP/TCP/UDP,
this function can be used to verify that checksum on received
packets.  In that case the function should return zero if the
checksum is correct.  In particular, this function will return zero
if skb-&gt;ip_summed is CHECKSUM_UNNECESSARY which indicates that the
hardware has already verified the correctness of the checksum.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_checksum_none_assert">
void <code class="descname">skb_checksum_none_assert</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_none_assert" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure skb ip_summed is CHECKSUM_NONE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>skb to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>fresh skbs have their ip_summed set to CHECKSUM_NONE.
Instead of forcing ip_summed to CHECKSUM_NONE, we can
use this helper, to document places where we make this assertion.</p>
<dl class="function">
<dt id="c.skb_head_is_locked">
bool <code class="descname">skb_head_is_locked</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_head_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the skb-&gt;head is locked down</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>skb to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>The head on skbs build around a head frag can be removed if they are
not cloned.  This function returns true if the skb head is locked down
due to either being allocated via kmalloc, or by being a clone with
multiple references to the head.</p>
<dl class="function">
<dt id="c.skb_gso_network_seglen">
unsigned int <code class="descname">skb_gso_network_seglen</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_gso_network_seglen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return length of individual segments of a gso packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>GSO skb</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_gso_network_seglen is used to determine the real size of the
individual segments, including Layer3 (IP, IPv6) and L4 headers (TCP/UDP).</p>
<p>The MAC/L2 header is not accounted for.</p>
<dl class="type">
<dt id="c.sock_common">
struct <code class="descname">sock_common</code><a class="headerlink" href="#c.sock_common" title="Permalink to this definition">¶</a></dt>
<dd><p>minimal network layer representation of sockets</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct sock_common {
  union {unnamed_union};
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is the minimal network layer representation of sockets, the header
for struct sock and struct inet_timewait_sock.</div></blockquote>
<dl class="type">
<dt id="c.sock">
struct <code class="descname">sock</code><a class="headerlink" href="#c.sock" title="Permalink to this definition">¶</a></dt>
<dd><p>network layer representation of sockets</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct sock {
  struct sock_common __sk_common;
#define sk_node                       __sk_common.skc_node
#define sk_nulls_node         __sk_common.skc_nulls_node
#define sk_refcnt             __sk_common.skc_refcnt
#define sk_tx_queue_mapping   __sk_common.skc_tx_queue_mapping
#define sk_dontcopy_begin     __sk_common.skc_dontcopy_begin
#define sk_dontcopy_end               __sk_common.skc_dontcopy_end
#define sk_hash                       __sk_common.skc_hash
#define sk_portpair           __sk_common.skc_portpair
#define sk_num                        __sk_common.skc_num
#define sk_dport              __sk_common.skc_dport
#define sk_addrpair           __sk_common.skc_addrpair
#define sk_daddr              __sk_common.skc_daddr
#define sk_rcv_saddr          __sk_common.skc_rcv_saddr
#define sk_family             __sk_common.skc_family
#define sk_state              __sk_common.skc_state
#define sk_reuse              __sk_common.skc_reuse
#define sk_reuseport          __sk_common.skc_reuseport
#define sk_ipv6only           __sk_common.skc_ipv6only
#define sk_net_refcnt         __sk_common.skc_net_refcnt
#define sk_bound_dev_if               __sk_common.skc_bound_dev_if
#define sk_bind_node          __sk_common.skc_bind_node
#define sk_prot                       __sk_common.skc_prot
#define sk_net                        __sk_common.skc_net
#define sk_v6_daddr           __sk_common.skc_v6_daddr
#define sk_v6_rcv_saddr       __sk_common.skc_v6_rcv_saddr
#define sk_cookie             __sk_common.skc_cookie
#define sk_incoming_cpu               __sk_common.skc_incoming_cpu
#define sk_flags              __sk_common.skc_flags
#define sk_rxhash             __sk_common.skc_rxhash
  socket_lock_t sk_lock;
  atomic_t sk_drops;
  int sk_rcvlowat;
  struct sk_buff_head sk_error_queue;
  struct sk_buff_head sk_receive_queue;
  struct {unnamed_struct};
#ifdef CONFIG_XFRM
  struct xfrm_policy __rcu * sk_policy;
#endif
  struct dst_entry * sk_rx_dst;
  struct dst_entry __rcu * sk_dst_cache;
  atomic_t sk_omem_alloc;
  int sk_sndbuf;
  int sk_wmem_queued;
  refcount_t sk_wmem_alloc;
  unsigned long sk_tsq_flags;
  struct sk_buff * sk_send_head;
  struct sk_buff_head sk_write_queue;
  __s32 sk_peek_off;
  int sk_write_pending;
  __u32 sk_dst_pending_confirm;
  u32 sk_pacing_status;
  long sk_sndtimeo;
  struct timer_list sk_timer;
  __u32 sk_priority;
  __u32 sk_mark;
  u32 sk_pacing_rate;
  u32 sk_max_pacing_rate;
  struct page_frag sk_frag;
  netdev_features_t sk_route_caps;
  netdev_features_t sk_route_nocaps;
  int sk_gso_type;
  unsigned int sk_gso_max_size;
  gfp_t sk_allocation;
  __u32 sk_txhash;
  unsigned int __sk_flags_offset;
#ifdef __BIG_ENDIAN_BITFIELD
#define SK_FL_PROTO_SHIFT  16
#define SK_FL_PROTO_MASK   0x00ff0000
#define SK_FL_TYPE_SHIFT   0
#define SK_FL_TYPE_MASK    0x0000ffff
#else
#define SK_FL_PROTO_SHIFT  8
#define SK_FL_PROTO_MASK   0x0000ff00
#define SK_FL_TYPE_SHIFT   16
#define SK_FL_TYPE_MASK    0xffff0000
#endif
  unsigned int sk_padding:1;
  unsigned int sk_kern_sock:1;
  unsigned int sk_no_check_tx:1;
  unsigned int sk_no_check_rx:1;
  unsigned int sk_userlocks:4;
  unsigned int sk_protocol:8;
  unsigned int sk_type:16;
#define SK_PROTOCOL_MAX U8_MAX
  u16 sk_gso_max_segs;
  unsigned long sk_lingertime;
  struct proto * sk_prot_creator;
  rwlock_t sk_callback_lock;
  int sk_err;
  int sk_err_soft;
  u32 sk_ack_backlog;
  u32 sk_max_ack_backlog;
  kuid_t sk_uid;
  struct pid * sk_peer_pid;
  const struct cred * sk_peer_cred;
  long sk_rcvtimeo;
  ktime_t sk_stamp;
  u16 sk_tsflags;
  u8 sk_shutdown;
  u32 sk_tskey;
  atomic_t sk_zckey;
  struct socket * sk_socket;
  void * sk_user_data;
#ifdef CONFIG_SECURITY
  void * sk_security;
#endif
  struct sock_cgroup_data sk_cgrp_data;
  struct mem_cgroup * sk_memcg;
  void (* sk_state_change) (struct sock *sk);
  void (* sk_data_ready) (struct sock *sk);
  void (* sk_write_space) (struct sock *sk);
  void (* sk_error_report) (struct sock *sk);
  int (* sk_backlog_rcv) (struct sock *sk, struct sk_buff *skb);
  void (* sk_destruct) (struct sock *sk);
  struct sock_reuseport __rcu * sk_reuseport_cb;
  struct rcu_head sk_rcu;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__sk_common</span></code></dt>
<dd>shared layout with inet_timewait_sock</dd>
<dt><code class="docutils literal"><span class="pre">sk_lock</span></code></dt>
<dd>synchronizer</dd>
<dt><code class="docutils literal"><span class="pre">sk_drops</span></code></dt>
<dd>raw/udp drops counter</dd>
<dt><code class="docutils literal"><span class="pre">sk_rcvlowat</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SO_RCVLOWAT</span></code> setting</dd>
<dt><code class="docutils literal"><span class="pre">sk_error_queue</span></code></dt>
<dd>rarely used</dd>
<dt><code class="docutils literal"><span class="pre">sk_receive_queue</span></code></dt>
<dd>incoming packets</dd>
<dt><code class="docutils literal"><span class="pre">{unnamed_struct}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal"><span class="pre">sk_policy</span></code></dt>
<dd>flow policy</dd>
<dt><code class="docutils literal"><span class="pre">sk_rx_dst</span></code></dt>
<dd>receive input route used by early demux</dd>
<dt><code class="docutils literal"><span class="pre">sk_dst_cache</span></code></dt>
<dd>destination cache</dd>
<dt><code class="docutils literal"><span class="pre">sk_omem_alloc</span></code></dt>
<dd>“o” is “option” or “other”</dd>
<dt><code class="docutils literal"><span class="pre">sk_sndbuf</span></code></dt>
<dd>size of send buffer in bytes</dd>
<dt><code class="docutils literal"><span class="pre">sk_wmem_queued</span></code></dt>
<dd>persistent queue size</dd>
<dt><code class="docutils literal"><span class="pre">sk_wmem_alloc</span></code></dt>
<dd>transmit queue bytes committed</dd>
<dt><code class="docutils literal"><span class="pre">sk_tsq_flags</span></code></dt>
<dd>TCP Small Queues flags</dd>
<dt><code class="docutils literal"><span class="pre">sk_send_head</span></code></dt>
<dd>front of stuff to transmit</dd>
<dt><code class="docutils literal"><span class="pre">sk_write_queue</span></code></dt>
<dd>Packet sending queue</dd>
<dt><code class="docutils literal"><span class="pre">sk_peek_off</span></code></dt>
<dd>current peek_offset value</dd>
<dt><code class="docutils literal"><span class="pre">sk_write_pending</span></code></dt>
<dd>a write to stream socket waits to start</dd>
<dt><code class="docutils literal"><span class="pre">sk_dst_pending_confirm</span></code></dt>
<dd>need to confirm neighbour</dd>
<dt><code class="docutils literal"><span class="pre">sk_pacing_status</span></code></dt>
<dd>Pacing status (requested, handled by sch_fq)</dd>
<dt><code class="docutils literal"><span class="pre">sk_sndtimeo</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SO_SNDTIMEO</span></code> setting</dd>
<dt><code class="docutils literal"><span class="pre">sk_timer</span></code></dt>
<dd>sock cleanup timer</dd>
<dt><code class="docutils literal"><span class="pre">sk_priority</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SO_PRIORITY</span></code> setting</dd>
<dt><code class="docutils literal"><span class="pre">sk_mark</span></code></dt>
<dd>generic packet mark</dd>
<dt><code class="docutils literal"><span class="pre">sk_pacing_rate</span></code></dt>
<dd>Pacing rate (if supported by transport/packet scheduler)</dd>
<dt><code class="docutils literal"><span class="pre">sk_max_pacing_rate</span></code></dt>
<dd>Maximum pacing rate (<code class="docutils literal"><span class="pre">SO_MAX_PACING_RATE</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">sk_frag</span></code></dt>
<dd>cached page frag</dd>
<dt><code class="docutils literal"><span class="pre">sk_route_caps</span></code></dt>
<dd>route capabilities (e.g. <code class="docutils literal"><span class="pre">NETIF_F_TSO</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">sk_route_nocaps</span></code></dt>
<dd>forbidden route capabilities (e.g NETIF_F_GSO_MASK)</dd>
<dt><code class="docutils literal"><span class="pre">sk_gso_type</span></code></dt>
<dd>GSO type (e.g. <code class="docutils literal"><span class="pre">SKB_GSO_TCPV4</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">sk_gso_max_size</span></code></dt>
<dd>Maximum GSO segment size to build</dd>
<dt><code class="docutils literal"><span class="pre">sk_allocation</span></code></dt>
<dd>allocation mode</dd>
<dt><code class="docutils literal"><span class="pre">sk_txhash</span></code></dt>
<dd>computed flow hash for use on transmit</dd>
<dt><code class="docutils literal"><span class="pre">__sk_flags_offset</span></code></dt>
<dd>empty field used to determine location of bitfield</dd>
<dt><code class="docutils literal"><span class="pre">sk_padding</span></code></dt>
<dd>unused element for alignment</dd>
<dt><code class="docutils literal"><span class="pre">sk_kern_sock</span></code></dt>
<dd>True if sock is using kernel lock classes</dd>
<dt><code class="docutils literal"><span class="pre">sk_no_check_tx</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SO_NO_CHECK</span></code> setting, set checksum in TX packets</dd>
<dt><code class="docutils literal"><span class="pre">sk_no_check_rx</span></code></dt>
<dd>allow zero checksum in RX packets</dd>
<dt><code class="docutils literal"><span class="pre">sk_userlocks</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SO_SNDBUF</span></code> and <code class="docutils literal"><span class="pre">SO_RCVBUF</span></code> settings</dd>
<dt><code class="docutils literal"><span class="pre">sk_protocol</span></code></dt>
<dd>which protocol this socket belongs in this network family</dd>
<dt><code class="docutils literal"><span class="pre">sk_type</span></code></dt>
<dd>socket type (<code class="docutils literal"><span class="pre">SOCK_STREAM</span></code>, etc)</dd>
<dt><code class="docutils literal"><span class="pre">sk_gso_max_segs</span></code></dt>
<dd>Maximum number of GSO segments</dd>
<dt><code class="docutils literal"><span class="pre">sk_lingertime</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SO_LINGER</span></code> l_linger setting</dd>
<dt><code class="docutils literal"><span class="pre">sk_prot_creator</span></code></dt>
<dd>sk_prot of original sock creator (see ipv6_setsockopt,
IPV6_ADDRFORM for instance)</dd>
<dt><code class="docutils literal"><span class="pre">sk_callback_lock</span></code></dt>
<dd>used with the callbacks in the end of this struct</dd>
<dt><code class="docutils literal"><span class="pre">sk_err</span></code></dt>
<dd>last error</dd>
<dt><code class="docutils literal"><span class="pre">sk_err_soft</span></code></dt>
<dd>errors that don’t cause failure but are the cause of a
persistent failure not just ‘timed out’</dd>
<dt><code class="docutils literal"><span class="pre">sk_ack_backlog</span></code></dt>
<dd>current listen backlog</dd>
<dt><code class="docutils literal"><span class="pre">sk_max_ack_backlog</span></code></dt>
<dd>listen backlog set in <code class="xref c c-func docutils literal"><span class="pre">listen()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">sk_uid</span></code></dt>
<dd>user id of owner</dd>
<dt><code class="docutils literal"><span class="pre">sk_peer_pid</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pid</span></code> for this socket’s peer</dd>
<dt><code class="docutils literal"><span class="pre">sk_peer_cred</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SO_PEERCRED</span></code> setting</dd>
<dt><code class="docutils literal"><span class="pre">sk_rcvtimeo</span></code></dt>
<dd><code class="docutils literal"><span class="pre">SO_RCVTIMEO</span></code> setting</dd>
<dt><code class="docutils literal"><span class="pre">sk_stamp</span></code></dt>
<dd>time stamp of last packet received</dd>
<dt><code class="docutils literal"><span class="pre">sk_tsflags</span></code></dt>
<dd>SO_TIMESTAMPING socket options</dd>
<dt><code class="docutils literal"><span class="pre">sk_shutdown</span></code></dt>
<dd>mask of <code class="docutils literal"><span class="pre">SEND_SHUTDOWN</span></code> and/or <code class="docutils literal"><span class="pre">RCV_SHUTDOWN</span></code></dd>
<dt><code class="docutils literal"><span class="pre">sk_tskey</span></code></dt>
<dd>counter to disambiguate concurrent tstamp requests</dd>
<dt><code class="docutils literal"><span class="pre">sk_zckey</span></code></dt>
<dd>counter to order MSG_ZEROCOPY notifications</dd>
<dt><code class="docutils literal"><span class="pre">sk_socket</span></code></dt>
<dd>Identd and reporting IO signals</dd>
<dt><code class="docutils literal"><span class="pre">sk_user_data</span></code></dt>
<dd>RPC layer private data</dd>
<dt><code class="docutils literal"><span class="pre">sk_security</span></code></dt>
<dd>used by security modules</dd>
<dt><code class="docutils literal"><span class="pre">sk_cgrp_data</span></code></dt>
<dd>cgroup data for this cgroup</dd>
<dt><code class="docutils literal"><span class="pre">sk_memcg</span></code></dt>
<dd>this socket’s memory cgroup association</dd>
<dt><code class="docutils literal"><span class="pre">sk_state_change</span></code></dt>
<dd>callback to indicate change in the state of the sock</dd>
<dt><code class="docutils literal"><span class="pre">sk_data_ready</span></code></dt>
<dd>callback to indicate there is data to be processed</dd>
<dt><code class="docutils literal"><span class="pre">sk_write_space</span></code></dt>
<dd>callback to indicate there is bf sending space available</dd>
<dt><code class="docutils literal"><span class="pre">sk_error_report</span></code></dt>
<dd>callback to indicate errors (e.g. <code class="docutils literal"><span class="pre">MSG_ERRQUEUE</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">sk_backlog_rcv</span></code></dt>
<dd>callback to process the backlog</dd>
<dt><code class="docutils literal"><span class="pre">sk_destruct</span></code></dt>
<dd>called at sock freeing time, i.e. when all refcnt == 0</dd>
<dt><code class="docutils literal"><span class="pre">sk_reuseport_cb</span></code></dt>
<dd>reuseport group container</dd>
<dt><code class="docutils literal"><span class="pre">sk_rcu</span></code></dt>
<dd>used during RCU grace period</dd>
</dl>
<dl class="function">
<dt id="c.sk_for_each_entry_offset_rcu">
<code class="descname">sk_for_each_entry_offset_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_for_each_entry_offset_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list at a given struct offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tpos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">offset</span></code></dt>
<dd>offset of hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.unlock_sock_fast">
void <code class="descname">unlock_sock_fast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, bool<em>&nbsp;slow</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_sock_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>complement of lock_sock_fast</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">slow</span></code></dt>
<dd>slow mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>fast unlock socket for user context.
If slow mode is on, we call regular <code class="xref c c-func docutils literal"><span class="pre">release_sock()</span></code></p>
<dl class="function">
<dt id="c.sk_wmem_alloc_get">
int <code class="descname">sk_wmem_alloc_get</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_wmem_alloc_get" title="Permalink to this definition">¶</a></dt>
<dd><p>returns write allocations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns sk_wmem_alloc minus initial offset of one</p>
<dl class="function">
<dt id="c.sk_rmem_alloc_get">
int <code class="descname">sk_rmem_alloc_get</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_rmem_alloc_get" title="Permalink to this definition">¶</a></dt>
<dd><p>returns read allocations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns sk_rmem_alloc</p>
<dl class="function">
<dt id="c.sk_has_allocations">
bool <code class="descname">sk_has_allocations</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_has_allocations" title="Permalink to this definition">¶</a></dt>
<dd><p>check if allocations are outstanding</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if socket has write or read allocations</p>
<dl class="function">
<dt id="c.skwq_has_sleeper">
bool <code class="descname">skwq_has_sleeper</code><span class="sig-paren">(</span>struct socket_wq *<em>&nbsp;wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skwq_has_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there are any waiting processes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">socket_wq</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>struct socket_wq</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if socket_wq has waiting processes</p>
<p>The purpose of the skwq_has_sleeper and sock_poll_wait is to wrap the memory
barrier call. They were added due to the race found within the tcp code.</p>
<p>Consider following tcp code paths:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>CPU1                CPU2
sys_select          receive packet
...                 ...
__add_wait_queue    update tp-&gt;rcv_nxt
...                 ...
tp-&gt;rcv_nxt check   sock_def_readable
...                 {
schedule               :c:func:`rcu_read_lock()`;
                       wq = rcu_dereference(sk-&gt;sk_wq);
                       if (wq &amp;&amp; waitqueue_active(:c:type:`wq-&gt;wait &lt;wq&gt;`))
                           wake_up_interruptible(:c:type:`wq-&gt;wait &lt;wq&gt;`)
                       ...
                    }
</pre></div>
</div>
<p>The race for tcp fires when the __add_wait_queue changes done by CPU1 stay
in its cache, and so does the tp-&gt;rcv_nxt update on CPU2 side.  The CPU1
could then endup calling schedule and sleep forever if there are no more
data on the socket.</p>
<dl class="function">
<dt id="c.sock_poll_wait">
void <code class="descname">sock_poll_wait</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, wait_queue_head_t *<em>&nbsp;wait_address</em>, poll_table *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_poll_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>place memory barrier behind the poll_wait call.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file</dd>
<dt><code class="docutils literal"><span class="pre">wait_queue_head_t</span> <span class="pre">*</span> <span class="pre">wait_address</span></code></dt>
<dd>socket wait queue</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>poll_table</dd>
</dl>
<p><strong>Description</strong></p>
<p>See the comments in the wq_has_sleeper function.</p>
<dl class="function">
<dt id="c.sk_page_frag">
struct page_frag * <code class="descname">sk_page_frag</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_page_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>return an appropriate page_frag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
</dl>
<p><strong>Description</strong></p>
<p>If socket allocation mode allows current thread to sleep, it means its
safe to use the per task page_frag instead of the per socket one.</p>
<dl class="function">
<dt id="c.sock_tx_timestamp">
void <code class="descname">sock_tx_timestamp</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, __u16<em>&nbsp;tsflags</em>, __u8 *<em>&nbsp;tx_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_tx_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>checks whether the outgoing packet is to be time stamped</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket sending this packet</dd>
<dt><code class="docutils literal"><span class="pre">__u16</span> <span class="pre">tsflags</span></code></dt>
<dd>timestamping flags to use</dd>
<dt><code class="docutils literal"><span class="pre">__u8</span> <span class="pre">*</span> <span class="pre">tx_flags</span></code></dt>
<dd>completed with instructions for time stamping</dd>
</dl>
<p><strong>Note</strong></p>
<p>callers should take care of initial <code class="docutils literal"><span class="pre">*tx_flags</span></code> value (usually 0)</p>
<dl class="function">
<dt id="c.sk_eat_skb">
void <code class="descname">sk_eat_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_eat_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>Release a skb if it is no longer needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket to eat this skb from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>socket buffer to eat</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine must be called with interrupts disabled or with the socket
locked so that the sk_buff queue operation is ok.</p>
<dl class="function">
<dt id="c.sk_state_load">
int <code class="descname">sk_state_load</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_state_load" title="Permalink to this definition">¶</a></dt>
<dd><p>read sk-&gt;sk_state for lockless contexts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Paired with <a class="reference internal" href="#c.sk_state_store" title="sk_state_store"><code class="xref c c-func docutils literal"><span class="pre">sk_state_store()</span></code></a>. Used in places we do not hold socket lock :
<code class="xref c c-func docutils literal"><span class="pre">tcp_diag_get_info()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">tcp_get_info()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">tcp_poll()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">get_tcp4_sock()</span></code> …</p>
<dl class="function">
<dt id="c.sk_state_store">
void <code class="descname">sk_state_store</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, int<em>&nbsp;newstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_state_store" title="Permalink to this definition">¶</a></dt>
<dd><p>update sk-&gt;sk_state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket pointer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">newstate</span></code></dt>
<dd>new state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Paired with <a class="reference internal" href="#c.sk_state_load" title="sk_state_load"><code class="xref c c-func docutils literal"><span class="pre">sk_state_load()</span></code></a>. Should be used in contexts where
state change might impact lockless readers.</p>
<dl class="function">
<dt id="c.sockfd_lookup">
struct <a class="reference internal" href="#c.socket" title="socket">socket</a> * <code class="descname">sockfd_lookup</code><span class="sig-paren">(</span>int<em>&nbsp;fd</em>, int *<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sockfd_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Go from a file number to its socket slot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd</span></code></dt>
<dd>file handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">err</span></code></dt>
<dd>pointer to an error code return</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The file handle passed in is locked and the socket it is bound
to is returned. If an error occurs the err pointer is overwritten
with a negative errno code and NULL is returned. The function checks
for both invalid handles and passing a handle which is not a socket.</p>
<p>On a success the socket object pointer is returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.sock_alloc">
struct <a class="reference internal" href="#c.socket" title="socket">socket</a> * <code class="descname">sock_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.sock_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Allocate a new inode and socket object. The two are bound together
and initialised. The socket is then returned. If we are out of inodes
NULL is returned.</div></blockquote>
<dl class="function">
<dt id="c.sock_release">
void <code class="descname">sock_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em>&nbsp;sock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_release" title="Permalink to this definition">¶</a></dt>
<dd><p>close a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt>
<dd>socket to close</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The socket is released from the protocol stack if it has a release
callback, and the inode is then released if the socket is bound to
an inode not a file.</div></blockquote>
<dl class="function">
<dt id="c.kernel_recvmsg">
int <code class="descname">kernel_recvmsg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em>&nbsp;sock</em>, struct msghdr *<em>&nbsp;msg</em>, struct kvec *<em>&nbsp;vec</em>, size_t<em>&nbsp;num</em>, size_t<em>&nbsp;size</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_recvmsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a message from a socket (kernel space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt>
<dd>The socket to receive the message from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>Received message</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*</span> <span class="pre">vec</span></code></dt>
<dd>Input s/g array for message data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">num</span></code></dt>
<dd>Size of input s/g array</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Number of bytes to read</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Message flags (MSG_DONTWAIT, etc…)</dd>
</dl>
<p><strong>Description</strong></p>
<p>On return the msg structure contains the scatter/gather array passed in the
vec argument. The array is modified so that it consists of the unfilled
portion of the original array.</p>
<p>The returned value is the total number of bytes received, or an error.</p>
<dl class="function">
<dt id="c.sock_register">
int <code class="descname">sock_register</code><span class="sig-paren">(</span>const struct net_proto_family *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_register" title="Permalink to this definition">¶</a></dt>
<dd><p>add a socket protocol handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_proto_family</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>description of protocol</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function is called by a protocol handler that wants to
advertise its address family, and have it linked into the
socket interface. The value ops-&gt;family corresponds to the
socket system call protocol family.</div></blockquote>
<dl class="function">
<dt id="c.sock_unregister">
void <code class="descname">sock_unregister</code><span class="sig-paren">(</span>int<em>&nbsp;family</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sock_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a protocol handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">family</span></code></dt>
<dd>protocol family to remove</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is called by a protocol handler that wants to
remove its address family, and have it unlinked from the
new socket creation.</p>
<p>If protocol handler is a module, then it can use module reference
counts to protect against new references. If protocol handler is not
a module then it needs to provide its own protection in
the ops-&gt;create routine.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">__alloc_skb</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;flags</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a network buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>size to allocate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mask</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>If SKB_ALLOC_FCLONE is set, allocate from fclone cache
instead of head cache and allocate a cloned (child) skb.
If SKB_ALLOC_RX is set, __GFP_MEMALLOC will be used for
allocations in case the data is required for writeback</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node to allocate memory on</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a>. The returned buffer has no headroom and a
tail room of at least size bytes. The object has a reference count
of one. The return is the buffer. On a failure the return is <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<p>Buffers may only be allocated from interrupts using a <strong>gfp_mask</strong> of
<code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_alloc_frag">
void * <code class="descname">netdev_alloc_frag</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;fragsz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_alloc_frag" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a page fragment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">fragsz</span></code></dt>
<dd>fragment size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a frag from a page for receive buffer.
Uses GFP_ATOMIC allocations.</p>
<dl class="function">
<dt id="c.__netdev_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">__netdev_alloc_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netdev_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an skbuff for rx on a specific device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device to receive on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length to allocate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>get_free_pages mask, passed to alloc_skb</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> and assign it a usage count of one. The
buffer has NET_SKB_PAD headroom built in. Users should allocate
the headroom they think they need without accounting for the
built in space. The built in space is used for optimisations.</p>
<p><code class="docutils literal"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__napi_alloc_skb">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">__napi_alloc_skb</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;napi</em>, unsigned int<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_alloc_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate skbuff for rx in a specific NAPI instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt>
<dd>napi instance this buffer was allocated for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length to allocate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>get_free_pages mask, passed to alloc_skb and alloc_pages</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate a new sk_buff for use in NAPI receive.  This buffer will
attempt to allocate the head from a special reserved region used
only for NAPI Rx allocation.  By doing this we can save several
CPU cycles by avoiding having to disable and re-enable IRQs.</p>
<p><code class="docutils literal"><span class="pre">NULL</span></code> is returned if there is no free memory.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__kfree_skb">
void <code class="descname">__kfree_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__kfree_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>private function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Free an sk_buff. Release anything attached to the buffer.
Clean the state. This is an internal helper function. Users should
always call kfree_skb</div></blockquote>
<dl class="function">
<dt id="c.kfree_skb">
void <code class="descname">kfree_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>free an sk_buff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Drop a reference to the buffer and free it if the usage count has
hit zero.</div></blockquote>
<dl class="function">
<dt id="c.skb_tx_error">
void <code class="descname">skb_tx_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_tx_error" title="Permalink to this definition">¶</a></dt>
<dd><p>report an sk_buff xmit error</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer that triggered an error</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Report xmit error if a device callback is tracking this skb.
skb must be freed afterwards.</div></blockquote>
<dl class="function">
<dt id="c.consume_skb">
void <code class="descname">consume_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.consume_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>free an skbuff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Drop a ref to the buffer and free it if the usage count has hit zero
Functions identically to kfree_skb, but kfree_skb assumes that the frame
is being dropped after a failure and notes that</div></blockquote>
<dl class="function">
<dt id="c.skb_morph">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_morph</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;dst</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_morph" title="Permalink to this definition">¶</a></dt>
<dd><p>morph one skb into another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>the skb to receive the contents</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>the skb to supply the contents</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is identical to skb_clone except that the target skb is
supplied by the user.</p>
<p>The target skb is returned upon exit.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_ubufs">
int <code class="descname">skb_copy_ubufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_ubufs" title="Permalink to this definition">¶</a></dt>
<dd><p>copy userspace skb frags buffers to kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the skb to modify</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This must be called on SKBTX_DEV_ZEROCOPY skb.
It will copy all frags into kernel and drop the reference
to userspace pages.</p>
<p>If this function is called from an interrupt <code class="xref c c-func docutils literal"><span class="pre">gfp_mask()</span></code> must be
<code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code>.</p>
<p>Returns 0 on success or a negative error code on failure
to allocate kernel memory to copy to.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_clone">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_clone</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an sk_buff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to clone</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Duplicate an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a>. The new one is not owned by a socket. Both
copies share the same packet data but not structure. The new
buffer has a reference count of 1. If the allocation fails the
function returns <code class="docutils literal"><span class="pre">NULL</span></code> otherwise the new buffer is returned.</p>
<p>If this function is called from an interrupt <code class="xref c c-func docutils literal"><span class="pre">gfp_mask()</span></code> must be
<code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code>.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_copy</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>create private copy of an sk_buff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to copy</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> and its data. This is used when the
caller wishes to modify the data and needs a private copy of the
data to alter. Returns <code class="docutils literal"><span class="pre">NULL</span></code> on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.</p>
<p>As by-product this function converts non-linear <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> to linear
one, so that <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> becomes completely private and caller is allowed
to modify all the data of returned buffer. This means that this
function is not recommended for use in circumstances when only
header is going to be modified. Use <code class="xref c c-func docutils literal"><span class="pre">pskb_copy()</span></code> instead.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__pskb_copy_fclone">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">__pskb_copy_fclone</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;headroom</em>, gfp_t<em>&nbsp;gfp_mask</em>, bool<em>&nbsp;fclone</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pskb_copy_fclone" title="Permalink to this definition">¶</a></dt>
<dd><p>create copy of an sk_buff with private head.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to copy</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">headroom</span></code></dt>
<dd>headroom of new skb</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">fclone</span></code></dt>
<dd>if true allocate the copy of the skb from the fclone
cache instead of the head cache; it is recommended to set this
to true for the cases where the copy will likely be cloned</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> and part of its data, located
in header. Fragmented data remain shared. This is used when
the caller wishes to modify only header of <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> and needs
private copy of the header to alter. Returns <code class="docutils literal"><span class="pre">NULL</span></code> on failure
or the pointer to the buffer on success.
The returned buffer has a reference count of 1.</div></blockquote>
<dl class="function">
<dt id="c.pskb_expand_head">
int <code class="descname">pskb_expand_head</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;nhead</em>, int<em>&nbsp;ntail</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_expand_head" title="Permalink to this definition">¶</a></dt>
<dd><p>reallocate header of <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to reallocate</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nhead</span></code></dt>
<dd>room to add at head</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ntail</span></code></dt>
<dd>room to add at tail</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Expands (or creates identical copy, if <strong>nhead</strong> and <strong>ntail</strong> are zero)
header of <strong>skb</strong>. <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> itself is not changed. <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> MUST have
reference count of 1. Returns zero in the case of success or error,
if expansion failed. In the last case, <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> is not changed.</p>
<p>All the pointers pointing into skb header may change and must be
reloaded after call to this function.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_expand">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_copy_expand</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;newheadroom</em>, int<em>&nbsp;newtailroom</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>copy and expand sk_buff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to copy</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">newheadroom</span></code></dt>
<dd>new free bytes at head</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">newtailroom</span></code></dt>
<dd>new free bytes at tail</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation priority</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Make a copy of both an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> and its data and while doing so
allocate additional space.</p>
<p>This is used when the caller wishes to modify the data and needs a
private copy of the data to alter as well as more space for new fields.
Returns <code class="docutils literal"><span class="pre">NULL</span></code> on failure or the pointer to the buffer
on success. The returned buffer has a reference count of 1.</p>
<p>You must pass <code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code> as the allocation priority if this function
is called from an interrupt.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__skb_pad">
int <code class="descname">__skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;pad</em>, bool<em>&nbsp;free_on_error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>zero pad the tail of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to pad</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">pad</span></code></dt>
<dd>space to pad</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">free_on_error</span></code></dt>
<dd>free buffer on error</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Ensure that a buffer is followed by a padding area that is zero
filled. Used by network drivers which may DMA or transfer data
beyond the buffer end onto the wire.</p>
<p>May return error in out of memory cases. The skb is freed on error
if <strong>free_on_error</strong> is true.</p>
</div></blockquote>
<dl class="function">
<dt id="c.pskb_put">
void * <code class="descname">pskb_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;tail</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pskb_put" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to the tail of a potentially fragmented buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>start of the buffer to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">tail</span></code></dt>
<dd>tail fragment of the buffer to use</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>amount of data to add</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function extends the used data area of the potentially
fragmented buffer. <strong>tail</strong> must be the last fragment of <strong>skb</strong> – or
<strong>skb</strong> itself. If this would exceed the total buffer size the kernel
will panic. A pointer to the first byte of the extra data is
returned.</div></blockquote>
<dl class="function">
<dt id="c.skb_put">
void * <code class="descname">skb_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_put" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to use</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>amount of data to add</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function extends the used data area of the buffer. If this would
exceed the total buffer size the kernel will panic. A pointer to the
first byte of the extra data is returned.</div></blockquote>
<dl class="function">
<dt id="c.skb_push">
void * <code class="descname">skb_push</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_push" title="Permalink to this definition">¶</a></dt>
<dd><p>add data to the start of a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to use</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>amount of data to add</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function extends the used data area of the buffer at the buffer
start. If this would exceed the total buffer headroom the kernel will
panic. A pointer to the first byte of the extra data is returned.</div></blockquote>
<dl class="function">
<dt id="c.skb_pull">
void * <code class="descname">skb_pull</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pull" title="Permalink to this definition">¶</a></dt>
<dd><p>remove data from the start of a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to use</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>amount of data to remove</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function removes data from the start of a buffer, returning
the memory to the headroom. A pointer to the next data in the buffer
is returned. Once the data has been pulled future pushes will overwrite
the old data.</div></blockquote>
<dl class="function">
<dt id="c.skb_trim">
void <code class="descname">skb_trim</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>remove end from a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to alter</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>new length</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Cut the length of a buffer down by removing data from the tail. If
the buffer is already under the length specified it is not modified.
The skb must be linear.</div></blockquote>
<dl class="function">
<dt id="c.__pskb_pull_tail">
void * <code class="descname">__pskb_pull_tail</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;delta</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__pskb_pull_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>advance tail of skb header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to reallocate</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">delta</span></code></dt>
<dd>number of bytes to advance tail</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The function makes a sense only on a fragmented <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a>,
it expands header moving its tail forward and copying necessary
data from fragmented part.</p>
<p><a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> MUST have reference count of 1.</p>
<p>Returns <code class="docutils literal"><span class="pre">NULL</span></code> (and <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> does not change) if pull failed
or value of new tail of skb in the case of success.</p>
<p>All the pointers pointing into skb header may change and must be
reloaded after call to this function.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_bits">
int <code class="descname">skb_copy_bits</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;offset</em>, void *<em>&nbsp;to</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>copy bits from skb to kernel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>source skb</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>offset in source</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Copy the specified number of bytes from the source skb to the
destination buffer.</p>
<dl class="docutils">
<dt>CAUTION ! :</dt>
<dd>If its prototype is ever changed,
check arch/{*}/net/{*}.S files,
since it is called from BPF assembly code.</dd>
</dl>
</div></blockquote>
<dl class="function">
<dt id="c.skb_store_bits">
int <code class="descname">skb_store_bits</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;offset</em>, const void *<em>&nbsp;from</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_store_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>store bits from kernel buffer to skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>offset in destination</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>source buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Copy the specified number of bytes from the source buffer to the
destination skb.  This function handles all the messy bits of
traversing fragment lists and such.</div></blockquote>
<dl class="function">
<dt id="c.skb_zerocopy">
int <code class="descname">skb_zerocopy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;to</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;from</em>, int<em>&nbsp;len</em>, int<em>&nbsp;hlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_zerocopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero copy skb to skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>source buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy from source buffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hlen</span></code></dt>
<dd>size of linear headroom in destination buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Copies up to <cite>len</cite> bytes from <cite>from</cite> to <cite>to</cite> by creating references
to the frags in the source buffer.</p>
<p>The <cite>hlen</cite> as calculated by <code class="xref c c-func docutils literal"><span class="pre">skb_zerocopy_headlen()</span></code> specifies the
headroom in the <cite>to</cite> buffer.</p>
<p>Return value:
0: everything is OK
-ENOMEM: couldn’t orphan frags of <strong>from</strong> due to lack of memory
-EFAULT: <a class="reference internal" href="#c.skb_copy_bits" title="skb_copy_bits"><code class="xref c c-func docutils literal"><span class="pre">skb_copy_bits()</span></code></a> found some problem with skb geometry</p>
</div></blockquote>
<dl class="function">
<dt>
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_dequeue</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span></dt>
<dd><p>remove from the head of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to dequeue from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove the head of the list. The list lock is taken so the function
may be used safely with other locking list functions. The head item is
returned or <code class="docutils literal"><span class="pre">NULL</span></code> if the list is empty.</div></blockquote>
<dl class="function">
<dt>
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_dequeue_tail</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span></dt>
<dd><p>remove from the tail of the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to dequeue from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove the tail of the list. The list lock is taken so the function
may be used safely with other locking list functions. The tail item is
returned or <code class="docutils literal"><span class="pre">NULL</span></code> if the list is empty.</div></blockquote>
<dl class="function">
<dt>
void <code class="descname">skb_queue_purge</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span></dt>
<dd><p>empty a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to empty</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Delete all buffers on an <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> list. Each buffer is removed from
the list and one reference dropped. This function takes the list
lock and is atomic with respect to other list locking functions.</div></blockquote>
<dl class="function">
<dt>
void <code class="descname">skb_queue_head</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;newsk</em><span class="sig-paren">)</span></dt>
<dd><p>queue a buffer at the list head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt>
<dd>buffer to queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer at the start of the list. This function takes the
list lock and can be used safely with other locking <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> functions
safely.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt>
void <code class="descname">skb_queue_tail</code><span class="sig-paren">(</span>struct sk_buff_head *<em>&nbsp;list</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;newsk</em><span class="sig-paren">)</span></dt>
<dd><p>queue a buffer at the list tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt>
<dd>buffer to queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a buffer at the tail of the list. This function takes the
list lock and can be used safely with other locking <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a> functions
safely.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_unlink">
void <code class="descname">skb_unlink</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a buffer from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to remove</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to use</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a packet from a list. The list locks are taken and this
function is atomic with respect to other list locked calls</p>
<p>You must know what list the SKB is on.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_append">
void <code class="descname">skb_append</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;old</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;newsk</em>, struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_append" title="Permalink to this definition">¶</a></dt>
<dd><p>append a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>buffer to insert after</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt>
<dd>buffer to insert</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to use</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Place a packet after a given packet in a list. The list locks are taken
and this function is atomic with respect to other list locked calls.
A buffer cannot be placed on two lists at the same time.</div></blockquote>
<dl class="function">
<dt id="c.skb_insert">
void <code class="descname">skb_insert</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;old</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;newsk</em>, struct sk_buff_head *<em>&nbsp;list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>buffer to insert before</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">newsk</span></code></dt>
<dd>buffer to insert</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>list to use</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Place a packet before a given packet in a list. The list locks are
taken and this function is atomic with respect to other list locked
calls.</p>
<p>A buffer cannot be placed on two lists at the same time.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_split">
void <code class="descname">skb_split</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb1</em>, const u32<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split fragmented skb to two parts at length len.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the buffer to split</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb1</span></code></dt>
<dd>the buffer to receive the second part</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">len</span></code></dt>
<dd>new length for skb</dd>
</dl>
<dl class="function">
<dt id="c.skb_prepare_seq_read">
void <code class="descname">skb_prepare_seq_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;from</em>, unsigned int<em>&nbsp;to</em>, struct skb_seq_state *<em>&nbsp;st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_prepare_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a sequential read of skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the buffer to read</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">from</span></code></dt>
<dd>lower offset of data to be read</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">to</span></code></dt>
<dd>upper offset of data to be read</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*</span> <span class="pre">st</span></code></dt>
<dd>state variable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the specified state variable. Must be called before
invoking <a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal"><span class="pre">skb_seq_read()</span></code></a> for the first time.</p>
<dl class="function">
<dt id="c.skb_seq_read">
unsigned int <code class="descname">skb_seq_read</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;consumed</em>, const u8 **<em>&nbsp;data</em>, struct skb_seq_state *<em>&nbsp;st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Sequentially read skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">consumed</span></code></dt>
<dd>number of bytes consumed by the caller so far</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">**</span> <span class="pre">data</span></code></dt>
<dd>destination pointer for data to be returned</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*</span> <span class="pre">st</span></code></dt>
<dd>state variable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reads a block of skb data at <strong>consumed</strong> relative to the
lower offset specified to <a class="reference internal" href="#c.skb_prepare_seq_read" title="skb_prepare_seq_read"><code class="xref c c-func docutils literal"><span class="pre">skb_prepare_seq_read()</span></code></a>. Assigns
the head of the data block to <strong>data</strong> and returns the length
of the block or 0 if the end of the skb data or the upper
offset has been reached.</p>
<p>The caller is not required to consume all of the data
returned, i.e. <strong>consumed</strong> is typically set to the number
of bytes already consumed and the next call to
<a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal"><span class="pre">skb_seq_read()</span></code></a> will return the remaining part of the block.</p>
<dl class="docutils">
<dt>Note 1: The size of each block of data returned can be arbitrary,</dt>
<dd>this limitation is the cost for zerocopy sequential
reads of potentially non linear data.</dd>
<dt>Note 2: Fragment lists within fragments are not implemented</dt>
<dd>at the moment, state-&gt;root_skb could be replaced with
a stack for this purpose.</dd>
</dl>
<dl class="function">
<dt id="c.skb_abort_seq_read">
void <code class="descname">skb_abort_seq_read</code><span class="sig-paren">(</span>struct skb_seq_state *<em>&nbsp;st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_abort_seq_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Abort a sequential read of skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">skb_seq_state</span> <span class="pre">*</span> <span class="pre">st</span></code></dt>
<dd>state variable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called if <a class="reference internal" href="#c.skb_seq_read" title="skb_seq_read"><code class="xref c c-func docutils literal"><span class="pre">skb_seq_read()</span></code></a> was not called until it
returned 0.</p>
<dl class="function">
<dt id="c.skb_find_text">
unsigned int <code class="descname">skb_find_text</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;from</em>, unsigned int<em>&nbsp;to</em>, struct ts_config *<em>&nbsp;config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_find_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a text pattern in skb data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the buffer to look in</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">from</span></code></dt>
<dd>search offset</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">to</span></code></dt>
<dd>search limit</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">config</span></code></dt>
<dd>textsearch configuration</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finds a pattern in the skb data according to the specified
textsearch configuration. Use <code class="xref c c-func docutils literal"><span class="pre">textsearch_next()</span></code> to retrieve
subsequent occurrences of the pattern. Returns the offset
to the first occurrence or UINT_MAX if no match was found.</p>
<dl class="function">
<dt id="c.skb_append_datato_frags">
int <code class="descname">skb_append_datato_frags</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int (*getfrag) (void<em>&nbsp;*from</em>, char<em>&nbsp;*to</em>, int<em>&nbsp;offset</em>, int<em>&nbsp;len</em>, int<em>&nbsp;odd</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, void *<em>&nbsp;from</em>, int<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_append_datato_frags" title="Permalink to this definition">¶</a></dt>
<dd><p>append the user data to a skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>sock  structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>skb structure to be appended with user data.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*from,</span> <span class="pre">char</span> <span class="pre">*to,</span> <span class="pre">int</span> <span class="pre">offset,</span> <span class="pre">int</span> <span class="pre">len,</span> <span class="pre">int</span> <span class="pre">odd,</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb)</span> <span class="pre">getfrag</span></code></dt>
<dd>call back function to be used for getting the user data</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>pointer to user message iov</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">length</span></code></dt>
<dd>length of the iov message</dd>
</dl>
<p><strong>Description</strong></p>
<p>This procedure append the user data in the fragment part
of the skb if any page alloc fails user this procedure returns  -ENOMEM</p>
<dl class="function">
<dt id="c.skb_pull_rcsum">
void * <code class="descname">skb_pull_rcsum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_pull_rcsum" title="Permalink to this definition">¶</a></dt>
<dd><p>pull skb and update receive checksum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to update</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of data pulled</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function performs an skb_pull on the packet and updates
the CHECKSUM_COMPLETE checksum.  It should be used on
receive path processing instead of skb_pull unless you know
that the checksum difference is zero (e.g., a valid IP header)
or you are setting ip_summed to CHECKSUM_NONE.</div></blockquote>
<dl class="function">
<dt id="c.skb_segment">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;head_skb</em>, netdev_features_t<em>&nbsp;features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform protocol segmentation on skb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">head_skb</span></code></dt>
<dd>buffer to segment</dd>
<dt><code class="docutils literal"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt>
<dd>features for the output path (see dev-&gt;features)</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function performs segmentation on the given skb.  It returns
a pointer to the first in a list of new skbs for the segments.
In case of error it returns ERR_PTR(err).</div></blockquote>
<dl class="function">
<dt id="c.skb_to_sgvec">
int <code class="descname">skb_to_sgvec</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct scatterlist *<em>&nbsp;sg</em>, int<em>&nbsp;offset</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_to_sgvec" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a scatter-gather list from a socket buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>Socket buffer containing the buffers to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>The scatter-gather list to map into</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>The offset into the buffer’s contents to start mapping</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>Length of buffer space to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Fill the specified scatter-gather list with mappings/pointers into a
region of the buffer space attached to a socket buffer. Returns either
the number of scatterlist items used, or -EMSGSIZE if the contents
could not fit.</div></blockquote>
<dl class="function">
<dt id="c.skb_cow_data">
int <code class="descname">skb_cow_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;tailbits</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> **<em>&nbsp;trailer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_cow_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that a socket buffer’s data buffers are writable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The socket buffer to check.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tailbits</span></code></dt>
<dd>Amount of trailing space to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**</span> <span class="pre">trailer</span></code></dt>
<dd>Returned pointer to the skb where the <strong>tailbits</strong> space begins</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Make sure that the data buffers attached to a socket buffer are
writable. If they are not, private copies are made of the data buffers
and the socket buffer is set to use these instead.</p>
<p>If <strong>tailbits</strong> is given, make sure that there is space to write <strong>tailbits</strong>
bytes of data beyond current end of socket buffer.  <strong>trailer</strong> will be
set to point to the skb in which this space begins.</p>
<p>The number of scatterlist elements required to completely map the
COW’d and extended socket buffer will be returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_clone_sk">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_clone_sk</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_clone_sk" title="Permalink to this definition">¶</a></dt>
<dd><p>create clone of skb, and take reference to socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the skb to clone</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a clone of a buffer that holds a reference on
sk_refcnt.  Buffers created via this function are meant to be
returned using sock_queue_err_skb, or free via kfree_skb.</p>
<p>When passing buffers allocated with this function to sock_queue_err_skb
it is necessary to wrap the call with sock_hold/sock_put in order to
prevent the socket from being released prior to being enqueued on
the sk_error_queue.</p>
<dl class="function">
<dt id="c.skb_partial_csum_set">
bool <code class="descname">skb_partial_csum_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, u16<em>&nbsp;start</em>, u16<em>&nbsp;off</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_partial_csum_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set up and verify partial csum values for packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the skb to set</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">start</span></code></dt>
<dd>the number of bytes after skb-&gt;data to start checksumming.</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">off</span></code></dt>
<dd>the offset from start to place the checksum.</dd>
</dl>
<p><strong>Description</strong></p>
<p>For untrusted partially-checksummed packets, we need to make sure the values
for skb-&gt;csum_start and skb-&gt;csum_offset are valid so we don’t oops.</p>
<p>This function checks and sets those values and skb-&gt;ip_summed: if this
returns false you should drop the packet.</p>
<dl class="function">
<dt id="c.skb_checksum_setup">
int <code class="descname">skb_checksum_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, bool<em>&nbsp;recalculate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>set up partial checksum offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the skb to set up</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">recalculate</span></code></dt>
<dd>if true the pseudo-header checksum will be recalculated</dd>
</dl>
<dl class="function">
<dt id="c.skb_checksum_trimmed">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_checksum_trimmed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;transport_len</em>, __sum16(*skb_chkf) (struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_checksum_trimmed" title="Permalink to this definition">¶</a></dt>
<dd><p>validate checksum of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>the skb to check</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">transport_len</span></code></dt>
<dd>the data length beyond the network header</dd>
<dt><code class="docutils literal"><span class="pre">__sum16(*)(struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb)</span> <span class="pre">skb_chkf</span></code></dt>
<dd>checksum function to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Applies the given checksum function skb_chkf to the provided skb.
Returns a checked and maybe trimmed skb. Returns NULL on error.</p>
<p>If the skb has data beyond the given transport length, then a
trimmed &amp; cloned skb is checked and returned.</p>
<p>Caller needs to set the skb transport header and free any returned skb if it
differs from the provided skb.</p>
<dl class="function">
<dt id="c.skb_try_coalesce">
bool <code class="descname">skb_try_coalesce</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;to</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;from</em>, bool *<em>&nbsp;fragstolen</em>, int *<em>&nbsp;delta_truesize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_try_coalesce" title="Permalink to this definition">¶</a></dt>
<dd><p>try to merge skb to prior one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>prior buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>buffer to add</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">fragstolen</span></code></dt>
<dd>pointer to boolean</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">delta_truesize</span></code></dt>
<dd>how much more was allocated than was requested</dd>
</dl>
<dl class="function">
<dt id="c.skb_scrub_packet">
void <code class="descname">skb_scrub_packet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, bool<em>&nbsp;xnet</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_scrub_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>scrub an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to clean</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">xnet</span></code></dt>
<dd>packet is crossing netns</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_scrub_packet can be used after encapsulating or decapsulting a packet
into/from a tunnel. Some information have to be cleared during these
operations.
skb_scrub_packet can also be used to clean a skb before injecting it in
another namespace (<strong>xnet</strong> == true). We have to clear all information in the
skb that could impact namespace isolation.</p>
<dl class="function">
<dt id="c.skb_gso_transport_seglen">
unsigned int <code class="descname">skb_gso_transport_seglen</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_gso_transport_seglen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return length of individual segments of a gso packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>GSO skb</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_gso_transport_seglen is used to determine the real size of the
individual segments, including Layer4 headers (TCP/UDP).</p>
<p>The MAC/L2 or network (IP, IPv6) headers are not accounted for.</p>
<dl class="function">
<dt id="c.skb_gso_validate_mtu">
bool <code class="descname">skb_gso_validate_mtu</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;mtu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_gso_validate_mtu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return in case such skb fits a given MTU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>GSO skb</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mtu</span></code></dt>
<dd>MTU to validate against</dd>
</dl>
<p><strong>Description</strong></p>
<p>skb_gso_validate_mtu validates if a given skb will fit a wanted MTU
once split.</p>
<dl class="function">
<dt id="c.alloc_skb_with_frags">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">alloc_skb_with_frags</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;header_len</em>, unsigned long<em>&nbsp;data_len</em>, int<em>&nbsp;max_page_order</em>, int *<em>&nbsp;errcode</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_skb_with_frags" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate skb with page frags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">header_len</span></code></dt>
<dd>size of linear part</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">data_len</span></code></dt>
<dd>needed length in frags</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_page_order</span></code></dt>
<dd>max page order desired.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">errcode</span></code></dt>
<dd>pointer to error code if any</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to allocate a paged skb, given a maximal order for frags.</p>
<dl class="function">
<dt id="c.sk_ns_capable">
bool <code class="descname">sk_ns_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, struct user_namespace *<em>&nbsp;user_ns</em>, int<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_ns_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>General socket capability test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>Socket to use a capability on or through</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">user_namespace</span> <span class="pre">*</span> <span class="pre">user_ns</span></code></dt>
<dd>The user namespace of the capability to use</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cap</span></code></dt>
<dd>The capability to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was
created and the current process has the capability <strong>cap</strong> in the user
namespace <strong>user_ns</strong>.</p>
<dl class="function">
<dt id="c.sk_capable">
bool <code class="descname">sk_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, int<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>Socket global capability test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>Socket to use a capability on or through</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cap</span></code></dt>
<dd>The global capability to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was
created and the current process has the capability <strong>cap</strong> in all user
namespaces.</p>
<dl class="function">
<dt id="c.sk_net_capable">
bool <code class="descname">sk_net_capable</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, int<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_net_capable" title="Permalink to this definition">¶</a></dt>
<dd><p>Network namespace socket capability test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>Socket to use a capability on or through</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cap</span></code></dt>
<dd>The capability to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test to see if the opener of the socket had when the socket was created
and the current process has the capability <strong>cap</strong> over the network namespace
the socket is a member of.</p>
<dl class="function">
<dt id="c.sk_set_memalloc">
void <code class="descname">sk_set_memalloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_set_memalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>sets <code class="docutils literal"><span class="pre">SOCK_MEMALLOC</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket to set it on</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set <code class="docutils literal"><span class="pre">SOCK_MEMALLOC</span></code> on a socket for access to emergency reserves.
It’s the responsibility of the admin to adjust min_free_kbytes
to meet the requirements</p>
<dl class="function">
<dt id="c.sk_alloc">
struct <a class="reference internal" href="#c.sock" title="sock">sock</a> * <code class="descname">sk_alloc</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, int<em>&nbsp;family</em>, gfp_t<em>&nbsp;priority</em>, struct proto *<em>&nbsp;prot</em>, int<em>&nbsp;kern</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>All socket objects are allocated here</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">family</span></code></dt>
<dd>protocol family</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt>
<dd>for allocation (<code class="docutils literal"><span class="pre">GFP_KERNEL</span></code>, <code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code>, etc)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">proto</span> <span class="pre">*</span> <span class="pre">prot</span></code></dt>
<dd>struct proto associated with this new sock instance</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">kern</span></code></dt>
<dd>is this to be a kernel socket?</dd>
</dl>
<dl class="function">
<dt id="c.sk_clone_lock">
struct <a class="reference internal" href="#c.sock" title="sock">sock</a> * <code class="descname">sk_clone_lock</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, const gfp_t<em>&nbsp;priority</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_clone_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>clone a socket, and lock its clone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>the socket to clone</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">gfp_t</span> <span class="pre">priority</span></code></dt>
<dd>for allocation (<code class="docutils literal"><span class="pre">GFP_KERNEL</span></code>, <code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code>, etc)</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Caller must unlock socket even in error path (bh_unlock_sock(newsk))</div></blockquote>
<dl class="function">
<dt id="c.skb_page_frag_refill">
bool <code class="descname">skb_page_frag_refill</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;sz</em>, struct page_frag *<em>&nbsp;pfrag</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_page_frag_refill" title="Permalink to this definition">¶</a></dt>
<dd><p>check that a page_frag contains enough room</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz</span></code></dt>
<dd>minimum size of the fragment we want to get</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page_frag</span> <span class="pre">*</span> <span class="pre">pfrag</span></code></dt>
<dd>pointer to page_frag</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>priority for memory allocation</dd>
</dl>
<p><strong>Note</strong></p>
<p>While this allocator tries to use high order pages, there is
no guarantee that allocations succeed. Therefore, <strong>sz</strong> MUST be
less or equal than PAGE_SIZE.</p>
<dl class="function">
<dt id="c.sk_wait_data">
int <code class="descname">sk_wait_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, long *<em>&nbsp;timeo</em>, const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_wait_data" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for data to arrive at sk_receive_queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>sock to wait on</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">timeo</span></code></dt>
<dd>for how long</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>last skb seen on sk_receive_queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Now socket state including sk-&gt;sk_err is changed only under lock,
hence we may omit checks after joining wait queue.
We check receive queue before <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code> only as optimization;
it is very likely that <code class="xref c c-func docutils literal"><span class="pre">release_sock()</span></code> added new data.</p>
<dl class="function">
<dt id="c.__sk_mem_raise_allocated">
int <code class="descname">__sk_mem_raise_allocated</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, int<em>&nbsp;size</em>, int<em>&nbsp;amt</em>, int<em>&nbsp;kind</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_raise_allocated" title="Permalink to this definition">¶</a></dt>
<dd><p>increase memory_allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>memory size to allocate</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">amt</span></code></dt>
<dd>pages to allocate</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">kind</span></code></dt>
<dd>allocation type</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Similar to <a class="reference internal" href="#c.__sk_mem_schedule" title="__sk_mem_schedule"><code class="xref c c-func docutils literal"><span class="pre">__sk_mem_schedule()</span></code></a>, but does not update sk_forward_alloc</div></blockquote>
<dl class="function">
<dt id="c.__sk_mem_schedule">
int <code class="descname">__sk_mem_schedule</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, int<em>&nbsp;size</em>, int<em>&nbsp;kind</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>increase sk_forward_alloc and memory_allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>memory size to allocate</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">kind</span></code></dt>
<dd>allocation type</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If kind is SK_MEM_SEND, it means wmem allocation. Otherwise it means
rmem allocation. This function assumes that protocols which have
memory_pressure use sk_wmem_queued as write buffer accounting.</div></blockquote>
<dl class="function">
<dt id="c.__sk_mem_reduce_allocated">
void <code class="descname">__sk_mem_reduce_allocated</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, int<em>&nbsp;amount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_reduce_allocated" title="Permalink to this definition">¶</a></dt>
<dd><p>reclaim memory_allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">amount</span></code></dt>
<dd>number of quanta</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Similar to <a class="reference internal" href="#c.__sk_mem_reclaim" title="__sk_mem_reclaim"><code class="xref c c-func docutils literal"><span class="pre">__sk_mem_reclaim()</span></code></a>, but does not update sk_forward_alloc</div></blockquote>
<dl class="function">
<dt id="c.__sk_mem_reclaim">
void <code class="descname">__sk_mem_reclaim</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, int<em>&nbsp;amount</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sk_mem_reclaim" title="Permalink to this definition">¶</a></dt>
<dd><p>reclaim sk_forward_alloc and memory_allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">amount</span></code></dt>
<dd>number of bytes (rounded down to a SK_MEM_QUANTUM multiple)</dd>
</dl>
<dl class="function">
<dt id="c.lock_sock_fast">
bool <code class="descname">lock_sock_fast</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lock_sock_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>fast version of lock_sock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
</dl>
<p><strong>Description</strong></p>
<p>This version should be used for very small section, where process wont block
return false if fast path is taken:</p>
<blockquote>
<div>sk_lock.slock locked, owned = 0, BH disabled</div></blockquote>
<p>return true if slow path is taken:</p>
<blockquote>
<div>sk_lock.slock unlocked, owned = 1, BH enabled</div></blockquote>
<dl class="function">
<dt id="c.__skb_try_recv_datagram">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">__skb_try_recv_datagram</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, unsigned int<em>&nbsp;flags</em>, void (*destructor) (struct <a class="reference internal" href="#c.sock" title="sock">sock</a><em>&nbsp;*sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a><em>&nbsp;*skb</em>, int *<em>&nbsp;peeked</em>, int *<em>&nbsp;off</em>, int *<em>&nbsp;err</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> **<em>&nbsp;last</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_try_recv_datagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive a datagram skbuff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>MSG_ flags</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">sock</span> <span class="pre">*sk,</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*skb)</span> <span class="pre">destructor</span></code></dt>
<dd>invoked under the receive lock on successful dequeue</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">peeked</span></code></dt>
<dd>returns non-zero if this packet has been seen before</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">off</span></code></dt>
<dd>an offset in bytes to peek skb from. Returns an offset
within an skb where data actually starts</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">err</span></code></dt>
<dd>error code returned</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">**</span> <span class="pre">last</span></code></dt>
<dd>set to last peeked message to inform the wait function
what to look for when peeking</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Get a datagram skbuff, understands the peeking, nonblocking wakeups
and possible races. This replaces identical code in packet, raw and
udp, as well as the IPX AX.25 and Appletalk. It also finally fixes
the long standing peek and read race for datagram sockets. If you
alter this routine remember it must be re-entrant.</p>
<p>This function will lock the socket if a skb is returned, so
the caller needs to unlock the socket in that case (usually by
calling skb_free_datagram). Returns NULL with <strong>err</strong> set to
-EAGAIN if no data was available or to some other value if an
error was detected.</p>
<ul class="simple">
<li>It does not lock socket since today. This function is</li>
<li>free of race conditions. This measure should/can improve</li>
<li>significantly datagram socket latencies at high loads,</li>
<li>when data copying to user space takes lots of time.</li>
<li>(BTW I’ve just killed the last <code class="xref c c-func docutils literal"><span class="pre">cli()</span></code> in IP/IPv6/core/netlink/packet</li>
<li><ol class="first arabic" start="8">
<li>Great win.)</li>
</ol>
</li>
<li>–ANK (980729)</li>
</ul>
<p>The order of the tests when we find no data waiting are specified
quite explicitly by POSIX 1003.1g, don’t change them without having
the standard around please.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_kill_datagram">
int <code class="descname">skb_kill_datagram</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_kill_datagram" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a datagram skbuff forcibly</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>datagram skbuff</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>MSG_ flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function frees a datagram skbuff that was received by
skb_recv_datagram.  The flags argument must match the one
used for skb_recv_datagram.</p>
<p>If the MSG_PEEK flag is set, and the packet is still on the
receive queue of the socket, it will be taken off the queue
before it is freed.</p>
<p>This function currently only disables BH when acquiring the
sk_receive_queue lock.  Therefore it must not be used in a
context where that lock is acquired in an IRQ context.</p>
<p>It returns 0 if the packet was removed by us.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_datagram_iter">
int <code class="descname">skb_copy_datagram_iter</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;offset</em>, struct iov_iter *<em>&nbsp;to</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_datagram_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a datagram to an iovec iterator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to copy</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>offset in the buffer to start copying from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>iovec iterator to copy to</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>amount of data to copy from buffer to iovec</dd>
</dl>
<dl class="function">
<dt id="c.skb_copy_datagram_from_iter">
int <code class="descname">skb_copy_datagram_from_iter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;offset</em>, struct iov_iter *<em>&nbsp;from</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_datagram_from_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a datagram from an iov_iter.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to copy</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>offset in the buffer to start copying to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>the copy source</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>amount of data to copy to buffer from iovec</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns 0 or -EFAULT.</div></blockquote>
<dl class="function">
<dt id="c.zerocopy_sg_from_iter">
int <code class="descname">zerocopy_sg_from_iter</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct iov_iter *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.zerocopy_sg_from_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a zerocopy datagram from an iov_iter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to copy</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>the source to copy from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The function will first copy up to headlen, and then pin the userspace
pages and build frags through them.</p>
<p>Returns 0, -EFAULT or -EMSGSIZE.</p>
</div></blockquote>
<dl class="function">
<dt id="c.skb_copy_and_csum_datagram_msg">
int <code class="descname">skb_copy_and_csum_datagram_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;hlen</em>, struct msghdr *<em>&nbsp;msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_copy_and_csum_datagram_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy and checksum skb to user iovec.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>skbuff</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hlen</span></code></dt>
<dd>hardware length</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>destination</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Caller _must_ check that skb will fit to this iovec.</div></blockquote>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>0       - success.</dt>
<dd>-EINVAL - checksum failure.
-EFAULT - fault during copy.</dd>
</dl>
<dl class="function">
<dt id="c.datagram_poll">
unsigned int <code class="descname">datagram_poll</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, struct <a class="reference internal" href="#c.socket" title="socket">socket</a> *<em>&nbsp;sock</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.datagram_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>generic datagram poll</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">*</span> <span class="pre">sock</span></code></dt>
<dd>socket</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>poll table</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Datagram poll: Again totally generic. This also handles
sequenced packet sockets providing the socket receive queue
is only ever holding data ready to receive.</div></blockquote>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>when you <em>don’t</em> use this routine for this protocol,</dt>
<dd>and you use a different write policy from <code class="xref c c-func docutils literal"><span class="pre">sock_writeable()</span></code>
then please supply your own write_space callback.</dd>
</dl>
<dl class="function">
<dt id="c.sk_stream_wait_connect">
int <code class="descname">sk_stream_wait_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, long *<em>&nbsp;timeo_p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_stream_wait_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for a socket to get into the connected state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>sock to wait on</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">timeo_p</span></code></dt>
<dd>for how long to wait</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called with the socket locked.</p>
<dl class="function">
<dt id="c.sk_stream_wait_memory">
int <code class="descname">sk_stream_wait_memory</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, long *<em>&nbsp;timeo_p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_stream_wait_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for more memory for a socket</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>socket to wait for memory</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">timeo_p</span></code></dt>
<dd>for how long</dd>
</dl>
</div>
<div class="section" id="socket-filter">
<h3>Socket Filter<a class="headerlink" href="#socket-filter" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.sk_filter_trim_cap">
int <code class="descname">sk_filter_trim_cap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned int<em>&nbsp;cap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_filter_trim_cap" title="Permalink to this definition">¶</a></dt>
<dd><p>run a packet through a socket filter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>sock associated with <a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">sk_buff</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to filter</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cap</span></code></dt>
<dd>limit on how short the eBPF program may trim the packet</dd>
</dl>
<p><strong>Description</strong></p>
<p>Run the eBPF program and then cut skb-&gt;data to correct size returned by
the program. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
than pkt_len we keep whole skb-&gt;data. This is the socket level
wrapper to BPF_PROG_RUN. It returns 0 if the packet should
be accepted or -EPERM if the packet should be tossed.</p>
<dl class="function">
<dt id="c.bpf_prog_create">
int <code class="descname">bpf_prog_create</code><span class="sig-paren">(</span>struct bpf_prog **<em>&nbsp;pfp</em>, struct sock_fprog_kern *<em>&nbsp;fprog</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bpf_prog_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an unattached filter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bpf_prog</span> <span class="pre">**</span> <span class="pre">pfp</span></code></dt>
<dd>the unattached filter that is created</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_fprog_kern</span> <span class="pre">*</span> <span class="pre">fprog</span></code></dt>
<dd>the filter program</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a filter independent of any socket. We first run some
sanity checks on it to make sure it does not explode on us later.
If an error occurs or there is insufficient memory for the filter
a negative errno code is returned. On success the return is zero.</p>
<dl class="function">
<dt id="c.bpf_prog_create_from_user">
int <code class="descname">bpf_prog_create_from_user</code><span class="sig-paren">(</span>struct bpf_prog **<em>&nbsp;pfp</em>, struct sock_fprog *<em>&nbsp;fprog</em>, bpf_aux_classic_check_t<em>&nbsp;trans</em>, bool<em>&nbsp;save_orig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bpf_prog_create_from_user" title="Permalink to this definition">¶</a></dt>
<dd><p>create an unattached filter from user buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bpf_prog</span> <span class="pre">**</span> <span class="pre">pfp</span></code></dt>
<dd>the unattached filter that is created</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_fprog</span> <span class="pre">*</span> <span class="pre">fprog</span></code></dt>
<dd>the filter program</dd>
<dt><code class="docutils literal"><span class="pre">bpf_aux_classic_check_t</span> <span class="pre">trans</span></code></dt>
<dd>post-classic verifier transformation handler</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">save_orig</span></code></dt>
<dd>save classic BPF program</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function effectively does the same as <a class="reference internal" href="#c.bpf_prog_create" title="bpf_prog_create"><code class="xref c c-func docutils literal"><span class="pre">bpf_prog_create()</span></code></a>, only
that it builds up its insns buffer from user space provided buffer.
It also allows for passing a bpf_aux_classic_check_t handler.</p>
<dl class="function">
<dt id="c.sk_attach_filter">
int <code class="descname">sk_attach_filter</code><span class="sig-paren">(</span>struct sock_fprog *<em>&nbsp;fprog</em>, struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sk_attach_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a socket filter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock_fprog</span> <span class="pre">*</span> <span class="pre">fprog</span></code></dt>
<dd>the filter program</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>the socket to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attach the user’s filter code. We first run some sanity checks on
it to make sure it does not explode on us later. If an error
occurs or there is insufficient memory for the filter a negative
errno code is returned. On success the return is zero.</p>
</div>
<div class="section" id="generic-network-statistics">
<h3>Generic Network Statistics<a class="headerlink" href="#generic-network-statistics" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.gnet_stats_basic">
struct <code class="descname">gnet_stats_basic</code><a class="headerlink" href="#c.gnet_stats_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>byte/packet throughput statistics</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct gnet_stats_basic {
  __u64 bytes;
  __u32 packets;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bytes</span></code></dt>
<dd>number of seen bytes</dd>
<dt><code class="docutils literal"><span class="pre">packets</span></code></dt>
<dd>number of seen packets</dd>
</dl>
<dl class="type">
<dt id="c.gnet_stats_rate_est">
struct <code class="descname">gnet_stats_rate_est</code><a class="headerlink" href="#c.gnet_stats_rate_est" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct gnet_stats_rate_est {
  __u32 bps;
  __u32 pps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bps</span></code></dt>
<dd>current byte rate</dd>
<dt><code class="docutils literal"><span class="pre">pps</span></code></dt>
<dd>current packet rate</dd>
</dl>
<dl class="type">
<dt id="c.gnet_stats_rate_est64">
struct <code class="descname">gnet_stats_rate_est64</code><a class="headerlink" href="#c.gnet_stats_rate_est64" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct gnet_stats_rate_est64 {
  __u64 bps;
  __u64 pps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bps</span></code></dt>
<dd>current byte rate</dd>
<dt><code class="docutils literal"><span class="pre">pps</span></code></dt>
<dd>current packet rate</dd>
</dl>
<dl class="type">
<dt id="c.gnet_stats_queue">
struct <code class="descname">gnet_stats_queue</code><a class="headerlink" href="#c.gnet_stats_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>queuing statistics</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct gnet_stats_queue {
  __u32 qlen;
  __u32 backlog;
  __u32 drops;
  __u32 requeues;
  __u32 overlimits;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">qlen</span></code></dt>
<dd>queue length</dd>
<dt><code class="docutils literal"><span class="pre">backlog</span></code></dt>
<dd>backlog size of queue</dd>
<dt><code class="docutils literal"><span class="pre">drops</span></code></dt>
<dd>number of dropped packets</dd>
<dt><code class="docutils literal"><span class="pre">requeues</span></code></dt>
<dd>number of requeues</dd>
<dt><code class="docutils literal"><span class="pre">overlimits</span></code></dt>
<dd>number of enqueues over the limit</dd>
</dl>
<dl class="type">
<dt id="c.gnet_estimator">
struct <code class="descname">gnet_estimator</code><a class="headerlink" href="#c.gnet_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>rate estimator configuration</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct gnet_estimator {
  signed char interval;
  unsigned char ewma_log;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">interval</span></code></dt>
<dd>sampling period</dd>
<dt><code class="docutils literal"><span class="pre">ewma_log</span></code></dt>
<dd>the log of measurement window weight</dd>
</dl>
<dl class="function">
<dt id="c.gnet_stats_start_copy_compat">
int <code class="descname">gnet_stats_start_copy_compat</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;type</em>, int<em>&nbsp;tc_stats_type</em>, int<em>&nbsp;xstats_type</em>, spinlock_t *<em>&nbsp;lock</em>, struct gnet_dump *<em>&nbsp;d</em>, int<em>&nbsp;padattr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_start_copy_compat" title="Permalink to this definition">¶</a></dt>
<dd><p>start dumping procedure in compatibility mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>socket buffer to put statistics TLVs into</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>TLV type for top level statistic TLV</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tc_stats_type</span></code></dt>
<dd>TLV type for backward compatibility struct tc_stats TLV</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">xstats_type</span></code></dt>
<dd>TLV type for backward compatibility xstats TLV</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>statistics lock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>dumping handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">padattr</span></code></dt>
<dd>padding attribute</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.</p>
<p>The dumping handle is marked to be in backward compatibility mode telling
all <code class="xref c c-func docutils literal"><span class="pre">gnet_stats_copy_XXX()</span></code> functions to fill a local copy of struct tc_stats.</p>
<p>Returns 0 on success or -1 if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_start_copy">
int <code class="descname">gnet_stats_start_copy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, int<em>&nbsp;type</em>, spinlock_t *<em>&nbsp;lock</em>, struct gnet_dump *<em>&nbsp;d</em>, int<em>&nbsp;padattr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_start_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>start dumping procedure in compatibility mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>socket buffer to put statistics TLVs into</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>TLV type for top level statistic TLV</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>statistics lock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>dumping handle</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">padattr</span></code></dt>
<dd>padding attribute</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes the dumping handle, grabs the statistic lock and appends
an empty TLV header to the socket buffer for use a container for all
other statistic TLVS.</p>
<p>Returns 0 on success or -1 if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_basic">
int <code class="descname">gnet_stats_copy_basic</code><span class="sig-paren">(</span>const seqcount_t *<em>&nbsp;running</em>, struct gnet_dump *<em>&nbsp;d</em>, struct gnet_stats_basic_cpu __percpu *<em>&nbsp;cpu</em>, struct gnet_stats_basic_packed *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_basic" title="Permalink to this definition">¶</a></dt>
<dd><p>copy basic statistics into statistic TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">seqcount_t</span> <span class="pre">*</span> <span class="pre">running</span></code></dt>
<dd>seqcount_t pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>dumping handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_cpu</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu</span></code></dt>
<dd>copy statistic per cpu</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_packed</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>basic statistics</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the basic statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal"><span class="pre">gnet_stats_start_copy()</span></code></a>.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_rate_est">
int <code class="descname">gnet_stats_copy_rate_est</code><span class="sig-paren">(</span>struct gnet_dump *<em>&nbsp;d</em>, struct net_rate_estimator __rcu **<em>&nbsp;rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_rate_est" title="Permalink to this definition">¶</a></dt>
<dd><p>copy rate estimator statistics into statistics TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>dumping handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt>
<dd>rate estimator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the rate estimator statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal"><span class="pre">gnet_stats_start_copy()</span></code></a>.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_queue">
int <code class="descname">gnet_stats_copy_queue</code><span class="sig-paren">(</span>struct gnet_dump *<em>&nbsp;d</em>, struct <a class="reference internal" href="#c.gnet_stats_queue" title="gnet_stats_queue">gnet_stats_queue</a> __percpu *<em>&nbsp;cpu_q</em>, struct <a class="reference internal" href="#c.gnet_stats_queue" title="gnet_stats_queue">gnet_stats_queue</a> *<em>&nbsp;q</em>, __u32<em>&nbsp;qlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>copy queue statistics into statistics TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>dumping handle</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_stats_queue</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu_q</span></code></dt>
<dd>per cpu queue statistics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_stats_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue statistics</dd>
<dt><code class="docutils literal"><span class="pre">__u32</span> <span class="pre">qlen</span></code></dt>
<dd>queue length statistics</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the queue statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal"><span class="pre">gnet_stats_start_copy()</span></code></a>. Using per cpu queue statistics if
they are available.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_copy_app">
int <code class="descname">gnet_stats_copy_app</code><span class="sig-paren">(</span>struct gnet_dump *<em>&nbsp;d</em>, void *<em>&nbsp;st</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_copy_app" title="Permalink to this definition">¶</a></dt>
<dd><p>copy application specific statistics into statistics TLV</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>dumping handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">st</span></code></dt>
<dd>application specific statistics data</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Appends the application specific statistics to the top level TLV created by
<a class="reference internal" href="#c.gnet_stats_start_copy" title="gnet_stats_start_copy"><code class="xref c c-func docutils literal"><span class="pre">gnet_stats_start_copy()</span></code></a> and remembers the data for XSTATS if the dumping
handle is in backward compatibility mode.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gnet_stats_finish_copy">
int <code class="descname">gnet_stats_finish_copy</code><span class="sig-paren">(</span>struct gnet_dump *<em>&nbsp;d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gnet_stats_finish_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>finish dumping procedure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_dump</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>dumping handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Corrects the length of the top level TLV to include all TLVs added
by <code class="xref c c-func docutils literal"><span class="pre">gnet_stats_copy_XXX()</span></code> calls. Adds the backward compatibility TLVs
if <a class="reference internal" href="#c.gnet_stats_start_copy_compat" title="gnet_stats_start_copy_compat"><code class="xref c c-func docutils literal"><span class="pre">gnet_stats_start_copy_compat()</span></code></a> was used and releases the statistics
lock.</p>
<p>Returns 0 on success or -1 with the statistic lock released
if the room in the socket buffer was not sufficient.</p>
<dl class="function">
<dt id="c.gen_new_estimator">
int <code class="descname">gen_new_estimator</code><span class="sig-paren">(</span>struct gnet_stats_basic_packed *<em>&nbsp;bstats</em>, struct gnet_stats_basic_cpu __percpu *<em>&nbsp;cpu_bstats</em>, struct net_rate_estimator __rcu **<em>&nbsp;rate_est</em>, spinlock_t *<em>&nbsp;stats_lock</em>, seqcount_t *<em>&nbsp;running</em>, struct nlattr *<em>&nbsp;opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_new_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new rate estimator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_packed</span> <span class="pre">*</span> <span class="pre">bstats</span></code></dt>
<dd>basic statistics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_cpu</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu_bstats</span></code></dt>
<dd>bstats per cpu</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt>
<dd>rate estimator statistics</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">stats_lock</span></code></dt>
<dd>statistics lock</dd>
<dt><code class="docutils literal"><span class="pre">seqcount_t</span> <span class="pre">*</span> <span class="pre">running</span></code></dt>
<dd>qdisc running seqcount</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*</span> <span class="pre">opt</span></code></dt>
<dd>rate estimator configuration TLV</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new rate estimator with <code class="xref c c-type docutils literal"><span class="pre">bstats</span></code> as source and <code class="xref c c-type docutils literal"><span class="pre">rate_est</span></code>
as destination. A new timer with the interval specified in the
configuration TLV is created. Upon each interval, the latest statistics
will be read from <code class="xref c c-type docutils literal"><span class="pre">bstats</span></code> and the estimated rate will be stored in
<code class="xref c c-type docutils literal"><span class="pre">rate_est</span></code> with the statistics lock grabbed during this period.</p>
<p>Returns 0 on success or a negative error code.</p>
<dl class="function">
<dt id="c.gen_kill_estimator">
void <code class="descname">gen_kill_estimator</code><span class="sig-paren">(</span>struct net_rate_estimator __rcu **<em>&nbsp;rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_kill_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a rate estimator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt>
<dd>rate estimator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the rate estimator.</p>
<dl class="function">
<dt id="c.gen_replace_estimator">
int <code class="descname">gen_replace_estimator</code><span class="sig-paren">(</span>struct gnet_stats_basic_packed *<em>&nbsp;bstats</em>, struct gnet_stats_basic_cpu __percpu *<em>&nbsp;cpu_bstats</em>, struct net_rate_estimator __rcu **<em>&nbsp;rate_est</em>, spinlock_t *<em>&nbsp;stats_lock</em>, seqcount_t *<em>&nbsp;running</em>, struct nlattr *<em>&nbsp;opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_replace_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>replace rate estimator configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_packed</span> <span class="pre">*</span> <span class="pre">bstats</span></code></dt>
<dd>basic statistics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gnet_stats_basic_cpu</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">cpu_bstats</span></code></dt>
<dd>bstats per cpu</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt>
<dd>rate estimator statistics</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">stats_lock</span></code></dt>
<dd>statistics lock</dd>
<dt><code class="docutils literal"><span class="pre">seqcount_t</span> <span class="pre">*</span> <span class="pre">running</span></code></dt>
<dd>qdisc running seqcount (might be NULL)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">nlattr</span> <span class="pre">*</span> <span class="pre">opt</span></code></dt>
<dd>rate estimator configuration TLV</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replaces the configuration of a rate estimator by calling
<a class="reference internal" href="#c.gen_kill_estimator" title="gen_kill_estimator"><code class="xref c c-func docutils literal"><span class="pre">gen_kill_estimator()</span></code></a> and <a class="reference internal" href="#c.gen_new_estimator" title="gen_new_estimator"><code class="xref c c-func docutils literal"><span class="pre">gen_new_estimator()</span></code></a>.</p>
<p>Returns 0 on success or a negative error code.</p>
<dl class="function">
<dt id="c.gen_estimator_active">
bool <code class="descname">gen_estimator_active</code><span class="sig-paren">(</span>struct net_rate_estimator __rcu **<em>&nbsp;rate_est</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gen_estimator_active" title="Permalink to this definition">¶</a></dt>
<dd><p>test if estimator is currently in use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_rate_estimator</span> <span class="pre">__rcu</span> <span class="pre">**</span> <span class="pre">rate_est</span></code></dt>
<dd>rate estimator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if estimator is active, and false if not.</p>
</div>
<div class="section" id="sun-rpc-subsystem">
<h3>SUN RPC subsystem<a class="headerlink" href="#sun-rpc-subsystem" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.xdr_encode_opaque_fixed">
__be32 * <code class="descname">xdr_encode_opaque_fixed</code><span class="sig-paren">(</span>__be32 *<em>&nbsp;p</em>, const void *<em>&nbsp;ptr</em>, unsigned int<em>&nbsp;nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_encode_opaque_fixed" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode fixed length opaque data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__be32</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to current position in XDR buffer.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>pointer to data to encode (or NULL)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt>
<dd>size of data.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the array of data of length nbytes at ptr to the XDR buffer
at position p, then align to the next 32-bit boundary by padding
with zero bytes (see RFC1832).</p>
<p><strong>Note</strong></p>
<p>if ptr is NULL, only the padding is performed.</p>
<p>Returns the updated current XDR buffer position</p>
<dl class="function">
<dt id="c.xdr_encode_opaque">
__be32 * <code class="descname">xdr_encode_opaque</code><span class="sig-paren">(</span>__be32 *<em>&nbsp;p</em>, const void *<em>&nbsp;ptr</em>, unsigned int<em>&nbsp;nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_encode_opaque" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode variable length opaque data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__be32</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to current position in XDR buffer.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>pointer to data to encode (or NULL)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbytes</span></code></dt>
<dd>size of data.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated current XDR buffer position</p>
<dl class="function">
<dt id="c.xdr_terminate_string">
void <code class="descname">xdr_terminate_string</code><span class="sig-paren">(</span>struct xdr_buf *<em>&nbsp;buf</em>, const u32<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_terminate_string" title="Permalink to this definition">¶</a></dt>
<dd><p>‘0’-terminate a string residing in an xdr_buf</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>XDR buffer where string resides</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">len</span></code></dt>
<dd>length of string, in bytes</dd>
</dl>
<dl class="function">
<dt id="c._copy_from_pages">
void <code class="descname">_copy_from_pages</code><span class="sig-paren">(</span>char *<em>&nbsp;p</em>, struct page **<em>&nbsp;pages</em>, size_t<em>&nbsp;pgbase</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c._copy_from_pages" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to destination</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>array of pages</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">pgbase</span></code></dt>
<dd>offset of source data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies data into an arbitrary memory location from an array of pages
The copy is assumed to be non-overlapping.</p>
<dl class="function">
<dt id="c.xdr_stream_pos">
unsigned int <code class="descname">xdr_stream_pos</code><span class="sig-paren">(</span>const struct xdr_stream *<em>&nbsp;xdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current offset from the start of the xdr_stream</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to struct xdr_stream</dd>
</dl>
<dl class="function">
<dt id="c.xdr_init_encode">
void <code class="descname">xdr_init_encode</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, struct xdr_buf *<em>&nbsp;buf</em>, __be32 *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a struct xdr_stream for sending data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to XDR buffer in which to encode data</dd>
<dt><code class="docutils literal"><span class="pre">__be32</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>current pointer inside XDR buffer</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>at the moment the RPC client only passes the length of our</dt>
<dd>scratch buffer in the xdr_buf’s header kvec. Previously this
meant we needed to call <code class="xref c c-func docutils literal"><span class="pre">xdr_adjust_iovec()</span></code> after encoding the
data. With the new scheme, the xdr_stream manages the details
of the buffer length, and takes care of adjusting the kvec
length for us.</dd>
</dl>
<dl class="function">
<dt id="c.xdr_commit_encode">
void <code class="descname">xdr_commit_encode</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_commit_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure all data is written to buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream</dd>
</dl>
<p><strong>Description</strong></p>
<p>We handle encoding across page boundaries by giving the caller a
temporary location to write to, then later copying the data into
place; xdr_commit_encode does that copying.</p>
<p>Normally the caller doesn’t need to call this directly, as the
following xdr_reserve_space will do it.  But an explicit call may be
required at the end of encoding, or any other time when the xdr_buf
data might be read.</p>
<dl class="function">
<dt id="c.xdr_reserve_space">
__be32 * <code class="descname">xdr_reserve_space</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, size_t<em>&nbsp;nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_reserve_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Reserve buffer space for sending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt>
<dd>number of bytes to reserve</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks that we have enough buffer space to encode ‘nbytes’ more
bytes of data. If so, update the total xdr_buf length, and
adjust the length of the current kvec.</p>
<dl class="function">
<dt id="c.xdr_truncate_encode">
void <code class="descname">xdr_truncate_encode</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_truncate_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate an encode buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>new length of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncates the xdr stream, so that xdr-&gt;buf-&gt;len == len,
and xdr-&gt;p points at offset len from the start of the buffer, and
head, tail, and page lengths are adjusted to correspond.</p>
<p>If this means moving xdr-&gt;p to a different buffer, we assume that
that the end pointer should be set to the end of the current page,
except in the case of the head buffer when we assume the head
buffer’s current length represents the end of the available buffer.</p>
<p>This is <em>not</em> safe to use on a buffer that already has inlined page
cache pages (as in a zero-copy server read reply), except for the
simple case of truncating from one position in the tail to another.</p>
<dl class="function">
<dt id="c.xdr_restrict_buflen">
int <code class="descname">xdr_restrict_buflen</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, int<em>&nbsp;newbuflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_restrict_buflen" title="Permalink to this definition">¶</a></dt>
<dd><p>decrease available buffer space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">newbuflen</span></code></dt>
<dd>new maximum number of bytes available</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adjust our idea of how much space is available in the buffer.
If we’ve already used too much space in the buffer, returns -1.
If the available space is already smaller than newbuflen, returns 0
and does nothing.  Otherwise, adjusts xdr-&gt;buf-&gt;buflen to newbuflen
and ensures xdr-&gt;end is set at most offset newbuflen from the start
of the buffer.</p>
<dl class="function">
<dt id="c.xdr_write_pages">
void <code class="descname">xdr_write_pages</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;base</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_write_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a list of pages into an XDR buffer for sending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>list of pages</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>offset of first byte</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of data in bytes</dd>
</dl>
<dl class="function">
<dt id="c.xdr_init_decode">
void <code class="descname">xdr_init_decode</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, struct xdr_buf *<em>&nbsp;buf</em>, __be32 *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an xdr_stream for decoding data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to XDR buffer from which to decode data</dd>
<dt><code class="docutils literal"><span class="pre">__be32</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>current pointer inside XDR buffer</dd>
</dl>
<dl class="function">
<dt id="c.xdr_init_decode_pages">
void <code class="descname">xdr_init_decode_pages</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, struct xdr_buf *<em>&nbsp;buf</em>, struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_init_decode_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an xdr_stream for decoding into pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to XDR buffer from which to decode data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>list of pages to decode into</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length in bytes of buffer in pages</dd>
</dl>
<dl class="function">
<dt id="c.xdr_set_scratch_buffer">
void <code class="descname">xdr_set_scratch_buffer</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_set_scratch_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a scratch buffer for decoding data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream struct</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to an empty buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">buflen</span></code></dt>
<dd>size of ‘buf’</dd>
</dl>
<p><strong>Description</strong></p>
<p>The scratch buffer is used when decoding from an array of pages.
If an <a class="reference internal" href="#c.xdr_inline_decode" title="xdr_inline_decode"><code class="xref c c-func docutils literal"><span class="pre">xdr_inline_decode()</span></code></a> call spans across page boundaries, then
we copy the data into the scratch buffer in order to allow linear
access.</p>
<dl class="function">
<dt id="c.xdr_inline_decode">
__be32 * <code class="descname">xdr_inline_decode</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, size_t<em>&nbsp;nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_inline_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve XDR data to decode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream struct</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt>
<dd>number of bytes of data to decode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the input buffer is long enough to enable us to decode
‘nbytes’ more bytes of data starting at the current position.
If so return the current pointer, then update the current
pointer position.</p>
<dl class="function">
<dt id="c.xdr_read_pages">
unsigned int <code class="descname">xdr_read_pages</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_read_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure page-based XDR data to decode is aligned at current pointer position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream struct</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes of page data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves data beyond the current pointer position from the XDR head[] buffer
into the page list. Any data that lies beyond current position + “len”
bytes is moved into the XDR tail[].</p>
<p>Returns the number of XDR encoded bytes now contained in the pages</p>
<dl class="function">
<dt id="c.xdr_enter_page">
void <code class="descname">xdr_enter_page</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_enter_page" title="Permalink to this definition">¶</a></dt>
<dd><p>decode data from the XDR page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream struct</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes of page data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves data beyond the current pointer position from the XDR head[] buffer
into the page list. Any data that lies beyond current position + “len”
bytes is moved into the XDR tail[]. The current pointer is then
repositioned at the beginning of the first XDR page.</p>
<dl class="function">
<dt id="c.xdr_buf_subsegment">
int <code class="descname">xdr_buf_subsegment</code><span class="sig-paren">(</span>struct xdr_buf *<em>&nbsp;buf</em>, struct xdr_buf *<em>&nbsp;subbuf</em>, unsigned int<em>&nbsp;base</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_buf_subsegment" title="Permalink to this definition">¶</a></dt>
<dd><p>set subbuf to a portion of buf</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>an xdr buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">subbuf</span></code></dt>
<dd>the result buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>beginning of range in bytes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of range in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>sets <strong>subbuf</strong> to an xdr buffer representing the portion of <strong>buf</strong> of
length <strong>len</strong> starting at offset <strong>base</strong>.</p>
<p><strong>buf</strong> and <strong>subbuf</strong> may be pointers to the same struct xdr_buf.</p>
<p>Returns -1 if base of length are out of bounds.</p>
<dl class="function">
<dt id="c.xdr_buf_trim">
void <code class="descname">xdr_buf_trim</code><span class="sig-paren">(</span>struct xdr_buf *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_buf_trim" title="Permalink to this definition">¶</a></dt>
<dd><p>lop at most “len” bytes off the end of “buf”</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buf to be trimmed</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to reduce “buf” by</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trim an xdr_buf by the given number of bytes by fixing up the lengths. Note
that it’s possible that we’ll trim less than that amount if the xdr_buf is
too small, or if (for instance) it’s all in the head and the parser has
already read too far into it.</p>
<dl class="function">
<dt id="c.xdr_stream_decode_string_dup">
ssize_t <code class="descname">xdr_stream_decode_string_dup</code><span class="sig-paren">(</span>struct xdr_stream *<em>&nbsp;xdr</em>, char **<em>&nbsp;str</em>, size_t<em>&nbsp;maxlen</em>, gfp_t<em>&nbsp;gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_stream_decode_string_dup" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode and duplicate variable length string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_stream</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>pointer to xdr_stream</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">str</span></code></dt>
<dd>location to store pointer to string</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">maxlen</span></code></dt>
<dd>maximum acceptable string length</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt>
<dd>GFP mask to use</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Return values:</dt>
<dd>On success, returns length of NUL-terminated string stored in <strong>*ptr</strong>
<code class="docutils literal"><span class="pre">-EBADMSG</span></code> on XDR buffer overflow
<code class="docutils literal"><span class="pre">-EMSGSIZE</span></code> if the size of the string would exceed <strong>maxlen</strong>
<code class="docutils literal"><span class="pre">-ENOMEM</span></code> on memory allocation failure</dd>
</dl>
<dl class="function">
<dt id="c.svc_print_addr">
char * <code class="descname">svc_print_addr</code><span class="sig-paren">(</span>struct svc_rqst *<em>&nbsp;rqstp</em>, char *<em>&nbsp;buf</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_print_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Format rq_addr field for printing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">svc_rqst</span> <span class="pre">*</span> <span class="pre">rqstp</span></code></dt>
<dd>svc_rqst struct containing address to print</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>target buffer for formatted address</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of target buffer</dd>
</dl>
<dl class="function">
<dt id="c.svc_reserve">
void <code class="descname">svc_reserve</code><span class="sig-paren">(</span>struct svc_rqst *<em>&nbsp;rqstp</em>, int<em>&nbsp;space</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>change the space reserved for the reply to a request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">svc_rqst</span> <span class="pre">*</span> <span class="pre">rqstp</span></code></dt>
<dd>The request in question</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">space</span></code></dt>
<dd>new max space to reserve</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each request reserves some space on the output queue of the transport
to make sure the reply fits.  This function reduces that reserved
space to be the amount of space used already, plus <strong>space</strong>.</p>
<dl class="function">
<dt id="c.svc_find_xprt">
struct svc_xprt * <code class="descname">svc_find_xprt</code><span class="sig-paren">(</span>struct svc_serv *<em>&nbsp;serv</em>, const char *<em>&nbsp;xcl_name</em>, struct net *<em>&nbsp;net</em>, const sa_family_t<em>&nbsp;af</em>, const unsigned short<em>&nbsp;port</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_find_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>find an RPC transport instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">svc_serv</span> <span class="pre">*</span> <span class="pre">serv</span></code></dt>
<dd>pointer to svc_serv to search</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">xcl_name</span></code></dt>
<dd>C string containing transport’s class name</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>owner net pointer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">sa_family_t</span> <span class="pre">af</span></code></dt>
<dd>Address family of transport’s local address</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">port</span></code></dt>
<dd>transport’s IP port number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the transport instance pointer for the endpoint accepting
connections/peer traffic from the specified transport class,
address family and port.</p>
<p>Specifying 0 for the address family or port is effectively a
wild-card, and will result in matching the first transport in the
service’s list that has a matching class name.</p>
<dl class="function">
<dt id="c.svc_xprt_names">
int <code class="descname">svc_xprt_names</code><span class="sig-paren">(</span>struct svc_serv *<em>&nbsp;serv</em>, char *<em>&nbsp;buf</em>, const int<em>&nbsp;buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.svc_xprt_names" title="Permalink to this definition">¶</a></dt>
<dd><p>format a buffer with a list of transport names</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">svc_serv</span> <span class="pre">*</span> <span class="pre">serv</span></code></dt>
<dd>pointer to an RPC service</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to a buffer to be filled in</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>length of buffer to be filled in</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills in <strong>buf</strong> with a string containing a list of transport names,
each name terminated with ‘n’.</p>
<p>Returns positive length of the filled-in string on success; otherwise
a negative errno value is returned if an error occurs.</p>
<dl class="function">
<dt id="c.xprt_register_transport">
int <code class="descname">xprt_register_transport</code><span class="sig-paren">(</span>struct xprt_class *<em>&nbsp;transport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_register_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>register a transport implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xprt_class</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt>
<dd>transport to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a transport implementation is loaded as a kernel module, it can
call this interface to make itself known to the RPC client.</p>
<p><strong>Return</strong></p>
<p>0:              transport successfully registered
-EEXIST:        transport already registered
-EINVAL:        transport module being unloaded</p>
<dl class="function">
<dt id="c.xprt_unregister_transport">
int <code class="descname">xprt_unregister_transport</code><span class="sig-paren">(</span>struct xprt_class *<em>&nbsp;transport</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_unregister_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a transport implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xprt_class</span> <span class="pre">*</span> <span class="pre">transport</span></code></dt>
<dd>transport to unregister</dd>
</dl>
<p><strong>Return</strong></p>
<p>0:              transport successfully unregistered
-ENOENT:        transport never registered</p>
<dl class="function">
<dt id="c.xprt_load_transport">
int <code class="descname">xprt_load_transport</code><span class="sig-paren">(</span>const char *<em>&nbsp;transport_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_load_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>load a transport implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">transport_name</span></code></dt>
<dd>transport to load</dd>
</dl>
<p><strong>Return</strong></p>
<p>0:              transport successfully loaded
-ENOENT:        transport module not available</p>
<dl class="function">
<dt id="c.xprt_reserve_xprt">
int <code class="descname">xprt_reserve_xprt</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em>, struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_reserve_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>serialize write access to transports</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>pointer to the target transport</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task that is requesting access to the transport</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prevents mixing the payload of separate requests, and prevents
transport connects from colliding with writes.  No congestion control
is provided.</p>
<dl class="function">
<dt id="c.xprt_release_xprt">
void <code class="descname">xprt_release_xprt</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em>, struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>allow other requests to use a transport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>transport with other tasks potentially waiting</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task that is releasing access to the transport</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that “task” can be NULL.  No congestion control is provided.</p>
<dl class="function">
<dt id="c.xprt_release_xprt_cong">
void <code class="descname">xprt_release_xprt_cong</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em>, struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_xprt_cong" title="Permalink to this definition">¶</a></dt>
<dd><p>allow other requests to use a transport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>transport with other tasks potentially waiting</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task that is releasing access to the transport</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that “task” can be NULL.  Another task is awoken to use the
transport if the transport’s congestion window allows it.</p>
<dl class="function">
<dt id="c.xprt_release_rqst_cong">
void <code class="descname">xprt_release_rqst_cong</code><span class="sig-paren">(</span>struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_release_rqst_cong" title="Permalink to this definition">¶</a></dt>
<dd><p>housekeeping when request is complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>RPC request that recently completed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Useful for transports that require congestion control.</p>
<dl class="function">
<dt id="c.xprt_adjust_cwnd">
void <code class="descname">xprt_adjust_cwnd</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em>, struct rpc_task *<em>&nbsp;task</em>, int<em>&nbsp;result</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_adjust_cwnd" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust transport congestion window</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>pointer to xprt</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>recently completed RPC request used to adjust window</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">result</span></code></dt>
<dd>result code of completed RPC request</dd>
</dl>
<p><strong>Description</strong></p>
<p>The transport code maintains an estimate on the maximum number of out-
standing RPC requests, using a smoothed version of the congestion
avoidance implemented in 44BSD. This is basically the Van Jacobson
congestion algorithm: If a retransmit occurs, the congestion window is
halved; otherwise, it is incremented by 1/cwnd when</p>
<blockquote>
<div><ul class="simple">
<li>a reply is received and</li>
<li>a full number of requests are outstanding and</li>
<li>the congestion window hasn’t been updated recently.</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.xprt_wake_pending_tasks">
void <code class="descname">xprt_wake_pending_tasks</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wake_pending_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>wake all tasks on a transport’s pending queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>transport with waiting tasks</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>result code to plant in each task before waking it</dd>
</dl>
<dl class="function">
<dt id="c.xprt_wait_for_buffer_space">
void <code class="descname">xprt_wait_for_buffer_space</code><span class="sig-paren">(</span>struct rpc_task *<em>&nbsp;task</em>, rpc_action<em>&nbsp;action</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_wait_for_buffer_space" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for transport output buffer to clear</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task to be put to sleep</dd>
<dt><code class="docutils literal"><span class="pre">rpc_action</span> <span class="pre">action</span></code></dt>
<dd>function pointer to be executed after wait</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that we only set the timer for the case of <code class="xref c c-func docutils literal"><span class="pre">RPC_IS_SOFT()</span></code>, since
we don’t in general want to force a socket disconnection due to
an incomplete RPC call transmission.</p>
<dl class="function">
<dt id="c.xprt_write_space">
void <code class="descname">xprt_write_space</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_write_space" title="Permalink to this definition">¶</a></dt>
<dd><p>wake the task waiting for transport output buffer space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>transport with waiting tasks</dd>
</dl>
<p><strong>Description</strong></p>
<p>Can be called in a soft IRQ context, so xprt_write_space never sleeps.</p>
<dl class="function">
<dt id="c.xprt_set_retrans_timeout_def">
void <code class="descname">xprt_set_retrans_timeout_def</code><span class="sig-paren">(</span>struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_set_retrans_timeout_def" title="Permalink to this definition">¶</a></dt>
<dd><p>set a request’s retransmit timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task whose timeout is to be set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a request’s retransmit timeout based on the transport’s
default timeout parameters.  Used by transports that don’t adjust
the retransmit timeout based on round-trip time estimation.</p>
<dl class="function">
<dt id="c.xprt_set_retrans_timeout_rtt">
void <code class="descname">xprt_set_retrans_timeout_rtt</code><span class="sig-paren">(</span>struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_set_retrans_timeout_rtt" title="Permalink to this definition">¶</a></dt>
<dd><p>set a request’s retransmit timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task whose timeout is to be set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a request’s retransmit timeout using the RTT estimator.</p>
<dl class="function">
<dt id="c.xprt_disconnect_done">
void <code class="descname">xprt_disconnect_done</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_disconnect_done" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a transport as disconnected</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>transport to flag for disconnect</dd>
</dl>
<dl class="function">
<dt id="c.xprt_force_disconnect">
void <code class="descname">xprt_force_disconnect</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_force_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>force a transport to disconnect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>transport to disconnect</dd>
</dl>
<dl class="function">
<dt id="c.xprt_lookup_rqst">
struct rpc_rqst * <code class="descname">xprt_lookup_rqst</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em>, __be32<em>&nbsp;xid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_lookup_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>find an RPC request corresponding to an XID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>transport on which the original request was transmitted</dd>
<dt><code class="docutils literal"><span class="pre">__be32</span> <span class="pre">xid</span></code></dt>
<dd>RPC XID of incoming reply</dd>
</dl>
<dl class="function">
<dt id="c.xprt_pin_rqst">
void <code class="descname">xprt_pin_rqst</code><span class="sig-paren">(</span>struct rpc_rqst *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_pin_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>Pin a request on the transport receive list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>Request to pin</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller must ensure this is atomic with the call to <a class="reference internal" href="#c.xprt_lookup_rqst" title="xprt_lookup_rqst"><code class="xref c c-func docutils literal"><span class="pre">xprt_lookup_rqst()</span></code></a>
so should be holding the xprt transport lock.</p>
<dl class="function">
<dt id="c.xprt_unpin_rqst">
void <code class="descname">xprt_unpin_rqst</code><span class="sig-paren">(</span>struct rpc_rqst *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_unpin_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpin a request on the transport receive list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_rqst</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>Request to pin</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller should be holding the xprt transport lock.</p>
<dl class="function">
<dt id="c.xprt_complete_rqst">
void <code class="descname">xprt_complete_rqst</code><span class="sig-paren">(</span>struct rpc_task *<em>&nbsp;task</em>, int<em>&nbsp;copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_complete_rqst" title="Permalink to this definition">¶</a></dt>
<dd><p>called when reply processing is complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>RPC request that recently completed</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">copied</span></code></dt>
<dd>actual number of bytes received from the transport</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller holds transport lock.</p>
<dl class="function">
<dt id="c.xprt_get">
struct rpc_xprt * <code class="descname">xprt_get</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_get" title="Permalink to this definition">¶</a></dt>
<dd><p>return a reference to an RPC transport.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>pointer to the transport</dd>
</dl>
<dl class="function">
<dt id="c.xprt_put">
void <code class="descname">xprt_put</code><span class="sig-paren">(</span>struct rpc_xprt *<em>&nbsp;xprt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xprt_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to an RPC transport.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>pointer to the transport</dd>
</dl>
<dl class="function">
<dt id="c.rpc_wake_up">
void <code class="descname">rpc_wake_up</code><span class="sig-paren">(</span>struct rpc_wait_queue *<em>&nbsp;queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_wake_up" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up all rpc_tasks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_wait_queue</span> <span class="pre">*</span> <span class="pre">queue</span></code></dt>
<dd>rpc_wait_queue on which the tasks are sleeping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grabs queue-&gt;lock</p>
<dl class="function">
<dt id="c.rpc_wake_up_status">
void <code class="descname">rpc_wake_up_status</code><span class="sig-paren">(</span>struct rpc_wait_queue *<em>&nbsp;queue</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_wake_up_status" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up all rpc_tasks and set their status value.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_wait_queue</span> <span class="pre">*</span> <span class="pre">queue</span></code></dt>
<dd>rpc_wait_queue on which the tasks are sleeping</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>status value to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Grabs queue-&gt;lock</p>
<dl class="function">
<dt id="c.rpc_malloc">
int <code class="descname">rpc_malloc</code><span class="sig-paren">(</span>struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_malloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate RPC buffer resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>RPC task</dd>
</dl>
<p><strong>Description</strong></p>
<p>A single memory region is allocated, which is split between the
RPC call and RPC reply that this task is being used for. When
this RPC is retired, the memory is released by calling rpc_free.</p>
<p>To prevent rpciod from hanging, this allocator never sleeps,
returning -ENOMEM and suppressing warning if the request cannot
be serviced immediately. The caller can arrange to sleep in a
way that is safe for rpciod.</p>
<p>Most requests are ‘small’ (under 2KiB) and can be serviced from a
mempool, ensuring that NFS reads and writes can always proceed,
and that there is good locality of reference for these buffers.</p>
<p>In order to avoid memory starvation triggering more writebacks of
NFS requests, we avoid using GFP_KERNEL.</p>
<dl class="function">
<dt id="c.rpc_free">
void <code class="descname">rpc_free</code><span class="sig-paren">(</span>struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free RPC buffer resources allocated via rpc_malloc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>RPC task</dd>
</dl>
<dl class="function">
<dt id="c.xdr_skb_read_bits">
size_t <code class="descname">xdr_skb_read_bits</code><span class="sig-paren">(</span>struct xdr_skb_reader *<em>&nbsp;desc</em>, void *<em>&nbsp;to</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_skb_read_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>copy some data bits from skb to internal buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_skb_reader</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>sk_buff copy helper</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>copy destination</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Possibly called several times to iterate over an sk_buff and copy
data out of it.</p>
<dl class="function">
<dt id="c.xdr_partial_copy_from_skb">
ssize_t <code class="descname">xdr_partial_copy_from_skb</code><span class="sig-paren">(</span>struct xdr_buf *<em>&nbsp;xdr</em>, unsigned int<em>&nbsp;base</em>, struct xdr_skb_reader *<em>&nbsp;desc</em>, xdr_skb_read_actor<em>&nbsp;copy_actor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xdr_partial_copy_from_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>copy data out of an skb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>target XDR buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>starting offset</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_skb_reader</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>sk_buff copy helper</dd>
<dt><code class="docutils literal"><span class="pre">xdr_skb_read_actor</span> <span class="pre">copy_actor</span></code></dt>
<dd>virtual method for copying data</dd>
</dl>
<dl class="function">
<dt id="c.csum_partial_copy_to_xdr">
int <code class="descname">csum_partial_copy_to_xdr</code><span class="sig-paren">(</span>struct xdr_buf *<em>&nbsp;xdr</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.csum_partial_copy_to_xdr" title="Permalink to this definition">¶</a></dt>
<dd><p>checksum and copy data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xdr_buf</span> <span class="pre">*</span> <span class="pre">xdr</span></code></dt>
<dd>target XDR buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>source skb</dd>
</dl>
<p><strong>Description</strong></p>
<p>We have set things up such that we perform the checksum of the UDP
packet in parallel with the copies into the RPC client iovec.  -DaveM</p>
<dl class="function">
<dt id="c.rpc_alloc_iostats">
struct rpc_iostats * <code class="descname">rpc_alloc_iostats</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_alloc_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an rpc_iostats structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC program, version, and xprt</dd>
</dl>
<dl class="function">
<dt id="c.rpc_free_iostats">
void <code class="descname">rpc_free_iostats</code><span class="sig-paren">(</span>struct rpc_iostats *<em>&nbsp;stats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_free_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>release an rpc_iostats structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*</span> <span class="pre">stats</span></code></dt>
<dd>doomed rpc_iostats structure</dd>
</dl>
<dl class="function">
<dt id="c.rpc_count_iostats_metrics">
void <code class="descname">rpc_count_iostats_metrics</code><span class="sig-paren">(</span>const struct rpc_task *<em>&nbsp;task</em>, struct rpc_iostats *<em>&nbsp;op_metrics</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_count_iostats_metrics" title="Permalink to this definition">¶</a></dt>
<dd><p>tally up per-task stats</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>completed rpc_task</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*</span> <span class="pre">op_metrics</span></code></dt>
<dd>stat structure for OP that will accumulate stats from <strong>task</strong></dd>
</dl>
<dl class="function">
<dt id="c.rpc_count_iostats">
void <code class="descname">rpc_count_iostats</code><span class="sig-paren">(</span>const struct rpc_task *<em>&nbsp;task</em>, struct rpc_iostats *<em>&nbsp;stats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_count_iostats" title="Permalink to this definition">¶</a></dt>
<dd><p>tally up per-task stats</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>completed rpc_task</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_iostats</span> <span class="pre">*</span> <span class="pre">stats</span></code></dt>
<dd>array of stat structures</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses the statidx from <strong>task</strong></p>
<dl class="function">
<dt id="c.rpc_queue_upcall">
int <code class="descname">rpc_queue_upcall</code><span class="sig-paren">(</span>struct rpc_pipe *<em>&nbsp;pipe</em>, struct rpc_pipe_msg *<em>&nbsp;msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_queue_upcall" title="Permalink to this definition">¶</a></dt>
<dd><p>queue an upcall message to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>upcall pipe on which to queue given message</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_msg</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>message to queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call with an <strong>inode</strong> created by <code class="xref c c-func docutils literal"><span class="pre">rpc_mkpipe()</span></code> to queue an upcall.
A userspace process may then later read the upcall by performing a
read on an open file for this inode.  It is up to the caller to
initialize the fields of <strong>msg</strong> (other than <strong>msg</strong>-&gt;list) appropriately.</p>
<dl class="function">
<dt id="c.rpc_mkpipe_dentry">
struct dentry * <code class="descname">rpc_mkpipe_dentry</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;parent</em>, const char *<em>&nbsp;name</em>, void *<em>&nbsp;private</em>, struct rpc_pipe *<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_mkpipe_dentry" title="Permalink to this definition">¶</a></dt>
<dd><p>make an rpc_pipefs file for kernel&lt;-&gt;userspace communication</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>dentry of directory to create new “pipe” in</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of pipe</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private</span></code></dt>
<dd>private data to associate with the pipe, for the caller’s use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">rpc_pipe</span></code> containing input parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>Data is made available for userspace to read by calls to
<a class="reference internal" href="#c.rpc_queue_upcall" title="rpc_queue_upcall"><code class="xref c c-func docutils literal"><span class="pre">rpc_queue_upcall()</span></code></a>.  The actual reads will result in calls to
<strong>ops</strong>-&gt;upcall, which will be called with the file pointer,
message, and userspace buffer to copy to.</p>
<p>Writes can come at any time, and do not necessarily have to be
responses to upcalls.  They will result in calls to <strong>msg</strong>-&gt;downcall.</p>
<p>The <strong>private</strong> argument passed here will be available to all these methods
from the file pointer, via RPC_I(file_inode(file))-&gt;private.</p>
<dl class="function">
<dt id="c.rpc_unlink">
int <code class="descname">rpc_unlink</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a pipe</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry for the pipe, as returned from rpc_mkpipe</dd>
</dl>
<p><strong>Description</strong></p>
<p>After this call, lookups will no longer find the pipe, and any
attempts to read or write using preexisting opens of the pipe will
return -EPIPE.</p>
<dl class="function">
<dt id="c.rpc_init_pipe_dir_head">
void <code class="descname">rpc_init_pipe_dir_head</code><span class="sig-paren">(</span>struct rpc_pipe_dir_head *<em>&nbsp;pdh</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_init_pipe_dir_head" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a struct rpc_pipe_dir_head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*</span> <span class="pre">pdh</span></code></dt>
<dd>pointer to struct rpc_pipe_dir_head</dd>
</dl>
<dl class="function">
<dt id="c.rpc_init_pipe_dir_object">
void <code class="descname">rpc_init_pipe_dir_object</code><span class="sig-paren">(</span>struct rpc_pipe_dir_object *<em>&nbsp;pdo</em>, const struct rpc_pipe_dir_object_ops *<em>&nbsp;pdo_ops</em>, void *<em>&nbsp;pdo_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_init_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise a struct rpc_pipe_dir_object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*</span> <span class="pre">pdo</span></code></dt>
<dd>pointer to struct rpc_pipe_dir_object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object_ops</span> <span class="pre">*</span> <span class="pre">pdo_ops</span></code></dt>
<dd>pointer to const struct rpc_pipe_dir_object_ops</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pdo_data</span></code></dt>
<dd>pointer to caller-defined data</dd>
</dl>
<dl class="function">
<dt id="c.rpc_add_pipe_dir_object">
int <code class="descname">rpc_add_pipe_dir_object</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, struct rpc_pipe_dir_head *<em>&nbsp;pdh</em>, struct rpc_pipe_dir_object *<em>&nbsp;pdo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_add_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a rpc_pipe_dir_object to a directory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>pointer to struct net</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*</span> <span class="pre">pdh</span></code></dt>
<dd>pointer to struct rpc_pipe_dir_head</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*</span> <span class="pre">pdo</span></code></dt>
<dd>pointer to struct rpc_pipe_dir_object</dd>
</dl>
<dl class="function">
<dt id="c.rpc_remove_pipe_dir_object">
void <code class="descname">rpc_remove_pipe_dir_object</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, struct rpc_pipe_dir_head *<em>&nbsp;pdh</em>, struct rpc_pipe_dir_object *<em>&nbsp;pdo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_remove_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a rpc_pipe_dir_object from a directory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>pointer to struct net</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*</span> <span class="pre">pdh</span></code></dt>
<dd>pointer to struct rpc_pipe_dir_head</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*</span> <span class="pre">pdo</span></code></dt>
<dd>pointer to struct rpc_pipe_dir_object</dd>
</dl>
<dl class="function">
<dt id="c.rpc_find_or_alloc_pipe_dir_object">
struct rpc_pipe_dir_object * <code class="descname">rpc_find_or_alloc_pipe_dir_object</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, struct rpc_pipe_dir_head *<em>&nbsp;pdh</em>, int (*match) (struct rpc_pipe_dir_object<em>&nbsp;*</em>, void<em>&nbsp;*</em>, struct rpc_pipe_dir_object *(*alloc) (void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_find_or_alloc_pipe_dir_object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>pointer to struct net</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_head</span> <span class="pre">*</span> <span class="pre">pdh</span></code></dt>
<dd>pointer to struct rpc_pipe_dir_head</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">match</span></code></dt>
<dd>match struct rpc_pipe_dir_object to data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_pipe_dir_object</span> <span class="pre">*(*)(void</span> <span class="pre">*)</span> <span class="pre">alloc</span></code></dt>
<dd>allocate a new struct rpc_pipe_dir_object</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>user defined data for <code class="xref c c-func docutils literal"><span class="pre">match()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">alloc()</span></code></dd>
</dl>
<dl class="function">
<dt id="c.rpcb_getport_async">
void <code class="descname">rpcb_getport_async</code><span class="sig-paren">(</span>struct rpc_task *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpcb_getport_async" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the port for a given RPC service on a given host</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_task</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task that is waiting for portmapper request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This one can be called for an ongoing RPC request, and can be used in
an async (rpciod) context.</p>
<dl class="function">
<dt id="c.rpc_create">
struct rpc_clnt * <code class="descname">rpc_create</code><span class="sig-paren">(</span>struct rpc_create_args *<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an RPC client and transport with one call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_create_args</span> <span class="pre">*</span> <span class="pre">args</span></code></dt>
<dd>rpc_clnt create argument structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates and initializes an RPC transport and an RPC client.</p>
<p>It can ping the server in order to determine if it is up, and to see if
it supports this program and version.  RPC_CLNT_CREATE_NOPING disables
this behavior so asynchronous tasks can also use rpc_create.</p>
<dl class="function">
<dt id="c.rpc_clone_client">
struct rpc_clnt * <code class="descname">rpc_clone_client</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clone_client" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an RPC client structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client whose parameters are copied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a fresh RPC client or an ERR_PTR.</p>
<dl class="function">
<dt id="c.rpc_clone_client_set_auth">
struct rpc_clnt * <code class="descname">rpc_clone_client_set_auth</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, rpc_authflavor_t<em>&nbsp;flavor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clone_client_set_auth" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an RPC client structure and set its auth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client whose parameters are copied</dd>
<dt><code class="docutils literal"><span class="pre">rpc_authflavor_t</span> <span class="pre">flavor</span></code></dt>
<dd>security flavor for new client</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a fresh RPC client or an ERR_PTR.</p>
<dl class="function">
<dt id="c.rpc_switch_client_transport">
int <code class="descname">rpc_switch_client_transport</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, struct xprt_create *<em>&nbsp;args</em>, const struct rpc_timeout *<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_switch_client_transport" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>pointer to a struct rpc_clnt</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xprt_create</span> <span class="pre">*</span> <span class="pre">args</span></code></dt>
<dd>pointer to the new transport arguments</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_timeout</span> <span class="pre">*</span> <span class="pre">timeout</span></code></dt>
<dd>pointer to the new timeout parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows the caller to switch the RPC transport for the
rpc_clnt structure ‘clnt’ to allow it to connect to a mirrored NFS
server, for instance.  It assumes that the caller has ensured that
there are no active RPC tasks by using some form of locking.</p>
<p>Returns zero if “clnt” is now using the new xprt.  Otherwise a
negative errno is returned, and “clnt” continues to use the old
xprt.</p>
<dl class="function">
<dt id="c.rpc_clnt_iterate_for_each_xprt">
int <code class="descname">rpc_clnt_iterate_for_each_xprt</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, int (*fn) (struct rpc_clnt<em>&nbsp;*</em>, struct rpc_xprt<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_iterate_for_each_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to all transports</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>pointer to client</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>function to apply</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>void pointer to function data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterates through the list of RPC transports currently attached to the
client and applies the function fn(clnt, xprt, data).</p>
<p>On error, the iteration stops, and the function returns the error value.</p>
<dl class="function">
<dt id="c.rpc_bind_new_program">
struct rpc_clnt * <code class="descname">rpc_bind_new_program</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;old</em>, const struct rpc_program *<em>&nbsp;program</em>, u32<em>&nbsp;vers</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_bind_new_program" title="Permalink to this definition">¶</a></dt>
<dd><p>bind a new RPC program to an existing client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>old rpc_client</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_program</span> <span class="pre">*</span> <span class="pre">program</span></code></dt>
<dd>rpc program to set</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">vers</span></code></dt>
<dd>rpc program version</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clones the rpc client and sets up a new RPC program. This is mainly
of use for enabling different RPC programs to share the same transport.
The Sun NFSv2/v3 ACL protocol can do this.</p>
<dl class="function">
<dt id="c.rpc_run_task">
struct rpc_task * <code class="descname">rpc_run_task</code><span class="sig-paren">(</span>const struct rpc_task_setup *<em>&nbsp;task_setup_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_run_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a new RPC task, then run rpc_execute against it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_task_setup</span> <span class="pre">*</span> <span class="pre">task_setup_data</span></code></dt>
<dd>pointer to task initialisation data</dd>
</dl>
<dl class="function">
<dt id="c.rpc_call_sync">
int <code class="descname">rpc_call_sync</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, const struct rpc_message *<em>&nbsp;msg</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_call_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a synchronous RPC call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>pointer to RPC client</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_message</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>RPC call parameters</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>RPC call flags</dd>
</dl>
<dl class="function">
<dt id="c.rpc_call_async">
int <code class="descname">rpc_call_async</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, const struct rpc_message *<em>&nbsp;msg</em>, int<em>&nbsp;flags</em>, const struct rpc_call_ops *<em>&nbsp;tk_ops</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_call_async" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an asynchronous RPC call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>pointer to RPC client</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_message</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>RPC call parameters</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>RPC call flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">rpc_call_ops</span> <span class="pre">*</span> <span class="pre">tk_ops</span></code></dt>
<dd>RPC call ops</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>user call data</dd>
</dl>
<dl class="function">
<dt id="c.rpc_peeraddr">
size_t <code class="descname">rpc_peeraddr</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, struct sockaddr *<em>&nbsp;buf</em>, size_t<em>&nbsp;bufsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_peeraddr" title="Permalink to this definition">¶</a></dt>
<dd><p>extract remote peer address from clnt’s xprt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>target buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">bufsize</span></code></dt>
<dd>length of target buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of bytes that are actually in the stored address.</p>
<dl class="function">
<dt id="c.rpc_peeraddr2str">
const char * <code class="descname">rpc_peeraddr2str</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, enum rpc_display_format_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_peeraddr2str" title="Permalink to this definition">¶</a></dt>
<dd><p>return remote peer address in printable format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client structure</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">rpc_display_format_t</span> <span class="pre">format</span></code></dt>
<dd>address format</dd>
</dl>
<p><strong>Description</strong></p>
<p>NB: the lifetime of the memory referenced by the returned pointer is
the same as the rpc_xprt itself.  As long as the caller uses this
pointer, it must hold the RCU read lock.</p>
<dl class="function">
<dt id="c.rpc_localaddr">
int <code class="descname">rpc_localaddr</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, struct sockaddr *<em>&nbsp;buf</em>, size_t<em>&nbsp;buflen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_localaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>discover local endpoint address for an RPC client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>target buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">buflen</span></code></dt>
<dd>size of target buffer, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns zero and fills in “buf” and “buflen” if successful;
otherwise, a negative errno is returned.</p>
<p>This works even if the underlying transport is not currently connected,
or if the upper layer never previously provided a source address.</p>
<p>The result of this function call is transient: multiple calls in
succession may give different results, depending on how local
networking configuration changes over time.</p>
<dl class="function">
<dt id="c.rpc_protocol">
int <code class="descname">rpc_protocol</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_protocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Get transport protocol number for an RPC client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client to query</dd>
</dl>
<dl class="function">
<dt id="c.rpc_net_ns">
struct net * <code class="descname">rpc_net_ns</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_net_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the network namespace for this RPC client</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client to query</dd>
</dl>
<dl class="function">
<dt id="c.rpc_max_payload">
size_t <code class="descname">rpc_max_payload</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_max_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Get maximum payload size for a transport, in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client to query</dd>
</dl>
<p><strong>Description</strong></p>
<p>For stream transports, this is one RPC record fragment (see RFC
1831), as we don’t support multi-record requests yet.  For datagram
transports, this is the size of an IP packet minus the IP, UDP, and
RPC header sizes.</p>
<dl class="function">
<dt id="c.rpc_max_bc_payload">
size_t <code class="descname">rpc_max_bc_payload</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_max_bc_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Get maximum backchannel payload size, in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>RPC client to query</dd>
</dl>
<dl class="function">
<dt id="c.rpc_force_rebind">
void <code class="descname">rpc_force_rebind</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_force_rebind" title="Permalink to this definition">¶</a></dt>
<dd><p>force transport to check that remote port is unchanged</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>client to rebind</dd>
</dl>
<dl class="function">
<dt id="c.rpc_clnt_test_and_add_xprt">
int <code class="descname">rpc_clnt_test_and_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, struct rpc_xprt_switch *<em>&nbsp;xps</em>, struct rpc_xprt *<em>&nbsp;xprt</em>, void *<em>&nbsp;dummy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_test_and_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Test and add a new transport to a rpc_clnt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>pointer to struct rpc_clnt</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*</span> <span class="pre">xps</span></code></dt>
<dd>pointer to struct rpc_xprt_switch,</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>pointer struct rpc_xprt</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dummy</span></code></dt>
<dd>unused</dd>
</dl>
<dl class="function">
<dt id="c.rpc_clnt_setup_test_and_add_xprt">
int <code class="descname">rpc_clnt_setup_test_and_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, struct rpc_xprt_switch *<em>&nbsp;xps</em>, struct rpc_xprt *<em>&nbsp;xprt</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_setup_test_and_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>struct rpc_clnt to get the new transport</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*</span> <span class="pre">xps</span></code></dt>
<dd>the rpc_xprt_switch to hold the new transport</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*</span> <span class="pre">xprt</span></code></dt>
<dd>the rpc_xprt to test</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a struct rpc_add_xprt_test pointer that holds the test function
and test function call data</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>This is an rpc_clnt_add_xprt <code class="xref c c-func docutils literal"><span class="pre">setup()</span></code> function which returns 1 so:</dt>
<dd>1) caller of the test function must dereference the rpc_xprt_switch
and the rpc_xprt.
2) test function must call rpc_xprt_switch_add_xprt, usually in
the rpc_call_done routine.</dd>
</dl>
<p>Upon success (return of 1), the test function adds the new
transport to the rpc_clnt xprt switch</p>
<dl class="function">
<dt id="c.rpc_clnt_add_xprt">
int <code class="descname">rpc_clnt_add_xprt</code><span class="sig-paren">(</span>struct rpc_clnt *<em>&nbsp;clnt</em>, struct xprt_create *<em>&nbsp;xprtargs</em>, int (*setup) (struct rpc_clnt<em>&nbsp;*</em>, struct rpc_xprt_switch<em>&nbsp;*</em>, struct rpc_xprt<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rpc_clnt_add_xprt" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new transport to a rpc_clnt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*</span> <span class="pre">clnt</span></code></dt>
<dd>pointer to struct rpc_clnt</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">xprt_create</span> <span class="pre">*</span> <span class="pre">xprtargs</span></code></dt>
<dd>pointer to struct xprt_create</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">rpc_clnt</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt_switch</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">rpc_xprt</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">setup</span></code></dt>
<dd>callback to test and/or set up the connection</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to setup function data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new transport using the parameters set in args and
adds it to clnt.
If ping is set, then test that connectivity succeeds before
adding the new transport.</p>
</div>
<div class="section" id="wimax">
<h3>WiMAX<a class="headerlink" href="#wimax" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.wimax_msg_alloc">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">wimax_msg_alloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em>, const char *<em>&nbsp;pipe_name</em>, const void *<em>&nbsp;msg</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new skb for sending a message to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pipe_name</span></code></dt>
<dd>“named pipe” the message will be sent to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>pointer to the message data to send</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the message to send (in bytes), including the header.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt>
<dd>flags for memory allocation.</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">0</span></code> if ok, negative errno code on error</p>
<p><strong>Description</strong></p>
<p>Allocates an skb that will contain the message to send to user
space over the messaging pipe and initializes it, copying the
payload.</p>
<p>Once this call is done, you can deliver it with
<a class="reference internal" href="#c.wimax_msg_send" title="wimax_msg_send"><code class="xref c c-func docutils literal"><span class="pre">wimax_msg_send()</span></code></a>.</p>
<p>IMPORTANT:</p>
<p>Don’t use <a class="reference internal" href="#c.skb_push" title="skb_push"><code class="xref c c-func docutils literal"><span class="pre">skb_push()</span></code></a>/<a class="reference internal" href="#c.skb_pull" title="skb_pull"><code class="xref c c-func docutils literal"><span class="pre">skb_pull()</span></code></a>/<a class="reference internal" href="#c.skb_reserve" title="skb_reserve"><code class="xref c c-func docutils literal"><span class="pre">skb_reserve()</span></code></a> on the skb, as
<a class="reference internal" href="#c.wimax_msg_send" title="wimax_msg_send"><code class="xref c c-func docutils literal"><span class="pre">wimax_msg_send()</span></code></a> depends on skb-&gt;data being placed at the
beginning of the user message.</p>
<p>Unlike other WiMAX stack calls, this call can be used way early,
even before <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a> is called, as long as the
wimax_dev-&gt;net_dev pointer is set to point to a proper
net_dev. This is so that drivers can use it early in case they need
to send stuff around or communicate with user space.</p>
<dl class="function">
<dt id="c.wimax_msg_data_len">
const void * <code class="descname">wimax_msg_data_len</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;msg</em>, size_t *<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_data_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pointer and size of a message’s payload</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>Pointer to a message created with <a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal"><span class="pre">wimax_msg_alloc()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt>
<dd>Pointer to where to store the message’s size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the pointer to the message data.</p>
<dl class="function">
<dt id="c.wimax_msg_data">
const void * <code class="descname">wimax_msg_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pointer to a message’s payload</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>Pointer to a message created with <a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal"><span class="pre">wimax_msg_alloc()</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.wimax_msg_len">
ssize_t <code class="descname">wimax_msg_len</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;msg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a message’s payload length</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">msg</span></code></dt>
<dd>Pointer to a message created with <a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal"><span class="pre">wimax_msg_alloc()</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.wimax_msg_send">
int <code class="descname">wimax_msg_send</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg_send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a pre-allocated message to user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd><a class="reference internal" href="#c.sk_buff" title="sk_buff"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code></a> returned by <a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal"><span class="pre">wimax_msg_alloc()</span></code></a>. Note the
ownership of <strong>skb</strong> is transferred to this function.</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 if ok, &lt; 0 errno code on error</p>
<p><strong>Description</strong></p>
<p>Sends a free-form message that was preallocated with
<a class="reference internal" href="#c.wimax_msg_alloc" title="wimax_msg_alloc"><code class="xref c c-func docutils literal"><span class="pre">wimax_msg_alloc()</span></code></a> and filled up.</p>
<p>Assumes that once you pass an skb to this function for sending, it
owns it and will release it when done (on success).</p>
<p>IMPORTANT:</p>
<p>Don’t use <a class="reference internal" href="#c.skb_push" title="skb_push"><code class="xref c c-func docutils literal"><span class="pre">skb_push()</span></code></a>/<a class="reference internal" href="#c.skb_pull" title="skb_pull"><code class="xref c c-func docutils literal"><span class="pre">skb_pull()</span></code></a>/<a class="reference internal" href="#c.skb_reserve" title="skb_reserve"><code class="xref c c-func docutils literal"><span class="pre">skb_reserve()</span></code></a> on the skb, as
<a class="reference internal" href="#c.wimax_msg_send" title="wimax_msg_send"><code class="xref c c-func docutils literal"><span class="pre">wimax_msg_send()</span></code></a> depends on skb-&gt;data being placed at the
beginning of the user message.</p>
<p>Unlike other WiMAX stack calls, this call can be used way early,
even before <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a> is called, as long as the
wimax_dev-&gt;net_dev pointer is set to point to a proper
net_dev. This is so that drivers can use it early in case they need
to send stuff around or communicate with user space.</p>
<dl class="function">
<dt id="c.wimax_msg">
int <code class="descname">wimax_msg</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em>, const char *<em>&nbsp;pipe_name</em>, const void *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a message to user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor (properly referenced)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pipe_name</span></code></dt>
<dd>“named pipe” the message will be sent to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to the message to send.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the buffer pointed to by <strong>buf</strong> (in bytes).</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_flags</span></code></dt>
<dd>flags for memory allocation.</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">0</span></code> if ok, negative errno code on error.</p>
<p><strong>Description</strong></p>
<p>Sends a free-form message to user space on the device <strong>wimax_dev</strong>.</p>
<p><strong>NOTES</strong></p>
<p>Once the <strong>skb</strong> is given to this function, who will own it and will
release it when done (unless it returns error).</p>
<dl class="function">
<dt id="c.wimax_reset">
int <code class="descname">wimax_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset a WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">0</span></code> if ok and a warm reset was done (the device still exists in
the system).</p>
<p>-<code class="docutils literal"><span class="pre">ENODEV</span></code> if a cold/bus reset had to be done (device has
disconnected and reconnected, so current handle is not valid
any more).</p>
<p>-<code class="docutils literal"><span class="pre">EINVAL</span></code> if the device is not even registered.</p>
<p>Any other negative error code shall be considered as
non-recoverable.</p>
<p><strong>Description</strong></p>
<p>Called when wanting to reset the device for any reason. Device is
taken back to power on status.</p>
<p>This call blocks; on successful return, the device has completed the
reset process and is ready to operate.</p>
<dl class="function">
<dt id="c.wimax_report_rfkill_hw">
void <code class="descname">wimax_report_rfkill_hw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em>, enum wimax_rf_state<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_report_rfkill_hw" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports changes in the hardware RF switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">wimax_rf_state</span> <span class="pre">state</span></code></dt>
<dd>New state of the RF Kill switch. <code class="docutils literal"><span class="pre">WIMAX_RF_ON</span></code> radio on,
<code class="docutils literal"><span class="pre">WIMAX_RF_OFF</span></code> radio off.</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the device detects a change in the state of thehardware RF
switch, it must call this function to let the WiMAX kernel stack
know that the state has changed so it can be properly propagated.</p>
<p>The WiMAX stack caches the state (the driver doesn’t need to). As
well, as the change is propagated it will come back as a request to
change the software state to mirror the hardware state.</p>
<p>If the device doesn’t have a hardware kill switch, just report
it on initialization as always on (<code class="docutils literal"><span class="pre">WIMAX_RF_ON</span></code>, radio on).</p>
<dl class="function">
<dt id="c.wimax_report_rfkill_sw">
void <code class="descname">wimax_report_rfkill_sw</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em>, enum wimax_rf_state<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_report_rfkill_sw" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports changes in the software RF switch</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">wimax_rf_state</span> <span class="pre">state</span></code></dt>
<dd>New state of the RF kill switch. <code class="docutils literal"><span class="pre">WIMAX_RF_ON</span></code> radio on,
<code class="docutils literal"><span class="pre">WIMAX_RF_OFF</span></code> radio off.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reports changes in the software RF switch state to the WiMAX stack.</p>
<p>The main use is during initialization, so the driver can query the
device for its current software radio kill switch state and feed it
to the system.</p>
<p>On the side, the device does not change the software state by
itself. In practice, this can happen, as the device might decide to
switch (in software) the radio off for different reasons.</p>
<dl class="function">
<dt id="c.wimax_rfkill">
int <code class="descname">wimax_rfkill</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em>, enum wimax_rf_state<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_rfkill" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the software RF switch state for a WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">wimax_rf_state</span> <span class="pre">state</span></code></dt>
<dd>New RF state.</dd>
</dl>
<p><strong>Return</strong></p>
<p>&gt;= 0 toggle state if ok, &lt; 0 errno code on error. The toggle state
is returned as a bitmap, bit 0 being the hardware RF state, bit 1
the software RF state.</p>
<p>0 means disabled (<code class="docutils literal"><span class="pre">WIMAX_RF_ON</span></code>, radio on), 1 means enabled radio
off (<code class="docutils literal"><span class="pre">WIMAX_RF_OFF</span></code>).</p>
<p><strong>Description</strong></p>
<p>Called by the user when he wants to request the WiMAX radio to be
switched on (<code class="docutils literal"><span class="pre">WIMAX_RF_ON</span></code>) or off (<code class="docutils literal"><span class="pre">WIMAX_RF_OFF</span></code>). With
<code class="docutils literal"><span class="pre">WIMAX_RF_QUERY</span></code>, just the current state is returned.</p>
<p><strong>NOTE</strong></p>
<p>This call will block until the operation is complete.</p>
<dl class="function">
<dt id="c.wimax_state_change">
void <code class="descname">wimax_state_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em>, enum <a class="reference internal" href="#c.wimax_st" title="wimax_st">wimax_st</a><em>&nbsp;new_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_state_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current state of a WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor (properly referenced)</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">wimax_st</span> <span class="pre">new_state</span></code></dt>
<dd>New state to switch to</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implements the state changes for the wimax devices. It will</p>
<ul class="simple">
<li>verify that the state transition is legal (for now it’ll just
print a warning if not) according to the table in
linux/wimax.h’s documentation for ‘enum wimax_st’.</li>
<li>perform the actions needed for leaving the current state and
whichever are needed for entering the new state.</li>
<li>issue a report to user space indicating the new state (and an
optional payload with information about the new state).</li>
</ul>
<p><strong>NOTE</strong></p>
<p><strong>wimax_dev</strong> must be locked</p>
<dl class="function">
<dt id="c.wimax_state_get">
enum <a class="reference internal" href="#c.wimax_st" title="wimax_st">wimax_st</a> <code class="descname">wimax_state_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_state_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current state of a WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor</dd>
</dl>
<p><strong>Return</strong></p>
<p>Current state of the device according to its driver.</p>
<dl class="function">
<dt id="c.wimax_dev_init">
void <code class="descname">wimax_dev_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_dev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a newly allocated instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor to initialize.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes fields of a freshly allocated <strong>wimax_dev</strong> instance. This
function assumes that after allocation, the memory occupied by
<strong>wimax_dev</strong> was zeroed.</p>
<dl class="function">
<dt id="c.wimax_dev_add">
int <code class="descname">wimax_dev_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;net_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_dev_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a new WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor (as embedded in your <strong>net_dev</strong>’s
priv data). You must have called <a class="reference internal" href="#c.wimax_dev_init" title="wimax_dev_init"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_init()</span></code></a> on it before.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">net_dev</span></code></dt>
<dd>net device the <strong>wimax_dev</strong> is associated with. The
function expects <code class="xref c c-func docutils literal"><span class="pre">SET_NETDEV_DEV()</span></code> and <a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal"><span class="pre">register_netdev()</span></code></a> were
already called on it.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers the new WiMAX device, sets up the user-kernel control
interface (generic netlink) and common WiMAX infrastructure.</p>
<p>Note that the parts that will allow interaction with user space are
setup at the very end, when the rest is in place, as once that
happens, the driver might get user space control requests via
netlink or from debugfs that might translate into calls into
wimax_dev-&gt;op_*().</p>
<dl class="function">
<dt id="c.wimax_dev_rm">
void <code class="descname">wimax_dev_rm</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.wimax_dev" title="wimax_dev">wimax_dev</a> *<em>&nbsp;wimax_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wimax_dev_rm" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister an existing WiMAX device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span> <span class="pre">*</span> <span class="pre">wimax_dev</span></code></dt>
<dd>WiMAX device descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a WiMAX device previously registered for use with
<code class="xref c c-func docutils literal"><span class="pre">wimax_add_rm()</span></code>.</p>
<p>IMPORTANT! Must call before calling <a class="reference internal" href="#c.unregister_netdev" title="unregister_netdev"><code class="xref c c-func docutils literal"><span class="pre">unregister_netdev()</span></code></a>.</p>
<p>After this function returns, you will not get any more user space
control requests (via netlink or debugfs) and thus to wimax_dev-&gt;ops.</p>
<p>Reentrancy control is ensured by setting the state to
<code class="docutils literal"><span class="pre">__WIMAX_ST_QUIESCING</span></code>. rfkill operations coming through
wimax_*rfkill*() will be stopped by the quiescing state; ops coming
from the rfkill subsystem will be stopped by the support being
removed by <code class="xref c c-func docutils literal"><span class="pre">wimax_rfkill_rm()</span></code>.</p>
<dl class="type">
<dt id="c.wimax_dev">
struct <code class="descname">wimax_dev</code><a class="headerlink" href="#c.wimax_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic WiMAX device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct wimax_dev {
  struct net_device * net_dev;
  struct list_head id_table_node;
  struct mutex mutex;
  struct mutex mutex_reset;
  enum wimax_st state;
  int (* op_msg_from_user) (struct wimax_dev *wimax_dev,const char *,const void *, size_t, const struct genl_info *info);
  int (* op_rfkill_sw_toggle) (struct wimax_dev *wimax_dev, enum wimax_rf_state);
  int (* op_reset) (struct wimax_dev *wimax_dev);
  struct rfkill * rfkill;
  unsigned int rf_hw;
  unsigned int rf_sw;
  char name;
  struct dentry * debugfs_dentry;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">net_dev</span></code></dt>
<dd>[fill] Pointer to the <a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span></code></a> this WiMAX
device implements.</dd>
<dt><code class="docutils literal"><span class="pre">id_table_node</span></code></dt>
<dd>[private] link to the list of wimax devices kept by
id-table.c. Protected by it’s own spinlock.</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>[private] Serializes all concurrent access and execution of
operations.</dd>
<dt><code class="docutils literal"><span class="pre">mutex_reset</span></code></dt>
<dd>[private] Serializes reset operations. Needs to be a
different mutex because as part of the reset operation, the
driver has to call back into the stack to do things such as
state change, that require wimax_dev-&gt;mutex.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>[private] Current state of the WiMAX device.</dd>
<dt><code class="docutils literal"><span class="pre">op_msg_from_user</span></code></dt>
<dd>[fill] Driver-specific operation to
handle a raw message from user space to the driver. The
driver can send messages to user space using with
<code class="xref c c-func docutils literal"><span class="pre">wimax_msg_to_user()</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">op_rfkill_sw_toggle</span></code></dt>
<dd>[fill] Driver-specific operation to act on
userspace (or any other agent) requesting the WiMAX device to
change the RF Kill software switch (WIMAX_RF_ON or
WIMAX_RF_OFF).
If such hardware support is not present, it is assumed the
radio cannot be switched off and it is always on (and the stack
will error out when trying to switch it off). In such case,
this function pointer can be left as NULL.</dd>
<dt><code class="docutils literal"><span class="pre">op_reset</span></code></dt>
<dd>[fill] Driver specific operation to reset the
device.
This operation should always attempt first a warm reset that
does not disconnect the device from the bus and return 0.
If that fails, it should resort to some sort of cold or bus
reset (even if it implies a bus disconnection and device
disappearance). In that case, -ENODEV should be returned to
indicate the device is gone.
This operation has to be synchronous, and return only when the
reset is complete. In case of having had to resort to bus/cold
reset implying a device disconnection, the call is allowed to
return immediately.</dd>
<dt><code class="docutils literal"><span class="pre">rfkill</span></code></dt>
<dd>[private] integration into the RF-Kill infrastructure.</dd>
<dt><code class="docutils literal"><span class="pre">rf_hw</span></code></dt>
<dd>[private] State of the hardware radio switch (OFF/ON)</dd>
<dt><code class="docutils literal"><span class="pre">rf_sw</span></code></dt>
<dd>[private] State of the software radio switch (OFF/ON)</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>[fill] A way to identify this device. We need to register a
name with many subsystems (rfkill, workqueue creation, etc).
We can’t use the network device name as that
might change and in some instances we don’t know it yet (until
we don’t call <a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal"><span class="pre">register_netdev()</span></code></a>). So we generate an unique one
using the driver name and device bus id, place it here and use
it across the board. Recommended naming:
DRIVERNAME-BUSNAME:BUSID (dev-&gt;bus-&gt;name, dev-&gt;bus_id).</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_dentry</span></code></dt>
<dd>[private] Used to hook up a debugfs entry. This
shows up in the debugfs root as wimax:DEVICENAME.</dd>
</dl>
<p><strong>NOTE</strong></p>
<dl class="docutils">
<dt>wimax_dev-&gt;mutex is NOT locked when this op is being</dt>
<dd>called; however, wimax_dev-&gt;mutex_reset IS locked to ensure
serialization of calls to <a class="reference internal" href="#c.wimax_reset" title="wimax_reset"><code class="xref c c-func docutils literal"><span class="pre">wimax_reset()</span></code></a>.
See <a class="reference internal" href="#c.wimax_reset" title="wimax_reset"><code class="xref c c-func docutils literal"><span class="pre">wimax_reset()</span></code></a>’s documentation.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure defines a common interface to access all WiMAX
devices from different vendors and provides a common API as well as
a free-form device-specific messaging channel.</p>
<dl class="docutils">
<dt>Usage:</dt>
<dd><ol class="first last arabic simple">
<li>Embed a <a class="reference internal" href="#c.wimax_dev" title="wimax_dev"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">wimax_dev</span></code></a> at <em>the beginning</em> the network
device structure so that <a class="reference internal" href="#c.netdev_priv" title="netdev_priv"><code class="xref c c-func docutils literal"><span class="pre">netdev_priv()</span></code></a> points to it.</li>
<li><a class="reference internal" href="../core-api/kernel-api.html#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> it to zero</li>
<li>Initialize with <a class="reference internal" href="#c.wimax_dev_init" title="wimax_dev_init"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_init()</span></code></a>. This will leave the WiMAX
device in the <code class="docutils literal"><span class="pre">__WIMAX_ST_NULL</span></code> state.</li>
<li>Fill all the fields marked with [fill]; once called
<a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a>, those fields CANNOT be modified.</li>
<li>Call <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a> <em>after</em> registering the network
device. This will leave the WiMAX device in the <code class="docutils literal"><span class="pre">WIMAX_ST_DOWN</span></code>
state.
Protect the driver’s net_device-&gt;:c:func:<cite>open()</cite> against succeeding if
the wimax device state is lower than <code class="docutils literal"><span class="pre">WIMAX_ST_DOWN</span></code>.</li>
<li>Select when the device is going to be turned on/initialized;
for example, it could be initialized on ‘ifconfig up’ (when the
netdev op ‘<a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a>’ is called on the driver).</li>
</ol>
</dd>
</dl>
<p>When the device is initialized (at <cite>ifconfig up</cite> time, or right
after calling <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a> from <code class="xref c c-func docutils literal"><span class="pre">_probe()</span></code>, make sure the
following steps are taken</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>Move the device to <code class="docutils literal"><span class="pre">WIMAX_ST_UNINITIALIZED</span></code>. This is needed so
some API calls that shouldn’t work until the device is ready
can be blocked.</li>
<li>Initialize the device. Make sure to turn the SW radio switch
off and move the device to state <code class="docutils literal"><span class="pre">WIMAX_ST_RADIO_OFF</span></code> when
done. When just initialized, a device should be left in RADIO
OFF state until user space devices to turn it on.</li>
<li>Query the device for the state of the hardware rfkill switch
and call <code class="xref c c-func docutils literal"><span class="pre">wimax_rfkill_report_hw()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">wimax_rfkill_report_sw()</span></code>
as needed. See below.</li>
</ol>
</div></blockquote>
<p><a class="reference internal" href="#c.wimax_dev_rm" title="wimax_dev_rm"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_rm()</span></code></a> undoes before unregistering the network device. Once
<a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a> is called, the driver can get called on the
wimax_dev-&gt;op_* function pointers</p>
<p>CONCURRENCY:</p>
<p>The stack provides a mutex for each device that will disallow API
calls happening concurrently; thus, op calls into the driver
through the wimax_dev-&gt;op*() function pointers will always be
serialized and <em>never</em> concurrent.</p>
<p>For locking, take wimax_dev-&gt;mutex is taken; (most) operations in
the API have to check for <code class="xref c c-func docutils literal"><span class="pre">wimax_dev_is_ready()</span></code> to return 0 before
continuing (this is done internally).</p>
<p>REFERENCE COUNTING:</p>
<p>The WiMAX device is reference counted by the associated network
device. The only operation that can be used to reference the device
is <code class="xref c c-func docutils literal"><span class="pre">wimax_dev_get_by_genl_info()</span></code>, and the reference it acquires has
to be released with dev_put(wimax_dev-&gt;net_dev).</p>
<p>RFKILL:</p>
<p>At startup, both HW and SW radio switchess are assumed to be off.</p>
<p>At initialization time [after calling <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a>], have the
driver query the device for the status of the software and hardware
RF kill switches and call <a class="reference internal" href="#c.wimax_report_rfkill_hw" title="wimax_report_rfkill_hw"><code class="xref c c-func docutils literal"><span class="pre">wimax_report_rfkill_hw()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">wimax_rfkill_report_sw()</span></code> to indicate their state. If any is
missing, just call it to indicate it is ON (radio always on).</p>
<p>Whenever the driver detects a change in the state of the RF kill
switches, it should call <a class="reference internal" href="#c.wimax_report_rfkill_hw" title="wimax_report_rfkill_hw"><code class="xref c c-func docutils literal"><span class="pre">wimax_report_rfkill_hw()</span></code></a> or
<a class="reference internal" href="#c.wimax_report_rfkill_sw" title="wimax_report_rfkill_sw"><code class="xref c c-func docutils literal"><span class="pre">wimax_report_rfkill_sw()</span></code></a> to report it to the stack.</p>
<dl class="type">
<dt id="c.wimax_st">
enum <code class="descname">wimax_st</code><a class="headerlink" href="#c.wimax_st" title="Permalink to this definition">¶</a></dt>
<dd><p>The different states of a WiMAX device</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__WIMAX_ST_NULL</span></code></dt>
<dd>The device structure has been allocated and zeroed,
but still <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a> hasn’t been called. There is no state.</dd>
<dt><code class="docutils literal"><span class="pre">WIMAX_ST_DOWN</span></code></dt>
<dd>The device has been registered with the WiMAX and
networking stacks, but it is not initialized (normally that is
done with ‘ifconfig DEV up’ [or equivalent], which can upload
firmware and enable communications with the device).
In this state, the device is powered down and using as less
power as possible.
This state is the default after a call to <a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a>. It
is ok to have drivers move directly to <code class="docutils literal"><span class="pre">WIMAX_ST_UNINITIALIZED</span></code>
or <code class="docutils literal"><span class="pre">WIMAX_ST_RADIO_OFF</span></code> in <code class="xref c c-func docutils literal"><span class="pre">_probe()</span></code> after the call to
<a class="reference internal" href="#c.wimax_dev_add" title="wimax_dev_add"><code class="xref c c-func docutils literal"><span class="pre">wimax_dev_add()</span></code></a>.
It is recommended that the driver leaves this state when
calling ‘ifconfig DEV up’ and enters it back on ‘ifconfig DEV
down’.</dd>
<dt><code class="docutils literal"><span class="pre">__WIMAX_ST_QUIESCING</span></code></dt>
<dd>The device is being torn down, so no API
operations are allowed to proceed except the ones needed to
complete the device clean up process.</dd>
<dt><code class="docutils literal"><span class="pre">WIMAX_ST_UNINITIALIZED</span></code></dt>
<dd>[optional] Communication with the device
is setup, but the device still requires some configuration
before being operational.
Some WiMAX API calls might work.</dd>
<dt><code class="docutils literal"><span class="pre">WIMAX_ST_RADIO_OFF</span></code></dt>
<dd>The device is fully up; radio is off (wether
by hardware or software switches).
It is recommended to always leave the device in this state
after initialization.</dd>
<dt><code class="docutils literal"><span class="pre">WIMAX_ST_READY</span></code></dt>
<dd>The device is fully up and radio is on.</dd>
<dt><code class="docutils literal"><span class="pre">WIMAX_ST_SCANNING</span></code></dt>
<dd>[optional] The device has been instructed to
scan. In this state, the device cannot be actively connected to
a network.</dd>
<dt><code class="docutils literal"><span class="pre">WIMAX_ST_CONNECTING</span></code></dt>
<dd>The device is connecting to a network. This
state exists because in some devices, the connect process can
include a number of negotiations between user space, kernel
space and the device. User space needs to know what the device
is doing. If the connect sequence in a device is atomic and
fast, the device can transition directly to CONNECTED</dd>
<dt><code class="docutils literal"><span class="pre">WIMAX_ST_CONNECTED</span></code></dt>
<dd>The device is connected to a network.</dd>
<dt><code class="docutils literal"><span class="pre">__WIMAX_ST_INVALID</span></code></dt>
<dd>This is an invalid state used to mark the
maximum numeric value of states.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Transitions from one state to another one are atomic and can only
be caused in kernel space with <a class="reference internal" href="#c.wimax_state_change" title="wimax_state_change"><code class="xref c c-func docutils literal"><span class="pre">wimax_state_change()</span></code></a>. To read the
state, use <a class="reference internal" href="#c.wimax_state_get" title="wimax_state_get"><code class="xref c c-func docutils literal"><span class="pre">wimax_state_get()</span></code></a>.</p>
<p>States starting with __ are internal and shall not be used or
referred to by drivers or userspace. They look ugly, but that’s the
point – if any use is made non-internal to the stack, it is easier
to catch on review.</p>
<p>All API operations [with well defined exceptions] will take the
device mutex before starting and then check the state. If the state
is <code class="docutils literal"><span class="pre">__WIMAX_ST_NULL</span></code>, <code class="docutils literal"><span class="pre">WIMAX_ST_DOWN</span></code>, <code class="docutils literal"><span class="pre">WIMAX_ST_UNINITIALIZED</span></code> or
<code class="docutils literal"><span class="pre">__WIMAX_ST_QUIESCING</span></code>, it will drop the lock and quit with
-<code class="docutils literal"><span class="pre">EINVAL</span></code>, -<code class="docutils literal"><span class="pre">ENOMEDIUM</span></code>, -<code class="docutils literal"><span class="pre">ENOTCONN</span></code> or -<code class="docutils literal"><span class="pre">ESHUTDOWN</span></code>.</p>
<p>The order of the definitions is important, so we can do numerical
comparisons (eg: &lt; <code class="docutils literal"><span class="pre">WIMAX_ST_RADIO_OFF</span></code> means the device is not ready
to operate).</p>
</div>
</div>
<div class="section" id="network-device-support">
<h2>Network device support<a class="headerlink" href="#network-device-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="driver-support">
<h3>Driver Support<a class="headerlink" href="#driver-support" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.dev_add_pack">
void <code class="descname">dev_add_pack</code><span class="sig-paren">(</span>struct packet_type *<em>&nbsp;pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_add_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>add packet handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*</span> <span class="pre">pt</span></code></dt>
<dd>packet type declaration</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add a protocol handler to the networking stack. The passed <code class="xref c c-type docutils literal"><span class="pre">packet_type</span></code>
is linked into kernel lists and may not be freed until it has been
removed from the kernel lists.</p>
<p>This call does not sleep therefore it can not
guarantee all CPU’s that are in middle of receiving packets
will see the new packet type (until the next received packet).</p>
</div></blockquote>
<dl class="function">
<dt id="c.__dev_remove_pack">
void <code class="descname">__dev_remove_pack</code><span class="sig-paren">(</span>struct packet_type *<em>&nbsp;pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_remove_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>remove packet handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*</span> <span class="pre">pt</span></code></dt>
<dd>packet type declaration</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><blockquote>
<div>Remove a protocol handler that was previously added to the kernel
protocol handlers by <a class="reference internal" href="#c.dev_add_pack" title="dev_add_pack"><code class="xref c c-func docutils literal"><span class="pre">dev_add_pack()</span></code></a>. The passed <code class="xref c c-type docutils literal"><span class="pre">packet_type</span></code> is removed
from the kernel lists and can be freed or reused once this function
returns.</div></blockquote>
<dl class="docutils">
<dt>The packet type might still be in use by receivers</dt>
<dd>and must not be freed until after all the CPU’s have gone
through a quiescent state.</dd>
</dl>
</div></blockquote>
<dl class="function">
<dt id="c.dev_remove_pack">
void <code class="descname">dev_remove_pack</code><span class="sig-paren">(</span>struct packet_type *<em>&nbsp;pt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_remove_pack" title="Permalink to this definition">¶</a></dt>
<dd><p>remove packet handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">packet_type</span> <span class="pre">*</span> <span class="pre">pt</span></code></dt>
<dd>packet type declaration</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a protocol handler that was previously added to the kernel
protocol handlers by <a class="reference internal" href="#c.dev_add_pack" title="dev_add_pack"><code class="xref c c-func docutils literal"><span class="pre">dev_add_pack()</span></code></a>. The passed <code class="xref c c-type docutils literal"><span class="pre">packet_type</span></code> is removed
from the kernel lists and can be freed or reused once this function
returns.</p>
<p>This call sleeps to guarantee that no CPU is looking at the packet
type after return.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_add_offload">
void <code class="descname">dev_add_offload</code><span class="sig-paren">(</span>struct packet_offload *<em>&nbsp;po</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_add_offload" title="Permalink to this definition">¶</a></dt>
<dd><p>register offload handlers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">packet_offload</span> <span class="pre">*</span> <span class="pre">po</span></code></dt>
<dd>protocol offload declaration</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Add protocol offload handlers to the networking stack. The passed
<code class="xref c c-type docutils literal"><span class="pre">proto_offload</span></code> is linked into kernel lists and may not be freed until
it has been removed from the kernel lists.</p>
<p>This call does not sleep therefore it can not
guarantee all CPU’s that are in middle of receiving packets
will see the new offload handlers (until the next received packet).</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_remove_offload">
void <code class="descname">dev_remove_offload</code><span class="sig-paren">(</span>struct packet_offload *<em>&nbsp;po</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_remove_offload" title="Permalink to this definition">¶</a></dt>
<dd><p>remove packet offload handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">packet_offload</span> <span class="pre">*</span> <span class="pre">po</span></code></dt>
<dd>packet offload declaration</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a packet offload handler that was previously added to the kernel
offload handlers by <a class="reference internal" href="#c.dev_add_offload" title="dev_add_offload"><code class="xref c c-func docutils literal"><span class="pre">dev_add_offload()</span></code></a>. The passed <code class="xref c c-type docutils literal"><span class="pre">offload_type</span></code> is
removed from the kernel lists and can be freed or reused once this
function returns.</p>
<p>This call sleeps to guarantee that no CPU is looking at the packet
type after return.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_boot_setup_check">
int <code class="descname">netdev_boot_setup_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_boot_setup_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check boot time settings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the netdevice</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check boot time settings for the device.
The found settings are set for the device to be used
later in the device probing.
Returns 0 if no settings found, 1 if they are.</p>
<dl class="function">
<dt id="c.dev_get_iflink">
int <code class="descname">dev_get_iflink</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_iflink" title="Permalink to this definition">¶</a></dt>
<dd><p>get ‘iflink’ value of a interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>targeted interface</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Indicates the ifindex the interface is linked to.
Physical interfaces have the same ‘ifindex’ and ‘iflink’ values.</div></blockquote>
<dl class="function">
<dt id="c.dev_fill_metadata_dst">
int <code class="descname">dev_fill_metadata_dst</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_fill_metadata_dst" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve tunnel egress information.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>targeted interface</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The packet.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For better visibility of tunnel traffic OVS needs to retrieve
egress tunnel information for a packet. Following API allows
user to get this info.</div></blockquote>
<dl class="function">
<dt id="c.__dev_get_by_name">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">__dev_get_by_name</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name to find</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Find an interface by name. Must be called under RTNL semaphore
or <strong>dev_base_lock</strong>. If the name is found a pointer to the device
is returned. If the name is not found then <code class="docutils literal"><span class="pre">NULL</span></code> is returned. The
reference counters are not incremented so the caller must be
careful with locks.</div></blockquote>
<dl class="function">
<dt id="c.dev_get_by_name_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">dev_get_by_name_rcu</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_name_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find an interface by name.
If the name is found a pointer to the device is returned.
If the name is not found then <code class="docutils literal"><span class="pre">NULL</span></code> is returned.
The reference counters are not incremented so the caller must be
careful with locks. The caller must hold RCU lock.</p>
<dl class="function">
<dt id="c.dev_get_by_name">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">dev_get_by_name</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name to find</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Find an interface by name. This can be called from any
context and does its own locking. The returned handle has
the usage count incremented and the caller must use <a class="reference internal" href="#c.dev_put" title="dev_put"><code class="xref c c-func docutils literal"><span class="pre">dev_put()</span></code></a> to
release it when it is no longer needed. <code class="docutils literal"><span class="pre">NULL</span></code> is returned if no
matching device is found.</div></blockquote>
<dl class="function">
<dt id="c.__dev_get_by_index">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">__dev_get_by_index</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, int<em>&nbsp;ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt>
<dd>index of device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Search for an interface by index. Returns <code class="docutils literal"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold either the RTNL semaphore
or <strong>dev_base_lock</strong>.</div></blockquote>
<dl class="function">
<dt id="c.dev_get_by_index_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">dev_get_by_index_rcu</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, int<em>&nbsp;ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_index_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt>
<dd>index of device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Search for an interface by index. Returns <code class="docutils literal"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not
had its reference counter increased so the caller must be careful
about locking. The caller must hold RCU lock.</div></blockquote>
<dl class="function">
<dt id="c.dev_get_by_index">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">dev_get_by_index</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, int<em>&nbsp;ifindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its ifindex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ifindex</span></code></dt>
<dd>index of device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Search for an interface by index. Returns NULL if the device
is not found or a pointer to the device. The device returned has
had a reference added and the pointer is safe until the user calls
dev_put to indicate they have finished with it.</div></blockquote>
<dl class="function">
<dt id="c.dev_get_by_napi_id">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">dev_get_by_napi_id</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;napi_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_by_napi_id" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by napi_id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">napi_id</span></code></dt>
<dd>ID of the NAPI struct</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Search for an interface by NAPI ID. Returns <code class="docutils literal"><span class="pre">NULL</span></code> if the device
is not found or a pointer to the device. The device has not had
its reference counter increased so the caller must be careful
about locking. The caller must hold RCU lock.</div></blockquote>
<dl class="function">
<dt id="c.dev_getbyhwaddr_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">dev_getbyhwaddr_rcu</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, unsigned short<em>&nbsp;type</em>, const char *<em>&nbsp;ha</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_getbyhwaddr_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>find a device by its hardware address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">type</span></code></dt>
<dd>media type of device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ha</span></code></dt>
<dd>hardware address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Search for an interface by MAC address. Returns NULL if the device
is not found or a pointer to the device.
The caller must hold RCU or RTNL.
The returned device has not had its ref count increased
and the caller must therefore be careful about locking</div></blockquote>
<dl class="function">
<dt id="c.__dev_get_by_flags">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">__dev_get_by_flags</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, unsigned short<em>&nbsp;if_flags</em>, unsigned short<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_get_by_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>find any device with given flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>the applicable net namespace</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">if_flags</span></code></dt>
<dd>IFF_* values</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">mask</span></code></dt>
<dd>bitmask of bits in if_flags to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Search for any interface with the given flags. Returns NULL if a device
is not found or a pointer to the device. Must be called inside
<code class="xref c c-func docutils literal"><span class="pre">rtnl_lock()</span></code>, and result refcount is unchanged.</div></blockquote>
<dl class="function">
<dt id="c.dev_valid_name">
bool <code class="descname">dev_valid_name</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_valid_name" title="Permalink to this definition">¶</a></dt>
<dd><p>check if name is okay for network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name string</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Network device names need to be valid file names to
to allow sysfs to work.  We also disallow any kind of
whitespace.</div></blockquote>
<dl class="function">
<dt id="c.dev_alloc_name">
int <code class="descname">dev_alloc_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_alloc_name" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a name for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name format string</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Passed a format string - eg “lt``d``” it will try and find a suitable
id. It scans list of devices to build up a free map, then chooses
the first empty slot. The caller must hold the dev_base or rtnl lock
while allocating the name and adding the device in order to avoid
duplicates.
Limited to bits_per_byte * page size devices (ie 32K on most platforms).
Returns the number of the unit assigned or a negative errno code.</div></blockquote>
<dl class="function">
<dt id="c.netdev_features_change">
void <code class="descname">netdev_features_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_features_change" title="Permalink to this definition">¶</a></dt>
<dd><p>device changes features</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to cause notification</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Called to indicate a device has changed features.</div></blockquote>
<dl class="function">
<dt id="c.netdev_state_change">
void <code class="descname">netdev_state_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_state_change" title="Permalink to this definition">¶</a></dt>
<dd><p>device changes state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to cause notification</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Called to indicate a device has changed state. This function calls
the notifier chains for netdev_chain and sends a NEWLINK message
to the routing socket.</div></blockquote>
<dl class="function">
<dt id="c.netdev_notify_peers">
void <code class="descname">netdev_notify_peers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_notify_peers" title="Permalink to this definition">¶</a></dt>
<dd><p>notify network peers about existence of <strong>dev</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate traffic such that interested network peers are aware of
<strong>dev</strong>, such as by generating a gratuitous ARP. This may be used when
a device wants to inform the rest of the network about some sort of
reconfiguration such as a failover event or virtual machine
migration.</p>
<dl class="function">
<dt id="c.dev_open">
int <code class="descname">dev_open</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_open" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare an interface for use.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to open</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Takes a device from down to up state. The device’s private open
function is invoked and then the multicast lists are loaded. Finally
the device is moved into the up state and a <code class="docutils literal"><span class="pre">NETDEV_UP</span></code> message is
sent to the netdev notifier chain.</p>
<p>Calling this function on an active interface is a nop. On a failure
a negative errno code is returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_close">
void <code class="descname">dev_close</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_close" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown an interface.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to shutdown</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function moves an active device into down state. A
<code class="docutils literal"><span class="pre">NETDEV_GOING_DOWN</span></code> is sent to the netdev notifier chain. The device
is then deactivated and finally a <code class="docutils literal"><span class="pre">NETDEV_DOWN</span></code> is sent to the notifier
chain.</div></blockquote>
<dl class="function">
<dt id="c.dev_disable_lro">
void <code class="descname">dev_disable_lro</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_disable_lro" title="Permalink to this definition">¶</a></dt>
<dd><p>disable Large Receive Offload on a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Disable Large Receive Offload (LRO) on a net device.  Must be
called under RTNL.  This is needed if received packets may be
forwarded to another interface.</div></blockquote>
<dl class="function">
<dt id="c.register_netdevice_notifier">
int <code class="descname">register_netdevice_notifier</code><span class="sig-paren">(</span>struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdevice_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network notifier block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>notifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a notifier to be called when network device events occur.
The notifier passed is linked into the kernel structures and must
not be reused until it has been unregistered. A negative errno code
is returned on a failure.</p>
<p>When registered all registration and up events are replayed
to the new notifier to allow device to have a race free
view of the network device list.</p>
<dl class="function">
<dt id="c.unregister_netdevice_notifier">
int <code class="descname">unregister_netdevice_notifier</code><span class="sig-paren">(</span>struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a network notifier block</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>notifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister a notifier previously registered by
<a class="reference internal" href="#c.register_netdevice_notifier" title="register_netdevice_notifier"><code class="xref c c-func docutils literal"><span class="pre">register_netdevice_notifier()</span></code></a>. The notifier is unlinked into the
kernel structures and may then be reused. A negative errno code
is returned on a failure.</p>
<p>After unregistering unregister and down device events are synthesized
for all devices on the device list to the removed notifier to remove
the need for special case cleanup code.</p>
<dl class="function">
<dt id="c.call_netdevice_notifiers">
int <code class="descname">call_netdevice_notifiers</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;val</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_netdevice_notifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>call all network notifier blocks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">val</span></code></dt>
<dd>value passed unmodified to notifier function</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>net_device pointer passed unmodified to notifier function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Call all network notifier blocks.  Parameters and return value
are as for <code class="xref c c-func docutils literal"><span class="pre">raw_notifier_call_chain()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.dev_forward_skb">
int <code class="descname">dev_forward_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_forward_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>loopback an skb to another netif</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>destination network device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to forward</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>return values:</dt>
<dd>NET_RX_SUCCESS  (no congestion)
NET_RX_DROP     (packet was dropped, but freed)</dd>
</dl>
<p>dev_forward_skb can be used for injecting an skb from the
start_xmit function of one device into the receive queue
of another device.</p>
<p>The receiving device may be in another namespace, so
we have to clear all information in the skb that could
impact namespace isolation.</p>
<dl class="function">
<dt id="c.netif_set_real_num_rx_queues">
int <code class="descname">netif_set_real_num_rx_queues</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;rxq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_set_real_num_rx_queues" title="Permalink to this definition">¶</a></dt>
<dd><p>set actual number of RX queues used</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Network device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxq</span></code></dt>
<dd>Actual number of RX queues</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This must be called either with the rtnl_lock held or before
registration of the net device.  Returns 0 on success, or a
negative error code.  If called before registration, it always
succeeds.</div></blockquote>
<dl class="function">
<dt id="c.netif_get_num_default_rss_queues">
int <code class="descname">netif_get_num_default_rss_queues</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.netif_get_num_default_rss_queues" title="Permalink to this definition">¶</a></dt>
<dd><p>default number of RSS queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine should set an upper limit on the number of RSS queues
used by default by multiqueue devices.</p>
<dl class="function">
<dt id="c.netif_device_detach">
void <code class="descname">netif_device_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as removed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as removed from system and therefore no longer available.</p>
<dl class="function">
<dt id="c.netif_device_attach">
void <code class="descname">netif_device_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as attached</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as attached from system and restart if needed.</p>
<dl class="function">
<dt id="c.skb_mac_gso_segment">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">skb_mac_gso_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, netdev_features_t<em>&nbsp;features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skb_mac_gso_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>mac layer segmentation handler.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to segment</dd>
<dt><code class="docutils literal"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt>
<dd>features for the output path (see dev-&gt;features)</dd>
</dl>
<dl class="function">
<dt id="c.__skb_gso_segment">
struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> * <code class="descname">__skb_gso_segment</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, netdev_features_t<em>&nbsp;features</em>, bool<em>&nbsp;tx_path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__skb_gso_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform segmentation on skb.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to segment</dd>
<dt><code class="docutils literal"><span class="pre">netdev_features_t</span> <span class="pre">features</span></code></dt>
<dd>features for the output path (see dev-&gt;features)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">tx_path</span></code></dt>
<dd>whether it is called in TX path</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function segments the given skb and returns a list of segments.</p>
<p>It may return NULL if the skb requires no segmentation.  This is
only possible when GSO is used for verifying header integrity.</p>
<p>Segmentation preserves SKB_SGO_CB_OFFSET bytes of previous skb cb.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_loopback_xmit">
int <code class="descname">dev_loopback_xmit</code><span class="sig-paren">(</span>struct net *<em>&nbsp;net</em>, struct <a class="reference internal" href="#c.sock" title="sock">sock</a> *<em>&nbsp;sk</em>, struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_loopback_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>loop back <strong>skb</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>network namespace this loopback is happening in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span> <span class="pre">*</span> <span class="pre">sk</span></code></dt>
<dd>sk needed to be a netfilter okfn</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to transmit</dd>
</dl>
<dl class="function">
<dt id="c.rps_may_expire_flow">
bool <code class="descname">rps_may_expire_flow</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, u16<em>&nbsp;rxq_index</em>, u32<em>&nbsp;flow_id</em>, u16<em>&nbsp;filter_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rps_may_expire_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether an RFS hardware filter may be removed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device on which the filter was set</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">rxq_index</span></code></dt>
<dd>RX queue index</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flow_id</span></code></dt>
<dd>Flow ID passed to <code class="xref c c-func docutils literal"><span class="pre">ndo_rx_flow_steer()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">filter_id</span></code></dt>
<dd>Filter ID returned by <code class="xref c c-func docutils literal"><span class="pre">ndo_rx_flow_steer()</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers that implement <code class="xref c c-func docutils literal"><span class="pre">ndo_rx_flow_steer()</span></code> should periodically call
this function for each installed filter and remove the filters for
which it returns <code class="docutils literal"><span class="pre">true</span></code>.</p>
<dl class="function">
<dt id="c.netif_rx">
int <code class="descname">netif_rx</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>post buffer to the network code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to post</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function receives a packet from a device driver and queues it for
the upper (protocol) levels to process.  It always succeeds. The buffer
may be dropped during processing for congestion control or by the
protocol layers.</p>
<p>return values:
NET_RX_SUCCESS  (no congestion)
NET_RX_DROP     (packet was dropped)</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_is_rx_handler_busy">
bool <code class="descname">netdev_is_rx_handler_busy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_is_rx_handler_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>check if receive handler is registered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check if a receive handler is already registered for a given device.
Return true if there one.</p>
<p>The caller must hold the rtnl_mutex.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_rx_handler_register">
int <code class="descname">netdev_rx_handler_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, rx_handler_func_t *<em>&nbsp;rx_handler</em>, void *<em>&nbsp;rx_handler_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_rx_handler_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register receive handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to register a handler for</dd>
<dt><code class="docutils literal"><span class="pre">rx_handler_func_t</span> <span class="pre">*</span> <span class="pre">rx_handler</span></code></dt>
<dd>receive handler to register</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">rx_handler_data</span></code></dt>
<dd>data pointer that is used by rx handler</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Register a receive handler for a device. This handler will then be
called from __netif_receive_skb. A negative errno code is returned
on a failure.</p>
<p>The caller must hold the rtnl_mutex.</p>
<p>For a general description of rx_handler, see enum rx_handler_result.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_rx_handler_unregister">
void <code class="descname">netdev_rx_handler_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_rx_handler_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister receive handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to unregister a handler from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Unregister a receive handler from a device.</p>
<p>The caller must hold the rtnl_mutex.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netif_receive_skb">
int <code class="descname">netif_receive_skb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_receive_skb" title="Permalink to this definition">¶</a></dt>
<dd><p>process receive buffer from network</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to process</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><a class="reference internal" href="#c.netif_receive_skb" title="netif_receive_skb"><code class="xref c c-func docutils literal"><span class="pre">netif_receive_skb()</span></code></a> is the main receive data processing function.
It always succeeds. The buffer may be dropped during processing
for congestion control or by the protocol layers.</p>
<p>This function may only be called from softirq context and interrupts
should be enabled.</p>
<p>Return values (usually ignored):
NET_RX_SUCCESS: no congestion
NET_RX_DROP: packet was dropped</p>
</div></blockquote>
<dl class="function">
<dt id="c.__napi_schedule">
void <code class="descname">__napi_schedule</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule for receive</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>entry to schedule</dd>
</dl>
<p><strong>Description</strong></p>
<p>The entry’s receive function will be scheduled to run.
Consider using <a class="reference internal" href="#c.__napi_schedule_irqoff" title="__napi_schedule_irqoff"><code class="xref c c-func docutils literal"><span class="pre">__napi_schedule_irqoff()</span></code></a> if hard irqs are masked.</p>
<dl class="function">
<dt id="c.napi_schedule_prep">
bool <code class="descname">napi_schedule_prep</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule_prep" title="Permalink to this definition">¶</a></dt>
<dd><p>check if napi can be scheduled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>napi context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if NAPI routine is already running, and if not mark
it as running.  This is used as a condition variable
insure only one NAPI poll instance runs.  We also make
sure there is no pending NAPI disable.</p>
<dl class="function">
<dt id="c.__napi_schedule_irqoff">
void <code class="descname">__napi_schedule_irqoff</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__napi_schedule_irqoff" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule for receive</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>entry to schedule</dd>
</dl>
<p><strong>Description</strong></p>
<p>Variant of <a class="reference internal" href="#c.__napi_schedule" title="__napi_schedule"><code class="xref c c-func docutils literal"><span class="pre">__napi_schedule()</span></code></a> assuming hard irqs are masked</p>
<dl class="function">
<dt id="c.netdev_has_upper_dev">
bool <code class="descname">netdev_has_upper_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_upper_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to an upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt>
<dd>upper device to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to specified upper device and return true
in case it is. Note that this checks only immediate upper device,
not through a complete stack of devices. The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_has_upper_dev_all_rcu">
bool <code class="descname">netdev_has_upper_dev_all_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_upper_dev_all_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to an upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt>
<dd>upper device to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to specified upper device and return true
in case it is. Note that this checks the entire upper device chain.
The caller must hold rcu lock.</p>
<dl class="function">
<dt id="c.netdev_has_any_upper_dev">
bool <code class="descname">netdev_has_any_upper_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_has_any_upper_dev" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if device is linked to some device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out if a device is linked to an upper device and return true in case
it is. The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_master_upper_dev_get">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">netdev_master_upper_dev_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get master upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a master upper device and return pointer to it or NULL in case
it’s not there. The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_upper_get_next_dev_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">netdev_upper_get_next_dev_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct list_head **<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_get_next_dev_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next dev from upper list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**</span> <span class="pre">iter</span></code></dt>
<dd>list_head ** of the current position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next device from the dev’s upper list, starting from iter
position. The caller must hold RCU read lock.</p>
<dl class="function">
<dt id="c.netdev_lower_get_next_private">
void * <code class="descname">netdev_lower_get_next_private</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct list_head **<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next_private" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next -&gt;private from the lower neighbour list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**</span> <span class="pre">iter</span></code></dt>
<dd>list_head ** of the current position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent-&gt;private from the dev’s lower neighbour
list, starting from iter position. The caller must hold either hold the
RTNL lock or its own locking that guarantees that the neighbour lower
list will remain unchanged.</p>
<dl class="function">
<dt id="c.netdev_lower_get_next_private_rcu">
void * <code class="descname">netdev_lower_get_next_private_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct list_head **<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next_private_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next -&gt;private from the lower neighbour list, RCU variant</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**</span> <span class="pre">iter</span></code></dt>
<dd>list_head ** of the current position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent-&gt;private from the dev’s lower neighbour
list, starting from iter position. The caller must hold RCU read lock.</p>
<dl class="function">
<dt id="c.netdev_lower_get_next">
void * <code class="descname">netdev_lower_get_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct list_head **<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next device from the lower neighbour list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">**</span> <span class="pre">iter</span></code></dt>
<dd>list_head ** of the current position</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the next netdev_adjacent from the dev’s lower neighbour
list, starting from iter position. The caller must hold RTNL lock or
its own locking that guarantees that the neighbour lower
list will remain unchanged.</p>
<dl class="function">
<dt id="c.netdev_lower_get_first_private_rcu">
void * <code class="descname">netdev_lower_get_first_private_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_get_first_private_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first -&gt;private from the lower neighbour list, RCU variant</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets the first netdev_adjacent-&gt;private from the dev’s lower neighbour
list. The caller must hold RCU read lock.</p>
<dl class="function">
<dt id="c.netdev_master_upper_dev_get_rcu">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">netdev_master_upper_dev_get_rcu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_get_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Get master upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a master upper device and return pointer to it or NULL in case
it’s not there. The caller must hold the RCU read lock.</p>
<dl class="function">
<dt id="c.netdev_upper_dev_link">
int <code class="descname">netdev_upper_dev_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_dev_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a link to the upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt>
<dd>new upper device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a link to device which is upper to this one. The caller must hold
the RTNL lock. On a failure a negative errno code is returned.
On success the reference counts are adjusted and the function
returns zero.</p>
<dl class="function">
<dt id="c.netdev_master_upper_dev_link">
int <code class="descname">netdev_master_upper_dev_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;upper_dev</em>, void *<em>&nbsp;upper_priv</em>, void *<em>&nbsp;upper_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_master_upper_dev_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a master link to the upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt>
<dd>new upper device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">upper_priv</span></code></dt>
<dd>upper device private</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">upper_info</span></code></dt>
<dd>upper info to be passed down via notifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a link to device which is upper to this one. In this case, only
one master upper device can be linked, although other non-master devices
might be linked as well. The caller must hold the RTNL lock.
On a failure a negative errno code is returned. On success the reference
counts are adjusted and the function returns zero.</p>
<dl class="function">
<dt id="c.netdev_upper_dev_unlink">
void <code class="descname">netdev_upper_dev_unlink</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;upper_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_upper_dev_unlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a link to upper device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">upper_dev</span></code></dt>
<dd>new upper device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a link to device which is upper to this one. The caller must hold
the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_bonding_info_change">
void <code class="descname">netdev_bonding_info_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct netdev_bonding_info *<em>&nbsp;bonding_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_bonding_info_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch event about slave change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">netdev_bonding_info</span> <span class="pre">*</span> <span class="pre">bonding_info</span></code></dt>
<dd>info to dispatch</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send NETDEV_BONDING_INFO to netdev notifiers with info.
The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.netdev_lower_state_changed">
void <code class="descname">netdev_lower_state_changed</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;lower_dev</em>, void *<em>&nbsp;lower_state_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_lower_state_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Dispatch event about lower device state change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">lower_dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">lower_state_info</span></code></dt>
<dd>state to dispatch</dd>
</dl>
<p><strong>Description</strong></p>
<p>Send NETDEV_CHANGELOWERSTATE to netdev notifiers with info.
The caller must hold the RTNL lock.</p>
<dl class="function">
<dt id="c.dev_set_promiscuity">
int <code class="descname">dev_set_promiscuity</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;inc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_promiscuity" title="Permalink to this definition">¶</a></dt>
<dd><p>update promiscuity count on a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">inc</span></code></dt>
<dd>modifier</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Add or remove promiscuity from a device. While the count in the device
remains above zero the interface remains promiscuous. Once it hits zero
the device reverts back to normal filtering operation. A negative inc
value is used to drop promiscuity on the device.
Return 0 if successful or a negative errno code on error.</div></blockquote>
<dl class="function">
<dt id="c.dev_set_allmulti">
int <code class="descname">dev_set_allmulti</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;inc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_allmulti" title="Permalink to this definition">¶</a></dt>
<dd><p>update allmulti count on a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">inc</span></code></dt>
<dd>modifier</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Add or remove reception of all multicast frames to a device. While the
count in the device remains above zero the interface remains listening
to all interfaces. Once it hits zero the device reverts back to normal
filtering operation. A negative <strong>inc</strong> value is used to drop the counter
when releasing a resource needing all multicasts.
Return 0 if successful or a negative errno code on error.</div></blockquote>
<dl class="function">
<dt id="c.dev_get_flags">
unsigned int <code class="descname">dev_get_flags</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get flags reported to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Get the combination of flag bits exported through APIs to userspace.</div></blockquote>
<dl class="function">
<dt id="c.dev_change_flags">
int <code class="descname">dev_change_flags</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>change device settings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>device state flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Change settings on device based state flags. The flags are
in the userspace exported format.</div></blockquote>
<dl class="function">
<dt id="c.dev_set_mtu">
int <code class="descname">dev_set_mtu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;new_mtu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_mtu" title="Permalink to this definition">¶</a></dt>
<dd><p>Change maximum transfer unit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_mtu</span></code></dt>
<dd>new transfer unit</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Change the maximum transfer size of the network device.</div></blockquote>
<dl class="function">
<dt id="c.dev_set_group">
void <code class="descname">dev_set_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;new_group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Change group this device belongs to</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_group</span></code></dt>
<dd>group this device should belong to</dd>
</dl>
<dl class="function">
<dt id="c.dev_set_mac_address">
int <code class="descname">dev_set_mac_address</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct sockaddr *<em>&nbsp;sa</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_mac_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Change Media Access Control Address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr</span> <span class="pre">*</span> <span class="pre">sa</span></code></dt>
<dd>new address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Change the hardware (MAC) address of the device</div></blockquote>
<dl class="function">
<dt id="c.dev_change_carrier">
int <code class="descname">dev_change_carrier</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, bool<em>&nbsp;new_carrier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_carrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Change device carrier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">new_carrier</span></code></dt>
<dd>new value</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Change device carrier</div></blockquote>
<dl class="function">
<dt id="c.dev_get_phys_port_id">
int <code class="descname">dev_get_phys_port_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct netdev_phys_item_id *<em>&nbsp;ppid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_phys_port_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device physical port ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">netdev_phys_item_id</span> <span class="pre">*</span> <span class="pre">ppid</span></code></dt>
<dd>port ID</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Get device physical port ID</div></blockquote>
<dl class="function">
<dt id="c.dev_get_phys_port_name">
int <code class="descname">dev_get_phys_port_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, char *<em>&nbsp;name</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_phys_port_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get device physical port name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>port name</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>limit of bytes to copy to name</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Get device physical port name</div></blockquote>
<dl class="function">
<dt id="c.dev_change_proto_down">
int <code class="descname">dev_change_proto_down</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, bool<em>&nbsp;proto_down</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_proto_down" title="Permalink to this definition">¶</a></dt>
<dd><p>update protocol port state information</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">proto_down</span></code></dt>
<dd>new value</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This info can be used by switch drivers to set the phys state of the
port.</div></blockquote>
<dl class="function">
<dt id="c.netdev_update_features">
void <code class="descname">netdev_update_features</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_update_features" title="Permalink to this definition">¶</a></dt>
<dd><p>recalculate device features</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Recalculate dev-&gt;features set and send notifications if it
has changed. Should be called after driver or hardware dependent
conditions might have changed that influence the features.</div></blockquote>
<dl class="function">
<dt id="c.netdev_change_features">
void <code class="descname">netdev_change_features</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_change_features" title="Permalink to this definition">¶</a></dt>
<dd><p>recalculate device features</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Recalculate dev-&gt;features set and send notifications even
if they have not changed. Should be called instead of
<a class="reference internal" href="#c.netdev_update_features" title="netdev_update_features"><code class="xref c c-func docutils literal"><span class="pre">netdev_update_features()</span></code></a> if also dev-&gt;vlan_features might
have changed to allow the changes to be propagated to stacked
VLAN devices.</div></blockquote>
<dl class="function">
<dt id="c.netif_stacked_transfer_operstate">
void <code class="descname">netif_stacked_transfer_operstate</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;rootdev</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stacked_transfer_operstate" title="Permalink to this definition">¶</a></dt>
<dd><p>transfer operstate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">rootdev</span></code></dt>
<dd>the root or lower level device to transfer state from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device to transfer operstate to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Transfer operational state from root to device. This is normally
called when a stacking relationship exists between the root
device and the device(a leaf device).</div></blockquote>
<dl class="function">
<dt id="c.register_netdevice">
int <code class="descname">register_netdevice</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdevice" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to register</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Take a completed network device structure and add it to the kernel
interfaces. A <code class="docutils literal"><span class="pre">NETDEV_REGISTER</span></code> message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.</p>
<p>Callers must hold the rtnl semaphore. You may want
<a class="reference internal" href="#c.register_netdev" title="register_netdev"><code class="xref c c-func docutils literal"><span class="pre">register_netdev()</span></code></a> instead of this.</p>
<p>BUGS:
The locking appears insufficient to guarantee two parallel registers
will not get the same name.</p>
</div></blockquote>
<dl class="function">
<dt id="c.init_dummy_netdev">
int <code class="descname">init_dummy_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_dummy_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>init a dummy network device for NAPI</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to init</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This takes a network device structure and initialize the minimum
amount of fields so it can be used to schedule NAPI polls without
registering a full blown interface. This is to be used by drivers
that need to tie several hardware interfaces to a single NAPI
poll scheduler due to HW limitations.</div></blockquote>
<dl class="function">
<dt id="c.register_netdev">
int <code class="descname">register_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>register a network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to register</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Take a completed network device structure and add it to the kernel
interfaces. A <code class="docutils literal"><span class="pre">NETDEV_REGISTER</span></code> message is sent to the netdev notifier
chain. 0 is returned on success. A negative errno code is returned
on a failure to set up the device, or if the name is a duplicate.</p>
<p>This is a wrapper around register_netdevice that takes the rtnl semaphore
and expands the device name if you passed a format string to
alloc_netdev.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_get_stats">
struct rtnl_link_stats64 * <code class="descname">dev_get_stats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct rtnl_link_stats64 *<em>&nbsp;storage</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_get_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>get network device statistics</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to get statistics from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rtnl_link_stats64</span> <span class="pre">*</span> <span class="pre">storage</span></code></dt>
<dd>place to store stats</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Get network statistics from device. Return <strong>storage</strong>.
The device driver may provide its own method by setting
dev-&gt;netdev_ops-&gt;get_stats64 or dev-&gt;netdev_ops-&gt;get_stats;
otherwise the internal statistics structure is used.</div></blockquote>
<dl class="function">
<dt id="c.alloc_netdev_mqs">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">alloc_netdev_mqs</code><span class="sig-paren">(</span>int<em>&nbsp;sizeof_priv</em>, const char *<em>&nbsp;name</em>, unsigned char<em>&nbsp;name_assign_type</em>, void (*setup) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, unsigned int<em>&nbsp;txqs</em>, unsigned int<em>&nbsp;rxqs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_netdev_mqs" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt>
<dd>size of private data to allocate space for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>device name format string</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">name_assign_type</span></code></dt>
<dd>origin of device name</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span> <span class="pre">setup</span></code></dt>
<dd>callback to initialize device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">txqs</span></code></dt>
<dd>the number of TX subqueues to allocate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxqs</span></code></dt>
<dd>the number of RX subqueues to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a struct net_device with private data area for driver use
and performs basic initialization.  Also allocates subqueue structs
for each queue on the device.</p>
<dl class="function">
<dt id="c.free_netdev">
void <code class="descname">free_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>free network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does the last stage of destroying an allocated device
interface. The reference to the device object is released. If this
is the last reference then it will be freed.Must be called in process
context.</p>
<dl class="function">
<dt id="c.synchronize_net">
void <code class="descname">synchronize_net</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_net" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronize with packet receive processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Wait for packets currently being received to be done.
Does not block later packets from starting.</div></blockquote>
<dl class="function">
<dt id="c.unregister_netdevice_queue">
void <code class="descname">unregister_netdevice_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>remove device from the kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function shuts down a device interface and removes it
from the kernel tables.
If head not NULL, device is queued to be unregistered later.</p>
<p>Callers must hold the rtnl semaphore.  You may want
<a class="reference internal" href="#c.unregister_netdev" title="unregister_netdev"><code class="xref c c-func docutils literal"><span class="pre">unregister_netdev()</span></code></a> instead of this.</p>
</div></blockquote>
<dl class="function">
<dt id="c.unregister_netdevice_many">
void <code class="descname">unregister_netdevice_many</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdevice_many" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister many devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list of devices</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>As most callers use a stack allocated list_head,</dt>
<dd>we force a <code class="xref c c-func docutils literal"><span class="pre">list_del()</span></code> to make sure stack wont be corrupted later.</dd>
</dl>
<dl class="function">
<dt id="c.unregister_netdev">
void <code class="descname">unregister_netdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_netdev" title="Permalink to this definition">¶</a></dt>
<dd><p>remove device from the kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function shuts down a device interface and removes it
from the kernel tables.</p>
<p>This is just a wrapper for unregister_netdevice that takes
the rtnl semaphore.  In general you want to use this and not
unregister_netdevice.</p>
</div></blockquote>
<dl class="function">
<dt id="c.dev_change_net_namespace">
int <code class="descname">dev_change_net_namespace</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct net *<em>&nbsp;net</em>, const char *<em>&nbsp;pat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_change_net_namespace" title="Permalink to this definition">¶</a></dt>
<dd><p>move device to different nethost namespace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net</span> <span class="pre">*</span> <span class="pre">net</span></code></dt>
<dd>network namespace</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pat</span></code></dt>
<dd>If not NULL name pattern to try if the current device name
is already taken in the destination network namespace.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function shuts down a device interface and moves it
to a new network namespace. On success 0 is returned, on
a failure a netagive errno code is returned.</p>
<p>Callers must hold the rtnl semaphore.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_increment_features">
netdev_features_t <code class="descname">netdev_increment_features</code><span class="sig-paren">(</span>netdev_features_t<em>&nbsp;all</em>, netdev_features_t<em>&nbsp;one</em>, netdev_features_t<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_increment_features" title="Permalink to this definition">¶</a></dt>
<dd><p>increment feature set by one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">netdev_features_t</span> <span class="pre">all</span></code></dt>
<dd>current feature set</dd>
<dt><code class="docutils literal"><span class="pre">netdev_features_t</span> <span class="pre">one</span></code></dt>
<dd>new feature set</dd>
<dt><code class="docutils literal"><span class="pre">netdev_features_t</span> <span class="pre">mask</span></code></dt>
<dd>mask feature set</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Computes a new feature set after adding a device with feature set
<strong>one</strong> to the master device with current feature set <strong>all</strong>.  Will not
enable anything that is off in <strong>mask</strong>. Returns the new feature set.</div></blockquote>
<dl class="function">
<dt id="c.eth_header">
int <code class="descname">eth_header</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, unsigned short<em>&nbsp;type</em>, const void *<em>&nbsp;daddr</em>, const void *<em>&nbsp;saddr</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header" title="Permalink to this definition">¶</a></dt>
<dd><p>create the Ethernet header</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>buffer to alter</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>source device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">type</span></code></dt>
<dd>Ethernet type field</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">daddr</span></code></dt>
<dd>destination address (NULL leave destination address)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">saddr</span></code></dt>
<dd>source address (NULL use device source address)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>packet length (&lt;= skb-&gt;len)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the protocol type. For a packet of type ETH_P_802_3/2 we put the length
in here instead.</p>
<dl class="function">
<dt id="c.eth_get_headlen">
u32 <code class="descname">eth_get_headlen</code><span class="sig-paren">(</span>void *<em>&nbsp;data</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_get_headlen" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the length of header for an ethernet frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointer to start of frame</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>total length of frame</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make a best effort attempt to pull the length for all of the headers for
a given frame in a linear buffer.</p>
<dl class="function">
<dt id="c.eth_type_trans">
__be16 <code class="descname">eth_type_trans</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_type_trans" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the packet’s protocol ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>received socket data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>receiving network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>The rule here is that we
assume 802.3 if the type field is short enough to be a length.
This is normal practice and works for any ‘now in use’ protocol.</p>
<dl class="function">
<dt id="c.eth_header_parse">
int <code class="descname">eth_header_parse</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em>, unsigned char *<em>&nbsp;haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>extract hardware address from packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>packet to extract header from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">haddr</span></code></dt>
<dd>destination buffer</dd>
</dl>
<dl class="function">
<dt id="c.eth_header_cache">
int <code class="descname">eth_header_cache</code><span class="sig-paren">(</span>const struct neighbour *<em>&nbsp;neigh</em>, struct hh_cache *<em>&nbsp;hh</em>, __be16<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>fill cache entry from neighbour</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">neighbour</span> <span class="pre">*</span> <span class="pre">neigh</span></code></dt>
<dd>source neighbour</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hh_cache</span> <span class="pre">*</span> <span class="pre">hh</span></code></dt>
<dd>destination cache entry</dd>
<dt><code class="docutils literal"><span class="pre">__be16</span> <span class="pre">type</span></code></dt>
<dd>Ethernet type field</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create an Ethernet header template from the neighbour.</p>
<dl class="function">
<dt id="c.eth_header_cache_update">
void <code class="descname">eth_header_cache_update</code><span class="sig-paren">(</span>struct hh_cache *<em>&nbsp;hh</em>, const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, const unsigned char *<em>&nbsp;haddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_header_cache_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update cache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hh_cache</span> <span class="pre">*</span> <span class="pre">hh</span></code></dt>
<dd>destination cache entry</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">haddr</span></code></dt>
<dd>new hardware address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by Address Resolution module to notify changes in address.</p>
<dl class="function">
<dt id="c.eth_prepare_mac_addr_change">
int <code class="descname">eth_prepare_mac_addr_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_prepare_mac_addr_change" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare for mac change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>socket address</dd>
</dl>
<dl class="function">
<dt id="c.eth_commit_mac_addr_change">
void <code class="descname">eth_commit_mac_addr_change</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_commit_mac_addr_change" title="Permalink to this definition">¶</a></dt>
<dd><p>commit mac change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>socket address</dd>
</dl>
<dl class="function">
<dt id="c.eth_mac_addr">
int <code class="descname">eth_mac_addr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_mac_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>set new Ethernet hardware address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>socket address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Change hardware address of device.</p>
<p>This doesn’t change hardware matching, so needs to be overridden
for most real devices.</p>
<dl class="function">
<dt id="c.eth_change_mtu">
int <code class="descname">eth_change_mtu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;new_mtu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_change_mtu" title="Permalink to this definition">¶</a></dt>
<dd><p>set new MTU size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_mtu</span></code></dt>
<dd>new Maximum Transfer Unit</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow changing MTU size. Needs to be overridden for devices
supporting jumbo frames.</p>
<dl class="function">
<dt id="c.ether_setup">
void <code class="descname">ether_setup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>setup Ethernet network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the fields of the device structure with Ethernet-generic values.</p>
<dl class="function">
<dt id="c.alloc_etherdev_mqs">
struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> * <code class="descname">alloc_etherdev_mqs</code><span class="sig-paren">(</span>int<em>&nbsp;sizeof_priv</em>, unsigned int<em>&nbsp;txqs</em>, unsigned int<em>&nbsp;rxqs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_etherdev_mqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates and sets up an Ethernet device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt>
<dd>Size of additional driver-private structure to be allocated
for this Ethernet device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">txqs</span></code></dt>
<dd>The number of TX queues this device has.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rxqs</span></code></dt>
<dd>The number of RX queues this device has.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the fields of the device structure with Ethernet-generic
values. Basically does everything except registering the device.</p>
<p>Constructs a new net device, complete with a private data area of
size (sizeof_priv).  A 32-byte (not bit) alignment is enforced for
this private data area.</p>
<dl class="function">
<dt id="c.netif_carrier_on">
void <code class="descname">netif_carrier_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_on" title="Permalink to this definition">¶</a></dt>
<dd><p>set carrier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device has detected that carrier.</p>
<dl class="function">
<dt id="c.netif_carrier_off">
void <code class="descname">netif_carrier_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_off" title="Permalink to this definition">¶</a></dt>
<dd><p>clear carrier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device has detected loss of carrier.</p>
<dl class="function">
<dt id="c.is_link_local_ether_addr">
bool <code class="descname">is_link_local_ether_addr</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_link_local_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given Ethernet address is link-local</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if address is link local reserved addr (01:80:c2:00:00:0X) per
IEEE 802.1Q 8.6.3 Frame filtering.</p>
<p>Please note: addr must be aligned to u16.</p>
<dl class="function">
<dt id="c.is_zero_ether_addr">
bool <code class="descname">is_zero_ether_addr</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_zero_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if give Ethernet address is all zeros.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is all zeroes.</p>
<p>Please note: addr must be aligned to u16.</p>
<dl class="function">
<dt id="c.is_multicast_ether_addr">
bool <code class="descname">is_multicast_ether_addr</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_multicast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is a multicast.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a multicast address.
By definition the broadcast address is also a multicast address.</p>
<dl class="function">
<dt id="c.is_local_ether_addr">
bool <code class="descname">is_local_ether_addr</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_local_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is locally-assigned one (IEEE 802).</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a local address.</p>
<dl class="function">
<dt id="c.is_broadcast_ether_addr">
bool <code class="descname">is_broadcast_ether_addr</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_broadcast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is broadcast</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is the broadcast address.</p>
<p>Please note: addr must be aligned to u16.</p>
<dl class="function">
<dt id="c.is_unicast_ether_addr">
bool <code class="descname">is_unicast_ether_addr</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_unicast_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the Ethernet address is unicast</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if the address is a unicast address.</p>
<dl class="function">
<dt id="c.is_valid_ether_addr">
bool <code class="descname">is_valid_ether_addr</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_valid_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the given Ethernet address is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
a multicast address, and is not FF:FF:FF:FF:FF:FF.</p>
<p>Return true if the address is valid.</p>
<p>Please note: addr must be aligned to u16.</p>
<dl class="function">
<dt id="c.eth_proto_is_802_3">
bool <code class="descname">eth_proto_is_802_3</code><span class="sig-paren">(</span>__be16<em>&nbsp;proto</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_proto_is_802_3" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a given Ethertype/length is a protocol</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__be16</span> <span class="pre">proto</span></code></dt>
<dd>Ethertype/length value to be tested</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check that the value from the Ethertype/length field is a valid Ethertype.</p>
<p>Return true if the valid is an 802.3 supported Ethertype.</p>
<dl class="function">
<dt id="c.eth_random_addr">
void <code class="descname">eth_random_addr</code><span class="sig-paren">(</span>u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_random_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate software assigned random Ethernet address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a random Ethernet address (MAC) that is not multicast
and has the local assigned bit set.</p>
<dl class="function">
<dt id="c.eth_broadcast_addr">
void <code class="descname">eth_broadcast_addr</code><span class="sig-paren">(</span>u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_broadcast_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign broadcast address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assign the broadcast address to the given address array.</p>
<dl class="function">
<dt id="c.eth_zero_addr">
void <code class="descname">eth_zero_addr</code><span class="sig-paren">(</span>u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_zero_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign zero address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assign the zero address to the given address array.</p>
<dl class="function">
<dt id="c.eth_hw_addr_random">
void <code class="descname">eth_hw_addr_random</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_random" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate software assigned random Ethernet and set device flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to net_device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generate a random Ethernet address (MAC) to be used by a net device
and set addr_assign_type so the state can be read by sysfs and be
used by userspace.</p>
<dl class="function">
<dt id="c.ether_addr_copy">
void <code class="descname">ether_addr_copy</code><span class="sig-paren">(</span>u8 *<em>&nbsp;dst</em>, const u8 *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy an Ethernet address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>Pointer to a six-byte array Ethernet address destination</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Pointer to a six-byte array Ethernet address source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Please note: dst &amp; src must both be aligned to u16.</p>
<dl class="function">
<dt id="c.eth_hw_addr_inherit">
void <code class="descname">eth_hw_addr_inherit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dst</em>, struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_hw_addr_inherit" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy dev_addr from another net_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>pointer to net_device to copy dev_addr to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>pointer to net_device to copy dev_addr from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the Ethernet address from one net_device to another along with
the address attributes (addr_assign_type).</p>
<dl class="function">
<dt id="c.ether_addr_equal">
bool <code class="descname">ether_addr_equal</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr1</em>, const u8 *<em>&nbsp;addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr1</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr2</span></code></dt>
<dd>Pointer other six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal</p>
<p>Please note: addr1 &amp; addr2 must both be aligned to u16.</p>
<dl class="function">
<dt id="c.ether_addr_equal_64bits">
bool <code class="descname">ether_addr_equal_64bits</code><span class="sig-paren">(</span>const u8<em>&nbsp;addr1</em>, const u8<em>&nbsp;addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_64bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">addr1</span></code></dt>
<dd>Pointer to an array of 8 bytes</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">addr2</span></code></dt>
<dd>Pointer to an other array of 8 bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal, false otherwise.</p>
<p>The function doesn’t need any conditional branches and possibly uses
word memory accesses on CPU allowing cheap unaligned memory reads.
arrays = { byte1, byte2, byte3, byte4, byte5, byte6, pad1, pad2 }</p>
<p>Please note that alignment of addr1 &amp; addr2 are only guaranteed to be 16 bits.</p>
<dl class="function">
<dt id="c.ether_addr_equal_unaligned">
bool <code class="descname">ether_addr_equal_unaligned</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr1</em>, const u8 *<em>&nbsp;addr2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_unaligned" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two not u16 aligned Ethernet addresses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr1</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr2</span></code></dt>
<dd>Pointer other six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses, returns true if equal</p>
<p>Please note: Use only when any Ethernet address may not be u16 aligned.</p>
<dl class="function">
<dt id="c.ether_addr_equal_masked">
bool <code class="descname">ether_addr_equal_masked</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr1</em>, const u8 *<em>&nbsp;addr2</em>, const u8 *<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_equal_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet addresses with a mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr1</span></code></dt>
<dd>Pointer to a six-byte array containing the 1st Ethernet address</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr2</span></code></dt>
<dd>Pointer to a six-byte array containing the 2nd Ethernet address</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">mask</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address bitmask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet addresses with a mask, returns true if for every bit
set in the bitmask the equivalent bits in the ethernet addresses are equal.
Using a mask with all bits set is a slower ether_addr_equal.</p>
<dl class="function">
<dt id="c.ether_addr_to_u64">
u64 <code class="descname">ether_addr_to_u64</code><span class="sig-paren">(</span>const u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ether_addr_to_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an Ethernet address into a u64 value.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return a u64 value of the address</p>
<dl class="function">
<dt id="c.u64_to_ether_addr">
void <code class="descname">u64_to_ether_addr</code><span class="sig-paren">(</span>u64<em>&nbsp;u</em>, u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.u64_to_ether_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a u64 to an Ethernet address.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">u</span></code></dt>
<dd>u64 to convert to an Ethernet MAC address</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array to contain the Ethernet address</dd>
</dl>
<dl class="function">
<dt id="c.eth_addr_dec">
void <code class="descname">eth_addr_dec</code><span class="sig-paren">(</span>u8 *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_addr_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrement the given MAC address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing Ethernet address to decrement</dd>
</dl>
<dl class="function">
<dt id="c.is_etherdev_addr">
bool <code class="descname">is_etherdev_addr</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, const u8<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_etherdev_addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell if given Ethernet address belongs to the device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Pointer to a device structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to a six-byte array containing the Ethernet address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare passed address with all addresses of the device. Return true if the
address if one of the device addresses.</p>
<p>Note that this function calls <a class="reference internal" href="#c.ether_addr_equal_64bits" title="ether_addr_equal_64bits"><code class="xref c c-func docutils literal"><span class="pre">ether_addr_equal_64bits()</span></code></a> so take care of
the right padding.</p>
<dl class="function">
<dt id="c.compare_ether_header">
unsigned long <code class="descname">compare_ether_header</code><span class="sig-paren">(</span>const void *<em>&nbsp;a</em>, const void *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.compare_ether_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Ethernet headers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">a</span></code></dt>
<dd>Pointer to Ethernet header</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>Pointer to Ethernet header</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compare two Ethernet headers, returns 0 if equal.
This assumes that the network header (i.e., IP header) is 4-byte
aligned OR the platform can handle unaligned access.  This is the
case for all packets coming into netif_receive_skb or similar
entry points.</p>
<dl class="function">
<dt id="c.eth_skb_pad">
int <code class="descname">eth_skb_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.eth_skb_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad buffer to mininum number of octets for Ethernet frame</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>Buffer to pad</dd>
</dl>
<p><strong>Description</strong></p>
<p>An Ethernet frame should have a minimum size of 60 bytes.  This function
takes short frames and pads them with zeros up to the 60 byte limit.</p>
<dl class="function">
<dt id="c.napi_schedule">
void <code class="descname">napi_schedule</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule NAPI poll</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>NAPI context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule NAPI poll routine to be called if it is not already
running.</p>
<dl class="function">
<dt id="c.napi_schedule_irqoff">
void <code class="descname">napi_schedule_irqoff</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_schedule_irqoff" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule NAPI poll</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>NAPI context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Variant of <a class="reference internal" href="#c.napi_schedule" title="napi_schedule"><code class="xref c c-func docutils literal"><span class="pre">napi_schedule()</span></code></a>, assuming hard irqs are masked.</p>
<dl class="function">
<dt id="c.napi_complete">
bool <code class="descname">napi_complete</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>NAPI processing complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>NAPI context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark NAPI processing as complete.
Consider using <code class="xref c c-func docutils literal"><span class="pre">napi_complete_done()</span></code> instead.
Return false if device should avoid rearming interrupts.</p>
<dl class="function">
<dt id="c.napi_hash_del">
bool <code class="descname">napi_hash_del</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;napi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_hash_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a NAPI from global table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt>
<dd>NAPI context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Warning: caller must observe RCU grace period
before freeing memory containing <strong>napi</strong>, if
this function returns true.</p>
<p><strong>Note</strong></p>
<p>core networking stack automatically calls it
from <a class="reference internal" href="#c.netif_napi_del" title="netif_napi_del"><code class="xref c c-func docutils literal"><span class="pre">netif_napi_del()</span></code></a>.
Drivers might want to call this helper to combine all
the needed RCU grace periods into a single one.</p>
<dl class="function">
<dt id="c.napi_disable">
void <code class="descname">napi_disable</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>prevent NAPI from scheduling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>NAPI context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop NAPI from being scheduled on this context.
Waits till any outstanding processing completes.</p>
<dl class="function">
<dt id="c.napi_enable">
void <code class="descname">napi_enable</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>enable NAPI scheduling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>NAPI context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resume NAPI from being scheduled on this context.
Must be paired with napi_disable.</p>
<dl class="function">
<dt id="c.napi_synchronize">
void <code class="descname">napi_synchronize</code><span class="sig-paren">(</span>const struct napi_struct *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.napi_synchronize" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until NAPI is not running</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>NAPI context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until NAPI is done being scheduled on this context.
Waits till any outstanding processing completes but
does not disable future activations.</p>
<dl class="type">
<dt id="c.netdev_priv_flags">
enum <code class="descname">netdev_priv_flags</code><a class="headerlink" href="#c.netdev_priv_flags" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span></code></a> priv_flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">IFF_802_1Q_VLAN</span></code></dt>
<dd>802.1Q VLAN device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_EBRIDGE</span></code></dt>
<dd>Ethernet bridging device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_BONDING</span></code></dt>
<dd>bonding master or slave</dd>
<dt><code class="docutils literal"><span class="pre">IFF_ISATAP</span></code></dt>
<dd>ISATAP interface (RFC4214)</dd>
<dt><code class="docutils literal"><span class="pre">IFF_WAN_HDLC</span></code></dt>
<dd>WAN HDLC device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_XMIT_DST_RELEASE</span></code></dt>
<dd><code class="xref c c-func docutils literal"><span class="pre">dev_hard_start_xmit()</span></code> is allowed to
release skb-&gt;dst</dd>
<dt><code class="docutils literal"><span class="pre">IFF_DONT_BRIDGE</span></code></dt>
<dd>disallow bridging this ether dev</dd>
<dt><code class="docutils literal"><span class="pre">IFF_DISABLE_NETPOLL</span></code></dt>
<dd>disable netpoll at run-time</dd>
<dt><code class="docutils literal"><span class="pre">IFF_MACVLAN_PORT</span></code></dt>
<dd>device used as macvlan port</dd>
<dt><code class="docutils literal"><span class="pre">IFF_BRIDGE_PORT</span></code></dt>
<dd>device used as bridge port</dd>
<dt><code class="docutils literal"><span class="pre">IFF_OVS_DATAPATH</span></code></dt>
<dd>device used as Open vSwitch datapath port</dd>
<dt><code class="docutils literal"><span class="pre">IFF_TX_SKB_SHARING</span></code></dt>
<dd>The interface supports sharing skbs on transmit</dd>
<dt><code class="docutils literal"><span class="pre">IFF_UNICAST_FLT</span></code></dt>
<dd>Supports unicast filtering</dd>
<dt><code class="docutils literal"><span class="pre">IFF_TEAM_PORT</span></code></dt>
<dd>device used as team port</dd>
<dt><code class="docutils literal"><span class="pre">IFF_SUPP_NOFCS</span></code></dt>
<dd>device supports sending custom FCS</dd>
<dt><code class="docutils literal"><span class="pre">IFF_LIVE_ADDR_CHANGE</span></code></dt>
<dd>device supports hardware address
change when it’s running</dd>
<dt><code class="docutils literal"><span class="pre">IFF_MACVLAN</span></code></dt>
<dd>Macvlan device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_XMIT_DST_RELEASE_PERM</span></code></dt>
<dd>IFF_XMIT_DST_RELEASE not taking into account
underlying stacked devices</dd>
<dt><code class="docutils literal"><span class="pre">IFF_IPVLAN_MASTER</span></code></dt>
<dd>IPvlan master device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_IPVLAN_SLAVE</span></code></dt>
<dd>IPvlan slave device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_L3MDEV_MASTER</span></code></dt>
<dd>device is an L3 master device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_NO_QUEUE</span></code></dt>
<dd>device can run without qdisc attached</dd>
<dt><code class="docutils literal"><span class="pre">IFF_OPENVSWITCH</span></code></dt>
<dd>device is a Open vSwitch master</dd>
<dt><code class="docutils literal"><span class="pre">IFF_L3MDEV_SLAVE</span></code></dt>
<dd>device is enslaved to an L3 master device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_TEAM</span></code></dt>
<dd>device is a team device</dd>
<dt><code class="docutils literal"><span class="pre">IFF_RXFH_CONFIGURED</span></code></dt>
<dd>device has had Rx Flow indirection table configured</dd>
<dt><code class="docutils literal"><span class="pre">IFF_PHONY_HEADROOM</span></code></dt>
<dd>the headroom value is controlled by an external
entity (i.e. the master device for bridged veth)</dd>
<dt><code class="docutils literal"><span class="pre">IFF_MACSEC</span></code></dt>
<dd>device is a MACsec device</dd>
</dl>
<p><strong>Description</strong></p>
<p>These are the <a class="reference internal" href="#c.net_device" title="net_device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span></code></a>, they are only set internally
by drivers and used in the kernel. These flags are invisible to
userspace; this means that the order of these flags can change
during any kernel release.</p>
<p>You should have a pretty good reason to be extending these flags.</p>
<dl class="type">
<dt id="c.net_device">
struct <code class="descname">net_device</code><a class="headerlink" href="#c.net_device" title="Permalink to this definition">¶</a></dt>
<dd><p>The DEVICE structure.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre><span></span>struct net_device {
  char name;
  struct hlist_node name_hlist;
  char * ifalias;
  unsigned long mem_end;
  unsigned long mem_start;
  unsigned long base_addr;
  int irq;
  atomic_t carrier_changes;
  unsigned long state;
  struct list_head dev_list;
  struct list_head napi_list;
  struct list_head unreg_list;
  struct list_head close_list;
  struct list_head ptype_all;
  struct list_head ptype_specific;
  struct {unnamed_struct};
#if IS_ENABLED(CONFIG_GARP
  struct garp_port __rcu * garp_port;
#endif
#if IS_ENABLED(CONFIG_MRP
  struct mrp_port __rcu * mrp_port;
#endif
  struct device dev;
  const struct attribute_group * sysfs_groups;
  const struct attribute_group * sysfs_rx_queue_group;
  const struct rtnl_link_ops * rtnl_link_ops;
#define GSO_MAX_SIZE          65536
  unsigned int gso_max_size;
#define GSO_MAX_SEGS          65535
  u16 gso_max_segs;
#ifdef CONFIG_DCB
  const struct dcbnl_rtnl_ops * dcbnl_ops;
#endif
  u8 num_tc;
  struct netdev_tc_txq tc_to_txq;
  u8 prio_tc_map;
#if IS_ENABLED(CONFIG_FCOE
  unsigned int fcoe_ddp_xid;
#endif
#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO
  struct netprio_map __rcu * priomap;
#endif
  struct phy_device * phydev;
  struct lock_class_key * qdisc_tx_busylock;
  struct lock_class_key * qdisc_running_key;
  bool proto_down;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>This is the first field of the “visible” part of this structure
(i.e. as seen by users in the “Space.c” file).  It is the name
of the interface.</dd>
<dt><code class="docutils literal"><span class="pre">name_hlist</span></code></dt>
<dd>Device name hash chain, please keep it close to name[]</dd>
<dt><code class="docutils literal"><span class="pre">ifalias</span></code></dt>
<dd>SNMP alias</dd>
<dt><code class="docutils literal"><span class="pre">mem_end</span></code></dt>
<dd>Shared memory end</dd>
<dt><code class="docutils literal"><span class="pre">mem_start</span></code></dt>
<dd>Shared memory start</dd>
<dt><code class="docutils literal"><span class="pre">base_addr</span></code></dt>
<dd>Device I/O address</dd>
<dt><code class="docutils literal"><span class="pre">irq</span></code></dt>
<dd>Device IRQ number</dd>
<dt><code class="docutils literal"><span class="pre">carrier_changes</span></code></dt>
<dd>Stats to monitor carrier on&lt;-&gt;off transitions</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>Generic network queuing layer state, see netdev_state_t</dd>
<dt><code class="docutils literal"><span class="pre">dev_list</span></code></dt>
<dd>The global list of network devices</dd>
<dt><code class="docutils literal"><span class="pre">napi_list</span></code></dt>
<dd>List entry used for polling NAPI devices</dd>
<dt><code class="docutils literal"><span class="pre">unreg_list</span></code></dt>
<dd>List entry  when we are unregistering the
device; see the function unregister_netdev</dd>
<dt><code class="docutils literal"><span class="pre">close_list</span></code></dt>
<dd>List entry used when we are closing the device</dd>
<dt><code class="docutils literal"><span class="pre">ptype_all</span></code></dt>
<dd>Device-specific packet handlers for all protocols</dd>
<dt><code class="docutils literal"><span class="pre">ptype_specific</span></code></dt>
<dd>Device-specific, protocol-specific packet handlers</dd>
<dt><code class="docutils literal"><span class="pre">{unnamed_struct}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal"><span class="pre">garp_port</span></code></dt>
<dd>GARP</dd>
<dt><code class="docutils literal"><span class="pre">mrp_port</span></code></dt>
<dd>MRP</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Class/net/name entry</dd>
<dt><code class="docutils literal"><span class="pre">sysfs_groups</span></code></dt>
<dd>Space for optional device, statistics and wireless
sysfs groups</dd>
<dt><code class="docutils literal"><span class="pre">sysfs_rx_queue_group</span></code></dt>
<dd>Space for optional per-rx queue attributes</dd>
<dt><code class="docutils literal"><span class="pre">rtnl_link_ops</span></code></dt>
<dd>Rtnl_link_ops</dd>
<dt><code class="docutils literal"><span class="pre">gso_max_size</span></code></dt>
<dd>Maximum size of generic segmentation offload</dd>
<dt><code class="docutils literal"><span class="pre">gso_max_segs</span></code></dt>
<dd>Maximum number of segments that can be passed to the
NIC for GSO</dd>
<dt><code class="docutils literal"><span class="pre">dcbnl_ops</span></code></dt>
<dd>Data Center Bridging netlink ops</dd>
<dt><code class="docutils literal"><span class="pre">num_tc</span></code></dt>
<dd>Number of traffic classes in the net device</dd>
<dt><code class="docutils literal"><span class="pre">tc_to_txq</span></code></dt>
<dd>XXX: need comments on this one</dd>
<dt><code class="docutils literal"><span class="pre">prio_tc_map</span></code></dt>
<dd>XXX: need comments on this one</dd>
<dt><code class="docutils literal"><span class="pre">fcoe_ddp_xid</span></code></dt>
<dd>Max exchange id for FCoE LRO by ddp</dd>
<dt><code class="docutils literal"><span class="pre">priomap</span></code></dt>
<dd>XXX: need comments on this one</dd>
<dt><code class="docutils literal"><span class="pre">phydev</span></code></dt>
<dd>Physical device may attach itself
for hardware timestamping</dd>
<dt><code class="docutils literal"><span class="pre">qdisc_tx_busylock</span></code></dt>
<dd>lockdep class annotating Qdisc-&gt;busylock spinlock</dd>
<dt><code class="docutils literal"><span class="pre">qdisc_running_key</span></code></dt>
<dd>lockdep class annotating Qdisc-&gt;running seqcount</dd>
<dt><code class="docutils literal"><span class="pre">proto_down</span></code></dt>
<dd>protocol port state information can be sent to the
switch driver and used to set the phys state of the
switch port.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Actually, this whole structure is a big mistake.  It mixes I/O
data with strictly “high-level” data, and it has to know about
almost every data structure used in the INET module.</p>
<p>interface address info:</p>
<p>FIXME: cleanup struct net_device such that network protocol info
moves out.</p>
</div></blockquote>
<dl class="function">
<dt id="c.netdev_priv">
void * <code class="descname">netdev_priv</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>access network device private data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get network device private data</p>
<dl class="function">
<dt id="c.netif_napi_add">
void <code class="descname">netif_napi_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct napi_struct *<em>&nbsp;napi</em>, int (*poll) (struct napi_struct<em>&nbsp;*</em>, int, int<em>&nbsp;weight</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_napi_add" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a NAPI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt>
<dd>NAPI context</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">napi_struct</span> <span class="pre">*,</span> <span class="pre">int)</span> <span class="pre">poll</span></code></dt>
<dd>polling function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">weight</span></code></dt>
<dd>default weight</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.netif_napi_add" title="netif_napi_add"><code class="xref c c-func docutils literal"><span class="pre">netif_napi_add()</span></code></a> must be used to initialize a NAPI context prior to calling
<em>any</em> of the other NAPI-related functions.</p>
<dl class="function">
<dt id="c.netif_tx_napi_add">
void <code class="descname">netif_tx_napi_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct napi_struct *<em>&nbsp;napi</em>, int (*poll) (struct napi_struct<em>&nbsp;*</em>, int, int<em>&nbsp;weight</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_tx_napi_add" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a NAPI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt>
<dd>NAPI context</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">napi_struct</span> <span class="pre">*,</span> <span class="pre">int)</span> <span class="pre">poll</span></code></dt>
<dd>polling function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">weight</span></code></dt>
<dd>default weight</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.netif_napi_add" title="netif_napi_add"><code class="xref c c-func docutils literal"><span class="pre">netif_napi_add()</span></code></a> should be used from drivers using NAPI
to exclusively poll a TX queue.
This will avoid we add it into napi_hash[], thus polluting this hash table.</p>
<dl class="function">
<dt id="c.netif_napi_del">
void <code class="descname">netif_napi_del</code><span class="sig-paren">(</span>struct napi_struct *<em>&nbsp;napi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_napi_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a NAPI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">napi_struct</span> <span class="pre">*</span> <span class="pre">napi</span></code></dt>
<dd>NAPI context</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.netif_napi_del" title="netif_napi_del"><code class="xref c c-func docutils literal"><span class="pre">netif_napi_del()</span></code></a> removes a NAPI context from the network device NAPI list</div></blockquote>
<dl class="function">
<dt id="c.netif_start_queue">
void <code class="descname">netif_start_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_start_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow transmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Allow upper layers to call the device hard_start_xmit routine.</div></blockquote>
<dl class="function">
<dt id="c.netif_wake_queue">
void <code class="descname">netif_wake_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_wake_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart transmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Allow upper layers to call the device hard_start_xmit routine.
Used for flow control when transmit resources are available.</div></blockquote>
<dl class="function">
<dt id="c.netif_stop_queue">
void <code class="descname">netif_stop_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stop_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop transmitted packets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Stop upper layers calling the device hard_start_xmit routine.
Used for flow control when transmit resources are unavailable.</div></blockquote>
<dl class="function">
<dt id="c.netif_queue_stopped">
bool <code class="descname">netif_queue_stopped</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_queue_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>test if transmit queue is flowblocked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Test if transmit queue on device is currently unable to send.</div></blockquote>
<dl class="function">
<dt id="c.netdev_txq_bql_enqueue_prefetchw">
void <code class="descname">netdev_txq_bql_enqueue_prefetchw</code><span class="sig-paren">(</span>struct netdev_queue *<em>&nbsp;dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_txq_bql_enqueue_prefetchw" title="Permalink to this definition">¶</a></dt>
<dd><p>prefetch bql data for write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*</span> <span class="pre">dev_queue</span></code></dt>
<dd>pointer to transmit queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>BQL enabled drivers might use this helper in their <code class="xref c c-func docutils literal"><span class="pre">ndo_start_xmit()</span></code>,
to give appropriate hint to the CPU.</p>
<dl class="function">
<dt id="c.netdev_txq_bql_complete_prefetchw">
void <code class="descname">netdev_txq_bql_complete_prefetchw</code><span class="sig-paren">(</span>struct netdev_queue *<em>&nbsp;dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_txq_bql_complete_prefetchw" title="Permalink to this definition">¶</a></dt>
<dd><p>prefetch bql data for write</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">netdev_queue</span> <span class="pre">*</span> <span class="pre">dev_queue</span></code></dt>
<dd>pointer to transmit queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>BQL enabled drivers might use this helper in their TX completion path,
to give appropriate hint to the CPU.</p>
<dl class="function">
<dt id="c.netdev_sent_queue">
void <code class="descname">netdev_sent_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_sent_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>report the number of bytes queued to hardware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bytes</span></code></dt>
<dd>number of bytes queued to the hardware device queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Report the number of bytes queued for sending/completion to the network
device hardware queue. <strong>bytes</strong> should be a good approximation and should
exactly match <a class="reference internal" href="#c.netdev_completed_queue" title="netdev_completed_queue"><code class="xref c c-func docutils literal"><span class="pre">netdev_completed_queue()</span></code></a> <strong>bytes</strong></div></blockquote>
<dl class="function">
<dt id="c.netdev_completed_queue">
void <code class="descname">netdev_completed_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;pkts</em>, unsigned int<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_completed_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>report bytes and packets completed by device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pkts</span></code></dt>
<dd>actual number of packets sent over the medium</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bytes</span></code></dt>
<dd>actual number of bytes sent over the medium</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Report the number of bytes and packets transmitted by the network device
hardware queue over the physical medium, <strong>bytes</strong> must exactly match the
<strong>bytes</strong> amount passed to <a class="reference internal" href="#c.netdev_sent_queue" title="netdev_sent_queue"><code class="xref c c-func docutils literal"><span class="pre">netdev_sent_queue()</span></code></a></div></blockquote>
<dl class="function">
<dt id="c.netdev_reset_queue">
void <code class="descname">netdev_reset_queue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_reset_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the packets and bytes count of a network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev_queue</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Reset the bytes and packet count of a network device and clear the
software flow control OFF bit for this network device</div></blockquote>
<dl class="function">
<dt id="c.netdev_cap_txqueue">
u16 <code class="descname">netdev_cap_txqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, u16<em>&nbsp;queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netdev_cap_txqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>check if selected tx queue exceeds device queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt>
<dd>given tx queue index</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns 0 if given tx queue index &gt;= number of device tx queues,
otherwise returns the originally passed tx queue index.</div></blockquote>
<dl class="function">
<dt id="c.netif_running">
bool <code class="descname">netif_running</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_running" title="Permalink to this definition">¶</a></dt>
<dd><p>test if up</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Test if the device has been brought up.</div></blockquote>
<dl class="function">
<dt id="c.netif_start_subqueue">
void <code class="descname">netif_start_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, u16<em>&nbsp;queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_start_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow sending packets on subqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt>
<dd>sub queue index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start individual transmit queue of a device with multiple transmit queues.</p>
<dl class="function">
<dt id="c.netif_stop_subqueue">
void <code class="descname">netif_stop_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, u16<em>&nbsp;queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_stop_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop sending packets on subqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt>
<dd>sub queue index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stop individual transmit queue of a device with multiple transmit queues.</p>
<dl class="function">
<dt id="c.__netif_subqueue_stopped">
bool <code class="descname">__netif_subqueue_stopped</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, u16<em>&nbsp;queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__netif_subqueue_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>test status of subqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt>
<dd>sub queue index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check individual transmit queue of a device with multiple transmit queues.</p>
<dl class="function">
<dt id="c.netif_wake_subqueue">
void <code class="descname">netif_wake_subqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, u16<em>&nbsp;queue_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_wake_subqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>allow sending packets on subqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">queue_index</span></code></dt>
<dd>sub queue index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resume individual transmit queue of a device with multiple transmit queues.</p>
<dl class="function">
<dt id="c.netif_is_multiqueue">
bool <code class="descname">netif_is_multiqueue</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_is_multiqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device has multiple transmit queues</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device has multiple transmit queues</p>
<dl class="function">
<dt id="c.dev_put">
void <code class="descname">dev_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release reference to device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release reference to device to allow it to be freed.</p>
<dl class="function">
<dt id="c.dev_hold">
void <code class="descname">dev_hold</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_hold" title="Permalink to this definition">¶</a></dt>
<dd><p>get reference to device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hold reference to device to keep it from being freed.</p>
<dl class="function">
<dt id="c.netif_carrier_ok">
bool <code class="descname">netif_carrier_ok</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_carrier_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>test if carrier present</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if carrier is present on device</p>
<dl class="function">
<dt id="c.netif_dormant_on">
void <code class="descname">netif_dormant_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant_on" title="Permalink to this definition">¶</a></dt>
<dd><p>mark device as dormant.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark device as dormant (as per RFC2863).</p>
<p>The dormant state indicates that the relevant interface is not
actually in a condition to pass packets (i.e., it is not ‘up’) but is
in a “pending” state, waiting for some external event.  For “on-
demand” interfaces, this new state identifies the situation where the
interface is waiting for events to place it in the up state.</p>
<dl class="function">
<dt id="c.netif_dormant_off">
void <code class="descname">netif_dormant_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant_off" title="Permalink to this definition">¶</a></dt>
<dd><p>set device as not dormant.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Device is not in dormant state.</p>
<dl class="function">
<dt id="c.netif_dormant">
bool <code class="descname">netif_dormant</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_dormant" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device is dormant</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device is dormant.</p>
<dl class="function">
<dt id="c.netif_oper_up">
bool <code class="descname">netif_oper_up</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_oper_up" title="Permalink to this definition">¶</a></dt>
<dd><p>test if device is operational</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if carrier is operational</p>
<dl class="function">
<dt id="c.netif_device_present">
bool <code class="descname">netif_device_present</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_device_present" title="Permalink to this definition">¶</a></dt>
<dd><p>is device available or removed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if device has not been removed from system.</p>
<dl class="function">
<dt id="c.netif_tx_lock">
void <code class="descname">netif_tx_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.netif_tx_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>grab network device transmit lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get network device transmit lock</p>
<dl class="function">
<dt id="c.__dev_uc_sync">
int <code class="descname">__dev_uc_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int (*sync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, const unsigned char<em>&nbsp;*</em>, int (*unsync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, const unsigned char<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_uc_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchonize device’s unicast list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to sync</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">sync</span></code></dt>
<dd>function to call if address should be added</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">unsync</span></code></dt>
<dd>function to call if address should be removed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Add newly added addresses to the interface, and release
addresses that have been deleted.</div></blockquote>
<dl class="function">
<dt id="c.__dev_uc_unsync">
void <code class="descname">__dev_uc_unsync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int (*unsync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, const unsigned char<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_uc_unsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove synchronized addresses from device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to sync</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">unsync</span></code></dt>
<dd>function to call if address should be removed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove all addresses that were added to the device by <code class="xref c c-func docutils literal"><span class="pre">dev_uc_sync()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.__dev_mc_sync">
int <code class="descname">__dev_mc_sync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int (*sync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, const unsigned char<em>&nbsp;*</em>, int (*unsync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, const unsigned char<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_mc_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchonize device’s multicast list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to sync</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">sync</span></code></dt>
<dd>function to call if address should be added</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">unsync</span></code></dt>
<dd>function to call if address should be removed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Add newly added addresses to the interface, and release
addresses that have been deleted.</div></blockquote>
<dl class="function">
<dt id="c.__dev_mc_unsync">
void <code class="descname">__dev_mc_unsync</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, int (*unsync) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, const unsigned char<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__dev_mc_unsync" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove synchronized addresses from device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to sync</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">*)</span> <span class="pre">unsync</span></code></dt>
<dd>function to call if address should be removed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Remove all addresses that were added to the device by <code class="xref c c-func docutils literal"><span class="pre">dev_mc_sync()</span></code>.</div></blockquote>
</div>
<div class="section" id="phy-support">
<h3>PHY Support<a class="headerlink" href="#phy-support" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.phy_print_status">
void <code class="descname">phy_print_status</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_print_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to print out the current phy status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the phy_device struct</dd>
</dl>
<dl class="function">
<dt id="c.phy_restart_aneg">
int <code class="descname">phy_restart_aneg</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Restart the autonegotiation on <strong>phydev</strong>.  Returns &gt;= 0 on success or
negative errno on error.</p>
<dl class="function">
<dt id="c.phy_aneg_done">
int <code class="descname">phy_aneg_done</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_aneg_done" title="Permalink to this definition">¶</a></dt>
<dd><p>return auto-negotiation status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the auto-negotiation status from this <strong>phydev</strong>
Returns &gt; 0 on success or &lt; 0 on error. 0 means that auto-negotiation
is still pending.</p>
<dl class="function">
<dt id="c.phy_ethtool_sset">
int <code class="descname">phy_ethtool_sset</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, struct ethtool_cmd *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_sset" title="Permalink to this definition">¶</a></dt>
<dd><p>generic ethtool sset function, handles all the details</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ethtool_cmd</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>ethtool_cmd</dd>
</dl>
<p><strong>Description</strong></p>
<p>A few notes about parameter checking:</p>
<ul class="simple">
<li>We don’t set port or transceiver, so we don’t care what they
were set to.</li>
<li><a class="reference internal" href="#c.phy_start_aneg" title="phy_start_aneg"><code class="xref c c-func docutils literal"><span class="pre">phy_start_aneg()</span></code></a> will make sure forced settings are sane, and
choose the next best ones from the ones selected, so we don’t
care if ethtool tries to give us bad values.</li>
</ul>
<dl class="function">
<dt id="c.phy_mii_ioctl">
int <code class="descname">phy_mii_ioctl</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, struct ifreq *<em>&nbsp;ifr</em>, int<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_mii_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>generic PHY MII ioctl interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ifreq</span> <span class="pre">*</span> <span class="pre">ifr</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">ifreq</span></code> for socket ioctl’s</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>ioctl cmd to execute</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function is currently incompatible with the
PHYCONTROL layer.  It changes registers without regard to
current state.  Use at own risk.</p>
<dl class="function">
<dt id="c.phy_start_aneg">
int <code class="descname">phy_start_aneg</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>start auto-negotiation for this PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Sanitizes the settings (if we’re not autonegotiating</dt>
<dd>them), and then calls the driver’s config_aneg function.
If the PHYCONTROL Layer is operating, we change the state to
reflect the beginning of Auto-negotiation or forcing.</dd>
</dl>
<dl class="function">
<dt id="c.phy_start_machine">
void <code class="descname">phy_start_machine</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>start PHY state machine tracking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>The PHY infrastructure can run a state machine</dt>
<dd>which tracks whether the PHY is starting up, negotiating,
etc.  This function starts the delayed workqueue which tracks
the state of the PHY. If you want to maintain your own state machine,
do not call this function.</dd>
</dl>
<dl class="function">
<dt id="c.phy_start_interrupts">
int <code class="descname">phy_start_interrupts</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>request and enable interrupts for a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Request the interrupt for the given PHY.</dt>
<dd>If this fails, then we set irq to PHY_POLL.
Otherwise, we enable the interrupts in the PHY.
This should only be called with a valid IRQ number.
Returns 0 on success or &lt; 0 on error.</dd>
</dl>
<dl class="function">
<dt id="c.phy_stop_interrupts">
int <code class="descname">phy_stop_interrupts</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_stop_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>disable interrupts from a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<dl class="function">
<dt id="c.phy_stop">
void <code class="descname">phy_stop</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bring down the PHY link, and stop checking the status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<dl class="function">
<dt id="c.phy_start">
void <code class="descname">phy_start</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start or restart a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Indicates the attached device’s readiness to</dt>
<dd>handle PHY-related work.  Used during startup to start the
PHY, and after a call to <a class="reference internal" href="#c.phy_stop" title="phy_stop"><code class="xref c c-func docutils literal"><span class="pre">phy_stop()</span></code></a> to resume operation.
Also used to indicate the MDIO bus has cleared an error
condition.</dd>
</dl>
<dl class="function">
<dt id="c.phy_mac_interrupt">
void <code class="descname">phy_mac_interrupt</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, int<em>&nbsp;new_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_mac_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>MAC says the link has changed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>phy_device struct with changed link</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_link</span></code></dt>
<dd>Link is Up/Down.</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>The MAC layer is able indicate there has been a change</dt>
<dd>in the PHY link status. Set the new link status, and trigger the
state machine, work a work queue.</dd>
</dl>
<dl class="function">
<dt id="c.phy_init_eee">
int <code class="descname">phy_init_eee</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, bool<em>&nbsp;clk_stop_enable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_init_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>init and check the EEE feature</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">clk_stop_enable</span></code></dt>
<dd>PHY may stop the clock during LPI</dd>
</dl>
<p><strong>Description</strong></p>
<p>it checks if the Energy-Efficient Ethernet (EEE)
is supported by looking at the MMD registers 3.20 and 7.60/61
and it programs the MMD register 3.0 setting the “Clock stop enable”
bit if required.</p>
<dl class="function">
<dt id="c.phy_get_eee_err">
int <code class="descname">phy_get_eee_err</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_get_eee_err" title="Permalink to this definition">¶</a></dt>
<dd><p>report the EEE wake error count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>it is to report the number of time where the PHY
failed to complete its normal wake sequence.</p>
<dl class="function">
<dt id="c.phy_ethtool_get_eee">
int <code class="descname">phy_ethtool_get_eee</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, struct ethtool_eee *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_get_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>get EEE supported and status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>ethtool_eee data</dd>
</dl>
<p><strong>Description</strong></p>
<p>it reportes the Supported/Advertisement/LP Advertisement
capabilities.</p>
<dl class="function">
<dt id="c.phy_ethtool_set_eee">
int <code class="descname">phy_ethtool_set_eee</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, struct ethtool_eee *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_ethtool_set_eee" title="Permalink to this definition">¶</a></dt>
<dd><p>set EEE supported and status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ethtool_eee</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>ethtool_eee data</dd>
</dl>
<p><strong>Description</strong></p>
<p>it is to program the Advertisement EEE register.</p>
<dl class="function">
<dt id="c.phy_clear_interrupt">
int <code class="descname">phy_clear_interrupt</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_clear_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Ack the phy device’s interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the <strong>phydev</strong> driver has an ack_interrupt function, call it to
ack and clear the phy device’s interrupt.</p>
<p>Returns 0 on success or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.phy_config_interrupt">
int <code class="descname">phy_config_interrupt</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, u32<em>&nbsp;interrupts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_config_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>configure the PHY device for the requested interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">interrupts</span></code></dt>
<dd>interrupt flags to configure for this <strong>phydev</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.phy_find_valid">
const struct phy_setting * <code class="descname">phy_find_valid</code><span class="sig-paren">(</span>int<em>&nbsp;speed</em>, int<em>&nbsp;duplex</em>, u32<em>&nbsp;supported</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_find_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>find a PHY setting that matches the requested parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">speed</span></code></dt>
<dd>desired speed</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">duplex</span></code></dt>
<dd>desired duplex</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">supported</span></code></dt>
<dd>mask of supported link modes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Locate a supported phy setting that is, in priority order:
- an exact match for the specified speed and duplex mode
- a match for the specified speed, or slower speed
- the slowest supported speed
Returns the matched phy_setting entry, or <code class="docutils literal"><span class="pre">NULL</span></code> if no supported phy
settings were found.</p>
<dl class="function">
<dt id="c.phy_supported_speeds">
unsigned int <code class="descname">phy_supported_speeds</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phy</em>, unsigned int *<em>&nbsp;speeds</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_supported_speeds" title="Permalink to this definition">¶</a></dt>
<dd><p>return all speeds currently supported by a phy device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phy</span></code></dt>
<dd>The phy device to return supported speeds of.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">speeds</span></code></dt>
<dd>buffer to store supported speeds in.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>size of speeds buffer.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of supported speeds, and fills the speeds
buffer with the supported speeds. If speeds buffer is too small to contain
all currently supported speeds, will return as many speeds as can fit.</p>
<dl class="function">
<dt id="c.phy_check_valid">
bool <code class="descname">phy_check_valid</code><span class="sig-paren">(</span>int<em>&nbsp;speed</em>, int<em>&nbsp;duplex</em>, u32<em>&nbsp;features</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_check_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there is a valid PHY setting which matches speed, duplex, and feature mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">speed</span></code></dt>
<dd>speed to match</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">duplex</span></code></dt>
<dd>duplex to match</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">features</span></code></dt>
<dd>A mask of the valid settings</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if there is a valid setting, false otherwise.</p>
<dl class="function">
<dt id="c.phy_sanitize_settings">
void <code class="descname">phy_sanitize_settings</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_sanitize_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure the PHY is set to supported speed and duplex</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Make sure the PHY is set to supported speeds and</dt>
<dd>duplexes.  Drop down by one in this order:  1000/FULL,
1000/HALF, 100/FULL, 100/HALF, 10/FULL, 10/HALF.</dd>
</dl>
<dl class="function">
<dt id="c.phy_start_aneg_priv">
int <code class="descname">phy_start_aneg_priv</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, bool<em>&nbsp;sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_start_aneg_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>start auto-negotiation for this PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">sync</span></code></dt>
<dd>indicate whether we should wait for the workqueue cancelation</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Sanitizes the settings (if we’re not autonegotiating</dt>
<dd>them), and then calls the driver’s config_aneg function.
If the PHYCONTROL Layer is operating, we change the state to
reflect the beginning of Auto-negotiation or forcing.</dd>
</dl>
<dl class="function">
<dt id="c.phy_trigger_machine">
void <code class="descname">phy_trigger_machine</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, bool<em>&nbsp;sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_trigger_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>trigger the state machine to run</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">sync</span></code></dt>
<dd>indicate whether we should wait for the workqueue cancelation</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>There has been a change in state which requires that the</dt>
<dd>state machine runs.</dd>
</dl>
<dl class="function">
<dt id="c.phy_stop_machine">
void <code class="descname">phy_stop_machine</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_stop_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the PHY state machine tracking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Stops the state machine delayed workqueue, sets the</dt>
<dd>state to UP (unless it wasn’t up yet). This function must be
called BEFORE phy_detach.</dd>
</dl>
<dl class="function">
<dt id="c.phy_error">
void <code class="descname">phy_error</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_error" title="Permalink to this definition">¶</a></dt>
<dd><p>enter HALTED state for this PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Moves the PHY to the HALTED state in response to a read
or write error, and tells the controller the link is down.
Must not be called from interrupt context, or while the
phydev-&gt;lock is held.</p>
<dl class="function">
<dt id="c.phy_interrupt">
irqreturn_t <code class="descname">phy_interrupt</code><span class="sig-paren">(</span>int<em>&nbsp;irq</em>, void *<em>&nbsp;phy_dat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>PHY interrupt handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt line</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">phy_dat</span></code></dt>
<dd>phy_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a PHY interrupt occurs, the handler disables
interrupts, and uses phy_change to handle the interrupt.</p>
<dl class="function">
<dt id="c.phy_enable_interrupts">
int <code class="descname">phy_enable_interrupts</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_enable_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable the interrupts from the PHY side</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<dl class="function">
<dt id="c.phy_disable_interrupts">
int <code class="descname">phy_disable_interrupts</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_disable_interrupts" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable the PHY interrupts from the PHY side</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<dl class="function">
<dt id="c.phy_change">
void <code class="descname">phy_change</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Called by the phy_interrupt to handle PHY changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>phy_device struct that interrupted</dd>
</dl>
<dl class="function">
<dt id="c.phy_change_work">
void <code class="descname">phy_change_work</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_change_work" title="Permalink to this definition">¶</a></dt>
<dd><p>Scheduled by the phy_mac_interrupt to handle PHY changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work_struct that describes the work to be done</dd>
</dl>
<dl class="function">
<dt id="c.phy_state_machine">
void <code class="descname">phy_state_machine</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_state_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle the state machine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work_struct that describes the work to be done</dd>
</dl>
<dl class="function">
<dt id="c.phy_register_fixup">
int <code class="descname">phy_register_fixup</code><span class="sig-paren">(</span>const char *<em>&nbsp;bus_id</em>, u32<em>&nbsp;phy_uid</em>, u32<em>&nbsp;phy_uid_mask</em>, int (*run) (struct phy_device<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_register_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a new phy_fixup and adds it to the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt>
<dd>A string which matches phydev-&gt;mdio.dev.bus_id (or PHY_ANY_ID)</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">phy_uid</span></code></dt>
<dd>Used to match against phydev-&gt;phy_id (the UID of the PHY)
It can also be PHY_ANY_UID</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">phy_uid_mask</span></code></dt>
<dd>Applied to phydev-&gt;phy_id and fixup-&gt;phy_uid before
comparison</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">phy_device</span> <span class="pre">*)</span> <span class="pre">run</span></code></dt>
<dd>The actual code to be run when a matching PHY is found</dd>
</dl>
<dl class="function">
<dt id="c.phy_unregister_fixup">
int <code class="descname">phy_unregister_fixup</code><span class="sig-paren">(</span>const char *<em>&nbsp;bus_id</em>, u32<em>&nbsp;phy_uid</em>, u32<em>&nbsp;phy_uid_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_unregister_fixup" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a phy_fixup from the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt>
<dd>A string matches fixup-&gt;bus_id (or PHY_ANY_ID) in phy_fixup_list</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">phy_uid</span></code></dt>
<dd>A phy id matches fixup-&gt;phy_id (or PHY_ANY_UID) in phy_fixup_list</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">phy_uid_mask</span></code></dt>
<dd>Applied to phy_uid and fixup-&gt;phy_uid before comparison</dd>
</dl>
<dl class="function">
<dt id="c.get_phy_device">
struct phy_device * <code class="descname">get_phy_device</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, int<em>&nbsp;addr</em>, bool<em>&nbsp;is_c45</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_device" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified PHY device and returns its <strong>phy_device</strong> struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the target MII bus</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>PHY address on the MII bus</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">is_c45</span></code></dt>
<dd>If true the PHY uses the 802.3 clause 45 protocol</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Reads the ID registers of the PHY at <strong>addr</strong> on the</dt>
<dd><strong>bus</strong>, then allocates and returns the phy_device to represent it.</dd>
</dl>
<dl class="function">
<dt id="c.phy_device_register">
int <code class="descname">phy_device_register</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register the phy device on the MDIO bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>phy_device structure to be added to the MDIO bus</dd>
</dl>
<dl class="function">
<dt id="c.phy_device_remove">
void <code class="descname">phy_device_remove</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_device_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a previously registered phy device from the MDIO bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>phy_device structure to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This doesn’t free the phy_device itself, it merely reverses the effects
of <a class="reference internal" href="#c.phy_device_register" title="phy_device_register"><code class="xref c c-func docutils literal"><span class="pre">phy_device_register()</span></code></a>. Use <code class="xref c c-func docutils literal"><span class="pre">phy_device_free()</span></code> to free the device
after calling this function.</p>
<dl class="function">
<dt id="c.phy_find_first">
struct phy_device * <code class="descname">phy_find_first</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_find_first" title="Permalink to this definition">¶</a></dt>
<dd><p>finds the first PHY device on the bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the target MII bus</dd>
</dl>
<dl class="function">
<dt id="c.phy_connect_direct">
int <code class="descname">phy_connect_direct</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct phy_device *<em>&nbsp;phydev</em>, void (*handler) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, phy_interface_t<em>&nbsp;interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_connect_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>connect an ethernet device to a specific phy_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the network device to connect</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>the pointer to the phy device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span> <span class="pre">handler</span></code></dt>
<dd>callback function for state change notifications</dd>
<dt><code class="docutils literal"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt>
<dd>PHY device’s interface</dd>
</dl>
<dl class="function">
<dt id="c.phy_connect">
struct phy_device * <code class="descname">phy_connect</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;bus_id</em>, void (*handler) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em>, phy_interface_t<em>&nbsp;interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>connect an ethernet device to a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the network device to connect</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt>
<dd>the id string of the PHY device to connect</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span> <span class="pre">handler</span></code></dt>
<dd>callback function for state change notifications</dd>
<dt><code class="docutils literal"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt>
<dd>PHY device’s interface</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Convenience function for connecting ethernet</dt>
<dd>devices to PHY devices.  The default behavior is for
the PHY infrastructure to handle everything, and only notify
the connected driver when the link status changes.  If you
don’t want, or can’t use the provided functionality, you may
choose to call only the subset of functions which provide
the desired functionality.</dd>
</dl>
<dl class="function">
<dt id="c.phy_disconnect">
void <code class="descname">phy_disconnect</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>disable interrupts, stop state machine, and detach a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<dl class="function">
<dt id="c.phy_attach_direct">
int <code class="descname">phy_attach_direct</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct phy_device *<em>&nbsp;phydev</em>, u32<em>&nbsp;flags</em>, phy_interface_t<em>&nbsp;interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_attach_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a network device to a given PHY device pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device to attach</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>Pointer to phy_device to attach</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>PHY device’s dev_flags</dd>
<dt><code class="docutils literal"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt>
<dd>PHY device’s interface</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Called by drivers to attach to a particular PHY</dt>
<dd>device. The phy_device is found, and properly hooked up
to the phy_driver.  If no driver is attached, then a
generic driver is used.  The phy_device is given a ptr to
the attaching device, and given a callback for link status
change.  The phy_device is returned to the attaching driver.
This function takes a reference on the phy device.</dd>
</dl>
<dl class="function">
<dt id="c.phy_attach">
struct phy_device * <code class="descname">phy_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;bus_id</em>, phy_interface_t<em>&nbsp;interface</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_attach" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a network device to a particular PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>network device to attach</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">bus_id</span></code></dt>
<dd>Bus ID of PHY device to attach</dd>
<dt><code class="docutils literal"><span class="pre">phy_interface_t</span> <span class="pre">interface</span></code></dt>
<dd>PHY device’s interface</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Same as <a class="reference internal" href="#c.phy_attach_direct" title="phy_attach_direct"><code class="xref c c-func docutils literal"><span class="pre">phy_attach_direct()</span></code></a> except that a PHY bus_id</dt>
<dd>string is passed instead of a pointer to a struct phy_device.</dd>
</dl>
<dl class="function">
<dt id="c.phy_detach">
void <code class="descname">phy_detach</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>detach a PHY device from its network device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>This detaches the phy device from its network device and the phy
driver, and drops the reference count taken in <a class="reference internal" href="#c.phy_attach_direct" title="phy_attach_direct"><code class="xref c c-func docutils literal"><span class="pre">phy_attach_direct()</span></code></a>.</p>
<dl class="function">
<dt id="c.genphy_setup_forced">
int <code class="descname">genphy_setup_forced</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_setup_forced" title="Permalink to this definition">¶</a></dt>
<dd><p>configures/forces speed/duplex from <strong>phydev</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Configures MII_BMCR to force speed/duplex</dt>
<dd>to the values in phydev. Assumes that the values are valid.
Please see <a class="reference internal" href="#c.phy_sanitize_settings" title="phy_sanitize_settings"><code class="xref c c-func docutils literal"><span class="pre">phy_sanitize_settings()</span></code></a>.</dd>
</dl>
<dl class="function">
<dt id="c.genphy_restart_aneg">
int <code class="descname">genphy_restart_aneg</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_restart_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable and Restart Autonegotiation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<dl class="function">
<dt id="c.genphy_config_aneg">
int <code class="descname">genphy_config_aneg</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_config_aneg" title="Permalink to this definition">¶</a></dt>
<dd><p>restart auto-negotiation or write BMCR</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>If auto-negotiation is enabled, we configure the</dt>
<dd>advertising, and then restart auto-negotiation.  If it is not
enabled, then we write the BMCR.</dd>
</dl>
<dl class="function">
<dt id="c.genphy_aneg_done">
int <code class="descname">genphy_aneg_done</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_aneg_done" title="Permalink to this definition">¶</a></dt>
<dd><p>return auto-negotiation status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Reads the status register and returns 0 either if</dt>
<dd>auto-negotiation is incomplete, or if there was an error.
Returns BMSR_ANEGCOMPLETE if auto-negotiation is done.</dd>
</dl>
<dl class="function">
<dt id="c.genphy_update_link">
int <code class="descname">genphy_update_link</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_update_link" title="Permalink to this definition">¶</a></dt>
<dd><p>update link status in <strong>phydev</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Update the value in phydev-&gt;link to reflect the</dt>
<dd>current link value.  In order to do this, we need to read
the status register twice, keeping the second value.</dd>
</dl>
<dl class="function">
<dt id="c.genphy_read_status">
int <code class="descname">genphy_read_status</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_read_status" title="Permalink to this definition">¶</a></dt>
<dd><p>check the link status and update current link state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Check the link, then figure out the current state</dt>
<dd>by comparing what we advertise with what the link partner
advertises.  Start by checking the gigabit possibilities,
then move on to 10/100.</dd>
</dl>
<dl class="function">
<dt id="c.genphy_soft_reset">
int <code class="descname">genphy_soft_reset</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_soft_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>software reset the PHY via BMCR_RESET bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a software PHY reset using the standard
BMCR_RESET bit and poll for the reset bit to be cleared.</p>
<p><strong>Return</strong></p>
<p>0 on success, &lt; 0 on failure</p>
<dl class="function">
<dt id="c.phy_driver_register">
int <code class="descname">phy_driver_register</code><span class="sig-paren">(</span>struct phy_driver *<em>&nbsp;new_driver</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_driver_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a phy_driver with the PHY layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_driver</span> <span class="pre">*</span> <span class="pre">new_driver</span></code></dt>
<dd>new phy_driver to register</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>module owning this PHY</dd>
</dl>
<dl class="function">
<dt id="c.get_phy_c45_ids">
int <code class="descname">get_phy_c45_ids</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, int<em>&nbsp;addr</em>, u32 *<em>&nbsp;phy_id</em>, struct phy_c45_device_ids *<em>&nbsp;c45_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_c45_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified addr for its 802.3-c45 IDs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the target MII bus</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>PHY address on the MII bus</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">phy_id</span></code></dt>
<dd>where to store the ID retrieved.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_c45_device_ids</span> <span class="pre">*</span> <span class="pre">c45_ids</span></code></dt>
<dd>where to store the c45 ID information.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If the PHY devices-in-package appears to be valid, it and the
corresponding identifiers are stored in <strong>c45_ids</strong>, zero is stored
in <strong>phy_id</strong>.  Otherwise 0xffffffff is stored in <strong>phy_id</strong>.  Returns
zero on success.</div></blockquote>
<dl class="function">
<dt id="c.get_phy_id">
int <code class="descname">get_phy_id</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, int<em>&nbsp;addr</em>, u32 *<em>&nbsp;phy_id</em>, bool<em>&nbsp;is_c45</em>, struct phy_c45_device_ids *<em>&nbsp;c45_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_phy_id" title="Permalink to this definition">¶</a></dt>
<dd><p>reads the specified addr for its ID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the target MII bus</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>PHY address on the MII bus</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">phy_id</span></code></dt>
<dd>where to store the ID retrieved.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">is_c45</span></code></dt>
<dd>If true the PHY uses the 802.3 clause 45 protocol</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_c45_device_ids</span> <span class="pre">*</span> <span class="pre">c45_ids</span></code></dt>
<dd>where to store the c45 ID information.</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>In the case of a 802.3-c22 PHY, reads the ID registers</dt>
<dd><p class="first">of the PHY at <strong>addr</strong> on the <strong>bus</strong>, stores it in <strong>phy_id</strong> and returns
zero on success.</p>
<p class="last">In the case of a 802.3-c45 PHY, <a class="reference internal" href="#c.get_phy_c45_ids" title="get_phy_c45_ids"><code class="xref c c-func docutils literal"><span class="pre">get_phy_c45_ids()</span></code></a> is invoked, and
its return value is in turn returned.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.phy_prepare_link">
void <code class="descname">phy_prepare_link</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em>, void (*handler) (struct <a class="reference internal" href="#c.net_device" title="net_device">net_device</a><em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_prepare_link" title="Permalink to this definition">¶</a></dt>
<dd><p>prepares the PHY layer to monitor link status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">net_device</span> <span class="pre">*)</span> <span class="pre">handler</span></code></dt>
<dd>callback function for link status change notifications</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Tells the PHY infrastructure to handle the</dt>
<dd>gory details on monitoring link status (whether through
polling or an interrupt), and to call back to the
connected device driver when the link status changes.
If you want to monitor your own link state, don’t call
this function.</dd>
</dl>
<dl class="function">
<dt id="c.phy_poll_reset">
int <code class="descname">phy_poll_reset</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_poll_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Safely wait until a PHY reset has properly completed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>The PHY device to poll</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>According to IEEE 802.3, Section 2, Subsection 22.2.4.1.1, as</dt>
<dd><p class="first">published in 2008, a PHY reset may take up to 0.5 seconds.  The MII BMCR
register must be polled until the BMCR_RESET bit clears.</p>
<p>Furthermore, any attempts to write to PHY registers may have no effect
or even generate MDIO bus errors until this is complete.</p>
<p class="last">Some PHYs (such as the Marvell 88E1111) don’t entirely conform to the
standard and do not fully reset after the BMCR_RESET bit is set, and may
even <em>REQUIRE</em> a soft-reset to properly restart autonegotiation.  In an
effort to support such broken PHYs, this function is separate from the
standard <code class="xref c c-func docutils literal"><span class="pre">phy_init_hw()</span></code> which will zero all the other bits in the BMCR
and reapply all driver-specific and board-specific fixups.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.genphy_config_advert">
int <code class="descname">genphy_config_advert</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_config_advert" title="Permalink to this definition">¶</a></dt>
<dd><p>sanitize and advertise auto-negotiation parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Writes MII_ADVERTISE with the appropriate values,</dt>
<dd>after sanitizing the values to make sure we only advertise
what is supported.  Returns &lt; 0 on error, 0 if the PHY’s advertisement
hasn’t changed, and &gt; 0 if it has changed.</dd>
</dl>
<dl class="function">
<dt id="c.genphy_config_eee_advert">
int <code class="descname">genphy_config_eee_advert</code><span class="sig-paren">(</span>struct phy_device *<em>&nbsp;phydev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.genphy_config_eee_advert" title="Permalink to this definition">¶</a></dt>
<dd><p>disable unwanted eee mode advertisement</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">phy_device</span> <span class="pre">*</span> <span class="pre">phydev</span></code></dt>
<dd>target phy_device struct</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Writes MDIO_AN_EEE_ADV after disabling unsupported energy</dt>
<dd>efficent ethernet modes. Returns 0 if the PHY’s advertisement hasn’t
changed, and 1 if it has changed.</dd>
</dl>
<dl class="function">
<dt id="c.phy_probe">
int <code class="descname">phy_probe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.phy_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>probe and init a PHY device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to probe and init</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Take care of setting up the phy_device structure,</dt>
<dd>set the state to READY (the driver’s init function should
set it to STARTING if needed).</dd>
</dl>
<dl class="function">
<dt id="c.mdiobus_alloc_size">
struct mii_bus * <code class="descname">mdiobus_alloc_size</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_alloc_size" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a mii_bus structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>extra amount of memory to allocate for private storage.
If non-zero, then bus-&gt;priv is points to that memory.</dd>
</dl>
<p><strong>Description</strong></p>
<p>called by a bus driver to allocate an mii_bus
structure to fill in.</p>
<dl class="function">
<dt id="c.devm_mdiobus_alloc_size">
struct mii_bus * <code class="descname">devm_mdiobus_alloc_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;sizeof_priv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_mdiobus_alloc_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.mdiobus_alloc_size" title="mdiobus_alloc_size"><code class="xref c c-func docutils literal"><span class="pre">mdiobus_alloc_size()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate mii_bus for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sizeof_priv</span></code></dt>
<dd>Space to allocate for private structure.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed mdiobus_alloc_size. mii_bus allocated with this function is
automatically freed on driver detach.</p>
<p>If an mii_bus allocated with this function needs to be freed separately,
<a class="reference internal" href="#c.devm_mdiobus_free" title="devm_mdiobus_free"><code class="xref c c-func docutils literal"><span class="pre">devm_mdiobus_free()</span></code></a> must be used.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated mii_bus on success, NULL on failure.</p>
<dl class="function">
<dt id="c.devm_mdiobus_free">
void <code class="descname">devm_mdiobus_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct mii_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_mdiobus_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.mdiobus_free" title="mdiobus_free"><code class="xref c c-func docutils literal"><span class="pre">mdiobus_free()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device this mii_bus belongs to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the mii_bus associated with the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free mii_bus allocated with <a class="reference internal" href="#c.devm_mdiobus_alloc_size" title="devm_mdiobus_alloc_size"><code class="xref c c-func docutils literal"><span class="pre">devm_mdiobus_alloc_size()</span></code></a>.</p>
<dl class="function">
<dt id="c.of_mdio_find_bus">
struct mii_bus * <code class="descname">of_mdio_find_bus</code><span class="sig-paren">(</span>struct device_node *<em>&nbsp;mdio_bus_np</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mdio_find_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an mii_bus node, find the mii_bus.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">mdio_bus_np</span></code></dt>
<dd>Pointer to the mii_bus.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a reference to the mii_bus, or NULL if none found.  The
embedded struct device will have its reference count incremented,
and this must be put once the bus is finished with.</p>
<p>Because the association of a device_node and mii_bus is made via
<code class="xref c c-func docutils literal"><span class="pre">of_mdiobus_register()</span></code>, the mii_bus cannot be found before it is
registered with <code class="xref c c-func docutils literal"><span class="pre">of_mdiobus_register()</span></code>.</p>
<dl class="function">
<dt id="c.__mdiobus_register">
int <code class="descname">__mdiobus_register</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__mdiobus_register" title="Permalink to this definition">¶</a></dt>
<dd><p>bring up all the PHYs on a given bus and attach them to bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>target mii_bus</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>module containing bus accessor functions</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Called by a bus driver to bring up all the PHYs</dt>
<dd>on a given bus, and attach them to the bus. Drivers should use
<code class="xref c c-func docutils literal"><span class="pre">mdiobus_register()</span></code> rather than <a class="reference internal" href="#c.__mdiobus_register" title="__mdiobus_register"><code class="xref c c-func docutils literal"><span class="pre">__mdiobus_register()</span></code></a> unless they
need to pass a specific owner module. MDIO devices which are not
PHYs will not be brought up by this function. They are expected to
to be explicitly listed in DT and instantiated by <code class="xref c c-func docutils literal"><span class="pre">of_mdiobus_register()</span></code>.</dd>
</dl>
<p>Returns 0 on success or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.mdiobus_free">
void <code class="descname">mdiobus_free</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a struct mii_bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>mii_bus to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function releases the reference to the underlying device
object in the mii_bus.  If this is the last reference, the mii_bus
will be freed.</p>
<dl class="function">
<dt id="c.mdiobus_scan">
struct phy_device * <code class="descname">mdiobus_scan</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, int<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_scan" title="Permalink to this definition">¶</a></dt>
<dd><p>scan a bus for MDIO devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>mii_bus to scan</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>address on bus to scan</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function scans the MDIO bus, looking for devices which can be
identified using a vendor/product ID in registers 2 and 3. Not all
MDIO devices have such registers, but PHY devices typically
do. Hence this function assumes anything found is a PHY, or can be
treated as a PHY. Other MDIO devices, such as switches, will
probably not be found during the scan.</p>
<dl class="function">
<dt id="c.mdiobus_read_nested">
int <code class="descname">mdiobus_read_nested</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, int<em>&nbsp;addr</em>, u32<em>&nbsp;regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_read_nested" title="Permalink to this definition">¶</a></dt>
<dd><p>Nested version of the mdiobus_read function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the mii_bus struct</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>the phy address</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt>
<dd>register number to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>In case of nested MDIO bus access avoid lockdep false positives by
using <code class="xref c c-func docutils literal"><span class="pre">mutex_lock_nested()</span></code>.</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<dl class="function">
<dt id="c.mdiobus_read">
int <code class="descname">mdiobus_read</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, int<em>&nbsp;addr</em>, u32<em>&nbsp;regnum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for reading a given MII mgmt register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the mii_bus struct</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>the phy address</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt>
<dd>register number to read</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<dl class="function">
<dt id="c.mdiobus_write_nested">
int <code class="descname">mdiobus_write_nested</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, int<em>&nbsp;addr</em>, u32<em>&nbsp;regnum</em>, u16<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_write_nested" title="Permalink to this definition">¶</a></dt>
<dd><p>Nested version of the mdiobus_write function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the mii_bus struct</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>the phy address</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt>
<dd>register number to write</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">val</span></code></dt>
<dd>value to write to <strong>regnum</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>In case of nested MDIO bus access avoid lockdep false positives by
using <code class="xref c c-func docutils literal"><span class="pre">mutex_lock_nested()</span></code>.</p>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<dl class="function">
<dt id="c.mdiobus_write">
int <code class="descname">mdiobus_write</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, int<em>&nbsp;addr</em>, u32<em>&nbsp;regnum</em>, u16<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for writing a given MII mgmt register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the mii_bus struct</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">addr</span></code></dt>
<dd>the phy address</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">regnum</span></code></dt>
<dd>register number to write</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">val</span></code></dt>
<dd>value to write to <strong>regnum</strong></dd>
</dl>
<p><strong>NOTE</strong></p>
<p>MUST NOT be called from interrupt context,
because the bus read/write functions may wait for an interrupt
to conclude the operation.</p>
<dl class="function">
<dt id="c.mdiobus_release">
void <code class="descname">mdiobus_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_release" title="Permalink to this definition">¶</a></dt>
<dd><p>mii_bus device release callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>the target struct device that contains the mii_bus</dd>
</dl>
<p><strong>Description</strong></p>
<p>called when the last reference to an mii_bus is
dropped, to free the underlying memory.</p>
<dl class="function">
<dt id="c.mdiobus_create_device">
int <code class="descname">mdiobus_create_device</code><span class="sig-paren">(</span>struct mii_bus *<em>&nbsp;bus</em>, struct mdio_board_info *<em>&nbsp;bi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdiobus_create_device" title="Permalink to this definition">¶</a></dt>
<dd><p>create a full MDIO device given a mdio_board_info structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mii_bus</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>MDIO bus to create the devices on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mdio_board_info</span> <span class="pre">*</span> <span class="pre">bi</span></code></dt>
<dd>mdio_board_info structure describing the devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.mdio_bus_match">
int <code class="descname">mdio_bus_match</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mdio_bus_match" title="Permalink to this definition">¶</a></dt>
<dd><p>determine if given MDIO driver supports the given MDIO device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>target MDIO device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>given MDIO driver</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Given a MDIO device, and a MDIO driver, return 1 if</dt>
<dd>the driver supports the device.  Otherwise, return 0. This may
require calling the devices own match function, since different classes
of MDIO devices have different match criteria.</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="z8530book.html" class="btn btn-neutral float-right" title="Z8530 Programming Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="batman-adv.html" class="btn btn-neutral" title="batman-adv" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>