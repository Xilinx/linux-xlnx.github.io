

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Z8530 Programming Guide &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="Linux Networking Documentation" href="index.html"/>
        <link rel="next" title="MSG_ZEROCOPY" href="msg_zerocopy.html"/>
        <link rel="prev" title="Linux Networking and Network Devices APIs" href="kapi.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Networking Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="netdev-FAQ.html">netdev FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="af_xdp.html">AF_XDP</a></li>
<li class="toctree-l2"><a class="reference internal" href="batman-adv.html">batman-adv</a></li>
<li class="toctree-l2"><a class="reference internal" href="can.html">SocketCAN - Controller Area Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="can_ucan_protocol.html">The UCAN Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="dpaa2/index.html">DPAA2 Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="e100.html">Linux* Base Driver for the Intel(R) PRO/100 Family of Adapters</a></li>
<li class="toctree-l2"><a class="reference internal" href="e1000.html">Linux* Base Driver for Intel(R) Ethernet Network Connection</a></li>
<li class="toctree-l2"><a class="reference internal" href="kapi.html">Linux Networking and Network Devices APIs</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Z8530 Programming Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-modes">Driver Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-the-z85230-driver">Using the Z85230 driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#attaching-network-interfaces">Attaching Network Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-and-activating-the-port">Configuring And Activating The Port</a></li>
<li class="toctree-l3"><a class="reference internal" href="#network-layer-functions">Network Layer Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#porting-the-z8530-driver">Porting The Z8530 Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#known-bugs-and-assumptions">Known Bugs And Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#public-functions-provided">Public Functions Provided</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internal-functions">Internal Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="msg_zerocopy.html">MSG_ZEROCOPY</a></li>
<li class="toctree-l2"><a class="reference internal" href="failover.html">FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="net_failover.html">NET_FAILOVER</a></li>
<li class="toctree-l2"><a class="reference internal" href="alias.html">IP-Aliasing</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge.html">Ethernet Bridging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux Networking Documentation</a> &raquo;</li>
      
    <li>Z8530 Programming Guide</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/networking/z8530book.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="z8530-programming-guide">
<h1>Z8530 Programming Guide<a class="headerlink" href="#z8530-programming-guide" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Alan Cox</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Z85x30 family synchronous/asynchronous controller chips are used on
a large number of cheap network interface cards. The kernel provides a
core interface layer that is designed to make it easy to provide WAN
services using this chip.</p>
<p>The current driver only support synchronous operation. Merging the
asynchronous driver support into this code to allow any Z85x30 device to
be used as both a tty interface and as a synchronous controller is a
project for Linux post the 2.4 release</p>
</div>
<div class="section" id="driver-modes">
<h2>Driver Modes<a class="headerlink" href="#driver-modes" title="Permalink to this headline">¶</a></h2>
<p>The Z85230 driver layer can drive Z8530, Z85C30 and Z85230 devices in
three different modes. Each mode can be applied to an individual channel
on the chip (each chip has two channels).</p>
<p>The PIO synchronous mode supports the most common Z8530 wiring. Here the
chip is interface to the I/O and interrupt facilities of the host
machine but not to the DMA subsystem. When running PIO the Z8530 has
extremely tight timing requirements. Doing high speeds, even with a
Z85230 will be tricky. Typically you should expect to achieve at best
9600 baud with a Z8C530 and 64Kbits with a Z85230.</p>
<p>The DMA mode supports the chip when it is configured to use dual DMA
channels on an ISA bus. The better cards tend to support this mode of
operation for a single channel. With DMA running the Z85230 tops out
when it starts to hit ISA DMA constraints at about 512Kbits. It is worth
noting here that many PC machines hang or crash when the chip is driven
fast enough to hold the ISA bus solid.</p>
<p>Transmit DMA mode uses a single DMA channel. The DMA channel is used for
transmission as the transmit FIFO is smaller than the receive FIFO. it
gives better performance than pure PIO mode but is nowhere near as ideal
as pure DMA mode.</p>
</div>
<div class="section" id="using-the-z85230-driver">
<h2>Using the Z85230 driver<a class="headerlink" href="#using-the-z85230-driver" title="Permalink to this headline">¶</a></h2>
<p>The Z85230 driver provides the back end interface to your board. To
configure a Z8530 interface you need to detect the board and to identify
its ports and interrupt resources. It is also your problem to verify the
resources are available.</p>
<p>Having identified the chip you need to fill in a struct z8530_dev,
which describes each chip. This object must exist until you finally
shutdown the board. Firstly zero the active field. This ensures nothing
goes off without you intending it. The irq field should be set to the
interrupt number of the chip. (Each chip has a single interrupt source
rather than each channel). You are responsible for allocating the
interrupt line. The interrupt handler should be set to
<a class="reference internal" href="#c.z8530_interrupt" title="z8530_interrupt"><code class="xref c c-func docutils literal"><span class="pre">z8530_interrupt()</span></code></a>. The device id should be set to the
z8530_dev structure pointer. Whether the interrupt can be shared or not
is board dependent, and up to you to initialise.</p>
<p>The structure holds two channel structures. Initialise chanA.ctrlio and
chanA.dataio with the address of the control and data ports. You can or
this with Z8530_PORT_SLEEP to indicate your interface needs the 5uS
delay for chip settling done in software. The PORT_SLEEP option is
architecture specific. Other flags may become available on future
platforms, eg for MMIO. Initialise the chanA.irqs to &amp;z8530_nop to
start the chip up as disabled and discarding interrupt events. This
ensures that stray interrupts will be mopped up and not hang the bus.
Set chanA.dev to point to the device structure itself. The private and
name field you may use as you wish. The private field is unused by the
Z85230 layer. The name is used for error reporting and it may thus make
sense to make it match the network name.</p>
<p>Repeat the same operation with the B channel if your chip has both
channels wired to something useful. This isn&#8217;t always the case. If it is
not wired then the I/O values do not matter, but you must initialise
chanB.dev.</p>
<p>If your board has DMA facilities then initialise the txdma and rxdma
fields for the relevant channels. You must also allocate the ISA DMA
channels and do any necessary board level initialisation to configure
them. The low level driver will do the Z8530 and DMA controller
programming but not board specific magic.</p>
<p>Having initialised the device you can then call
<a class="reference internal" href="#c.z8530_init" title="z8530_init"><code class="xref c c-func docutils literal"><span class="pre">z8530_init()</span></code></a>. This will probe the chip and reset it into
a known state. An identification sequence is then run to identify the
chip type. If the checks fail to pass the function returns a non zero
error code. Typically this indicates that the port given is not valid.
After this call the type field of the z8530_dev structure is
initialised to either Z8530, Z85C30 or Z85230 according to the chip
found.</p>
<p>Once you have called z8530_init you can also make use of the utility
function <a class="reference internal" href="#c.z8530_describe" title="z8530_describe"><code class="xref c c-func docutils literal"><span class="pre">z8530_describe()</span></code></a>. This provides a consistent
reporting format for the Z8530 devices, and allows all the drivers to
provide consistent reporting.</p>
</div>
<div class="section" id="attaching-network-interfaces">
<h2>Attaching Network Interfaces<a class="headerlink" href="#attaching-network-interfaces" title="Permalink to this headline">¶</a></h2>
<p>If you wish to use the network interface facilities of the driver, then
you need to attach a network device to each channel that is present and
in use. In addition to use the generic HDLC you need to follow some
additional plumbing rules. They may seem complex but a look at the
example hostess_sv11 driver should reassure you.</p>
<p>The network device used for each channel should be pointed to by the
netdevice field of each channel. The hdlc-&gt; priv field of the network
device points to your private data - you will need to be able to find
your private data from this.</p>
<p>The way most drivers approach this particular problem is to create a
structure holding the Z8530 device definition and put that into the
private field of the network device. The network device fields of the
channels then point back to the network devices.</p>
<p>If you wish to use the generic HDLC then you need to register the HDLC
device.</p>
<p>Before you register your network device you will also need to provide
suitable handlers for most of the network device callbacks. See the
network device documentation for more details on this.</p>
</div>
<div class="section" id="configuring-and-activating-the-port">
<h2>Configuring And Activating The Port<a class="headerlink" href="#configuring-and-activating-the-port" title="Permalink to this headline">¶</a></h2>
<p>The Z85230 driver provides helper functions and tables to load the port
registers on the Z8530 chips. When programming the register settings for
a channel be aware that the documentation recommends initialisation
orders. Strange things happen when these are not followed.</p>
<p><a class="reference internal" href="#c.z8530_channel_load" title="z8530_channel_load"><code class="xref c c-func docutils literal"><span class="pre">z8530_channel_load()</span></code></a> takes an array of pairs of
initialisation values in an array of u8 type. The first value is the
Z8530 register number. Add 16 to indicate the alternate register bank on
the later chips. The array is terminated by a 255.</p>
<p>The driver provides a pair of public tables. The z8530_hdlc_kilostream
table is for the UK &#8216;Kilostream&#8217; service and also happens to cover most
other end host configurations. The z8530_hdlc_kilostream_85230 table
is the same configuration using the enhancements of the 85230 chip. The
configuration loaded is standard NRZ encoded synchronous data with HDLC
bitstuffing. All of the timing is taken from the other end of the link.</p>
<p>When writing your own tables be aware that the driver internally tracks
register values. It may need to reload values. You should therefore be
sure to set registers 1-7, 9-11, 14 and 15 in all configurations. Where
the register settings depend on DMA selection the driver will update the
bits itself when you open or close. Loading a new table with the
interface open is not recommended.</p>
<p>There are three standard configurations supported by the core code. In
PIO mode the interface is programmed up to use interrupt driven PIO.
This places high demands on the host processor to avoid latency. The
driver is written to take account of latency issues but it cannot avoid
latencies caused by other drivers, notably IDE in PIO mode. Because the
drivers allocate buffers you must also prevent MTU changes while the
port is open.</p>
<p>Once the port is open it will call the rx_function of each channel
whenever a completed packet arrived. This is invoked from interrupt
context and passes you the channel and a network buffer (struct
sk_buff) holding the data. The data includes the CRC bytes so most
users will want to trim the last two bytes before processing the data.
This function is very timing critical. When you wish to simply discard
data the support code provides the function
<a class="reference internal" href="#c.z8530_null_rx" title="z8530_null_rx"><code class="xref c c-func docutils literal"><span class="pre">z8530_null_rx()</span></code></a> to discard the data.</p>
<p>To active PIO mode sending and receiving the <code class="docutils literal"><span class="pre">z8530_sync_open</span></code> is called.
This expects to be passed the network device and the channel. Typically
this is called from your network device open callback. On a failure a
non zero error status is returned.
The <a class="reference internal" href="#c.z8530_sync_close" title="z8530_sync_close"><code class="xref c c-func docutils literal"><span class="pre">z8530_sync_close()</span></code></a> function shuts down a PIO
channel. This must be done before the channel is opened again and before
the driver shuts down and unloads.</p>
<p>The ideal mode of operation is dual channel DMA mode. Here the kernel
driver will configure the board for DMA in both directions. The driver
also handles ISA DMA issues such as controller programming and the
memory range limit for you. This mode is activated by calling the
<a class="reference internal" href="#c.z8530_sync_dma_open" title="z8530_sync_dma_open"><code class="xref c c-func docutils literal"><span class="pre">z8530_sync_dma_open()</span></code></a> function. On failure a non zero
error value is returned. Once this mode is activated it can be shut down
by calling the <a class="reference internal" href="#c.z8530_sync_dma_close" title="z8530_sync_dma_close"><code class="xref c c-func docutils literal"><span class="pre">z8530_sync_dma_close()</span></code></a>. You must call
the close function matching the open mode you used.</p>
<p>The final supported mode uses a single DMA channel to drive the transmit
side. As the Z85C30 has a larger FIFO on the receive channel this tends
to increase the maximum speed a little. This is activated by calling the
<code class="docutils literal"><span class="pre">z8530_sync_txdma_open</span></code>. This returns a non zero error code on failure. The
<a class="reference internal" href="#c.z8530_sync_txdma_close" title="z8530_sync_txdma_close"><code class="xref c c-func docutils literal"><span class="pre">z8530_sync_txdma_close()</span></code></a> function closes down the Z8530
interface from this mode.</p>
</div>
<div class="section" id="network-layer-functions">
<h2>Network Layer Functions<a class="headerlink" href="#network-layer-functions" title="Permalink to this headline">¶</a></h2>
<p>The Z8530 layer provides functions to queue packets for transmission.
The driver internally buffers the frame currently being transmitted and
one further frame (in order to keep back to back transmission running).
Any further buffering is up to the caller.</p>
<p>The function <a class="reference internal" href="#c.z8530_queue_xmit" title="z8530_queue_xmit"><code class="xref c c-func docutils literal"><span class="pre">z8530_queue_xmit()</span></code></a> takes a network buffer
in sk_buff format and queues it for transmission. The caller must
provide the entire packet with the exception of the bitstuffing and CRC.
This is normally done by the caller via the generic HDLC interface
layer. It returns 0 if the buffer has been queued and non zero values
for queue full. If the function accepts the buffer it becomes property
of the Z8530 layer and the caller should not free it.</p>
<p>The function <code class="xref c c-func docutils literal"><span class="pre">z8530_get_stats()</span></code> returns a pointer to an
internally maintained per interface statistics block. This provides most
of the interface code needed to implement the network layer get_stats
callback.</p>
</div>
<div class="section" id="porting-the-z8530-driver">
<h2>Porting The Z8530 Driver<a class="headerlink" href="#porting-the-z8530-driver" title="Permalink to this headline">¶</a></h2>
<p>The Z8530 driver is written to be portable. In DMA mode it makes
assumptions about the use of ISA DMA. These are probably warranted in
most cases as the Z85230 in particular was designed to glue to PC type
machines. The PIO mode makes no real assumptions.</p>
<p>Should you need to retarget the Z8530 driver to another architecture the
only code that should need changing are the port I/O functions. At the
moment these assume PC I/O port accesses. This may not be appropriate
for all platforms. Replacing <a class="reference internal" href="#c.z8530_read_port" title="z8530_read_port"><code class="xref c c-func docutils literal"><span class="pre">z8530_read_port()</span></code></a> and
<code class="docutils literal"><span class="pre">z8530_write_port</span></code> is intended to be all that is required to port
this driver layer.</p>
</div>
<div class="section" id="known-bugs-and-assumptions">
<h2>Known Bugs And Assumptions<a class="headerlink" href="#known-bugs-and-assumptions" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Interrupt Locking</dt>
<dd>The locking in the driver is done via the global cli/sti lock. This
makes for relatively poor SMP performance. Switching this to use a
per device spin lock would probably materially improve performance.</dd>
<dt>Occasional Failures</dt>
<dd>We have reports of occasional failures when run for very long
periods of time and the driver starts to receive junk frames. At the
moment the cause of this is not clear.</dd>
</dl>
</div>
<div class="section" id="public-functions-provided">
<h2>Public Functions Provided<a class="headerlink" href="#public-functions-provided" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.z8530_interrupt">
irqreturn_t <code class="descname">z8530_interrupt</code><span class="sig-paren">(</span>int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_interrupt" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle an interrupt from a Z8530</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt number</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>The Z8530 device that is interrupting.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A Z85[2]30 device has stuck its hand in the air for attention.
We scan both the channels on the chip for events and then call
the channel specific call backs for each channel that has events.
We have to use callback functions because the two channels can be
in different modes.</p>
<p>Locking is done for the handlers. Note that locking is done
at the chip level (the 5uS delay issue is per chip not per
channel). c-&gt;lock for both channels points to dev-&gt;lock</p>
</div></blockquote>
<dl class="function">
<dt id="c.z8530_sync_open">
int <code class="descname">z8530_sync_open</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_sync_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a Z8530 channel for PIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The network interface we are using</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel to open in synchronous PIO mode</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Switch a Z8530 into synchronous mode without DMA assist. We
raise the RTS/DTR and commence network operation.</div></blockquote>
<dl class="function">
<dt id="c.z8530_sync_close">
int <code class="descname">z8530_sync_close</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_sync_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a PIO Z8530 channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Network device to close</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to disassociate and move to idle</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Close down a Z8530 interface and switch its interrupt handlers
to discard future events.</div></blockquote>
<dl class="function">
<dt id="c.z8530_sync_dma_open">
int <code class="descname">z8530_sync_dma_open</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_sync_dma_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a Z8530 for DMA I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The network device to attach</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel to configure in sync DMA mode.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Set up a Z85x30 device for synchronous DMA in both directions. Two
ISA DMA channels must be available for this to work. We assume ISA
DMA driven I/O and PC limits on access.</div></blockquote>
<dl class="function">
<dt id="c.z8530_sync_dma_close">
int <code class="descname">z8530_sync_dma_close</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_sync_dma_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close down DMA I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Network device to detach</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to move into discard mode</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Shut down a DMA mode synchronous interface. Halt the DMA, and
free the buffers.</div></blockquote>
<dl class="function">
<dt id="c.z8530_sync_txdma_open">
int <code class="descname">z8530_sync_txdma_open</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_sync_txdma_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a Z8530 for TX driven DMA</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The network device to attach</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel to configure in sync DMA mode.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Set up a Z85x30 device for synchronous DMA transmission. One
ISA DMA channel must be available for this to work. The receive
side is run in PIO mode, but then it has the bigger FIFO.</div></blockquote>
<dl class="function">
<dt id="c.z8530_sync_txdma_close">
int <code class="descname">z8530_sync_txdma_close</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.net_device" title="net_device">net_device</a> *<em>&nbsp;dev</em>, struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_sync_txdma_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close down a TX driven DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">net_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Network device to detach</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to move into discard mode</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Shut down a DMA/PIO split mode synchronous interface. Halt the DMA,
and  free the buffers.</div></blockquote>
<dl class="function">
<dt id="c.z8530_describe">
void <code class="descname">z8530_describe</code><span class="sig-paren">(</span>struct z8530_dev *<em>&nbsp;dev</em>, char *<em>&nbsp;mapping</em>, unsigned long<em>&nbsp;io</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Uniformly describe a Z8530 port</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Z8530 device to describe</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>string holding mapping type (eg &#8220;I/O&#8221; or &#8220;Mem&#8221;)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">io</span></code></dt>
<dd>the port value in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Describe a Z8530 in a standard format. We must pass the I/O as
the port offset isn&#8217;t predictable. The main reason for this function
is to try and get a common format of report.</div></blockquote>
<dl class="function">
<dt id="c.z8530_init">
int <code class="descname">z8530_init</code><span class="sig-paren">(</span>struct z8530_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a Z8530 device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Z8530 device to initialise.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Configure up a Z8530/Z85C30 or Z85230 chip. We check the device
is present, identify the type and then program it to hopefully
keep quite and behave. This matters a lot, a Z8530 in the wrong
state will sometimes get into stupid modes generating 10Khz
interrupt streams and the like.</p>
<p>We set the interrupt handler up to discard any events, in case
we get them during reset or setp.</p>
<p>Return 0 for success, or a negative value indicating the problem
in errno form.</p>
</div></blockquote>
<dl class="function">
<dt id="c.z8530_shutdown">
int <code class="descname">z8530_shutdown</code><span class="sig-paren">(</span>struct z8530_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown a Z8530 device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The Z8530 chip to shutdown</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>We set the interrupt handlers to silence any interrupts. We then
reset the chip and wait 100uS to be sure the reset completed. Just
in case the caller then tries to do stuff.</p>
<p>This is called without the lock held</p>
</div></blockquote>
<dl class="function">
<dt id="c.z8530_channel_load">
int <code class="descname">z8530_channel_load</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em>, u8 *<em>&nbsp;rtable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_channel_load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load channel data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to configure</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">rtable</span></code></dt>
<dd>table of register, value pairs
FIXME: ioctl to allow user uploaded tables</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Load a Z8530 channel up from the system data. We use +16 to
indicate the &#8220;prime&#8221; registers. The value 255 terminates the
table.</div></blockquote>
<dl class="function">
<dt id="c.z8530_null_rx">
void <code class="descname">z8530_null_rx</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_null_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Discard a packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The channel the packet arrived on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>We point the receive handler at this function when idle. Instead
of processing the frames we get to throw them away.</div></blockquote>
<dl class="function">
<dt id="c.z8530_queue_xmit">
netdev_tx_t <code class="descname">z8530_queue_xmit</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em>, struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_queue_xmit" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a packet</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The channel to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The packet to kick down the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Queue a packet for transmission. Because we have rather
hard to hit interrupt latencies for the Z85230 per packet
even in DMA mode we do the flip to DMA buffer if needed here
not in the IRQ.</p>
<p>Called from the network code. The lock is not held at this
point.</p>
</div></blockquote>
</div>
<div class="section" id="internal-functions">
<h2>Internal Functions<a class="headerlink" href="#internal-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.z8530_read_port">
int <code class="descname">z8530_read_port</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_read_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Architecture specific interface function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">p</span></code></dt>
<dd>port to read</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Provided port access methods. The Comtrol SV11 requires no delays
between accesses and uses PC I/O. Some drivers may need a 5uS delay</p>
<p>In the longer term this should become an architecture specific
section so that this can become a generic driver interface for all
platforms. For now we only handle PC I/O ports with or without the
dread 5uS sanity delay.</p>
<p>The caller must hold sufficient locks to avoid violating the horrible
5uS delay rule.</p>
</div></blockquote>
<dl class="function">
<dt id="c.z8530_write_port">
void <code class="descname">z8530_write_port</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;p</em>, u8<em>&nbsp;d</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_write_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Architecture specific interface function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">p</span></code></dt>
<dd>port to write</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">d</span></code></dt>
<dd>value to write</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Write a value to a port with delays if need be. Note that the
caller must hold locks to avoid read/writes from other contexts
violating the 5uS rule</p>
<p>In the longer term this should become an architecture specific
section so that this can become a generic driver interface for all
platforms. For now we only handle PC I/O ports with or without the
dread 5uS sanity delay.</p>
</div></blockquote>
<dl class="function">
<dt id="c.read_zsreg">
u8 <code class="descname">read_zsreg</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em>, u8<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_zsreg" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a register from a Z85230</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to read from (2 per chip)</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">reg</span></code></dt>
<dd><p class="first">Register to read
FIXME: Use a spinlock.</p>
<p class="last">Most of the Z8530 registers are indexed off the control registers.
A read is done by writing to the control register and reading the
register back.  The caller must hold the lock</p>
</dd>
</dl>
<dl class="function">
<dt id="c.read_zsdata">
u8 <code class="descname">read_zsdata</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_zsdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the data port of a Z8530 channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel to read the data port from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The data port provides fast access to some things. We still
have all the 5uS delays to worry about.</div></blockquote>
<dl class="function">
<dt id="c.write_zsreg">
void <code class="descname">write_zsreg</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em>, u8<em>&nbsp;reg</em>, u8<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_zsreg" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to a Z8530 channel register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">reg</span></code></dt>
<dd>Register number</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">val</span></code></dt>
<dd>Value to write</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Write a value to an indexed register. The caller must hold the lock
to honour the irritating delay rules. We know about register 0
being fast to access.</p>
<p>Assumes c-&gt;lock is held.</p>
</div></blockquote>
<dl class="function">
<dt id="c.write_zsctrl">
void <code class="descname">write_zsctrl</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em>, u8<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_zsctrl" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to a Z8530 control register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">val</span></code></dt>
<dd>Value to write</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Write directly to the control register on the Z8530</div></blockquote>
<dl class="function">
<dt id="c.write_zsdata">
void <code class="descname">write_zsdata</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em>, u8<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_zsdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Write to a Z8530 control register</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">val</span></code></dt>
<dd>Value to write</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Write directly to the data register on the Z8530</div></blockquote>
<dl class="function">
<dt id="c.z8530_flush_fifo">
void <code class="descname">z8530_flush_fifo</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_flush_fifo" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush on chip RX FIFO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Channel to flush</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Flush the receive FIFO. There is no specific option for this, we
blindly read bytes and discard them. Reading when there is no data
is harmless. The 8530 has a 4 byte FIFO, the 85230 has 8 bytes.</p>
<p>All locking is handled for the caller. On return data may still be
present if it arrived during the flush.</p>
</div></blockquote>
<dl class="function">
<dt id="c.z8530_rtsdtr">
void <code class="descname">z8530_rtsdtr</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em>, int<em>&nbsp;set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_rtsdtr" title="Permalink to this definition">¶</a></dt>
<dd><p>Control the outgoing DTS/RTS line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel to control;</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">set</span></code></dt>
<dd>1 to set, 0 to clear</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Sets or clears DTR/RTS on the requested line. All locking is handled
by the caller. For now we assume all boards use the actual RTS/DTR
on the chip. Apparently one or two don&#8217;t. We&#8217;ll scream about them
later.</div></blockquote>
<dl class="function">
<dt id="c.z8530_rx">
void <code class="descname">z8530_rx</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a PIO receive event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to process</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Receive handler for receiving in PIO mode. This is much like the
async one but not quite the same or as complex</div></blockquote>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>Its intended that this handler can easily be separated from</dt>
<dd><p class="first">the main code to run realtime. That&#8217;ll be needed for some machines
(eg to ever clock 64kbits on a sparc ;)).</p>
<p>The RT_LOCK macros don&#8217;t do anything now. Keep the code covered
by them as short as possible in all circumstances - clocks cost
baud. The interrupt handler is assumed to be atomic w.r.t. to
other code - this is true in the RT case too.</p>
<p>We only cover the sync cases for this. If you want 2Mbit async
do it yourself but consider medical assistance first. This non DMA
synchronous mode is portable code. The DMA mode assumes PCI like
ISA DMA</p>
<p class="last">Called with the device lock held</p>
</dd>
</dl>
<dl class="function">
<dt id="c.z8530_tx">
void <code class="descname">z8530_tx</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a PIO transmit event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to process</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Z8530 transmit interrupt handler for the PIO mode. The basic
idea is to attempt to keep the FIFO fed. We fill as many bytes
in as possible, its quite possible that we won&#8217;t keep up with the
data rate otherwise.</div></blockquote>
<dl class="function">
<dt id="c.z8530_status">
void <code class="descname">z8530_status</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a PIO status exception</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>Z8530 channel to process</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>A status event occurred in PIO synchronous mode. There are several
reasons the chip will bother us here. A transmit underrun means we
failed to feed the chip fast enough and just broke a packet. A DCD
change is a line up or down.</div></blockquote>
<dl class="function">
<dt id="c.z8530_dma_rx">
void <code class="descname">z8530_dma_rx</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_dma_rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a DMA RX event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>Channel to handle</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Non bus mastering DMA interfaces for the Z8x30 devices. This
is really pretty PC specific. The DMA mode means that most receive
events are handled by the DMA hardware. We get a kick here only if
a frame ended.</div></blockquote>
<dl class="function">
<dt id="c.z8530_dma_tx">
void <code class="descname">z8530_dma_tx</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_dma_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a DMA TX event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>The Z8530 channel to handle</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>We have received an interrupt while doing DMA transmissions. It
shouldn&#8217;t happen. Scream loudly if it does.</div></blockquote>
<dl class="function">
<dt id="c.z8530_dma_status">
void <code class="descname">z8530_dma_status</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_dma_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a DMA status exception</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd><p class="first">Z8530 channel to process</p>
<p class="last">A status event occurred on the Z8530. We receive these for two reasons
when in DMA mode. Firstly if we finished a packet transfer we get one
and kick the next packet out. Secondly we may see a DCD change.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.z8530_rx_clear">
void <code class="descname">z8530_rx_clear</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_rx_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle RX events from a stopped chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to shut up</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Receive interrupt vectors for a Z8530 that is in &#8216;parked&#8217; mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.</div></blockquote>
<dl class="function">
<dt id="c.z8530_tx_clear">
void <code class="descname">z8530_tx_clear</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_tx_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle TX events from a stopped chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>Z8530 channel to shut up</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Transmit interrupt vectors for a Z8530 that is in &#8216;parked&#8217; mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.</div></blockquote>
<dl class="function">
<dt id="c.z8530_status_clear">
void <code class="descname">z8530_status_clear</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_status_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle status events from a stopped chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>Z8530 channel to shut up</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Status interrupt vectors for a Z8530 that is in &#8216;parked&#8217; mode.
For machines with PCI Z85x30 cards, or level triggered interrupts
(eg the MacII) we must clear the interrupt cause or die.</div></blockquote>
<dl class="function">
<dt id="c.z8530_tx_begin">
void <code class="descname">z8530_tx_begin</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_tx_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>Begin packet transmission</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The Z8530 channel to kick</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is the speed sensitive side of transmission. If we are called
and no buffer is being transmitted we commence the next buffer. If
nothing is queued we idle the sync.</div></blockquote>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>We are handling this code path in the interrupt path, keep it</dt>
<dd><p class="first">fast or bad things will happen.</p>
<p class="last">Called with the lock held.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.z8530_tx_done">
void <code class="descname">z8530_tx_done</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_tx_done" title="Permalink to this definition">¶</a></dt>
<dd><p>TX complete callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The channel that completed a transmit.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This is called when we complete a packet send. We wake the queue,
start the next packet going and then free the buffer of the existing
packet. This code is fairly timing sensitive.</p>
<p>Called with the register lock held.</p>
</div></blockquote>
<dl class="function">
<dt id="c.z8530_rx_done">
void <code class="descname">z8530_rx_done</code><span class="sig-paren">(</span>struct z8530_channel *<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.z8530_rx_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive completion callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">z8530_channel</span> <span class="pre">*</span> <span class="pre">c</span></code></dt>
<dd>The channel that completed a receive</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>A new packet is complete. Our goal here is to get back into receive
mode as fast as possible. On the Z85230 we could change to using
ESCC mode, but on the older chips we have no choice. We flip to the
new buffer immediately in DMA mode so that the DMA of the next
frame can occur while we are copying the previous buffer to an sk_buff</p>
<p>Called with the lock held</p>
</div></blockquote>
<dl class="function">
<dt id="c.spans_boundary">
int <code class="descname">spans_boundary</code><span class="sig-paren">(</span>struct <a class="reference internal" href="kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;skb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.spans_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Check a packet can be ISA DMA&#8217;d</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">skb</span></code></dt>
<dd>The buffer to check</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns true if the buffer cross a DMA boundary on a PC. The poor
thing can only DMA within a 64K block not across the edges of it.</div></blockquote>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="msg_zerocopy.html" class="btn btn-neutral float-right" title="MSG_ZEROCOPY" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="kapi.html" class="btn btn-neutral" title="Linux Networking and Network Devices APIs" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>