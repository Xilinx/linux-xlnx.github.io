

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Memory Management APIs &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="Core API Documentation" href="index.html"/>
        <link rel="next" title="GFP masks used from FS/IO context" href="gfp_mask-from-fs-io.html"/>
        <link rel="prev" title="Circular Buffers" href="circular-buffers.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kernel-api.html">The Linux Kernel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomic_ops.html">Semantics and Behavior of Atomic and Bitmask Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="cachetlb.html">Cache and TLB Flushing Under Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="refcount-vs-atomic.html">refcount_t API compared to atomic_t</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="idr.html">ID Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="flexible-arrays.html">Using flexible arrays in the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="genalloc.html">The genalloc/genpool subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="errseq.html">The errseq_t datatype</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-formats.html">How to get printk format specifiers right</a></li>
<li class="toctree-l3"><a class="reference internal" href="circular-buffers.html">Circular Buffers</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Memory Management APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#user-space-memory-access">User Space Memory Access</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-allocation-controls">Memory Allocation Controls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-slab-cache">The Slab Cache</a></li>
<li class="toctree-l4"><a class="reference internal" href="#more-memory-management-functions">More Memory Management Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="gfp_mask-from-fs-io.html">GFP masks used from FS/IO context</a></li>
<li class="toctree-l3"><a class="reference internal" href="timekeeping.html">ktime accessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="boot-time-mm.html">Boot time memory management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
      
    <li>Memory Management APIs</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/core-api/mm-api.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="memory-management-apis">
<h1>Memory Management APIs<a class="headerlink" href="#memory-management-apis" title="Permalink to this headline">¶</a></h1>
<div class="section" id="user-space-memory-access">
<h2>User Space Memory Access<a class="headerlink" href="#user-space-memory-access" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.access_ok">
<code class="descname">access_ok</code><span class="sig-paren">(</span><em>type</em>, <em>addr</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.access_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a user space pointer is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Type of access: <code class="docutils literal"><span class="pre">VERIFY_READ</span></code> or <code class="docutils literal"><span class="pre">VERIFY_WRITE</span></code>.  Note that
<code class="docutils literal"><span class="pre">VERIFY_WRITE</span></code> is a superset of <code class="docutils literal"><span class="pre">VERIFY_READ</span></code> - if it is safe
to write to a block, it is always safe to read from it.</dd>
<dt><code class="docutils literal"><span class="pre">addr</span></code></dt>
<dd>User space pointer to start of block to check</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>Size of block to check</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>Checks if a pointer to a block of memory in user space is valid.</p>
<p>Returns true (nonzero) if the memory block may be valid, false (zero)
if it is definitely invalid.</p>
<p>Note that, depending on architecture, this function probably just
checks that the pointer is in the user space range - after calling
this function, memory access functions may still return -EFAULT.</p>
<dl class="function">
<dt id="c.get_user">
<code class="descname">get_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a simple variable from user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Variable to store result.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Source address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p>Returns zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
<dl class="function">
<dt id="c.put_user">
<code class="descname">put_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.put_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a simple value into user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Value to copy to user space.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Destination address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p>Returns zero on success, or -EFAULT on error.</p>
<dl class="function">
<dt id="c.__get_user">
<code class="descname">__get_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a simple variable from user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Variable to store result.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Source address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple variable from user space to kernel
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and the result of
dereferencing <strong>ptr</strong> must be assignable to <strong>x</strong> without a cast.</p>
<p>Caller must check the pointer with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this
function.</p>
<p>Returns zero on success, or -EFAULT on error.
On error, the variable <strong>x</strong> is set to zero.</p>
<dl class="function">
<dt id="c.__put_user">
<code class="descname">__put_user</code><span class="sig-paren">(</span><em>x</em>, <em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__put_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a simple value into user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>Value to copy to user space.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>Destination address, in user space.</dd>
</dl>
<p><strong>Context</strong></p>
<p>User context only. This function may sleep if pagefaults are
enabled.</p>
<p><strong>Description</strong></p>
<p>This macro copies a single simple value from kernel space to user
space.  It supports simple types like char and int, but not larger
data types like structures or arrays.</p>
<p><strong>ptr</strong> must have pointer-to-simple-variable type, and <strong>x</strong> must be assignable
to the result of dereferencing <strong>ptr</strong>.</p>
<p>Caller must check the pointer with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this
function.</p>
<p>Returns zero on success, or -EFAULT on error.</p>
<dl class="function">
<dt id="c.clear_user">
unsigned long <code class="descname">clear_user</code><span class="sig-paren">(</span>void __user *<em>&nbsp;to</em>, unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero a block of memory in user space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>Destination address, in user space.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>Number of bytes to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.</p>
<p>Returns number of bytes that could not be cleared.
On success, this will be zero.</p>
<dl class="function">
<dt id="c.__clear_user">
unsigned long <code class="descname">__clear_user</code><span class="sig-paren">(</span>void __user *<em>&nbsp;to</em>, unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__clear_user" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero a block of memory in user space, with less checking.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">to</span></code></dt>
<dd>Destination address, in user space.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>Number of bytes to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Zero a block of memory in user space.  Caller must check
the specified block with <a class="reference internal" href="#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> before calling this function.</p>
<p>Returns number of bytes that could not be cleared.
On success, this will be zero.</p>
<dl class="function">
<dt id="c.get_user_pages_fast">
int <code class="descname">get_user_pages_fast</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start</em>, int<em>&nbsp;nr_pages</em>, int<em>&nbsp;write</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_user_pages_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>pin user pages in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>starting user address</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>number of pages from start to pin</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">write</span></code></dt>
<dd>whether pages will be written to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>array that receives pointers to the pages pinned.
Should be at least nr_pages long.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns number of pages pinned. This may be fewer than the number
requested. If nr_pages is 0 or negative, returns 0. If no pages
were pinned, returns -errno.</p>
<p>get_user_pages_fast provides equivalent functionality to get_user_pages,
operating on current and current-&gt;mm, with force=0 and vma=NULL. However
unlike get_user_pages, it must be called without mmap_sem held.</p>
<p>get_user_pages_fast may take mmap_sem and page table locks, so no
assumptions can be made about lack of locking. get_user_pages_fast is to be
implemented in a way that is advantageous (vs <code class="xref c c-func docutils literal"><span class="pre">get_user_pages()</span></code>) when the
user memory area is already faulted in and present in ptes. However if the
pages have to be faulted in, it may turn out to be slightly slower so
callers need to carefully consider what to use. On many architectures,
get_user_pages_fast simply falls back to get_user_pages.</p>
</div>
<div class="section" id="memory-allocation-controls">
<h2>Memory Allocation Controls<a class="headerlink" href="#memory-allocation-controls" title="Permalink to this headline">¶</a></h2>
<p>Functions which need to allocate memory often use GFP flags to express
how that memory should be allocated. The GFP acronym stands for &#8220;get
free pages&#8221;, the underlying memory allocation function. Not every GFP
flag is allowed to every function which may allocate memory. Most
users will want to use a plain <code class="docutils literal"><span class="pre">GFP_KERNEL</span></code>.</p>
<div class="section" id="page-mobility-and-placement-hints">
<h3>Page mobility and placement hints<a class="headerlink" href="#page-mobility-and-placement-hints" title="Permalink to this headline">¶</a></h3>
<p>These flags provide hints about how mobile the page is. Pages with similar
mobility are placed within the same pageblocks to minimise problems due
to external fragmentation.</p>
<p><code class="docutils literal"><span class="pre">__GFP_MOVABLE</span></code> (also a zone modifier) indicates that the page can be
moved by page migration during memory compaction or can be reclaimed.</p>
<p><code class="docutils literal"><span class="pre">__GFP_RECLAIMABLE</span></code> is used for slab allocations that specify
SLAB_RECLAIM_ACCOUNT and whose pages can be freed via shrinkers.</p>
<p><code class="docutils literal"><span class="pre">__GFP_WRITE</span></code> indicates the caller intends to dirty the page. Where possible,
these pages will be spread between local zones to avoid all the dirty
pages being in one zone (fair zone allocation policy).</p>
<p><code class="docutils literal"><span class="pre">__GFP_HARDWALL</span></code> enforces the cpuset memory allocation policy.</p>
<p><code class="docutils literal"><span class="pre">__GFP_THISNODE</span></code> forces the allocation to be satisified from the requested
node with no fallbacks or placement policy enforcements.</p>
<p><code class="docutils literal"><span class="pre">__GFP_ACCOUNT</span></code> causes the allocation to be accounted to kmemcg.</p>
</div>
<div class="section" id="watermark-modifiers-controls-access-to-emergency-reserves">
<h3>Watermark modifiers &#8211; controls access to emergency reserves<a class="headerlink" href="#watermark-modifiers-controls-access-to-emergency-reserves" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">__GFP_HIGH</span></code> indicates that the caller is high-priority and that granting
the request is necessary before the system can make forward progress.
For example, creating an IO context to clean pages.</p>
<p><code class="docutils literal"><span class="pre">__GFP_ATOMIC</span></code> indicates that the caller cannot reclaim or sleep and is
high priority. Users are typically interrupt handlers. This may be
used in conjunction with <code class="docutils literal"><span class="pre">__GFP_HIGH</span></code></p>
<p><code class="docutils literal"><span class="pre">__GFP_MEMALLOC</span></code> allows access to all memory. This should only be used when
the caller guarantees the allocation will allow more memory to be freed
very shortly e.g. process exiting or swapping. Users either should
be the MM or co-ordinating closely with the VM (e.g. swap over NFS).</p>
<p><code class="docutils literal"><span class="pre">__GFP_NOMEMALLOC</span></code> is used to explicitly forbid access to emergency reserves.
This takes precedence over the <code class="docutils literal"><span class="pre">__GFP_MEMALLOC</span></code> flag if both are set.</p>
</div>
<div class="section" id="reclaim-modifiers">
<h3>Reclaim modifiers<a class="headerlink" href="#reclaim-modifiers" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">__GFP_IO</span></code> can start physical IO.</p>
<p><code class="docutils literal"><span class="pre">__GFP_FS</span></code> can call down to the low-level FS. Clearing the flag avoids the
allocator recursing into the filesystem which might already be holding
locks.</p>
<p><code class="docutils literal"><span class="pre">__GFP_DIRECT_RECLAIM</span></code> indicates that the caller may enter direct reclaim.
This flag can be cleared to avoid unnecessary delays when a fallback
option is available.</p>
<p><code class="docutils literal"><span class="pre">__GFP_KSWAPD_RECLAIM</span></code> indicates that the caller wants to wake kswapd when
the low watermark is reached and have it reclaim pages until the high
watermark is reached. A caller may wish to clear this flag when fallback
options are available and the reclaim is likely to disrupt the system. The
canonical example is THP allocation where a fallback is cheap but
reclaim/compaction may cause indirect stalls.</p>
<p><code class="docutils literal"><span class="pre">__GFP_RECLAIM</span></code> is shorthand to allow/forbid both direct and kswapd reclaim.</p>
<p>The default allocator behavior depends on the request size. We have a concept
of so called costly allocations (with order &gt; <code class="docutils literal"><span class="pre">PAGE_ALLOC_COSTLY_ORDER</span></code>).
!costly allocations are too essential to fail so they are implicitly
non-failing by default (with some exceptions like OOM victims might fail so
the caller still has to check for failures) while costly requests try to be
not disruptive and back off even without invoking the OOM killer.
The following three modifiers might be used to override some of these
implicit rules</p>
<p><code class="docutils literal"><span class="pre">__GFP_NORETRY</span></code>: The VM implementation will try only very lightweight
memory direct reclaim to get some memory under memory pressure (thus
it can sleep). It will avoid disruptive actions like OOM killer. The
caller must handle the failure which is quite likely to happen under
heavy memory pressure. The flag is suitable when failure can easily be
handled at small cost, such as reduced throughput</p>
<p><code class="docutils literal"><span class="pre">__GFP_RETRY_MAYFAIL</span></code>: The VM implementation will retry memory reclaim
procedures that have previously failed if there is some indication
that progress has been made else where.  It can wait for other
tasks to attempt high level approaches to freeing memory such as
compaction (which removes fragmentation) and page-out.
There is still a definite limit to the number of retries, but it is
a larger limit than with <code class="docutils literal"><span class="pre">__GFP_NORETRY</span></code>.
Allocations with this flag may fail, but only when there is
genuinely little unused memory. While these allocations do not
directly trigger the OOM killer, their failure indicates that
the system is likely to need to use the OOM killer soon.  The
caller must handle failure, but can reasonably do so by failing
a higher-level request, or completing it only in a much less
efficient manner.
If the allocation does fail, and the caller is in a position to
free some non-essential memory, doing so could benefit the system
as a whole.</p>
<p><code class="docutils literal"><span class="pre">__GFP_NOFAIL</span></code>: The VM implementation _must_ retry infinitely: the caller
cannot handle allocation failures. The allocation could block
indefinitely but will never return with failure. Testing for
failure is pointless.
New users should be evaluated carefully (and the flag should be
used only when there is no reasonable failure policy) but it is
definitely preferable to use the flag rather than opencode endless
loop around allocator.
Using this flag for costly allocations is _highly_ discouraged.</p>
</div>
</div>
<div class="section" id="the-slab-cache">
<h2>The Slab Cache<a class="headerlink" href="#the-slab-cache" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.kmalloc">
void * <code class="descname">kmalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate.</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc is the normal method of allocating memory
for objects smaller than page size in the kernel.</p>
<p>The <strong>flags</strong> argument may be one of:</p>
<p><code class="docutils literal"><span class="pre">GFP_USER</span></code> - Allocate memory on behalf of user.  May sleep.</p>
<p><code class="docutils literal"><span class="pre">GFP_KERNEL</span></code> - Allocate normal kernel ram.  May sleep.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">GFP_ATOMIC</span></code> - Allocation will not sleep.  May use emergency pools.</dt>
<dd>For example, use this inside interrupt handlers.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">GFP_HIGHUSER</span></code> - Allocate pages from high memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOIO</span></code> - Do not do any I/O at all while trying to get memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOFS</span></code> - Do not make any fs calls while trying to get memory.</p>
<p><code class="docutils literal"><span class="pre">GFP_NOWAIT</span></code> - Allocation will not sleep.</p>
<p><code class="docutils literal"><span class="pre">__GFP_THISNODE</span></code> - Allocate node-local memory only.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">GFP_DMA</span></code> - Allocation suitable for DMA.</dt>
<dd>Should only be used for <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> caches. Otherwise, use a
slab created with SLAB_DMA.</dd>
</dl>
<p>Also it is possible to set different flags by OR&#8217;ing
in one or more of the following additional <strong>flags</strong>:</p>
<p><code class="docutils literal"><span class="pre">__GFP_HIGH</span></code> - This allocation has high priority and may use emergency pools.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__GFP_NOFAIL</span></code> - Indicate that this allocation is in no way allowed to fail</dt>
<dd>(think twice before using).</dd>
<dt><code class="docutils literal"><span class="pre">__GFP_NORETRY</span></code> - If memory is not immediately available,</dt>
<dd>then give up at once.</dd>
</dl>
<p><code class="docutils literal"><span class="pre">__GFP_NOWARN</span></code> - If allocation fails, don&#8217;t issue any warnings.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__GFP_RETRY_MAYFAIL</span></code> - Try really hard to succeed the allocation but fail</dt>
<dd>eventually.</dd>
</dl>
<p>There are other flags available as well, but these are not intended
for general use, and so are not documented here. For a full list of
potential flags, always refer to linux/gfp.h.</p>
<dl class="function">
<dt id="c.kmalloc_array">
void * <code class="descname">kmalloc_array</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmalloc_array" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory for an array.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of elements.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>element size.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kcalloc">
void * <code class="descname">kcalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;n</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kcalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory for an array. The memory is set to zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of elements.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>element size.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kzalloc">
void * <code class="descname">kzalloc</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory. The memory is set to zero.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
</dl>
<dl class="function">
<dt id="c.kzalloc_node">
void * <code class="descname">kzalloc_node</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kzalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed memory from a particular memory node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>how many bytes of memory are required.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>the type of memory to allocate (see kmalloc).</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>memory node from which to allocate</dd>
</dl>
<dl class="function">
<dt id="c.kmem_cache_alloc">
void * <code class="descname">kmem_cache_alloc</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, gfp_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache to allocate from.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an object from this cache.  The flags are only relevant
if the cache has no available objects.</p>
<dl class="function">
<dt id="c.kmem_cache_alloc_node">
void * <code class="descname">kmem_cache_alloc_node</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;nodeid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_alloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate an object on the specified node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache to allocate from.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>See <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nodeid</span></code></dt>
<dd>node number of the target node.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Identical to kmem_cache_alloc but it will allocate memory on the given
node, which can improve the performance for cpu bound structures.</p>
<p>Fallback to other node is possible if __GFP_THISNODE is not set.</p>
<dl class="function">
<dt id="c.kmem_cache_free">
void <code class="descname">kmem_cache_free</code><span class="sig-paren">(</span>struct kmem_cache *<em>&nbsp;cachep</em>, void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmem_cache_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocate an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmem_cache</span> <span class="pre">*</span> <span class="pre">cachep</span></code></dt>
<dd>The cache the allocation was from.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>The previously allocated object.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free an object which was previously allocated from this
cache.</p>
<dl class="function">
<dt id="c.kfree">
void <code class="descname">kfree</code><span class="sig-paren">(</span>const void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree" title="Permalink to this definition">¶</a></dt>
<dd><p>free previously allocated memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>pointer returned by kmalloc.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>objp</strong> is NULL, no operation is performed.</p>
<p>Don&#8217;t free memory not originally allocated by <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a>
or you will run into trouble.</p>
<dl class="function">
<dt id="c.ksize">
size_t <code class="descname">ksize</code><span class="sig-paren">(</span>const void *<em>&nbsp;objp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ksize" title="Permalink to this definition">¶</a></dt>
<dd><p>get the actual amount of memory allocated for a given object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">objp</span></code></dt>
<dd>Pointer to the object</dd>
</dl>
<p><strong>Description</strong></p>
<p>kmalloc may internally round up allocations and return more memory
than requested. <a class="reference internal" href="#c.ksize" title="ksize"><code class="xref c c-func docutils literal"><span class="pre">ksize()</span></code></a> can be used to determine the actual amount of
memory allocated. The caller may use this additional memory, even though
a smaller amount of memory was initially specified with the kmalloc call.
The caller must guarantee that objp points to a valid object previously
allocated with either <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> or <a class="reference internal" href="#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal"><span class="pre">kmem_cache_alloc()</span></code></a>. The object
must not be freed during the duration of the call.</p>
<dl class="function">
<dt id="c.kfree_const">
void <code class="descname">kfree_const</code><span class="sig-paren">(</span>const void *<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_const" title="Permalink to this definition">¶</a></dt>
<dd><p>conditionally free memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">x</span></code></dt>
<dd>pointer to the memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function calls kfree only if <strong>x</strong> is not in .rodata section.</p>
<dl class="function">
<dt id="c.kvmalloc_node">
void * <code class="descname">kvmalloc_node</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;flags</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kvmalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the request.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">flags</span></code></dt>
<dd>gfp mask for the allocation - must be compatible (superset) with GFP_KERNEL.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node to allocate from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses kmalloc to get the memory but if the allocation fails then falls back
to the vmalloc allocator. Use kvfree for freeing the memory.</p>
<p>Reclaim modifiers - __GFP_NORETRY and __GFP_NOFAIL are not supported.
__GFP_RETRY_MAYFAIL is supported, and it should be used only if kmalloc is
preferable to the vmalloc fallback, due to visible performance drawbacks.</p>
<p>Please note that any use of gfp flags outside of GFP_KERNEL is careful to not
fall back to vmalloc.</p>
<dl class="function">
<dt id="c.kvfree">
void <code class="descname">kvfree</code><span class="sig-paren">(</span>const void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kvfree" title="Permalink to this definition">¶</a></dt>
<dd><p>Free memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Pointer to allocated memory.</dd>
</dl>
<p><strong>Description</strong></p>
<p>kvfree frees memory allocated by any of <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code></a>, <a class="reference internal" href="#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> or <code class="xref c c-func docutils literal"><span class="pre">kvmalloc()</span></code>.
It is slightly more efficient to use <a class="reference internal" href="#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a> or <a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal"><span class="pre">vfree()</span></code></a> if you are certain
that you know which one to use.</p>
<p><strong>Context</strong></p>
<p>Any context except NMI.</p>
</div>
<div class="section" id="more-memory-management-functions">
<h2>More Memory Management Functions<a class="headerlink" href="#more-memory-management-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.read_cache_pages">
int <code class="descname">read_cache_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct list_head *<em>&nbsp;pages</em>, int (*filler) (void<em>&nbsp;*</em>, struct page<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>populate an address space with some pages &amp; start reads against them</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">pages</span></code></dt>
<dd>The address of a list_head which contains the target pages.  These
pages have their -&gt;index populated and are otherwise uninitialised.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*)</span> <span class="pre">filler</span></code></dt>
<dd>callback routine for filling a single page.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private data for the callback routine.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hides the details of the LRU cache etc from the filesystems.</p>
<dl class="function">
<dt id="c.page_cache_sync_readahead">
void <code class="descname">page_cache_sync_readahead</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct file_ra_state *<em>&nbsp;ra</em>, struct file *<em>&nbsp;filp</em>, pgoff_t<em>&nbsp;offset</em>, unsigned long<em>&nbsp;req_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_sync_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>generic file readahead</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which holds the pagecache and I/O vectors</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*</span> <span class="pre">ra</span></code></dt>
<dd>file_ra_state which holds the readahead state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>passed on to -&gt;:c:func:<cite>readpage()</cite> and -&gt;:c:func:<cite>readpages()</cite></dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>start offset into <strong>mapping</strong>, in pagecache page-sized units</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_size</span></code></dt>
<dd>hint: total size of the read which the caller is performing in
pagecache pages</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_sync_readahead" title="page_cache_sync_readahead"><code class="xref c c-func docutils literal"><span class="pre">page_cache_sync_readahead()</span></code></a> should be called when a cache miss happened:
it will submit the read.  The readahead logic may decide to piggyback more
pages onto the read request if access patterns suggest it will improve
performance.</p>
<dl class="function">
<dt id="c.page_cache_async_readahead">
void <code class="descname">page_cache_async_readahead</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct file_ra_state *<em>&nbsp;ra</em>, struct file *<em>&nbsp;filp</em>, struct page *<em>&nbsp;page</em>, pgoff_t<em>&nbsp;offset</em>, unsigned long<em>&nbsp;req_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_async_readahead" title="Permalink to this definition">¶</a></dt>
<dd><p>file readahead for marked pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which holds the pagecache and I/O vectors</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_ra_state</span> <span class="pre">*</span> <span class="pre">ra</span></code></dt>
<dd>file_ra_state which holds the readahead state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>passed on to -&gt;:c:func:<cite>readpage()</cite> and -&gt;:c:func:<cite>readpages()</cite></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page at <strong>offset</strong> which has the PG_readahead flag set</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>start offset into <strong>mapping</strong>, in pagecache page-sized units</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">req_size</span></code></dt>
<dd>hint: total size of the read which the caller is performing in
pagecache pages</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.page_cache_async_readahead" title="page_cache_async_readahead"><code class="xref c c-func docutils literal"><span class="pre">page_cache_async_readahead()</span></code></a> should be called when a page is used which
has the PG_readahead flag; this is a marker to suggest that the application
has used up enough of the readahead window that we should start pulling in
more pages.</p>
<dl class="function">
<dt id="c.delete_from_page_cache">
void <code class="descname">delete_from_page_cache</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.delete_from_page_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>delete page from page cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page which the kernel is trying to remove from page cache</dd>
</dl>
<p><strong>Description</strong></p>
<p>This must be called only on pages that have been verified to be in the page
cache and locked.  It will never put the page into the free list, the caller
has a reference on the page.</p>
<dl class="function">
<dt id="c.filemap_flush">
int <code class="descname">filemap_flush</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>mostly a non-blocking flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>target address_space</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a mostly non-blocking flush.  Not suitable for data-integrity
purposes - I/O may not be started against all dirty pages.</p>
<dl class="function">
<dt id="c.filemap_range_has_page">
bool <code class="descname">filemap_range_has_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;start_byte</em>, loff_t<em>&nbsp;end_byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_range_has_page" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a page exists in range.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space within which to check</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find at least one page in the range supplied, usually used to check if
direct writing in this range will trigger a writeback.</p>
<dl class="function">
<dt id="c.filemap_fdatawait_range">
int <code class="descname">filemap_fdatawait_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;start_byte</em>, loff_t<em>&nbsp;end_byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to wait for</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
in the given range and wait for all of them.  Check error status of
the address space and return it.</p>
<p>Since the error status of the address space is cleared by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<dl class="function">
<dt id="c.file_fdatawait_range">
int <code class="descname">file_fdatawait_range</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;start_byte</em>, loff_t<em>&nbsp;end_byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_fdatawait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback to complete</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file pointing to address space structure to wait for</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">start_byte</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">end_byte</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the address space that file
refers to, in the given range and wait for all of them.  Check error
status of the address space vs. the file-&gt;f_wb_err cursor and return it.</p>
<p>Since the error status of the file is advanced by this function,
callers are responsible for checking the return value and handling and/or
reporting the error.</p>
<dl class="function">
<dt id="c.filemap_fdatawait_keep_errors">
int <code class="descname">filemap_fdatawait_keep_errors</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fdatawait_keep_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback without clearing errors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of under-writeback pages of the given address space
and wait for all of them.  Unlike <code class="xref c c-func docutils literal"><span class="pre">filemap_fdatawait()</span></code>, this function
does not clear error status of the address space.</p>
<p>Use this function if callers don&#8217;t handle errors themselves.  Expected
call sites are system-wide / filesystem-wide data flushers: e.g. sync(2),
fsfreeze(8)</p>
<dl class="function">
<dt id="c.filemap_write_and_wait_range">
int <code class="descname">filemap_write_and_wait_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_write_and_wait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space for the pages</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<dl class="function">
<dt id="c.file_check_and_advance_wb_err">
int <code class="descname">file_check_and_advance_wb_err</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_check_and_advance_wb_err" title="Permalink to this definition">¶</a></dt>
<dd><p>report wb error (if any) that was previously and advance wb_err to current one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>struct file on which the error is being reported</dd>
</dl>
<p><strong>Description</strong></p>
<p>When userland calls fsync (or something like nfsd does the equivalent), we
want to report any writeback errors that occurred since the last fsync (or
since the file was opened if there haven&#8217;t been any).</p>
<p>Grab the wb_err from the mapping. If it matches what we have in the file,
then just quickly return 0. The file is all caught up.</p>
<p>If it doesn&#8217;t match, then take the mapping value, set the &#8220;seen&#8221; flag in
it and try to swap it into place. If it works, or another task beat us
to it with the new value, then update the f_wb_err and return the error
portion. The error at this point must be reported via proper channels
(a&#8217;la fsync, or NFS COMMIT operation, etc.).</p>
<p>While we handle mapping-&gt;wb_err with atomic operations, the f_wb_err
value is protected by the f_lock since we must ensure that it reflects
the latest value swapped in for this file descriptor.</p>
<dl class="function">
<dt id="c.file_write_and_wait_range">
int <code class="descname">file_write_and_wait_range</code><span class="sig-paren">(</span>struct file *<em>&nbsp;file</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.file_write_and_wait_range" title="Permalink to this definition">¶</a></dt>
<dd><p>write out &amp; wait on a file range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file pointing to address_space with pages</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset in bytes where the range starts</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset in bytes where the range ends (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write out and wait upon file offsets lstart-&gt;lend, inclusive.</p>
<p>Note that <strong>lend</strong> is inclusive (describes the last byte to be written) so
that this function can be used to write to the very end-of-file (end = -1).</p>
<p>After writing out and waiting on the data, we check and advance the
f_wb_err cursor to the latest value, and return any errors detected there.</p>
<dl class="function">
<dt id="c.replace_page_cache_page">
int <code class="descname">replace_page_cache_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;old</em>, struct page *<em>&nbsp;new</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.replace_page_cache_page" title="Permalink to this definition">¶</a></dt>
<dd><p>replace a pagecache page with a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>page to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>page to replace with</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function replaces a page in the pagecache with a new one.  On
success it acquires the pagecache reference for the new page and
drops it for the old page.  Both the old and new pages must be
locked.  This function does not add the new page to the LRU, the
caller must do that.</p>
<p>The remove + add is atomic.  The only way this function can fail is
memory allocation failure.</p>
<dl class="function">
<dt id="c.add_to_page_cache_locked">
int <code class="descname">add_to_page_cache_locked</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_to_page_cache_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>add a locked page to the pagecache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page&#8217;s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>page index</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>page allocation mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to add a page to the pagecache. It must be locked.
This function does not add the page to the LRU.  The caller must do that.</p>
<dl class="function">
<dt id="c.add_page_wait_queue">
void <code class="descname">add_page_wait_queue</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, wait_queue_entry_t *<em>&nbsp;waiter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_page_wait_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an arbitrary waiter to a page&#8217;s wait queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>Page defining the wait queue of interest</dd>
<dt><code class="docutils literal"><span class="pre">wait_queue_entry_t</span> <span class="pre">*</span> <span class="pre">waiter</span></code></dt>
<dd>Waiter to add to the queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an arbitrary <strong>waiter</strong> to the wait queue for the nominated <strong>page</strong>.</p>
<dl class="function">
<dt id="c.unlock_page">
void <code class="descname">unlock_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unlock_page" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock a locked page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlocks the page and wakes up sleepers in <code class="xref c c-func docutils literal"><span class="pre">___wait_on_page_locked()</span></code>.
Also wakes sleepers in <code class="xref c c-func docutils literal"><span class="pre">wait_on_page_writeback()</span></code> because the wakeup
mechanism between PageLocked pages and PageWriteback pages is shared.
But that&#8217;s OK - sleepers in <code class="xref c c-func docutils literal"><span class="pre">wait_on_page_writeback()</span></code> just go back to sleep.</p>
<p>Note that this depends on PG_waiters being the sign bit in the byte
that contains PG_locked - thus the <code class="xref c c-func docutils literal"><span class="pre">BUILD_BUG_ON()</span></code>. That allows us to
clear the PG_locked bit and test PG_waiters at the same time fairly
portably (architectures that do LL/SC can test any bit, while x86 can
test the sign bit).</p>
<dl class="function">
<dt id="c.end_page_writeback">
void <code class="descname">end_page_writeback</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.end_page_writeback" title="Permalink to this definition">¶</a></dt>
<dd><p>end writeback against a page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page</dd>
</dl>
<dl class="function">
<dt id="c.__lock_page">
void <code class="descname">__lock_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;__page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__lock_page" title="Permalink to this definition">¶</a></dt>
<dd><p>get a lock on the page, assuming we need to sleep to get it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">__page</span></code></dt>
<dd>the page to lock</dd>
</dl>
<dl class="function">
<dt id="c.page_cache_next_hole">
pgoff_t <code class="descname">page_cache_next_hole</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned long<em>&nbsp;max_scan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_next_hole" title="Permalink to this definition">¶</a></dt>
<dd><p>find the next hole (not-present entry)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt>
<dd>maximum range to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the set [index, min(index+max_scan-1, MAX_INDEX)] for the
lowest indexed hole.</p>
<p><strong>Return</strong></p>
<p>the index of the hole if found, otherwise returns an index
outside of the set specified (in which case &#8216;return - index &gt;=
max_scan&#8217; will be true). In rare cases of index wrap-around, 0 will
be returned.</p>
<p>page_cache_next_hole may be called under rcu_read_lock. However,
like radix_tree_gang_lookup, this will not atomically search a
snapshot of the tree at a single point in time. For example, if a
hole is created at index 5, then subsequently a hole is created at
index 10, page_cache_next_hole covering both indexes may return 10
if called under rcu_read_lock.</p>
<dl class="function">
<dt id="c.page_cache_prev_hole">
pgoff_t <code class="descname">page_cache_prev_hole</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned long<em>&nbsp;max_scan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.page_cache_prev_hole" title="Permalink to this definition">¶</a></dt>
<dd><p>find the prev hole (not-present entry)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_scan</span></code></dt>
<dd>maximum range to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search backwards in the range [max(index-max_scan+1, 0), index] for
the first hole.</p>
<p><strong>Return</strong></p>
<p>the index of the hole if found, otherwise returns an index
outside of the set specified (in which case &#8216;index - return &gt;=
max_scan&#8217; will be true). In rare cases of wrap-around, ULONG_MAX
will be returned.</p>
<p>page_cache_prev_hole may be called under rcu_read_lock. However,
like radix_tree_gang_lookup, this will not atomically search a
snapshot of the tree at a single point in time. For example, if a
hole is created at index 10, then subsequently a hole is created at
index 5, page_cache_prev_hole covering both indexes may return 5 if
called under rcu_read_lock.</p>
<dl class="function">
<dt id="c.find_get_entry">
struct page * <code class="descname">find_get_entry</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>find and get a page cache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page cache index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned with an increased refcount.</p>
<p>If the slot holds a shadow entry of a previously evicted page, or a
swap entry from shmem/tmpfs, it is returned.</p>
<p>Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.find_lock_entry">
struct page * <code class="descname">find_lock_entry</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_lock_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>locate, pin and lock a page cache entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page cache index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.  If there is a
page cache page, it is returned locked and with an increased
refcount.</p>
<p>If the slot holds a shadow entry of a previously evicted page, or a
swap entry from shmem/tmpfs, it is returned.</p>
<p>Otherwise, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<p><a class="reference internal" href="#c.find_lock_entry" title="find_lock_entry"><code class="xref c c-func docutils literal"><span class="pre">find_lock_entry()</span></code></a> may sleep.</p>
<dl class="function">
<dt id="c.pagecache_get_page">
struct page * <code class="descname">pagecache_get_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;offset</em>, int<em>&nbsp;fgp_flags</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pagecache_get_page" title="Permalink to this definition">¶</a></dt>
<dd><p>find and get a page reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">offset</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fgp_flags</span></code></dt>
<dd>PCG flags</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>gfp mask to use for the page cache data page allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the page cache slot at <strong>mapping</strong> &amp; <strong>offset</strong>.</p>
<p>PCG flags modify how the page is returned.</p>
<p><strong>fgp_flags</strong> can be:</p>
<ul class="simple">
<li>FGP_ACCESSED: the page will be marked accessed</li>
<li>FGP_LOCK: Page is return locked</li>
<li>FGP_CREAT: If page is not present then a new page is allocated using
<strong>gfp_mask</strong> and added to the page cache and the VM&#8217;s LRU
list. The page is returned locked and with an increased
refcount. Otherwise, NULL is returned.</li>
</ul>
<p>If FGP_LOCK or FGP_CREAT are specified then the function may sleep even
if the GFP flags specified for FGP_CREAT are atomic.</p>
<p>If there is a page cache page, it is returned with an increased refcount.</p>
<dl class="function">
<dt id="c.find_get_pages_contig">
unsigned <code class="descname">find_get_pages_contig</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, unsigned int<em>&nbsp;nr_pages</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_pages_contig" title="Permalink to this definition">¶</a></dt>
<dd><p>gang contiguous pagecache lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>The address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>The starting page index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>The maximum number of pages</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>Where the resulting pages are placed</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.find_get_pages_contig" title="find_get_pages_contig"><code class="xref c c-func docutils literal"><span class="pre">find_get_pages_contig()</span></code></a> works exactly like <code class="xref c c-func docutils literal"><span class="pre">find_get_pages()</span></code>, except
that the returned number of pages are guaranteed to be contiguous.</p>
<p><a class="reference internal" href="#c.find_get_pages_contig" title="find_get_pages_contig"><code class="xref c c-func docutils literal"><span class="pre">find_get_pages_contig()</span></code></a> returns the number of pages which were found.</p>
<dl class="function">
<dt id="c.find_get_pages_range_tag">
unsigned <code class="descname">find_get_pages_range_tag</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t *<em>&nbsp;index</em>, pgoff_t<em>&nbsp;end</em>, int<em>&nbsp;tag</em>, unsigned int<em>&nbsp;nr_pages</em>, struct page **<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_pages_range_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find and return pages in given range matching <strong>tag</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">*</span> <span class="pre">index</span></code></dt>
<dd>the starting page index</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>The final page index (inclusive)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>the tag index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>the maximum number of pages</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>where the resulting pages are placed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like find_get_pages, except we only return pages which are tagged with
<strong>tag</strong>.   We update <strong>index</strong> to index the next page for the traversal.</p>
<dl class="function">
<dt id="c.find_get_entries_tag">
unsigned <code class="descname">find_get_entries_tag</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, int<em>&nbsp;tag</em>, unsigned int<em>&nbsp;nr_entries</em>, struct page **<em>&nbsp;entries</em>, pgoff_t *<em>&nbsp;indices</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_get_entries_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find and return entries that match <strong>tag</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space to search</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the starting page cache index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>the tag index</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_entries</span></code></dt>
<dd>the maximum number of entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">entries</span></code></dt>
<dd>where the resulting entries are placed</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">*</span> <span class="pre">indices</span></code></dt>
<dd>the cache indices corresponding to the entries in <strong>entries</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Like find_get_entries, except we only return entries which are tagged with
<strong>tag</strong>.</p>
<dl class="function">
<dt id="c.generic_file_read_iter">
ssize_t <code class="descname">generic_file_read_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_read_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>generic filesystem read routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>kernel I/O control block</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>destination for the data read</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the &#8220;<code class="xref c c-func docutils literal"><span class="pre">read_iter()</span></code>&#8221; routine for all filesystems
that can use the page cache directly.</p>
<dl class="function">
<dt id="c.filemap_fault">
vm_fault_t <code class="descname">filemap_fault</code><span class="sig-paren">(</span>struct vm_fault *<em>&nbsp;vmf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.filemap_fault" title="Permalink to this definition">¶</a></dt>
<dd><p>read in file data for page fault handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_fault</span> <span class="pre">*</span> <span class="pre">vmf</span></code></dt>
<dd>struct vm_fault containing details of the fault</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.filemap_fault" title="filemap_fault"><code class="xref c c-func docutils literal"><span class="pre">filemap_fault()</span></code></a> is invoked via the vma operations vector for a
mapped memory region to read in file data during a page fault.</p>
<p>The goto&#8217;s are kind of ugly, but this streamlines the normal case of having
it in the page cache, and handles the special cases reasonably without
having a lot of duplicated code.</p>
<p>vma-&gt;vm_mm-&gt;mmap_sem must be held on entry.</p>
<p>If our return value has VM_FAULT_RETRY set, it&#8217;s because
<code class="xref c c-func docutils literal"><span class="pre">lock_page_or_retry()</span></code> returned 0.
The mmap_sem has usually been released in this case.
See <code class="xref c c-func docutils literal"><span class="pre">__lock_page_or_retry()</span></code> for the exception.</p>
<p>If our return value does not have VM_FAULT_RETRY set, the mmap_sem
has not been released.</p>
<p>We never return with VM_FAULT_RETRY and a bit from VM_FAULT_ERROR set.</p>
<dl class="function">
<dt id="c.read_cache_page">
struct page * <code class="descname">read_cache_page</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, int (*filler) (void<em>&nbsp;*</em>, struct page<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page" title="Permalink to this definition">¶</a></dt>
<dd><p>read into page cache, fill it if needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page&#8217;s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*)</span> <span class="pre">filler</span></code></dt>
<dd>function to perform the read</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>first arg to filler(data, page) function, often left as NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read into the page cache. If a page already exists, and <code class="xref c c-func docutils literal"><span class="pre">PageUptodate()</span></code> is
not set, try to fill the page and wait for it to become unlocked.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<dl class="function">
<dt id="c.read_cache_page_gfp">
struct page * <code class="descname">read_cache_page_gfp</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;index</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.read_cache_page_gfp" title="Permalink to this definition">¶</a></dt>
<dd><p>read into page cache, using specified page allocation flags.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the page&#8217;s address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">index</span></code></dt>
<dd>the page index</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the page allocator flags to use if allocating</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as &#8220;read_mapping_page(mapping, index, NULL)&#8221;, but with
any new page allocations done using the specified allocation flags.</p>
<p>If the page does not get brought uptodate, return -EIO.</p>
<dl class="function">
<dt id="c.__generic_file_write_iter">
ssize_t <code class="descname">__generic_file_write_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__generic_file_write_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>IO state structure (file, offset, etc.)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>iov_iter with data to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does all the work needed for actually writing data to a
file. It does all basic checks, removes SUID from the file, updates
modification times and calls proper subroutines depending on whether we
do direct IO or a standard buffered write.</p>
<p>It expects i_mutex to be grabbed unless we work on a block device or similar
object which does not need locking at all.</p>
<p>This function does <em>not</em> take care of syncing data in case of O_SYNC write.
A caller has to handle it. This is mainly due to the fact that we want to
avoid syncing under i_mutex.</p>
<dl class="function">
<dt id="c.generic_file_write_iter">
ssize_t <code class="descname">generic_file_write_iter</code><span class="sig-paren">(</span>struct kiocb *<em>&nbsp;iocb</em>, struct iov_iter *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_file_write_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>write data to a file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kiocb</span> <span class="pre">*</span> <span class="pre">iocb</span></code></dt>
<dd>IO state structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>iov_iter with data to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a wrapper around <a class="reference internal" href="#c.__generic_file_write_iter" title="__generic_file_write_iter"><code class="xref c c-func docutils literal"><span class="pre">__generic_file_write_iter()</span></code></a> to be used by most
filesystems. It takes care of syncing the file in case of O_SYNC file
and acquires i_mutex as needed.</p>
<dl class="function">
<dt id="c.try_to_release_page">
int <code class="descname">try_to_release_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_release_page" title="Permalink to this definition">¶</a></dt>
<dd><p>release old fs-specific metadata on a page</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page which the kernel is trying to free</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (and I/O mode)</dd>
</dl>
<p><strong>Description</strong></p>
<p>The address_space is to try to release any data against the page
(presumably at page-&gt;private).  If the release was successful, return &#8216;1&#8217;.
Otherwise return zero.</p>
<p>This may also be called if PG_fscache is set on a page, indicating that the
page is known to the local caching routines.</p>
<p>The <strong>gfp_mask</strong> argument specifies whether I/O may be performed to release
this page (__GFP_IO), and whether the call may block (__GFP_RECLAIM &amp; __GFP_FS).</p>
<dl class="function">
<dt id="c.zap_vma_ptes">
void <code class="descname">zap_vma_ptes</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;address</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.zap_vma_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ptes mapping the vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vm_area_struct holding ptes to be zapped</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt>
<dd>starting address of pages to zap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>number of bytes to zap</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only unmaps ptes assigned to VM_PFNMAP vmas.</p>
<p>The entire address range must be fully contained within the vma.</p>
<dl class="function">
<dt id="c.vm_insert_page">
int <code class="descname">vm_insert_page</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_page" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single page into user vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>source kernel page</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allows drivers to insert individual pages they&#8217;ve allocated
into a user vma.</p>
<p>The page has to be a nice clean _individual_ kernel allocation.
If you allocate a compound page, you need to have marked it as
such (__GFP_COMP), or manually just split the page up yourself
(see <code class="xref c c-func docutils literal"><span class="pre">split_page()</span></code>).</p>
<p>NOTE! Traditionally this was done with &#8220;<a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a>&#8221; which
took an arbitrary page protection parameter. This doesn&#8217;t allow
that. Your vma protection will have to be set up correctly, which
means that if you want a shared writable mapping, you&#8217;d better
ask for a shared writable mapping!</p>
<p>The page does not need to be reserved.</p>
<p>Usually this function is called from f_op-&gt;:c:func:<cite>mmap()</cite> handler
under mm-&gt;mmap_sem write-lock, so it can change vma-&gt;vm_flags.
Caller must set VM_MIXEDMAP on vma if it wants to call this
function from other places, for example from page-fault handler.</p>
<dl class="function">
<dt id="c.vm_insert_pfn">
int <code class="descname">vm_insert_pfn</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single pfn into user vma</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>source kernel pfn</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to vm_insert_page, this allows drivers to insert individual pages
they&#8217;ve allocated into a user vma. Same comments apply.</p>
<p>This function should only be called from a vm_ops-&gt;fault handler, and
in that case the handler should return NULL.</p>
<p>vma cannot be a COW mapping.</p>
<p>As this is called only for pages that do not currently exist, we
do not need to flush old virtual caches or the TLB.</p>
<dl class="function">
<dt id="c.vm_insert_pfn_prot">
int <code class="descname">vm_insert_pfn_prot</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em>, pgprot_t<em>&nbsp;pgprot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_insert_pfn_prot" title="Permalink to this definition">¶</a></dt>
<dd><p>insert single pfn into user vma with specified pgprot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address of this page</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>source kernel pfn</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">pgprot</span></code></dt>
<dd>pgprot flags for the inserted page</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is exactly like vm_insert_pfn, except that it allows drivers to
to override pgprot on a per-page basis.</p>
<p>This only makes sense for IO mappings, and it makes no sense for
cow mappings.  In general, using multiple vmas is preferable;
vm_insert_pfn_prot should only be used if using multiple VMAs is
impractical.</p>
<dl class="function">
<dt id="c.remap_pfn_range">
int <code class="descname">remap_pfn_range</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;size</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_pfn_range" title="Permalink to this definition">¶</a></dt>
<dd><p>remap kernel memory to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>target user address to start at</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>physical address of kernel memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of map area</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>page protection flags for this mapping</dd>
</dl>
<p><strong>Note</strong></p>
<p>this is only safe if the mm semaphore is held when called.</p>
<dl class="function">
<dt id="c.vm_iomap_memory">
int <code class="descname">vm_iomap_memory</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, phys_addr_t<em>&nbsp;start</em>, unsigned long<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_iomap_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>remap memory to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>user vma to map to</dd>
<dt><code class="docutils literal"><span class="pre">phys_addr_t</span> <span class="pre">start</span></code></dt>
<dd>start of area</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt>
<dd>size of area</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified <code class="xref c c-func docutils literal"><span class="pre">io_remap_pfn_range()</span></code> for common driver use. The
driver just needs to give us the physical memory range to be mapped,
we&#8217;ll figure out the rest from the vma information.</p>
<p>NOTE! Some drivers might want to tweak vma-&gt;vm_page_prot first to get
whatever write-combining details or similar.</p>
<dl class="function">
<dt id="c.unmap_mapping_range">
void <code class="descname">unmap_mapping_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t const<em>&nbsp;holebegin</em>, loff_t const<em>&nbsp;holelen</em>, int<em>&nbsp;even_cows</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_mapping_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap the portion of all mmaps in the specified address_space corresponding to the specified byte range in the underlying file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address space containing mmaps to be unmapped.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holebegin</span></code></dt>
<dd>byte in first page to unmap, relative to the start of
the underlying file.  This will be rounded down to a PAGE_SIZE
boundary.  Note that this is different from <a class="reference internal" href="#c.truncate_pagecache" title="truncate_pagecache"><code class="xref c c-func docutils literal"><span class="pre">truncate_pagecache()</span></code></a>, which
must keep the partial page.  In contrast, we must get rid of
partial pages.</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">const</span> <span class="pre">holelen</span></code></dt>
<dd>size of prospective hole in bytes.  This will be rounded
up to a PAGE_SIZE boundary.  A holelen of zero truncates to the
end of the file.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">even_cows</span></code></dt>
<dd>1 when truncating a file, unmap even private COWed pages;
but 0 when invalidating pagecache, don&#8217;t throw away private data.</dd>
</dl>
<dl class="function">
<dt id="c.follow_pfn">
int <code class="descname">follow_pfn</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;address</em>, unsigned long *<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.follow_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>look up PFN at a user virtual address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>memory mapping</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">address</span></code></dt>
<dd>user virtual address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">pfn</span></code></dt>
<dd>location to store found PFN</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only IO mappings and raw PFN mappings are allowed.</p>
<p>Returns zero and the pfn at <strong>pfn</strong> on success, -ve otherwise.</p>
<dl class="function">
<dt id="c.vm_unmap_aliases">
void <code class="descname">vm_unmap_aliases</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_aliases" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap outstanding lazy aliases in the vmap layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vmap/vmalloc layer lazily flushes kernel virtual mappings primarily
to amortize TLB flushing overheads. What this means is that any page you
have now, may, in a former life, have been mapped into kernel virtual
address by the vmap layer and so there might be some CPUs with TLB entries
still referencing that page (additional to the regular 1:1 kernel mapping).</p>
<p>vm_unmap_aliases flushes all such lazy mappings. After it returns, we can
be sure that none of the pages we have control over will have any aliases
from the vmap layer.</p>
<dl class="function">
<dt id="c.vm_unmap_ram">
void <code class="descname">vm_unmap_ram</code><span class="sig-paren">(</span>const void *<em>&nbsp;mem</em>, unsigned int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_unmap_ram" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap linear kernel address space set up by vm_map_ram</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">mem</span></code></dt>
<dd>the pointer returned by vm_map_ram</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the count passed to that vm_map_ram call (cannot unmap partial)</dd>
</dl>
<dl class="function">
<dt id="c.vm_map_ram">
void * <code class="descname">vm_map_ram</code><span class="sig-paren">(</span>struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;count</em>, int<em>&nbsp;node</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vm_map_ram" title="Permalink to this definition">¶</a></dt>
<dd><p>map pages linearly into kernel virtual address (vmalloc space)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>an array of pointers to the pages to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pages</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>prefer to allocate data structures on this node</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>memory protection to use. PAGE_KERNEL for regular RAM</dd>
</dl>
<p><strong>Description</strong></p>
<p>If you use this function for less than VMAP_MAX_ALLOC pages, it could be
faster than vmap so it&#8217;s good.  But if you mix long-life and short-life
objects with <a class="reference internal" href="#c.vm_map_ram" title="vm_map_ram"><code class="xref c c-func docutils literal"><span class="pre">vm_map_ram()</span></code></a>, it could consume lots of address space through
fragmentation (especially on a 32bit machine).  You could see failures in
the end.  Please use this function for short-lived objects.</p>
<p><strong>Return</strong></p>
<p>a pointer to the address that has been mapped, or <code class="docutils literal"><span class="pre">NULL</span></code> on failure</p>
<dl class="function">
<dt id="c.unmap_kernel_range_noflush">
void <code class="descname">unmap_kernel_range_noflush</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_kernel_range_noflush" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap kernel VM area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>start of the VM area to unmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the VM area to unmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap PFN_UP(<strong>size</strong>) pages at <strong>addr</strong>.  The VM area <strong>addr</strong> and <strong>size</strong>
specify should have been allocated using <code class="xref c c-func docutils literal"><span class="pre">get_vm_area()</span></code> and its
friends.</p>
<p><strong>NOTE</strong></p>
<p>This function does NOT do any cache flushing.  The caller is
responsible for calling <code class="xref c c-func docutils literal"><span class="pre">flush_cache_vunmap()</span></code> on to-be-mapped areas
before calling this function and <code class="xref c c-func docutils literal"><span class="pre">flush_tlb_kernel_range()</span></code> after.</p>
<dl class="function">
<dt id="c.unmap_kernel_range">
void <code class="descname">unmap_kernel_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unmap_kernel_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap kernel VM area and flush cache and TLB</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>start of the VM area to unmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the VM area to unmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.unmap_kernel_range_noflush" title="unmap_kernel_range_noflush"><code class="xref c c-func docutils literal"><span class="pre">unmap_kernel_range_noflush()</span></code></a> but flushes vcache before
the unmapping and tlb after.</p>
<dl class="function">
<dt id="c.vfree">
void <code class="descname">vfree</code><span class="sig-paren">(</span>const void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vfree" title="Permalink to this definition">¶</a></dt>
<dd><p>release memory allocated by <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>memory base address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Free the virtually continuous memory area starting at <strong>addr</strong>, as
obtained from <a class="reference internal" href="#c.vmalloc" title="vmalloc"><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code></a>, <a class="reference internal" href="#c.vmalloc_32" title="vmalloc_32"><code class="xref c c-func docutils literal"><span class="pre">vmalloc_32()</span></code></a> or <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code>. If <strong>addr</strong> is
NULL, no operation is performed.</p>
<p>Must not be called in NMI context (strictly speaking, only if we don&#8217;t
have CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG, but making the calling
conventions for <a class="reference internal" href="#c.vfree" title="vfree"><code class="xref c c-func docutils literal"><span class="pre">vfree()</span></code></a> arch-depenedent would be a really bad idea)</p>
</div></blockquote>
<p><strong>NOTE</strong></p>
<p>assumes that the object at <strong>addr</strong> has a size &gt;= sizeof(llist_node)</p>
<dl class="function">
<dt id="c.vunmap">
void <code class="descname">vunmap</code><span class="sig-paren">(</span>const void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>release virtual mapping obtained by <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal"><span class="pre">vmap()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>memory base address</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Free the virtually contiguous memory area starting at <strong>addr</strong>,
which was created from the page array passed to <a class="reference internal" href="#c.vmap" title="vmap"><code class="xref c c-func docutils literal"><span class="pre">vmap()</span></code></a>.</p>
<p>Must not be called in interrupt context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.vmap">
void * <code class="descname">vmap</code><span class="sig-paren">(</span>struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;count</em>, unsigned long<em>&nbsp;flags</em>, pgprot_t<em>&nbsp;prot</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map an array of pages into virtually contiguous space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>array of page pointers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>number of pages to map</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>vm_area-&gt;flags</dd>
<dt><code class="docutils literal"><span class="pre">pgprot_t</span> <span class="pre">prot</span></code></dt>
<dd>page protection for the mapping</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Maps <strong>count</strong> pages from <strong>pages</strong> into contiguous kernel virtual
space.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc">
void * <code class="descname">vmalloc</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size
Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</div></blockquote>
<dl class="function">
<dt id="c.vzalloc">
void * <code class="descname">vzalloc</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vzalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory with zero fill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size
Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.
The memory allocated is set to zero.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc_user">
void * <code class="descname">vmalloc_user</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_user" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed virtually contiguous memory for userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The resulting memory area is zeroed so it can be mapped to userspace
without leaking data.</p>
<dl class="function">
<dt id="c.vmalloc_node">
void * <code class="descname">vmalloc_node</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory on a specific node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.</p>
<p>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc()</span></code> instead.</p>
</div></blockquote>
<dl class="function">
<dt id="c.vzalloc_node">
void * <code class="descname">vzalloc_node</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, int<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vzalloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate memory on a specific node with zero fill</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>numa node</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate enough pages to cover <strong>size</strong> from the page level
allocator and map them into contiguous kernel virtual space.
The memory allocated is set to zero.</p>
<p>For tight control over page level allocator and protection flags
use <code class="xref c c-func docutils literal"><span class="pre">__vmalloc_node()</span></code> instead.</p>
<dl class="function">
<dt id="c.vmalloc_32">
void * <code class="descname">vmalloc_32</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_32" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate virtually contiguous memory (32bit addressable)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Allocate enough 32bit PA addressable pages to cover <strong>size</strong> from the
page level allocator and map them into contiguous kernel virtual space.</div></blockquote>
<dl class="function">
<dt id="c.vmalloc_32_user">
void * <code class="descname">vmalloc_32_user</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmalloc_32_user" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate zeroed virtually contiguous 32bit memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>allocation size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The resulting memory area is 32bit addressable and zeroed so it can be
mapped to userspace without leaking data.</p>
<dl class="function">
<dt id="c.remap_vmalloc_range_partial">
int <code class="descname">remap_vmalloc_range_partial</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, unsigned long<em>&nbsp;uaddr</em>, void *<em>&nbsp;kaddr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_vmalloc_range_partial" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc pages to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma to cover</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">uaddr</span></code></dt>
<dd>target user address to start at</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">kaddr</span></code></dt>
<dd>virtual address of vmalloc kernel memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of map area</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -Exxx on failure</p>
<blockquote>
<div><p>This function checks that <strong>kaddr</strong> is a valid vmalloc&#8217;ed area,
and that it is big enough to cover the range starting at
<strong>uaddr</strong> in <strong>vma</strong>. Will return failure if that criteria isn&#8217;t
met.</p>
<p>Similar to <a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a> (see mm/memory.c)</p>
</div></blockquote>
<dl class="function">
<dt id="c.remap_vmalloc_range">
int <code class="descname">remap_vmalloc_range</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em>, void *<em>&nbsp;addr</em>, unsigned long<em>&nbsp;pgoff</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remap_vmalloc_range" title="Permalink to this definition">¶</a></dt>
<dd><p>map vmalloc pages to userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma to cover (map full range of vma)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>vmalloc memory</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt>
<dd>number of pages into addr before first page to map</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -Exxx on failure</p>
<blockquote>
<div><p>This function checks that addr is a valid vmalloc&#8217;ed area, and
that it is big enough to cover the vma. Will return failure if
that criteria isn&#8217;t met.</p>
<p>Similar to <a class="reference internal" href="#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a> (see mm/memory.c)</p>
</div></blockquote>
<dl class="function">
<dt id="c.alloc_vm_area">
struct vm_struct * <code class="descname">alloc_vm_area</code><span class="sig-paren">(</span>size_t<em>&nbsp;size</em>, pte_t **<em>&nbsp;ptes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_vm_area" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a range of kernel address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the area</dd>
<dt><code class="docutils literal"><span class="pre">pte_t</span> <span class="pre">**</span> <span class="pre">ptes</span></code></dt>
<dd>returns the PTEs for the address space</dd>
</dl>
<p><strong>Return</strong></p>
<p>NULL on failure, vm_struct on success</p>
<blockquote>
<div><p>This function reserves a range of kernel address space, and
allocates pagetables to map that range.  No actual mappings
are created.</p>
<p>If <strong>ptes</strong> is non-NULL, pointers to the PTEs (in init_mm)
allocated for the VM area are returned.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__get_pfnblock_flags_mask">
unsigned long <code class="descname">__get_pfnblock_flags_mask</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;end_bitidx</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_pfnblock_flags_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the requested group of flags for the pageblock_nr_pages block of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page within the block of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>The target page frame number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_bitidx</span></code></dt>
<dd>The last bit of interest to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>mask of bits that the caller is interested in</dd>
</dl>
<p><strong>Return</strong></p>
<p>pageblock_bits flags</p>
<dl class="function">
<dt id="c.set_pfnblock_flags_mask">
void <code class="descname">set_pfnblock_flags_mask</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em>, unsigned long<em>&nbsp;flags</em>, unsigned long<em>&nbsp;pfn</em>, unsigned long<em>&nbsp;end_bitidx</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_pfnblock_flags_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the requested group of flags for a pageblock_nr_pages block of pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page within the block of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>The flags to set</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pfn</span></code></dt>
<dd>The target page frame number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_bitidx</span></code></dt>
<dd>The last bit of interest</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>mask of bits that the caller is interested in</dd>
</dl>
<dl class="function">
<dt id="c.alloc_pages_exact_nid">
void * <code class="descname">alloc_pages_exact_nid</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_pages_exact_nid" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an exact number of physically-contiguous pages on a node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>the preferred node ID where memory should be allocated</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the number of bytes to allocate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP flags for the allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <code class="xref c c-func docutils literal"><span class="pre">alloc_pages_exact()</span></code>, but try to allocate on node nid first before falling
back.</p>
<dl class="function">
<dt id="c.nr_free_zone_pages">
unsigned long <code class="descname">nr_free_zone_pages</code><span class="sig-paren">(</span>int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_zone_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>The zone index of the highest zone</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_zone_pages" title="nr_free_zone_pages"><code class="xref c c-func docutils literal"><span class="pre">nr_free_zone_pages()</span></code></a> counts the number of counts pages which are beyond the
high watermark within all zones at or below a given zone index.  For each
zone, the number of pages is calculated as:</p>
<blockquote>
<div>nr_free_zone_pages = managed_pages - high_pages</div></blockquote>
<dl class="function">
<dt id="c.nr_free_pagecache_pages">
unsigned long <code class="descname">nr_free_pagecache_pages</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.nr_free_pagecache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>count number of pages beyond high watermark</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.nr_free_pagecache_pages" title="nr_free_pagecache_pages"><code class="xref c c-func docutils literal"><span class="pre">nr_free_pagecache_pages()</span></code></a> counts the number of pages which are beyond the
high watermark within all zones.</p>
<dl class="function">
<dt id="c.find_next_best_node">
int <code class="descname">find_next_best_node</code><span class="sig-paren">(</span>int<em>&nbsp;node</em>, nodemask_t *<em>&nbsp;used_node_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_next_best_node" title="Permalink to this definition">¶</a></dt>
<dd><p>find the next node that should appear in a given node&#8217;s fallback list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>node whose fallback list we&#8217;re appending</dd>
<dt><code class="docutils literal"><span class="pre">nodemask_t</span> <span class="pre">*</span> <span class="pre">used_node_mask</span></code></dt>
<dd>nodemask_t of already used nodes</dd>
</dl>
<p><strong>Description</strong></p>
<p>We use a number of factors to determine which is the next node that should
appear on a given node&#8217;s fallback list.  The node should not have appeared
already in <strong>node</strong>&#8216;s fallback list, and it should be the next closest node
according to the distance array (which contains arbitrary distance values
from each node to each node in the system), and should also prefer nodes
with no CPUs, since presumably they&#8217;ll have very little allocation pressure
on them otherwise.
It returns -1 if no node is found.</p>
<dl class="function">
<dt id="c.free_bootmem_with_active_regions">
void <code class="descname">free_bootmem_with_active_regions</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em>, unsigned long<em>&nbsp;max_low_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_bootmem_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Call memblock_free_early_nid for each active range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The node to free memory on. If MAX_NUMNODES, all nodes are freed.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max_low_pfn</span></code></dt>
<dd>The highest PFN that will be passed to memblock_free_early_nid</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an architecture guarantees that all ranges registered contain no holes
and may be freed, this this function may be used instead of calling
<code class="xref c c-func docutils literal"><span class="pre">memblock_free_early_nid()</span></code> manually.</p>
<dl class="function">
<dt id="c.sparse_memory_present_with_active_regions">
void <code class="descname">sparse_memory_present_with_active_regions</code><span class="sig-paren">(</span>int<em>&nbsp;nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sparse_memory_present_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Call memory_present for each active range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The node to call memory_present for. If MAX_NUMNODES, all nodes will be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If an architecture guarantees that all ranges registered contain no holes and may
be freed, this function may be used instead of calling <code class="xref c c-func docutils literal"><span class="pre">memory_present()</span></code> manually.</p>
<dl class="function">
<dt id="c.get_pfn_range_for_nid">
void <code class="descname">get_pfn_range_for_nid</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;nid</em>, unsigned long *<em>&nbsp;start_pfn</em>, unsigned long *<em>&nbsp;end_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_pfn_range_for_nid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the start and end page frames for a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>The nid to return the range for. If MAX_NUMNODES, the min and max PFN are returned.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">start_pfn</span></code></dt>
<dd>Passed by reference. On return, it will have the node start_pfn.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">end_pfn</span></code></dt>
<dd>Passed by reference. On return, it will have the node end_pfn.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the start and end page frame of a node based on information
provided by <code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>. If called for a node
with no available memory, a warning is printed and the start and end
PFNs will be 0.</p>
<dl class="function">
<dt id="c.absent_pages_in_range">
unsigned long <code class="descname">absent_pages_in_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start_pfn</em>, unsigned long<em>&nbsp;end_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.absent_pages_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of page frames in holes within a range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start_pfn</span></code></dt>
<dd>The start PFN to start searching for holes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end_pfn</span></code></dt>
<dd>The end PFN to stop searching for holes</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the number of pages frames in memory holes within a range.</p>
<dl class="function">
<dt id="c.node_map_pfn_alignment">
unsigned long <code class="descname">node_map_pfn_alignment</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.node_map_pfn_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the maximum internode alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called after node map is populated and sorted.
It calculates the maximum power of two alignment which can distinguish
all the nodes.</p>
<p>For example, if all nodes are 1GiB and aligned to 1GiB, the return value
would indicate 1GiB alignment with (1 &lt;&lt; (30 - PAGE_SHIFT)).  If the
nodes are shifted by 256MiB, 256MiB.  Note that if only the last node is
shifted, 1GiB is enough and this function will indicate so.</p>
<p>This is used to test whether pfn -&gt; nid mapping of the chosen memory
model has fine enough granularity to avoid incorrect mapping for the
populated node map.</p>
<p>Returns the determined alignment in pfn&#8217;s.  0 if there is no alignment
requirement (single node).</p>
<dl class="function">
<dt id="c.find_min_pfn_with_active_regions">
unsigned long <code class="descname">find_min_pfn_with_active_regions</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.find_min_pfn_with_active_regions" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum PFN registered</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>It returns the minimum PFN based on information provided via
<code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>.</p>
<dl class="function">
<dt id="c.free_area_init_nodes">
void <code class="descname">free_area_init_nodes</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;max_zone_pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_area_init_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise all pg_data_t and zone data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">max_zone_pfn</span></code></dt>
<dd>an array of max PFNs for each zone</dd>
</dl>
<p><strong>Description</strong></p>
<p>This will call <code class="xref c c-func docutils literal"><span class="pre">free_area_init_node()</span></code> for each active node in the system.
Using the page ranges provided by <code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>, the size of each
zone in each node and their holes is calculated. If the maximum PFN
between two adjacent zones match, it is assumed that the zone is empty.
For example, if arch_max_dma_pfn == arch_max_dma32_pfn, it is assumed
that arch_max_dma32_pfn has no pages. It is also assumed that a zone
starts where the previous one ended. For example, ZONE_DMA32 starts
at arch_max_dma_pfn.</p>
<dl class="function">
<dt id="c.set_dma_reserve">
void <code class="descname">set_dma_reserve</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;new_dma_reserve</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_dma_reserve" title="Permalink to this definition">¶</a></dt>
<dd><p>set the specified number of pages reserved in the first zone</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">new_dma_reserve</span></code></dt>
<dd>The number of pages to mark reserved</dd>
</dl>
<p><strong>Description</strong></p>
<p>The per-cpu batchsize and zone watermarks are determined by managed_pages.
In the DMA zone, a significant percentage may be consumed by kernel image
and other unfreeable allocations which can skew the watermarks badly. This
function may optionally be used to account for unfreeable pages in the
first zone (e.g., ZONE_DMA). The effect will be lower watermarks and
smaller per-cpu batchsize.</p>
<dl class="function">
<dt id="c.setup_per_zone_wmarks">
void <code class="descname">setup_per_zone_wmarks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.setup_per_zone_wmarks" title="Permalink to this definition">¶</a></dt>
<dd><p>called when min_free_kbytes changes or when memory is hot-{added|removed}</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Ensures that the watermark[min,low,high] values for each zone are set
correctly with respect to min_free_kbytes.</p>
<dl class="function">
<dt id="c.alloc_contig_range">
int <code class="descname">alloc_contig_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em>, unsigned<em>&nbsp;migratetype</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_contig_range" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>tries to allocate given range of pages</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>start PFN to allocate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>one-past-the-last PFN to allocate</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">migratetype</span></code></dt>
<dd>migratetype of the underlaying pageblocks (either
#MIGRATE_MOVABLE or #MIGRATE_CMA).  All pageblocks
in range must have the same migratetype and it must
be either of the two.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>GFP mask to use during compaction</dd>
</dl>
<p><strong>Description</strong></p>
<p>The PFN range does not have to be pageblock or MAX_ORDER_NR_PAGES
aligned.  The PFN range must belong to a single zone.</p>
<p>The first thing this routine does is attempt to MIGRATE_ISOLATE all
pageblocks in the range.  Once isolated, the pageblocks should not
be modified by others.</p>
<p>Returns zero on success or negative error code.  On success all
pages which PFN is in [start, end) are allocated for the caller and
need to be freed with <code class="xref c c-func docutils literal"><span class="pre">free_contig_range()</span></code>.</p>
<dl class="function">
<dt id="c.mempool_exit">
void <code class="descname">mempool_exit</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>exit a mempool initialized with <a class="reference internal" href="#c.mempool_init" title="mempool_init"><code class="xref c c-func docutils literal"><span class="pre">mempool_init()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was initialized with
<a class="reference internal" href="#c.mempool_init" title="mempool_init"><code class="xref c c-func docutils literal"><span class="pre">mempool_init()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all reserved elements in <strong>pool</strong> and <strong>pool</strong> itself.  This function
only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code> function sleeps.</p>
<p>May be called on a zeroed but uninitialized mempool (i.e. allocated with
<a class="reference internal" href="#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal"><span class="pre">kzalloc()</span></code></a>).</p>
<dl class="function">
<dt id="c.mempool_destroy">
void <code class="descname">mempool_destroy</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all reserved elements in <strong>pool</strong> and <strong>pool</strong> itself.  This function
only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code> function sleeps.</p>
<dl class="function">
<dt id="c.mempool_init">
int <code class="descname">mempool_init</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em>, int<em>&nbsp;min_nr</em>, mempool_alloc_t *<em>&nbsp;alloc_fn</em>, mempool_free_t *<em>&nbsp;free_fn</em>, void *<em>&nbsp;pool_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool that should be initialized</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_nr</span></code></dt>
<dd>the minimum number of elements guaranteed to be
allocated for this pool.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_alloc_t</span> <span class="pre">*</span> <span class="pre">alloc_fn</span></code></dt>
<dd>user-defined element-allocation function.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_free_t</span> <span class="pre">*</span> <span class="pre">free_fn</span></code></dt>
<dd>user-defined element-freeing function.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pool_data</span></code></dt>
<dd>optional private data available to the user-defined functions.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Like <a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>, but initializes the pool in (i.e. embedded in another
structure).</p>
<dl class="function">
<dt id="c.mempool_create">
mempool_t * <code class="descname">mempool_create</code><span class="sig-paren">(</span>int<em>&nbsp;min_nr</em>, mempool_alloc_t *<em>&nbsp;alloc_fn</em>, mempool_free_t *<em>&nbsp;free_fn</em>, void *<em>&nbsp;pool_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">min_nr</span></code></dt>
<dd>the minimum number of elements guaranteed to be
allocated for this pool.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_alloc_t</span> <span class="pre">*</span> <span class="pre">alloc_fn</span></code></dt>
<dd>user-defined element-allocation function.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_free_t</span> <span class="pre">*</span> <span class="pre">free_fn</span></code></dt>
<dd>user-defined element-freeing function.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pool_data</span></code></dt>
<dd>optional private data available to the user-defined functions.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function creates and allocates a guaranteed size, preallocated
memory pool. The pool can be used from the <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> and <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a>
functions. This function might sleep. Both the <code class="xref c c-func docutils literal"><span class="pre">alloc_fn()</span></code> and the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code>
functions might sleep - as long as the <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> function is not called
from IRQ contexts.</p>
<dl class="function">
<dt id="c.mempool_resize">
int <code class="descname">mempool_resize</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em>, int<em>&nbsp;new_min_nr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_resize" title="Permalink to this definition">¶</a></dt>
<dd><p>resize an existing memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_min_nr</span></code></dt>
<dd>the new minimum number of elements guaranteed to be
allocated for this pool.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function shrinks/grows the pool. In the case of growing,
it cannot be guaranteed that the pool will be grown to the new
size immediately, but new <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a> calls will refill it.
This function may sleep.</p>
<p>Note, the caller must guarantee that no mempool_destroy is called
while this function is running. <a class="reference internal" href="#c.mempool_alloc" title="mempool_alloc"><code class="xref c c-func docutils literal"><span class="pre">mempool_alloc()</span></code></a> &amp; <a class="reference internal" href="#c.mempool_free" title="mempool_free"><code class="xref c c-func docutils literal"><span class="pre">mempool_free()</span></code></a>
might be called (eg. from IRQ contexts) while this function executes.</p>
<dl class="function">
<dt id="c.mempool_alloc">
void * <code class="descname">mempool_alloc</code><span class="sig-paren">(</span>mempool_t *<em>&nbsp;pool</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an element from a specific memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>the usual allocation bitmask.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">alloc_fn()</span></code> function sleeps or
returns NULL. Note that due to preallocation, this function
<em>never</em> fails when called from process contexts. (it might
fail if called from an IRQ context.)</p>
<p><strong>Note</strong></p>
<p>using __GFP_ZERO is not supported.</p>
<dl class="function">
<dt id="c.mempool_free">
void <code class="descname">mempool_free</code><span class="sig-paren">(</span>void *<em>&nbsp;element</em>, mempool_t *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mempool_free" title="Permalink to this definition">¶</a></dt>
<dd><p>return an element to the pool.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">element</span></code></dt>
<dd>pool element pointer.</dd>
<dt><code class="docutils literal"><span class="pre">mempool_t</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>pointer to the memory pool which was allocated via
<a class="reference internal" href="#c.mempool_create" title="mempool_create"><code class="xref c c-func docutils literal"><span class="pre">mempool_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>this function only sleeps if the <code class="xref c c-func docutils literal"><span class="pre">free_fn()</span></code> function sleeps.</p>
<dl class="function">
<dt id="c.dma_pool_create">
struct dma_pool * <code class="descname">dma_pool_create</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;align</em>, size_t<em>&nbsp;boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a pool of consistent memory blocks, for dma.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of pool, for diagnostics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that will be doing the DMA</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the blocks in this pool.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requirement for blocks; must be a power of two</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">boundary</span></code></dt>
<dd>returned blocks won&#8217;t cross this power of two boundary</dd>
</dl>
<p><strong>Context</strong></p>
<p>!:c:func:<cite>in_interrupt()</cite></p>
<p><strong>Description</strong></p>
<p>Returns a dma allocation pool with the requested characteristics, or
null if one can&#8217;t be created.  Given one of these pools, <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_alloc()</span></code></a>
may be used to allocate memory.  Such memory will all have &#8220;consistent&#8221;
DMA mappings, accessible by the device and its driver without using
cache flushing primitives.  The actual size of blocks allocated may be
larger than requested because of alignment.</p>
<p>If <strong>boundary</strong> is nonzero, objects returned from <a class="reference internal" href="#c.dma_pool_alloc" title="dma_pool_alloc"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_alloc()</span></code></a> won&#8217;t
cross that size boundary.  This is useful for devices which have
addressing restrictions on individual DMA transfers, such as not crossing
boundaries of 4KBytes.</p>
<dl class="function">
<dt id="c.dma_pool_destroy">
void <code class="descname">dma_pool_destroy</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroys a pool of dma memory blocks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will be destroyed</dd>
</dl>
<p><strong>Context</strong></p>
<p>!:c:func:<cite>in_interrupt()</cite></p>
<p><strong>Description</strong></p>
<p>Caller guarantees that no more memory from the pool is in use,
and that nothing will try to use the pool after this call.</p>
<dl class="function">
<dt id="c.dma_pool_alloc">
void * <code class="descname">dma_pool_alloc</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em>, gfp_t<em>&nbsp;mem_flags</em>, dma_addr_t *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>get a block of consistent memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will produce the block</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">mem_flags</span></code></dt>
<dd>GFP_* bitmask</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>pointer to dma address of block</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the kernel virtual address of a currently unused block,
and reports its dma address through the handle.
If such a memory block can&#8217;t be allocated, <code class="docutils literal"><span class="pre">NULL</span></code> is returned.</p>
<dl class="function">
<dt id="c.dma_pool_free">
void <code class="descname">dma_pool_free</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em>, void *<em>&nbsp;vaddr</em>, dma_addr_t<em>&nbsp;dma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_pool_free" title="Permalink to this definition">¶</a></dt>
<dd><p>put block back into dma pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>the dma pool holding the block</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>virtual address of block</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">dma</span></code></dt>
<dd>dma address of block</dd>
</dl>
<p><strong>Description</strong></p>
<p>Caller promises neither device nor driver will again touch this block
unless it is first re-allocated.</p>
<dl class="function">
<dt id="c.dmam_pool_create">
struct dma_pool * <code class="descname">dmam_pool_create</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;align</em>, size_t<em>&nbsp;allocation</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_create" title="dma_pool_create"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_create()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of pool, for diagnostics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device that will be doing the DMA</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the blocks in this pool.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requirement for blocks; must be a power of two</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">allocation</span></code></dt>
<dd>returned blocks won&#8217;t cross this boundary (or zero)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_create" title="dma_pool_create"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_create()</span></code></a>.  DMA pool created with this function is
automatically destroyed on driver detach.</p>
<dl class="function">
<dt id="c.dmam_pool_destroy">
void <code class="descname">dmam_pool_destroy</code><span class="sig-paren">(</span>struct dma_pool *<em>&nbsp;pool</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_pool_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_destroy()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_pool</span> <span class="pre">*</span> <span class="pre">pool</span></code></dt>
<dd>dma pool that will be destroyed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dma_pool_destroy" title="dma_pool_destroy"><code class="xref c c-func docutils literal"><span class="pre">dma_pool_destroy()</span></code></a>.</p>
<dl class="function">
<dt id="c.balance_dirty_pages_ratelimited">
void <code class="descname">balance_dirty_pages_ratelimited</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.balance_dirty_pages_ratelimited" title="Permalink to this definition">¶</a></dt>
<dd><p>balance dirty memory state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address_space which was dirtied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Processes which are dirtying memory should call in here once for each page
which was newly dirtied.  The function will periodically check the system&#8217;s
dirty state and will initiate writeback if needed.</p>
<p>On really big machines, get_writeback_state is expensive, so try to avoid
calling it too often (ratelimiting).  But once we&#8217;re over the dirty memory
limit we decrease the ratelimiting by a lot, to prevent individual processes
from overshooting the limit by (ratelimit_pages) each.</p>
<dl class="function">
<dt id="c.tag_pages_for_writeback">
void <code class="descname">tag_pages_for_writeback</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.tag_pages_for_writeback" title="Permalink to this definition">¶</a></dt>
<dd><p>tag pages to be written by write_cache_pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>starting page index</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>ending page index (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function scans the page range from <strong>start</strong> to <strong>end</strong> (inclusive) and tags
all pages that have DIRTY tag set with a special TOWRITE tag. The idea is
that write_cache_pages (or whoever calls this function) will then use
TOWRITE tag to identify pages eligible for writeback.  This mechanism is
used to avoid livelocking of writeback by a process steadily creating new
dirty pages in the file (thus it is important for this function to be quick
so that it can tag pages faster than a dirtying process can create them).</p>
<dl class="function">
<dt id="c.write_cache_pages">
int <code class="descname">write_cache_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct writeback_control *<em>&nbsp;wbc</em>, writepage_t<em>&nbsp;writepage</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_cache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space and write all of them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>subtract the number of written pages from <strong>*wbc</strong>-&gt;nr_to_write</dd>
<dt><code class="docutils literal"><span class="pre">writepage_t</span> <span class="pre">writepage</span></code></dt>
<dd>function called for each page</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data passed to writepage function</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a page is already under I/O, <a class="reference internal" href="#c.write_cache_pages" title="write_cache_pages"><code class="xref c c-func docutils literal"><span class="pre">write_cache_pages()</span></code></a> skips it, even
if it&#8217;s dirty.  This is desirable behaviour for memory-cleaning writeback,
but it is INCORRECT for data-integrity system calls such as <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>.  <code class="xref c c-func docutils literal"><span class="pre">fsync()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">msync()</span></code> need to guarantee that all the data which was dirty at the time
the call was made get new I/O started against them.  If wbc-&gt;sync_mode is
WB_SYNC_ALL then we were called for data integrity and we must wait for
existing IO to complete.</p>
<p>To avoid livelocks (when other process dirties new pages), we first tag
pages which should be written back with TOWRITE tag and only then start
writing them. For data-integrity sync we have to be careful so that we do
not miss some pages (e.g., because some other process has cleared TOWRITE
tag we set). The rule we follow is that TOWRITE tag can be cleared only
by the process clearing the DIRTY tag (and submitting the page for IO).</p>
<dl class="function">
<dt id="c.generic_writepages">
int <code class="descname">generic_writepages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, struct writeback_control *<em>&nbsp;wbc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_writepages" title="Permalink to this definition">¶</a></dt>
<dd><p>walk the list of dirty pages of the given address space and <code class="xref c c-func docutils literal"><span class="pre">writepage()</span></code> all of them.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>address space structure to write</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">writeback_control</span> <span class="pre">*</span> <span class="pre">wbc</span></code></dt>
<dd>subtract the number of written pages from <strong>*wbc</strong>-&gt;nr_to_write</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a library function, which implements the <code class="xref c c-func docutils literal"><span class="pre">writepages()</span></code>
address_space_operation.</p>
<dl class="function">
<dt id="c.write_one_page">
int <code class="descname">write_one_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.write_one_page" title="Permalink to this definition">¶</a></dt>
<dd><p>write out a single page and wait on I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>the page to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>The page must be locked by the caller and will be unlocked upon return.</p>
<p>Note that the mapping&#8217;s AS_EIO/AS_ENOSPC flags will be cleared when this
function returns.</p>
<dl class="function">
<dt id="c.wait_for_stable_page">
void <code class="descname">wait_for_stable_page</code><span class="sig-paren">(</span>struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_for_stable_page" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for writeback to finish, if necessary.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>The page to wait on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function determines if the given page is related to a backing device
that requires page contents to be held stable during writeback.  If so, then
it will wait for any pending writeback to complete.</p>
<dl class="function">
<dt id="c.truncate_inode_pages_range">
void <code class="descname">truncate_inode_pages_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_range" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate range of pages specified by start &amp; end byte offsets</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset from which to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset to which to truncate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Truncate the page cache, removing the pages that are between
specified offsets (and zeroing out partial pages
if lstart or lend + 1 is not page aligned).</p>
<p>Truncate takes two passes - the first pass is nonblocking.  It will not
block on page locks and it will not block on writeback.  The second pass
will wait.  This is to prevent as much IO as possible in the affected region.
The first pass will remove most pages, so the search cost of the second pass
is low.</p>
<p>We pass down the cache-hot hint to the page freeing code.  Even if the
mapping is large, it is probably the case that the final pages are the most
recently touched, and freeing happens in ascending file offset order.</p>
<p>Note that since -&gt;:c:func:<cite>invalidatepage()</cite> accepts range to invalidate
truncate_inode_pages_range is able to handle cases where lend + 1 is not
page aligned properly.</p>
<dl class="function">
<dt id="c.truncate_inode_pages">
void <code class="descname">truncate_inode_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, loff_t<em>&nbsp;lstart</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate <em>all</em> the pages from an offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset from which to truncate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialised by) inode-&gt;i_mutex.</p>
<p><strong>Note</strong></p>
<p>When this function returns, there can be a page in the process of
deletion (inside <code class="xref c c-func docutils literal"><span class="pre">__delete_from_page_cache()</span></code>) in the specified range.  Thus
mapping-&gt;nrpages can be non-zero when this function returns even after
truncation of the whole mapping.</p>
<dl class="function">
<dt id="c.truncate_inode_pages_final">
void <code class="descname">truncate_inode_pages_final</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_inode_pages_final" title="Permalink to this definition">¶</a></dt>
<dd><p>truncate <em>all</em> pages before inode dies</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to truncate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called under (and serialized by) inode-&gt;i_mutex.</p>
<p>Filesystems have to use this in the .evict_inode path to inform the
VM that this is the final truncate and the inode is going away.</p>
<dl class="function">
<dt id="c.invalidate_mapping_pages">
unsigned long <code class="descname">invalidate_mapping_pages</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_mapping_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate all the unlocked pages of one inode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space which holds the pages to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the offset &#8216;from&#8217; which to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>the offset &#8216;to&#8217; which to invalidate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only removes the unlocked pages, if you want to
remove all the pages of one inode, you must call truncate_inode_pages.</p>
<p><a class="reference internal" href="#c.invalidate_mapping_pages" title="invalidate_mapping_pages"><code class="xref c c-func docutils literal"><span class="pre">invalidate_mapping_pages()</span></code></a> will not block on IO activity. It will not
invalidate pages which are dirty, locked, under writeback or mapped into
pagetables.</p>
<dl class="function">
<dt id="c.invalidate_inode_pages2_range">
int <code class="descname">invalidate_inode_pages2_range</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em>, pgoff_t<em>&nbsp;start</em>, pgoff_t<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2_range" title="Permalink to this definition">¶</a></dt>
<dd><p>remove range of pages from an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">start</span></code></dt>
<dd>the page offset &#8216;from&#8217; which to invalidate</dd>
<dt><code class="docutils literal"><span class="pre">pgoff_t</span> <span class="pre">end</span></code></dt>
<dd>the page offset &#8216;to&#8217; which to invalidate (inclusive)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p>Returns -EBUSY if any pages could not be invalidated.</p>
<dl class="function">
<dt id="c.invalidate_inode_pages2">
int <code class="descname">invalidate_inode_pages2</code><span class="sig-paren">(</span>struct address_space *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.invalidate_inode_pages2" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all pages from an address_space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the address_space</dd>
</dl>
<p><strong>Description</strong></p>
<p>Any pages which are found to be mapped into pagetables are unmapped prior to
invalidation.</p>
<p>Returns -EBUSY if any pages could not be invalidated.</p>
<dl class="function">
<dt id="c.truncate_pagecache">
void <code class="descname">truncate_pagecache</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;newsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap and remove pagecache that has been truncated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt>
<dd>new file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>inode&#8217;s new i_size must already be written before truncate_pagecache
is called.</p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
<dl class="function">
<dt id="c.truncate_setsize">
void <code class="descname">truncate_setsize</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;newsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_setsize" title="Permalink to this definition">¶</a></dt>
<dd><p>update inode and pagecache for a new file size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">newsize</span></code></dt>
<dd>new file size</dd>
</dl>
<p><strong>Description</strong></p>
<p>truncate_setsize updates i_size and performs pagecache truncation (if
necessary) to <strong>newsize</strong>. It will be typically be called from the filesystem&#8217;s
setattr function when ATTR_SIZE is passed in.</p>
<p>Must be called with a lock serializing truncates and writes (generally
i_mutex but e.g. xfs uses a different lock) and before all filesystem
specific block truncation has been performed.</p>
<dl class="function">
<dt id="c.pagecache_isize_extended">
void <code class="descname">pagecache_isize_extended</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;from</em>, loff_t<em>&nbsp;to</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pagecache_isize_extended" title="Permalink to this definition">¶</a></dt>
<dd><p>update pagecache after extension of i_size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode for which i_size was extended</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">from</span></code></dt>
<dd>original inode size</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">to</span></code></dt>
<dd>new inode size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle extension of inode size either caused by extending truncate or by
write starting after current i_size. We mark the page straddling current
i_size RO so that <code class="xref c c-func docutils literal"><span class="pre">page_mkwrite()</span></code> is called on the nearest write access to
the page.  This way filesystem can be sure that <code class="xref c c-func docutils literal"><span class="pre">page_mkwrite()</span></code> is called on
the page before user writes to the page via mmap after the i_size has been
changed.</p>
<p>The function must be called after i_size is updated so that page fault
coming after we unlock the page will already see the new i_size.
The function must be called while we still hold i_mutex - this not only
makes sure i_size is stable but also that userspace cannot observe new
i_size value before we are prepared to store mmap writes at new inode size.</p>
<dl class="function">
<dt id="c.truncate_pagecache_range">
void <code class="descname">truncate_pagecache_range</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, loff_t<em>&nbsp;lstart</em>, loff_t<em>&nbsp;lend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.truncate_pagecache_range" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap and remove pagecache that is hole-punched</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>inode</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lstart</span></code></dt>
<dd>offset of beginning of hole</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">lend</span></code></dt>
<dd>offset of last byte of hole</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should typically be called before the filesystem
releases resources associated with the freed range (eg. deallocates
blocks). This way, pagecache will always stay logically coherent
with on-disk format, and the filesystem would not have to deal with
situations such as writepage being called for a page that has already
had its underlying blocks deallocated.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gfp_mask-from-fs-io.html" class="btn btn-neutral float-right" title="GFP masks used from FS/IO context" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="circular-buffers.html" class="btn btn-neutral" title="Circular Buffers" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>