

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Linux Kernel API &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="Core API Documentation" href="index.html"/>
        <link rel="next" title="Generic Associative Array Implementation" href="assoc_array.html"/>
        <link rel="prev" title="Core API Documentation" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="">The Linux Kernel API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#list-management-functions">List Management Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-c-library-functions">Basic C Library Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-kernel-library-functions">Basic Kernel Library Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crc-and-math-functions-in-linux">CRC and Math Functions in Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-ipc-facilities">Kernel IPC facilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fifo-buffer">FIFO Buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#relay-interface-support">relay interface support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-support">Module Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-interfaces">Hardware Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#security-framework">Security Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#audit-interfaces">Audit Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accounting-framework">Accounting Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#block-devices">Block Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#char-devices">Char devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clock-framework">Clock Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-primitives">Synchronization Primitives</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomic_ops.html">Semantics and Behavior of Atomic and Bitmask Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="cachetlb.html">Cache and TLB Flushing Under Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="refcount-vs-atomic.html">refcount_t API compared to atomic_t</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="idr.html">ID Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="flexible-arrays.html">Using flexible arrays in the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="genalloc.html">The genalloc/genpool subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="errseq.html">The errseq_t datatype</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-formats.html">How to get printk format specifiers right</a></li>
<li class="toctree-l3"><a class="reference internal" href="circular-buffers.html">Circular Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm-api.html">Memory Management APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfp_mask-from-fs-io.html">GFP masks used from FS/IO context</a></li>
<li class="toctree-l3"><a class="reference internal" href="timekeeping.html">ktime accessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="boot-time-mm.html">Boot time memory management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
      
    <li>The Linux Kernel API</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/core-api/kernel-api.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-linux-kernel-api">
<h1>The Linux Kernel API<a class="headerlink" href="#the-linux-kernel-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="list-management-functions">
<h2>List Management Functions<a class="headerlink" href="#list-management-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.list_add">
void <code class="descname">list_add</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it after</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<dl class="function">
<dt id="c.list_add_tail">
void <code class="descname">list_add_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it before</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
<dl class="function">
<dt id="c.__list_del_entry">
void <code class="descname">__list_del_entry</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__list_del_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the element to delete from the list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal"><span class="pre">list_empty()</span></code></a> on entry does not return true after this, the entry is
in an undefined state.</p>
<dl class="function">
<dt id="c.list_replace">
void <code class="descname">list_replace</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;old</em>, struct list_head *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the element to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new element to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>old</strong> was empty, it will be overwritten.</p>
<dl class="function">
<dt id="c.list_del_init">
void <code class="descname">list_del_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_init" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list and reinitialize it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the element to delete from the list.</dd>
</dl>
<dl class="function">
<dt id="c.list_move">
void <code class="descname">list_move</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move" title="Permalink to this definition">¶</a></dt>
<dd><p>delete from one list and add as another&#8217;s head</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to move</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head that will precede our entry</dd>
</dl>
<dl class="function">
<dt id="c.list_move_tail">
void <code class="descname">list_move_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_move_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>delete from one list and add as another&#8217;s tail</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to move</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head that will follow our entry</dd>
</dl>
<dl class="function">
<dt id="c.list_is_last">
int <code class="descname">list_is_last</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;list</em>, const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_last" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether <strong>list</strong> is the last entry in list <strong>head</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the entry to test</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
</dl>
<dl class="function">
<dt id="c.list_empty">
int <code class="descname">list_empty</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test.</dd>
</dl>
<dl class="function">
<dt id="c.list_empty_careful">
int <code class="descname">list_empty_careful</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_empty_careful" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list is empty and not being modified</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>tests whether a list is empty _and_ checks that no other CPU might be
in the process of modifying either member (next or prev)</p>
<p><strong>NOTE</strong></p>
<p>using <a class="reference internal" href="#c.list_empty_careful" title="list_empty_careful"><code class="xref c c-func docutils literal"><span class="pre">list_empty_careful()</span></code></a> without synchronization
can only be safe if the only activity that can happen
to the list entry is <a class="reference internal" href="#c.list_del_init" title="list_del_init"><code class="xref c c-func docutils literal"><span class="pre">list_del_init()</span></code></a>. Eg. it cannot be used
if another CPU could re-<a class="reference internal" href="#c.list_add" title="list_add"><code class="xref c c-func docutils literal"><span class="pre">list_add()</span></code></a> it.</p>
<dl class="function">
<dt id="c.list_rotate_left">
void <code class="descname">list_rotate_left</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_rotate_left" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate the list to the left</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
</dl>
<dl class="function">
<dt id="c.list_is_singular">
int <code class="descname">list_is_singular</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_is_singular" title="Permalink to this definition">¶</a></dt>
<dd><p>tests whether a list has just one entry.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to test.</dd>
</dl>
<dl class="function">
<dt id="c.list_cut_position">
void <code class="descname">list_cut_position</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em>, struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_position" title="Permalink to this definition">¶</a></dt>
<dd><p>cut a list into two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>a new list to add all removed entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>a list with entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>an entry within head, could be the head itself
and if so we won&#8217;t cut the list</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to and
including <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>. You should
pass on <strong>entry</strong> an element you know is on <strong>head</strong>. <strong>list</strong>
should be an empty list or a list you do not care about
losing its data.</p>
<dl class="function">
<dt id="c.list_cut_before">
void <code class="descname">list_cut_before</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em>, struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_cut_before" title="Permalink to this definition">¶</a></dt>
<dd><p>cut a list into two, before given entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>a new list to add all removed entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>a list with entries</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>an entry within head, could be the head itself</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper moves the initial part of <strong>head</strong>, up to but
excluding <strong>entry</strong>, from <strong>head</strong> to <strong>list</strong>.  You should pass
in <strong>entry</strong> an element you know is on <strong>head</strong>.  <strong>list</strong> should
be an empty list or a list you do not care about losing
its data.
If <strong>entry</strong> == <strong>head</strong>, all entries on <strong>head</strong> are moved to
<strong>list</strong>.</p>
<dl class="function">
<dt id="c.list_splice">
void <code class="descname">list_splice</code><span class="sig-paren">(</span>const struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists, this is designed for stacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_tail">
void <code class="descname">list_splice_tail</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists, each list being a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_init">
void <code class="descname">list_splice_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists and reinitialise the emptied list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list at <strong>list</strong> is reinitialised</p>
<dl class="function">
<dt id="c.list_splice_tail_init">
void <code class="descname">list_splice_tail_init</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init" title="Permalink to this definition">¶</a></dt>
<dd><p>join two lists and reinitialise the emptied list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the new list to add.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place to add it in the first list.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each of the lists is a queue.
The list at <strong>list</strong> is reinitialised</p>
<dl class="function">
<dt id="c.list_entry">
<code class="descname">list_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_first_entry">
<code class="descname">list_first_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
<dl class="function">
<dt id="c.list_last_entry">
<code class="descname">list_last_entry</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_last_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the last element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, that list is expected to be not empty.</p>
<dl class="function">
<dt id="c.list_first_entry_or_null">
<code class="descname">list_first_entry_or_null</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_entry_or_null" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
<dl class="function">
<dt id="c.list_next_entry">
<code class="descname">list_next_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_next_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the next element in list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to cursor</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_prev_entry">
<code class="descname">list_prev_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_prev_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>get the prev element in list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to cursor</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each">
<code class="descname">list_for_each</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_prev">
<code class="descname">list_for_each_prev</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_prev" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list backwards</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_safe">
<code class="descname">list_for_each_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_prev_safe">
<code class="descname">list_for_each_prev_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_prev_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list backwards safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry">
<code class="descname">list_for_each_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry_reverse">
<code class="descname">list_for_each_entry_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list of given type.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_prepare_entry">
<code class="descname">list_prepare_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_prepare_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a pos entry for use in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_continue()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a start point</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head of the list</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Prepares a pos entry for use as a start point in <a class="reference internal" href="#c.list_for_each_entry_continue" title="list_for_each_entry_continue"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_continue()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue">
<code class="descname">list_for_each_entry_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue iteration over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue_reverse">
<code class="descname">list_for_each_entry_continue_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards from the given point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start to iterate over list of given type backwards, continuing after
the current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from">
<code class="descname">list_for_each_entry_from</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type from the current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing from current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from_reverse">
<code class="descname">list_for_each_entry_from_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list of given type from the current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, continuing from current position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe">
<code class="descname">list_for_each_entry_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_for_each_entry_safe_continue">
<code class="descname">list_for_each_entry_safe_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>continue list iteration safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type, continuing after current point,
safe against removal of list entry.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe_from">
<code class="descname">list_for_each_entry_safe_from</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list from current point safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over list of given type from current point, safe against
removal of list entry.</p>
<dl class="function">
<dt id="c.list_for_each_entry_safe_reverse">
<code class="descname">list_for_each_entry_safe_reverse</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_safe_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate backwards over list safe against removal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another type * to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate backwards over list of given type, safe against removal
of list entry.</p>
<dl class="function">
<dt id="c.list_safe_reset_next">
<code class="descname">list_safe_reset_next</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_safe_reset_next" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a stale list_for_each_entry_safe loop</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the loop cursor used in the list_for_each_entry_safe loop</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>temporary storage used in list_for_each_entry_safe</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>list_safe_reset_next is not safe to use in general if the list may be
modified concurrently (eg. the lock is dropped in the loop body). An
exception to this is if the cursor element (pos) is pinned in the list,
and list_safe_reset_next is called after re-taking the lock and before
completing the current iteration of the loop body.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry">
<code class="descname">hlist_for_each_entry</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue">
<code class="descname">hlist_for_each_entry_continue</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_from">
<code class="descname">hlist_for_each_entry_from</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_from" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_safe">
<code class="descname">hlist_for_each_entry_safe</code><span class="sig-paren">(</span><em>pos</em>, <em>n</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>another <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span></code> to use as temporary storage</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
</div>
<div class="section" id="basic-c-library-functions">
<h2>Basic C Library Functions<a class="headerlink" href="#basic-c-library-functions" title="Permalink to this headline">¶</a></h2>
<p>When writing drivers, you cannot in general use routines which are from
the C Library. Some of the functions have been found generally useful
and they are listed below. The behaviour of these functions may vary
slightly from those defined by ANSI, and these deviations are noted in
the text.</p>
<div class="section" id="string-conversions">
<h3>String Conversions<a class="headerlink" href="#string-conversions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.simple_strtoull">
unsigned long long <code class="descname">simple_strtoull</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoull" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoull instead.</p>
<dl class="function">
<dt id="c.simple_strtoul">
unsigned long <code class="descname">simple_strtoul</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoul instead.</p>
<dl class="function">
<dt id="c.simple_strtol">
long <code class="descname">simple_strtol</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a signed long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtol instead.</p>
<dl class="function">
<dt id="c.simple_strtoll">
long long <code class="descname">simple_strtoll</code><span class="sig-paren">(</span>const char *<em>&nbsp;cp</em>, char **<em>&nbsp;endp</em>, unsigned int<em>&nbsp;base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.simple_strtoll" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a signed long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The start of the string</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">endp</span></code></dt>
<dd>A pointer to the end of the parsed string will be placed here</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is obsolete. Please use kstrtoll instead.</p>
<dl class="function">
<dt id="c.vsnprintf">
int <code class="descname">vsnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function generally follows C99 vsnprintf, but has some
extensions and a few limitations:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">``n``</span></code> is unsupported</li>
<li><code class="docutils literal"><span class="pre">``p``*</span></code> is handled by <code class="xref c c-func docutils literal"><span class="pre">pointer()</span></code></li>
</ul>
</div></blockquote>
<p>See <code class="xref c c-func docutils literal"><span class="pre">pointer()</span></code> or Documentation/core-api/printk-formats.rst for more
extensive description.</p>
<p><strong>Please update the documentation in both places when making changes</strong></p>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
&#8216;0&#8217;, as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing &#8216;0&#8217;), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<p>If you&#8217;re not already dealing with a va_list consider using <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal"><span class="pre">snprintf()</span></code></a>.</p>
<dl class="function">
<dt id="c.vscnprintf">
int <code class="descname">vscnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vscnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which have been written into
the <strong>buf</strong> not including the trailing &#8216;0&#8217;. If <strong>size</strong> is == 0 the function
returns 0.</p>
<p>If you&#8217;re not already dealing with a va_list consider using <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal"><span class="pre">scnprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.snprintf">
int <code class="descname">snprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.snprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters which would be
generated for the given input, excluding the trailing null,
as per ISO C99.  If the return is greater than or equal to
<strong>size</strong>, the resulting string is truncated.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.scnprintf">
int <code class="descname">scnprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.scnprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is the number of characters written into <strong>buf</strong> not including
the trailing &#8216;0&#8217;. If <strong>size</strong> is == 0 the function returns 0.</p>
<dl class="function">
<dt id="c.vsprintf">
int <code class="descname">vsprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> or <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>If you&#8217;re not already dealing with a va_list consider using <a class="reference internal" href="#c.sprintf" title="sprintf"><code class="xref c c-func docutils literal"><span class="pre">sprintf()</span></code></a>.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.sprintf">
int <code class="descname">sprintf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of characters written
into <strong>buf</strong>. Use <a class="reference internal" href="#c.snprintf" title="snprintf"><code class="xref c c-func docutils literal"><span class="pre">snprintf()</span></code></a> or <a class="reference internal" href="#c.scnprintf" title="scnprintf"><code class="xref c c-func docutils literal"><span class="pre">scnprintf()</span></code></a> in order to avoid
buffer overflows.</p>
<p>See the <a class="reference internal" href="#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.vbin_printf">
int <code class="descname">vbin_printf</code><span class="sig-paren">(</span>u32 *<em>&nbsp;bin_buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vbin_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a format string and place args&#8217; binary value in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>The buffer to place args&#8217; binary value</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer(by words(32bits), not characters)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format follows C99 vsnprintf, except <code class="docutils literal"><span class="pre">n</span></code> is ignored, and its argument
is skipped.</p>
<p>The return value is the number of words(32bits) which would be generated for
the given input.</p>
<p><strong>NOTE</strong></p>
<p>If the return value is greater than <strong>size</strong>, the resulting bin_buf is NOT
valid for <a class="reference internal" href="#c.bstr_printf" title="bstr_printf"><code class="xref c c-func docutils literal"><span class="pre">bstr_printf()</span></code></a>.</p>
<dl class="function">
<dt id="c.bstr_printf">
int <code class="descname">bstr_printf</code><span class="sig-paren">(</span>char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, const u32 *<em>&nbsp;bin_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bstr_printf" title="Permalink to this definition">¶</a></dt>
<dd><p>Format a string from binary arguments and place it in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>The buffer to place the result into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer, including the trailing null space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>Binary arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function like C99 vsnprintf, but the difference is that vsnprintf gets
arguments from stack, and bstr_printf gets arguments from <strong>bin_buf</strong> which is
a binary buffer that generated by vbin_printf.</p>
<dl class="docutils">
<dt>The format follows C99 vsnprintf, but has some extensions:</dt>
<dd>see vsnprintf comment for details.</dd>
</dl>
<p>The return value is the number of characters which would
be generated for the given input, excluding the trailing
&#8216;0&#8217;, as per ISO C99. If you want to have the exact
number of characters written into <strong>buf</strong> as return value
(not including the trailing &#8216;0&#8217;), use <a class="reference internal" href="#c.vscnprintf" title="vscnprintf"><code class="xref c c-func docutils literal"><span class="pre">vscnprintf()</span></code></a>. If the
return is greater than or equal to <strong>size</strong>, the resulting
string is truncated.</p>
<dl class="function">
<dt id="c.bprintf">
int <code class="descname">bprintf</code><span class="sig-paren">(</span>u32 *<em>&nbsp;bin_buf</em>, size_t<em>&nbsp;size</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.bprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a format string and place args&#8217; binary value in a buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bin_buf</span></code></dt>
<dd>The buffer to place args&#8217; binary value</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the buffer(by words(32bits), not characters)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function returns the number of words(u32) written
into <strong>bin_buf</strong>.</p>
<dl class="function">
<dt id="c.vsscanf">
int <code class="descname">vsscanf</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vsscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>input buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format of buffer</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>arguments</dd>
</dl>
<dl class="function">
<dt id="c.sscanf">
int <code class="descname">sscanf</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.sscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Unformat a buffer into a list of arguments</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>input buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>formatting of buffer</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>resulting arguments</dd>
</dl>
<dl class="function">
<dt id="c.kstrtol">
int <code class="descname">kstrtol</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoul">
int <code class="descname">kstrtoul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoull">
int <code class="descname">kstrtoull</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned long long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoull" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoll">
int <code class="descname">kstrtoll</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, long long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoll" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtouint">
int <code class="descname">kstrtouint</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned int *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtouint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtoint">
int <code class="descname">kstrtoint</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, int *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an int</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtobool">
int <code class="descname">kstrtobool</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, bool *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtobool" title="Permalink to this definition">¶</a></dt>
<dd><p>convert common user inputs into boolean values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>input string</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>result</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns 0 iff the first character is one of &#8216;Yy1Nn0&#8217;, or
[oO][NnFf] for &#8220;on&#8221; and &#8220;off&#8221;. Otherwise it will return -EINVAL.  Value
pointed to by res is updated upon finding a match.</p>
</div>
<div class="section" id="string-manipulation">
<h3>String Manipulation<a class="headerlink" href="#string-manipulation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.strncasecmp">
int <code class="descname">strncasecmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncasecmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Case insensitive, length-limited string comparison</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The other string</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>the maximum number of characters to compare</dd>
</dl>
<dl class="function">
<dt id="c.strcpy">
char * <code class="descname">strcpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a <code class="docutils literal"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
</dl>
<dl class="function">
<dt id="c.strncpy">
char * <code class="descname">strncpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a length-limited, C-string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>The result is not <code class="docutils literal"><span class="pre">NUL-terminated</span></code> if the source exceeds
<strong>count</strong> bytes.</p>
<p>In the case where the length of <strong>src</strong> is less than  that  of
count, the remainder of <strong>dest</strong> will be padded with <code class="docutils literal"><span class="pre">NUL</span></code>.</p>
<dl class="function">
<dt id="c.strlcpy">
size_t <code class="descname">strlcpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of destination buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatible with <code class="docutils literal"><span class="pre">*BSD</span></code>: the result is always a valid
NUL-terminated string that fits in the buffer (unless,
of course, the buffer size is zero). It does not pad
out the result like <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a> does.</p>
<dl class="function">
<dt id="c.strscpy">
ssize_t <code class="descname">strscpy</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strscpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a C-string into a sized buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy the string to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy the string from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>Size of destination buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy the string, or as much of it as fits, into the dest buffer.
The routine returns the number of characters copied (not including
the trailing NUL) or -E2BIG if the destination buffer wasn&#8217;t big enough.
The behavior is undefined if the string buffers overlap.
The destination buffer is always NUL terminated, unless it&#8217;s zero-sized.</p>
<p>Preferred to <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a> since the API doesn&#8217;t require reading memory
from the src string beyond the specified &#8220;count&#8221; bytes, and since
the return value is easier to error-check than <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a>&#8216;s.
In addition, the implementation is robust to the string changing out
from underneath it, unlike the current <a class="reference internal" href="#c.strlcpy" title="strlcpy"><code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code></a> implementation.</p>
<p>Preferred to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a> since it always returns a valid string, and
doesn&#8217;t unnecessarily force the tail of the destination buffer to be
zeroed.  If the zeroing is desired, it&#8217;s likely cleaner to use <a class="reference internal" href="#c.strscpy" title="strscpy"><code class="xref c c-func docutils literal"><span class="pre">strscpy()</span></code></a>
with an overflow test, then just <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> the tail of the dest buffer.</p>
<dl class="function">
<dt id="c.strcat">
char * <code class="descname">strcat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append one <code class="docutils literal"><span class="pre">NUL-terminated</span></code> string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
</dl>
<dl class="function">
<dt id="c.strncat">
char * <code class="descname">strncat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a length-limited, C-string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum numbers of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that in contrast to <a class="reference internal" href="#c.strncpy" title="strncpy"><code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code></a>, <a class="reference internal" href="#c.strncat" title="strncat"><code class="xref c c-func docutils literal"><span class="pre">strncat()</span></code></a> ensures the result is
terminated.</p>
<dl class="function">
<dt id="c.strlcat">
size_t <code class="descname">strlcat</code><span class="sig-paren">(</span>char *<em>&nbsp;dest</em>, const char *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a length-limited, C-string to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>The string to be appended to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>The string to append to it</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the destination buffer.</dd>
</dl>
<dl class="function">
<dt id="c.strcmp">
int <code class="descname">strcmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another string</dd>
</dl>
<dl class="function">
<dt id="c.strncmp">
int <code class="descname">strncmp</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strncmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two length-limited strings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another string</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to compare</dd>
</dl>
<dl class="function">
<dt id="c.strchr">
char * <code class="descname">strchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first occurrence of a character in a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.strchrnul">
char * <code class="descname">strchrnul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strchrnul" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and return a character in a string, or end of string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to first occurrence of &#8216;c&#8217; in s. If c is not found, then
return a pointer to the null byte at the end of s.</p>
<dl class="function">
<dt id="c.strrchr">
char * <code class="descname">strrchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strrchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the last occurrence of a character in a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.strnchr">
char * <code class="descname">strnchr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em>, int<em>&nbsp;c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in a length limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of characters to be searched</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The character to search for</dd>
</dl>
<dl class="function">
<dt id="c.skip_spaces">
char * <code class="descname">skip_spaces</code><span class="sig-paren">(</span>const char *<em>&nbsp;str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.skip_spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading whitespace from <strong>str</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>The string to be stripped.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the first non-whitespace character in <strong>str</strong>.</p>
<dl class="function">
<dt id="c.strim">
char * <code class="descname">strim</code><span class="sig-paren">(</span>char *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strim" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes leading and trailing whitespace from <strong>s</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be stripped.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the first trailing whitespace is replaced with a <code class="docutils literal"><span class="pre">NUL-terminator</span></code>
in the given string <strong>s</strong>. Returns a pointer to the first non-whitespace
character in <strong>s</strong>.</p>
<dl class="function">
<dt id="c.strlen">
size_t <code class="descname">strlen</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the length of a string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be sized</dd>
</dl>
<dl class="function">
<dt id="c.strnlen">
size_t <code class="descname">strnlen</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnlen" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the length of a length-limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be sized</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The maximum number of bytes to search</dd>
</dl>
<dl class="function">
<dt id="c.strspn">
size_t <code class="descname">strspn</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, const char *<em>&nbsp;accept</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strspn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which only contain letters in <strong>accept</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">accept</span></code></dt>
<dd>The string to search for</dd>
</dl>
<dl class="function">
<dt id="c.strcspn">
size_t <code class="descname">strcspn</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, const char *<em>&nbsp;reject</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strcspn" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the length of the initial substring of <strong>s</strong> which does not contain letters in <strong>reject</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">reject</span></code></dt>
<dd>The string to avoid</dd>
</dl>
<dl class="function">
<dt id="c.strpbrk">
char * <code class="descname">strpbrk</code><span class="sig-paren">(</span>const char *<em>&nbsp;cs</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strpbrk" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first occurrence of a set of characters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>The characters to search for</dd>
</dl>
<dl class="function">
<dt id="c.strsep">
char * <code class="descname">strsep</code><span class="sig-paren">(</span>char **<em>&nbsp;s</em>, const char *<em>&nbsp;ct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strsep" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a string into tokens</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">s</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>The characters to search for</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.strsep" title="strsep"><code class="xref c c-func docutils literal"><span class="pre">strsep()</span></code></a> updates <strong>s</strong> to point after the token, ready for the next call.</p>
<p>It returns empty tokens, too, behaving exactly like the libc function
of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
Same semantics, slimmer shape. ;)</p>
<dl class="function">
<dt id="c.sysfs_streq">
bool <code class="descname">sysfs_streq</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sysfs_streq" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if strings are equal, modulo trailing newline</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>one string</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>another string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine returns true iff two strings are equal, treating both
NUL and newline-then-NUL as equivalent string terminations.  It&#8217;s
geared for use with sysfs input strings, which generally terminate
with newlines but are compared against values without newlines.</p>
<dl class="function">
<dt id="c.match_string">
int <code class="descname">match_string</code><span class="sig-paren">(</span>const char *const *<em>&nbsp;array</em>, size_t<em>&nbsp;n</em>, const char *<em>&nbsp;string</em><span class="sig-paren">)</span><a class="headerlink" href="#c.match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>array of strings</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of strings in the array or -1 for NULL terminated arrays</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">string</span></code></dt>
<dd>string to match with</dd>
</dl>
<p><strong>Return</strong></p>
<p>index of a <strong>string</strong> in the <strong>array</strong> if matches, or <code class="docutils literal"><span class="pre">-EINVAL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.__sysfs_match_string">
int <code class="descname">__sysfs_match_string</code><span class="sig-paren">(</span>const char *const *<em>&nbsp;array</em>, size_t<em>&nbsp;n</em>, const char *<em>&nbsp;str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__sysfs_match_string" title="Permalink to this definition">¶</a></dt>
<dd><p>matches given string in an array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">array</span></code></dt>
<dd>array of strings</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>number of strings in the array or -1 for NULL terminated arrays</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>string to match with</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns index of <strong>str</strong> in the <strong>array</strong> or -EINVAL, just like <a class="reference internal" href="#c.match_string" title="match_string"><code class="xref c c-func docutils literal"><span class="pre">match_string()</span></code></a>.
Uses sysfs_streq instead of strcmp for matching.</p>
<dl class="function">
<dt id="c.memset">
void * <code class="descname">memset</code><span class="sig-paren">(</span>void *<em>&nbsp;s</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of memory with the given value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not use <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> to access IO space, use <code class="xref c c-func docutils literal"><span class="pre">memset_io()</span></code> instead.</p>
<dl class="function">
<dt id="c.memzero_explicit">
void <code class="descname">memzero_explicit</code><span class="sig-paren">(</span>void *<em>&nbsp;s</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memzero_explicit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a region of memory (e.g. sensitive keying data) with 0s.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Note</strong></p>
<p>usually using <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> is just fine (!), but in cases
where clearing out _local_ data at the end of a scope is
necessary, <a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal"><span class="pre">memzero_explicit()</span></code></a> should be used instead in
order to prevent the compiler from optimising away zeroing.</p>
<p><a class="reference internal" href="#c.memzero_explicit" title="memzero_explicit"><code class="xref c c-func docutils literal"><span class="pre">memzero_explicit()</span></code></a> doesn&#8217;t need an arch-specific version as
it just invokes the one of <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> implicitly.</p>
<dl class="function">
<dt id="c.memset16">
void * <code class="descname">memset16</code><span class="sig-paren">(</span>uint16_t *<em>&nbsp;s</em>, uint16_t<em>&nbsp;v</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset16" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint16_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint16_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">uint16_t</span> <span class="pre">v</span></code></dt>
<dd>The value to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of values to store</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> in that it fills with a uint16_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint16_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memset32">
void * <code class="descname">memset32</code><span class="sig-paren">(</span>uint32_t *<em>&nbsp;s</em>, uint32_t<em>&nbsp;v</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset32" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint32_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">v</span></code></dt>
<dd>The value to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of values to store</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> in that it fills with a uint32_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint32_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memset64">
void * <code class="descname">memset64</code><span class="sig-paren">(</span>uint64_t *<em>&nbsp;s</em>, uint64_t<em>&nbsp;v</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memset64" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a memory area with a uint64_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>Pointer to the start of the area.</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">v</span></code></dt>
<dd>The value to fill the area with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The number of values to store</dd>
</dl>
<p><strong>Description</strong></p>
<p>Differs from <a class="reference internal" href="#c.memset" title="memset"><code class="xref c c-func docutils literal"><span class="pre">memset()</span></code></a> in that it fills with a uint64_t instead
of a byte.  Remember that <strong>count</strong> is the number of uint64_ts to
store, not the number of bytes.</p>
<dl class="function">
<dt id="c.memcpy">
void * <code class="descname">memcpy</code><span class="sig-paren">(</span>void *<em>&nbsp;dest</em>, const void *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>You should not use this function to access IO space, use <code class="xref c c-func docutils literal"><span class="pre">memcpy_toio()</span></code>
or <code class="xref c c-func docutils literal"><span class="pre">memcpy_fromio()</span></code> instead.</p>
<dl class="function">
<dt id="c.memmove">
void * <code class="descname">memmove</code><span class="sig-paren">(</span>void *<em>&nbsp;dest</em>, const void *<em>&nbsp;src</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memmove" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy one area of memory to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dest</span></code></dt>
<dd>Where to copy to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Where to copy from</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.memcpy" title="memcpy"><code class="xref c c-func docutils literal"><span class="pre">memcpy()</span></code></a>, <a class="reference internal" href="#c.memmove" title="memmove"><code class="xref c c-func docutils literal"><span class="pre">memmove()</span></code></a> copes with overlapping areas.</p>
<dl class="function">
<dt id="c.memcmp">
__visible int <code class="descname">memcmp</code><span class="sig-paren">(</span>const void *<em>&nbsp;cs</em>, const void *<em>&nbsp;ct</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memcmp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two areas of memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">cs</span></code></dt>
<dd>One area of memory</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">ct</span></code></dt>
<dd>Another area of memory</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<dl class="function">
<dt id="c.memscan">
void * <code class="descname">memscan</code><span class="sig-paren">(</span>void *<em>&nbsp;addr</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memscan" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or 1 byte past
the area if <strong>c</strong> is not found</p>
<dl class="function">
<dt id="c.strstr">
char * <code class="descname">strstr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first substring in a <code class="docutils literal"><span class="pre">NUL</span></code> terminated string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The string to search for</dd>
</dl>
<dl class="function">
<dt id="c.strnstr">
char * <code class="descname">strnstr</code><span class="sig-paren">(</span>const char *<em>&nbsp;s1</em>, const char *<em>&nbsp;s2</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strnstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the first substring in a length-limited string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s1</span></code></dt>
<dd>The string to be searched</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s2</span></code></dt>
<dd>The string to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>the maximum number of characters to search</dd>
</dl>
<dl class="function">
<dt id="c.memchr">
void * <code class="descname">memchr</code><span class="sig-paren">(</span>const void *<em>&nbsp;s</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>The byte to search for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first occurrence of <strong>c</strong>, or <code class="docutils literal"><span class="pre">NULL</span></code>
if <strong>c</strong> is not found</p>
<dl class="function">
<dt id="c.memchr_inv">
void * <code class="descname">memchr_inv</code><span class="sig-paren">(</span>const void *<em>&nbsp;start</em>, int<em>&nbsp;c</em>, size_t<em>&nbsp;bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memchr_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an unmatching character in an area of memory.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>The memory area</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">c</span></code></dt>
<dd>Find a character other than c</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">bytes</span></code></dt>
<dd>The size of the area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns the address of the first character other than <strong>c</strong>, or <code class="docutils literal"><span class="pre">NULL</span></code>
if the whole buffer contains just <strong>c</strong>.</p>
<dl class="function">
<dt id="c.strreplace">
char * <code class="descname">strreplace</code><span class="sig-paren">(</span>char *<em>&nbsp;s</em>, char<em>&nbsp;old</em>, char<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strreplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all occurrences of character in string.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to operate on.</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">old</span></code></dt>
<dd>The character being replaced.</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">new</span></code></dt>
<dd>The character <strong>old</strong> is replaced with.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns pointer to the nul byte at the end of <strong>s</strong>.</p>
<dl class="function">
<dt id="c.kstrdup">
char * <code class="descname">kstrdup</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<dl class="function">
<dt id="c.kstrdup_const">
const char * <code class="descname">kstrdup_const</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrdup_const" title="Permalink to this definition">¶</a></dt>
<dd><p>conditionally duplicate an existing const string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function returns source string if it is in .rodata section otherwise it
fallbacks to kstrdup.
Strings allocated by kstrdup_const should be freed by kfree_const.</p>
<dl class="function">
<dt id="c.kstrndup">
char * <code class="descname">kstrndup</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;max</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrndup" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate space for and copy an existing string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">max</span></code></dt>
<dd>read at most <strong>max</strong> chars from <strong>s</strong></dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<p><strong>Note</strong></p>
<p>Use <a class="reference internal" href="#c.kmemdup_nul" title="kmemdup_nul"><code class="xref c c-func docutils literal"><span class="pre">kmemdup_nul()</span></code></a> instead if the size is known exactly.</p>
<dl class="function">
<dt id="c.kmemdup">
void * <code class="descname">kmemdup</code><span class="sig-paren">(</span>const void *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate region of memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>memory region to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>memory region length</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>GFP mask to use</dd>
</dl>
<dl class="function">
<dt id="c.kmemdup_nul">
char * <code class="descname">kmemdup_nul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, size_t<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmemdup_nul" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a NUL-terminated string from unterminated data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The data to stringify</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>The size of the data</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a> call when allocating memory</dd>
</dl>
<dl class="function">
<dt id="c.memdup_user">
void * <code class="descname">memdup_user</code><span class="sig-paren">(</span>const void __user *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source address in user space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure.  Result is physically
contiguous, to be freed by <a class="reference internal" href="mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a>.</p>
<dl class="function">
<dt id="c.vmemdup_user">
void * <code class="descname">vmemdup_user</code><span class="sig-paren">(</span>const void __user *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vmemdup_user" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source address in user space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure.  Result may be not
physically contiguous.  Use <a class="reference internal" href="mm-api.html#c.kvfree" title="kvfree"><code class="xref c c-func docutils literal"><span class="pre">kvfree()</span></code></a> to free.</p>
<dl class="function">
<dt id="c.strndup_user">
char * <code class="descname">strndup_user</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;s</em>, long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.strndup_user" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate an existing string from user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>Maximum number of bytes to copy, including the trailing NUL.</dd>
</dl>
<dl class="function">
<dt id="c.memdup_user_nul">
void * <code class="descname">memdup_user_nul</code><span class="sig-paren">(</span>const void __user *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memdup_user_nul" title="Permalink to this definition">¶</a></dt>
<dd><p>duplicate memory region from user space and NUL-terminate</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source address in user space</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure.</p>
</div>
</div>
<div class="section" id="basic-kernel-library-functions">
<h2>Basic Kernel Library Functions<a class="headerlink" href="#basic-kernel-library-functions" title="Permalink to this headline">¶</a></h2>
<p>The Linux kernel provides more basic utility functions.</p>
<div class="section" id="bit-operations">
<h3>Bit Operations<a class="headerlink" href="#bit-operations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.set_bit">
void <code class="descname">set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Atomically set a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is atomic and may not be reordered.  See <a class="reference internal" href="#c.__set_bit" title="__set_bit"><code class="xref c c-func docutils literal"><span class="pre">__set_bit()</span></code></a>
if you do not require the atomic guarantees.</p>
<p><strong>Note</strong></p>
<p>there are no guarantees that this function will not be reordered
on non x86 architectures, so if you are writing portable code,
make sure not to rely on its reordering guarantees.</p>
<p>Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
<dl class="function">
<dt id="c.__set_bit">
void <code class="descname">__set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.set_bit" title="set_bit"><code class="xref c c-func docutils literal"><span class="pre">set_bit()</span></code></a>, this function is non-atomic and may be reordered.
If it&#8217;s called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.</p>
<dl class="function">
<dt id="c.clear_bit">
void <code class="descname">clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.clear_bit" title="clear_bit"><code class="xref c c-func docutils literal"><span class="pre">clear_bit()</span></code></a> is atomic and may not be reordered.  However, it does
not contain a memory barrier, so if it is used for locking purposes,
you should call <code class="xref c c-func docutils literal"><span class="pre">smp_mb__before_atomic()</span></code> and/or <code class="xref c c-func docutils literal"><span class="pre">smp_mb__after_atomic()</span></code>
in order to ensure changes are visible on other processors.</p>
<dl class="function">
<dt id="c.__change_bit">
void <code class="descname">__change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>the bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>the address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unlike <a class="reference internal" href="#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal"><span class="pre">change_bit()</span></code></a>, this function is non-atomic and may be reordered.
If it&#8217;s called on the same region of memory simultaneously, the effect
may be that only one operation succeeds.</p>
<dl class="function">
<dt id="c.change_bit">
void <code class="descname">change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle a bit in memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.change_bit" title="change_bit"><code class="xref c c-func docutils literal"><span class="pre">change_bit()</span></code></a> is atomic and may not be reordered.
Note that <strong>nr</strong> may be almost arbitrarily large; this function is not
restricted to acting on a single-word quantity.</p>
<dl class="function">
<dt id="c.test_and_set_bit">
bool <code class="descname">test_and_set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.test_and_set_bit_lock">
bool <code class="descname">test_and_set_bit_lock</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_set_bit_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value for lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as test_and_set_bit on x86.</p>
<dl class="function">
<dt id="c.__test_and_set_bit">
bool <code class="descname">__test_and_set_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_set_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to set</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic and can be reordered.
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.</p>
<dl class="function">
<dt id="c.test_and_clear_bit">
bool <code class="descname">test_and_clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.__test_and_clear_bit">
bool <code class="descname">__test_and_clear_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__test_and_clear_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to clear</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is non-atomic and can be reordered.
If two examples of this operation race, one can appear to succeed
but actually fail.  You must protect multiple accesses with a lock.</p>
<p><strong>Note</strong></p>
<p>the operation is performed atomically with respect to
the local CPU, but not other CPUs. Portable code should not
rely on this behaviour.
KVM relies on this behaviour on x86 for modifying memory that is also
accessed from a hypervisor on the same CPU if running in a VM: don&#8217;t change
this without also updating arch/x86/kernel/kvm.c</p>
<dl class="function">
<dt id="c.test_and_change_bit">
bool <code class="descname">test_and_change_bit</code><span class="sig-paren">(</span>long<em>&nbsp;nr</em>, volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_and_change_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a bit and return its old value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">nr</span></code></dt>
<dd>Bit to change</dd>
<dt><code class="docutils literal"><span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to count from</dd>
</dl>
<p><strong>Description</strong></p>
<p>This operation is atomic and cannot be reordered.
It also implies a memory barrier.</p>
<dl class="function">
<dt id="c.test_bit">
bool <code class="descname">test_bit</code><span class="sig-paren">(</span>int<em>&nbsp;nr</em>, const volatile unsigned long *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.test_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether a bit is set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>bit number to test</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">volatile</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Address to start counting from</dd>
</dl>
<dl class="function">
<dt id="c.__ffs">
unsigned long <code class="descname">__ffs</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;word</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__ffs" title="Permalink to this definition">¶</a></dt>
<dd><p>find first set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">word</span></code></dt>
<dd>The word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undefined if no bit exists, so code should check against 0 first.</p>
<dl class="function">
<dt id="c.ffz">
unsigned long <code class="descname">ffz</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;word</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ffz" title="Permalink to this definition">¶</a></dt>
<dd><p>find first zero bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">word</span></code></dt>
<dd>The word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undefined if no zero exists, so code should check against ~0UL first.</p>
<dl class="function">
<dt id="c.ffs">
int <code class="descname">ffs</code><span class="sig-paren">(</span>int<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ffs" title="Permalink to this definition">¶</a></dt>
<dd><p>find first set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined the same way as the libc and compiler builtin ffs
routines, therefore differs in spirit from the other bitops.</p>
<p>ffs(value) returns 0 if value is 0 or the position of the first
set bit if value is nonzero. The first (least significant) bit
is at position 1.</p>
<dl class="function">
<dt id="c.fls">
int <code class="descname">fls</code><span class="sig-paren">(</span>int<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fls" title="Permalink to this definition">¶</a></dt>
<dd><p>find last set bit in word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined in a similar way as the libc and compiler builtin
ffs, but returns the position of the most significant set bit.</p>
<p>fls(value) returns 0 if value is 0 or the position of the last
set bit if value is nonzero. The last (most significant) bit is
at position 32.</p>
<dl class="function">
<dt id="c.fls64">
int <code class="descname">fls64</code><span class="sig-paren">(</span>__u64<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fls64" title="Permalink to this definition">¶</a></dt>
<dd><p>find last set bit in a 64-bit word</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__u64</span> <span class="pre">x</span></code></dt>
<dd>the word to search</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is defined in a similar way as the libc and compiler builtin
ffsll, but returns the position of the most significant set bit.</p>
<p>fls64(value) returns 0 if value is 0 or the position of the last
set bit if value is nonzero. The last (most significant) bit is
at position 64.</p>
</div>
<div class="section" id="bitmap-operations">
<h3>Bitmap Operations<a class="headerlink" href="#bitmap-operations" title="Permalink to this headline">¶</a></h3>
<p>bitmaps provide an array of bits, implemented using an an
array of unsigned longs.  The number of valid bits in a
given bitmap does _not_ need to be an exact multiple of
BITS_PER_LONG.</p>
<p>The possible unused bits in the last, partially used word
of a bitmap are &#8216;don&#8217;t care&#8217;.  The implementation makes
no particular effort to keep them zero.  It ensures that
their value will not affect the results of any operation.
The bitmap operations that return Boolean (bitmap_empty,
for example) or scalar (bitmap_weight, for example) results
carefully filter out these unused bits from impacting their
results.</p>
<p>These operations actually hold to a slightly stronger rule:
if you don&#8217;t input any bitmaps to these ops that have some
unused bits set, then they won&#8217;t output any set unused bits
in output bitmaps.</p>
<p>The byte ordering of bitmaps is more natural on little
endian architectures.  See the big-endian headers
include/asm-ppc64/bitops.h and include/asm-s390/bitops.h
for the best explanations of this ordering.</p>
<p>The DECLARE_BITMAP(name,bits) macro, in linux/types.h, can be used
to declare an array named &#8216;name&#8217; of just enough unsigned longs to
contain all bit positions from 0 to &#8216;bits&#8217; - 1.</p>
<p>The available bitmap operations and their rough meaning in the
case that the bitmap is a single unsigned long are thus:</p>
<p>Note that nbits should be always a compile time evaluable constant.
Otherwise many inlines will generate horrible code.</p>
<div class="highlight-none"><div class="highlight"><pre>bitmap_zero(dst, nbits)                     *dst = 0UL
bitmap_fill(dst, nbits)                     *dst = ~0UL
bitmap_copy(dst, src, nbits)                *dst = *src
bitmap_and(dst, src1, src2, nbits)          *dst = *src1 &amp; *src2
bitmap_or(dst, src1, src2, nbits)           *dst = *src1 | *src2
bitmap_xor(dst, src1, src2, nbits)          *dst = *src1 ^ *src2
bitmap_andnot(dst, src1, src2, nbits)       *dst = *src1 &amp; ~(*src2)
bitmap_complement(dst, src, nbits)          *dst = ~(*src)
bitmap_equal(src1, src2, nbits)             Are *src1 and *src2 equal?
bitmap_intersects(src1, src2, nbits)        Do *src1 and *src2 overlap?
bitmap_subset(src1, src2, nbits)            Is *src1 a subset of *src2?
bitmap_empty(src, nbits)                    Are all bits zero in *src?
bitmap_full(src, nbits)                     Are all bits set in *src?
bitmap_weight(src, nbits)                   Hamming Weight: number set bits
bitmap_set(dst, pos, nbits)                 Set specified bit area
bitmap_clear(dst, pos, nbits)               Clear specified bit area
bitmap_find_next_zero_area(buf, len, pos, n, mask)  Find bit free area
bitmap_find_next_zero_area_off(buf, len, pos, n, mask)  as above
bitmap_shift_right(dst, src, n, nbits)      *dst = *src &gt;&gt; n
bitmap_shift_left(dst, src, n, nbits)       *dst = *src &lt;&lt; n
bitmap_remap(dst, src, old, new, nbits)     *dst = map(old, new)(src)
bitmap_bitremap(oldbit, old, new, nbits)    newbit = map(old, new)(oldbit)
bitmap_onto(dst, orig, relmap, nbits)       *dst = orig relative to relmap
bitmap_fold(dst, orig, sz, nbits)           dst bits = orig bits mod sz
bitmap_parse(buf, buflen, dst, nbits)       Parse bitmap dst from kernel buf
bitmap_parse_user(ubuf, ulen, dst, nbits)   Parse bitmap dst from user buf
bitmap_parselist(buf, dst, nbits)           Parse bitmap dst from kernel buf
bitmap_parselist_user(buf, dst, nbits)      Parse bitmap dst from user buf
bitmap_find_free_region(bitmap, bits, order)  Find and allocate bit region
bitmap_release_region(bitmap, pos, order)   Free specified bit region
bitmap_allocate_region(bitmap, pos, order)  Allocate specified bit region
bitmap_from_arr32(dst, buf, nbits)          Copy nbits from u32[] buf to dst
bitmap_to_arr32(buf, src, nbits)            Copy nbits from buf to u32[] dst
</pre></div>
</div>
<p>Note, <code class="xref c c-func docutils literal"><span class="pre">bitmap_zero()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">bitmap_fill()</span></code> operate over the region of
unsigned longs, that is, bits behind bitmap till the unsigned long
boundary will be zeroed or filled as well. Consider to use
<code class="xref c c-func docutils literal"><span class="pre">bitmap_clear()</span></code> or <code class="xref c c-func docutils literal"><span class="pre">bitmap_set()</span></code> to make explicit zeroing or filling
respectively.</p>
<p>Also the following operations in asm/bitops.h apply to bitmaps.:</p>
<div class="highlight-none"><div class="highlight"><pre>set_bit(bit, addr)                  *addr |= bit
clear_bit(bit, addr)                *addr &amp;= ~bit
change_bit(bit, addr)               *addr ^= bit
test_bit(bit, addr)                 Is bit set in *addr?
test_and_set_bit(bit, addr)         Set bit and return old value
test_and_clear_bit(bit, addr)       Clear bit and return old value
test_and_change_bit(bit, addr)      Change bit and return old value
find_first_zero_bit(addr, nbits)    Position first zero bit in *addr
find_first_bit(addr, nbits)         Position first set bit in *addr
find_next_zero_bit(addr, nbits, bit)
                                    Position next zero bit in *addr &gt;= bit
find_next_bit(addr, nbits, bit)     Position next set bit in *addr &gt;= bit
find_next_and_bit(addr1, addr2, nbits, bit)
                                    Same as find_next_bit, but in
                                    (*addr1 &amp; *addr2)
</pre></div>
</div>
<dl class="function">
<dt id="c.__bitmap_shift_right">
void <code class="descname">__bitmap_shift_right</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned<em>&nbsp;shift</em>, unsigned<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_right" title="Permalink to this definition">¶</a></dt>
<dd><p>logical right shift of the bits in a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">shift</span></code></dt>
<dd>shift by this many bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">nbits</span></code></dt>
<dd>bitmap size, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting right (dividing) means moving bits in the MS -&gt; LS bit
direction.  Zeros are fed into the vacated MS positions and the
LS bits shifted off the bottom are lost.</p>
<dl class="function">
<dt id="c.__bitmap_shift_left">
void <code class="descname">__bitmap_shift_left</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned int<em>&nbsp;shift</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_shift_left" title="Permalink to this definition">¶</a></dt>
<dd><p>logical left shift of the bits in a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>source bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">shift</span></code></dt>
<dd>shift by this many bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>bitmap size, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifting left (multiplying) means moving bits in the LS -&gt; MS
direction.  Zeros are fed into the vacated LS bit positions
and those MS bits shifted off the top are lost.</p>
<dl class="function">
<dt id="c.bitmap_find_next_zero_area_off">
unsigned long <code class="descname">bitmap_find_next_zero_area_off</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;map</em>, unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;start</em>, unsigned int<em>&nbsp;nr</em>, unsigned long<em>&nbsp;align_mask</em>, unsigned long<em>&nbsp;align_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_next_zero_area_off" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned zero area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">map</span></code></dt>
<dd>The address to base the search on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>The bitmap size in bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>The bitnumber to start searching at</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>The number of zeroed bits we&#8217;re looking for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_mask</span></code></dt>
<dd>Alignment mask for zero area</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_offset</span></code></dt>
<dd>Alignment offset for zero area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>align_mask</strong> should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds plus <strong>align_offset</strong>
is multiple of that power of 2.</p>
<dl class="function">
<dt id="c.__bitmap_parse">
int <code class="descname">__bitmap_parse</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;buflen</em>, int<em>&nbsp;is_user</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an ASCII hex string into a bitmap.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">is_user</span></code></dt>
<dd>location of buffer, 0 indicates kernel space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Commas group hex digits into chunks.  Each chunk defines exactly 32
bits of the resultant bitmask.  No chunk may specify a value larger
than 32 bits (<code class="docutils literal"><span class="pre">-EOVERFLOW</span></code>), and if a chunk specifies a smaller value
then leading 0-bits are prepended.  <code class="docutils literal"><span class="pre">-EINVAL</span></code> is returned for illegal
characters and for grouping errors such as &#8220;1,,5&#8221;, &#8221;,44&#8221;, &#8221;,&#8221; and &#8220;&#8221;.
Leading and trailing whitespace accepted, but not embedded whitespace.</p>
<dl class="function">
<dt id="c.bitmap_parse_user">
int <code class="descname">bitmap_parse_user</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;ubuf</em>, unsigned int<em>&nbsp;ulen</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parse_user" title="Permalink to this definition">¶</a></dt>
<dd><p>convert an ASCII hex string in a user buffer into a bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">ubuf</span></code></dt>
<dd>pointer to user buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper for <a class="reference internal" href="#c.__bitmap_parse" title="__bitmap_parse"><code class="xref c c-func docutils literal"><span class="pre">__bitmap_parse()</span></code></a>, providing it with user buffer.</p>
<p>We cannot have this as an inline function in bitmap.h because it needs
linux/uaccess.h to get the <a class="reference internal" href="mm-api.html#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> declaration and this causes
cyclic dependencies.</p>
<dl class="function">
<dt id="c.bitmap_print_to_pagebuf">
int <code class="descname">bitmap_print_to_pagebuf</code><span class="sig-paren">(</span>bool<em>&nbsp;list</em>, char *<em>&nbsp;buf</em>, const unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_print_to_pagebuf" title="Permalink to this definition">¶</a></dt>
<dd><p>convert bitmap to list or hex format ASCII string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">list</span></code></dt>
<dd>indicates whether the bitmap must be list</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>page aligned buffer into which string is placed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap to convert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits</dd>
</dl>
<p><strong>Description</strong></p>
<p>Output format is a comma-separated list of decimal numbers and
ranges if list is specified or hex digits grouped into comma-separated
sets of 8 digits/set. Returns the number of characters written to buf.</p>
<p>It is assumed that <strong>buf</strong> is a pointer into a PAGE_SIZE area and that
sufficient storage remains at <strong>buf</strong> to accommodate the
<a class="reference internal" href="#c.bitmap_print_to_pagebuf" title="bitmap_print_to_pagebuf"><code class="xref c c-func docutils literal"><span class="pre">bitmap_print_to_pagebuf()</span></code></a> output.</p>
<dl class="function">
<dt id="c.bitmap_parselist_user">
int <code class="descname">bitmap_parselist_user</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;ubuf</em>, unsigned int<em>&nbsp;ulen</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_parselist_user" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">ubuf</span></code></dt>
<dd>pointer to user buffer containing string.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ulen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>pointer to bitmap array that will contain result.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>size of bitmap, in bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wrapper for <code class="xref c c-func docutils literal"><span class="pre">bitmap_parselist()</span></code>, providing it with user buffer.</p>
<p>We cannot have this as an inline function in bitmap.h because it needs
linux/uaccess.h to get the <a class="reference internal" href="mm-api.html#c.access_ok" title="access_ok"><code class="xref c c-func docutils literal"><span class="pre">access_ok()</span></code></a> declaration and this causes
cyclic dependencies.</p>
<dl class="function">
<dt id="c.bitmap_remap">
void <code class="descname">bitmap_remap</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, const unsigned long *<em>&nbsp;old</em>, const unsigned long *<em>&nbsp;new</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply map defined by a pair of bitmaps to another bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>remapped result</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>subset to be remapped</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>defines domain of map</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>defines range of map</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight &#8216;w&#8217; of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>If either of the <strong>old</strong> and <strong>new</strong> bitmaps are empty, or if <strong>src</strong> and
<strong>dst</strong> point to the same location, then this routine copies <strong>src</strong>
to <strong>dst</strong>.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to <strong>src</strong>, placing the result in
<strong>dst</strong>, clearing any bits previously set in <strong>dst</strong>.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>src</strong> comes into this routine
with bits 1, 5 and 7 set, then <strong>dst</strong> should leave with bits 1,
13 and 15 set.</p>
<dl class="function">
<dt id="c.bitmap_bitremap">
int <code class="descname">bitmap_bitremap</code><span class="sig-paren">(</span>int<em>&nbsp;oldbit</em>, const unsigned long *<em>&nbsp;old</em>, const unsigned long *<em>&nbsp;new</em>, int<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_bitremap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply map defined by a pair of bitmaps to a single bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oldbit</span></code></dt>
<dd>bit position to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>defines domain of map</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>defines range of map</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Let <strong>old</strong> and <strong>new</strong> define a mapping of bit positions, such that
whatever position is held by the n-th set bit in <strong>old</strong> is mapped
to the n-th set bit in <strong>new</strong>.  In the more general case, allowing
for the possibility that the weight &#8216;w&#8217; of <strong>new</strong> is less than the
weight of <strong>old</strong>, map the position of the n-th set bit in <strong>old</strong> to
the position of the m-th set bit in <strong>new</strong>, where m == n % w.</p>
<p>The positions of unset bits in <strong>old</strong> are mapped to themselves
(the identify map).</p>
<p>Apply the above specified mapping to bit position <strong>oldbit</strong>, returning
the new bit position.</p>
<p>For example, lets say that <strong>old</strong> has bits 4 through 7 set, and
<strong>new</strong> has bits 12 through 15 set.  This defines the mapping of bit
position 4 to 12, 5 to 13, 6 to 14 and 7 to 15, and of all other
bit positions unchanged.  So if say <strong>oldbit</strong> is 5, then this routine
returns 13.</p>
<dl class="function">
<dt id="c.bitmap_onto">
void <code class="descname">bitmap_onto</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;orig</em>, const unsigned long *<em>&nbsp;relmap</em>, unsigned int<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_onto" title="Permalink to this definition">¶</a></dt>
<dd><p>translate one bitmap relative to another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>resulting translated bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">orig</span></code></dt>
<dd>original untranslated bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">relmap</span></code></dt>
<dd>bitmap relative to which translated</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the n-th bit of <strong>dst</strong> iff there exists some m such that the
n-th bit of <strong>relmap</strong> is set, the m-th bit of <strong>orig</strong> is set, and
the n-th bit of <strong>relmap</strong> is also the m-th _set_ bit of <strong>relmap</strong>.
(If you understood the previous sentence the first time your
read it, you&#8217;re overqualified for your current job.)</p>
<p>In other words, <strong>orig</strong> is mapped onto (surjectively) <strong>dst</strong>,
using the map { &lt;n, m&gt; | the n-th bit of <strong>relmap</strong> is the
m-th set bit of <strong>relmap</strong> }.</p>
<p>Any set bits in <strong>orig</strong> above bit number W, where W is the
weight of (number of set bits in) <strong>relmap</strong> are mapped nowhere.
In particular, if for all bits m set in <strong>orig</strong>, m &gt;= W, then
<strong>dst</strong> will end up empty.  In situations where the possibility
of such an empty result is not desired, one way to avoid it is
to use the <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> operator, below, to first fold the
<strong>orig</strong> bitmap over itself so that all its set bits x are in the
range 0 &lt;= x &lt; W.  The <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> operator does this by
setting the bit (m % W) in <strong>dst</strong>, for each bit (m) set in <strong>orig</strong>.</p>
<dl class="docutils">
<dt>Example [1] for <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a>:</dt>
<dd><p class="first">Let&#8217;s say <strong>relmap</strong> has bits 30-39 set, and <strong>orig</strong> has bits
1, 3, 5, 7, 9 and 11 set.  Then on return from this routine,
<strong>dst</strong> will have bits 31, 33, 35, 37 and 39 set.</p>
<p>When bit 0 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the first bit (if any)
that is turned on in <strong>relmap</strong>.  Since bit 0 was off in the
above example, we leave off that bit (bit 30) in <strong>dst</strong>.</p>
<p>When bit 1 is set in <strong>orig</strong> (as in the above example), it
means turn on the bit in <strong>dst</strong> corresponding to whatever
is the second bit that is turned on in <strong>relmap</strong>.  The second
bit in <strong>relmap</strong> that was turned on in the above example was
bit 31, so we turned on bit 31 in <strong>dst</strong>.</p>
<p>Similarly, we turned on bits 33, 35, 37 and 39 in <strong>dst</strong>,
because they were the 4th, 6th, 8th and 10th set bits
set in <strong>relmap</strong>, and the 4th, 6th, 8th and 10th bits of
<strong>orig</strong> (i.e. bits 3, 5, 7 and 9) were also set.</p>
<p class="last">When bit 11 is set in <strong>orig</strong>, it means turn on the bit in
<strong>dst</strong> corresponding to whatever is the twelfth bit that is
turned on in <strong>relmap</strong>.  In the above example, there were
only ten bits turned on in <strong>relmap</strong> (30..39), so that bit
11 was set in <strong>orig</strong> had no affect on <strong>dst</strong>.</p>
</dd>
<dt>Example [2] for <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> + <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a>:</dt>
<dd><p class="first">Let&#8217;s say <strong>relmap</strong> has these ten bits set:</p>
<div class="highlight-none"><div class="highlight"><pre>40 41 42 43 45 48 53 61 74 95
</pre></div>
</div>
<p>(for the curious, that&#8217;s 40 plus the first ten terms of the
Fibonacci sequence.)</p>
<p>Further lets say we use the following code, invoking
<a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> then bitmap_onto, as suggested above to
avoid the possibility of an empty <strong>dst</strong> result:</p>
<div class="highlight-none"><div class="highlight"><pre>unsigned long *tmp;     // a temporary bitmap&#39;s bits

bitmap_fold(tmp, orig, bitmap_weight(relmap, bits), bits);
bitmap_onto(dst, tmp, relmap, bits);
</pre></div>
</div>
<p>Then this table shows what various values of <strong>dst</strong> would be, for
various <strong>orig</strong>&#8216;s.  I list the zero-based positions of each set bit.
The tmp column shows the intermediate result, as computed by
using <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a> to fold the <strong>orig</strong> bitmap modulo ten
(the weight of <strong>relmap</strong>):</p>
<blockquote class="last">
<div><table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="30%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>orig</strong></td>
<td>tmp</td>
<td><strong>dst</strong></td>
</tr>
<tr class="row-even"><td>0</td>
<td>0</td>
<td>40</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>1</td>
<td>41</td>
</tr>
<tr class="row-even"><td>9</td>
<td>9</td>
<td>95</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>0</td>
<td>40 <a class="footnote-reference" href="#f1" id="id1">[1]</a></td>
</tr>
<tr class="row-even"><td>1 3 5 7</td>
<td>1 3 5 7</td>
<td>41 43 48 61</td>
</tr>
<tr class="row-odd"><td>0 1 2 3 4</td>
<td>0 1 2 3 4</td>
<td>40 41 42 43 45</td>
</tr>
<tr class="row-even"><td>0 9 18 27</td>
<td>0 9 8 7</td>
<td>40 61 74 95</td>
</tr>
<tr class="row-odd"><td>0 10 20 30</td>
<td>0</td>
<td>40</td>
</tr>
<tr class="row-even"><td>0 11 22 33</td>
<td>0 1 2 3</td>
<td>40 41 42 43</td>
</tr>
<tr class="row-odd"><td>0 12 24 36</td>
<td>0 2 4 6</td>
<td>40 42 45 53</td>
</tr>
<tr class="row-even"><td>78 102 211</td>
<td>1 2 8</td>
<td>41 42 74 <a class="footnote-reference" href="#f1" id="id2">[1]</a></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
</dl>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> For these marked lines, if we hadn&#8217;t first done <a class="reference internal" href="#c.bitmap_fold" title="bitmap_fold"><code class="xref c c-func docutils literal"><span class="pre">bitmap_fold()</span></code></a>
into tmp, then the <strong>dst</strong> result would have been empty.</td></tr>
</tbody>
</table>
<p>If either of <strong>orig</strong> or <strong>relmap</strong> is empty (no set bits), then <strong>dst</strong>
will be returned empty.</p>
<p>If (as explained above) the only set bits in <strong>orig</strong> are in positions
m where m &gt;= W, (where W is the weight of <strong>relmap</strong>) then <strong>dst</strong> will
once again be returned empty.</p>
<p>All bits in <strong>dst</strong> not set by the above rule are cleared.</p>
<dl class="function">
<dt id="c.bitmap_fold">
void <code class="descname">bitmap_fold</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;orig</em>, unsigned int<em>&nbsp;sz</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_fold" title="Permalink to this definition">¶</a></dt>
<dd><p>fold larger bitmap into smaller, modulo specified size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>resulting smaller bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">orig</span></code></dt>
<dd>original larger bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">sz</span></code></dt>
<dd>specified size</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in each of these bitmaps</dd>
</dl>
<p><strong>Description</strong></p>
<p>For each bit oldbit in <strong>orig</strong>, set bit oldbit mod <strong>sz</strong> in <strong>dst</strong>.
Clear all other bits in <strong>dst</strong>.  See further the comment and
Example [2] for <a class="reference internal" href="#c.bitmap_onto" title="bitmap_onto"><code class="xref c c-func docutils literal"><span class="pre">bitmap_onto()</span></code></a> for why and how to use this.</p>
<dl class="function">
<dt id="c.bitmap_find_free_region">
int <code class="descname">bitmap_find_free_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;bits</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_free_region" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned mem region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a region of free (zero) bits in a <strong>bitmap</strong> of <strong>bits</strong> bits and
allocate them (set them to one).  Only consider regions of length
a power (<strong>order</strong>) of two, aligned to that power of two, which
makes the search algorithm much faster.</p>
<p>Return the bit offset in bitmap of the allocated region,
or -errno on failure.</p>
<dl class="function">
<dt id="c.bitmap_release_region">
void <code class="descname">bitmap_release_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;pos</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>release allocated bitmap region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>beginning of bit region to release</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the complement to <code class="xref c c-func docutils literal"><span class="pre">__bitmap_find_free_region()</span></code> and releases
the found region (by clearing it in the bitmap).</p>
<p>No return value.</p>
<dl class="function">
<dt id="c.bitmap_allocate_region">
int <code class="descname">bitmap_allocate_region</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;pos</em>, int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_allocate_region" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate bitmap region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs corresponding to the bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>beginning of bit region to allocate</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>region size (log base 2 of number of bits) to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate (set bits in) a specified region of a bitmap.</p>
<p>Return 0 on success, or <code class="docutils literal"><span class="pre">-EBUSY</span></code> if specified region wasn&#8217;t
free (not all bits were zero).</p>
<dl class="function">
<dt id="c.bitmap_copy_le">
void <code class="descname">bitmap_copy_le</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, const unsigned long *<em>&nbsp;src</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_copy_le" title="Permalink to this definition">¶</a></dt>
<dd><p>copy a bitmap, putting the bits into little-endian order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>bitmap to copy</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in the bitmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>Require nbits % BITS_PER_LONG == 0.</p>
<dl class="function">
<dt id="c.bitmap_from_arr32">
void <code class="descname">bitmap_from_arr32</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;bitmap</em>, const u32 *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_arr32" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the contents of u32 array of bits to bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs, the destination bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>array of u32 (in host byte order), the source bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in <strong>bitmap</strong></dd>
</dl>
<dl class="function">
<dt id="c.bitmap_to_arr32">
void <code class="descname">bitmap_to_arr32</code><span class="sig-paren">(</span>u32 *<em>&nbsp;buf</em>, const unsigned long *<em>&nbsp;bitmap</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_to_arr32" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the contents of bitmap to a u32 array of bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>array of u32 (in host byte order), the dest bitmap</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">bitmap</span></code></dt>
<dd>array of unsigned longs, the source bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of bits in <strong>bitmap</strong></dd>
</dl>
<dl class="function">
<dt id="c.__bitmap_parselist">
int <code class="descname">__bitmap_parselist</code><span class="sig-paren">(</span>const char *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;buflen</em>, int<em>&nbsp;is_user</em>, unsigned long *<em>&nbsp;maskp</em>, int<em>&nbsp;nmaskbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__bitmap_parselist" title="Permalink to this definition">¶</a></dt>
<dd><p>convert list format ASCII string to bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>read nul-terminated user string from this buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">buflen</span></code></dt>
<dd>buffer size in bytes.  If string is smaller than this
then it must be terminated with a 0.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">is_user</span></code></dt>
<dd>location of buffer, 0 indicates kernel space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">maskp</span></code></dt>
<dd>write resulting mask here</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nmaskbits</span></code></dt>
<dd>number of bits in mask to be written</dd>
</dl>
<p><strong>Description</strong></p>
<p>Input format is a comma-separated list of decimal numbers and
ranges.  Consecutively set bits are shown as two hyphen-separated
decimal numbers, the smallest and largest bit numbers set in
the range.
Optionally each range can be postfixed to denote that only parts of it
should be set. The range will divided to groups of specific size.
From each group will be used only defined amount of bits.
Syntax: range:used_size/group_size</p>
<p><strong>Example</strong></p>
<p>0-1023:2/256 ==&gt; 0,1,256,257,512,513,768,769</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on invalid input strings. Error values:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: second number in range smaller than first</li>
<li><code class="docutils literal"><span class="pre">-EINVAL</span></code>: invalid character in string</li>
<li><code class="docutils literal"><span class="pre">-ERANGE</span></code>: bit number specified too large for mask</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="c.bitmap_pos_to_ord">
int <code class="descname">bitmap_pos_to_ord</code><span class="sig-paren">(</span>const unsigned long *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;pos</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_pos_to_ord" title="Permalink to this definition">¶</a></dt>
<dd><p>find ordinal of set bit at given position in bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to a bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pos</span></code></dt>
<dd>a bit position in <strong>buf</strong> (0 &lt;= <strong>pos</strong> &lt; <strong>nbits</strong>)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of valid bit positions in <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the bit at position <strong>pos</strong> in <strong>buf</strong> (of length <strong>nbits</strong>) to the
ordinal of which set bit it is.  If it is not set or if <strong>pos</strong>
is not a valid bit position, map to -1.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>pos</strong>
values 4 through 7 will get mapped to 0 through 3, respectively,
and other <strong>pos</strong> values will get mapped to -1.  When <strong>pos</strong> value 7
gets mapped to (returns) <strong>ord</strong> value 3 in this example, that means
that bit 7 is the 3rd (starting with 0th) set bit in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>bits</strong> are valid positions in <strong>buf</strong>.</p>
<dl class="function">
<dt id="c.bitmap_ord_to_pos">
unsigned int <code class="descname">bitmap_ord_to_pos</code><span class="sig-paren">(</span>const unsigned long *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;ord</em>, unsigned int<em>&nbsp;nbits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_ord_to_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find position of n-th set bit in bitmap</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to bitmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ord</span></code></dt>
<dd>ordinal bit position (n-th set bit, n &gt;= 0)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nbits</span></code></dt>
<dd>number of valid bit positions in <strong>buf</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the ordinal offset of bit <strong>ord</strong> in <strong>buf</strong> to its position in <strong>buf</strong>.
Value of <strong>ord</strong> should be in range 0 &lt;= <strong>ord</strong> &lt; weight(buf). If <strong>ord</strong>
&gt;= weight(buf), returns <strong>nbits</strong>.</p>
<p>If for example, just bits 4 through 7 are set in <strong>buf</strong>, then <strong>ord</strong>
values 0 through 3 will get mapped to 4 through 7, respectively,
and all other <strong>ord</strong> values returns <strong>nbits</strong>.  When <strong>ord</strong> value 3
gets mapped to (returns) <strong>pos</strong> value 7 in this example, that means
that the 3rd set bit (starting with 0th) is at position 7 in <strong>buf</strong>.</p>
<p>The bit positions 0 through <strong>nbits</strong>-1 are valid positions in <strong>buf</strong>.</p>
<dl class="function">
<dt id="c.bitmap_find_next_zero_area">
unsigned long <code class="descname">bitmap_find_next_zero_area</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;map</em>, unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;start</em>, unsigned int<em>&nbsp;nr</em>, unsigned long<em>&nbsp;align_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_find_next_zero_area" title="Permalink to this definition">¶</a></dt>
<dd><p>find a contiguous aligned zero area</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">map</span></code></dt>
<dd>The address to base the search on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>The bitmap size in bits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>The bitnumber to start searching at</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr</span></code></dt>
<dd>The number of zeroed bits we&#8217;re looking for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align_mask</span></code></dt>
<dd>Alignment mask for zero area</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>align_mask</strong> should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds is multiples of that
power of 2. A <strong>align_mask</strong> of 0 means no alignment is required.</p>
<dl class="function">
<dt id="c.BITMAP_FROM_U64">
<code class="descname">BITMAP_FROM_U64</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.BITMAP_FROM_U64" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent u64 value in the format suitable for bitmap.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>u64 value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Linux bitmaps are internally arrays of unsigned longs, i.e. 32-bit
integers in 32-bit environment, and 64-bit integers in 64-bit one.</p>
<p>There are four combinations of endianness and length of the word in linux
ABIs: LE64, BE64, LE32 and BE32.</p>
<p>On 64-bit kernels 64-bit LE and BE numbers are naturally ordered in
bitmaps and therefore don&#8217;t require any special handling.</p>
<p>On 32-bit kernels 32-bit LE ABI orders lo word of 64-bit number in memory
prior to hi, and 32-bit BE orders hi word prior to lo. The bitmap on the
other hand is represented as an array of 32-bit words and the position of
bit N may therefore be calculated as: word #(N/32) and bit #(N``32``) in that
word.  For example, bit #42 is located at 10th position of 2nd word.
It matches 32-bit LE ABI, and we can simply let the compiler store 64-bit
values in memory as it usually does. But for BE we need to swap hi and lo
words manually.</p>
<p>With all that, the macro <a class="reference internal" href="#c.BITMAP_FROM_U64" title="BITMAP_FROM_U64"><code class="xref c c-func docutils literal"><span class="pre">BITMAP_FROM_U64()</span></code></a> does explicit reordering of hi and
lo parts of u64.  For LE32 it does nothing, and for BE environment it swaps
hi and lo words, as is expected by bitmap.</p>
<dl class="function">
<dt id="c.bitmap_from_u64">
void <code class="descname">bitmap_from_u64</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;dst</em>, u64<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bitmap_from_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>Check and swap words within u64.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>destination bitmap</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">mask</span></code></dt>
<dd>source bitmap</dd>
</dl>
<p><strong>Description</strong></p>
<p>In 32-bit Big Endian kernel, when using <code class="docutils literal"><span class="pre">(u32</span> <span class="pre">*)(:c:type:`val`)[*]</span></code>
to read u64 mask, we will get the wrong word.
That is <code class="docutils literal"><span class="pre">(u32</span> <span class="pre">*)(:c:type:`val`)[0]</span></code> gets the upper 32 bits,
but we expect the lower 32-bits of u64.</p>
</div>
<div class="section" id="command-line-parsing">
<h3>Command-line Parsing<a class="headerlink" href="#command-line-parsing" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.get_option">
int <code class="descname">get_option</code><span class="sig-paren">(</span>char **<em>&nbsp;str</em>, int *<em>&nbsp;pint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse integer from an option string</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">str</span></code></dt>
<dd>option string</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">pint</span></code></dt>
<dd>(output) integer value parsed from <strong>str</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Read an int from an option string; if available accept a subsequent
comma as well.</p>
<p>Return values:
0 - no int in string
1 - int found, no subsequent comma
2 - int found including a subsequent comma
3 - hyphen found to denote a range</p>
</div></blockquote>
<dl class="function">
<dt id="c.get_options">
char * <code class="descname">get_options</code><span class="sig-paren">(</span>const char *<em>&nbsp;str</em>, int<em>&nbsp;nints</em>, int *<em>&nbsp;ints</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a string into a list of integers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">str</span></code></dt>
<dd>String to be parsed</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nints</span></code></dt>
<dd>size of integer array</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">ints</span></code></dt>
<dd>integer array</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function parses a string containing a comma-separated
list of integers, a hyphen-separated range of _positive_ integers,
or a combination of both.  The parse halts when the array is
full, or when no more numbers can be retrieved from the
string.</p>
<p>Return value is the character in the string which caused
the parse to end (typically a null terminator, if <strong>str</strong> is
completely parseable).</p>
</div></blockquote>
<dl class="function">
<dt id="c.memparse">
unsigned long long <code class="descname">memparse</code><span class="sig-paren">(</span>const char *<em>&nbsp;ptr</em>, char **<em>&nbsp;retptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memparse" title="Permalink to this definition">¶</a></dt>
<dd><p>parse a string with mem suffixes into a number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">ptr</span></code></dt>
<dd>Where parse begins</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">**</span> <span class="pre">retptr</span></code></dt>
<dd>(output) Optional pointer to next char after parse completes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Parses a string into a number.  The number stored at <strong>ptr</strong> is
potentially suffixed with K, M, G, T, P, E.</div></blockquote>
</div>
<div class="section" id="sorting">
<h3>Sorting<a class="headerlink" href="#sorting" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.sort">
void <code class="descname">sort</code><span class="sig-paren">(</span>void *<em>&nbsp;base</em>, size_t<em>&nbsp;num</em>, size_t<em>&nbsp;size</em>, int (*cmp_func) (const void<em>&nbsp;*</em>, const void<em>&nbsp;*</em>, void (*swap_func) (void<em>&nbsp;*</em>, void<em>&nbsp;*</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>sort an array of elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>pointer to data to sort</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">num</span></code></dt>
<dd>number of elements</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of each element</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(const</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">cmp_func</span></code></dt>
<dd>pointer to comparison function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">int</span> <span class="pre">size)</span> <span class="pre">swap_func</span></code></dt>
<dd>pointer to swap function or NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does a heapsort on the given array. You may provide a
swap_func function optimized to your element type.</p>
<p>Sorting time is O(n log n) both on average and worst-case. While
qsort is about 20% faster on average, it suffers from exploitable
O(n*n) worst-case behavior and extra memory requirements that make
it less suitable for kernel use.</p>
<dl class="function">
<dt id="c.list_sort">
void <code class="descname">list_sort</code><span class="sig-paren">(</span>void *<em>&nbsp;priv</em>, struct list_head *<em>&nbsp;head</em>, int (*cmp) (void<em>&nbsp;*priv</em>, struct list_head<em>&nbsp;*a</em>, struct list_head<em>&nbsp;*b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>sort a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>private data, opaque to <a class="reference internal" href="#c.list_sort" title="list_sort"><code class="xref c c-func docutils literal"><span class="pre">list_sort()</span></code></a>, passed to <strong>cmp</strong></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the list to sort</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*priv,</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*a,</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*b)</span> <span class="pre">cmp</span></code></dt>
<dd>the elements comparison function</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements &#8220;merge sort&#8221;, which has O(nlog(n))
complexity.</p>
<p>The comparison function <strong>cmp</strong> must return a negative value if <strong>a</strong>
should sort before <strong>b</strong>, and a positive value if <strong>a</strong> should sort after
<strong>b</strong>. If <strong>a</strong> and <strong>b</strong> are equivalent, and their original relative
ordering is to be preserved, <strong>cmp</strong> must return 0.</p>
</div>
<div class="section" id="text-searching">
<h3>Text Searching<a class="headerlink" href="#text-searching" title="Permalink to this headline">¶</a></h3>
<p>INTRODUCTION</p>
<blockquote>
<div>The textsearch infrastructure provides text searching facilities for
both linear and non-linear data. Individual search algorithms are
implemented in modules and chosen by the user.</div></blockquote>
<p>ARCHITECTURE</p>
<div class="highlight-none"><div class="highlight"><pre>  User
  +----------------+
  |        finish()|&lt;--------------(6)-----------------+
  |get_next_block()|&lt;--------------(5)---------------+ |
  |                |                     Algorithm   | |
  |                |                    +------------------------------+
  |                |                    |  init()   find()   destroy() |
  |                |                    +------------------------------+
  |                |       Core API           ^       ^          ^
  |                |      +---------------+  (2)     (4)        (8)
  |             (1)|-----&gt;| prepare()     |---+       |          |
  |             (3)|-----&gt;| find()/next() |-----------+          |
  |             (7)|-----&gt;| destroy()     |----------------------+
  +----------------+      +---------------+

(1) User configures a search by calling :c:func:`textsearch_prepare()` specifying
    the search parameters such as the pattern and algorithm name.
(2) Core requests the algorithm to allocate and initialize a search
    configuration according to the specified parameters.
(3) User starts the search(es) by calling :c:func:`textsearch_find()` or
    :c:func:`textsearch_next()` to fetch subsequent occurrences. A state variable
    is provided to the algorithm to store persistent variables.
(4) Core eventually resets the search offset and forwards the :c:func:`find()`
    request to the algorithm.
(5) Algorithm calls :c:func:`get_next_block()` provided by the user continuously
    to fetch the data to be searched in block by block.
(6) Algorithm invokes :c:func:`finish()` after the last call to get_next_block
    to clean up any leftovers from get_next_block. (Optional)
(7) User destroys the configuration by calling :c:func:`textsearch_destroy()`.
(8) Core notifies the algorithm to destroy algorithm specific
    allocations. (Optional)
</pre></div>
</div>
<p>USAGE</p>
<blockquote>
<div><p>Before a search can be performed, a configuration must be created
by calling <a class="reference internal" href="#c.textsearch_prepare" title="textsearch_prepare"><code class="xref c c-func docutils literal"><span class="pre">textsearch_prepare()</span></code></a> specifying the searching algorithm,
the pattern to look for and flags. As a flag, you can set TS_IGNORECASE
to perform case insensitive matching. But it might slow down
performance of algorithm, so you should use it at own your risk.
The returned configuration may then be used for an arbitrary
amount of times and even in parallel as long as a separate struct
ts_state variable is provided to every instance.</p>
<p>The actual search is performed by either calling
<a class="reference internal" href="#c.textsearch_find_continuous" title="textsearch_find_continuous"><code class="xref c c-func docutils literal"><span class="pre">textsearch_find_continuous()</span></code></a> for linear data or by providing
an own <code class="xref c c-func docutils literal"><span class="pre">get_next_block()</span></code> implementation and
calling <a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal"><span class="pre">textsearch_find()</span></code></a>. Both functions return
the position of the first occurrence of the pattern or UINT_MAX if
no match was found. Subsequent occurrences can be found by calling
<a class="reference internal" href="#c.textsearch_next" title="textsearch_next"><code class="xref c c-func docutils literal"><span class="pre">textsearch_next()</span></code></a> regardless of the linearity of the data.</p>
<p>Once you&#8217;re done using a configuration it must be given back via
textsearch_destroy.</p>
</div></blockquote>
<p>EXAMPLE:</p>
<div class="highlight-none"><div class="highlight"><pre>int pos;
struct ts_config *conf;
struct ts_state state;
const char *pattern = &quot;chicken&quot;;
const char *example = &quot;We dance the funky chicken&quot;;

conf = textsearch_prepare(&quot;kmp&quot;, pattern, strlen(pattern),
                          GFP_KERNEL, TS_AUTOLOAD);
if (IS_ERR(conf)) {
    err = PTR_ERR(conf);
    goto errout;
}

pos = textsearch_find_continuous(conf, \&amp;state, example, strlen(example));
if (pos != UINT_MAX)
    panic(&quot;Oh my god, dancing chickens at \%d\n&quot;, pos);

textsearch_destroy(conf);
</pre></div>
</div>
<dl class="function">
<dt id="c.textsearch_register">
int <code class="descname">textsearch_register</code><span class="sig-paren">(</span>struct ts_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a textsearch module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>operations lookup table</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by textsearch modules to announce
their presence. The specified &amp;**ops** must have <code class="docutils literal"><span class="pre">name</span></code> set to a
unique identifier and the callbacks <code class="xref c c-func docutils literal"><span class="pre">find()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">init()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">get_pattern()</span></code>,
and <code class="xref c c-func docutils literal"><span class="pre">get_pattern_len()</span></code> must be implemented.</p>
<p>Returns 0 or -EEXISTS if another module has already registered
with same name.</p>
<dl class="function">
<dt id="c.textsearch_unregister">
int <code class="descname">textsearch_unregister</code><span class="sig-paren">(</span>struct ts_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a textsearch module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>operations lookup table</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called by textsearch modules to announce
their disappearance for examples when the module gets unloaded.
The <code class="xref c c-type docutils literal"><span class="pre">ops</span></code> parameter must be the same as the one during the
registration.</p>
<p>Returns 0 on success or -ENOENT if no matching textsearch
registration was found.</p>
<dl class="function">
<dt id="c.textsearch_find_continuous">
unsigned int <code class="descname">textsearch_find_continuous</code><span class="sig-paren">(</span>struct ts_config *<em>&nbsp;conf</em>, struct ts_state *<em>&nbsp;state</em>, const void *<em>&nbsp;data</em>, unsigned int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_find_continuous" title="Permalink to this definition">¶</a></dt>
<dd><p>search a pattern in continuous/linear data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>search configuration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>search state</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data to search in</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of data</dd>
</dl>
<p><strong>Description</strong></p>
<p>A simplified version of <a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal"><span class="pre">textsearch_find()</span></code></a> for continuous/linear data.
Call <a class="reference internal" href="#c.textsearch_next" title="textsearch_next"><code class="xref c c-func docutils literal"><span class="pre">textsearch_next()</span></code></a> to retrieve subsequent matches.</p>
<p>Returns the position of first occurrence of the pattern or
<code class="docutils literal"><span class="pre">UINT_MAX</span></code> if no occurrence was found.</p>
<dl class="function">
<dt id="c.textsearch_prepare">
struct ts_config * <code class="descname">textsearch_prepare</code><span class="sig-paren">(</span>const char *<em>&nbsp;algo</em>, const void *<em>&nbsp;pattern</em>, unsigned int<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare a search</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">algo</span></code></dt>
<dd>name of search algorithm</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">pattern</span></code></dt>
<dd>pattern data</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of pattern</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocation mask</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>search flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Looks up the search algorithm module and creates a new textsearch
configuration for the specified pattern.</p>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>The format of the pattern may not be compatible between</dt>
<dd>the various search algorithms.</dd>
</dl>
<p>Returns a new textsearch configuration according to the specified
parameters or a <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>. If a zero length pattern is passed, this
function returns EINVAL.</p>
<dl class="function">
<dt id="c.textsearch_destroy">
void <code class="descname">textsearch_destroy</code><span class="sig-paren">(</span>struct ts_config *<em>&nbsp;conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a search configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>search configuration</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases all references of the configuration and frees
up the memory.</p>
<dl class="function">
<dt id="c.textsearch_next">
unsigned int <code class="descname">textsearch_next</code><span class="sig-paren">(</span>struct ts_config *<em>&nbsp;conf</em>, struct ts_state *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_next" title="Permalink to this definition">¶</a></dt>
<dd><p>continue searching for a pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>search configuration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>search state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continues a search looking for more occurrences of the pattern.
<a class="reference internal" href="#c.textsearch_find" title="textsearch_find"><code class="xref c c-func docutils literal"><span class="pre">textsearch_find()</span></code></a> must be called to find the first occurrence
in order to reset the state.</p>
<p>Returns the position of the next occurrence of the pattern or
UINT_MAX if not match was found.</p>
<dl class="function">
<dt id="c.textsearch_find">
unsigned int <code class="descname">textsearch_find</code><span class="sig-paren">(</span>struct ts_config *<em>&nbsp;conf</em>, struct ts_state *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_find" title="Permalink to this definition">¶</a></dt>
<dd><p>start searching for a pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>search configuration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>search state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the position of first occurrence of the pattern or
UINT_MAX if no match was found.</p>
<dl class="function">
<dt id="c.textsearch_get_pattern">
void * <code class="descname">textsearch_get_pattern</code><span class="sig-paren">(</span>struct ts_config *<em>&nbsp;conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_get_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>return head of the pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>search configuration</dd>
</dl>
<dl class="function">
<dt id="c.textsearch_get_pattern_len">
unsigned int <code class="descname">textsearch_get_pattern_len</code><span class="sig-paren">(</span>struct ts_config *<em>&nbsp;conf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.textsearch_get_pattern_len" title="Permalink to this definition">¶</a></dt>
<dd><p>return length of the pattern</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ts_config</span> <span class="pre">*</span> <span class="pre">conf</span></code></dt>
<dd>search configuration</dd>
</dl>
</div>
</div>
<div class="section" id="crc-and-math-functions-in-linux">
<h2>CRC and Math Functions in Linux<a class="headerlink" href="#crc-and-math-functions-in-linux" title="Permalink to this headline">¶</a></h2>
<div class="section" id="crc-functions">
<h3>CRC Functions<a class="headerlink" href="#crc-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.crc4">
uint8_t <code class="descname">crc4</code><span class="sig-paren">(</span>uint8_t<em>&nbsp;c</em>, uint64_t<em>&nbsp;x</em>, int<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc4" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the 4-bit crc of a value.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint8_t</span> <span class="pre">c</span></code></dt>
<dd>starting crc4</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">x</span></code></dt>
<dd>value to checksum</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bits</span></code></dt>
<dd>number of bits in <strong>x</strong> to checksum</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the crc4 value of <strong>x</strong>, using polynomial 0b10111.</p>
<p>The <strong>x</strong> value is treated as left-aligned, and bits above <strong>bits</strong> are ignored
in the crc calculations.</p>
<dl class="function">
<dt id="c.crc7_be">
u8 <code class="descname">crc7_be</code><span class="sig-paren">(</span>u8<em>&nbsp;crc</em>, const u8 *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc7_be" title="Permalink to this definition">¶</a></dt>
<dd><p>update the CRC7 for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC7 value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Context</strong></p>
<p>any</p>
<p><strong>Description</strong></p>
<p>Returns the updated CRC7 value.
The CRC7 is left-aligned in the byte (the lsbit is always 0), as that
makes the computation easier, and all callers want it in that form.</p>
<dl class="function">
<dt id="c.crc8_populate_msb">
void <code class="descname">crc8_populate_msb</code><span class="sig-paren">(</span>u8<em>&nbsp;table</em>, u8<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8_populate_msb" title="Permalink to this definition">¶</a></dt>
<dd><p>fill crc table for given polynomial in reverse bit order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">table</span></code></dt>
<dd>table to be filled.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">polynomial</span></code></dt>
<dd>polynomial for which table is to be filled.</dd>
</dl>
<dl class="function">
<dt id="c.crc8_populate_lsb">
void <code class="descname">crc8_populate_lsb</code><span class="sig-paren">(</span>u8<em>&nbsp;table</em>, u8<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8_populate_lsb" title="Permalink to this definition">¶</a></dt>
<dd><p>fill crc table for given polynomial in regular bit order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">table</span></code></dt>
<dd>table to be filled.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">polynomial</span></code></dt>
<dd>polynomial for which table is to be filled.</dd>
</dl>
<dl class="function">
<dt id="c.crc8">
u8 <code class="descname">crc8</code><span class="sig-paren">(</span>const u8<em>&nbsp;table</em>, u8 *<em>&nbsp;pdata</em>, size_t<em>&nbsp;nbytes</em>, u8<em>&nbsp;crc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc8" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate a crc8 over the given input data.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">table</span></code></dt>
<dd>crc table used for calculation.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">pdata</span></code></dt>
<dd>pointer to data buffer.</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">nbytes</span></code></dt>
<dd>number of bytes in data buffer.</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">crc</span></code></dt>
<dd>previous returned crc8 value.</dd>
</dl>
<dl class="function">
<dt id="c.crc16">
u16 <code class="descname">crc16</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, u8 const *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc16" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the CRC-16 for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value.</p>
<dl class="function">
<dt id="c.crc32_le_generic">
u32 __pure <code class="descname">crc32_le_generic</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, unsigned char const *<em>&nbsp;p</em>, size_t<em>&nbsp;len</em>, const u32 ( *<em>&nbsp;tab</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_le_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bitwise little-endian Ethernet AUTODIN II CRC32/CRC32C</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>seed value for computation.  ~0 for Ethernet, sometimes 0 for other
uses, or the previous crc32/crc32c value if computing incrementally.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to buffer over which CRC32/CRC32C is run</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of buffer <strong>p</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(</span> <span class="pre">*</span> <span class="pre">tab</span></code></dt>
<dd>little-endian Ethernet table</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>CRC32/CRC32c LE polynomial</dd>
</dl>
<dl class="function">
<dt id="c.crc32_generic_shift">
u32 __attribute_const__ <code class="descname">crc32_generic_shift</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, size_t<em>&nbsp;len</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_generic_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Append <strong>len</strong> 0 bytes to crc, in logarithmic time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>The original little-endian CRC (i.e. lsbit is x^31 coefficient)</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>The number of bytes. <strong>crc</strong> is multiplied by x^(8***len**)</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>The modulus used to reduce the result to 32 bits.</dd>
</dl>
<p><strong>Description</strong></p>
<p>It&#8217;s possible to parallelize CRC computations by computing a CRC
over separate ranges of a buffer, then summing them.
This shifts the given CRC by 8*len bits (i.e. produces the same effect
as appending len bytes of zero to the data), in time proportional
to log(len).</p>
<dl class="function">
<dt id="c.crc32_be_generic">
u32 __pure <code class="descname">crc32_be_generic</code><span class="sig-paren">(</span>u32<em>&nbsp;crc</em>, unsigned char const *<em>&nbsp;p</em>, size_t<em>&nbsp;len</em>, const u32 ( *<em>&nbsp;tab</em>, u32<em>&nbsp;polynomial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc32_be_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate bitwise big-endian Ethernet AUTODIN II CRC32</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">crc</span></code></dt>
<dd>seed value for computation.  ~0 for Ethernet, sometimes 0 for
other uses, or the previous crc32 value if computing incrementally.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>pointer to buffer over which CRC32 is run</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>length of buffer <strong>p</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">(</span> <span class="pre">*</span> <span class="pre">tab</span></code></dt>
<dd>big-endian Ethernet table</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">polynomial</span></code></dt>
<dd>CRC32 BE polynomial</dd>
</dl>
<dl class="function">
<dt id="c.crc_ccitt">
u16 <code class="descname">crc_ccitt</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, u8 const *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_ccitt" title="Permalink to this definition">¶</a></dt>
<dd><p>recompute the CRC (CRC-CCITT variant) for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<dl class="function">
<dt id="c.crc_ccitt_false">
u16 <code class="descname">crc_ccitt_false</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, u8 const *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_ccitt_false" title="Permalink to this definition">¶</a></dt>
<dd><p>recompute the CRC (CRC-CCITT-FALSE variant) for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<dl class="function">
<dt id="c.crc_itu_t">
u16 <code class="descname">crc_itu_t</code><span class="sig-paren">(</span>u16<em>&nbsp;crc</em>, const u8 *<em>&nbsp;buffer</em>, size_t<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.crc_itu_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the CRC-ITU-T for the data buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">crc</span></code></dt>
<dd>previous CRC value</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>data pointer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>number of bytes in the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the updated CRC value</p>
</div>
<div class="section" id="base-2-log-and-power-functions">
<h3>Base 2 log and power Functions<a class="headerlink" href="#base-2-log-and-power-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.is_power_of_2">
bool <code class="descname">is_power_of_2</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_power_of_2" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a value is a power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>the value to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether some value is a power of two, where zero is
<em>not</em> considered a power of two.</p>
<p><strong>Return</strong></p>
<p>true if <strong>n</strong> is a power of 2, otherwise false.</p>
<dl class="function">
<dt id="c.__roundup_pow_of_two">
unsigned long <code class="descname">__roundup_pow_of_two</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__roundup_pow_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>round up to nearest power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>value to round up</dd>
</dl>
<dl class="function">
<dt id="c.__rounddown_pow_of_two">
unsigned long <code class="descname">__rounddown_pow_of_two</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__rounddown_pow_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>round down to nearest power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">n</span></code></dt>
<dd>value to round down</dd>
</dl>
<dl class="function">
<dt id="c.const_ilog2">
<code class="descname">const_ilog2</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.const_ilog2" title="Permalink to this definition">¶</a></dt>
<dd><p>log base 2 of 32-bit or a 64-bit constant unsigned value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>parameter</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this where sparse expects a true constant expression, e.g. for array
indices.</p>
<dl class="function">
<dt id="c.ilog2">
<code class="descname">ilog2</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ilog2" title="Permalink to this definition">¶</a></dt>
<dd><p>log base 2 of 32-bit or a 64-bit unsigned value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>parameter</dd>
</dl>
<p><strong>Description</strong></p>
<p>constant-capable log of base 2 calculation
- this can be used to initialise global variables from constant data, hence
the massive ternary operator construction</p>
<p>selects the appropriately-sized optimised version depending on sizeof(n)</p>
<dl class="function">
<dt id="c.roundup_pow_of_two">
<code class="descname">roundup_pow_of_two</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.roundup_pow_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>round the given value up to nearest power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>parameter</dd>
</dl>
<p><strong>Description</strong></p>
<p>round the given value up to the nearest power of two
- the result is undefined when n == 0
- this can be used to initialise global variables from constant data</p>
<dl class="function">
<dt id="c.rounddown_pow_of_two">
<code class="descname">rounddown_pow_of_two</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rounddown_pow_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>round the given value down to nearest power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>parameter</dd>
</dl>
<p><strong>Description</strong></p>
<p>round the given value down to the nearest power of two
- the result is undefined when n == 0
- this can be used to initialise global variables from constant data</p>
<dl class="function">
<dt id="c.order_base_2">
<code class="descname">order_base_2</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.order_base_2" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the (rounded up) base 2 order of the argument</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>parameter</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>The first few values calculated by this routine:</dt>
<dd>ob2(0) = 0
ob2(1) = 0
ob2(2) = 1
ob2(3) = 2
ob2(4) = 2
ob2(5) = 3
... and so on.</dd>
</dl>
</div>
<div class="section" id="division-functions">
<h3>Division Functions<a class="headerlink" href="#division-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.do_div">
<code class="descname">do_div</code><span class="sig-paren">(</span><em>n</em>, <em>base</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_div" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 2 values: calculate remainder and update new dividend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>pointer to uint64_t dividend (will be updated)</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>uint32_t divisor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Summary:
<code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">remainder</span> <span class="pre">=</span> <span class="pre">*n</span> <span class="pre">%</span> <span class="pre">base;</span></code>
<code class="docutils literal"><span class="pre">*n</span> <span class="pre">=</span> <span class="pre">*n</span> <span class="pre">/</span> <span class="pre">base;</span></code></p>
<p><strong>Return</strong></p>
<p>(uint32_t)remainder</p>
<p><strong>NOTE</strong></p>
<p>macro parameter <strong>n</strong> is evaluated multiple times,
beware of side effects!</p>
<dl class="function">
<dt id="c.div_u64_rem">
u64 <code class="descname">div_u64_rem</code><span class="sig-paren">(</span>u64<em>&nbsp;dividend</em>, u32<em>&nbsp;divisor</em>, u32 *<em>&nbsp;remainder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div_u64_rem" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 32bit divisor with remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt>
<dd>unsigned 64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">divisor</span></code></dt>
<dd>unsigned 32bit divisor</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt>
<dd>pointer to unsigned 32bit remainder</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
<p>This is commonly provided by 32bit archs to provide an optimized 64bit
divide.</p>
<dl class="function">
<dt id="c.div_s64_rem">
s64 <code class="descname">div_s64_rem</code><span class="sig-paren">(</span>s64<em>&nbsp;dividend</em>, s32<em>&nbsp;divisor</em>, s32 *<em>&nbsp;remainder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div_s64_rem" title="Permalink to this definition">¶</a></dt>
<dd><p>signed 64bit divide with 32bit divisor with remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt>
<dd>signed 64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">s32</span> <span class="pre">divisor</span></code></dt>
<dd>signed 32bit divisor</dd>
<dt><code class="docutils literal"><span class="pre">s32</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt>
<dd>pointer to signed 32bit remainder</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
<dl class="function">
<dt id="c.div64_u64_rem">
u64 <code class="descname">div64_u64_rem</code><span class="sig-paren">(</span>u64<em>&nbsp;dividend</em>, u64<em>&nbsp;divisor</em>, u64 *<em>&nbsp;remainder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_u64_rem" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 64bit divisor and remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt>
<dd>unsigned 64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt>
<dd>unsigned 64bit divisor</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt>
<dd>pointer to unsigned 64bit remainder</dd>
</dl>
<p><strong>Return</strong></p>
<p>sets <code class="docutils literal"><span class="pre">*remainder</span></code>, then returns dividend / divisor</p>
<dl class="function">
<dt id="c.div64_u64">
u64 <code class="descname">div64_u64</code><span class="sig-paren">(</span>u64<em>&nbsp;dividend</em>, u64<em>&nbsp;divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 64bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt>
<dd>unsigned 64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt>
<dd>unsigned 64bit divisor</dd>
</dl>
<p><strong>Return</strong></p>
<p>dividend / divisor</p>
<dl class="function">
<dt id="c.div64_s64">
s64 <code class="descname">div64_s64</code><span class="sig-paren">(</span>s64<em>&nbsp;dividend</em>, s64<em>&nbsp;divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div64_s64" title="Permalink to this definition">¶</a></dt>
<dd><p>signed 64bit divide with 64bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt>
<dd>signed 64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">s64</span> <span class="pre">divisor</span></code></dt>
<dd>signed 64bit divisor</dd>
</dl>
<p><strong>Return</strong></p>
<p>dividend / divisor</p>
<dl class="function">
<dt id="c.div_u64">
u64 <code class="descname">div_u64</code><span class="sig-paren">(</span>u64<em>&nbsp;dividend</em>, u32<em>&nbsp;divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div_u64" title="Permalink to this definition">¶</a></dt>
<dd><p>unsigned 64bit divide with 32bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt>
<dd>unsigned 64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">divisor</span></code></dt>
<dd>unsigned 32bit divisor</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the most common 64bit divide and should be used if possible,
as many 32bit archs can optimize this variant better than a full 64bit
divide.</p>
<dl class="function">
<dt id="c.div_s64">
s64 <code class="descname">div_s64</code><span class="sig-paren">(</span>s64<em>&nbsp;dividend</em>, s32<em>&nbsp;divisor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.div_s64" title="Permalink to this definition">¶</a></dt>
<dd><p>signed 64bit divide with 32bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt>
<dd>signed 64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">s32</span> <span class="pre">divisor</span></code></dt>
<dd>signed 32bit divisor</dd>
</dl>
<dl class="function">
<dt>
s64 <code class="descname">div_s64_rem</code><span class="sig-paren">(</span>s64<em>&nbsp;dividend</em>, s32<em>&nbsp;divisor</em>, s32 *<em>&nbsp;remainder</em><span class="sig-paren">)</span></dt>
<dd><p>signed 64bit divide with 64bit divisor and remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt>
<dd>64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">s32</span> <span class="pre">divisor</span></code></dt>
<dd>64bit divisor</dd>
<dt><code class="docutils literal"><span class="pre">s32</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt>
<dd>64bit remainder</dd>
</dl>
<dl class="function">
<dt>
u64 <code class="descname">div64_u64_rem</code><span class="sig-paren">(</span>u64<em>&nbsp;dividend</em>, u64<em>&nbsp;divisor</em>, u64 *<em>&nbsp;remainder</em><span class="sig-paren">)</span></dt>
<dd><p>unsigned 64bit divide with 64bit divisor and remainder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt>
<dd>64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt>
<dd>64bit divisor</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">remainder</span></code></dt>
<dd>64bit remainder</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implementation is a comparable to algorithm used by div64_u64.
But this operation, which includes math for calculating the remainder,
is kept distinct to avoid slowing down the div64_u64 operation on 32bit
systems.</p>
<dl class="function">
<dt>
u64 <code class="descname">div64_u64</code><span class="sig-paren">(</span>u64<em>&nbsp;dividend</em>, u64<em>&nbsp;divisor</em><span class="sig-paren">)</span></dt>
<dd><p>unsigned 64bit divide with 64bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">dividend</span></code></dt>
<dd>64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">divisor</span></code></dt>
<dd>64bit divisor</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implementation is a modified version of the algorithm proposed
by the book &#8216;Hacker&#8217;s Delight&#8217;.  The original source and full proof
can be found here and is available for use without restriction.</p>
<p>&#8216;<a class="reference external" href="http://www.hackersdelight.org/hdcodetxt/divDouble.c.txt">http://www.hackersdelight.org/hdcodetxt/divDouble.c.txt</a>&#8216;</p>
<dl class="function">
<dt>
s64 <code class="descname">div64_s64</code><span class="sig-paren">(</span>s64<em>&nbsp;dividend</em>, s64<em>&nbsp;divisor</em><span class="sig-paren">)</span></dt>
<dd><p>signed 64bit divide with 64bit divisor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">s64</span> <span class="pre">dividend</span></code></dt>
<dd>64bit dividend</dd>
<dt><code class="docutils literal"><span class="pre">s64</span> <span class="pre">divisor</span></code></dt>
<dd>64bit divisor</dd>
</dl>
<dl class="function">
<dt id="c.gcd">
unsigned long <code class="descname">gcd</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;a</em>, unsigned long<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gcd" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate and return the greatest common divisor of 2 unsigned longs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a</span></code></dt>
<dd>first value</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">b</span></code></dt>
<dd>second value</dd>
</dl>
</div>
<div class="section" id="uuid-guid">
<h3>UUID/GUID<a class="headerlink" href="#uuid-guid" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.generate_random_uuid">
void <code class="descname">generate_random_uuid</code><span class="sig-paren">(</span>unsigned char<em>&nbsp;uuid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generate_random_uuid" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a random UUID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">uuid</span></code></dt>
<dd>where to put the generated UUID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Random UUID interface</p>
<p>Used to create a Boot ID or a filesystem UUID/GUID, but can be
useful for other kernel drivers.</p>
<dl class="function">
<dt id="c.uuid_is_valid">
bool <code class="descname">uuid_is_valid</code><span class="sig-paren">(</span>const char *<em>&nbsp;uuid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uuid_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>checks if a UUID string is valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">uuid</span></code></dt>
<dd>UUID string to check</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>It checks if the UUID string is following the format:</dt>
<dd>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</dd>
</dl>
<p>where x is a hex digit.</p>
<p><strong>Return</strong></p>
<p>true if input is valid UUID string.</p>
</div>
</div>
<div class="section" id="kernel-ipc-facilities">
<h2>Kernel IPC facilities<a class="headerlink" href="#kernel-ipc-facilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ipc-utilities">
<h3>IPC utilities<a class="headerlink" href="#ipc-utilities" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.ipc_init">
int <code class="descname">ipc_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise ipc subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The various sysv ipc resources (semaphores, messages and shared
memory) are initialised.</p>
<p>A callback routine is registered into the memory hotplug notifier
chain: since msgmni scales to lowmem this callback routine will be
called upon successful memory add / remove to recompute msmgni.</p>
<dl class="function">
<dt id="c.ipc_init_ids">
void <code class="descname">ipc_init_ids</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>initialise ipc identifiers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up the sequence range to use for the ipc identifier range (limited
below IPCMNI) then initialise the keys hashtable and ids idr.</p>
<dl class="function">
<dt id="c.ipc_init_proc_interface">
void <code class="descname">ipc_init_proc_interface</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em>, const char *<em>&nbsp;header</em>, int<em>&nbsp;ids</em>, int (*show) (struct seq_file<em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_init_proc_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>create a proc interface for sysipc types using a seq_file interface.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>Path in procfs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">header</span></code></dt>
<dd>Banner to be printed at the beginning of the file.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ids</span></code></dt>
<dd>ipc id table to iterate.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">seq_file</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">show</span></code></dt>
<dd>show routine.</dd>
</dl>
<dl class="function">
<dt id="c.ipc_findkey">
struct kern_ipc_perm * <code class="descname">ipc_findkey</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, key_t<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_findkey" title="Permalink to this definition">¶</a></dt>
<dd><p>find a key in an ipc identifier set</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">key_t</span> <span class="pre">key</span></code></dt>
<dd>key to find</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the locked pointer to the ipc structure if found or NULL
otherwise. If key is found ipc points to the owning ipc structure</p>
<p>Called with writer ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipc_addid">
int <code class="descname">ipc_addid</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;new</em>, int<em>&nbsp;limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_addid" title="Permalink to this definition">¶</a></dt>
<dd><p>add an ipc identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">limit</span></code></dt>
<dd>limit for the number of used ids</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add an entry &#8216;new&#8217; to the ipc ids idr. The permissions object is
initialised and the first free entry is set up and the index assigned
is returned. The &#8216;new&#8217; entry is returned in a locked state on success.</p>
<p>On failure the entry is not locked and a negative err-code is returned.
The caller must use <code class="xref c c-func docutils literal"><span class="pre">ipc_rcu_putref()</span></code> to free the identifier.</p>
<p>Called with writer ipc_ids.rwsem held.</p>
<dl class="function">
<dt id="c.ipcget_new">
int <code class="descname">ipcget_new</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_new" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual creation routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is IPC_PRIVATE.</p>
<dl class="function">
<dt id="c.ipc_check_perms">
int <code class="descname">ipc_check_perms</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_check_perms" title="Permalink to this definition">¶</a></dt>
<dd><p>check security and permissions for an ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual security routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by <code class="xref c c-func docutils literal"><span class="pre">sys_msgget()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is not IPC_PRIVATE and that key already exists in the
ds IDR.</p>
<p>On success, the ipc id is returned.</p>
<p>It is called with ipc_ids.rwsem and ipcp-&gt;lock held.</p>
<dl class="function">
<dt id="c.ipcget_public">
int <code class="descname">ipcget_public</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget_public" title="Permalink to this definition">¶</a></dt>
<dd><p>get an ipc object or create a new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>the actual creation routine to call</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>its parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine is called by sys_msgget, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>
when the key is not IPC_PRIVATE.
It adds a new entry if the key is not found and does some permission
/ security checkings if the key is found.</p>
<p>On success, the ipc id is returned.</p>
<dl class="function">
<dt id="c.ipc_kht_remove">
void <code class="descname">ipc_kht_remove</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_kht_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an ipc from the key hashtable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc perm structure containing the key to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipc_rmid">
void <code class="descname">ipc_rmid</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_rmid" title="Permalink to this definition">¶</a></dt>
<dd><p>remove an ipc identifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc perm structure containing the identifier to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipc_set_key_private">
void <code class="descname">ipc_set_key_private</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_set_key_private" title="Permalink to this definition">¶</a></dt>
<dd><p>switch the key of an existing ipc to IPC_PRIVATE</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc perm structure containing the key to modify</dd>
</dl>
<p><strong>Description</strong></p>
<p>ipc_ids.rwsem (as a writer) and the spinlock for this ID are held
before this function is called, and remain locked on the exit.</p>
<dl class="function">
<dt id="c.ipcperms">
int <code class="descname">ipcperms</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct kern_ipc_perm *<em>&nbsp;ipcp</em>, short<em>&nbsp;flag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcperms" title="Permalink to this definition">¶</a></dt>
<dd><p>check ipc permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permission set</dd>
<dt><code class="docutils literal"><span class="pre">short</span> <span class="pre">flag</span></code></dt>
<dd>desired permission set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check user, group, other permissions for access
to ipc resources. return 0 if allowed</p>
<p><strong>flag</strong> will most probably be 0 or <code class="docutils literal"><span class="pre">S_...UGO</span></code> from &lt;linux/stat.h&gt;</p>
<dl class="function">
<dt id="c.kernel_to_ipc64_perm">
void <code class="descname">kernel_to_ipc64_perm</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em>&nbsp;in</em>, struct ipc64_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kernel_to_ipc64_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>convert kernel ipc permissions to user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>kernel permissions</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>new style ipc permissions</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the kernel object <strong>in</strong> into a set of permissions descriptions
for returning to userspace (<strong>out</strong>).</p>
<dl class="function">
<dt id="c.ipc64_perm_to_ipc_perm">
void <code class="descname">ipc64_perm_to_ipc_perm</code><span class="sig-paren">(</span>struct ipc64_perm *<em>&nbsp;in</em>, struct ipc_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc64_perm_to_ipc_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>convert new ipc permissions to old</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>new style ipc permissions</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>old style ipc permissions</dd>
</dl>
<p><strong>Description</strong></p>
<p>Turn the new style permissions object <strong>in</strong> into a compatibility
object and store it into the <strong>out</strong> pointer.</p>
<dl class="function">
<dt id="c.ipc_obtain_object_idr">
struct kern_ipc_perm * <code class="descname">ipc_obtain_object_idr</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_idr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ipc id to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for an id in the ipc ids idr and return associated ipc object.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
<dl class="function">
<dt id="c.ipc_obtain_object_check">
struct kern_ipc_perm * <code class="descname">ipc_obtain_object_check</code><span class="sig-paren">(</span>struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_obtain_object_check" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>ipc id to look for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="#c.ipc_obtain_object_idr" title="ipc_obtain_object_idr"><code class="xref c c-func docutils literal"><span class="pre">ipc_obtain_object_idr()</span></code></a> but also checks the ipc object
sequence number.</p>
<p>Call inside the RCU critical section.
The ipc object is <em>not</em> locked on exit.</p>
<dl class="function">
<dt id="c.ipcget">
int <code class="descname">ipcget</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, const struct ipc_ops *<em>&nbsp;ops</em>, struct ipc_params *<em>&nbsp;params</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcget" title="Permalink to this definition">¶</a></dt>
<dd><p>Common sys_*:c:func:<cite>get()</cite> code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>ipc identifier set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">ipc_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>operations to be called on ipc object creation, permission checks
and further checks</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>the parameters needed by the previous operations.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Common routine called by <code class="xref c c-func docutils literal"><span class="pre">sys_msgget()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">sys_semget()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">sys_shmget()</span></code>.</p>
<dl class="function">
<dt id="c.ipc_update_perm">
int <code class="descname">ipc_update_perm</code><span class="sig-paren">(</span>struct ipc64_perm *<em>&nbsp;in</em>, struct kern_ipc_perm *<em>&nbsp;out</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_update_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>update the permissions of an ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">in</span></code></dt>
<dd>the permission given as input.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">out</span></code></dt>
<dd>the permission of the ipc to set.</dd>
</dl>
<dl class="function">
<dt id="c.ipcctl_obtain_check">
struct kern_ipc_perm * <code class="descname">ipcctl_obtain_check</code><span class="sig-paren">(</span>struct ipc_namespace *<em>&nbsp;ns</em>, struct ipc_ids *<em>&nbsp;ids</em>, int<em>&nbsp;id</em>, int<em>&nbsp;cmd</em>, struct ipc64_perm *<em>&nbsp;perm</em>, int<em>&nbsp;extra_perm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipcctl_obtain_check" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve an ipc object and check permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_namespace</span> <span class="pre">*</span> <span class="pre">ns</span></code></dt>
<dd>ipc namespace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc_ids</span> <span class="pre">*</span> <span class="pre">ids</span></code></dt>
<dd>the table of ids where to look for the ipc</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>the id of the ipc to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cmd</span></code></dt>
<dd>the cmd to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ipc64_perm</span> <span class="pre">*</span> <span class="pre">perm</span></code></dt>
<dd>the permission to set</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">extra_perm</span></code></dt>
<dd>one extra permission parameter used by msq</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function does some common audit and permissions check for some IPC_XXX
cmd and is called from semctl_down, shmctl_down and msgctl_down.</p>
<dl class="docutils">
<dt>It:</dt>
<dd><ul class="first last simple">
<li>retrieves the ipc object with the given id in the given table.</li>
<li>performs some audit and permission check, depending on the given cmd</li>
<li>returns a pointer to the ipc object or otherwise, the corresponding
error.</li>
</ul>
</dd>
</dl>
<p>Call holding the both the rwsem and the rcu read lock.</p>
<dl class="function">
<dt id="c.ipc_parse_version">
int <code class="descname">ipc_parse_version</code><span class="sig-paren">(</span>int *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ipc_parse_version" title="Permalink to this definition">¶</a></dt>
<dd><p>ipc call version</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>pointer to command</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return IPC_64 for new style IPC and IPC_OLD for old style IPC.
The <strong>cmd</strong> value is turned from an encoding command and version into
just the command code.</p>
</div>
</div>
<div class="section" id="fifo-buffer">
<h2>FIFO Buffer<a class="headerlink" href="#fifo-buffer" title="Permalink to this headline">¶</a></h2>
<div class="section" id="kfifo-interface">
<h3>kfifo interface<a class="headerlink" href="#kfifo-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.DECLARE_KFIFO_PTR">
<code class="descname">DECLARE_KFIFO_PTR</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_KFIFO_PTR" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to declare a fifo pointer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
</dl>
<dl class="function">
<dt id="c.DECLARE_KFIFO">
<code class="descname">DECLARE_KFIFO</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to declare a fifo object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
</dl>
<dl class="function">
<dt id="c.INIT_KFIFO">
<code class="descname">INIT_KFIFO</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.INIT_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a fifo declared by DECLARE_KFIFO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo datatype</dd>
</dl>
<dl class="function">
<dt id="c.DEFINE_KFIFO">
<code class="descname">DEFINE_KFIFO</code><span class="sig-paren">(</span><em>fifo</em>, <em>type</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_KFIFO" title="Permalink to this definition">¶</a></dt>
<dd><p>macro to define and initialize a fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>name of the declared fifo datatype</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the fifo elements</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
</dl>
<p><strong>Note</strong></p>
<p>the macro can be used for global and local fifo data type variables.</p>
<dl class="function">
<dt id="c.kfifo_initialized">
<code class="descname">kfifo_initialized</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the fifo is initialized</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return <code class="docutils literal"><span class="pre">true</span></code> if fifo is initialized, otherwise <code class="docutils literal"><span class="pre">false</span></code>.
Assumes the fifo was 0 before.</p>
<dl class="function">
<dt id="c.kfifo_esize">
<code class="descname">kfifo_esize</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_esize" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the element managed by the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_recsize">
<code class="descname">kfifo_recsize</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_recsize" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the record length field</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_size">
<code class="descname">kfifo_size</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_size" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the fifo in elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_reset">
<code class="descname">kfifo_reset</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>removes the entire fifo content</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Note</strong></p>
<p>usage of <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset()</span></code></a> is dangerous. It should be only called when the
fifo is exclusived locked or when it is secured that no other thread is
accessing the fifo.</p>
<dl class="function">
<dt id="c.kfifo_reset_out">
<code class="descname">kfifo_reset_out</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_reset_out" title="Permalink to this definition">¶</a></dt>
<dd><p>skip fifo content</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Note</strong></p>
<p>The usage of <a class="reference internal" href="#c.kfifo_reset_out" title="kfifo_reset_out"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset_out()</span></code></a> is safe until it will be only called
from the reader thread and there is only one concurrent reader. Otherwise
it is dangerous and must be handled in the same way as <a class="reference internal" href="#c.kfifo_reset" title="kfifo_reset"><code class="xref c c-func docutils literal"><span class="pre">kfifo_reset()</span></code></a>.</p>
<dl class="function">
<dt id="c.kfifo_len">
<code class="descname">kfifo_len</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_len" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of used elements in the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_empty">
<code class="descname">kfifo_is_empty</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_is_full">
<code class="descname">kfifo_is_full</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the fifo is full</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_avail">
<code class="descname">kfifo_avail</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of unused elements in the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_skip">
<code class="descname">kfifo_skip</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_skip" title="Permalink to this definition">¶</a></dt>
<dd><p>skip output data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_peek_len">
<code class="descname">kfifo_peek_len</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_peek_len" title="Permalink to this definition">¶</a></dt>
<dd><p>gets the size of the next fifo record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the size of the next fifo record in number of bytes.</p>
<dl class="function">
<dt id="c.kfifo_alloc">
<code class="descname">kfifo_alloc</code><span class="sig-paren">(</span><em>fifo</em>, <em>size</em>, <em>gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>dynamically allocates a new fifo buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>pointer to the fifo</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the number of elements in the fifo, this must be a power of 2</dd>
<dt><code class="docutils literal"><span class="pre">gfp_mask</span></code></dt>
<dd>get_free_pages mask, passed to <a class="reference internal" href="mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro dynamically allocates a new fifo buffer.</p>
<p>The number of elements will be rounded-up to a power of 2.
The fifo will be release with <a class="reference internal" href="#c.kfifo_free" title="kfifo_free"><code class="xref c c-func docutils literal"><span class="pre">kfifo_free()</span></code></a>.
Return 0 if no error, otherwise an error code.</p>
<dl class="function">
<dt id="c.kfifo_free">
<code class="descname">kfifo_free</code><span class="sig-paren">(</span><em>fifo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_free" title="Permalink to this definition">¶</a></dt>
<dd><p>frees the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>the fifo to be freed</dd>
</dl>
<dl class="function">
<dt id="c.kfifo_init">
<code class="descname">kfifo_init</code><span class="sig-paren">(</span><em>fifo</em>, <em>buffer</em>, <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a fifo using a preallocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>the fifo to assign the buffer</dd>
<dt><code class="docutils literal"><span class="pre">buffer</span></code></dt>
<dd>the preallocated buffer to be used</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>the size of the internal buffer, this have to be a power of 2</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro initializes a fifo using a preallocated buffer.</p>
<p>The number of elements will be rounded-up to a power of 2.
Return 0 if no error, otherwise an error code.</p>
<dl class="function">
<dt id="c.kfifo_put">
<code class="descname">kfifo_put</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_put" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>the data to be added</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given value into the fifo.
It returns 0 if the fifo was full. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_get">
<code class="descname">kfifo_get</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>address where to store the data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro reads the data from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_peek">
<code class="descname">kfifo_peek</code><span class="sig-paren">(</span><em>fifo</em>, <em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo without removing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>address where to store the data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reads the data from the fifo without removing it from the fifo.
It returns 0 if the fifo was empty. Otherwise it returns the number
processed elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_in">
<code class="descname">kfifo_in</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>number of elements to be added</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given buffer into the fifo and returns the
number of copied elements.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_in_spinlocked">
<code class="descname">kfifo_in_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_in_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>put data into the fifo using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>number of elements to be added</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to the spinlock to use for locking</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies the given values buffer into the fifo and returns the
number of copied elements.</p>
<dl class="function">
<dt id="c.kfifo_out">
<code class="descname">kfifo_out</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get some data from the fifo and return the numbers of elements
copied.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_out_spinlocked">
<code class="descname">kfifo_out_spinlocked</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_spinlocked" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from the fifo using a spinlock for locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to the spinlock to use for locking</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied.</p>
<dl class="function">
<dt id="c.kfifo_from_user">
<code class="descname">kfifo_from_user</code><span class="sig-paren">(</span><em>fifo</em>, <em>from</em>, <em>len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_from_user" title="Permalink to this definition">¶</a></dt>
<dd><p>puts some data from user space into the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">from</span></code></dt>
<dd>pointer to the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>the length of the data to be added</dd>
<dt><code class="docutils literal"><span class="pre">copied</span></code></dt>
<dd>pointer to output variable to store the number of copied bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the <strong>from</strong> into the
fifo, depending of the available space and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_to_user">
<code class="descname">kfifo_to_user</code><span class="sig-paren">(</span><em>fifo</em>, <em>to</em>, <em>len</em>, <em>copied</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_to_user" title="Permalink to this definition">¶</a></dt>
<dd><p>copies data from the fifo into user space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">to</span></code></dt>
<dd>where the data must be copied</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>the size of the destination buffer</dd>
<dt><code class="docutils literal"><span class="pre">copied</span></code></dt>
<dd>pointer to output variable to store the number of copied bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro copies at most <strong>len</strong> bytes from the fifo into the
<strong>to</strong> buffer and returns -EFAULT/0.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
<dl class="function">
<dt id="c.kfifo_dma_in_prepare">
<code class="descname">kfifo_dma_in_prepare</code><span class="sig-paren">(</span><em>fifo</em>, <em>sgl</em>, <em>nents</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_in_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a scatterlist for DMA input</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">sgl</span></code></dt>
<dd>pointer to the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">nents</span></code></dt>
<dd>number of entries in the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of elements to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA input.
It returns the number entries in the scatterlist array.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_in_finish">
<code class="descname">kfifo_dma_in_finish</code><span class="sig-paren">(</span><em>fifo</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_in_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a DMA IN operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of bytes to received</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA IN operation. The in counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_out_prepare">
<code class="descname">kfifo_dma_out_prepare</code><span class="sig-paren">(</span><em>fifo</em>, <em>sgl</em>, <em>nents</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_out_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>setup a scatterlist for DMA output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">sgl</span></code></dt>
<dd>pointer to the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">nents</span></code></dt>
<dd>number of entries in the scatterlist array</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of elements to transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro fills a scatterlist for DMA output which at most <strong>len</strong> bytes
to transfer.
It returns the number entries in the scatterlist array.
A zero means there is no space available and the scatterlist is not filled.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_dma_out_finish">
<code class="descname">kfifo_dma_out_finish</code><span class="sig-paren">(</span><em>fifo</em>, <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_dma_out_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>finish a DMA OUT operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>number of bytes transferred</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro finish a DMA OUT operation. The out counter will be updated by
the len parameter. No error checking will be done.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macros.</p>
<dl class="function">
<dt id="c.kfifo_out_peek">
<code class="descname">kfifo_out_peek</code><span class="sig-paren">(</span><em>fifo</em>, <em>buf</em>, <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfifo_out_peek" title="Permalink to this definition">¶</a></dt>
<dd><p>gets some data from the fifo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fifo</span></code></dt>
<dd>address of the fifo to be used</dd>
<dt><code class="docutils literal"><span class="pre">buf</span></code></dt>
<dd>pointer to the storage buffer</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>max. number of elements to get</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro get the data from the fifo and return the numbers of elements
copied. The data is not removed from the fifo.</p>
<p>Note that with only one concurrent reader and one concurrent
writer, you don&#8217;t need extra locking to use these macro.</p>
</div>
</div>
<div class="section" id="relay-interface-support">
<h2>relay interface support<a class="headerlink" href="#relay-interface-support" title="Permalink to this headline">¶</a></h2>
<p>Relay interface support is designed to provide an efficient mechanism
for tools and facilities to relay large amounts of data from kernel
space to user space.</p>
<div class="section" id="relay-interface">
<h3>relay interface<a class="headerlink" href="#relay-interface" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.relay_buf_full">
int <code class="descname">relay_buf_full</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_full" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean, is the channel buffer full?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns 1 if the buffer is full, 0 otherwise.</div></blockquote>
<dl class="function">
<dt id="c.relay_reset">
void <code class="descname">relay_reset</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This has the effect of erasing all data from all channel buffers
and restarting the channel in its initial state.  The buffers
are not freed, so any mappings are still in effect.</p>
<p>NOTE. Care should be taken that the channel isn&#8217;t actually
being used by anything when this call is made.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_open">
struct rchan * <code class="descname">relay_open</code><span class="sig-paren">(</span>const char *<em>&nbsp;base_filename</em>, struct dentry *<em>&nbsp;parent</em>, size_t<em>&nbsp;subbuf_size</em>, size_t<em>&nbsp;n_subbufs</em>, struct rchan_callbacks *<em>&nbsp;cb</em>, void *<em>&nbsp;private_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_open" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new relay channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">base_filename</span></code></dt>
<dd>base name of files to create, <code class="docutils literal"><span class="pre">NULL</span></code> for buffering only</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>dentry of parent directory, <code class="docutils literal"><span class="pre">NULL</span></code> for root directory or buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">subbuf_size</span></code></dt>
<dd>size of sub-buffers</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">n_subbufs</span></code></dt>
<dd>number of sub-buffers</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_callbacks</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt>
<dd>client callback functions</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">private_data</span></code></dt>
<dd>user-defined data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns channel pointer if successful, <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</p>
<p>Creates a channel buffer for each cpu using the sizes and
attributes specified.  The created channel buffer files
will be named base_filename0...base_filenameN-1.  File
permissions will be <code class="docutils literal"><span class="pre">S_IRUSR</span></code>.</p>
<p>If opening a buffer (<strong>parent</strong> = NULL) that you later wish to register
in a filesystem, call <a class="reference internal" href="#c.relay_late_setup_files" title="relay_late_setup_files"><code class="xref c c-func docutils literal"><span class="pre">relay_late_setup_files()</span></code></a> once the <strong>parent</strong> dentry
is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_late_setup_files">
int <code class="descname">relay_late_setup_files</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em>, const char *<em>&nbsp;base_filename</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_late_setup_files" title="Permalink to this definition">¶</a></dt>
<dd><p>triggers file creation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>channel to operate on</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">base_filename</span></code></dt>
<dd>base name of files to create</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>dentry of parent directory, <code class="docutils literal"><span class="pre">NULL</span></code> for root directory</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if successful, non-zero otherwise.</p>
<p>Use to setup files for a previously buffer-only channel created
by <a class="reference internal" href="#c.relay_open" title="relay_open"><code class="xref c c-func docutils literal"><span class="pre">relay_open()</span></code></a> with a NULL parent dentry.</p>
<p>For example, this is useful for perfomring early tracing in kernel,
before VFS is up and then exposing the early results once the dentry
is available.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_switch_subbuf">
size_t <code class="descname">relay_switch_subbuf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_switch_subbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>switch to a new sub-buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">length</span></code></dt>
<dd>size of current event</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns either the length passed in or 0 if full.</p>
<p>Performs sub-buffer-switch tasks such as invoking callbacks,
updating padding counts, waking up readers, etc.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_subbufs_consumed">
void <code class="descname">relay_subbufs_consumed</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em>, unsigned int<em>&nbsp;cpu</em>, size_t<em>&nbsp;subbufs_consumed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_subbufs_consumed" title="Permalink to this definition">¶</a></dt>
<dd><p>update the buffer&#8217;s sub-buffers-consumed count</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the cpu associated with the channel buffer to update</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">subbufs_consumed</span></code></dt>
<dd>number of sub-buffers to add to current buf&#8217;s count</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Adds to the channel buffer&#8217;s consumed sub-buffer count.
subbufs_consumed should be the number of sub-buffers newly consumed,
not the total consumed.</p>
<p>NOTE. Kernel clients don&#8217;t need to call this function if the channel
mode is &#8216;overwrite&#8217;.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_close">
void <code class="descname">relay_close</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Closes all channel buffers and frees the channel.</div></blockquote>
<dl class="function">
<dt id="c.relay_flush">
void <code class="descname">relay_flush</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>close the channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Flushes all channel buffers, i.e. forces buffer switch.</div></blockquote>
<dl class="function">
<dt id="c.relay_mmap_buf">
int <code class="descname">relay_mmap_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_mmap_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap channel buffer to process address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vm_area_struct describing memory to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Returns 0 if ok, negative on error</p>
<p>Caller should already have grabbed mmap_sem.</p>
</div></blockquote>
<dl class="function">
<dt id="c.relay_alloc_buf">
void * <code class="descname">relay_alloc_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t *<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_alloc_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer struct</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt>
<dd>total size of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a pointer to the resulting buffer, <code class="docutils literal"><span class="pre">NULL</span></code> if unsuccessful. The
passed in size will get page aligned, if it isn&#8217;t already.</div></blockquote>
<dl class="function">
<dt id="c.relay_create_buf">
struct rchan_buf * <code class="descname">relay_create_buf</code><span class="sig-paren">(</span>struct rchan *<em>&nbsp;chan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_create_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and initialize a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan</span> <span class="pre">*</span> <span class="pre">chan</span></code></dt>
<dd>the relay channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns channel buffer if successful, <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</div></blockquote>
<dl class="function">
<dt id="c.relay_destroy_channel">
void <code class="descname">relay_destroy_channel</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>free the channel struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>target kernel reference that contains the relay channel</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Should only be called from <code class="xref c c-func docutils literal"><span class="pre">kref_put()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.relay_destroy_buf">
void <code class="descname">relay_destroy_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_destroy_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy an rchan_buf struct and associated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the buffer struct</dd>
</dl>
<dl class="function">
<dt id="c.relay_remove_buf">
void <code class="descname">relay_remove_buf</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_remove_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>target kernel reference that contains the relay buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Removes the file from the filesystem, which also frees the
rchan_buf_struct and the channel buffer.  Should only be called from
<code class="xref c c-func docutils literal"><span class="pre">kref_put()</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.relay_buf_empty">
int <code class="descname">relay_buf_empty</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_buf_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>boolean, is the channel buffer empty?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns 1 if the buffer is empty, 0 otherwise.</div></blockquote>
<dl class="function">
<dt id="c.wakeup_readers">
void <code class="descname">wakeup_readers</code><span class="sig-paren">(</span>struct irq_work *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeup_readers" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up readers waiting on a channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>contains the channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This is the function used to defer reader waking</div></blockquote>
<dl class="function">
<dt id="c.__relay_reset">
void <code class="descname">__relay_reset</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;init</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__relay_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>the channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">init</span></code></dt>
<dd>1 if this is a first-time initialization</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>See <a class="reference internal" href="#c.relay_reset" title="relay_reset"><code class="xref c c-func docutils literal"><span class="pre">relay_reset()</span></code></a> for description of effect.</div></blockquote>
<dl class="function">
<dt id="c.relay_close_buf">
void <code class="descname">relay_close_buf</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_close_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>close a channel buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Marks the buffer finalized and restores the default callbacks.
The channel buffer and channel buffer data structure are then freed
automatically when the last reference is given up.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_open">
int <code class="descname">relay_file_open</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_open" title="Permalink to this definition">¶</a></dt>
<dd><p>open file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Increments the channel buffer refcount.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_mmap">
int <code class="descname">relay_file_mmap</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>the vma describing what to map</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Calls upon <a class="reference internal" href="#c.relay_mmap_buf" title="relay_mmap_buf"><code class="xref c c-func docutils literal"><span class="pre">relay_mmap_buf()</span></code></a> to map the file into user space.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_poll">
__poll_t <code class="descname">relay_file_poll</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>poll file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>poll table</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Poll implemention.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_release">
int <code class="descname">relay_file_release</code><span class="sig-paren">(</span>struct inode *<em>&nbsp;inode</em>, struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release file op for relay files</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span> <span class="pre">*</span> <span class="pre">inode</span></code></dt>
<dd>the inode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>the file</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Decrements the channel refcount, as the filesystem is
no longer using it.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_read_subbuf_avail">
size_t <code class="descname">relay_file_read_subbuf_avail</code><span class="sig-paren">(</span>size_t<em>&nbsp;read_pos</em>, struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_subbuf_avail" title="Permalink to this definition">¶</a></dt>
<dd><p>return bytes available in sub-buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
</dl>
<dl class="function">
<dt id="c.relay_file_read_start_pos">
size_t <code class="descname">relay_file_read_start_pos</code><span class="sig-paren">(</span>size_t<em>&nbsp;read_pos</em>, struct rchan_buf *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_start_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>find the first available byte to read</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If the <strong>read_pos</strong> is in the middle of padding, return the
position of the first actually available byte, otherwise
return the original value.</div></blockquote>
<dl class="function">
<dt id="c.relay_file_read_end_pos">
size_t <code class="descname">relay_file_read_end_pos</code><span class="sig-paren">(</span>struct rchan_buf *<em>&nbsp;buf</em>, size_t<em>&nbsp;read_pos</em>, size_t<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.relay_file_read_end_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>return the new read position</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rchan_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>relay channel buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">read_pos</span></code></dt>
<dd>file read position</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to be read</dd>
</dl>
</div>
</div>
<div class="section" id="module-support">
<h2>Module Support<a class="headerlink" href="#module-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-loading">
<h3>Module Loading<a class="headerlink" href="#module-loading" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.__request_module">
int <code class="descname">__request_module</code><span class="sig-paren">(</span>bool<em>&nbsp;wait</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.__request_module" title="Permalink to this definition">¶</a></dt>
<dd><p>try to load a kernel module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">wait</span></code></dt>
<dd>wait (or not) for the operation to complete</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>printf style format string for the name of the module</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>arguments as specified in the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>Load a module using the user mode module loader. The function returns
zero on success or a negative errno code or positive exit code from
&#8220;modprobe&#8221; on failure. Note that a successful module load does not mean
the module did not then unload and exit on an error of its own. Callers
must check that the service they requested is now available not blindly
invoke it.</p>
<p>If module auto-loading support is disabled then this function
becomes a no-operation.</p>
</div>
<div class="section" id="inter-module-support">
<h3>Inter Module support<a class="headerlink" href="#inter-module-support" title="Permalink to this headline">¶</a></h3>
<p>Refer to the file kernel/module.c for more information.</p>
</div>
</div>
<div class="section" id="hardware-interfaces">
<h2>Hardware Interfaces<a class="headerlink" href="#hardware-interfaces" title="Permalink to this headline">¶</a></h2>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.synchronize_hardirq">
bool <code class="descname">synchronize_hardirq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending hard IRQ handlers (on other CPUs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this
function while holding a resource the IRQ handler may need you
will deadlock. It does not take associated threaded handlers
into account.</p>
<p>Do not use this for shutdown scenarios where you must be sure
that all parts (hardirq and threaded handler) have completed.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div>This function may be called - with care - from IRQ context.</div></blockquote>
<dl class="function">
<dt id="c.synchronize_irq">
void <code class="descname">synchronize_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for pending IRQ handlers (on other CPUs)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_affinity_notifier">
int <code class="descname">irq_set_affinity_notifier</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irq_affinity_notify" title="irq_affinity_notify">irq_affinity_notify</a> *<em>&nbsp;notify</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_affinity_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>control notification of IRQ affinity changes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt for which to enable/disable notification</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_affinity_notify</span> <span class="pre">*</span> <span class="pre">notify</span></code></dt>
<dd>Context for notification, or <code class="docutils literal"><span class="pre">NULL</span></code> to disable
notification.  Function pointers must be initialised;
the other fields will be initialised by this function.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Must be called in process context.  Notification may only be enabled
after the IRQ is allocated and must be disabled before the IRQ is
freed using <a class="reference internal" href="#c.free_irq" title="free_irq"><code class="xref c c-func docutils literal"><span class="pre">free_irq()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.irq_set_vcpu_affinity">
int <code class="descname">irq_set_vcpu_affinity</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;vcpu_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_vcpu_affinity" title="Permalink to this definition">¶</a></dt>
<dd><p>Set vcpu affinity for the interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt number to set affinity</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vcpu_info</span></code></dt>
<dd>vCPU specific data or pointer to a percpu array of vCPU
specific data for percpu_devid interrupts</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This function uses the vCPU specific data to set the vCPU
affinity for an irq. The vCPU specific data is passed from
outside, such as KVM. One example code path is as below:
KVM -&gt; IOMMU -&gt; <a class="reference internal" href="#c.irq_set_vcpu_affinity" title="irq_set_vcpu_affinity"><code class="xref c c-func docutils literal"><span class="pre">irq_set_vcpu_affinity()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.disable_irq_nosync">
void <code class="descname">disable_irq_nosync</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq_nosync" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq without waiting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Disables and Enables are
nested.
Unlike <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code></a>, this function does not ensure existing
instances of the IRQ handler have completed before returning.</p>
<p>This function may be called from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_irq">
void <code class="descname">disable_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>disable an irq and wait for completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending IRQ handlers for this interrupt
to complete before returning. If you use this function while
holding a resource the IRQ handler may need you will deadlock.</p>
<p>This function may be called - with care - from IRQ context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.disable_hardirq">
bool <code class="descname">disable_hardirq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disable_hardirq" title="Permalink to this definition">¶</a></dt>
<dd><p>disables an irq and waits for hardirq completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to disable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Disable the selected interrupt line.  Enables and Disables are
nested.
This function waits for any pending hard IRQ handlers for this
interrupt to complete before returning. If you use this function while
holding a resource the hard IRQ handler may need you will deadlock.</p>
<p>When used to optimistically disable an interrupt from atomic context
the return value must be checked.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<p>false if a threaded handler is active.</p>
<blockquote>
<div>This function may be called - with care - from IRQ context.</div></blockquote>
<dl class="function">
<dt id="c.enable_irq">
void <code class="descname">enable_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.enable_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>enable handling of an irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt to enable</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Undoes the effect of one call to <a class="reference internal" href="#c.disable_irq" title="disable_irq"><code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code></a>.  If this
matches the last disable, processing of interrupts on this
IRQ line is re-enabled.</p>
<p>This function may be called from IRQ context only when
desc-&gt;irq_data.chip-&gt;bus_lock and desc-&gt;chip-&gt;bus_sync_unlock are NULL !</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_irq_wake">
int <code class="descname">irq_set_irq_wake</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, unsigned int<em>&nbsp;on</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irq_wake" title="Permalink to this definition">¶</a></dt>
<dd><p>control irq power management wakeup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>interrupt to control</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">on</span></code></dt>
<dd>enable/disable power management wakeup</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enable/disable power management wakeup mode, which is
disabled by default.  Enables and disables must match,
just as they match for non-wakeup mode support.</p>
<p>Wakeup mode lets this IRQ wake the system from sleep
states like &#8220;suspend to RAM&#8221;.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_wake_thread">
void <code class="descname">irq_wake_thread</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_wake_thread" title="Permalink to this definition">¶</a></dt>
<dd><p>wake the irq thread for the action identified by dev_id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity for which the thread should be woken</dd>
</dl>
<dl class="function">
<dt id="c.setup_irq">
int <code class="descname">setup_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irqaction" title="irqaction">irqaction</a> *<em>&nbsp;act</em><span class="sig-paren">)</span><a class="headerlink" href="#c.setup_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>setup an interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to setup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irqaction</span> <span class="pre">*</span> <span class="pre">act</span></code></dt>
<dd>irqaction for the interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to statically setup interrupts in the early boot process.</p>
<dl class="function">
<dt id="c.remove_irq">
void <code class="descname">remove_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, struct <a class="reference internal" href="genericirq.html#c.irqaction" title="irqaction">irqaction</a> *<em>&nbsp;act</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irqaction</span> <span class="pre">*</span> <span class="pre">act</span></code></dt>
<dd>irqaction for the interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used to remove interrupts statically setup by the early boot process.</p>
<dl class="function">
<dt id="c.free_irq">
const void * <code class="descname">free_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove an interrupt handler. The handler is removed and if the
interrupt line is no longer in use by any driver it is disabled.
On a shared IRQ the caller must ensure the interrupt is disabled
on the card it drives before calling this function. The function
does not return until any executing interrupts for this IRQ
have completed.</p>
<p>This function must not be called from interrupt context.</p>
<p>Returns the devname argument passed to request_irq.</p>
</div></blockquote>
<dl class="function">
<dt id="c.request_threaded_irq">
int <code class="descname">request_threaded_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, irq_handler_t<em>&nbsp;thread_fn</em>, unsigned long<em>&nbsp;irqflags</em>, const char *<em>&nbsp;devname</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_threaded_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.
Primary handler for threaded interrupts
If NULL and thread_fn != NULL the default
primary handler is installed</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">thread_fn</span></code></dt>
<dd>Function called from the irq handler thread
If NULL, no irq thread is created</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">irqflags</span></code></dt>
<dd>Interrupt type flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">devname</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. From the point this
call is made your handler function may be invoked. Since
your handler function must clear any interrupt the board
raises, you must take care both to initialise your hardware
and to set up the interrupt handler in the right order.</p>
<p>If you want to set up a threaded irq handler for your device
then you need to supply <strong>handler</strong> and <strong>thread_fn</strong>. <strong>handler</strong> is
still called in hard interrupt context and has to check
whether the interrupt originates from the device. If yes it
needs to disable the interrupt on the device and return
IRQ_WAKE_THREAD which will wake up the handler thread and run
<strong>thread_fn</strong>. This split handler design is necessary to support
shared interrupts.</p>
<p>Dev_id must be globally unique. Normally the address of the
device data structure is used as the cookie. Since the handler
receives this value it makes sense to use it.</p>
<p>If your interrupt is shared you must pass a non NULL dev_id
as this is required when freeing the interrupt.</p>
<p>Flags:</p>
<p>IRQF_SHARED             Interrupt is shared
IRQF_TRIGGER_*          Specify active edge(s) or level</p>
</div></blockquote>
<dl class="function">
<dt id="c.request_any_context_irq">
int <code class="descname">request_any_context_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, unsigned long<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, void *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_any_context_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.
Threaded handler for threaded interrupts.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>Interrupt type flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt line and IRQ handling. It selects either a
hardirq or threaded handling method depending on the
context.</p>
<p>On failure, it returns a negative value. On success,
it returns either IRQC_IS_HARDIRQ or IRQC_IS_NESTED.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_percpu_is_enabled">
bool <code class="descname">irq_percpu_is_enabled</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_percpu_is_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the per cpu irq is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Linux irq number to check for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called from a non migratable context. Returns the enable
state of a per cpu interrupt on the current cpu.</p>
<dl class="function">
<dt id="c.free_percpu_irq">
void <code class="descname">free_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, void __percpu *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>free an interrupt allocated with request_percpu_irq</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to free</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>Device identity to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Remove a percpu interrupt handler. The handler is removed, but
the interrupt line is not disabled. This must be done on each
CPU before calling this function. The function does not return
until any executing interrupts for this IRQ have completed.</p>
<p>This function must not be called from interrupt context.</p>
</div></blockquote>
<dl class="function">
<dt id="c.__request_percpu_irq">
int <code class="descname">__request_percpu_irq</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, irq_handler_t<em>&nbsp;handler</em>, unsigned long<em>&nbsp;flags</em>, const char *<em>&nbsp;devname</em>, void __percpu *<em>&nbsp;dev_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_percpu_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a percpu interrupt line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line to allocate</dd>
<dt><code class="docutils literal"><span class="pre">irq_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>Function to be called when the IRQ occurs.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>Interrupt type flags (IRQF_TIMER only)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">devname</span></code></dt>
<dd>An ascii name for the claiming device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>A percpu cookie passed back to the handler function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call allocates interrupt resources and enables the
interrupt on the local CPU. If the interrupt is supposed to be
enabled on other CPUs, it has to be done on each CPU using
<code class="xref c c-func docutils literal"><span class="pre">enable_percpu_irq()</span></code>.</p>
<p>Dev_id must be globally unique. It is a per-cpu variable, and
the handler gets called with the interrupted CPU&#8217;s instance of
that variable.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_get_irqchip_state">
int <code class="descname">irq_get_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, enum irqchip_irq_state<em>&nbsp;which</em>, bool *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_get_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the irqchip state of a interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line that is forwarded to a VM</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt>
<dd>One of IRQCHIP_STATE_* the caller wants to know about</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>a pointer to a boolean where the state is to be storeed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call snapshots the internal irqchip state of an
interrupt, returning into <strong>state</strong> the bit corresponding to
stage <strong>which</strong></p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</div></blockquote>
<dl class="function">
<dt id="c.irq_set_irqchip_state">
int <code class="descname">irq_set_irqchip_state</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;irq</em>, enum irqchip_irq_state<em>&nbsp;which</em>, bool<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.irq_set_irqchip_state" title="Permalink to this definition">¶</a></dt>
<dd><p>set the state of a forwarded interrupt.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>Interrupt line that is forwarded to a VM</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">irqchip_irq_state</span> <span class="pre">which</span></code></dt>
<dd>State to be restored (one of IRQCHIP_STATE_*)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">val</span></code></dt>
<dd>Value corresponding to <strong>which</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This call sets the internal irqchip state of an interrupt,
depending on the value of <strong>which</strong>.</p>
<p>This function should be called with preemption disabled if the
interrupt controller has per-cpu registers.</p>
</div></blockquote>
</div>
<div class="section" id="dma-channels">
<h3>DMA Channels<a class="headerlink" href="#dma-channels" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_dma">
int <code class="descname">request_dma</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;dmanr</em>, const char *<em>&nbsp;device_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve a system DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt>
<dd>DMA channel number</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">device_id</span></code></dt>
<dd>reserving device ID string, used in /proc/dma</dd>
</dl>
<dl class="function">
<dt id="c.free_dma">
void <code class="descname">free_dma</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;dmanr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_dma" title="Permalink to this definition">¶</a></dt>
<dd><p>free a reserved system DMA channel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dmanr</span></code></dt>
<dd>DMA channel number</dd>
</dl>
</div>
<div class="section" id="resources-management">
<h3>Resources Management<a class="headerlink" href="#resources-management" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_resource_conflict">
struct resource * <code class="descname">request_resource_conflict</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, conflict resource on error.</p>
<dl class="function">
<dt id="c.reallocate_resource">
int <code class="descname">reallocate_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;old</em>, resource_size_t<em>&nbsp;newsize</em>, struct resource_constraint *<em>&nbsp;constraint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reallocate_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a slot in the resource tree given range &amp; alignment. The resource will be relocated if the new size cannot be reallocated in the current location.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource descriptor desired by caller</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">newsize</span></code></dt>
<dd>new size of the resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource_constraint</span> <span class="pre">*</span> <span class="pre">constraint</span></code></dt>
<dd>the size and alignment constraints to be met.</dd>
</dl>
<dl class="function">
<dt id="c.lookup_resource">
struct resource * <code class="descname">lookup_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, resource_size_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lookup_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>find an existing resource by a resource start address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the resource if found, NULL otherwise</p>
<dl class="function">
<dt id="c.insert_resource_conflict">
struct resource * <code class="descname">insert_resource_conflict</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_conflict" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of the new resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, conflict resource if the resource can&#8217;t be inserted.</p>
<p>This function is equivalent to request_resource_conflict when no conflict
happens. If a conflict happens, and the conflicting resources
entirely fit within the range of the new resource, then the new
resource is inserted and the conflicting resources become children of
the new resource.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
<dl class="function">
<dt id="c.insert_resource_expand_to_fit">
void <code class="descname">insert_resource_expand_to_fit</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource_expand_to_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a resource into the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a resource into the resource tree, possibly expanding it in order
to make it encompass any conflicting resources.</p>
<dl class="function">
<dt id="c.resource_alignment">
resource_size_t <code class="descname">resource_alignment</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.resource_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate resource&#8217;s alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>resource pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns alignment on success, 0 (invalid alignment) on failure.</p>
<dl class="function">
<dt id="c.release_mem_region_adjustable">
int <code class="descname">release_mem_region_adjustable</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_mem_region_adjustable" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>resource region size</dd>
</dl>
<p><strong>Description</strong></p>
<p>This interface is intended for memory hot-delete.  The requested region
is released from a currently busy memory resource.  The requested region
must either match exactly or fit into a single busy resource entry.  In
the latter case, the remaining resource is adjusted accordingly.
Existing children of the busy memory resource must be immutable in the
request.</p>
<p><strong>Note</strong></p>
<ul class="simple">
<li>Additional release conditions, such as overlapping region, can be
supported after they are confirmed as valid cases.</li>
<li>When a busy memory resource gets split into two entries, the code
assumes that all children remain in the lower address entry for
simplicity.  Enhance this logic when necessary.</li>
</ul>
<dl class="function">
<dt id="c.request_resource">
int <code class="descname">request_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success, negative error code on error.</p>
<dl class="function">
<dt id="c.release_resource">
int <code class="descname">release_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource pointer</dd>
</dl>
<dl class="function">
<dt id="c.region_intersects">
int <code class="descname">region_intersects</code><span class="sig-paren">(</span>resource_size_t<em>&nbsp;start</em>, size_t<em>&nbsp;size</em>, unsigned long<em>&nbsp;flags</em>, unsigned long<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.region_intersects" title="Permalink to this definition">¶</a></dt>
<dd><p>determine intersection of region with known resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>region start address</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of region</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>flags of resource (in iomem_resource)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">desc</span></code></dt>
<dd>descriptor of resource (in iomem_resource) or IORES_DESC_NONE</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if the specified region partially overlaps or fully eclipses a
resource identified by <strong>flags</strong> and <strong>desc</strong> (optional with IORES_DESC_NONE).
Return REGION_DISJOINT if the region does not overlap <strong>flags</strong>/<strong>desc</strong>,
return REGION_MIXED if the region overlaps <strong>flags</strong>/<strong>desc</strong> and another
resource, and return REGION_INTERSECTS if the region overlaps <strong>flags</strong>/<strong>desc</strong>
and no other defined resource. Note that REGION_INTERSECTS is also
returned in the case when the specified region overlaps RAM and undefined
memory holes.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">region_intersect()</span></code> is used by memory remapping functions to ensure
the user is not remapping RAM and is a vast speed up over walking
through the resource table page by page.</p>
<dl class="function">
<dt id="c.allocate_resource">
int <code class="descname">allocate_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em>, resource_size_t<em>&nbsp;size</em>, resource_size_t<em>&nbsp;min</em>, resource_size_t<em>&nbsp;max</em>, resource_size_t<em>&nbsp;align</em>, resource_size_t (*alignf) (void<em>&nbsp;*</em>, const struct resource<em>&nbsp;*</em>, resource_size_t, resource_size_t, void *<em>&nbsp;alignf_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.allocate_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate empty slot in the resource tree given range &amp; alignment. The resource will be reallocated with a new size if it was already allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>resource descriptor desired by caller</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>requested resource region size</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">min</span></code></dt>
<dd>minimum boundary to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">max</span></code></dt>
<dd>maximum boundary to allocate</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">align</span></code></dt>
<dd>alignment requested, in bytes</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">(*)(void</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*,</span> <span class="pre">resource_size_t,</span> <span class="pre">resource_size_t)</span> <span class="pre">alignf</span></code></dt>
<dd>alignment function, optional, called if not NULL</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">alignf_data</span></code></dt>
<dd>arbitrary data to pass to the <strong>alignf</strong> function</dd>
</dl>
<dl class="function">
<dt id="c.insert_resource">
int <code class="descname">insert_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.insert_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts a resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent of the new resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new resource to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EBUSY if the resource can&#8217;t be inserted.</p>
<p>This function is intended for producers of resources, such as FW modules
and bus drivers.</p>
<dl class="function">
<dt id="c.remove_resource">
int <code class="descname">remove_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.remove_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a resource in the resource tree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>resource to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -EINVAL if the resource is not valid.</p>
<p>This function removes a resource previously inserted by <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a>
or <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a>, and moves the children (if any) up to
where they were before.  <a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a> and <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a>
insert a new resource, and move any conflicting resources down to the
children of the new resource.</p>
<p><a class="reference internal" href="#c.insert_resource" title="insert_resource"><code class="xref c c-func docutils literal"><span class="pre">insert_resource()</span></code></a>, <a class="reference internal" href="#c.insert_resource_conflict" title="insert_resource_conflict"><code class="xref c c-func docutils literal"><span class="pre">insert_resource_conflict()</span></code></a> and <a class="reference internal" href="#c.remove_resource" title="remove_resource"><code class="xref c c-func docutils literal"><span class="pre">remove_resource()</span></code></a> are
intended for producers of resources, such as FW modules and bus drivers.</p>
<dl class="function">
<dt id="c.adjust_resource">
int <code class="descname">adjust_resource</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;res</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.adjust_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>modify a resource&#8217;s start and size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>resource to modify</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>new start value</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">size</span></code></dt>
<dd>new size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given an existing resource, change its start and size to match the
arguments.  Returns 0 on success, -EBUSY if it can&#8217;t fit.
Existing children of the resource are assumed to be immutable.</p>
<dl class="function">
<dt id="c.__request_region">
struct resource * <code class="descname">__request_region</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;n</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__request_region" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new busy resource region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt>
<dd>resource region size</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>reserving caller&#8217;s ID string</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>IO resource flags</dd>
</dl>
<dl class="function">
<dt id="c.__release_region">
void <code class="descname">__release_region</code><span class="sig-paren">(</span>struct resource *<em>&nbsp;parent</em>, resource_size_t<em>&nbsp;start</em>, resource_size_t<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__release_region" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously reserved resource region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent resource descriptor</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">start</span></code></dt>
<dd>resource start address</dd>
<dt><code class="docutils literal"><span class="pre">resource_size_t</span> <span class="pre">n</span></code></dt>
<dd>resource region size</dd>
</dl>
<p><strong>Description</strong></p>
<p>The described resource region must match a currently busy region.</p>
<dl class="function">
<dt id="c.devm_request_resource">
int <code class="descname">devm_request_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;root</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_request_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>request and reserve an I/O or memory resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for which to request the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">root</span></code></dt>
<dd>root of the resource tree from which to request the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>descriptor of the resource to request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a device-managed version of <a class="reference internal" href="#c.request_resource" title="request_resource"><code class="xref c c-func docutils literal"><span class="pre">request_resource()</span></code></a>. There is usually
no need to release resources requested by this function explicitly since
that will be taken care of when the device is unbound from its driver.
If for some reason the resource needs to be released explicitly, because
of ordering issues for example, drivers must call <a class="reference internal" href="#c.devm_release_resource" title="devm_release_resource"><code class="xref c c-func docutils literal"><span class="pre">devm_release_resource()</span></code></a>
rather than the regular <a class="reference internal" href="#c.release_resource" title="release_resource"><code class="xref c c-func docutils literal"><span class="pre">release_resource()</span></code></a>.</p>
<p>When a conflict is detected between any existing resources and the newly
requested resource, an error message will be printed.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.devm_release_resource">
void <code class="descname">devm_release_resource</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct resource *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_release_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>release a previously requested resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for which to release the resource</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>descriptor of the resource to release</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a resource previously requested using <a class="reference internal" href="#c.devm_request_resource" title="devm_request_resource"><code class="xref c c-func docutils literal"><span class="pre">devm_request_resource()</span></code></a>.</p>
</div>
<div class="section" id="mtrr-handling">
<h3>MTRR Handling<a class="headerlink" href="#mtrr-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.arch_phys_wc_add">
int <code class="descname">arch_phys_wc_add</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;base</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_phys_wc_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a WC MTRR and handle errors if PAT is unavailable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">base</span></code></dt>
<dd>Physical base address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>Size of region</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PAT is available, this does nothing.  If PAT is unavailable, it
attempts to add a WC MTRR covering size bytes starting at base and
logs an error if this fails.</p>
<p>The called should provide a power of two size on an equivalent
power of two boundary.</p>
<p>Drivers must store the return value to pass to mtrr_del_wc_if_needed,
but drivers should not try to interpret that return value.</p>
</div>
</div>
<div class="section" id="security-framework">
<h2>Security Framework<a class="headerlink" href="#security-framework" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.security_init">
int <code class="descname">security_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.security_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes the security framework</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called early in the kernel initialization sequence.</p>
<dl class="function">
<dt id="c.security_module_enable">
int <code class="descname">security_module_enable</code><span class="sig-paren">(</span>const char *<em>&nbsp;module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.security_module_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Load given security module on boot ?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>the name of the module</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each LSM must pass this method before registering its own operations
to avoid security registration races. This method may also be used
to check if your LSM is currently loaded during kernel initialization.</p>
<p><strong>Return</strong></p>
<p>true if:</p>
<ul class="simple">
<li>The passed LSM is the one chosen by user at boot time,</li>
<li>or the passed LSM is configured as the default and the user did not
choose an alternate LSM at boot time.</li>
</ul>
<p>Otherwise, return false.</p>
<dl class="function">
<dt id="c.security_add_hooks">
void <code class="descname">security_add_hooks</code><span class="sig-paren">(</span>struct security_hook_list *<em>&nbsp;hooks</em>, int<em>&nbsp;count</em>, char *<em>&nbsp;lsm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.security_add_hooks" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a modules hooks to the hook lists.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">security_hook_list</span> <span class="pre">*</span> <span class="pre">hooks</span></code></dt>
<dd>the hooks to add</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of hooks to add</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">lsm</span></code></dt>
<dd>the name of the security module</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each LSM has to register its hooks with the infrastructure.</p>
<dl class="function">
<dt id="c.securityfs_create_file">
struct dentry * <code class="descname">securityfs_create_file</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, umode_t<em>&nbsp;mode</em>, struct dentry *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>create a file in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the file to create.</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>the permission that the file should have</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
file will be created in the root of the securityfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>a pointer to something that the caller will want to get to later
on.  The inode.i_private pointer will point to this value on
the <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> call.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>a pointer to a struct file_operations that should be used for
this file.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a file in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_create_dir">
struct dentry * <code class="descname">securityfs_create_dir</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>create a directory in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the directory to
create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for this file.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a directory in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_create_symlink">
struct dentry * <code class="descname">securityfs_create_symlink</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct dentry *<em>&nbsp;parent</em>, const char *<em>&nbsp;target</em>, const struct inode_operations *<em>&nbsp;iops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>create a symlink in the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>a pointer to a string containing the name of the symlink to
create.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>a pointer to the parent dentry for the symlink.  This should be a
directory dentry if set.  If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the
directory will be created in the root of the securityfs filesystem.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">target</span></code></dt>
<dd>a pointer to a string containing the name of the symlink&#8217;s target.
If this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the <strong>iops</strong> parameter needs to be
setup to handle .readlink and .get_link inode_operations.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">inode_operations</span> <span class="pre">*</span> <span class="pre">iops</span></code></dt>
<dd>a pointer to the struct inode_operations to use for the symlink. If
this parameter is <code class="docutils literal"><span class="pre">NULL</span></code>, then the default simple_symlink_inode
operations will be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a symlink in securityfs with the given <strong>name</strong>.</p>
<p>This function returns a pointer to a dentry if it succeeds.  This
pointer must be passed to the <a class="reference internal" href="#c.securityfs_remove" title="securityfs_remove"><code class="xref c c-func docutils literal"><span class="pre">securityfs_remove()</span></code></a> function when the file is
to be removed (no automatic cleanup happens if your module is unloaded,
you are responsible here).  If an error occurs, the function will return
the error value (via ERR_PTR).</p>
<p>If securityfs is not enabled in the kernel, the value <code class="docutils literal"><span class="pre">-ENODEV</span></code> is
returned.</p>
<dl class="function">
<dt id="c.securityfs_remove">
void <code class="descname">securityfs_remove</code><span class="sig-paren">(</span>struct dentry *<em>&nbsp;dentry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.securityfs_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a file or directory from the securityfs filesystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>a pointer to a the dentry of the file or directory to be removed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a file or directory in securityfs that was previously
created with a call to another securityfs function (like
<a class="reference internal" href="#c.securityfs_create_file" title="securityfs_create_file"><code class="xref c c-func docutils literal"><span class="pre">securityfs_create_file()</span></code></a> or variants thereof.)</p>
<p>This function is required to be called in order for the file to be
removed. No automatic cleanup of files will happen when a module is
removed; you are responsible here.</p>
</div>
<div class="section" id="audit-interfaces">
<h2>Audit Interfaces<a class="headerlink" href="#audit-interfaces" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.audit_log_start">
struct audit_buffer * <code class="descname">audit_log_start</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_start" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain an audit buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit_context (may be NULL)</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>type of allocation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns audit_buffer pointer on success or NULL on error.</p>
<p>Obtain an audit buffer.  This routine does locking to obtain the
audit buffer, but then no locking is required for calls to
audit_log_*format.  If the task (ctx) is a task that is currently in a
syscall, then the syscall is marked as auditable and an audit record
will be written at syscall exit.  If there is no associated task, then
task context (ctx) should be NULL.</p>
<dl class="function">
<dt id="c.audit_log_format">
void <code class="descname">audit_log_format</code><span class="sig-paren">(</span>struct audit_buffer *<em>&nbsp;ab</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_format" title="Permalink to this definition">¶</a></dt>
<dd><p>format a message into the audit buffer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt>
<dd>audit_buffer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>optional parameters matching <strong>fmt</strong> string</dd>
</dl>
<p><strong>Description</strong></p>
<p>All the work is done in audit_log_vformat.</p>
<dl class="function">
<dt id="c.audit_log_end">
void <code class="descname">audit_log_end</code><span class="sig-paren">(</span>struct audit_buffer *<em>&nbsp;ab</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log_end" title="Permalink to this definition">¶</a></dt>
<dd><p>end one audit record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_buffer</span> <span class="pre">*</span> <span class="pre">ab</span></code></dt>
<dd>the audit_buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>We can not do a netlink send inside an irq context because it blocks (last
arg, flags, is not set to MSG_DONTWAIT), so the audit buffer is placed on a
queue and a tasklet is scheduled to remove them from the queue outside the
irq context.  May be called in any context.</p>
<dl class="function">
<dt id="c.audit_log">
void <code class="descname">audit_log</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;type</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.audit_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Log an audit record</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit context</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>type of allocation</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string to use</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable parameters matching the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a convenience function that calls audit_log_start,
audit_log_vformat, and audit_log_end.  It may be called
in any context.</p>
<dl class="function">
<dt id="c.audit_alloc">
int <code class="descname">audit_alloc</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an audit context block for a task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt>
<dd>task</dd>
</dl>
<p><strong>Description</strong></p>
<p>Filter on the task information and allocate a per-task audit context
if necessary.  Doing so turns on system call auditing for the
specified task.  This is called from copy_process, so no lock is
needed.</p>
<dl class="function">
<dt id="c.__audit_free">
void <code class="descname">__audit_free</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free a per-task audit context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt>
<dd>task whose audit context block to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called from copy_process and do_exit</p>
<dl class="function">
<dt id="c.__audit_syscall_entry">
void <code class="descname">__audit_syscall_entry</code><span class="sig-paren">(</span>int<em>&nbsp;major</em>, unsigned long<em>&nbsp;a1</em>, unsigned long<em>&nbsp;a2</em>, unsigned long<em>&nbsp;a3</em>, unsigned long<em>&nbsp;a4</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in an audit record at syscall entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major syscall type (function)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a1</span></code></dt>
<dd>additional syscall register 1</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a2</span></code></dt>
<dd>additional syscall register 2</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a3</span></code></dt>
<dd>additional syscall register 3</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">a4</span></code></dt>
<dd>additional syscall register 4</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in audit context at syscall entry.  This only happens if the
audit context was created when the task was created and the state or
filters demand the audit context be built.  If the state from the
per-task filter or from the per-syscall filter is AUDIT_RECORD_CONTEXT,
then the record will be written at syscall exit time (otherwise, it
will only be written if another part of the kernel requests that it
be written).</p>
<dl class="function">
<dt id="c.__audit_syscall_exit">
void <code class="descname">__audit_syscall_exit</code><span class="sig-paren">(</span>int<em>&nbsp;success</em>, long<em>&nbsp;return_code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_syscall_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>deallocate audit context after a system call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">success</span></code></dt>
<dd>success value of the syscall</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">return_code</span></code></dt>
<dd>return value of the syscall</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down after system call.  If the audit context has been marked as
auditable (either because of the AUDIT_RECORD_CONTEXT state from
filtering, or because some other part of the kernel wrote an audit
message), then write out the syscall information.  In call cases,
free the names stored from <code class="xref c c-func docutils literal"><span class="pre">getname()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_reusename">
struct filename * <code class="descname">__audit_reusename</code><span class="sig-paren">(</span>const __user char *<em>&nbsp;uptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_reusename" title="Permalink to this definition">¶</a></dt>
<dd><p>fill out filename with info from existing entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">__user</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">uptr</span></code></dt>
<dd>userland ptr to pathname</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the audit_names list for the current audit context. If there is an
existing entry with a matching &#8220;uptr&#8221; then return the filename
associated with that audit_name. If not, return NULL.</p>
<dl class="function">
<dt id="c.__audit_getname">
void <code class="descname">__audit_getname</code><span class="sig-paren">(</span>struct filename *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_getname" title="Permalink to this definition">¶</a></dt>
<dd><p>add a name to the list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a name to the list of audit names for this context.
Called from fs/namei.c:<code class="xref c c-func docutils literal"><span class="pre">getname()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_inode">
void <code class="descname">__audit_inode</code><span class="sig-paren">(</span>struct filename *<em>&nbsp;name</em>, const struct dentry *<em>&nbsp;dentry</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_inode" title="Permalink to this definition">¶</a></dt>
<dd><p>store the inode and device from a lookup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">filename</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name being audited</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">dentry</span> <span class="pre">*</span> <span class="pre">dentry</span></code></dt>
<dd>dentry being audited</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>attributes for this particular entry</dd>
</dl>
<dl class="function">
<dt id="c.auditsc_get_stamp">
int <code class="descname">auditsc_get_stamp</code><span class="sig-paren">(</span>struct audit_context *<em>&nbsp;ctx</em>, struct timespec64 *<em>&nbsp;t</em>, unsigned int *<em>&nbsp;serial</em><span class="sig-paren">)</span><a class="headerlink" href="#c.auditsc_get_stamp" title="Permalink to this definition">¶</a></dt>
<dd><p>get local copies of audit_context values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">audit_context</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>audit_context for the task</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>timespec64 to store time recorded in the audit_context</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">serial</span></code></dt>
<dd>serial value that is recorded in the audit_context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also sets the context as auditable.</p>
<dl class="function">
<dt id="c.audit_set_loginuid">
int <code class="descname">audit_set_loginuid</code><span class="sig-paren">(</span>kuid_t<em>&nbsp;loginuid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_set_loginuid" title="Permalink to this definition">¶</a></dt>
<dd><p>set current task&#8217;s audit_context loginuid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">kuid_t</span> <span class="pre">loginuid</span></code></dt>
<dd>loginuid value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0.</p>
<p>Called (set) from fs/proc/base.c::<code class="xref c c-func docutils literal"><span class="pre">proc_loginuid_write()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_mq_open">
void <code class="descname">__audit_mq_open</code><span class="sig-paren">(</span>int<em>&nbsp;oflag</em>, umode_t<em>&nbsp;mode</em>, struct mq_attr *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_open" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ open</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">oflag</span></code></dt>
<dd>open flag</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>mode bits</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>queue attributes</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_sendrecv">
void <code class="descname">__audit_mq_sendrecv</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, size_t<em>&nbsp;msg_len</em>, unsigned int<em>&nbsp;msg_prio</em>, const struct timespec64 *<em>&nbsp;abs_timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_sendrecv" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ timed send/receive</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">msg_len</span></code></dt>
<dd>Message length</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msg_prio</span></code></dt>
<dd>Message priority</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">abs_timeout</span></code></dt>
<dd>Message timeout in absolute time</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_notify">
void <code class="descname">__audit_mq_notify</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, const struct sigevent *<em>&nbsp;notification</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ notify</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigevent</span> <span class="pre">*</span> <span class="pre">notification</span></code></dt>
<dd>Notification event</dd>
</dl>
<dl class="function">
<dt id="c.__audit_mq_getsetattr">
void <code class="descname">__audit_mq_getsetattr</code><span class="sig-paren">(</span>mqd_t<em>&nbsp;mqdes</em>, struct mq_attr *<em>&nbsp;mqstat</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_mq_getsetattr" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for a POSIX MQ get/set attribute</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mqd_t</span> <span class="pre">mqdes</span></code></dt>
<dd>MQ descriptor</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mq_attr</span> <span class="pre">*</span> <span class="pre">mqstat</span></code></dt>
<dd>MQ flags</dd>
</dl>
<dl class="function">
<dt id="c.__audit_ipc_obj">
void <code class="descname">__audit_ipc_obj</code><span class="sig-paren">(</span>struct kern_ipc_perm *<em>&nbsp;ipcp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for ipc object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kern_ipc_perm</span> <span class="pre">*</span> <span class="pre">ipcp</span></code></dt>
<dd>ipc permissions</dd>
</dl>
<dl class="function">
<dt id="c.__audit_ipc_set_perm">
void <code class="descname">__audit_ipc_set_perm</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;qbytes</em>, uid_t<em>&nbsp;uid</em>, gid_t<em>&nbsp;gid</em>, umode_t<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_ipc_set_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for new ipc permissions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">qbytes</span></code></dt>
<dd>msgq bytes</dd>
<dt><code class="docutils literal"><span class="pre">uid_t</span> <span class="pre">uid</span></code></dt>
<dd>msgq user id</dd>
<dt><code class="docutils literal"><span class="pre">gid_t</span> <span class="pre">gid</span></code></dt>
<dd>msgq group id</dd>
<dt><code class="docutils literal"><span class="pre">umode_t</span> <span class="pre">mode</span></code></dt>
<dd>msgq mode (permissions)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called only after <code class="xref c c-func docutils literal"><span class="pre">audit_ipc_obj()</span></code>.</p>
<dl class="function">
<dt id="c.__audit_socketcall">
int <code class="descname">__audit_socketcall</code><span class="sig-paren">(</span>int<em>&nbsp;nargs</em>, unsigned long *<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_socketcall" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for sys_socketcall</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nargs</span></code></dt>
<dd>number of args, which should not be more than AUDITSC_ARGS.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">args</span></code></dt>
<dd>args array</dd>
</dl>
<dl class="function">
<dt id="c.__audit_fd_pair">
void <code class="descname">__audit_fd_pair</code><span class="sig-paren">(</span>int<em>&nbsp;fd1</em>, int<em>&nbsp;fd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_fd_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for pipe and socketpair</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd1</span></code></dt>
<dd>the first file descriptor</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">fd2</span></code></dt>
<dd>the second file descriptor</dd>
</dl>
<dl class="function">
<dt id="c.__audit_sockaddr">
int <code class="descname">__audit_sockaddr</code><span class="sig-paren">(</span>int<em>&nbsp;len</em>, void *<em>&nbsp;a</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_sockaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>record audit data for sys_bind, sys_connect, sys_sendto</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>data length in user space</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">a</span></code></dt>
<dd>data address in kernel space</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or NULL context or &lt; 0 on error.</p>
<dl class="function">
<dt id="c.audit_signal_info">
int <code class="descname">audit_signal_info</code><span class="sig-paren">(</span>int<em>&nbsp;sig</em>, struct task_struct *<em>&nbsp;t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_signal_info" title="Permalink to this definition">¶</a></dt>
<dd><p>record signal info for shutting down audit subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig</span></code></dt>
<dd>signal value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>task being signaled</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the audit subsystem is being terminated, record the task (pid)
and uid that is doing that.</p>
<dl class="function">
<dt id="c.__audit_log_bprm_fcaps">
int <code class="descname">__audit_log_bprm_fcaps</code><span class="sig-paren">(</span>struct linux_binprm *<em>&nbsp;bprm</em>, const struct cred *<em>&nbsp;new</em>, const struct cred *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_bprm_fcaps" title="Permalink to this definition">¶</a></dt>
<dd><p>store information about a loading bprm and relevant fcaps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">linux_binprm</span> <span class="pre">*</span> <span class="pre">bprm</span></code></dt>
<dd>pointer to the bprm being processed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the proposed new credentials</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the old credentials</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simply check if the proc already has the caps given by the file and if not
store the priv escalation info for later auditing at the end of the syscall</p>
<p>-Eric</p>
<dl class="function">
<dt id="c.__audit_log_capset">
void <code class="descname">__audit_log_capset</code><span class="sig-paren">(</span>const struct cred *<em>&nbsp;new</em>, const struct cred *<em>&nbsp;old</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__audit_log_capset" title="Permalink to this definition">¶</a></dt>
<dd><p>store information about the arguments to the capset syscall</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new credentials</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cred</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the old (current) credentials</dd>
</dl>
<p><strong>Description</strong></p>
<p>Record the arguments userspace sent to sys_capset for later printing by the
audit system if applicable</p>
<dl class="function">
<dt id="c.audit_core_dumps">
void <code class="descname">audit_core_dumps</code><span class="sig-paren">(</span>long<em>&nbsp;signr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_core_dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>record information about processes that end abnormally</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">signr</span></code></dt>
<dd>signal value</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a process ends with a core dump, something fishy is going on and we
should record the event for investigation.</p>
<dl class="function">
<dt id="c.audit_seccomp">
void <code class="descname">audit_seccomp</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;syscall</em>, long<em>&nbsp;signr</em>, int<em>&nbsp;code</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_seccomp" title="Permalink to this definition">¶</a></dt>
<dd><p>record information about a seccomp action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">syscall</span></code></dt>
<dd>syscall number</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">signr</span></code></dt>
<dd>signal value</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">code</span></code></dt>
<dd>the seccomp action</dd>
</dl>
<p><strong>Description</strong></p>
<p>Record the information associated with a seccomp action. Event filtering for
seccomp actions that are not to be logged is done in <code class="xref c c-func docutils literal"><span class="pre">seccomp_log()</span></code>.
Therefore, this function forces auditing independent of the audit_enabled
and dummy context state because seccomp actions should be logged even when
audit is not in use.</p>
<dl class="function">
<dt id="c.audit_rule_change">
int <code class="descname">audit_rule_change</code><span class="sig-paren">(</span>int<em>&nbsp;type</em>, int<em>&nbsp;seq</em>, void *<em>&nbsp;data</em>, size_t<em>&nbsp;datasz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_rule_change" title="Permalink to this definition">¶</a></dt>
<dd><p>apply all rules to the specified message type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>audit message type</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">seq</span></code></dt>
<dd>netlink audit message sequence (serial) number</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>payload data</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">datasz</span></code></dt>
<dd>size of payload data</dd>
</dl>
<dl class="function">
<dt id="c.audit_list_rules_send">
int <code class="descname">audit_list_rules_send</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff">sk_buff</a> *<em>&nbsp;request_skb</em>, int<em>&nbsp;seq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_list_rules_send" title="Permalink to this definition">¶</a></dt>
<dd><p>list the audit rules</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span> <span class="pre">*</span> <span class="pre">request_skb</span></code></dt>
<dd>skb of request we are replying to (used to target the reply)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">seq</span></code></dt>
<dd>netlink audit message sequence (serial) number</dd>
</dl>
<dl class="function">
<dt id="c.parent_len">
int <code class="descname">parent_len</code><span class="sig-paren">(</span>const char *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.parent_len" title="Permalink to this definition">¶</a></dt>
<dd><p>find the length of the parent portion of a pathname</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>pathname of which to determine length</dd>
</dl>
<dl class="function">
<dt id="c.audit_compare_dname_path">
int <code class="descname">audit_compare_dname_path</code><span class="sig-paren">(</span>const char *<em>&nbsp;dname</em>, const char *<em>&nbsp;path</em>, int<em>&nbsp;parentlen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.audit_compare_dname_path" title="Permalink to this definition">¶</a></dt>
<dd><p>compare given dentry name with last component in given path. Return of 0 indicates a match.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">dname</span></code></dt>
<dd>dentry name that we&#8217;re comparing</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>full pathname that we&#8217;re comparing</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">parentlen</span></code></dt>
<dd>length of the parent if known. Passing in AUDIT_NAME_FULL
here indicates that we must compute this value.</dd>
</dl>
</div>
<div class="section" id="accounting-framework">
<h2>Accounting Framework<a class="headerlink" href="#accounting-framework" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.sys_acct">
long <code class="descname">sys_acct</code><span class="sig-paren">(</span>const char __user *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_acct" title="Permalink to this definition">¶</a></dt>
<dd><p>enable/disable process accounting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>file name for accounting records or NULL to shutdown accounting</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for success or negative errno values for failure.</p>
<p><a class="reference internal" href="#c.sys_acct" title="sys_acct"><code class="xref c c-func docutils literal"><span class="pre">sys_acct()</span></code></a> is the only system call needed to implement process
accounting. It takes the name of the file where accounting records
should be written. If the filename is NULL, accounting will be
shutdown.</p>
<dl class="function">
<dt id="c.acct_collect">
void <code class="descname">acct_collect</code><span class="sig-paren">(</span>long<em>&nbsp;exitcode</em>, int<em>&nbsp;group_dead</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acct_collect" title="Permalink to this definition">¶</a></dt>
<dd><p>collect accounting information into pacct_struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">exitcode</span></code></dt>
<dd>task exit code</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">group_dead</span></code></dt>
<dd>not 0, if this thread is the last one in the process.</dd>
</dl>
<dl class="function">
<dt id="c.acct_process">
void <code class="descname">acct_process</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.acct_process" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>handles process accounting for an exiting task</p>
</div>
<div class="section" id="block-devices">
<h2>Block Devices<a class="headerlink" href="#block-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.blk_queue_flag_set">
void <code class="descname">blk_queue_flag_set</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;flag</em>, struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_set" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically set a queue flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt>
<dd>flag to be set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_flag_clear">
void <code class="descname">blk_queue_flag_clear</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;flag</em>, struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically clear a queue flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt>
<dd>flag to be cleared</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_flag_test_and_set">
bool <code class="descname">blk_queue_flag_test_and_set</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;flag</em>, struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_test_and_set" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically test and set a queue flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt>
<dd>flag to be set</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the previous value of <strong>flag</strong> - 0 if the flag was not set and 1 if
the flag was already set.</p>
<dl class="function">
<dt id="c.blk_queue_flag_test_and_clear">
bool <code class="descname">blk_queue_flag_test_and_clear</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;flag</em>, struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_flag_test_and_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>atomically test and clear a queue flag</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flag</span></code></dt>
<dd>flag to be cleared</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the previous value of <strong>flag</strong> - 0 if the flag was not set and 1 if
the flag was set.</p>
<dl class="function">
<dt id="c.blk_delay_queue">
void <code class="descname">blk_delay_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_delay_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart queueing after defined interval</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">msecs</span></code></dt>
<dd>Delay in msecs</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Sometimes queueing needs to be postponed for a little while, to allow
resources to come back. This function will make sure that queueing is
restarted around the specified time.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_queue_async">
void <code class="descname">blk_start_queue_async</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_queue_async" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronously restart a previously stopped queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_start_queue_async" title="blk_start_queue_async"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue_async()</span></code></a> will clear the stop flag on the queue, and
ensure that the request_fn for the queue is run from an async
context.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_queue">
void <code class="descname">blk_start_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>restart a previously stopped queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_start_queue" title="blk_start_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue()</span></code></a> will clear the stop flag on the queue, and call
the request_fn for the queue if it was in a stopped state when
entered. Also see <a class="reference internal" href="#c.blk_stop_queue" title="blk_stop_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_stop_queue()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.blk_stop_queue">
void <code class="descname">blk_stop_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_stop_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> in question</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The Linux block layer assumes that a block driver will consume all
entries on the request queue when the request_fn strategy is called.
Often this will not happen, because of hardware limitations (queue
depth settings). If a device driver gets a &#8216;queue full&#8217; response,
or if it simply chooses not to queue more I/O at one point, it can
call this function to prevent the request_fn from being called until
the driver has signalled it&#8217;s ready to go again. This happens by calling
<a class="reference internal" href="#c.blk_start_queue" title="blk_start_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_start_queue()</span></code></a> to restart queue operations.</div></blockquote>
<dl class="function">
<dt id="c.blk_sync_queue">
void <code class="descname">blk_sync_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_sync_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel any pending callbacks on a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>The block layer may perform asynchronous callback activity
on a queue, such as calling the unplug function after a timeout.
A block device may call blk_sync_queue to ensure that any
such activity is cancelled, thus allowing it to release resources
that the callbacks might use. The caller must already have made sure
that its -&gt;make_request_fn will not re-add plugging prior to calling
this function.</p>
<p>This function does not cancel any asynchronous activity arising
out of elevator or throttling code. That would require <code class="xref c c-func docutils literal"><span class="pre">elevator_exit()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">blkcg_exit_queue()</span></code> to be called with queue lock initialized.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_set_preempt_only">
int <code class="descname">blk_set_preempt_only</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_preempt_only" title="Permalink to this definition">¶</a></dt>
<dd><p>set QUEUE_FLAG_PREEMPT_ONLY</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the previous value of the PREEMPT_ONLY flag - 0 if the flag was not
set and 1 if the flag was already set.</p>
<dl class="function">
<dt id="c.__blk_run_queue_uncond">
void <code class="descname">__blk_run_queue_uncond</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_run_queue_uncond" title="Permalink to this definition">¶</a></dt>
<dd><p>run a queue whether or not it has been stopped</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Invoke request handling on a queue if there are any pending requests.
May be used to restart request handling after a request has completed.
This variant runs the queue whether or not the queue has been
stopped. Must be called with the queue lock held and interrupts
disabled. See also <strong>blk_run_queue</strong>.</div></blockquote>
<dl class="function">
<dt id="c.__blk_run_queue">
void <code class="descname">__blk_run_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_run_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>See <strong>blk_run_queue</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_run_queue_async">
void <code class="descname">blk_run_queue_async</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_run_queue_async" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue in workqueue context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Tells kblockd to perform the equivalent of <strong>blk_run_queue</strong> on behalf
of us.</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div>Since it is not allowed to run q-&gt;delay_work after <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a>
has canceled q-&gt;delay_work, callers must hold the queue lock to avoid
race conditions between <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> and <a class="reference internal" href="#c.blk_run_queue_async" title="blk_run_queue_async"><code class="xref c c-func docutils literal"><span class="pre">blk_run_queue_async()</span></code></a>.</div></blockquote>
<dl class="function">
<dt id="c.blk_run_queue">
void <code class="descname">blk_run_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_run_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>run a single device queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The queue to run</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Invoke request handling on this queue, if it has pending work to do.
May be used to restart queueing when a request has completed.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_bypass_start">
void <code class="descname">blk_queue_bypass_start</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bypass_start" title="Permalink to this definition">¶</a></dt>
<dd><p>enter queue bypass mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>In bypass mode, only the dispatch FIFO queue of <strong>q</strong> is used.  This
function makes <strong>q</strong> enter bypass mode and drains all requests which were
throttled or issued before.  On return, it&#8217;s guaranteed that no request
is being throttled or has ELVPRIV set and <code class="xref c c-func docutils literal"><span class="pre">blk_queue_bypass()</span></code> <code class="docutils literal"><span class="pre">true</span></code>
inside queue or RCU read lock.</p>
<dl class="function">
<dt id="c.blk_queue_bypass_end">
void <code class="descname">blk_queue_bypass_end</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bypass_end" title="Permalink to this definition">¶</a></dt>
<dd><p>leave queue bypass mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Leave bypass mode and restore the normal queueing behavior.</p>
<p><strong>Note</strong></p>
<p>although <a class="reference internal" href="#c.blk_queue_bypass_start" title="blk_queue_bypass_start"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_bypass_start()</span></code></a> is only called for blk-sq queues,
this function is called for both blk-sq and blk-mq queues.</p>
<dl class="function">
<dt id="c.blk_cleanup_queue">
void <code class="descname">blk_cleanup_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_cleanup_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>shutdown a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to shutdown</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark <strong>q</strong> DYING, drain all pending requests, mark <strong>q</strong> DEAD, destroy and
put it.  All future requests will be failed immediately with -ENODEV.</p>
<dl class="function">
<dt id="c.blk_alloc_queue_node">
struct request_queue * <code class="descname">blk_alloc_queue_node</code><span class="sig-paren">(</span>gfp_t<em>&nbsp;gfp_mask</em>, int<em>&nbsp;node_id</em>, spinlock_t *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_alloc_queue_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node_id</span></code></dt>
<dd>NUMA node to allocate memory from</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>For legacy queues, pointer to a spinlock that will be used to e.g.
serialize calls to the legacy .:c:func:<cite>request_fn()</cite> callback. Ignored for
blk-mq request queues.</dd>
</dl>
<p><strong>Note</strong></p>
<p>pass the queue lock as the third argument to this function instead of
setting the queue lock pointer explicitly to avoid triggering a sporadic
crash in the blkcg code. This function namely calls <code class="xref c c-func docutils literal"><span class="pre">blkcg_init_queue()</span></code> and
the queue lock pointer must be set before <code class="xref c c-func docutils literal"><span class="pre">blkcg_init_queue()</span></code> is called.</p>
<dl class="function">
<dt id="c.blk_init_queue">
struct request_queue * <code class="descname">blk_init_queue</code><span class="sig-paren">(</span>request_fn_proc *<em>&nbsp;rfn</em>, spinlock_t *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_init_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a request queue for use with a block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">request_fn_proc</span> <span class="pre">*</span> <span class="pre">rfn</span></code></dt>
<dd>The function to be called to process requests that have been
placed on the queue.</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>Request queue spin lock</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>If a block device wishes to use the standard request handling procedures,
which sorts requests and coalesces adjacent requests, then it must
call <a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a>.  The function <strong>rfn</strong> will be called when there
are requests on the queue that need to be processed.  If the device
supports plugging, then <strong>rfn</strong> may not be called immediately when requests
are available on the queue, but may be called at some time later instead.
Plugged queues are generally unplugged when a buffer belonging to one
of the requests on the queue is needed, or due to memory pressure.</p>
<p><strong>rfn</strong> is not required, or even expected, to remove all requests off the
queue, but only as many as it can handle at a time.  If it does leave
requests on the queue, it is responsible for arranging that the requests
get dealt with eventually.</p>
<p>The queue spin lock must be held while manipulating the requests on the
request queue; this lock will be taken also from interrupt context, so irq
disabling is needed for it.</p>
<p>Function returns a pointer to the initialized request queue, or <code class="docutils literal"><span class="pre">NULL</span></code> if
it didn&#8217;t succeed.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a> must be paired with a <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> call
when the block device is deactivated (such as at module unload).</div></blockquote>
<dl class="function">
<dt id="c.blk_get_request">
struct request * <code class="descname">blk_get_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;op</em>, blk_mq_req_flags_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_get_request" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to allocate a request for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>operation (REQ_OP_*) and REQ_* flags, e.g. REQ_SYNC.</dd>
<dt><code class="docutils literal"><span class="pre">blk_mq_req_flags_t</span> <span class="pre">flags</span></code></dt>
<dd>BLK_MQ_REQ_* flags, e.g. BLK_MQ_REQ_NOWAIT.</dd>
</dl>
<dl class="function">
<dt id="c.blk_requeue_request">
void <code class="descname">blk_requeue_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_requeue_request" title="Permalink to this definition">¶</a></dt>
<dd><p>put a request back on queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to be inserted</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Drivers often keep queueing requests until the hardware cannot accept
more, when that condition happens we need to put the request back
on the queue. Must be called with queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.part_round_stats">
void <code class="descname">part_round_stats</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;cpu</em>, struct hd_struct *<em>&nbsp;part</em><span class="sig-paren">)</span><a class="headerlink" href="#c.part_round_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Round off the performance stats on a struct disk_stats.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>target block queue</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>cpu number for stats access</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hd_struct</span> <span class="pre">*</span> <span class="pre">part</span></code></dt>
<dd>target partition</dd>
</dl>
<p><strong>Description</strong></p>
<p>The average IO queue length and utilisation statistics are maintained
by observing the current state of the queue length and the amount of
time it has been in this state for.</p>
<p>Normally, that accounting is done on IO completion, but that can result
in more than a second&#8217;s worth of IO being accounted for within any one
second, leading to &gt;100% utilisation.  To deal with that, we call this
function to do a round-off before returning the results when reading
/proc/diskstats.  This accounts immediately for all queue usage up to
the current jiffies and restarts the counters again.</p>
<dl class="function">
<dt id="c.generic_make_request">
blk_qc_t <code class="descname">generic_make_request</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.generic_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>hand a buffer to its device driver for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The bio describing the location in memory and on the device.</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> is used to make I/O requests of block
devices. It is passed a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code>, which describes the I/O that needs
to be done.</p>
<p><a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a> does not return any status.  The
success/failure status of the request, along with notification of
completion, is delivered asynchronously through the bio-&gt;bi_end_io
function described (one day) else where.</p>
<p>The caller of generic_make_request must make sure that bi_io_vec
are set to describe the memory buffer, and that bi_dev and bi_sector are
set to describe the device address, and the
bi_end_io and optionally bi_private are set to describe how
completion notification should be signaled.</p>
<p>generic_make_request and the drivers it calls may use bi_next if this
bio happens to be merged with someone else, and may resubmit the bio to
a lower device by calling into generic_make_request recursively, which
means the bio should NOT be touched after the call to -&gt;make_request_fn.</p>
<dl class="function">
<dt id="c.direct_make_request">
blk_qc_t <code class="descname">direct_make_request</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.direct_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>hand a buffer directly to its device driver for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The bio describing the location in memory and on the device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function behaves like <a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a>, but does not protect
against recursion.  Must only be used if the called driver is known
to not call generic_make_request (or direct_make_request) again from
its make_request function.  (Calling direct_make_request again from
a workqueue is perfectly fine as that doesn&#8217;t recurse).</p>
<dl class="function">
<dt id="c.submit_bio">
blk_qc_t <code class="descname">submit_bio</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.submit_bio" title="Permalink to this definition">¶</a></dt>
<dd><p>submit a bio to the block device layer for I/O</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> which describes the I/O</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.submit_bio" title="submit_bio"><code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code></a> is very similar in purpose to <a class="reference internal" href="#c.generic_make_request" title="generic_make_request"><code class="xref c c-func docutils literal"><span class="pre">generic_make_request()</span></code></a>, and
uses that function to do most of the work. Both are fairly rough
interfaces; <strong>bio</strong> must be presetup and ready for I/O.</p>
<dl class="function">
<dt id="c.blk_insert_cloned_request">
blk_status_t <code class="descname">blk_insert_cloned_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_insert_cloned_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for stacking drivers to submit a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue to submit the request</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being queued</dd>
</dl>
<dl class="function">
<dt id="c.blk_rq_err_bytes">
unsigned int <code class="descname">blk_rq_err_bytes</code><span class="sig-paren">(</span>const struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_err_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>determine number of bytes till the next failure boundary</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to examine</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>A request could be merge of IOs which require different failure
handling.  This function determines the number of bytes which
can be failed from the beginning of the request without
crossing into area which need to be retried further.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>The number of bytes to fail.</div></blockquote>
<dl class="function">
<dt id="c.blk_peek_request">
struct request * <code class="descname">blk_peek_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_peek_request" title="Permalink to this definition">¶</a></dt>
<dd><p>peek at the top of a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to peek at</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the request at the top of <strong>q</strong>.  The returned request
should be started using <a class="reference internal" href="#c.blk_start_request" title="blk_start_request"><code class="xref c c-func docutils literal"><span class="pre">blk_start_request()</span></code></a> before LLD starts
processing it.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to the request at the top of <strong>q</strong> if available.  Null
otherwise.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_request">
void <code class="descname">blk_start_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_request" title="Permalink to this definition">¶</a></dt>
<dd><p>start request processing on the driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>request to dequeue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Dequeue <strong>req</strong> and start timeout timer on it.  This hands off the
request to the driver.</div></blockquote>
<dl class="function">
<dt id="c.blk_fetch_request">
struct request * <code class="descname">blk_fetch_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_fetch_request" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch a request from a request queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue to fetch a request from</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Return the request at the top of <strong>q</strong>.  The request is started on
return and LLD can start processing it immediately.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>Pointer to the request at the top of <strong>q</strong> if available.  Null
otherwise.</div></blockquote>
<dl class="function">
<dt id="c.blk_update_request">
bool <code class="descname">blk_update_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_update_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Special helper function for request stacking drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>req</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Ends I/O on a number of bytes attached to <strong>req</strong>, but doesn&#8217;t complete
the request structure even if <strong>req</strong> doesn&#8217;t have leftover.
If <strong>req</strong> has leftover, sets it up for the next range of segments.</p>
<p>This special helper function is only for request stacking drivers
(e.g. request-based dm) so that they can handle partial completion.
Actual device drivers should use blk_end_request instead.</p>
<p>Passing the result of <code class="xref c c-func docutils literal"><span class="pre">blk_rq_bytes()</span></code> as <strong>nr_bytes</strong> guarantees
<code class="docutils literal"><span class="pre">false</span></code> return from this function.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div>The RQF_SPECIAL_PAYLOAD flag is ignored on purpose in both
<code class="xref c c-func docutils literal"><span class="pre">blk_rq_bytes()</span></code> and in <a class="reference internal" href="#c.blk_update_request" title="blk_update_request"><code class="xref c c-func docutils literal"><span class="pre">blk_update_request()</span></code></a>.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - this request doesn&#8217;t have any more data
<code class="docutils literal"><span class="pre">true</span></code>  - this request has more data</div></blockquote>
<dl class="function">
<dt id="c.blk_unprep_request">
void <code class="descname">blk_unprep_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_unprep_request" title="Permalink to this definition">¶</a></dt>
<dd><p>unprepare a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd>the request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function makes a request ready for complete resubmission (or
completion).  It happens only after all error handling is complete,
so represents the appropriate moment to deallocate any resources
that were allocated to the request in the prep_rq_fn.  The queue
lock is held when calling this.</p>
<dl class="function">
<dt id="c.blk_end_request">
bool <code class="descname">blk_end_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drivers to complete the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ends I/O on a number of bytes attached to <strong>rq</strong>.
If <strong>rq</strong> has leftover, sets it up for the next range of segments.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.blk_end_request_all">
void <code class="descname">blk_end_request_all</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_request_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drives to finish the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Completely finish <strong>rq</strong>.</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request">
bool <code class="descname">__blk_end_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drivers to complete the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being processed</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Must be called with queue lock held unlike <a class="reference internal" href="#c.blk_end_request" title="blk_end_request"><code class="xref c c-func docutils literal"><span class="pre">blk_end_request()</span></code></a>.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request_all">
void <code class="descname">__blk_end_request_all</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for drives to finish the request.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Completely finish <strong>rq</strong>.  Must be called with queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_request_cur">
bool <code class="descname">__blk_end_request_cur</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_request_cur" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to finish the current request chunk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to finish the current chunk for</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Complete the current consecutively mapped chunk from <strong>rq</strong>.  Must
be called with queue lock held.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.rq_flush_dcache_pages">
void <code class="descname">rq_flush_dcache_pages</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rq_flush_dcache_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to flush all pages in a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to be flushed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Flush all pages in <strong>rq</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_lld_busy">
int <code class="descname">blk_lld_busy</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_lld_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if underlying low-level drivers of a device are busy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device being checked</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Check if underlying low-level drivers of a device are busy.
If the drivers want to export their busy state, they must set own
exporting function using <code class="xref c c-func docutils literal"><span class="pre">blk_queue_lld_busy()</span></code> first.</p>
<p>Basically, this function is used only by request stacking drivers
to stop dispatching requests to underlying devices when underlying
devices are busy.  This behavior helps more I/O merging on the queue
of the request stacking driver and prevents I/O throughput regression
on burst I/O load.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>0 - Not busy (The request stacking driver should dispatch request)
1 - Busy (The request stacking driver should stop dispatching request)</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_unprep_clone">
void <code class="descname">blk_rq_unprep_clone</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unprep_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to free all bios in a cloned request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the clone request to be cleaned up</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Free all bios in <strong>rq</strong> for a cloned request.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_prep_clone">
int <code class="descname">blk_rq_prep_clone</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, struct request *<em>&nbsp;rq_src</em>, struct bio_set *<em>&nbsp;bs</em>, gfp_t<em>&nbsp;gfp_mask</em>, int (*bio_ctr) (struct bio<em>&nbsp;*</em>, struct bio<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_prep_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to setup clone request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to be setup</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq_src</span></code></dt>
<dd>original request to be cloned</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio_set</span> <span class="pre">*</span> <span class="pre">bs</span></code></dt>
<dd>bio_set that bios for clone are allocated from</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation mask for bio</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">bio</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">bio_ctr</span></code></dt>
<dd>setup function to be called for each clone bio.
Returns <code class="docutils literal"><span class="pre">0</span></code> for success, non <code class="docutils literal"><span class="pre">0</span></code> for failure.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>private data to be passed to <strong>bio_ctr</strong></dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Clones bios in <strong>rq_src</strong> to <strong>rq</strong>, and copies attributes of <strong>rq_src</strong> to <strong>rq</strong>.
The actual data parts of <strong>rq_src</strong> (e.g. -&gt;cmd, -&gt;sense)
are not copied, and copying such parts is the caller&#8217;s responsibility.
Also, pages which the original bios are pointing to are not copied
and the cloned bios just point same pages.
So cloned bios must be completed before original bios, which means
the caller must complete <strong>rq</strong> before <strong>rq_src</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_start_plug">
void <code class="descname">blk_start_plug</code><span class="sig-paren">(</span>struct blk_plug *<em>&nbsp;plug</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_start_plug" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize blk_plug and track it inside the task_struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_plug</span> <span class="pre">*</span> <span class="pre">plug</span></code></dt>
<dd>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_plug</span></code> that needs to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Tracking blk_plug inside the task_struct will help with auto-flushing the
pending I/O should the task end up blocking between <a class="reference internal" href="#c.blk_start_plug" title="blk_start_plug"><code class="xref c c-func docutils literal"><span class="pre">blk_start_plug()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">blk_finish_plug()</span></code>. This is important from a performance perspective, but
also ensures that we don&#8217;t deadlock. For instance, if the task is blocking
for a memory allocation, memory reclaim could end up wanting to free a
page belonging to that request that is currently residing in our private
plug. By flushing the pending I/O when the process goes to sleep, we avoid
this kind of deadlock.</div></blockquote>
<dl class="function">
<dt id="c.blk_pm_runtime_init">
void <code class="descname">blk_pm_runtime_init</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pm_runtime_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Block layer runtime PM initialization routine</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device the queue belongs to</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Initialize runtime-PM-related fields for <strong>q</strong> and start auto suspend for
<strong>dev</strong>. Drivers that want to take advantage of request-based runtime PM
should call this function after <strong>dev</strong> has been initialized, and its
request queue <strong>q</strong> has been allocated, and runtime PM for it can not happen
yet(either due to disabled/forbidden or its usage_count &gt; 0). In most
cases, driver should call this function before any I/O has taken place.</p>
<p>This function takes care of setting up using auto suspend for the device,
the autosuspend delay is set to -1 to make runtime suspend impossible
until an updated value is either set by user or by driver. Drivers do
not need to touch other autosuspend settings.</p>
<p>The block layer runtime PM is request based, so only works for drivers
that use request as their IO unit instead of those directly use bio&#8217;s.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_pre_runtime_suspend">
int <code class="descname">blk_pre_runtime_suspend</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pre_runtime_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre runtime suspend check</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function will check if runtime suspend is allowed for the device
by examining if there are any requests pending in the queue. If there
are requests pending, the device can not be runtime suspended; otherwise,
the queue&#8217;s status will be updated to SUSPENDING and the driver can
proceed to suspend the device.</p>
<p>For the not allowed case, we mark last busy for the device so that
runtime PM core will try to autosuspend it some time later.</p>
<p>This function should be called near the start of the device&#8217;s
runtime_suspend callback.</p>
</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div>0         - OK to runtime suspend the device
-EBUSY    - Device should not be runtime suspended</div></blockquote>
<dl class="function">
<dt id="c.blk_post_runtime_suspend">
void <code class="descname">blk_post_runtime_suspend</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_post_runtime_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Post runtime suspend processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>return value of the device&#8217;s runtime_suspend function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue&#8217;s runtime status according to the return value of the
device&#8217;s runtime suspend function and mark last busy for the device so
that PM core will try to auto suspend the device at a later time.</p>
<p>This function should be called near the end of the device&#8217;s
runtime_suspend callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_pre_runtime_resume">
void <code class="descname">blk_pre_runtime_resume</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_pre_runtime_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre runtime resume processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue&#8217;s runtime status to RESUMING in preparation for the
runtime resume of the device.</p>
<p>This function should be called near the start of the device&#8217;s
runtime_resume callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_post_runtime_resume">
void <code class="descname">blk_post_runtime_resume</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;err</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_post_runtime_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Post runtime resume processing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">err</span></code></dt>
<dd>return value of the device&#8217;s runtime_resume function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Update the queue&#8217;s runtime status according to the return value of the
device&#8217;s runtime_resume function. If it is successfully resumed, process
the requests that are queued into the device&#8217;s queue when it is resuming
and then mark last busy and initiate autosuspend for it.</p>
<p>This function should be called near the end of the device&#8217;s
runtime_resume callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_set_runtime_active">
void <code class="descname">blk_set_runtime_active</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_runtime_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Force runtime status of the queue to be active</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue of the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the device is left runtime suspended during system suspend the resume
hook typically resumes the device and corrects runtime status
accordingly. However, that does not affect the queue runtime PM status
which is still &#8220;suspended&#8221;. This prevents processing requests from the
queue.</p>
<p>This function can be used in driver&#8217;s resume hook to correct queue
runtime PM status and re-enable peeking requests from the queue. It
should be called before first request is added to the queue.</p>
<dl class="function">
<dt id="c.__blk_drain_queue">
void <code class="descname">__blk_drain_queue</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, bool<em>&nbsp;drain_all</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_drain_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>drain requests from request_queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to drain</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">drain_all</span></code></dt>
<dd>whether to drain all requests or only the ones w/ ELVPRIV</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drain requests from <strong>q</strong>.  If <strong>drain_all</strong> is set, all requests are drained.
If not, only ELVPRIV requests are drained.  The caller is responsible
for ensuring that no new requests which need to be drained are queued.</p>
<dl class="function">
<dt id="c.blk_queue_enter">
int <code class="descname">blk_queue_enter</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, blk_mq_req_flags_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>try to increase q-&gt;q_usage_counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue pointer</dd>
<dt><code class="docutils literal"><span class="pre">blk_mq_req_flags_t</span> <span class="pre">flags</span></code></dt>
<dd>BLK_MQ_REQ_NOWAIT and/or BLK_MQ_REQ_PREEMPT</dd>
</dl>
<dl class="function">
<dt id="c.__get_request">
struct request * <code class="descname">__get_request</code><span class="sig-paren">(</span>struct request_list *<em>&nbsp;rl</em>, unsigned int<em>&nbsp;op</em>, struct bio *<em>&nbsp;bio</em>, blk_mq_req_flags_t<em>&nbsp;flags</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__get_request" title="Permalink to this definition">¶</a></dt>
<dd><p>get a free request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_list</span> <span class="pre">*</span> <span class="pre">rl</span></code></dt>
<dd>request list to allocate from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>operation and flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to allocate request for (can be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">blk_mq_req_flags_t</span> <span class="pre">flags</span></code></dt>
<dd>BLQ_MQ_REQ_* flags</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>allocator flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a free request from <strong>q</strong>.  This function may fail under memory
pressure or if <strong>q</strong> is dead.</p>
<p>Must be called with <strong>q</strong>-&gt;queue_lock held and,
Returns ERR_PTR on failure, with <strong>q</strong>-&gt;queue_lock held.
Returns request pointer on success, with <strong>q</strong>-&gt;queue_lock <em>not held</em>.</p>
<dl class="function">
<dt id="c.get_request">
struct request * <code class="descname">get_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;op</em>, struct bio *<em>&nbsp;bio</em>, blk_mq_req_flags_t<em>&nbsp;flags</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_request" title="Permalink to this definition">¶</a></dt>
<dd><p>get a free request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request_queue to allocate request from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">op</span></code></dt>
<dd>operation and flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio to allocate request for (can be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">blk_mq_req_flags_t</span> <span class="pre">flags</span></code></dt>
<dd>BLK_MQ_REQ_* flags.</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocator flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a free request from <strong>q</strong>.  If <code class="docutils literal"><span class="pre">BLK_MQ_REQ_NOWAIT</span></code> is set in <strong>flags</strong>,
this function keeps retrying under memory pressure and fails iff <strong>q</strong> is dead.</p>
<p>Must be called with <strong>q</strong>-&gt;queue_lock held and,
Returns ERR_PTR on failure, with <strong>q</strong>-&gt;queue_lock held.
Returns request pointer on success, with <strong>q</strong>-&gt;queue_lock <em>not held</em>.</p>
<dl class="function">
<dt id="c.blk_attempt_plug_merge">
bool <code class="descname">blk_attempt_plug_merge</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, unsigned int *<em>&nbsp;request_count</em>, struct request **<em>&nbsp;same_queue_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_attempt_plug_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>try to merge with <code class="docutils literal"><span class="pre">current</span></code>&#8216;s plugged list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request_queue new bio is being queued at</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>new bio being queued</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">request_count</span></code></dt>
<dd>out parameter for number of traversed plugged requests</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">**</span> <span class="pre">same_queue_rq</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> that gets filled in when
another request associated with <strong>q</strong> is found on the plug list
(optional, may be <code class="docutils literal"><span class="pre">NULL</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine whether <strong>bio</strong> being queued on <strong>q</strong> can be merged with a request
on <code class="docutils literal"><span class="pre">current</span></code>&#8216;s plugged list.  Returns <code class="docutils literal"><span class="pre">true</span></code> if merge was successful,
otherwise <code class="docutils literal"><span class="pre">false</span></code>.</p>
<p>Plugging coalesces IOs from the same issuer for the same purpose without
going through <strong>q</strong>-&gt;queue_lock.  As such it&#8217;s more of an issuing mechanism
than scheduling, and the request, while may have elvpriv data, is not
added on the elevator at this point.  In addition, we don&#8217;t have
reliable access to the elevator outside queue lock.  Only check basic
merging parameters without querying the elevator.</p>
<p>Caller must ensure !blk_queue_nomerges(q) beforehand.</p>
<dl class="function">
<dt id="c.blk_cloned_rq_check_limits">
int <code class="descname">blk_cloned_rq_check_limits</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_cloned_rq_check_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to check a cloned request for new the queue limits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request being checked</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>rq</strong> may have been made based on weaker limitations of upper-level queues
in request stacking drivers, and it may violate the limitation of <strong>q</strong>.
Since the block layer and the underlying device driver trust <strong>rq</strong>
after it is inserted to <strong>q</strong>, it should be checked against <strong>q</strong> before
the insertion using this generic function.</p>
<p>Request stacking drivers like request-based dm may change the queue
limits when retrying requests on other queues. Those requests need
to be checked against the new queue limits again during dispatch.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_end_bidi_request">
bool <code class="descname">blk_end_bidi_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, unsigned int<em>&nbsp;bidi_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_end_bidi_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete a bidi request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to complete</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong></dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bidi_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong>-&gt;next_rq</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ends I/O on a number of bytes attached to <strong>rq</strong> and <strong>rq</strong>-&gt;next_rq.
Drivers that supports bidi can safely call this member for any
type of request, bidi or uni.  In the later case <strong>bidi_bytes</strong> is
just ignored.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.__blk_end_bidi_request">
bool <code class="descname">__blk_end_bidi_request</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, blk_status_t<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, unsigned int<em>&nbsp;bidi_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_end_bidi_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete a bidi request with queue lock held</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request to complete</dd>
<dt><code class="docutils literal"><span class="pre">blk_status_t</span> <span class="pre">error</span></code></dt>
<dd>block status code</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong></dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">bidi_bytes</span></code></dt>
<dd>number of bytes to complete <strong>rq</strong>-&gt;next_rq</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Identical to <a class="reference internal" href="#c.blk_end_bidi_request" title="blk_end_bidi_request"><code class="xref c c-func docutils literal"><span class="pre">blk_end_bidi_request()</span></code></a> except that queue lock is
assumed to be locked on entry and remains so on return.</div></blockquote>
<p><strong>Return</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">false</span></code> - we are done with this request
<code class="docutils literal"><span class="pre">true</span></code>  - still buffers pending for this request</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_map_user_iov">
int <code class="descname">blk_rq_map_user_iov</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, struct rq_map_data *<em>&nbsp;map_data</em>, const struct iov_iter *<em>&nbsp;iter</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_user_iov" title="Permalink to this definition">¶</a></dt>
<dd><p>map user data to a request, for passthrough requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to map data to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rq_map_data</span> <span class="pre">*</span> <span class="pre">map_data</span></code></dt>
<dd>pointer to the rq_map_data holding pages (if necessary)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">iov_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>iovec iterator</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Data will be mapped directly for zero copy I/O, if possible. Otherwise
a kernel bounce buffer is used.</p>
<p>A matching <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_unmap_user()</span></code></a> must be issued at the end of I/O, while
still in process context.</p>
</div></blockquote>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>The mapped bio may need to be bounced through <code class="xref c c-func docutils literal"><span class="pre">blk_queue_bounce()</span></code></dt>
<dd>before being submitted to the device, as pages mapped may be out of
reach. It&#8217;s the callers responsibility to make sure this happens. The
original bio must be passed back in to <a class="reference internal" href="#c.blk_rq_unmap_user" title="blk_rq_unmap_user"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_unmap_user()</span></code></a> for proper
unmapping.</dd>
</dl>
<dl class="function">
<dt id="c.blk_rq_unmap_user">
int <code class="descname">blk_rq_unmap_user</code><span class="sig-paren">(</span>struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_unmap_user" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap a request with user data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>start of bio list</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Unmap a rq previously mapped by <code class="xref c c-func docutils literal"><span class="pre">blk_rq_map_user()</span></code>. The caller must
supply the original rq-&gt;bio from the <code class="xref c c-func docutils literal"><span class="pre">blk_rq_map_user()</span></code> return, since
the I/O completion may have changed rq-&gt;bio.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_map_kern">
int <code class="descname">blk_rq_map_kern</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, void *<em>&nbsp;kbuf</em>, unsigned int<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_kern" title="Permalink to this definition">¶</a></dt>
<dd><p>map kernel data to a request, for passthrough requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue where request should be inserted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to fill</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">kbuf</span></code></dt>
<dd>the kernel buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>length of user data</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Data will be mapped directly if possible. Otherwise a bounce
buffer is used. Can be called multiple times to append multiple
buffers.</div></blockquote>
<dl class="function">
<dt id="c.__blk_release_queue">
void <code class="descname">__blk_release_queue</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_release_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>release a request queue when it is no longer needed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>pointer to the release_work member of the request queue to be released</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>blk_release_queue is the counterpart of <a class="reference internal" href="#c.blk_init_queue" title="blk_init_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_init_queue()</span></code></a>. It should be
called when a request queue is being released; typically when a block
device is being de-registered. Its primary task it to free the queue
itself.</div></blockquote>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>The low level driver must have finished any outstanding requests first
via <a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a>.</p>
<p>Although <code class="xref c c-func docutils literal"><span class="pre">blk_release_queue()</span></code> may be called with preemption disabled,
<a class="reference internal" href="#c.__blk_release_queue" title="__blk_release_queue"><code class="xref c c-func docutils literal"><span class="pre">__blk_release_queue()</span></code></a> may sleep.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_unregister_queue">
void <code class="descname">blk_unregister_queue</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_unregister_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>counterpart of <code class="xref c c-func docutils literal"><span class="pre">blk_register_queue()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>Disk of which the request queue should be unregistered from sysfs.</dd>
</dl>
<p><strong>Note</strong></p>
<p>the caller is responsible for guaranteeing that this function is called
after <code class="xref c c-func docutils literal"><span class="pre">blk_register_queue()</span></code> has finished.</p>
<dl class="function">
<dt id="c.blk_queue_prep_rq">
void <code class="descname">blk_queue_prep_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, prep_rq_fn *<em>&nbsp;pfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_prep_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>set a prepare_request function for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue</dd>
<dt><code class="docutils literal"><span class="pre">prep_rq_fn</span> <span class="pre">*</span> <span class="pre">pfn</span></code></dt>
<dd>prepare_request function</dd>
</dl>
<p><strong>Description</strong></p>
<p>It&#8217;s possible for a queue to register a prepare_request callback which
is invoked before the request is handed to the request_fn. The goal of
the function is to prepare a request for I/O, it can be used to build a
cdb from the request data for instance.</p>
<dl class="function">
<dt id="c.blk_queue_unprep_rq">
void <code class="descname">blk_queue_unprep_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unprep_rq_fn *<em>&nbsp;ufn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_unprep_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>set an unprepare_request function for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue</dd>
<dt><code class="docutils literal"><span class="pre">unprep_rq_fn</span> <span class="pre">*</span> <span class="pre">ufn</span></code></dt>
<dd>unprepare_request function</dd>
</dl>
<p><strong>Description</strong></p>
<p>It&#8217;s possible for a queue to register an unprepare_request callback
which is invoked before the request is finally completed. The goal
of the function is to deallocate any data that was allocated in the
prepare_request callback.</p>
<dl class="function">
<dt id="c.blk_set_default_limits">
void <code class="descname">blk_set_default_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;lim</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_default_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>reset limits to default values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">lim</span></code></dt>
<dd>the queue_limits structure to reset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a queue_limit struct to its default state.</div></blockquote>
<dl class="function">
<dt id="c.blk_set_stacking_limits">
void <code class="descname">blk_set_stacking_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;lim</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_stacking_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>set default limits for stacking devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">lim</span></code></dt>
<dd>the queue_limits structure to reset</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Returns a queue_limit struct to its default state. Should be used
by stacking drivers like DM that have no internal limits.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_make_request">
void <code class="descname">blk_queue_make_request</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, make_request_fn *<em>&nbsp;mfn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_make_request" title="Permalink to this definition">¶</a></dt>
<dd><p>define an alternate make_request function for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device to be affected</dd>
<dt><code class="docutils literal"><span class="pre">make_request_fn</span> <span class="pre">*</span> <span class="pre">mfn</span></code></dt>
<dd>the alternate make_request function</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The normal way for <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bios</span></code> to be passed to a device
driver is for them to be collected into requests on a request
queue, and then to allow the device driver to select requests
off that queue when it is ready.  This works well for many block
devices. However some block devices (typically virtual devices
such as md or lvm) do not benefit from the processing on the
request queue, and are served best by having the requests passed
directly to them.  This can be achieved by providing a function
to <a class="reference internal" href="#c.blk_queue_make_request" title="blk_queue_make_request"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_make_request()</span></code></a>.</div></blockquote>
<dl class="docutils">
<dt>Caveat:</dt>
<dd>The driver that does this <em>must</em> be able to deal appropriately
with buffers in &#8220;highmemory&#8221;. This can be accomplished by either calling
<code class="xref c c-func docutils literal"><span class="pre">kmap_atomic()</span></code> to get a temporary kernel mapping, or by calling
<code class="xref c c-func docutils literal"><span class="pre">blk_queue_bounce()</span></code> to create a buffer in normal memory.</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_bounce_limit">
void <code class="descname">blk_queue_bounce_limit</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, u64<em>&nbsp;max_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_bounce_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>set bounce buffer limit for queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">max_addr</span></code></dt>
<dd>the maximum address the device can handle</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Different hardware can have different requirements as to what pages
it can do I/O directly to. A low level driver can call
blk_queue_bounce_limit to have lower memory pages allocated as bounce
buffers for doing I/O to pages residing above <strong>max_addr</strong>.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_hw_sectors">
void <code class="descname">blk_queue_max_hw_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_hw_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_hw_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a request for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_hw_sectors</span></code></dt>
<dd>max hardware sectors in the usual 512b unit</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Enables a low level driver to set a hard upper limit,
max_hw_sectors, on the size of requests.  max_hw_sectors is set by
the device driver based upon the capabilities of the I/O
controller.</p>
<p>max_dev_sectors is a hard limit imposed by the storage device for
READ/WRITE requests. It is set by the disk driver.</p>
<p>max_sectors is a soft limit imposed by the block layer for
filesystem type requests.  This value can be overridden on a
per-device basis in /sys/block/&lt;device&gt;/queue/max_sectors_kb.
The soft limit can not exceed max_hw_sectors.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_chunk_sectors">
void <code class="descname">blk_queue_chunk_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;chunk_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_chunk_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set size of the chunk for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">chunk_sectors</span></code></dt>
<dd>chunk sectors in the usual 512b unit</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>If a driver doesn&#8217;t want IOs to cross a given chunk size, it can set
this limit and prevent merging across chunks. Note that the chunk size
must currently be a power-of-2 in sectors. Also note that the block
layer must accept a page worth of data at any offset. So if the
crossing of chunks is a hard limitation in the driver, it must still be
prepared to split single page bios.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_discard_sectors">
void <code class="descname">blk_queue_max_discard_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_discard_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single discard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_discard_sectors</span></code></dt>
<dd>maximum number of sectors to discard</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_write_same_sectors">
void <code class="descname">blk_queue_max_write_same_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_write_same_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_same_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single write same</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_same_sectors</span></code></dt>
<dd>maximum number of sectors to write per command</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_write_zeroes_sectors">
void <code class="descname">blk_queue_max_write_zeroes_sectors</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_write_zeroes_sectors</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_write_zeroes_sectors" title="Permalink to this definition">¶</a></dt>
<dd><p>set max sectors for a single write zeroes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_write_zeroes_sectors</span></code></dt>
<dd>maximum number of sectors to write per command</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_max_segments">
void <code class="descname">blk_queue_max_segments</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;max_segments</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>set max hw segments for a request for this queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt>
<dd>max number of segments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the number of
hw data segments in a request.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_discard_segments">
void <code class="descname">blk_queue_max_discard_segments</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;max_segments</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_discard_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>set max segments for discard requests</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">max_segments</span></code></dt>
<dd>max number of segments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the number of
segments in a discard request.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_max_segment_size">
void <code class="descname">blk_queue_max_segment_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;max_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_max_segment_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set max segment size for blk_rq_map_sg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max_size</span></code></dt>
<dd>max size of segment in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Enables a low level driver to set an upper limit on the size of a
coalesced segment</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_logical_block_size">
void <code class="descname">blk_queue_logical_block_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned short<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_logical_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set logical block size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">size</span></code></dt>
<dd>the logical block size, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This should be set to the lowest possible block size that the
storage device can address.  The default of 512 covers most
hardware.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_physical_block_size">
void <code class="descname">blk_queue_physical_block_size</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_physical_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set physical block size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>the physical block size, in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This should be set to the lowest possible sector size that the
hardware can operate on without reverting to read-modify-write
operations.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_alignment_offset">
void <code class="descname">blk_queue_alignment_offset</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_alignment_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>set physical block alignment offset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>alignment offset in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Some devices are naturally misaligned to compensate for things like
the legacy DOS partition table 63-sector offset.  Low-level drivers
should call this function for devices whose first sector is not
naturally aligned.</div></blockquote>
<dl class="function">
<dt id="c.blk_limits_io_min">
void <code class="descname">blk_limits_io_min</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;limits</em>, unsigned int<em>&nbsp;min</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_min" title="Permalink to this definition">¶</a></dt>
<dd><p>set minimum request size for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">limits</span></code></dt>
<dd>the queue limits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Some devices have an internal block size bigger than the reported
hardware sector size.  This function can be used to signal the
smallest I/O the device can perform without incurring a performance
penalty.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_io_min">
void <code class="descname">blk_queue_io_min</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;min</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_min" title="Permalink to this definition">¶</a></dt>
<dd><p>set minimum request size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report a granularity or preferred minimum I/O
size which is the smallest request the device can perform without
incurring a performance penalty.  For disk drives this is often the
physical block size.  For RAID arrays it is often the stripe chunk
size.  A properly aligned multiple of minimum_io_size is the
preferred request size for workloads where a high number of I/O
operations is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_limits_io_opt">
void <code class="descname">blk_limits_io_opt</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;limits</em>, unsigned int<em>&nbsp;opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_limits_io_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>set optimal request size for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">limits</span></code></dt>
<dd>the queue limits</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt>
<dd>smallest I/O size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report an optimal I/O size, which is the
device&#8217;s preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_io_opt">
void <code class="descname">blk_queue_io_opt</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;opt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_io_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>set optimal request size for the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">opt</span></code></dt>
<dd>optimal request size in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Storage devices may report an optimal I/O size, which is the
device&#8217;s preferred unit for sustained I/O.  This is rarely reported
for disk drives.  For RAID arrays it is usually the stripe width or
the internal track size.  A properly aligned multiple of
optimal_io_size is the preferred request size for workloads where
sustained throughput is desired.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_stack_limits">
void <code class="descname">blk_queue_stack_limits</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;t</em>, struct request_queue *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>inherit underlying queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver (top)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>the underlying device (bottom)</dd>
</dl>
<dl class="function">
<dt id="c.blk_stack_limits">
int <code class="descname">blk_stack_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;t</em>, struct queue_limits *<em>&nbsp;b</em>, sector_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue_limits for stacked devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver limits (top device)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>the underlying queue limits (bottom, component device)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt>
<dd>first data sector within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>This function is used by stacking drivers like MD and DM to ensure
that all component devices have compatible block sizes and
alignments.  The stacking driver must provide a queue_limits
struct (top) and then iteratively call the stacking function for
all component (bottom) devices.  The stacking function will
attempt to combine the values and ensure proper alignment.</p>
<p>Returns 0 if the top and bottom queue_limits are compatible.  The
top device&#8217;s block sizes and alignment offsets may be adjusted to
ensure alignment with the bottom device. If no compatible sizes
and alignments exist, -1 is returned and the resulting top
queue_limits will have the misaligned flag set to indicate that
the alignment_offset is undefined.</p>
</div></blockquote>
<dl class="function">
<dt id="c.bdev_stack_limits">
int <code class="descname">bdev_stack_limits</code><span class="sig-paren">(</span>struct queue_limits *<em>&nbsp;t</em>, struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;start</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdev_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">queue_limits</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>the stacking driver limits (top device)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the component block_device (bottom)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">start</span></code></dt>
<dd>first data sector within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Merges queue limits for a top device and a block_device.  Returns
0 if alignment didn&#8217;t change.  Returns -1 if adding the bottom
device caused misalignment.</div></blockquote>
<dl class="function">
<dt id="c.disk_stack_limits">
void <code class="descname">disk_stack_limits</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_stack_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust queue limits for stacked drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>MD/DM gendisk (top)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the underlying block device (bottom)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">offset</span></code></dt>
<dd>offset to beginning of data within component device</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Merges the limits for a top level gendisk and a bottom level
block_device.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_dma_pad">
void <code class="descname">blk_queue_dma_pad</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>set pad mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>pad mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set dma pad mask.</p>
<p>Appending pad buffer to a request modifies the last entry of a
scatter list such that it includes the pad buffer.</p>
<dl class="function">
<dt id="c.blk_queue_update_dma_pad">
void <code class="descname">blk_queue_update_dma_pad</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>update pad mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>pad mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update dma pad mask.</p>
<p>Appending pad buffer to a request modifies the last entry of a
scatter list such that it includes the pad buffer.</p>
<dl class="function">
<dt id="c.blk_queue_dma_drain">
int <code class="descname">blk_queue_dma_drain</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, dma_drain_needed_fn *<em>&nbsp;dma_drain_needed</em>, void *<em>&nbsp;buf</em>, unsigned int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_drain" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up a drain buffer for excess dma.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">dma_drain_needed_fn</span> <span class="pre">*</span> <span class="pre">dma_drain_needed</span></code></dt>
<dd>fn which returns non-zero if drain is necessary</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>physically contiguous buffer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size</span></code></dt>
<dd>size of the buffer in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some devices have excess DMA problems and can&#8217;t simply discard (or
zero fill) the unwanted piece of the transfer.  They have to have a
real area of memory to transfer it into.  The use case for this is
ATAPI devices in DMA mode.  If the packet command causes a transfer
bigger than the transfer size some HBAs will lock up if there
aren&#8217;t DMA elements to contain the excess transfer.  What this API
does is adjust the queue so that the buf is always appended
silently to the scatterlist.</p>
<p><strong>Note</strong></p>
<p>This routine adjusts max_hw_segments to make room for appending
the drain buffer.  If you call <a class="reference internal" href="#c.blk_queue_max_segments" title="blk_queue_max_segments"><code class="xref c c-func docutils literal"><span class="pre">blk_queue_max_segments()</span></code></a> after calling
this routine, you must set the limit to one fewer than your device
can support otherwise there won&#8217;t be room for the drain buffer.</p>
<dl class="function">
<dt id="c.blk_queue_segment_boundary">
void <code class="descname">blk_queue_segment_boundary</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_segment_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>set boundary rules for segment merging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>the memory boundary mask</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_virt_boundary">
void <code class="descname">blk_queue_virt_boundary</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_virt_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>set boundary rules for bio merging</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>the memory boundary mask</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_dma_alignment">
void <code class="descname">blk_queue_dma_alignment</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_dma_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>set dma length and memory alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>alignment mask</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>set required memory and length alignment for direct dma transactions.
this is used when building direct io requests for the queue.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_update_dma_alignment">
void <code class="descname">blk_queue_update_dma_alignment</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_update_dma_alignment" title="Permalink to this definition">¶</a></dt>
<dd><p>update dma length and memory alignment</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>alignment mask</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>update required memory and length alignment for direct dma transactions.
If the requested alignment is larger than the current alignment, then
the current queue alignment is updated to the new value, otherwise it
is left alone.  The design of this is to allow multiple objects
(driver, device, transport etc) to set their respective
alignments without having them interfere.</div></blockquote>
<dl class="function">
<dt id="c.blk_set_queue_depth">
void <code class="descname">blk_set_queue_depth</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, unsigned int<em>&nbsp;depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_set_queue_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>tell the block layer about the device queue depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>queue depth</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_write_cache">
void <code class="descname">blk_queue_write_cache</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, bool<em>&nbsp;wc</em>, bool<em>&nbsp;fua</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_write_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>configure queue&#8217;s write cache</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">wc</span></code></dt>
<dd>write back cache on or off</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">fua</span></code></dt>
<dd>device supports FUA writes, if true</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tell the block layer about the write cache of <strong>q</strong>.</p>
<dl class="function">
<dt id="c.blk_execute_rq_nowait">
void <code class="descname">blk_execute_rq_nowait</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct gendisk *<em>&nbsp;bd_disk</em>, struct request *<em>&nbsp;rq</em>, int<em>&nbsp;at_head</em>, rq_end_io_fn *<em>&nbsp;done</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_execute_rq_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a request into queue for execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to insert the request in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">bd_disk</span></code></dt>
<dd>matching gendisk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to insert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">at_head</span></code></dt>
<dd>insert request at head or tail of queue</dd>
<dt><code class="docutils literal"><span class="pre">rq_end_io_fn</span> <span class="pre">*</span> <span class="pre">done</span></code></dt>
<dd>I/O completion handler</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Insert a fully prepared request at the back of the I/O scheduler queue
for execution.  Don&#8217;t wait for completion.</div></blockquote>
<p><strong>Note</strong></p>
<blockquote>
<div>This function will invoke <strong>done</strong> directly if the queue is dead.</div></blockquote>
<dl class="function">
<dt id="c.blk_execute_rq">
void <code class="descname">blk_execute_rq</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct gendisk *<em>&nbsp;bd_disk</em>, struct request *<em>&nbsp;rq</em>, int<em>&nbsp;at_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_execute_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a request into queue for execution</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue to insert the request in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">bd_disk</span></code></dt>
<dd>matching gendisk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>request to insert</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">at_head</span></code></dt>
<dd>insert request at head or tail of queue</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Insert a fully prepared request at the back of the I/O scheduler queue
for execution and wait for completion.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_flush">
int <code class="descname">blkdev_issue_flush</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, gfp_t<em>&nbsp;gfp_mask</em>, sector_t *<em>&nbsp;error_sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a flush</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue flush for</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">*</span> <span class="pre">error_sector</span></code></dt>
<dd>error sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a flush for the block device in question. Caller can supply
room for storing the error offset in case of a flush error, if they
wish to.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_discard">
int <code class="descname">blkdev_issue_discard</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_discard" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a discard</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue discard for</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to discard</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>BLKDEV_DISCARD_* flags to control behaviour</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a discard request for the sectors in question.</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_write_same">
int <code class="descname">blkdev_issue_write_same</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct page *<em>&nbsp;page</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_write_same" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a write same operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>target blockdev</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">page</span></code></dt>
<dd>page containing data</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Issue a write same request for the sectors in question.</div></blockquote>
<dl class="function">
<dt id="c.__blkdev_issue_zeroout">
int <code class="descname">__blkdev_issue_zeroout</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, struct bio **<em>&nbsp;biop</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blkdev_issue_zeroout" title="Permalink to this definition">¶</a></dt>
<dd><p>generate number of zero filed write bios</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to issue</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">**</span> <span class="pre">biop</span></code></dt>
<dd>pointer to anchor bio</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt>
<dd>controls detailed behavior</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.</p>
<p>If a device is using logical block provisioning, the underlying space will
not be released if <code class="docutils literal"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOUNMAP.</p>
<p>If <code class="docutils literal"><span class="pre">flags</span></code> contains BLKDEV_ZERO_NOFALLBACK, the function will return
-EOPNOTSUPP if no explicit hardware offload for zeroing is provided.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blkdev_issue_zeroout">
int <code class="descname">blkdev_issue_zeroout</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, sector_t<em>&nbsp;sector</em>, sector_t<em>&nbsp;nr_sects</em>, gfp_t<em>&nbsp;gfp_mask</em>, unsigned<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blkdev_issue_zeroout" title="Permalink to this definition">¶</a></dt>
<dd><p>zero-fill a block range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>blockdev to write</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>start sector</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">nr_sects</span></code></dt>
<dd>number of sectors to write</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>memory allocation flags (for bio_alloc)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt>
<dd>controls detailed behavior</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Zero-fill a block range, either using hardware offload or by explicitly
writing zeroes to the device.  See <a class="reference internal" href="#c.__blkdev_issue_zeroout" title="__blkdev_issue_zeroout"><code class="xref c c-func docutils literal"><span class="pre">__blkdev_issue_zeroout()</span></code></a> for the
valid values for <code class="docutils literal"><span class="pre">flags</span></code>.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_find_tag">
struct request * <code class="descname">blk_queue_find_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_find_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find a request by its tag and queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>The request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">tag</span></code></dt>
<dd>The tag of the request</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><p>Should be used when a device returns a tag and you want to match
it with a request.</p>
<p>no locks need be held.</p>
</div></blockquote>
<dl class="function">
<dt id="c.blk_free_tags">
void <code class="descname">blk_free_tags</code><span class="sig-paren">(</span>struct blk_queue_tag *<em>&nbsp;bqt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release a given set of tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_queue_tag</span> <span class="pre">*</span> <span class="pre">bqt</span></code></dt>
<dd>the tag map to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop the reference count on <strong>bqt</strong> and frees it when the last reference
is dropped.</p>
<dl class="function">
<dt id="c.blk_queue_free_tags">
void <code class="descname">blk_queue_free_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div>This is used to disable tagged queuing to a device, yet leave
queue in function.</div></blockquote>
<dl class="function">
<dt id="c.blk_init_tags">
struct blk_queue_tag * <code class="descname">blk_init_tags</code><span class="sig-paren">(</span>int<em>&nbsp;depth</em>, int<em>&nbsp;alloc_policy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_init_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the tag info for an external tag map</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>the maximum queue depth supported</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">alloc_policy</span></code></dt>
<dd>tag allocation policy</dd>
</dl>
<dl class="function">
<dt id="c.blk_queue_init_tags">
int <code class="descname">blk_queue_init_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;depth</em>, struct blk_queue_tag *<em>&nbsp;tags</em>, int<em>&nbsp;alloc_policy</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_init_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the queue tag info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">depth</span></code></dt>
<dd>the maximum queue depth supported</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_queue_tag</span> <span class="pre">*</span> <span class="pre">tags</span></code></dt>
<dd>the tag to use</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">alloc_policy</span></code></dt>
<dd>tag allocation policy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue lock must be held here if the function is called to resize an
existing map.</p>
<dl class="function">
<dt id="c.blk_queue_resize_tags">
int <code class="descname">blk_queue_resize_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, int<em>&nbsp;new_depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_resize_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>change the queueing depth</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">new_depth</span></code></dt>
<dd>the new max command queueing depth</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div>Must be called with the queue lock held.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_start_tag">
int <code class="descname">blk_queue_start_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_start_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>find a free tag and assign it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the block request that needs tagging</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This can either be used as a stand-alone helper, or possibly be
assigned as the queue <code class="xref c c-type docutils literal"><span class="pre">prep_rq_fn</span></code> (in which case <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code>
automagically gets a tag assigned). Note that this function
assumes that any type of request can be queued! if this is not
true for your device, you must check the request type before
calling this function.  The request will also be removed from
the request queue, so it&#8217;s the drivers responsibility to readd
it if it should need to be restarted for some reason.</div></blockquote>
<dl class="function">
<dt id="c.__blk_queue_free_tags">
void <code class="descname">__blk_queue_free_tags</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__blk_queue_free_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>release tag maintenance info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
</dl>
<p><strong>Notes</strong></p>
<blockquote>
<div><a class="reference internal" href="#c.blk_cleanup_queue" title="blk_cleanup_queue"><code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code></a> will take care of calling this function, if tagging
has been used. So there&#8217;s no need to call this directly.</div></blockquote>
<dl class="function">
<dt id="c.blk_queue_end_tag">
void <code class="descname">blk_queue_end_tag</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_queue_end_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>end tag operations for a request</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue for the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the request that has completed</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Typically called when <code class="xref c c-func docutils literal"><span class="pre">end_that_request_first()</span></code> returns <code class="docutils literal"><span class="pre">0</span></code>, meaning
all transfers have been done for a request. It&#8217;s important to call
this function before <code class="xref c c-func docutils literal"><span class="pre">end_that_request_last()</span></code>, as that will put the
request back on the free list thus corrupting the internal tag list.</div></blockquote>
<dl class="function">
<dt id="c.blk_rq_count_integrity_sg">
int <code class="descname">blk_rq_count_integrity_sg</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_count_integrity_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Count number of integrity scatterlist elements</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio with integrity metadata attached</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the number of elements required in a
scatterlist corresponding to the integrity metadata in a bio.</p>
<dl class="function">
<dt id="c.blk_rq_map_integrity_sg">
int <code class="descname">blk_rq_map_integrity_sg</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, struct scatterlist *<em>&nbsp;sglist</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_rq_map_integrity_sg" title="Permalink to this definition">¶</a></dt>
<dd><p>Map integrity metadata into a scatterlist</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>request queue</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>bio with integrity metadata attached</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">scatterlist</span> <span class="pre">*</span> <span class="pre">sglist</span></code></dt>
<dd>target scatterlist</dd>
</dl>
<p><strong>Description</strong></p>
<p>Map the integrity vectors in request into a
scatterlist.  The scatterlist must be big enough to hold all
elements.  I.e. sized using <a class="reference internal" href="#c.blk_rq_count_integrity_sg" title="blk_rq_count_integrity_sg"><code class="xref c c-func docutils literal"><span class="pre">blk_rq_count_integrity_sg()</span></code></a>.</p>
<dl class="function">
<dt id="c.blk_integrity_compare">
int <code class="descname">blk_integrity_compare</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;gd1</em>, struct gendisk *<em>&nbsp;gd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare integrity profile of two disks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">gd1</span></code></dt>
<dd>Disk to compare</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">gd2</span></code></dt>
<dd>Disk to compare</dd>
</dl>
<p><strong>Description</strong></p>
<p>Meta-devices like DM and MD need to verify that all
sub-devices use the same integrity format before advertising to
upper layers that they can send/receive integrity metadata.  This
function can be used to check whether two gendisk devices have
compatible integrity formats.</p>
<dl class="function">
<dt id="c.blk_integrity_register">
void <code class="descname">blk_integrity_register</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct blk_integrity *<em>&nbsp;template</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a gendisk as being integrity-capable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>struct gendisk pointer to make integrity-aware</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">blk_integrity</span> <span class="pre">*</span> <span class="pre">template</span></code></dt>
<dd>block integrity profile to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device needs to advertise itself as being able to
send/receive integrity metadata it must use this function to register
the capability with the block layer. The template is a blk_integrity
struct with values appropriate for the underlying hardware. See
Documentation/block/data-integrity.txt.</p>
<dl class="function">
<dt id="c.blk_integrity_unregister">
void <code class="descname">blk_integrity_unregister</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_integrity_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister block integrity profile</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk whose integrity profile to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters the integrity capability from
a block device.</p>
<dl class="function">
<dt id="c.blk_trace_ioctl">
int <code class="descname">blk_trace_ioctl</code><span class="sig-paren">(</span>struct block_device *<em>&nbsp;bdev</em>, unsigned<em>&nbsp;cmd</em>, char __user *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>handle the ioctls associated with tracing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device</span> <span class="pre">*</span> <span class="pre">bdev</span></code></dt>
<dd>the block device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">cmd</span></code></dt>
<dd>the ioctl cmd</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>the argument data, if any</dd>
</dl>
<dl class="function">
<dt id="c.blk_trace_shutdown">
void <code class="descname">blk_trace_shutdown</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_trace_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>stop and cleanup trace structures</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>the request queue associated with the device</dd>
</dl>
<dl class="function">
<dt id="c.blk_add_trace_rq">
void <code class="descname">blk_add_trace_rq</code><span class="sig-paren">(</span>struct request *<em>&nbsp;rq</em>, int<em>&nbsp;error</em>, unsigned int<em>&nbsp;nr_bytes</em>, u32<em>&nbsp;what</em>, union kernfs_node_id *<em>&nbsp;cgid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a request oriented action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the source request</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">error</span></code></dt>
<dd>return status to log</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_bytes</span></code></dt>
<dd>number of completed bytes</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">what</span></code></dt>
<dd>the action</dd>
<dt><code class="docutils literal"><span class="pre">union</span> <span class="pre">kernfs_node_id</span> <span class="pre">*</span> <span class="pre">cgid</span></code></dt>
<dd>the cgroup info</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Records an action against a request. Will log the bio offset + size.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_bio">
void <code class="descname">blk_add_trace_bio</code><span class="sig-paren">(</span>struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, u32<em>&nbsp;what</em>, int<em>&nbsp;error</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a bio oriented action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>the source bio</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">what</span></code></dt>
<dd>the action</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">error</span></code></dt>
<dd>error, if any</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Records an action against a bio. Will log the bio offset + size.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_bio_remap">
void <code class="descname">blk_add_trace_bio_remap</code><span class="sig-paren">(</span>void *<em>&nbsp;ignore</em>, struct request_queue *<em>&nbsp;q</em>, struct bio *<em>&nbsp;bio</em>, dev_t<em>&nbsp;dev</em>, sector_t<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_bio_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a bio-remap operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ignore</span></code></dt>
<dd>trace callback data parameter (not used)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span> <span class="pre">*</span> <span class="pre">bio</span></code></dt>
<dd>the source bio</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>target device</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt>
<dd>source sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Device mapper or raid target sometimes need to split a bio because
it spans a stripe (or similar). Add a trace for that action.</div></blockquote>
<dl class="function">
<dt id="c.blk_add_trace_rq_remap">
void <code class="descname">blk_add_trace_rq_remap</code><span class="sig-paren">(</span>void *<em>&nbsp;ignore</em>, struct request_queue *<em>&nbsp;q</em>, struct request *<em>&nbsp;rq</em>, dev_t<em>&nbsp;dev</em>, sector_t<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_add_trace_rq_remap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a trace for a request-remap operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">ignore</span></code></dt>
<dd>trace callback data parameter (not used)</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>queue the io is for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">request</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>the source request</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>target device</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">from</span></code></dt>
<dd>source sector</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Device mapper remaps request to other devices.
Add a trace for that action.</div></blockquote>
<dl class="function">
<dt id="c.blk_mangle_minor">
int <code class="descname">blk_mangle_minor</code><span class="sig-paren">(</span>int<em>&nbsp;minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_mangle_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>scatter minor numbers apart</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">minor</span></code></dt>
<dd>minor number to mangle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scatter consecutively allocated <strong>minor</strong> number apart if MANGLE_DEVT
is enabled.  Mangling twice gives the original value.</p>
<p><strong>Return</strong></p>
<p>Mangled value.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<dl class="function">
<dt id="c.blk_alloc_devt">
int <code class="descname">blk_alloc_devt</code><span class="sig-paren">(</span>struct hd_struct *<em>&nbsp;part</em>, dev_t *<em>&nbsp;devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_alloc_devt" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a dev_t for a partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hd_struct</span> <span class="pre">*</span> <span class="pre">part</span></code></dt>
<dd>partition to allocate dev_t for</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">devt</span></code></dt>
<dd>out parameter for resulting dev_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a dev_t for block device.</p>
<p><strong>Return</strong></p>
<p>0 on success, allocated dev_t is returned in <strong>*devt</strong>.  -errno on
failure.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.blk_free_devt">
void <code class="descname">blk_free_devt</code><span class="sig-paren">(</span>dev_t<em>&nbsp;devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.blk_free_devt" title="Permalink to this definition">¶</a></dt>
<dd><p>free a dev_t</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>dev_t to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free <strong>devt</strong> which was allocated using <a class="reference internal" href="#c.blk_alloc_devt" title="blk_alloc_devt"><code class="xref c c-func docutils literal"><span class="pre">blk_alloc_devt()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.__device_add_disk">
void <code class="descname">__device_add_disk</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;parent</em>, struct gendisk *<em>&nbsp;disk</em>, bool<em>&nbsp;register_queue</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__device_add_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>add disk information to kernel list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device for the disk</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>per-device partitioning information</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">register_queue</span></code></dt>
<dd>register the queue if set to true</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function registers the partitioning information in <strong>disk</strong>
with the kernel.</p>
<p>FIXME: error handling</p>
<dl class="function">
<dt id="c.disk_replace_part_tbl">
void <code class="descname">disk_replace_part_tbl</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, struct disk_part_tbl *<em>&nbsp;new_ptbl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_replace_part_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>replace disk-&gt;part_tbl in RCU-safe way</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to replace part_tbl for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_tbl</span> <span class="pre">*</span> <span class="pre">new_ptbl</span></code></dt>
<dd>new part_tbl to install</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace disk-&gt;part_tbl with <strong>new_ptbl</strong> in RCU-safe way.  The
original ptbl is freed using RCU callback.</p>
<p>LOCKING:
Matching bd_mutex locked or the caller is the only user of <strong>disk</strong>.</p>
<dl class="function">
<dt id="c.disk_expand_part_tbl">
int <code class="descname">disk_expand_part_tbl</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_expand_part_tbl" title="Permalink to this definition">¶</a></dt>
<dd><p>expand disk-&gt;part_tbl</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to expand part_tbl for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>expand such that this partno can fit in</dd>
</dl>
<p><strong>Description</strong></p>
<p>Expand disk-&gt;part_tbl such that <strong>partno</strong> can fit in.  disk-&gt;part_tbl
uses RCU to allow unlocked dereferencing for stats and other stuff.</p>
<p>LOCKING:
Matching bd_mutex locked or the caller is the only user of <strong>disk</strong>.
Might sleep.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.disk_block_events">
void <code class="descname">disk_block_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_block_events" title="Permalink to this definition">¶</a></dt>
<dd><p>block and flush disk event checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to block events for</dd>
</dl>
<p><strong>Description</strong></p>
<p>On return from this function, it is guaranteed that event checking
isn&#8217;t in progress and won&#8217;t happen until unblocked by
<a class="reference internal" href="#c.disk_unblock_events" title="disk_unblock_events"><code class="xref c c-func docutils literal"><span class="pre">disk_unblock_events()</span></code></a>.  Events blocking is counted and the actual
unblocking happens after the matching number of unblocks are done.</p>
<p>Note that this intentionally does not block event checking from
<a class="reference internal" href="#c.disk_clear_events" title="disk_clear_events"><code class="xref c c-func docutils literal"><span class="pre">disk_clear_events()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_unblock_events">
void <code class="descname">disk_unblock_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_unblock_events" title="Permalink to this definition">¶</a></dt>
<dd><p>unblock disk event checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to unblock events for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo <a class="reference internal" href="#c.disk_block_events" title="disk_block_events"><code class="xref c c-func docutils literal"><span class="pre">disk_block_events()</span></code></a>.  When the block count reaches zero, it
starts events polling if configured.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.  Safe to call from irq context.</p>
<dl class="function">
<dt id="c.disk_flush_events">
void <code class="descname">disk_flush_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_flush_events" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule immediate event checking and flushing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to check and flush events for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>events to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>Schedule immediate event checking on <strong>disk</strong> if not blocked.  Events in
<strong>mask</strong> are scheduled to be cleared from the driver.  Note that this
doesn&#8217;t clear the events from <strong>disk</strong>-&gt;ev.</p>
<p><strong>Context</strong></p>
<p>If <strong>mask</strong> is non-zero must be called with bdev-&gt;bd_mutex held.</p>
<dl class="function">
<dt id="c.disk_clear_events">
unsigned int <code class="descname">disk_clear_events</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_clear_events" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronously check, clear and return pending events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to fetch and clear events from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mask</span></code></dt>
<dd>mask of events to be fetched and cleared</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disk events are synchronously checked and pending events in <strong>mask</strong>
are cleared and returned.  This ignores the block count.</p>
<p><strong>Context</strong></p>
<p>Might sleep.</p>
<dl class="function">
<dt id="c.disk_get_part">
struct hd_struct * <code class="descname">disk_get_part</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_get_part" title="Permalink to this definition">¶</a></dt>
<dd><p>get partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to look partition from</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>partition number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look for partition <strong>partno</strong> from <strong>disk</strong>.  If found, increment
reference count and return it.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<p><strong>Return</strong></p>
<p>Pointer to the found partition on success, NULL if not found.</p>
<dl class="function">
<dt id="c.disk_part_iter_init">
void <code class="descname">disk_part_iter_init</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em>, struct gendisk *<em>&nbsp;disk</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize partition iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iterator to initialize</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>disk to iterate over</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>DISK_PITER_* flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize <strong>piter</strong> so that it iterates over partitions of <strong>disk</strong>.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<dl class="function">
<dt id="c.disk_part_iter_next">
struct hd_struct * <code class="descname">disk_part_iter_next</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>proceed iterator to the next partition and return it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iterator of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>piter</strong> to the next partition and return it.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<dl class="function">
<dt id="c.disk_part_iter_exit">
void <code class="descname">disk_part_iter_exit</code><span class="sig-paren">(</span>struct disk_part_iter *<em>&nbsp;piter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_part_iter_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>finish up partition iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">disk_part_iter</span> <span class="pre">*</span> <span class="pre">piter</span></code></dt>
<dd>iter of interest</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called when iteration is over.  Cleans up <strong>piter</strong>.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<dl class="function">
<dt id="c.disk_map_sector_rcu">
struct hd_struct * <code class="descname">disk_map_sector_rcu</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, sector_t<em>&nbsp;sector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.disk_map_sector_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>map sector to partition</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>gendisk of interest</dd>
<dt><code class="docutils literal"><span class="pre">sector_t</span> <span class="pre">sector</span></code></dt>
<dd>sector to map</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find out which partition <strong>sector</strong> maps to on <strong>disk</strong>.  This is
primarily used for stats accounting.</p>
<p><strong>Context</strong></p>
<p>RCU read locked.  The returned partition pointer is valid only
while preemption is disabled.</p>
<p><strong>Return</strong></p>
<p>Found partition on success, part0 is returned if no partition matches</p>
<dl class="function">
<dt id="c.register_blkdev">
int <code class="descname">register_blkdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_blkdev" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new block device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>the requested major device number [1..BLKDEV_MAJOR_MAX-1]. If
<strong>major</strong> = 0, try to allocate any unused major number.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the new block device as a zero terminated string</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>name</strong> must be unique within the system.</p>
<p>The return value depends on the <strong>major</strong> input parameter:</p>
<blockquote>
<div><ul class="simple">
<li>if a major device number was requested in range [1..BLKDEV_MAJOR_MAX-1]
then the function returns zero on success, or a negative error code</li>
<li>if any unused major number was requested with <strong>major</strong> = 0 parameter
then the return value is the allocated major number in range
[1..BLKDEV_MAJOR_MAX-1] or a negative error code otherwise</li>
</ul>
</div></blockquote>
<p>See Documentation/admin-guide/devices.txt for the list of allocated
major numbers.</p>
<dl class="function">
<dt id="c.get_gendisk">
struct gendisk * <code class="descname">get_gendisk</code><span class="sig-paren">(</span>dev_t<em>&nbsp;devt</em>, int *<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_gendisk" title="Permalink to this definition">¶</a></dt>
<dd><p>get partitioning information for a given device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>device to get partitioning information for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">partno</span></code></dt>
<dd>returned partition index</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function gets the structure containing partitioning
information for the given device <strong>devt</strong>.</p>
<dl class="function">
<dt id="c.bdget_disk">
struct block_device * <code class="descname">bdget_disk</code><span class="sig-paren">(</span>struct gendisk *<em>&nbsp;disk</em>, int<em>&nbsp;partno</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bdget_disk" title="Permalink to this definition">¶</a></dt>
<dd><p>do <code class="xref c c-func docutils literal"><span class="pre">bdget()</span></code> by gendisk and partition number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span> <span class="pre">*</span> <span class="pre">disk</span></code></dt>
<dd>gendisk of interest</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">partno</span></code></dt>
<dd>partition number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find partition <strong>partno</strong> from <strong>disk</strong>, do <code class="xref c c-func docutils literal"><span class="pre">bdget()</span></code> on it.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t care.</p>
<p><strong>Return</strong></p>
<p>Resulting block_device on success, NULL on failure.</p>
</div>
<div class="section" id="char-devices">
<h2>Char devices<a class="headerlink" href="#char-devices" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.register_chrdev_region">
int <code class="descname">register_chrdev_region</code><span class="sig-paren">(</span>dev_t<em>&nbsp;from</em>, unsigned<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>register a range of device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt>
<dd>the first in the desired range of device numbers; must include
the major number.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of consecutive device numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the device or driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return value is zero on success, a negative error code on failure.</p>
<dl class="function">
<dt id="c.alloc_chrdev_region">
int <code class="descname">alloc_chrdev_region</code><span class="sig-paren">(</span>dev_t *<em>&nbsp;dev</em>, unsigned<em>&nbsp;baseminor</em>, unsigned<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>register a range of char device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>output parameter for first assigned number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the requested range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the associated device or driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates a range of char device numbers.  The major number will be
chosen dynamically, and returned (along with the first minor number)
in <strong>dev</strong>.  Returns zero or a negative error code.</p>
<dl class="function">
<dt id="c.__register_chrdev">
int <code class="descname">__register_chrdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, unsigned int<em>&nbsp;baseminor</em>, unsigned int<em>&nbsp;count</em>, const char *<em>&nbsp;name</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__register_chrdev" title="Permalink to this definition">¶</a></dt>
<dd><p>create and register a cdev occupying a range of minors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major device number or 0 for dynamic allocation</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the requested range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers required</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of this range of devices</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>file operations associated with this devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>major</strong> == 0 this functions will dynamically allocate a major and return
its number.</p>
<p>If <strong>major</strong> &gt; 0 this function will attempt to reserve a device with the given
major number and will return zero on success.</p>
<p>Returns a -ve errno on failure.</p>
<p>The name of this device has nothing to do with the name of the device in
/dev. It only helps to keep track of the different owners of devices. If
your module name has only one type of devices it&#8217;s ok to use e.g. the name
of the module here.</p>
<dl class="function">
<dt id="c.unregister_chrdev_region">
void <code class="descname">unregister_chrdev_region</code><span class="sig-paren">(</span>dev_t<em>&nbsp;from</em>, unsigned<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_chrdev_region" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a range of device numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">from</span></code></dt>
<dd>the first in the range of numbers to unregister</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of device numbers to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will unregister a range of <strong>count</strong> device numbers,
starting with <strong>from</strong>.  The caller should normally be the one who
allocated those numbers in the first place...</p>
<dl class="function">
<dt id="c.__unregister_chrdev">
void <code class="descname">__unregister_chrdev</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;major</em>, unsigned int<em>&nbsp;baseminor</em>, unsigned int<em>&nbsp;count</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__unregister_chrdev" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister and destroy a cdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">major</span></code></dt>
<dd>major device number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">baseminor</span></code></dt>
<dd>first of the range of minor numbers</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of minor numbers this cdev is occupying</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of this range of devices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister and destroy the cdev occupying the region described by
<strong>major</strong>, <strong>baseminor</strong> and <strong>count</strong>.  This function undoes what
<a class="reference internal" href="#c.__register_chrdev" title="__register_chrdev"><code class="xref c c-func docutils literal"><span class="pre">__register_chrdev()</span></code></a> did.</p>
<dl class="function">
<dt id="c.cdev_add">
int <code class="descname">cdev_add</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em>, dev_t<em>&nbsp;dev</em>, unsigned<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a char device to the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure for the device</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">dev</span></code></dt>
<dd>the first device number for which this device is responsible</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>the number of consecutive minor numbers corresponding to this
device</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_add()</span></code></a> adds the device represented by <strong>p</strong> to the system, making it
live immediately.  A negative error code is returned on failure.</p>
<dl class="function">
<dt id="c.cdev_set_parent">
void <code class="descname">cdev_set_parent</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em>, struct kobject *<em>&nbsp;kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>set the parent kobject for a char device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>the kobject to take a reference to</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_set_parent" title="cdev_set_parent"><code class="xref c c-func docutils literal"><span class="pre">cdev_set_parent()</span></code></a> sets a parent kobject which will be referenced
appropriately so the parent is not freed before the cdev. This
should be called before cdev_add.</p>
<dl class="function">
<dt id="c.cdev_device_add">
int <code class="descname">cdev_device_add</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a char device and it&#8217;s corresponding struct device, linkink</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_add" title="cdev_device_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_device_add()</span></code></a> adds the char device represented by <strong>cdev</strong> to the system,
just as cdev_add does. It then adds <strong>dev</strong> to the system using device_add
The dev_t for the char device will be taken from the struct device which
needs to be initialized first. This helper function correctly takes a
reference to the parent device so the parent will not get released until
all references to the cdev are released.</p>
<p>This helper uses dev-&gt;devt for the device number. If it is not set
it will not add the cdev and it will be equivalent to device_add.</p>
<p>This function should be used whenever the struct cdev and the
struct device are members of the same structure whose lifetime is
managed by the struct device.</p>
<p><strong>NOTE</strong></p>
<p>Callers must assume that userspace was able to open the cdev and
can call cdev fops callbacks at any time, even if this function fails.</p>
<dl class="function">
<dt id="c.cdev_device_del">
void <code class="descname">cdev_device_del</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_device_del" title="Permalink to this definition">¶</a></dt>
<dd><p>inverse of cdev_device_add</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the cdev structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_device_del" title="cdev_device_del"><code class="xref c c-func docutils literal"><span class="pre">cdev_device_del()</span></code></a> is a helper function to call cdev_del and device_del.
It should be used whenever cdev_device_add is used.</p>
<p>If dev-&gt;devt is not set it will not remove the cdev and will be equivalent
to device_del.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that associated sysfs callbacks are not running
or runnable, however any cdevs already open will remain and their fops
will still be callable even after this function returns.</p>
<dl class="function">
<dt id="c.cdev_del">
void <code class="descname">cdev_del</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_del" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a cdev from the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the cdev structure to be removed</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.cdev_del" title="cdev_del"><code class="xref c c-func docutils literal"><span class="pre">cdev_del()</span></code></a> removes <strong>p</strong> from the system, possibly freeing the structure
itself.</p>
<p><strong>NOTE</strong></p>
<p>This guarantees that cdev device will no longer be able to be
opened, however any cdevs already open will remain and their fops will
still be callable even after cdev_del returns.</p>
<dl class="function">
<dt id="c.cdev_alloc">
struct cdev * <code class="descname">cdev_alloc</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a cdev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and returns a cdev structure, or NULL on failure.</p>
<dl class="function">
<dt id="c.cdev_init">
void <code class="descname">cdev_init</code><span class="sig-paren">(</span>struct cdev *<em>&nbsp;cdev</em>, const struct file_operations *<em>&nbsp;fops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cdev_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a cdev structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span> <span class="pre">*</span> <span class="pre">cdev</span></code></dt>
<dd>the structure to initialize</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">file_operations</span> <span class="pre">*</span> <span class="pre">fops</span></code></dt>
<dd>the file_operations for this device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes <strong>cdev</strong>, remembering <strong>fops</strong>, making it ready to add to the
system with <a class="reference internal" href="#c.cdev_add" title="cdev_add"><code class="xref c c-func docutils literal"><span class="pre">cdev_add()</span></code></a>.</p>
</div>
<div class="section" id="clock-framework">
<h2>Clock Framework<a class="headerlink" href="#clock-framework" title="Permalink to this headline">¶</a></h2>
<p>The clock framework defines programming interfaces to support software
management of the system clock tree. This framework is widely used with
System-On-Chip (SOC) platforms to support power management and various
devices which may need custom clock rates. Note that these &#8220;clocks&#8221;
don&#8217;t relate to timekeeping or real time clocks (RTCs), each of which
have separate frameworks. These <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">clk</span></code>
instances may be used to manage for example a 96 MHz signal that is used
to shift bits into and out of peripherals or busses, or otherwise
trigger synchronous state machine transitions in system hardware.</p>
<p>Power management is supported by explicit software clock gating: unused
clocks are disabled, so the system doesn&#8217;t waste power changing the
state of transistors that aren&#8217;t in active use. On some systems this may
be backed by hardware clock gating, where clocks are gated without being
disabled in software. Sections of chips that are powered but not clocked
may be able to retain their last state. This low power state is often
called a <em>retention mode</em>. This mode still incurs leakage currents,
especially with finer circuit geometries, but for CMOS circuits power is
mostly used by clocked state changes.</p>
<p>Power-aware drivers only enable their clocks when the device they manage
is in active use. Also, system sleep states often differ according to
which clock domains are active: while a &#8220;standby&#8221; state may allow wakeup
from several active domains, a &#8220;mem&#8221; (suspend-to-RAM) state may require
a more wholesale shutdown of clocks derived from higher speed PLLs and
oscillators, limiting the number of possible wakeup event sources. A
driver&#8217;s suspend method may need to be aware of system-specific clock
constraints on the target sleep state.</p>
<p>Some platforms support programmable clock generators. These can be used
by external chips of various kinds, such as other CPUs, multimedia
codecs, and devices with strict requirements for interface clocking.</p>
<dl class="type">
<dt id="c.clk_notifier">
struct <code class="descname">clk_notifier</code><a class="headerlink" href="#c.clk_notifier" title="Permalink to this definition">¶</a></dt>
<dd><p>associate a clk with a notifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct clk_notifier {
  struct clk                      *clk;
  struct srcu_notifier_head       notifier_head;
  struct list_head                node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * to associate the notifier with</dd>
<dt><code class="docutils literal"><span class="pre">notifier_head</span></code></dt>
<dd>a blocking_notifier_head for this clk</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>linked list pointers</dd>
</dl>
<p><strong>Description</strong></p>
<p>A list of struct clk_notifier is maintained by the notifier code.
An entry is created whenever code registers the first notifier on a
particular <strong>clk</strong>.  Future notifiers on that <strong>clk</strong> are added to the
<strong>notifier_head</strong>.</p>
<dl class="type">
<dt id="c.clk_notifier_data">
struct <code class="descname">clk_notifier_data</code><a class="headerlink" href="#c.clk_notifier_data" title="Permalink to this definition">¶</a></dt>
<dd><p>rate data to pass to the notifier callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct clk_notifier_data {
  struct clk              *clk;
  unsigned long           old_rate;
  unsigned long           new_rate;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * being changed</dd>
<dt><code class="docutils literal"><span class="pre">old_rate</span></code></dt>
<dd>previous rate of this clk</dd>
<dt><code class="docutils literal"><span class="pre">new_rate</span></code></dt>
<dd>new rate of this clk</dd>
</dl>
<p><strong>Description</strong></p>
<p>For a pre-notifier, old_rate is the clk&#8217;s rate before this rate
change, and new_rate is what the rate will be in the future.  For a
post-notifier, old_rate and new_rate are both set to the clk&#8217;s
current rate (this was done to optimize the implementation).</p>
<dl class="type">
<dt id="c.clk_bulk_data">
struct <code class="descname">clk_bulk_data</code><a class="headerlink" href="#c.clk_bulk_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Data used for bulk clk operations.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct clk_bulk_data {
  const char              *id;
  struct clk              *clk;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
<dt><code class="docutils literal"><span class="pre">clk</span></code></dt>
<dd>struct clk * to store the associated clock</dd>
</dl>
<p><strong>Description</strong></p>
<p>The CLK APIs provide a series of <code class="xref c c-func docutils literal"><span class="pre">clk_bulk_()</span></code> API calls as
a convenience to consumers which require multiple clks.  This
structure is used to manage data for these calls.</p>
<dl class="function">
<dt id="c.clk_notifier_register">
int <code class="descname">clk_notifier_register</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>change notifier callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock whose rate we are interested in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>notifier block with callback function pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>ProTip: debugging across notifier chains can be frustrating. Make sure that
your notifier callback function prints a nice big warning in case of
failure.</p>
<dl class="function">
<dt id="c.clk_notifier_unregister">
int <code class="descname">clk_notifier_unregister</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct notifier_block *<em>&nbsp;nb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>change notifier callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock whose rate we are no longer interested in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">notifier_block</span> <span class="pre">*</span> <span class="pre">nb</span></code></dt>
<dd>notifier block which will be unregistered</dd>
</dl>
<dl class="function">
<dt id="c.clk_get_accuracy">
long <code class="descname">clk_get_accuracy</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the clock accuracy in ppb (parts per billion) for a clock source.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This gets the clock source accuracy expressed in ppb.
A perfect clock returns 0.</p>
<dl class="function">
<dt id="c.clk_set_phase">
int <code class="descname">clk_set_phase</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, int<em>&nbsp;degrees</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the phase shift of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock signal source</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">degrees</span></code></dt>
<dd>number of degrees the signal is shifted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shifts the phase of a clock signal by the specified degrees. Returns 0 on
success, -EERROR otherwise.</p>
<dl class="function">
<dt id="c.clk_get_phase">
int <code class="descname">clk_get_phase</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>return the phase shift of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock signal source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the phase shift of a clock node in degrees, otherwise returns
-EERROR.</p>
<dl class="function">
<dt id="c.clk_set_duty_cycle">
int <code class="descname">clk_set_duty_cycle</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned int<em>&nbsp;num</em>, unsigned int<em>&nbsp;den</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_duty_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust the duty cycle ratio of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock signal source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>numerator of the duty cycle ratio to be applied</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">den</span></code></dt>
<dd>denominator of the duty cycle ratio to be applied</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adjust the duty cycle of a clock signal by the specified ratio. Returns 0 on
success, -EERROR otherwise.</p>
<dl class="function">
<dt id="c.clk_get_scaled_duty_cycle">
int <code class="descname">clk_get_scaled_duty_cycle</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned int<em>&nbsp;scale</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_scaled_duty_cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>return the duty cycle ratio of a clock signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock signal source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">scale</span></code></dt>
<dd>scaling factor to be applied to represent the ratio as an integer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the duty cycle ratio multiplied by the scale provided, otherwise
returns -EERROR.</p>
<dl class="function">
<dt id="c.clk_is_match">
bool <code class="descname">clk_is_match</code><span class="sig-paren">(</span>const struct clk *<em>&nbsp;p</em>, const struct clk *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_is_match" title="Permalink to this definition">¶</a></dt>
<dd><p>check if two clk&#8217;s point to the same hardware clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>clk compared against q</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>clk compared against p</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the two struct clk pointers both point to the same hardware
clock node. Put differently, returns true if <strong>p</strong> and <strong>q</strong>
share the same <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">clk_core</span></code> object.</p>
<p>Returns false otherwise. Note that two NULL clks are treated as matching.</p>
<dl class="function">
<dt id="c.clk_prepare">
int <code class="descname">clk_prepare</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>prepare a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the clock source for use.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_unprepare">
void <code class="descname">clk_unprepare</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_unprepare" title="Permalink to this definition">¶</a></dt>
<dd><p>undo preparation of a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This undoes a previously prepared clock.  The caller must balance
the number of prepare and unprepare calls.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_get">
struct clk * <code class="descname">clk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a reference to a clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_get">
int <code class="descname">clk_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a number of references to clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to get several clk consumers in one
operation. If any of the clk cannot be acquired then any clks
that were obtained will be freed before returning to the caller.</p>
<p>Returns 0 if all clocks specified in clk_bulk_data table are obtained
successfully, or valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.
The implementation uses <strong>dev</strong> and <strong>clk_bulk_data.id</strong> to determine the
clock consumer, and thereby the clock producer.
The clock returned is stored in each <strong>clk_bulk_data.clk</strong> field.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_bulk_get should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.devm_clk_bulk_get">
int <code class="descname">devm_clk_bulk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_bulk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>managed get multiple clk consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, an errno on failure.</p>
<p>This helper function allows drivers to get several clk
consumers in one operation with management, the clks will
automatically be freed when the device is unbound.</p>
<dl class="function">
<dt id="c.devm_clk_get">
struct clk * <code class="descname">devm_clk_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_get" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to a clock producer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev</strong> and <strong>id</strong> to determine the clock consumer, and thereby
the clock producer.  (IOW, <strong>id</strong> may be identical strings, but
clk_get may return different clock producers depending on <strong>dev</strong>.)</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>devm_clk_get should not be called from within interrupt context.</p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
<dl class="function">
<dt id="c.devm_get_clk_from_child">
struct clk * <code class="descname">devm_get_clk_from_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct device_node *<em>&nbsp;np</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_clk_from_child" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup and obtain a managed reference to a clock producer from child node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for clock &#8220;consumer&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>pointer to clock consumer node</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>clock consumer ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function parses the clocks, and uses them to look up the
struct clk from the registered list of clock providers by using
<strong>np</strong> and <strong>con_id</strong></p>
<p>The clock will automatically be freed when the device is unbound
from the bus.</p>
<dl class="function">
<dt id="c.clk_rate_exclusive_get">
int <code class="descname">clk_rate_exclusive_get</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_rate_exclusive_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get exclusivity over the rate control of a producer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows drivers to get exclusive control over the rate of a
provider. It prevents any other consumer to execute, even indirectly,
opereation which could alter the rate of the provider or cause glitches</p>
<p>If exlusivity is claimed more than once on clock, even by the same driver,
the rate effectively gets locked as exclusivity can&#8217;t be preempted.</p>
<p>Must not be called from within atomic context.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_rate_exclusive_put">
void <code class="descname">clk_rate_exclusive_put</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_rate_exclusive_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release exclusivity over the rate control of a producer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allows drivers to release the exclusivity it previously got
from <a class="reference internal" href="#c.clk_rate_exclusive_get" title="clk_rate_exclusive_get"><code class="xref c c-func docutils literal"><span class="pre">clk_rate_exclusive_get()</span></code></a></p>
<p>The caller must balance the number of <a class="reference internal" href="#c.clk_rate_exclusive_get" title="clk_rate_exclusive_get"><code class="xref c c-func docutils literal"><span class="pre">clk_rate_exclusive_get()</span></code></a> and
<a class="reference internal" href="#c.clk_rate_exclusive_put" title="clk_rate_exclusive_put"><code class="xref c c-func docutils literal"><span class="pre">clk_rate_exclusive_put()</span></code></a> calls.</p>
<p>Must not be called from within atomic context.</p>
<dl class="function">
<dt id="c.clk_enable">
int <code class="descname">clk_enable</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the clock source should be running.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the clock can not be enabled/disabled, this should return success.</p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_bulk_enable">
int <code class="descname">clk_bulk_enable</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, const struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_enable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the set of clks should be running.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>May be called from atomic contexts.</p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_disable">
void <code class="descname">clk_disable</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the clock source is no longer required.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a clock source is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the clock source is shared between
multiple drivers, <a class="reference internal" href="#c.clk_enable" title="clk_enable"><code class="xref c c-func docutils literal"><span class="pre">clk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_disable" title="clk_disable"><code class="xref c c-func docutils literal"><span class="pre">clk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
<dl class="function">
<dt id="c.clk_bulk_disable">
void <code class="descname">clk_bulk_disable</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, const struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>inform the system when the set of clks is no longer required.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inform the system that a set of clks is no longer required by
a driver and may be shut down.</p>
<p>May be called from atomic contexts.</p>
<p>Implementation detail: if the set of clks is shared between
multiple drivers, <a class="reference internal" href="#c.clk_bulk_enable" title="clk_bulk_enable"><code class="xref c c-func docutils literal"><span class="pre">clk_bulk_enable()</span></code></a> calls must be balanced by the
same number of <a class="reference internal" href="#c.clk_bulk_disable" title="clk_bulk_disable"><code class="xref c c-func docutils literal"><span class="pre">clk_bulk_disable()</span></code></a> calls for the clock source to be
disabled.</p>
<dl class="function">
<dt id="c.clk_get_rate">
unsigned long <code class="descname">clk_get_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>obtain the current clock rate (in Hz) for a clock source. This is only valid once the clock source has been enabled.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<dl class="function">
<dt id="c.clk_put">
void <code class="descname">clk_put</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;free&#8221; the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p>clk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_bulk_put">
void <code class="descname">clk_bulk_put</code><span class="sig-paren">(</span>int<em>&nbsp;num_clks</em>, struct <a class="reference internal" href="#c.clk_bulk_data" title="clk_bulk_data">clk_bulk_data</a> *<em>&nbsp;clks</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_bulk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;free&#8221; the clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_clks</span></code></dt>
<dd>the number of clk_bulk_data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk_bulk_data</span> <span class="pre">*</span> <span class="pre">clks</span></code></dt>
<dd>the clk_bulk_data table of consumer</dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_bulk_enable calls made on this
clock source are balanced by clk_bulk_disable calls prior to calling
this function.</p>
<p>clk_bulk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.devm_clk_put">
void <code class="descname">devm_clk_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_clk_put" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;free&#8221; a managed clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device used to acquire the clock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source acquired with <a class="reference internal" href="#c.devm_clk_get" title="devm_clk_get"><code class="xref c c-func docutils literal"><span class="pre">devm_clk_get()</span></code></a></dd>
</dl>
<p><strong>Note</strong></p>
<p>drivers must ensure that all clk_enable calls made on this
clock source are balanced by clk_disable calls prior to calling
this function.</p>
<p>clk_put should not be called from within interrupt context.</p>
<dl class="function">
<dt id="c.clk_round_rate">
long <code class="descname">clk_round_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_round_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust a rate to the exact rate a clock can provide</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired clock rate in Hz</dd>
</dl>
<p><strong>Description</strong></p>
<p>This answers the question &#8220;if I were to pass <strong>rate</strong> to <a class="reference internal" href="#c.clk_set_rate" title="clk_set_rate"><code class="xref c c-func docutils literal"><span class="pre">clk_set_rate()</span></code></a>,
what clock rate would I end up with?&#8221; without changing the hardware
in any way.  In other words:</p>
<blockquote>
<div>rate = clk_round_rate(clk, r);</div></blockquote>
<p>and:</p>
<blockquote>
<div>clk_set_rate(clk, r);
rate = clk_get_rate(clk);</div></blockquote>
<p>are equivalent except the former does not modify the clock hardware
in any way.</p>
<p>Returns rounded clock rate in Hz, or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_rate">
int <code class="descname">clk_set_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set the clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired clock rate in Hz</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_rate_exclusive">
int <code class="descname">clk_set_rate_exclusive</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>set the clock rate and claim exclusivity over clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired clock rate in Hz</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function allows drivers to atomically set the rate of a producer
and claim exclusivity over the rate control of the producer.</p>
<p>It is essentially a combination of <a class="reference internal" href="#c.clk_set_rate" title="clk_set_rate"><code class="xref c c-func docutils literal"><span class="pre">clk_set_rate()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">clk_rate_exclusite_get()</span></code>. Caller must balance this call with a call to
<a class="reference internal" href="#c.clk_rate_exclusive_put" title="clk_rate_exclusive_put"><code class="xref c c-func docutils literal"><span class="pre">clk_rate_exclusive_put()</span></code></a></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_has_parent">
bool <code class="descname">clk_has_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct clk *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_has_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a clock is a possible parent for another</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used in drivers that need to check that a clock can be
the parent of another without actually changing the parent.</p>
<p>Returns true if <strong>parent</strong> is a possible parent for <strong>clk</strong>, false otherwise.</p>
<dl class="function">
<dt id="c.clk_set_rate_range">
int <code class="descname">clk_set_rate_range</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;min</em>, unsigned long<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_rate_range" title="Permalink to this definition">¶</a></dt>
<dd><p>set a rate range for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt>
<dd>desired minimum clock rate in Hz, inclusive</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt>
<dd>desired maximum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_min_rate">
int <code class="descname">clk_set_min_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_min_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set a minimum clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired minimum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_max_rate">
int <code class="descname">clk_set_max_rate</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, unsigned long<em>&nbsp;rate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_max_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>set a maximum clock rate for a clock source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">rate</span></code></dt>
<dd>desired maximum clock rate in Hz, inclusive</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_set_parent">
int <code class="descname">clk_set_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em>, struct clk *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_set_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>set the parent clock source for this clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns success (0) or negative errno.</p>
<dl class="function">
<dt id="c.clk_get_parent">
struct clk * <code class="descname">clk_get_parent</code><span class="sig-paren">(</span>struct clk *<em>&nbsp;clk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>get the parent clock source for this clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">clk</span> <span class="pre">*</span> <span class="pre">clk</span></code></dt>
<dd>clock source</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns struct clk corresponding to parent clock source, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.</p>
<dl class="function">
<dt id="c.clk_get_sys">
struct clk * <code class="descname">clk_get_sys</code><span class="sig-paren">(</span>const char *<em>&nbsp;dev_id</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clk_get_sys" title="Permalink to this definition">¶</a></dt>
<dd><p>get a clock based upon the device name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">dev_id</span></code></dt>
<dd>device name</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>connection ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a struct clk corresponding to the clock producer, or
valid <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> condition containing errno.  The implementation
uses <strong>dev_id</strong> and <strong>con_id</strong> to determine the clock consumer, and
thereby the clock producer. In contrast to <a class="reference internal" href="#c.clk_get" title="clk_get"><code class="xref c c-func docutils literal"><span class="pre">clk_get()</span></code></a> this function
takes the device name instead of the device itself for identification.</p>
<p>Drivers must assume that the clock source is not enabled.</p>
<p>clk_get_sys should not be called from within interrupt context.</p>
</div>
<div class="section" id="synchronization-primitives">
<h2>Synchronization Primitives<a class="headerlink" href="#synchronization-primitives" title="Permalink to this headline">¶</a></h2>
<div class="section" id="read-copy-update-rcu">
<h3>Read-Copy Update (RCU)<a class="headerlink" href="#read-copy-update-rcu" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.RCU_NONIDLE">
<code class="descname">RCU_NONIDLE</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_NONIDLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate idle-loop code that needs RCU readers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">a</span></code></dt>
<dd>Code that RCU needs to pay attention to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>RCU, RCU-bh, and RCU-sched read-side critical sections are forbidden
in the inner idle loop, that is, between the <a class="reference internal" href="#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_enter()</span></code></a> and
the <a class="reference internal" href="#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_exit()</span></code></a> &#8211; RCU will happily ignore any such read-side
critical sections.  However, things like powertop need tracepoints
in the inner idle loop.</p>
<p>This macro provides the way out:  RCU_NONIDLE(<code class="xref c c-func docutils literal"><span class="pre">do_something_with_RCU()</span></code>)
will tell RCU that it needs to pay attention, invoke its argument
(in this example, calling the <code class="xref c c-func docutils literal"><span class="pre">do_something_with_RCU()</span></code> function),
and then tell RCU to go back to ignoring this CPU.  It is permissible
to nest <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal"><span class="pre">RCU_NONIDLE()</span></code></a> wrappers, but not indefinitely (but the limit is
on the order of a million or so, even on 32-bit systems).  It is
not legal to block within <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal"><span class="pre">RCU_NONIDLE()</span></code></a>, nor is it permissible to
transfer control either into or out of <a class="reference internal" href="#c.RCU_NONIDLE" title="RCU_NONIDLE"><code class="xref c c-func docutils literal"><span class="pre">RCU_NONIDLE()</span></code></a>&#8216;s statement.</p>
<dl class="function">
<dt id="c.cond_resched_tasks_rcu_qs">
<code class="descname">cond_resched_tasks_rcu_qs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_resched_tasks_rcu_qs" title="Permalink to this definition">¶</a></dt>
<dd><p>Report potential quiescent states to RCU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>This macro resembles <code class="xref c c-func docutils literal"><span class="pre">cond_resched()</span></code>, except that it is defined to
report potential quiescent states to RCU-tasks even if the <code class="xref c c-func docutils literal"><span class="pre">cond_resched()</span></code>
machinery were to be shut off, as some advocate for PREEMPT kernels.</p>
<dl class="function">
<dt id="c.RCU_LOCKDEP_WARN">
<code class="descname">RCU_LOCKDEP_WARN</code><span class="sig-paren">(</span><em>c</em>, <em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_LOCKDEP_WARN" title="Permalink to this definition">¶</a></dt>
<dd><p>emit lockdep splat if specified condition is met</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>condition to check</dd>
<dt><code class="docutils literal"><span class="pre">s</span></code></dt>
<dd>informative message</dd>
</dl>
<dl class="function">
<dt id="c.RCU_INITIALIZER">
<code class="descname">RCU_INITIALIZER</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd><p>statically initialize an RCU-protected global variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">v</span></code></dt>
<dd>The value to statically initialize with.</dd>
</dl>
<dl class="function">
<dt id="c.rcu_assign_pointer">
<code class="descname">rcu_assign_pointer</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_assign_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>assign to RCU-protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>pointer to assign to</dd>
<dt><code class="docutils literal"><span class="pre">v</span></code></dt>
<dd>value to assign (publish)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Assigns the specified value to the specified RCU-protected
pointer, ensuring that any concurrent RCU readers will see
any prior initialization.</p>
<p>Inserts memory barriers on architectures that require them
(which is most of them), and also prevents the compiler from
reordering the code that initializes the structure after the pointer
assignment.  More importantly, this call documents which pointers
will be dereferenced by RCU read-side code.</p>
<p>In some special cases, you may use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> instead
of <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a>.  <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> is a bit faster due
to the fact that it does not constrain either the CPU or the compiler.
That said, using <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> when you should have used
<a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> is a very bad thing that results in
impossible-to-diagnose memory corruption.  So please be careful.
See the <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> comment header for details.</p>
<p>Note that <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> evaluates each of its arguments only
once, appearances notwithstanding.  One of the &#8220;extra&#8221; evaluations
is in <code class="xref c c-func docutils literal"><span class="pre">typeof()</span></code> and the other visible only to sparse (__CHECKER__),
neither of which actually execute the argument.  As with most cpp
macros, this execute-arguments-only-once property is important, so
please be careful when making changes to <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> and the
other macros that it invokes.</p>
<dl class="function">
<dt id="c.rcu_swap_protected">
<code class="descname">rcu_swap_protected</code><span class="sig-paren">(</span><em>rcu_ptr</em>, <em>ptr</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_swap_protected" title="Permalink to this definition">¶</a></dt>
<dd><p>swap an RCU and a regular pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">rcu_ptr</span></code></dt>
<dd>RCU pointer</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>regular pointer</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>the conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform swap(<strong>rcu_ptr</strong>, <strong>ptr</strong>) where <strong>rcu_ptr</strong> is an RCU-annotated pointer and
<strong>c</strong> is the argument that is passed to the <a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_protected()</span></code></a> call
used to read that pointer.</p>
<dl class="function">
<dt id="c.rcu_access_pointer">
<code class="descname">rcu_access_pointer</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_access_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU pointer with no dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the value of the specified RCU-protected pointer, but omit the
lockdep checks for being in an RCU read-side critical section.  This is
useful when the value of this pointer is accessed, but the pointer is
not dereferenced, for example, when testing an RCU-protected pointer
against NULL.  Although <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_access_pointer()</span></code></a> may also be used in cases
where update-side locks prevent the value of the pointer from changing,
you should instead use <a class="reference internal" href="#c.rcu_dereference_protected" title="rcu_dereference_protected"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_protected()</span></code></a> for this use case.</p>
<p>It is also permissible to use <a class="reference internal" href="#c.rcu_access_pointer" title="rcu_access_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_access_pointer()</span></code></a> when read-side
access to the pointer was removed at least one grace period ago, as
is the case in the context of the RCU callback that is freeing up
the data, or after a <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> returns.  This can be useful
when tearing down multi-linked structures after a grace period
has elapsed.</p>
<dl class="function">
<dt id="c.rcu_dereference_check">
<code class="descname">rcu_dereference_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>The conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do an <a class="reference internal" href="#c.rcu_dereference" title="rcu_dereference"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference()</span></code></a>, but check that the conditions under which the
dereference will take place are correct.  Typically the conditions
indicate the various locking conditions that should be held at that
point.  The check should return true if the conditions are satisfied.
An implicit check for being in an RCU read-side critical section
(<a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>) is included.</p>
<p>For example:</p>
<blockquote>
<div>bar = rcu_dereference_check(foo-&gt;bar, lockdep_is_held(<code class="xref c c-type docutils literal"><span class="pre">foo-&gt;lock</span></code>));</div></blockquote>
<p>could be used to indicate to lockdep that foo-&gt;bar may only be dereferenced
if either <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> is held, or that the lock required to replace
the bar struct at foo-&gt;bar is held.</p>
<p>Note that the list of conditions may also include indications of when a lock
need not be held, for example during initialisation or destruction of the
target struct:</p>
<blockquote>
<div><dl class="docutils">
<dt>bar = rcu_dereference_check(foo-&gt;bar, lockdep_is_held(<code class="xref c c-type docutils literal"><span class="pre">foo-&gt;lock</span></code>) ||</dt>
<dd>atomic_read(<code class="xref c c-type docutils literal"><span class="pre">foo-&gt;usage</span></code>) == 0);</dd>
</dl>
</div></blockquote>
<p>Inserts memory barriers on architectures that require them
(currently only the Alpha), prevents the compiler from refetching
(and from merging fetches), and, more importantly, documents exactly
which pointers are protected by RCU and checks that the pointer is
annotated as __rcu.</p>
<dl class="function">
<dt id="c.rcu_dereference_bh_check">
<code class="descname">rcu_dereference_bh_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_bh_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference_bh with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>The conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the RCU-bh counterpart to <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_sched_check">
<code class="descname">rcu_dereference_sched_check</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_sched_check" title="Permalink to this definition">¶</a></dt>
<dd><p>rcu_dereference_sched with debug checking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>The conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the RCU-sched counterpart to <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_protected">
<code class="descname">rcu_dereference_protected</code><span class="sig-paren">(</span><em>p</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_protected" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU pointer when updates prevented</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>The conditions under which the dereference will take place</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the value of the specified RCU-protected pointer, but omit
the <code class="xref c c-func docutils literal"><span class="pre">READ_ONCE()</span></code>.  This is useful in cases where update-side locks
prevent the value of the pointer from changing.  Please note that this
primitive does <em>not</em> prevent the compiler from repeating this reference
or combining it with other references, so it should not be used without
protection of appropriate locks.</p>
<p>This function is only for update-side use.  Using this function
when protected only by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> will result in infrequent
but very ugly failures.</p>
<dl class="function">
<dt id="c.rcu_dereference">
<code class="descname">rcu_dereference</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simple wrapper around <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_dereference_bh">
<code class="descname">rcu_dereference_bh</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch an RCU-bh-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.</p>
<dl class="function">
<dt id="c.rcu_dereference_sched">
<code class="descname">rcu_dereference_sched</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_dereference_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch RCU-sched-protected pointer for dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to read, prior to dereferencing</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.</p>
<dl class="function">
<dt id="c.rcu_pointer_handoff">
<code class="descname">rcu_pointer_handoff</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_pointer_handoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hand off a pointer from RCU to other mechanism</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to hand off</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is simply an identity function, but it documents where a pointer
is handed off from RCU to some other synchronization mechanism, for
example, reference counting or locking.  In C11, it would map to
<code class="xref c c-func docutils literal"><span class="pre">kill_dependency()</span></code>.  It could be used as follows:</p>
<div class="highlight-none"><div class="highlight"><pre>rcu_read_lock();
p = rcu_dereference(gp);
long_lived = is_long_lived(p);
if (long_lived) {
        if (!atomic_inc_not_zero(p-&gt;refcnt))
                long_lived = false;
        else
                p = rcu_pointer_handoff(p);
}
rcu_read_unlock();
</pre></div>
</div>
<dl class="function">
<dt id="c.rcu_read_lock">
void <code class="descname">rcu_read_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of an RCU read-side critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is invoked on one CPU while other CPUs
are within RCU read-side critical sections, then the
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is guaranteed to block until after all the other
CPUs exit their critical sections.  Similarly, if <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> is invoked
on one CPU while other CPUs are within RCU read-side critical
sections, invocation of the corresponding RCU callback is deferred
until after the all the other CPUs exit their critical sections.</p>
<p>Note, however, that RCU callbacks are permitted to run concurrently
with new RCU read-side critical sections.  One way that this can happen
is via the following sequence of events: (1) CPU 0 enters an RCU
read-side critical section, (2) CPU 1 invokes <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> to register
an RCU callback, (3) CPU 0 exits the RCU read-side critical section,
(4) CPU 2 enters a RCU read-side critical section, (5) the RCU
callback is invoked.  This is legal, because the RCU read-side critical
section that was running concurrently with the <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> (and which
therefore might be referencing something that the corresponding RCU
callback would free up) has completed before the corresponding
RCU callback is invoked.</p>
<p>RCU read-side critical sections may be nested.  Any deferred actions
will be deferred until the outermost RCU read-side critical section
completes.</p>
<p>You can avoid reading and understanding the next paragraph by
following this rule: don&#8217;t put anything in an <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> RCU
read-side critical section that would block in a !PREEMPT kernel.
But if you want the full story, read on!</p>
<p>In non-preemptible RCU implementations (TREE_RCU and TINY_RCU),
it is illegal to block while in an RCU read-side critical section.
In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPT
kernel builds, RCU read-side critical sections may be preempted,
but explicit blocking is illegal.  Finally, in preemptible RCU
implementations in real-time (with -rt patchset) kernel builds, RCU
read-side critical sections may be preempted and they may also block, but
only when acquiring spinlocks that are subject to priority inheritance.</p>
<dl class="function">
<dt id="c.rcu_read_unlock">
void <code class="descname">rcu_read_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>marks the end of an RCU read-side critical section.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>In most situations, <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> is immune from deadlock.
However, in kernels built with CONFIG_RCU_BOOST, <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>
is responsible for deboosting, which it does via <code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code>.
Unfortunately, this function acquires the scheduler&#8217;s runqueue and
priority-inheritance spinlocks.  This means that deadlock could result
if the caller of <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> already holds one of these locks or
any lock that is ever acquired while holding them.</p>
<p>That said, RCU readers are never priority boosted unless they were
preempted.  Therefore, one way to avoid deadlock is to make sure
that preemption never happens within any RCU read-side critical
section whose outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> is called with one of
<code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code>&#8216;s locks held.  Such preemption can be avoided in
a number of ways, for example, by invoking <code class="xref c c-func docutils literal"><span class="pre">preempt_disable()</span></code> before
critical section&#8217;s outermost <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<p>Given that the set of locks acquired by <code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code> might change
at any time, a somewhat more future-proofed approach is to make sure
that that preemption never happens within any RCU read-side critical
section whose outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> is called with irqs disabled.
This approach relies on the fact that <code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code> currently only
acquires irq-disabled locks.</p>
<p>The second of these two approaches is best in most situations,
however, the first approach can also be useful, at least to those
developers willing to keep abreast of the set of locks acquired by
<code class="xref c c-func docutils literal"><span class="pre">rt_mutex_unlock()</span></code>.</p>
<p>See <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> for more information.</p>
<dl class="function">
<dt id="c.rcu_read_lock_bh">
void <code class="descname">rcu_read_lock_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of an RCU-bh critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent of <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>, but to be used when updates
are being done using <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> or <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_bh" title="synchronize_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_bh()</span></code></a>. Since
both <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> and <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_bh" title="synchronize_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_bh()</span></code></a> consider completion of a
softirq handler to be a quiescent state, a process in RCU read-side
critical section must be protected by disabling softirqs. Read-side
critical sections in interrupt context can use just <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>,
though this should at least be commented to avoid confusing people
reading the code.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a> and the matching <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code>
must occur in the same context, for example, it is illegal to invoke
<code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code> from one task if the matching <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a>
was invoked from some other task.</p>
<dl class="function">
<dt id="c.rcu_read_lock_sched">
void <code class="descname">rcu_read_lock_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the beginning of a RCU-sched critical section</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent of <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>, but to be used when updates
are being done using <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a> or <code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_sched()</span></code>.
Read-side critical sections can also be introduced by anything that
disables preemption, including <code class="xref c c-func docutils literal"><span class="pre">local_irq_disable()</span></code> and friends.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> and the matching <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code>
must occur in the same context, for example, it is illegal to invoke
<code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code> from process context if the matching
<a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> was invoked from an NMI handler.</p>
<dl class="function">
<dt id="c.RCU_INIT_POINTER">
<code class="descname">RCU_INIT_POINTER</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_INIT_POINTER" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize an RCU protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to be initialized.</dd>
<dt><code class="docutils literal"><span class="pre">v</span></code></dt>
<dd>The value to initialized the pointer to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an RCU-protected pointer in special cases where readers
do not need ordering constraints on the CPU or the compiler.  These
special cases are:</p>
<ol class="arabic simple">
<li>This use of <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> is NULLing out the pointer <em>or</em></li>
<li>The caller has taken whatever steps are required to prevent
RCU readers from concurrently accessing this pointer <em>or</em></li>
<li>The referenced data structure has already been exposed to
readers either at compile time or via <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> <em>and</em><ol class="loweralpha">
<li>You have not made <em>any</em> reader-visible changes to
this structure since then <em>or</em></li>
<li>It is OK for readers accessing this structure from its
new location to see the old state of the structure.  (For
example, the changes were to statistical counters or to
other state where exact synchronization is not required.)</li>
</ol>
</li>
</ol>
<p>Failure to follow these rules governing use of <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> will
result in impossible-to-diagnose memory corruption.  As in the structures
will look OK in crash dumps, but any concurrent RCU readers might
see pre-initialized values of the referenced data structure.  So
please be very careful how you use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a>!!!</p>
<p>If you are creating an RCU-protected linked structure that is accessed
by a single external-to-structure RCU-protected pointer, then you may
use <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> to initialize the internal RCU-protected
pointers, but you must use <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a> to initialize the
external-to-structure pointer <em>after</em> you have completely initialized
the reader-accessible portions of the linked structure.</p>
<p>Note that unlike <a class="reference internal" href="#c.rcu_assign_pointer" title="rcu_assign_pointer"><code class="xref c c-func docutils literal"><span class="pre">rcu_assign_pointer()</span></code></a>, <a class="reference internal" href="#c.RCU_INIT_POINTER" title="RCU_INIT_POINTER"><code class="xref c c-func docutils literal"><span class="pre">RCU_INIT_POINTER()</span></code></a> provides no
ordering guarantees for either the CPU or the compiler.</p>
<dl class="function">
<dt id="c.RCU_POINTER_INITIALIZER">
<code class="descname">RCU_POINTER_INITIALIZER</code><span class="sig-paren">(</span><em>p</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.RCU_POINTER_INITIALIZER" title="Permalink to this definition">¶</a></dt>
<dd><p>statically initialize an RCU protected pointer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The pointer to be initialized.</dd>
<dt><code class="docutils literal"><span class="pre">v</span></code></dt>
<dd>The value to initialized the pointer to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>GCC-style initialization for an RCU-protected pointer in a structure field.</p>
<dl class="function">
<dt id="c.kfree_rcu">
<code class="descname">kfree_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>rcu_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kfree_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>kfree an object after a grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>pointer to kfree</dd>
<dt><code class="docutils literal"><span class="pre">rcu_head</span></code></dt>
<dd>the name of the struct rcu_head within the type of <strong>ptr</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Many rcu callbacks functions just call <a class="reference internal" href="mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a> on the base structure.
These functions are trivial, but their size adds up, and furthermore
when they are used in a kernel module, that module must invoke the
high-latency <a class="reference internal" href="../driver-api/basics.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal"><span class="pre">rcu_barrier()</span></code></a> function at module-unload time.</p>
<p>The <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal"><span class="pre">kfree_rcu()</span></code></a> function handles this issue.  Rather than encoding a
function address in the embedded rcu_head structure, <a class="reference internal" href="#c.kfree_rcu" title="kfree_rcu"><code class="xref c c-func docutils literal"><span class="pre">kfree_rcu()</span></code></a> instead
encodes the offset of the rcu_head structure within the base structure.
Because the functions are not allowed in the low-order 4096 bytes of
kernel virtual memory, offsets up to 4095 bytes can be accommodated.
If the offset is larger than 4095 bytes, a compile-time error will
be generated in <code class="xref c c-func docutils literal"><span class="pre">__kfree_rcu()</span></code>.  If this error is triggered, you can
either fall back to use of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> or rearrange the structure to
position the rcu_head structure into the first 4096 bytes.</p>
<p>Note that the allowable offset might decrease in the future, for example,
to allow something like <code class="xref c c-func docutils literal"><span class="pre">kmem_cache_free_rcu()</span></code>.</p>
<p>The BUILD_BUG_ON check must not involve any function calls, hence the
checks are done in macros here.</p>
<dl class="function">
<dt id="c.synchronize_rcu_mult">
<code class="descname">synchronize_rcu_mult</code><span class="sig-paren">(</span><em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait concurrently for multiple grace periods</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>List of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> functions for the flavors to wait on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro waits concurrently for multiple flavors of RCU grace periods.
For example, synchronize_rcu_mult(call_rcu, call_rcu_bh) would wait
on concurrent RCU and RCU-bh grace periods.  Waiting on a give SRCU
domain requires you to write a wrapper function for that SRCU domain&#8217;s
<a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal"><span class="pre">call_srcu()</span></code></a> function, supplying the corresponding srcu_struct.</p>
<p>If Tiny RCU, tell <code class="xref c c-func docutils literal"><span class="pre">_wait_rcu_gp()</span></code> not to bother waiting for RCU
or RCU-bh, given that anywhere <a class="reference internal" href="#c.synchronize_rcu_mult" title="synchronize_rcu_mult"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_mult()</span></code></a> can be called
is automatically a grace period.</p>
<dl class="function">
<dt id="c.synchronize_rcu_bh_expedited">
void <code class="descname">synchronize_rcu_bh_expedited</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_bh_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force RCU-bh grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an RCU-bh grace period to elapse, but use a &#8220;big hammer&#8221;
approach to force the grace period to end quickly.  This consumes
significant time on all CPUs and is unfriendly to real-time workloads,
so is thus not recommended for any sort of common-case code.  In fact,
if you are using <a class="reference internal" href="#c.synchronize_rcu_bh_expedited" title="synchronize_rcu_bh_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_bh_expedited()</span></code></a> in a loop, please
restructure your code to batch your updates, and then use a single
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_bh" title="synchronize_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_bh()</span></code></a> instead.</p>
<p>Note that it is illegal to call this function while holding any lock
that is acquired by a CPU-hotplug notifier.  And yes, it is also illegal
to call this function from a CPU-hotplug notifier.  Failing to observe
these restriction will result in deadlock.</p>
<dl class="function">
<dt id="c.rcu_idle_enter">
void <code class="descname">rcu_idle_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_idle_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is entering idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter idle mode, in other words, -leave- the mode in which RCU
read-side critical sections can occur.  (Though RCU read-side
critical sections can occur in irq handlers in idle, a possibility
handled by <code class="xref c c-func docutils literal"><span class="pre">irq_enter()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">irq_exit()</span></code>.)</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_enter()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_user_enter">
void <code class="descname">rcu_user_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_user_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that we are resuming userspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter RCU idle mode right before resuming userspace.  No use of RCU
is permitted between this call and <a class="reference internal" href="#c.rcu_user_exit" title="rcu_user_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_user_exit()</span></code></a>. This way the
CPU doesn&#8217;t need to maintain the tick for RCU maintenance purposes
when the CPU runs in userspace.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_user_enter" title="rcu_user_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_user_enter()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_nmi_exit">
void <code class="descname">rcu_nmi_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_nmi_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU of exit from NMI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If we are returning from the outermost NMI handler that interrupted an
RCU-idle period, update rdtp-&gt;dynticks and rdtp-&gt;dynticks_nmi_nesting
to let the RCU grace-period handling know that the CPU is back to
being RCU-idle.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_nmi_exit" title="rcu_nmi_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_nmi_exit()</span></code></a>, be sure to test
with CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_irq_exit">
void <code class="descname">rcu_irq_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_irq_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is exiting irq towards idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit from an interrupt handler, which might possibly result in entering
idle mode, in other words, leaving the mode in which read-side critical
sections can occur.  The caller must have disabled interrupts.</p>
<p>This code assumes that the idle loop never does anything that might
result in unbalanced calls to <code class="xref c c-func docutils literal"><span class="pre">irq_enter()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">irq_exit()</span></code>.  If your
architecture&#8217;s idle loop violates this assumption, RCU will give you what
you deserve, good and hard.  But very infrequently and irreproducibly.</p>
<p>Use things like work queues to work around this limitation.</p>
<p>You have been warned.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_irq_exit" title="rcu_irq_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_irq_exit()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_idle_exit">
void <code class="descname">rcu_idle_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_idle_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is leaving idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit idle mode, in other words, -enter- the mode in which RCU
read-side critical sections can occur.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_exit()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_user_exit">
void <code class="descname">rcu_user_exit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_user_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that we are exiting userspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit RCU idle mode while entering the kernel because it can
run a RCU read side critical section anytime.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_user_exit" title="rcu_user_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_user_exit()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_nmi_enter">
void <code class="descname">rcu_nmi_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_nmi_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU of entry to NMI context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the CPU was idle from RCU&#8217;s viewpoint, update rdtp-&gt;dynticks and
rdtp-&gt;dynticks_nmi_nesting to let the RCU grace-period handling know
that the CPU is active.  This implementation permits nested NMIs, as
long as the nesting level does not overflow an int.  (You will probably
run out of stack space first.)</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_nmi_enter" title="rcu_nmi_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_nmi_enter()</span></code></a>, be sure to test
with CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_irq_enter">
void <code class="descname">rcu_irq_enter</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_irq_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>inform RCU that current CPU is entering irq away from idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter an interrupt handler, which might possibly result in exiting
idle mode, in other words, entering the mode in which read-side critical
sections can occur.  The caller must have disabled interrupts.</p>
<p>Note that the Linux kernel is fully capable of entering an interrupt
handler that it never exits, for example when doing upcalls to user mode!
This code assumes that the idle loop never does upcalls to user mode.
If your architecture&#8217;s idle loop does do upcalls to user mode (or does
anything else that results in unbalanced calls to the <code class="xref c c-func docutils literal"><span class="pre">irq_enter()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">irq_exit()</span></code> functions), RCU will give you what you deserve, good and hard.
But very infrequently and irreproducibly.</p>
<p>Use things like work queues to work around this limitation.</p>
<p>You have been warned.</p>
<p>If you add or remove a call to <a class="reference internal" href="#c.rcu_irq_enter" title="rcu_irq_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_irq_enter()</span></code></a>, be sure to test with
CONFIG_RCU_EQS_DEBUG=y.</p>
<dl class="function">
<dt id="c.rcu_is_watching">
bool notrace <code class="descname">rcu_is_watching</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_watching" title="Permalink to this definition">¶</a></dt>
<dd><p>see if RCU thinks that the current CPU is idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if RCU is watching the running CPU, which means that this
CPU can safely enter RCU read-side critical sections.  In other words,
if the current CPU is in its idle loop and is neither in an interrupt
or NMI handler, return true.</p>
<dl class="function">
<dt id="c.rcu_is_cpu_rrupt_from_idle">
int <code class="descname">rcu_is_cpu_rrupt_from_idle</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_cpu_rrupt_from_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>see if idle or immediately interrupted from idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the current CPU is idle or running at a first-level (not nested)
interrupt from idle, return true.  The caller must have at least
disabled preemption.</p>
<dl class="function">
<dt id="c.rcu_cpu_stall_reset">
void <code class="descname">rcu_cpu_stall_reset</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_cpu_stall_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>prevent further stall warnings in current grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the stall-warning timeout way off into the future, thus preventing
any RCU CPU stall-warning messages from appearing in the current set of
RCU grace periods.</p>
<p>The caller must disable hard irqs.</p>
<dl class="function">
<dt id="c.call_rcu_sched">
void <code class="descname">call_rcu_sched</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation after sched grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a> assumes
that the read-side critical sections end on enabling of preemption
or on voluntary preemption.
RCU read-side critical sections are delimited by:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code>, OR</li>
<li>anything that disables preemption.</li>
</ul>
<blockquote>
<div>These may be nested.</div></blockquote>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.call_rcu_bh">
void <code class="descname">call_rcu_bh</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation after a quicker grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> assumes
that the read-side critical sections end on completion of a softirq
handler. This means that read-side critical sections in process
context must not be interrupted by softirqs. This interface is to be
used when most of the read-side critical sections are in softirq context.
RCU read-side critical sections are delimited by:</p>
<ul class="simple">
<li><a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and  <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>, if in interrupt context, OR</li>
<li><a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code>, if in process context.</li>
</ul>
<p>These may be nested.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.synchronize_sched">
void <code class="descname">synchronize_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu-sched grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu-sched
grace period has elapsed, in other words after all currently executing
rcu-sched read-side critical sections have completed.   These read-side
critical sections are delimited by <a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code>, and may be nested.  Note that <code class="xref c c-func docutils literal"><span class="pre">preempt_disable()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">local_irq_disable()</span></code>, and so on may be used in place of
<a class="reference internal" href="#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a>.</p>
<p>This means that all preempt_disable code sequences, including NMI and
non-threaded hardware-interrupt handlers, in progress on entry will
have completed before this primitive returns.  However, this does not
guarantee that softirq handlers will have completed, since in some
kernels, these handlers can run in process context, and can block.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-sched read-side critical section whose beginning
preceded the call to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>.  In addition, each CPU having
an RCU read-side critical section that extends beyond the return from
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> is guaranteed to have executed a full memory barrier
after the beginning of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> and before the beginning of
that RCU read-side critical section.  Note that these guarantees include
CPUs that are offline, idle, or executing in user mode, as well as CPUs
that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> &#8211; even if CPU A and CPU B are the same CPU (but
again only if the system has more than one CPU).</p>
<dl class="function">
<dt id="c.synchronize_rcu_bh">
void <code class="descname">synchronize_rcu_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu_bh grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu_bh grace
period has elapsed, in other words after all currently executing rcu_bh
read-side critical sections have completed.  RCU read-side critical
sections are delimited by <a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code>,
and may be nested.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> for more detailed information
on memory ordering guarantees.</p>
<dl class="function">
<dt id="c.get_state_synchronize_rcu">
unsigned long <code class="descname">get_state_synchronize_rcu</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Snapshot current RCU state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="../driver-api/basics.html#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">cond_synchronize_rcu()</span></code></a>
to determine whether or not a full grace period has elapsed in the
meantime.</p>
<dl class="function">
<dt id="c.cond_synchronize_rcu">
void <code class="descname">cond_synchronize_rcu</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;oldstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally wait for an RCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt>
<dd>return value from earlier call to <a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_rcu()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the earlier call to
<a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_rcu()</span></code></a>, just return.  Otherwise, invoke
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.</p>
<dl class="function">
<dt id="c.get_state_synchronize_sched">
unsigned long <code class="descname">get_state_synchronize_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Snapshot current RCU-sched state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="../driver-api/basics.html#c.cond_synchronize_sched" title="cond_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">cond_synchronize_sched()</span></code></a>
to determine whether or not a full grace period has elapsed in the
meantime.</p>
<dl class="function">
<dt id="c.cond_synchronize_sched">
void <code class="descname">cond_synchronize_sched</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;oldstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally wait for an RCU-sched grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt>
<dd>return value from earlier call to <a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_sched" title="get_state_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_sched()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU-sched grace period has elapsed since the earlier call to
<a class="reference internal" href="../driver-api/basics.html#c.get_state_synchronize_sched" title="get_state_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_sched()</span></code></a>, just return.  Otherwise, invoke
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.</p>
<dl class="function">
<dt id="c.rcu_barrier_bh">
void <code class="descname">rcu_barrier_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.rcu_barrier_sched">
void <code class="descname">rcu_barrier_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a> callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.call_rcu">
void <code class="descname">call_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU callback for invocation after a grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all pre-existing RCU read-side
critical sections have completed.  However, the callback function
might well execute concurrently with RCU read-side critical sections
that started after <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> was invoked.  RCU read-side critical
sections are delimited by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>,
and may be nested.</p>
<p>Note that all CPUs must agree that the grace period extended beyond
all pre-existing RCU read-side critical section.  On systems with more
than one CPU, this means that when &#8220;<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>&#8221; is invoked, each CPU is
guaranteed to have executed a full memory barrier since the end of its
last RCU read-side critical section whose beginning preceded the call
to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a>.  It also means that each CPU executing an RCU read-side
critical section that continues beyond the start of &#8220;<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>&#8221; must have
executed a memory barrier after the <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> but before the beginning
of that RCU read-side critical section.  Note that these guarantees
include CPUs that are offline, idle, or executing in user mode, as
well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> and CPU B invoked the
resulting RCU callback function &#8220;<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>&#8221;, then both CPU A and CPU B are
guaranteed to execute a full memory barrier during the time interval
between the call to <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> and the invocation of &#8220;<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>&#8221; &#8211; even
if CPU A and CPU B are the same CPU (but again only if the system has
more than one CPU).</p>
<dl class="function">
<dt id="c.synchronize_rcu">
void <code class="descname">synchronize_rcu</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until a grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full grace
period has elapsed, in other words after all currently executing RCU
read-side critical sections have completed.  Note, however, that
upon return from <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, the caller might well be executing
concurrently with new RCU read-side critical sections that began while
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> was waiting.  RCU read-side critical sections are
delimited by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>, and may be nested.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> for more detailed
information on memory-ordering guarantees.  However, please note
that -only- the memory-ordering guarantees apply.  For example,
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is -not- guaranteed to wait on things like code
protected by <code class="xref c c-func docutils literal"><span class="pre">preempt_disable()</span></code>, instead, <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is -only-
guaranteed to wait on RCU read-side critical sections, that is, sections
of code protected by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_barrier">
void <code class="descname">rcu_barrier</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this primitive does not necessarily wait for an RCU grace period
to complete.  For example, if there are no RCU callbacks queued anywhere
in the system, then <a class="reference internal" href="../driver-api/basics.html#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal"><span class="pre">rcu_barrier()</span></code></a> is within its rights to return
immediately, without waiting for anything, much less an RCU grace period.</p>
<dl class="function">
<dt id="c.synchronize_sched_expedited">
void <code class="descname">synchronize_sched_expedited</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_sched_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force RCU-sched grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an RCU-sched grace period to elapse, but use a &#8220;big hammer&#8221;
approach to force the grace period to end quickly.  This consumes
significant time on all CPUs and is unfriendly to real-time workloads,
so is thus not recommended for any sort of common-case code.  In fact,
if you are using <a class="reference internal" href="#c.synchronize_sched_expedited" title="synchronize_sched_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched_expedited()</span></code></a> in a loop, please
restructure your code to batch your updates, and then use a single
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> instead.</p>
<p>This implementation can be thought of as an application of sequence
locking to expedited grace periods, but using the sequence counter to
determine when someone else has already done the work instead of for
retrying readers.</p>
<dl class="function">
<dt id="c.synchronize_rcu_expedited">
void <code class="descname">synchronize_rcu_expedited</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force RCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an RCU-preempt grace period, but expedite it.  The basic
idea is to IPI all non-idle non-nohz online CPUs.  The IPI handler
checks whether the CPU is in an RCU-preempt critical section, and
if so, it sets a flag that causes the outermost <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>
to report the quiescent state.  On the other hand, if the CPU is
not in an RCU read-side critical section, the IPI handler reports
the quiescent state immediately.</p>
<p>Although this is a greate improvement over previous expedited
implementations, it is still unfriendly to real-time workloads, so is
thus not recommended for any sort of common-case code.  In fact, if
you are using <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_expedited()</span></code></a> in a loop, please restructure
your code to batch your updates, and then Use a single <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>
instead.</p>
<dl class="function">
<dt id="c.rcu_read_lock_sched_held">
int <code class="descname">rcu_read_lock_sched_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_sched_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU-sched read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an
RCU-sched read-side critical section.  In absence of
CONFIG_DEBUG_LOCK_ALLOC, this assumes we are in an RCU-sched read-side
critical section unless it can prove otherwise.  Note that disabling
of preemption (including disabling irqs) counts as an RCU-sched
read-side critical section.  This is useful for debug checks in functions
that required that they be called within an RCU-sched read-side
critical section.</p>
<p>Check <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that if the CPU is in the idle loop from an RCU point of
view (ie: that we are in the section between <a class="reference internal" href="#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_enter()</span></code></a> and
<a class="reference internal" href="#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_exit()</span></code></a>) then <a class="reference internal" href="../driver-api/basics.html#c.rcu_read_lock_held" title="rcu_read_lock_held"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_held()</span></code></a> returns false even if the CPU
did an <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.  The reason for this is that RCU ignores CPUs
that are in such a section, considering these as in extended quiescent
state, so such a CPU is effectively never in an RCU read-side critical
section regardless of what RCU primitives it invokes.  This state of
affairs is required &#8212; we need to keep an RCU-free window in idle
where the CPU may possibly enter into low power mode. This way we can
notice an extended quiescent state to other CPUs that started a grace
period. Otherwise we would delay any grace period as long as we run in
the idle task.</p>
<p>Similarly, we avoid claiming an SRCU read lock held if the current
CPU is offline.</p>
<dl class="function">
<dt id="c.rcu_expedite_gp">
void <code class="descname">rcu_expedite_gp</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_expedite_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Expedite future RCU grace periods</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>After a call to this function, future calls to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> and
friends act as the corresponding <a class="reference internal" href="#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_expedited()</span></code></a> function
had instead been called.</p>
<dl class="function">
<dt id="c.rcu_unexpedite_gp">
void <code class="descname">rcu_unexpedite_gp</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_unexpedite_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel prior <a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a> invocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo a prior call to <a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a>.  If all prior calls to
<a class="reference internal" href="../driver-api/basics.html#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a> are undone by a subsequent call to <a class="reference internal" href="../driver-api/basics.html#c.rcu_unexpedite_gp" title="rcu_unexpedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_unexpedite_gp()</span></code></a>,
and if the rcu_expedited sysfs/boot parameter is not set, then all
subsequent calls to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> and friends will return to
their normal non-expedited behavior.</p>
<dl class="function">
<dt id="c.rcu_read_lock_held">
int <code class="descname">rcu_read_lock_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an RCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an RCU read-side critical section unless it can
prove otherwise.  This is useful for debug checks in functions that
require that they be called within an RCU read-side critical section.</p>
<p>Checks <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> in process context if the matching <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>
was invoked from within an irq handler.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
<dl class="function">
<dt id="c.rcu_read_lock_bh_held">
int <code class="descname">rcu_read_lock_bh_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU-bh read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for bottom half being disabled, which covers both the
CONFIG_PROVE_RCU and not cases.  Note that if someone uses
<a class="reference internal" href="#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a>, but then later enables BH, lockdep (if enabled)
will show the situation.  This is useful for debug checks in functions
that require that they be called within an RCU read-side critical
section.</p>
<p>Check <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot.</p>
<p>Note that <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
<dl class="function">
<dt id="c.wakeme_after_rcu">
void <code class="descname">wakeme_after_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeme_after_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback function to awaken a task after grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>Pointer to rcu_head member within rcu_synchronize structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Awaken the corresponding task now that a grace period has elapsed.</p>
<dl class="function">
<dt id="c.init_rcu_head_on_stack">
void <code class="descname">init_rcu_head_on_stack</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_rcu_head_on_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize on-stack rcu_head for debugobjects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to rcu_head structure to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects of a new rcu_head structure that
has been allocated as an auto variable on the stack.  This function
is not required for rcu_head structures that are statically defined or
that are dynamically allocated on the heap.  This function has no
effect for !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
<dl class="function">
<dt id="c.destroy_rcu_head_on_stack">
void <code class="descname">destroy_rcu_head_on_stack</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.destroy_rcu_head_on_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy on-stack rcu_head for debugobjects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to rcu_head structure to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects that an on-stack rcu_head structure
is about to go out of scope.  As with <a class="reference internal" href="../driver-api/basics.html#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this
function is not required for rcu_head structures that are statically
defined or that are dynamically allocated on the heap.  Also as with
<a class="reference internal" href="../driver-api/basics.html#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this function has no effect for
!CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
<dl class="function">
<dt id="c.call_rcu_tasks">
void <code class="descname">call_rcu_tasks</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;rhp</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation task-based grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_tasks()</span></code></a> assumes
that the read-side critical sections end at a voluntary context
switch (not a preemption!), <code class="xref c c-func docutils literal"><span class="pre">cond_resched_rcu_qs()</span></code>, entry into idle,
or transition to usermode execution.  As such, there are no read-side
primitives analogous to <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> because
this primitive is intended to determine that all tasks have passed
through a safe state, not so much for data-strcuture synchronization.</p>
<p>See the description of <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.synchronize_rcu_tasks">
void <code class="descname">synchronize_rcu_tasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu-tasks grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu-tasks
grace period has elapsed, in other words after all currently
executing rcu-tasks read-side critical sections have elapsed.  These
read-side critical sections are delimited by calls to <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code>,
<a class="reference internal" href="#c.cond_resched_tasks_rcu_qs" title="cond_resched_tasks_rcu_qs"><code class="xref c c-func docutils literal"><span class="pre">cond_resched_tasks_rcu_qs()</span></code></a>, idle execution, userspace execution, calls
to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>, and (in theory, anyway) <code class="xref c c-func docutils literal"><span class="pre">cond_resched()</span></code>.</p>
<p>This is a very specialized primitive, intended only for a few uses in
tracing and other situations requiring manipulation of function
preambles and profiling hooks.  The <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> function
is not (yet) intended for heavy use from multiple CPUs.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-tasks read-side critical section whose beginning
preceded the call to <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>.  In addition, each CPU
having an RCU-tasks read-side critical section that extends beyond
the return from <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> is guaranteed to have executed
a full memory barrier after the beginning of <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>
and before the beginning of that RCU-tasks read-side critical section.
Note that these guarantees include CPUs that are offline, idle, or
executing in user mode, as well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> &#8211; even if CPU A and CPU B are the same CPU
(but again only if the system has more than one CPU).</p>
<dl class="function">
<dt id="c.rcu_barrier_tasks">
void <code class="descname">rcu_barrier_tasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_tasks()</span></code></a> callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Although the current implementation is guaranteed to wait, it is not
obligated to, for example, if there are no pending callbacks.</p>
<dl class="function">
<dt id="c.cleanup_srcu_struct">
void <code class="descname">cleanup_srcu_struct</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cleanup_srcu_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>deconstruct a sleep-RCU structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>structure to clean up.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this after you are finished using a given srcu_struct that
was initialized via <a class="reference internal" href="#c.init_srcu_struct" title="init_srcu_struct"><code class="xref c c-func docutils literal"><span class="pre">init_srcu_struct()</span></code></a>, else you leak memory.</p>
<dl class="function">
<dt id="c.cleanup_srcu_struct_quiesced">
void <code class="descname">cleanup_srcu_struct_quiesced</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cleanup_srcu_struct_quiesced" title="Permalink to this definition">¶</a></dt>
<dd><p>deconstruct a quiesced sleep-RCU structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>structure to clean up.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this after you are finished using a given srcu_struct that
was initialized via <a class="reference internal" href="#c.init_srcu_struct" title="init_srcu_struct"><code class="xref c c-func docutils literal"><span class="pre">init_srcu_struct()</span></code></a>, else you leak memory.  Also,
all grace-period processing must have completed.</p>
<p>&#8220;Completed&#8221; means that the last <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> and
<a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu_expedited()</span></code></a> calls must have returned before the call
to <a class="reference internal" href="#c.cleanup_srcu_struct_quiesced" title="cleanup_srcu_struct_quiesced"><code class="xref c c-func docutils literal"><span class="pre">cleanup_srcu_struct_quiesced()</span></code></a>.  It also means that the callback
from the last <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal"><span class="pre">call_srcu()</span></code></a> must have been invoked before the call to
<a class="reference internal" href="#c.cleanup_srcu_struct_quiesced" title="cleanup_srcu_struct_quiesced"><code class="xref c c-func docutils literal"><span class="pre">cleanup_srcu_struct_quiesced()</span></code></a>, but you can use <a class="reference internal" href="#c.srcu_barrier" title="srcu_barrier"><code class="xref c c-func docutils literal"><span class="pre">srcu_barrier()</span></code></a> to help
with this last.  Violating these rules will get you a <code class="xref c c-func docutils literal"><span class="pre">WARN_ON()</span></code> splat
(with high probability, anyway), and will also cause the srcu_struct
to be leaked.</p>
<dl class="function">
<dt id="c.srcu_read_lock_held">
int <code class="descname">srcu_read_lock_held</code><span class="sig-paren">(</span>const struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in SRCU read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>The srcu_struct structure to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an SRCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an SRCU read-side critical section unless it can
prove otherwise.</p>
<p>Checks <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that SRCU is based on its own statemachine and it doesn&#8217;t
relies on normal RCU, it can be called from the CPU which
is in the idle loop from an RCU point of view or offline.</p>
<dl class="function">
<dt id="c.srcu_dereference_check">
<code class="descname">srcu_dereference_check</code><span class="sig-paren">(</span><em>p</em>, <em>sp</em>, <em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_dereference_check" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch SRCU-protected pointer for later dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>the pointer to fetch and protect for later dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">sp</span></code></dt>
<dd>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</dd>
<dt><code class="docutils literal"><span class="pre">c</span></code></dt>
<dd>condition to check for update-side use</dd>
</dl>
<p><strong>Description</strong></p>
<p>If PROVE_RCU is enabled, invoking this outside of an RCU read-side
critical section will result in an RCU-lockdep splat, unless <strong>c</strong> evaluates
to 1.  The <strong>c</strong> argument will normally be a logical expression containing
<code class="xref c c-func docutils literal"><span class="pre">lockdep_is_held()</span></code> calls.</p>
<dl class="function">
<dt id="c.srcu_dereference">
<code class="descname">srcu_dereference</code><span class="sig-paren">(</span><em>p</em>, <em>sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_dereference" title="Permalink to this definition">¶</a></dt>
<dd><p>fetch SRCU-protected pointer for later dereferencing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>the pointer to fetch and protect for later dereferencing</dd>
<dt><code class="docutils literal"><span class="pre">sp</span></code></dt>
<dd>pointer to the srcu_struct, which is used to check that we
really are in an SRCU read-side critical section.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes <a class="reference internal" href="#c.rcu_dereference_check" title="rcu_dereference_check"><code class="xref c c-func docutils literal"><span class="pre">rcu_dereference_check()</span></code></a> do the dirty work.  If PROVE_RCU
is enabled, invoking this outside of an RCU read-side critical
section will result in an RCU-lockdep splat.</p>
<dl class="function">
<dt id="c.srcu_dereference_notrace">
<code class="descname">srcu_dereference_notrace</code><span class="sig-paren">(</span><em>p</em>, <em>sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_dereference_notrace" title="Permalink to this definition">¶</a></dt>
<dd><p>no tracing and no lockdep calls from here</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">sp</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<dl class="function">
<dt id="c.srcu_read_lock">
int <code class="descname">srcu_read_lock</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>register a new reader for an SRCU-protected structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct in which to register the new reader.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enter an SRCU read-side critical section.  Note that SRCU read-side
critical sections may be nested.  However, it is illegal to
call anything that waits on an SRCU grace period for the same
srcu_struct, whether directly or indirectly.  Please note that
one way to indirectly wait on an SRCU grace period is to acquire
a mutex that is held elsewhere while calling <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> or
<a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu_expedited()</span></code></a>.</p>
<p>Note that <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_unlock()</span></code></a> in an irq handler if the matching <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a>
was invoked in process context.</p>
<dl class="function">
<dt id="c.srcu_read_unlock">
void <code class="descname">srcu_read_unlock</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em>, int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a old reader from an SRCU-protected structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct in which to unregister the old reader.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>return value from corresponding <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exit an SRCU read-side critical section.</p>
<dl class="function">
<dt id="c.smp_mb__after_srcu_read_unlock">
void <code class="descname">smp_mb__after_srcu_read_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.smp_mb__after_srcu_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>ensure full ordering after srcu_read_unlock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Converts the preceding srcu_read_unlock into a two-way memory barrier.</p>
<p>Call this after srcu_read_unlock, to guarantee that all memory operations
that occur after smp_mb__after_srcu_read_unlock will appear to happen after
the preceding srcu_read_unlock.</p>
<dl class="function">
<dt id="c.init_srcu_struct">
int <code class="descname">init_srcu_struct</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_srcu_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a sleep-RCU structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>structure to initialize.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must invoke this on a given srcu_struct before passing that srcu_struct
to any other function.  Each srcu_struct represents a separate domain
of SRCU protection.</p>
<dl class="function">
<dt id="c.srcu_readers_active">
bool <code class="descname">srcu_readers_active</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_readers_active" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if there are readers. and false otherwise</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>which srcu_struct to count active readers (holding srcu_read_lock).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this is not an atomic primitive, and can therefore suffer
severe errors when invoked on an active srcu_struct.  That said, it
can be useful as an error check at cleanup time.</p>
<dl class="function">
<dt id="c.call_srcu">
void <code class="descname">call_srcu</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em>, struct rcu_head *<em>&nbsp;rhp</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_srcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a callback for invocation after an SRCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct in queue the callback</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt>
<dd>structure to be used for queueing the SRCU callback.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>function to be invoked after the SRCU grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full SRCU
grace period elapses, in other words after all pre-existing SRCU
read-side critical sections have completed.  However, the callback
function might well execute concurrently with other SRCU read-side
critical sections that started after <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal"><span class="pre">call_srcu()</span></code></a> was invoked.  SRCU
read-side critical sections are delimited by <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a> and
<a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_unlock()</span></code></a>, and may be nested.</p>
<p>The callback will be invoked from process context, but must nevertheless
be fast and must not block.</p>
<dl class="function">
<dt id="c.synchronize_srcu_expedited">
void <code class="descname">synchronize_srcu_expedited</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_srcu_expedited" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force SRCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct with which to synchronize.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for an SRCU grace period to elapse, but be more aggressive about
spinning rather than blocking when waiting.</p>
<p>Note that <a class="reference internal" href="#c.synchronize_srcu_expedited" title="synchronize_srcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu_expedited()</span></code></a> has the same deadlock and
memory-ordering properties as does <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.synchronize_srcu">
void <code class="descname">synchronize_srcu</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_srcu" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for prior SRCU read-side critical-section completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct with which to synchronize.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for the count to drain to zero of both indexes. To avoid the
possible starvation of <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>, it waits for the count of
the index=((-&gt;srcu_idx &amp; 1) ^ 1) to drain to zero at first,
and then flip the srcu_idx and wait for the count of the other index.</p>
<p>Can block; must be called from process context.</p>
<p>Note that it is illegal to call <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> from the corresponding
SRCU read-side critical section; doing so will result in deadlock.
However, it is perfectly legal to call <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> on one
srcu_struct from some other srcu_struct&#8217;s read-side critical section,
as long as the resulting graph of srcu_structs is acyclic.</p>
<p>There are memory-ordering constraints implied by <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>.
On systems with more than one CPU, when <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since
the end of its last corresponding SRCU-sched read-side critical section
whose beginning preceded the call to <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>.  In addition,
each CPU having an SRCU read-side critical section that extends beyond
the return from <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> is guaranteed to have executed a
full memory barrier after the beginning of <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a> and before
the beginning of that SRCU read-side critical section.  Note that these
guarantees include CPUs that are offline, idle, or executing in user mode,
as well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>.  This guarantee applies even if CPU A and CPU B
are the same CPU, but again only if the system has more than one CPU.</p>
<p>Of course, these memory-ordering guarantees apply only when
<a class="reference internal" href="#c.synchronize_srcu" title="synchronize_srcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_srcu()</span></code></a>, <a class="reference internal" href="#c.srcu_read_lock" title="srcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_lock()</span></code></a>, and <a class="reference internal" href="#c.srcu_read_unlock" title="srcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">srcu_read_unlock()</span></code></a> are
passed the same srcu_struct structure.</p>
<p>If SRCU is likely idle, expedite the first request.  This semantic
was provided by Classic SRCU, and is relied upon by its users, so TREE
SRCU must also provide it.  Note that detecting idleness is heuristic
and subject to both false positives and negatives.</p>
<dl class="function">
<dt id="c.srcu_barrier">
void <code class="descname">srcu_barrier</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="#c.call_srcu" title="call_srcu"><code class="xref c c-func docutils literal"><span class="pre">call_srcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct on which to wait for in-flight callbacks.</dd>
</dl>
<dl class="function">
<dt id="c.srcu_batches_completed">
unsigned long <code class="descname">srcu_batches_completed</code><span class="sig-paren">(</span>struct srcu_struct *<em>&nbsp;sp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.srcu_batches_completed" title="Permalink to this definition">¶</a></dt>
<dd><p>return batches completed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">srcu_struct</span> <span class="pre">*</span> <span class="pre">sp</span></code></dt>
<dd>srcu_struct on which to report batch completion.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Report the number of batches, correlated with, but not necessarily
precisely the same as, the number of grace periods that have elapsed.</p>
<dl class="function">
<dt id="c.hlist_bl_del_init_rcu">
void <code class="descname">hlist_bl_del_init_rcu</code><span class="sig-paren">(</span>struct hlist_bl_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_del_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_unhashed()</span></code> on the node returns true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so <code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_bl_for_each_entry_rcu" title="hlist_bl_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_bl_del_rcu">
void <code class="descname">hlist_bl_del_rcu</code><span class="sig-paren">(</span>struct hlist_bl_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_unhashed()</span></code> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<code class="xref c c-func docutils literal"><span class="pre">hlist_bl_for_each_entry()</span></code>.</p>
<dl class="function">
<dt id="c.hlist_bl_add_head_rcu">
void <code class="descname">hlist_bl_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_bl_node *<em>&nbsp;n</em>, struct hlist_bl_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_bl,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_bl_add_head_rcu" title="hlist_bl_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_bl_del_rcu" title="hlist_bl_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_bl_for_each_entry_rcu" title="hlist_bl_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_bl_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_bl_for_each_entry_rcu">
<code class="descname">hlist_bl_for_each_entry_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_bl_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tpos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_bl_node</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_bl_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.list_add_rcu">
void <code class="descname">list_add_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry to rcu-protected list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it after</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry after the specified head.
This is good for implementing stacks.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_add_tail_rcu">
void <code class="descname">list_add_tail_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;new</em>, struct list_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_add_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new entry to rcu-protected list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>new entry to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>list head to add it before</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new entry before the specified head.
This is useful for implementing queues.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_add_tail_rcu" title="list_add_tail_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_tail_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_del_rcu">
void <code class="descname">list_del_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>the element to delete from the list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><a class="reference internal" href="#c.list_empty" title="list_empty"><code class="xref c c-func docutils literal"><span class="pre">list_empty()</span></code></a> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.list_del_rcu" title="list_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_del_rcu()</span></code></a>
or <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.list_for_each_entry_rcu" title="list_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_rcu()</span></code></a>.</p>
<p>Note that the caller is not permitted to immediately free
the newly deleted entry.  Instead, either <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>
or <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> must be used to defer freeing until an RCU
grace period has elapsed.</p>
<dl class="function">
<dt id="c.hlist_del_init_rcu">
void <code class="descname">hlist_del_init_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> on the node return true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so <code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_replace_rcu">
void <code class="descname">list_replace_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;old</em>, struct list_head *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_replace_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the element to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new element to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>old</strong> entry will be replaced with the <strong>new</strong> entry atomically.</p>
<p><strong>Note</strong></p>
<p><strong>old</strong> should not be empty.</p>
<dl class="function">
<dt id="c.__list_splice_init_rcu">
void <code class="descname">__list_splice_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;prev</em>, struct list_head *<em>&nbsp;next</em>, void (*sync)<em>&nbsp;(void</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__list_splice_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>join an RCU-protected list into an existing list.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the RCU-protected list to splice</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt>
<dd>points to the last element of the existing list</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">next</span></code></dt>
<dd>points to the first element of the existing list</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt>
<dd>function to sync: <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, ...</dd>
</dl>
<p><strong>Description</strong></p>
<p>The list pointed to by <strong>prev</strong> and <strong>next</strong> can be RCU-read traversed
concurrently with this function.</p>
<p>Note that this function blocks.</p>
<p>Important note: the caller must take whatever action is necessary to prevent
any other updates to the existing list.  In principle, it is possible to
modify the list as soon as <code class="xref c c-func docutils literal"><span class="pre">sync()</span></code> begins execution. If this sort of thing
becomes necessary, an alternative version based on <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> could be
created.  But only if -really- needed &#8211; there is no shortage of RCU API
members.</p>
<dl class="function">
<dt id="c.list_splice_init_rcu">
void <code class="descname">list_splice_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em>, void (*sync)<em>&nbsp;(void</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>splice an RCU-protected list into an existing list, designed for stacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the RCU-protected list to splice</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place in the existing list to splice the first list into</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt>
<dd>function to sync: <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, ...</dd>
</dl>
<dl class="function">
<dt id="c.list_splice_tail_init_rcu">
void <code class="descname">list_splice_tail_init_rcu</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;list</em>, struct list_head *<em>&nbsp;head</em>, void (*sync)<em>&nbsp;(void</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_splice_tail_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>splice an RCU-protected list into an existing list, designed for queues.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">list</span></code></dt>
<dd>the RCU-protected list to splice</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>the place in the existing list to splice the first list into</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void)</span> <span class="pre">sync</span></code></dt>
<dd>function to sync: <a class="reference internal" href="../driver-api/basics.html#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, ...</dd>
</dl>
<dl class="function">
<dt id="c.list_entry_rcu">
<code class="descname">list_entry_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a> as long as it&#8217;s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_first_or_null_rcu">
<code class="descname">list_first_or_null_rcu</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_first_or_null_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the list is empty, it returns NULL.</p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a> as long as it&#8217;s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_next_or_null_rcu">
<code class="descname">list_next_or_null_rcu</code><span class="sig-paren">(</span><em>head</em>, <em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_next_or_null_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>get the first element from a list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for the list.</dd>
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the list head to take the next element from.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that if the ptr is at the end of the list, NULL is returned.</p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a> as long as it&#8217;s guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_for_each_entry_rcu">
<code class="descname">list_for_each_entry_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.list_entry_lockless">
<code class="descname">list_entry_lockless</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_entry_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>get the struct for this entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> pointer.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>, but requires some implicit RCU
read-side guarding.  One example is running within a special
exception-time environment where preemption is disabled and where
lockdep cannot be invoked (in which case updaters must use RCU-sched,
as in <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a>, and friends).  Another
example is when items are added to the list, but never deleted.</p>
<dl class="function">
<dt id="c.list_for_each_entry_lockless">
<code class="descname">list_for_each_entry_lockless</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_lockless" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_struct within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This primitive may safely run concurrently with the _rcu list-mutation
primitives such as <a class="reference internal" href="#c.list_add_rcu" title="list_add_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_add_rcu()</span></code></a>, but requires some implicit RCU
read-side guarding.  One example is running within a special
exception-time environment where preemption is disabled and where
lockdep cannot be invoked (in which case updaters must use RCU-sched,
as in <a class="reference internal" href="../driver-api/basics.html#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, <a class="reference internal" href="../driver-api/basics.html#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a>, and friends).  Another
example is when items are added to the list, but never deleted.</p>
<dl class="function">
<dt id="c.list_for_each_entry_continue_rcu">
<code class="descname">list_for_each_entry_continue_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_continue_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>continue iteration over list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_head within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Continue to iterate over list of given type, continuing after
the current position which must have been in the list when the RCU read
lock was taken.
This would typically require either that you obtained the node from a
previous walk of the list in the same RCU read-side critical section, or
that you held some sort of non-RCU reference (such as a reference count)
to keep the node alive <em>and</em> in the list.</p>
<p>This iterator is similar to <a class="reference internal" href="#c.list_for_each_entry_from_rcu" title="list_for_each_entry_from_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_from_rcu()</span></code></a> except
this starts after the given position and that one starts at the given
position.</p>
<dl class="function">
<dt id="c.list_for_each_entry_from_rcu">
<code class="descname">list_for_each_entry_from_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.list_for_each_entry_from_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a list from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the list_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the tail of a list starting from a given position,
which must have been in the list when the RCU read lock was taken.
This would typically require either that you obtained the node from a
previous walk of the list in the same RCU read-side critical section, or
that you held some sort of non-RCU reference (such as a reference count)
to keep the node alive <em>and</em> in the list.</p>
<p>This iterator is similar to <a class="reference internal" href="#c.list_for_each_entry_continue_rcu" title="list_for_each_entry_continue_rcu"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_entry_continue_rcu()</span></code></a> except
this starts from the given position and that one starts from the position
after the given position.</p>
<dl class="function">
<dt id="c.hlist_del_rcu">
void <code class="descname">hlist_del_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry" title="hlist_for_each_entry"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_replace_rcu">
void <code class="descname">hlist_replace_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;old</em>, struct hlist_node *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_replace_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>replace old entry by new one</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>the element to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>the new element to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <strong>old</strong> entry will be replaced with the <strong>new</strong> entry atomically.</p>
<dl class="function">
<dt id="c.hlist_add_head_rcu">
void <code class="descname">hlist_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em>, struct hlist_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_add_tail_rcu">
void <code class="descname">hlist_add_tail_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em>, struct hlist_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_tail_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_add_before_rcu">
void <code class="descname">hlist_add_before_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em>, struct hlist_node *<em>&nbsp;next</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_before_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the new element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">next</span></code></dt>
<dd>the existing element to add the new element before.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist
before the specified node while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.</p>
<dl class="function">
<dt id="c.hlist_add_behind_rcu">
void <code class="descname">hlist_add_behind_rcu</code><span class="sig-paren">(</span>struct hlist_node *<em>&nbsp;n</em>, struct hlist_node *<em>&nbsp;prev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_add_behind_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the new element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_node</span> <span class="pre">*</span> <span class="pre">prev</span></code></dt>
<dd>the existing element to add the new element after.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist
after the specified node while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_del_rcu" title="hlist_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu">
<code class="descname">hlist_for_each_entry_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu_notrace">
<code class="descname">hlist_for_each_entry_rcu_notrace</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu_notrace" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type (for tracing)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<p>This is the same as <a class="reference internal" href="#c.hlist_for_each_entry_rcu" title="hlist_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_for_each_entry_rcu()</span></code></a> except that it does
not do any RCU debugging or tracing.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_rcu_bh">
<code class="descname">hlist_for_each_entry_rcu_bh</code><span class="sig-paren">(</span><em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This list-traversal primitive may safely run concurrently with
the _rcu list-mutation primitives such as <a class="reference internal" href="#c.hlist_add_head_rcu" title="hlist_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_add_head_rcu()</span></code></a>
as long as the traversal is guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue_rcu">
<code class="descname">hlist_for_each_entry_continue_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_continue_rcu_bh">
<code class="descname">hlist_for_each_entry_continue_rcu_bh</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_continue_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing after current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_for_each_entry_from_rcu">
<code class="descname">hlist_for_each_entry_from_rcu</code><span class="sig-paren">(</span><em>pos</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_for_each_entry_from_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over a hlist continuing from current point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.hlist_nulls_del_init_rcu">
void <code class="descname">hlist_nulls_del_init_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_del_init_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list with re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_unhashed()</span></code> on the node return true after this. It is
useful for RCU based read lockfree traversal if the writer side
must know if the list entry is still hashed or already unhashed.</p>
<p>In particular, it means that we can not poison the forward pointers
that may still be used for walking the hash list and we can only
zero the pprev pointer so <code class="xref c c-func docutils literal"><span class="pre">list_unhashed()</span></code> will return true after
this.</p>
<p>The caller must take whatever precautions are necessary (such as
holding appropriate locks) to avoid racing with another
list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a> or
<a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.  However, it is
perfectly legal to run concurrently with the _rcu list-traversal
primitives, such as <a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_nulls_del_rcu">
void <code class="descname">hlist_nulls_del_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_del_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>deletes entry from hash list without re-initialization</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to delete from the hash list.</dd>
</dl>
<p><strong>Note</strong></p>
<p><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_unhashed()</span></code> on entry does not return true after this,
the entry is in an undefined state. It is useful for RCU based
lockfree traversal.</p>
<p>In particular, it means that we can not poison the forward
pointers that may still be used for walking the hash list.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_for_each_entry()</span></code>.</p>
<dl class="function">
<dt id="c.hlist_nulls_add_head_rcu">
void <code class="descname">hlist_nulls_add_head_rcu</code><span class="sig-paren">(</span>struct hlist_nulls_node *<em>&nbsp;n</em>, struct hlist_nulls_head *<em>&nbsp;h</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_add_head_rcu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span> <span class="pre">*</span> <span class="pre">n</span></code></dt>
<dd>the element to add to the hash list.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_head</span> <span class="pre">*</span> <span class="pre">h</span></code></dt>
<dd>the list to add to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds the specified element to the specified hlist_nulls,
while permitting racing traversals.</p>
<p>The caller must take whatever precautions are necessary
(such as holding appropriate locks) to avoid racing
with another list-mutation primitive, such as <a class="reference internal" href="#c.hlist_nulls_add_head_rcu" title="hlist_nulls_add_head_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_add_head_rcu()</span></code></a>
or <a class="reference internal" href="#c.hlist_nulls_del_rcu" title="hlist_nulls_del_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_del_rcu()</span></code></a>, running on this same list.
However, it is perfectly legal to run concurrently with
the _rcu list-traversal primitives, such as
<a class="reference internal" href="#c.hlist_nulls_for_each_entry_rcu" title="hlist_nulls_for_each_entry_rcu"><code class="xref c c-func docutils literal"><span class="pre">hlist_nulls_for_each_entry_rcu()</span></code></a>, used to prevent memory-consistency
problems on Alpha CPUs.  Regardless of the type of CPU, the
list-traversal primitive must be guarded by <a class="reference internal" href="#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.hlist_nulls_for_each_entry_rcu">
<code class="descname">hlist_nulls_for_each_entry_rcu</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_for_each_entry_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over rcu list of given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tpos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_nulls_node within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code class="xref c c-func docutils literal"><span class="pre">barrier()</span></code> is needed to make sure compiler doesn&#8217;t cache first element [1],
as this loop can be restarted [2]
[1] Documentation/core-api/atomic_ops.rst around line 114
[2] Documentation/RCU/rculist_nulls.txt around line 146</p>
<dl class="function">
<dt id="c.hlist_nulls_for_each_entry_safe">
<code class="descname">hlist_nulls_for_each_entry_safe</code><span class="sig-paren">(</span><em>tpos</em>, <em>pos</em>, <em>head</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hlist_nulls_for_each_entry_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over list of given type safe against removal of list entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">tpos</span></code></dt>
<dd>the type * to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">hlist_nulls_node</span></code> to use as a loop cursor.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>the head for your list.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the hlist_nulls_node within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.rcu_sync_is_idle">
bool <code class="descname">rcu_sync_is_idle</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_is_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>Are readers permitted to use their fastpaths?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if readers are permitted to use their fastpaths.
Must be invoked within an RCU read-side critical section whose
flavor matches that of the rcu_sync struture.</p>
<dl class="function">
<dt id="c.rcu_sync_init">
void <code class="descname">rcu_sync_init</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em>, enum rcu_sync_type<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an rcu_sync structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to be initialized</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">rcu_sync_type</span> <span class="pre">type</span></code></dt>
<dd>Flavor of RCU with which to synchronize rcu_sync structure</dd>
</dl>
<dl class="function">
<dt id="c.rcu_sync_enter_start">
void <code class="descname">rcu_sync_enter_start</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_enter_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Force readers onto slow path for multiple updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called after <a class="reference internal" href="#c.rcu_sync_init" title="rcu_sync_init"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_init()</span></code></a> and before first use.</p>
<p>Ensures <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_is_idle()</span></code></a> returns false and rcu_sync_{enter,exit}()
pairs turn into NO-OPs.</p>
<dl class="function">
<dt id="c.rcu_sync_enter">
void <code class="descname">rcu_sync_enter</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_enter" title="Permalink to this definition">¶</a></dt>
<dd><p>Force readers onto slowpath</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by updaters who need readers to make use of
a slowpath during the update.  After this function returns, all
subsequent calls to <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_is_idle()</span></code></a> will return false, which
tells readers to stay off their fastpaths.  A later call to
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a> re-enables reader slowpaths.</p>
<p>When called in isolation, <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a> must wait for a grace
period, however, closely spaced calls to <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a> can
optimize away the grace-period wait via a state machine implemented
by <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a>, <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a>, and <a class="reference internal" href="#c.rcu_sync_func" title="rcu_sync_func"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_func()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_sync_func">
void <code class="descname">rcu_sync_func</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;rhp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback function managing reader access to fastpath</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt>
<dd>Pointer to rcu_head in rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is passed to one of the <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> functions by
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a>, so that it is invoked after a grace period following the
that invocation of <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a>.  It takes action based on events that
have taken place in the meantime, so that closely spaced <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a>
and <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a> pairs need not wait for a grace period.</p>
<p>If another <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a> is invoked before the grace period
ended, reset state to allow the next <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a> to let the
readers back onto their fastpaths (after a grace period).  If both
another <a class="reference internal" href="#c.rcu_sync_enter" title="rcu_sync_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_enter()</span></code></a> and its matching <a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a> are invoked
before the grace period ended, re-invoke <a class="reference internal" href="../driver-api/basics.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> on behalf of that
<a class="reference internal" href="#c.rcu_sync_exit" title="rcu_sync_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_exit()</span></code></a>.  Otherwise, set all state back to idle so that readers
can again use their fastpaths.</p>
<dl class="function">
<dt id="c.rcu_sync_exit">
void <code class="descname">rcu_sync_exit</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow readers back onto fast patch after grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to use for synchronization</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used by updaters who have completed, and can therefore
now allow readers to make use of their fastpaths after a grace period
has elapsed.  After this grace period has completed, all subsequent
calls to <a class="reference internal" href="#c.rcu_sync_is_idle" title="rcu_sync_is_idle"><code class="xref c c-func docutils literal"><span class="pre">rcu_sync_is_idle()</span></code></a> will return true, which tells readers that
they can once again use their fastpaths.</p>
<dl class="function">
<dt id="c.rcu_sync_dtor">
void <code class="descname">rcu_sync_dtor</code><span class="sig-paren">(</span>struct rcu_sync *<em>&nbsp;rsp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_sync_dtor" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up an rcu_sync structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_sync</span> <span class="pre">*</span> <span class="pre">rsp</span></code></dt>
<dd>Pointer to rcu_sync structure to be cleaned up</dd>
</dl>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="assoc_array.html" class="btn btn-neutral float-right" title="Generic Associative Array Implementation" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Core API Documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>