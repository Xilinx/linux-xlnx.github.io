

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Boot time memory management &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="Core API Documentation" href="index.html"/>
        <link rel="next" title="The object-lifetime debugging infrastructure" href="debug-objects.html"/>
        <link rel="prev" title="ktime accessors" href="timekeeping.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#core-utilities">Core utilities</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="kernel-api.html">The Linux Kernel API</a></li>
<li class="toctree-l3"><a class="reference internal" href="assoc_array.html">Generic Associative Array Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomic_ops.html">Semantics and Behavior of Atomic and Bitmask Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="cachetlb.html">Cache and TLB Flushing Under Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="refcount-vs-atomic.html">refcount_t API compared to atomic_t</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="idr.html">ID Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="local_ops.html">Semantics and Behavior of Local Atomic Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="workqueue.html">Concurrency Managed Workqueue (cmwq)</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="flexible-arrays.html">Using flexible arrays in the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="librs.html">Reed-Solomon Library Programming Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="genalloc.html">The genalloc/genpool subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="errseq.html">The errseq_t datatype</a></li>
<li class="toctree-l3"><a class="reference internal" href="printk-formats.html">How to get printk format specifiers right</a></li>
<li class="toctree-l3"><a class="reference internal" href="circular-buffers.html">Circular Buffers</a></li>
<li class="toctree-l3"><a class="reference internal" href="mm-api.html">Memory Management APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="gfp_mask-from-fs-io.html">GFP masks used from FS/IO context</a></li>
<li class="toctree-l3"><a class="reference internal" href="timekeeping.html">ktime accessors</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Boot time memory management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bootmem">Bootmem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memblock">Memblock</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions-and-structures">Functions and structures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Core API Documentation</a> &raquo;</li>
      
    <li>Boot time memory management</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/core-api/boot-time-mm.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="boot-time-memory-management">
<h1>Boot time memory management<a class="headerlink" href="#boot-time-memory-management" title="Permalink to this headline">¶</a></h1>
<p>Early system initialization cannot use &#8220;normal&#8221; memory management
simply because it is not set up yet. But there is still need to
allocate memory for various data structures, for instance for the
physical page allocator. To address this, a specialized allocator
called the <a class="reference internal" href="#bootmem"><span>Boot Memory Allocator</span></a>, or bootmem, was
introduced. Several years later PowerPC developers added a &#8220;Logical
Memory Blocks&#8221; allocator, which was later adopted by other
architectures and renamed to <a class="reference internal" href="#memblock"><span>memblock</span></a>. There is also
a compatibility layer called <cite>nobootmem</cite> that translates bootmem
allocation interfaces to memblock calls.</p>
<p>The selection of the early allocator is done using
<code class="docutils literal"><span class="pre">CONFIG_NO_BOOTMEM</span></code> and <code class="docutils literal"><span class="pre">CONFIG_HAVE_MEMBLOCK</span></code> kernel
configuration options. These options are enabled or disabled
statically by the architectures&#8217; Kconfig files.</p>
<ul class="simple">
<li>Architectures that rely only on bootmem select
<code class="docutils literal"><span class="pre">CONFIG_NO_BOOTMEM=n</span> <span class="pre">&amp;&amp;</span> <span class="pre">CONFIG_HAVE_MEMBLOCK=n</span></code>.</li>
<li>The users of memblock with the nobootmem compatibility layer set
<code class="docutils literal"><span class="pre">CONFIG_NO_BOOTMEM=y</span> <span class="pre">&amp;&amp;</span> <span class="pre">CONFIG_HAVE_MEMBLOCK=y</span></code>.</li>
<li>And for those that use both memblock and bootmem the configuration
includes <code class="docutils literal"><span class="pre">CONFIG_NO_BOOTMEM=n</span> <span class="pre">&amp;&amp;</span> <span class="pre">CONFIG_HAVE_MEMBLOCK=y</span></code>.</li>
</ul>
<p>Whichever allocator is used, it is the responsibility of the
architecture specific initialization to set it up in
<code class="xref c c-func docutils literal"><span class="pre">setup_arch()</span></code> and tear it down in <code class="xref c c-func docutils literal"><span class="pre">mem_init()</span></code> functions.</p>
<p>Once the early memory management is available it offers a variety of
functions and macros for memory allocations. The allocation request
may be directed to the first (and probably the only) node or to a
particular node in a NUMA system. There are API variants that panic
when an allocation fails and those that don&#8217;t. And more recent and
advanced memblock even allows controlling its own behaviour.</p>
<div class="section" id="bootmem">
<span id="id1"></span><h2>Bootmem<a class="headerlink" href="#bootmem" title="Permalink to this headline">¶</a></h2>
<p>(mostly stolen from Mel Gorman&#8217;s &#8220;Understanding the Linux Virtual
Memory Manager&#8221; <a class="reference external" href="https://www.kernel.org/doc/gorman/">book</a>)</p>
<p>Bootmem is a boot-time physical memory allocator and configurator.</p>
<p>It is used early in the boot process before the page allocator is
set up.</p>
<p>Bootmem is based on the most basic of allocators, a First Fit
allocator which uses a bitmap to represent memory. If a bit is 1,
the page is allocated and 0 if unallocated. To satisfy allocations
of sizes smaller than a page, the allocator records the Page Frame
Number (PFN) of the last allocation and the offset the allocation
ended at. Subsequent small allocations are merged together and
stored on the same page.</p>
<p>The information used by the bootmem allocator is represented by
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bootmem_data</span></code>. An array to hold up to <code class="docutils literal"><span class="pre">MAX_NUMNODES</span></code>
such structures is statically allocated and then it is discarded
when the system initialization completes. Each entry in this array
corresponds to a node with memory. For UMA systems only entry 0 is
used.</p>
<p>The bootmem allocator is initialized during early architecture
specific setup. Each architecture is required to supply a
<code class="xref c c-func docutils literal"><span class="pre">setup_arch()</span></code> function which, among other tasks, is
responsible for acquiring the necessary parameters to initialise
the boot memory allocator. These parameters define limits of usable
physical memory:</p>
<ul class="simple">
<li><strong>min_low_pfn</strong> - the lowest PFN that is available in the system</li>
<li><strong>max_low_pfn</strong> - the highest PFN that may be addressed by low
memory (<code class="docutils literal"><span class="pre">ZONE_NORMAL</span></code>)</li>
<li><strong>max_pfn</strong> - the last PFN available to the system.</li>
</ul>
<p>After those limits are determined, the <code class="xref c c-func docutils literal"><span class="pre">init_bootmem()</span></code> or
<code class="xref c c-func docutils literal"><span class="pre">init_bootmem_node()</span></code> function should be called to initialize
the bootmem allocator. The UMA case should use the <cite>init_bootmem</cite>
function. It will initialize <code class="docutils literal"><span class="pre">contig_page_data</span></code> structure that
represents the only memory node in the system. In the NUMA case the
<cite>init_bootmem_node</cite> function should be called to initialize the
bootmem allocator for each node.</p>
<p>Once the allocator is set up, it is possible to use either single
node or NUMA variant of the allocation APIs.</p>
</div>
<div class="section" id="memblock">
<span id="id2"></span><h2>Memblock<a class="headerlink" href="#memblock" title="Permalink to this headline">¶</a></h2>
<p>Memblock is a method of managing memory regions during the early
boot period when the usual kernel memory allocators are not up and
running.</p>
<p>Memblock views the system memory as collections of contiguous
regions. There are several types of these collections:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">memory</span></code> - describes the physical memory available to the
kernel; this may differ from the actual physical memory installed
in the system, for instance when the memory is restricted with
<code class="docutils literal"><span class="pre">mem=</span></code> command line parameter</li>
<li><code class="docutils literal"><span class="pre">reserved</span></code> - describes the regions that were allocated</li>
<li><code class="docutils literal"><span class="pre">physmap</span></code> - describes the actual physical memory regardless of
the possible restrictions; the <code class="docutils literal"><span class="pre">physmap</span></code> type is only available
on some architectures.</li>
</ul>
<p>Each region is represented by <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">memblock_region</span></code> that
defines the region extents, its attributes and NUMA node id on NUMA
systems. Every memory type is described by the <code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">memblock_type</span></code> which contains an array of memory regions along with
the allocator metadata. The memory types are nicely wrapped with
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">memblock</span></code>. This structure is statically initialzed
at build time. The region arrays for the &#8220;memory&#8221; and &#8220;reserved&#8221;
types are initially sized to <code class="docutils literal"><span class="pre">INIT_MEMBLOCK_REGIONS</span></code> and for the
&#8220;physmap&#8221; type to <code class="docutils literal"><span class="pre">INIT_PHYSMEM_REGIONS</span></code>.
The <code class="xref c c-func docutils literal"><span class="pre">memblock_allow_resize()</span></code> enables automatic resizing of
the region arrays during addition of new regions. This feature
should be used with care so that memory allocated for the region
array will not overlap with areas that should be reserved, for
example initrd.</p>
<p>The early architecture setup should tell memblock what the physical
memory layout is by using <code class="xref c c-func docutils literal"><span class="pre">memblock_add()</span></code> or
<code class="xref c c-func docutils literal"><span class="pre">memblock_add_node()</span></code> functions. The first function does not
assign the region to a NUMA node and it is appropriate for UMA
systems. Yet, it is possible to use it on NUMA systems as well and
assign the region to a NUMA node later in the setup process using
<code class="xref c c-func docutils literal"><span class="pre">memblock_set_node()</span></code>. The <code class="xref c c-func docutils literal"><span class="pre">memblock_add_node()</span></code>
performs such an assignment directly.</p>
<p>Once memblock is setup the memory can be allocated using either
memblock or bootmem APIs.</p>
<p>As the system boot progresses, the architecture specific
<code class="xref c c-func docutils literal"><span class="pre">mem_init()</span></code> function frees all the memory to the buddy page
allocator.</p>
<p>If an architecure enables <code class="docutils literal"><span class="pre">CONFIG_ARCH_DISCARD_MEMBLOCK</span></code>, the
memblock data structures will be discarded after the system
initialization compltes.</p>
</div>
<div class="section" id="functions-and-structures">
<h2>Functions and structures<a class="headerlink" href="#functions-and-structures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="common-api">
<h3>Common API<a class="headerlink" href="#common-api" title="Permalink to this headline">¶</a></h3>
<p>The functions that are described in this section are available
regardless of what early memory manager is enabled.</p>
<dl class="function">
<dt id="c.free_bootmem_late">
void <code class="descname">free_bootmem_late</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_bootmem_late" title="Permalink to this definition">¶</a></dt>
<dd><p>free bootmem pages directly to page allocator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>starting address of the range</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the range in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is only useful when the bootmem allocator has already been torn
down, but we are still initializing the system.  Pages are given directly
to the page allocator, no bootmem metadata is updated because it is gone.</p>
<dl class="function">
<dt id="c.free_all_bootmem">
unsigned long <code class="descname">free_all_bootmem</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.free_all_bootmem" title="Permalink to this definition">¶</a></dt>
<dd><p>release free pages to the buddy allocator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of pages actually released.</p>
<dl class="function">
<dt id="c.free_bootmem_node">
void <code class="descname">free_bootmem_node</code><span class="sig-paren">(</span>pg_data_t *<em>&nbsp;pgdat</em>, unsigned long<em>&nbsp;physaddr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_bootmem_node" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a page range as usable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pg_data_t</span> <span class="pre">*</span> <span class="pre">pgdat</span></code></dt>
<dd>node the range resides on</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">physaddr</span></code></dt>
<dd>starting physical address of the range</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the range in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Partial pages will be considered reserved and left as they are.</p>
<p>The range must reside completely on the specified node.</p>
<dl class="function">
<dt id="c.free_bootmem">
void <code class="descname">free_bootmem</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.free_bootmem" title="Permalink to this definition">¶</a></dt>
<dd><p>mark a page range as usable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>starting physical address of the range</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the range in bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>Partial pages will be considered reserved and left as they are.</p>
<p>The range must be contiguous but may span node boundaries.</p>
<dl class="function">
<dt id="c.__alloc_bootmem_nopanic">
void * <code class="descname">__alloc_bootmem_nopanic</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;align</em>, unsigned long<em>&nbsp;goal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__alloc_bootmem_nopanic" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate boot memory without panicking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the request in bytes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align</span></code></dt>
<dd>alignment of the region</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">goal</span></code></dt>
<dd>preferred starting address of the region</dd>
</dl>
<p><strong>Description</strong></p>
<p>The goal is dropped if it can not be satisfied and the allocation will
fall back to memory below <strong>goal</strong>.</p>
<p>Allocation may happen on any node in the system.</p>
<p><strong>Return</strong></p>
<p>address of the allocated region or <code class="docutils literal"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.__alloc_bootmem">
void * <code class="descname">__alloc_bootmem</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;align</em>, unsigned long<em>&nbsp;goal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__alloc_bootmem" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate boot memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the request in bytes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align</span></code></dt>
<dd>alignment of the region</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">goal</span></code></dt>
<dd>preferred starting address of the region</dd>
</dl>
<p><strong>Description</strong></p>
<p>The goal is dropped if it can not be satisfied and the allocation will
fall back to memory below <strong>goal</strong>.</p>
<p>Allocation may happen on any node in the system.</p>
<p>The function panics if the request can not be satisfied.</p>
<p><strong>Return</strong></p>
<p>address of the allocated region.</p>
<dl class="function">
<dt id="c.__alloc_bootmem_node">
void * <code class="descname">__alloc_bootmem_node</code><span class="sig-paren">(</span>pg_data_t *<em>&nbsp;pgdat</em>, unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;align</em>, unsigned long<em>&nbsp;goal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__alloc_bootmem_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate boot memory from a specific node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pg_data_t</span> <span class="pre">*</span> <span class="pre">pgdat</span></code></dt>
<dd>node to allocate from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the request in bytes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align</span></code></dt>
<dd>alignment of the region</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">goal</span></code></dt>
<dd>preferred starting address of the region</dd>
</dl>
<p><strong>Description</strong></p>
<p>The goal is dropped if it can not be satisfied and the allocation will
fall back to memory below <strong>goal</strong>.</p>
<p>Allocation may fall back to any node in the system if the specified node
can not hold the requested memory.</p>
<p>The function panics if the request can not be satisfied.</p>
<p><strong>Return</strong></p>
<p>address of the allocated region.</p>
<dl class="function">
<dt id="c.__alloc_bootmem_low">
void * <code class="descname">__alloc_bootmem_low</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;align</em>, unsigned long<em>&nbsp;goal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__alloc_bootmem_low" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate low boot memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the request in bytes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align</span></code></dt>
<dd>alignment of the region</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">goal</span></code></dt>
<dd>preferred starting address of the region</dd>
</dl>
<p><strong>Description</strong></p>
<p>The goal is dropped if it can not be satisfied and the allocation will
fall back to memory below <strong>goal</strong>.</p>
<p>Allocation may happen on any node in the system.</p>
<p>The function panics if the request can not be satisfied.</p>
<p><strong>Return</strong></p>
<p>address of the allocated region.</p>
<dl class="function">
<dt id="c.__alloc_bootmem_low_node">
void * <code class="descname">__alloc_bootmem_low_node</code><span class="sig-paren">(</span>pg_data_t *<em>&nbsp;pgdat</em>, unsigned long<em>&nbsp;size</em>, unsigned long<em>&nbsp;align</em>, unsigned long<em>&nbsp;goal</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__alloc_bootmem_low_node" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate low boot memory from a specific node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pg_data_t</span> <span class="pre">*</span> <span class="pre">pgdat</span></code></dt>
<dd>node to allocate from</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size of the request in bytes</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">align</span></code></dt>
<dd>alignment of the region</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">goal</span></code></dt>
<dd>preferred starting address of the region</dd>
</dl>
<p><strong>Description</strong></p>
<p>The goal is dropped if it can not be satisfied and the allocation will
fall back to memory below <strong>goal</strong>.</p>
<p>Allocation may fall back to any node in the system if the specified node
can not hold the requested memory.</p>
<p>The function panics if the request can not be satisfied.</p>
<p><strong>Return</strong></p>
<p>address of the allocated region.</p>
</div>
<div class="section" id="bootmem-specific-api">
<h3>Bootmem specific API<a class="headerlink" href="#bootmem-specific-api" title="Permalink to this headline">¶</a></h3>
<p>These interfaces available only with bootmem, i.e when <code class="docutils literal"><span class="pre">CONFIG_NO_BOOTMEM=n</span></code></p>
<dl class="type">
<dt id="c.bootmem_data">
struct <code class="descname">bootmem_data</code><a class="headerlink" href="#c.bootmem_data" title="Permalink to this definition">¶</a></dt>
<dd><p>per-node information used by the bootmem allocator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct bootmem_data {
  unsigned long node_min_pfn;
  unsigned long node_low_pfn;
  void *node_bootmem_map;
  unsigned long last_end_off;
  unsigned long hint_idx;
  struct list_head list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node_min_pfn</span></code></dt>
<dd>the starting physical address of the node&#8217;s memory</dd>
<dt><code class="docutils literal"><span class="pre">node_low_pfn</span></code></dt>
<dd>the end physical address of the directly addressable memory</dd>
<dt><code class="docutils literal"><span class="pre">node_bootmem_map</span></code></dt>
<dd>is a bitmap pointer - the bits represent all physical
memory pages (including holes) on the node.</dd>
<dt><code class="docutils literal"><span class="pre">last_end_off</span></code></dt>
<dd>the offset within the page of the end of the last allocation;
if 0, the page used is full</dd>
<dt><code class="docutils literal"><span class="pre">hint_idx</span></code></dt>
<dd>the PFN of the page used with the last allocation;
together with using this with the <strong>last_end_offset</strong> field,
a test can be made to see if allocations can be merged
with the page used for the last allocation rather than
using up a full new page.</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>list entry in the linked list ordered by the memory addresses</dd>
</dl>
</div>
<div class="section" id="memblock-specific-api">
<h3>Memblock specific API<a class="headerlink" href="#memblock-specific-api" title="Permalink to this headline">¶</a></h3>
<p>Here is the description of memblock data structures, functions and
macros. Some of them are actually internal, but since they are
documented it would be silly to omit them. Besides, reading the
descriptions for the internal functions can help to understand what
really happens under the hood.</p>
<dl class="type">
<dt id="c.memblock_flags">
enum <code class="descname">memblock_flags</code><a class="headerlink" href="#c.memblock_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>definition of memory region attributes</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MEMBLOCK_NONE</span></code></dt>
<dd>no special request</dd>
<dt><code class="docutils literal"><span class="pre">MEMBLOCK_HOTPLUG</span></code></dt>
<dd>hotpluggable region</dd>
<dt><code class="docutils literal"><span class="pre">MEMBLOCK_MIRROR</span></code></dt>
<dd>mirrored region</dd>
<dt><code class="docutils literal"><span class="pre">MEMBLOCK_NOMAP</span></code></dt>
<dd>don&#8217;t add to kernel direct mapping</dd>
</dl>
<dl class="type">
<dt id="c.memblock_region">
struct <code class="descname">memblock_region</code><a class="headerlink" href="#c.memblock_region" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a memory region</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct memblock_region {
  phys_addr_t base;
  phys_addr_t size;
  enum memblock_flags flags;
#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP;
  int nid;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>physical address of the region</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size of the region</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>memory region attributes</dd>
<dt><code class="docutils literal"><span class="pre">nid</span></code></dt>
<dd>NUMA node id</dd>
</dl>
<dl class="type">
<dt id="c.memblock_type">
struct <code class="descname">memblock_type</code><a class="headerlink" href="#c.memblock_type" title="Permalink to this definition">¶</a></dt>
<dd><p>collection of memory regions of certain type</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct memblock_type {
  unsigned long cnt;
  unsigned long max;
  phys_addr_t total_size;
  struct memblock_region *regions;
  char *name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cnt</span></code></dt>
<dd>number of regions</dd>
<dt><code class="docutils literal"><span class="pre">max</span></code></dt>
<dd>size of the allocated array</dd>
<dt><code class="docutils literal"><span class="pre">total_size</span></code></dt>
<dd>size of all regions</dd>
<dt><code class="docutils literal"><span class="pre">regions</span></code></dt>
<dd>array of regions</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>the memory type symbolic name</dd>
</dl>
<dl class="type">
<dt id="c.memblock">
struct <code class="descname">memblock</code><a class="headerlink" href="#c.memblock" title="Permalink to this definition">¶</a></dt>
<dd><p>memblock allocator metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct memblock {
  bool bottom_up;
  phys_addr_t current_limit;
  struct memblock_type memory;
  struct memblock_type reserved;
#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP;
  struct memblock_type physmem;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bottom_up</span></code></dt>
<dd>is bottom up direction?</dd>
<dt><code class="docutils literal"><span class="pre">current_limit</span></code></dt>
<dd>physical address of the current allocation limit</dd>
<dt><code class="docutils literal"><span class="pre">memory</span></code></dt>
<dd>usabe memory regions</dd>
<dt><code class="docutils literal"><span class="pre">reserved</span></code></dt>
<dd>reserved memory regions</dd>
<dt><code class="docutils literal"><span class="pre">physmem</span></code></dt>
<dd>all physical memory</dd>
</dl>
<dl class="function">
<dt id="c.for_each_mem_range">
<code class="descname">for_each_mem_range</code><span class="sig-paren">(</span><em>i</em>, <em>type_a</em>, <em>type_b</em>, <em>nid</em>, <em>flags</em>, <em>p_start</em>, <em>p_end</em>, <em>p_nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_mem_range" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate through memblock areas from type_a and not included in type_b. Or just type_a if type_b is NULL.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>u64 used as loop variable</dd>
<dt><code class="docutils literal"><span class="pre">type_a</span></code></dt>
<dd>ptr to memblock_type to iterate</dd>
<dt><code class="docutils literal"><span class="pre">type_b</span></code></dt>
<dd>ptr to memblock_type which excludes from the iteration</dd>
<dt><code class="docutils literal"><span class="pre">nid</span></code></dt>
<dd>node selector, <code class="docutils literal"><span class="pre">NUMA_NO_NODE</span></code> for all nodes</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>pick from blocks based on memory attributes</dd>
<dt><code class="docutils literal"><span class="pre">p_start</span></code></dt>
<dd>ptr to phys_addr_t for start address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_end</span></code></dt>
<dd>ptr to phys_addr_t for end address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_nid</span></code></dt>
<dd>ptr to int for nid of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
</dl>
<dl class="function">
<dt id="c.for_each_mem_range_rev">
<code class="descname">for_each_mem_range_rev</code><span class="sig-paren">(</span><em>i</em>, <em>type_a</em>, <em>type_b</em>, <em>nid</em>, <em>flags</em>, <em>p_start</em>, <em>p_end</em>, <em>p_nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_mem_range_rev" title="Permalink to this definition">¶</a></dt>
<dd><p>reverse iterate through memblock areas from type_a and not included in type_b. Or just type_a if type_b is NULL.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>u64 used as loop variable</dd>
<dt><code class="docutils literal"><span class="pre">type_a</span></code></dt>
<dd>ptr to memblock_type to iterate</dd>
<dt><code class="docutils literal"><span class="pre">type_b</span></code></dt>
<dd>ptr to memblock_type which excludes from the iteration</dd>
<dt><code class="docutils literal"><span class="pre">nid</span></code></dt>
<dd>node selector, <code class="docutils literal"><span class="pre">NUMA_NO_NODE</span></code> for all nodes</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>pick from blocks based on memory attributes</dd>
<dt><code class="docutils literal"><span class="pre">p_start</span></code></dt>
<dd>ptr to phys_addr_t for start address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_end</span></code></dt>
<dd>ptr to phys_addr_t for end address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_nid</span></code></dt>
<dd>ptr to int for nid of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
</dl>
<dl class="function">
<dt id="c.for_each_reserved_mem_region">
<code class="descname">for_each_reserved_mem_region</code><span class="sig-paren">(</span><em>i</em>, <em>p_start</em>, <em>p_end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_reserved_mem_region" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all reserved memblock areas</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>u64 used as loop variable</dd>
<dt><code class="docutils literal"><span class="pre">p_start</span></code></dt>
<dd>ptr to phys_addr_t for start address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_end</span></code></dt>
<dd>ptr to phys_addr_t for end address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks over reserved areas of memblock. Available as soon as memblock
is initialized.</p>
<dl class="function">
<dt id="c.for_each_mem_pfn_range">
<code class="descname">for_each_mem_pfn_range</code><span class="sig-paren">(</span><em>i</em>, <em>nid</em>, <em>p_start</em>, <em>p_end</em>, <em>p_nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_mem_pfn_range" title="Permalink to this definition">¶</a></dt>
<dd><p>early memory pfn range iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>an integer used as loop variable</dd>
<dt><code class="docutils literal"><span class="pre">nid</span></code></dt>
<dd>node selector, <code class="docutils literal"><span class="pre">MAX_NUMNODES</span></code> for all nodes</dd>
<dt><code class="docutils literal"><span class="pre">p_start</span></code></dt>
<dd>ptr to ulong for start pfn of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_end</span></code></dt>
<dd>ptr to ulong for end pfn of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_nid</span></code></dt>
<dd>ptr to int for nid of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks over configured memory ranges.</p>
<dl class="function">
<dt id="c.for_each_free_mem_range">
<code class="descname">for_each_free_mem_range</code><span class="sig-paren">(</span><em>i</em>, <em>nid</em>, <em>flags</em>, <em>p_start</em>, <em>p_end</em>, <em>p_nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_free_mem_range" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate through free memblock areas</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>u64 used as loop variable</dd>
<dt><code class="docutils literal"><span class="pre">nid</span></code></dt>
<dd>node selector, <code class="docutils literal"><span class="pre">NUMA_NO_NODE</span></code> for all nodes</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>pick from blocks based on memory attributes</dd>
<dt><code class="docutils literal"><span class="pre">p_start</span></code></dt>
<dd>ptr to phys_addr_t for start address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_end</span></code></dt>
<dd>ptr to phys_addr_t for end address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_nid</span></code></dt>
<dd>ptr to int for nid of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks over free (memory &amp;&amp; !reserved) areas of memblock.  Available as
soon as memblock is initialized.</p>
<dl class="function">
<dt id="c.for_each_free_mem_range_reverse">
<code class="descname">for_each_free_mem_range_reverse</code><span class="sig-paren">(</span><em>i</em>, <em>nid</em>, <em>flags</em>, <em>p_start</em>, <em>p_end</em>, <em>p_nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_free_mem_range_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>rev-iterate through free memblock areas</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>u64 used as loop variable</dd>
<dt><code class="docutils literal"><span class="pre">nid</span></code></dt>
<dd>node selector, <code class="docutils literal"><span class="pre">NUMA_NO_NODE</span></code> for all nodes</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>pick from blocks based on memory attributes</dd>
<dt><code class="docutils literal"><span class="pre">p_start</span></code></dt>
<dd>ptr to phys_addr_t for start address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_end</span></code></dt>
<dd>ptr to phys_addr_t for end address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_nid</span></code></dt>
<dd>ptr to int for nid of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks over free (memory &amp;&amp; !reserved) areas of memblock in reverse
order.  Available as soon as memblock is initialized.</p>
<dl class="function">
<dt id="c.for_each_resv_unavail_range">
<code class="descname">for_each_resv_unavail_range</code><span class="sig-paren">(</span><em>i</em>, <em>p_start</em>, <em>p_end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_resv_unavail_range" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate through reserved and unavailable memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">i</span></code></dt>
<dd>u64 used as loop variable</dd>
<dt><code class="docutils literal"><span class="pre">p_start</span></code></dt>
<dd>ptr to phys_addr_t for start address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
<dt><code class="docutils literal"><span class="pre">p_end</span></code></dt>
<dd>ptr to phys_addr_t for end address of the range, can be <code class="docutils literal"><span class="pre">NULL</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Walks over unavailable but reserved (reserved &amp;&amp; !memory) areas of memblock.
Available as soon as memblock is initialized.</p>
<p><strong>Note</strong></p>
<p>because this memory does not belong to any physical node, flags and
nid arguments do not make sense and thus not exported as arguments.</p>
<dl class="function">
<dt id="c.memblock_set_current_limit">
void <code class="descname">memblock_set_current_limit</code><span class="sig-paren">(</span>phys_addr_t<em>&nbsp;limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memblock_set_current_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current allocation limit to allow limiting allocations to what is currently accessible during boot</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">phys_addr_t</span> <span class="pre">limit</span></code></dt>
<dd>New limit value (physical address)</dd>
</dl>
<dl class="function">
<dt id="c.memblock_region_memory_base_pfn">
unsigned long <code class="descname">memblock_region_memory_base_pfn</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.memblock_region" title="memblock_region">memblock_region</a> *<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memblock_region_memory_base_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>get the lowest pfn of the memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">memblock_region</span> <span class="pre">*</span> <span class="pre">reg</span></code></dt>
<dd>memblock_region structure</dd>
</dl>
<p><strong>Return</strong></p>
<p>the lowest pfn intersecting with the memory region</p>
<dl class="function">
<dt id="c.memblock_region_memory_end_pfn">
unsigned long <code class="descname">memblock_region_memory_end_pfn</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.memblock_region" title="memblock_region">memblock_region</a> *<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memblock_region_memory_end_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>get the end pfn of the memory region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">memblock_region</span> <span class="pre">*</span> <span class="pre">reg</span></code></dt>
<dd>memblock_region structure</dd>
</dl>
<p><strong>Return</strong></p>
<p>the end_pfn of the reserved region</p>
<dl class="function">
<dt id="c.memblock_region_reserved_base_pfn">
unsigned long <code class="descname">memblock_region_reserved_base_pfn</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.memblock_region" title="memblock_region">memblock_region</a> *<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memblock_region_reserved_base_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>get the lowest pfn of the reserved region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">memblock_region</span> <span class="pre">*</span> <span class="pre">reg</span></code></dt>
<dd>memblock_region structure</dd>
</dl>
<p><strong>Return</strong></p>
<p>the lowest pfn intersecting with the reserved region</p>
<dl class="function">
<dt id="c.memblock_region_reserved_end_pfn">
unsigned long <code class="descname">memblock_region_reserved_end_pfn</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.memblock_region" title="memblock_region">memblock_region</a> *<em>&nbsp;reg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.memblock_region_reserved_end_pfn" title="Permalink to this definition">¶</a></dt>
<dd><p>get the end pfn of the reserved region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">memblock_region</span> <span class="pre">*</span> <span class="pre">reg</span></code></dt>
<dd>memblock_region structure</dd>
</dl>
<p><strong>Return</strong></p>
<p>the end_pfn of the reserved region</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="debug-objects.html" class="btn btn-neutral float-right" title="The object-lifetime debugging infrastructure" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="timekeeping.html" class="btn btn-neutral" title="ktime accessors" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>