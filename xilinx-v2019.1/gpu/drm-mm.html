

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DRM Memory Management &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developerâ€™s Guide" href="index.html"/>
        <link rel="next" title="Kernel Mode Setting (KMS)" href="drm-kms.html"/>
        <link rel="prev" title="DRM Internals" href="drm-internals.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">DRM Memory Management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-translation-table-manager-ttm">The Translation Table Manager (TTM)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ttm-initialization">TTM initialization</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-graphics-execution-manager-gem">The Graphics Execution Manager (GEM)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gem-initialization">GEM Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gem-objects-creation">GEM Objects Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gem-objects-lifetime">GEM Objects Lifetime</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gem-objects-naming">GEM Objects Naming</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gem-objects-mapping">GEM Objects Mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-coherency">Memory Coherency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#command-execution">Command Execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gem-function-reference">GEM Function Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gem-cma-helper-functions-reference">GEM CMA Helper Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vma-offset-manager">VMA Offset Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prime-buffer-sharing">PRIME Buffer Sharing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview-and-driver-interface">Overview and Driver Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#prime-helper-functions">PRIME Helper Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#prime-function-references">PRIME Function References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#drm-mm-range-allocator">DRM MM Range Allocator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lru-scan-eviction-support">LRU Scan/Eviction Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#drm-mm-range-allocator-function-references">DRM MM Range Allocator Function References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#drm-cache-handling">DRM Cache Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#drm-sync-objects">DRM Sync Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gpu-scheduler">GPU Scheduler</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scheduler-function-references">Scheduler Function References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>DRM Memory Management</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/drm-mm.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="drm-memory-management">
<h1>DRM Memory Management<a class="headerlink" href="#drm-memory-management" title="Permalink to this headline">Â¶</a></h1>
<p>Modern Linux systems require large amount of graphics memory to store
frame buffers, textures, vertices and other graphics-related data. Given
the very dynamic nature of many of that data, managing graphics memory
efficiently is thus crucial for the graphics stack and plays a central
role in the DRM infrastructure.</p>
<p>The DRM core includes two memory managers, namely Translation Table Maps
(TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory
manager to be developed and tried to be a one-size-fits-them all
solution. It provides a single userspace API to accommodate the need of
all hardware, supporting both Unified Memory Architecture (UMA) devices
and devices with dedicated video RAM (i.e. most discrete video cards).
This resulted in a large, complex piece of code that turned out to be
hard to use for driver development.</p>
<p>GEM started as an Intel-sponsored project in reaction to TTM&#8217;s
complexity. Its design philosophy is completely different: instead of
providing a solution to every graphics memory-related problems, GEM
identified common code between drivers and created a support library to
share it. GEM has simpler initialization and execution requirements than
TTM, but has no video RAM management capabilities and is thus limited to
UMA devices.</p>
<div class="section" id="the-translation-table-manager-ttm">
<h2>The Translation Table Manager (TTM)<a class="headerlink" href="#the-translation-table-manager-ttm" title="Permalink to this headline">Â¶</a></h2>
<p>TTM design background and information belongs here.</p>
<div class="section" id="ttm-initialization">
<h3>TTM initialization<a class="headerlink" href="#ttm-initialization" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div><strong>Warning</strong>
This section is outdated.</div></blockquote>
<p>Drivers wishing to support TTM must pass a filled <code class="xref c c-type docutils literal"><span class="pre">ttm_bo_driver</span></code> structure to ttm_bo_device_init, together with an
initialized global reference to the memory manager.  The ttm_bo_driver
structure contains several fields with function pointers for
initializing the TTM, allocating and freeing memory, waiting for command
completion and fence synchronization, and memory migration.</p>
<p>The <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_global_reference</span></code> is made
up of several fields:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">drm_global_reference</span> <span class="p">{</span>
        <span class="k">enum</span> <span class="n">ttm_global_types</span> <span class="n">global_type</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_global_reference</span> <span class="o">*</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">drm_global_reference</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There should be one global reference structure for your memory manager
as a whole, and there will be others for each object created by the
memory manager at runtime. Your global TTM should have a type of
TTM_GLOBAL_TTM_MEM. The size field for the global object should be
sizeof(struct ttm_mem_global), and the init and release hooks should
point at your driver-specific init and release routines, which probably
eventually call ttm_mem_global_init and ttm_mem_global_release,
respectively.</p>
<p>Once your global TTM accounting structure is set up and initialized by
calling ttm_global_item_ref() on it, you need to create a buffer
object TTM to provide a pool for buffer object allocation by clients and
the kernel itself. The type of this object should be
TTM_GLOBAL_TTM_BO, and its size should be sizeof(struct
ttm_bo_global). Again, driver-specific init and release functions may
be provided, likely eventually calling ttm_bo_global_init() and
ttm_bo_global_release(), respectively. Also, like the previous
object, ttm_global_item_ref() is used to create an initial reference
count for the TTM, which will call your initialization function.</p>
<p>See the radeon_ttm.c file for an example of usage.</p>
<dl class="function">
<dt id="c.drm_global_item_ref">
int <code class="descname">drm_global_item_ref</code><span class="sig-paren">(</span>struct drm_global_reference *<em>&nbsp;ref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_global_item_ref" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Initialize and acquire reference to memory object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_global_reference</span> <span class="pre">*</span> <span class="pre">ref</span></code></dt>
<dd>Object for initialization</dd>
</dl>
<p><strong>Description</strong></p>
<p>This initializes a memory object, allocating memory and calling the
.:c:func:<cite>init()</cite> hook. Further calls will increase the reference count for
that item.</p>
<p><strong>Return</strong></p>
<p>Zero on success, non-zero otherwise.</p>
<dl class="function">
<dt id="c.drm_global_item_unref">
void <code class="descname">drm_global_item_unref</code><span class="sig-paren">(</span>struct drm_global_reference *<em>&nbsp;ref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_global_item_unref" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Drop reference to memory object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_global_reference</span> <span class="pre">*</span> <span class="pre">ref</span></code></dt>
<dd>Object being removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop a reference to the memory object and eventually call the
<code class="xref c c-func docutils literal"><span class="pre">release()</span></code> hook.  The allocated object should be dropped in the
<code class="xref c c-func docutils literal"><span class="pre">release()</span></code> hook or before calling this function</p>
</div>
</div>
<div class="section" id="the-graphics-execution-manager-gem">
<h2>The Graphics Execution Manager (GEM)<a class="headerlink" href="#the-graphics-execution-manager-gem" title="Permalink to this headline">Â¶</a></h2>
<p>The GEM design approach has resulted in a memory manager that doesn&#8217;t
provide full coverage of all (or even all common) use cases in its
userspace or kernel API. GEM exposes a set of standard memory-related
operations to userspace and a set of helper functions to drivers, and
let drivers implement hardware-specific operations with their own
private API.</p>
<p>The GEM userspace API is described in the <a class="reference external" href="http://lwn.net/Articles/283798/">GEM - the Graphics Execution
Manager</a> article on LWN. While
slightly outdated, the document provides a good overview of the GEM API
principles. Buffer allocation and read and write operations, described
as part of the common GEM API, are currently implemented using
driver-specific ioctls.</p>
<p>GEM is data-agnostic. It manages abstract buffer objects without knowing
what individual buffers contain. APIs that require knowledge of buffer
contents or purpose, such as buffer allocation or synchronization
primitives, are thus outside of the scope of GEM and must be implemented
using driver-specific ioctls.</p>
<p>On a fundamental level, GEM involves several operations:</p>
<ul class="simple">
<li>Memory allocation and freeing</li>
<li>Command execution</li>
<li>Aperture management at command execution time</li>
</ul>
<p>Buffer object allocation is relatively straightforward and largely
provided by Linux&#8217;s shmem layer, which provides memory to back each
object.</p>
<p>Device-specific operations, such as command execution, pinning, buffer
read &amp; write, mapping, and domain ownership transfers are left to
driver-specific ioctls.</p>
<div class="section" id="gem-initialization">
<h3>GEM Initialization<a class="headerlink" href="#gem-initialization" title="Permalink to this headline">Â¶</a></h3>
<p>Drivers that use GEM must set the DRIVER_GEM bit in the struct
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> driver_features
field. The DRM core will then automatically initialize the GEM core
before calling the load operation. Behind the scene, this will create a
DRM Memory Manager object which provides an address space pool for
object allocation.</p>
<p>In a KMS configuration, drivers need to allocate and initialize a
command ring buffer following core GEM initialization if required by the
hardware. UMA devices usually have what is called a &#8220;stolen&#8221; memory
region, which provides space for the initial framebuffer and large,
contiguous memory regions required by the device. This space is
typically not managed by GEM, and must be initialized separately into
its own DRM MM object.</p>
</div>
<div class="section" id="gem-objects-creation">
<h3>GEM Objects Creation<a class="headerlink" href="#gem-objects-creation" title="Permalink to this headline">Â¶</a></h3>
<p>GEM splits creation of GEM objects and allocation of the memory that
backs them in two distinct operations.</p>
<p>GEM objects are represented by an instance of struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_gem_object</span></code></a>. Drivers usually need to
extend GEM objects with private information and thus create a
driver-specific GEM object structure type that embeds an instance of
struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span></code></a>.</p>
<p>To create a GEM object, a driver allocates memory for an instance of its
specific GEM object type and initializes the embedded struct
<a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span></code></a> with a call
to <a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_init()</span></code></a>. The function takes a pointer
to the DRM device, a pointer to the GEM object and the buffer object
size in bytes.</p>
<p>GEM uses shmem to allocate anonymous pageable memory.
<a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_init()</span></code></a> will create an shmfs file of the
requested size and store it into the struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_gem_object</span></code></a> filp field. The memory is
used as either main storage for the object when the graphics hardware
uses system memory directly or as a backing store otherwise.</p>
<p>Drivers are responsible for the actual physical pages allocation by
calling <code class="xref c c-func docutils literal"><span class="pre">shmem_read_mapping_page_gfp()</span></code> for each page.
Note that they can decide to allocate pages when initializing the GEM
object, or to delay allocation until the memory is needed (for instance
when a page fault occurs as a result of a userspace memory access or
when the driver needs to start a DMA transfer involving the memory).</p>
<p>Anonymous pageable memory allocation is not always desired, for instance
when the hardware requires physically contiguous system memory as is
often the case in embedded devices. Drivers can create GEM objects with
no shmfs backing (called private GEM objects) by initializing them with
a call to <a class="reference internal" href="#c.drm_gem_private_object_init" title="drm_gem_private_object_init"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_private_object_init()</span></code></a> instead of
<a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_init()</span></code></a>. Storage for private GEM objects
must be managed by drivers.</p>
</div>
<div class="section" id="gem-objects-lifetime">
<h3>GEM Objects Lifetime<a class="headerlink" href="#gem-objects-lifetime" title="Permalink to this headline">Â¶</a></h3>
<p>All GEM objects are reference-counted by the GEM core. References can be
acquired and release by <code class="xref c c-func docutils literal"><span class="pre">calling</span> <span class="pre">drm_gem_object_get()</span></code> and
<a class="reference internal" href="#c.drm_gem_object_put" title="drm_gem_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put()</span></code></a> respectively. The caller must hold the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code> struct_mutex lock when calling
<a class="reference internal" href="#c.drm_gem_object_get" title="drm_gem_object_get"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_get()</span></code></a>. As a convenience, GEM provides
<a class="reference internal" href="#c.drm_gem_object_put_unlocked" title="drm_gem_object_put_unlocked"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put_unlocked()</span></code></a> functions that can be called without
holding the lock.</p>
<p>When the last reference to a GEM object is released the GEM core calls
the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> gem_free_object_unlocked
operation. That operation is mandatory for GEM-enabled drivers and must
free the GEM object and all associated resources.</p>
<p>void (*gem_free_object) (struct drm_gem_object *obj); Drivers are
responsible for freeing all GEM object resources. This includes the
resources created by the GEM core, which need to be released with
<a class="reference internal" href="#c.drm_gem_object_release" title="drm_gem_object_release"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_release()</span></code></a>.</p>
</div>
<div class="section" id="gem-objects-naming">
<h3>GEM Objects Naming<a class="headerlink" href="#gem-objects-naming" title="Permalink to this headline">Â¶</a></h3>
<p>Communication between userspace and the kernel refers to GEM objects
using local handles, global names or, more recently, file descriptors.
All of those are 32-bit integer values; the usual Linux kernel limits
apply to the file descriptors.</p>
<p>GEM handles are local to a DRM file. Applications get a handle to a GEM
object through a driver-specific ioctl, and can use that handle to refer
to the GEM object in other standard or driver-specific ioctls. Closing a
DRM file handle frees all its GEM handles and dereferences the
associated GEM objects.</p>
<p>To create a handle for a GEM object drivers call
<a class="reference internal" href="#c.drm_gem_handle_create" title="drm_gem_handle_create"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_handle_create()</span></code></a>. The function takes a pointer
to the DRM file and the GEM object and returns a locally unique handle.
When the handle is no longer needed drivers delete it with a call to
<a class="reference internal" href="#c.drm_gem_handle_delete" title="drm_gem_handle_delete"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_handle_delete()</span></code></a>. Finally the GEM object
associated with a handle can be retrieved by a call to
<a class="reference internal" href="#c.drm_gem_object_lookup" title="drm_gem_object_lookup"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_lookup()</span></code></a>.</p>
<p>Handles don&#8217;t take ownership of GEM objects, they only take a reference
to the object that will be dropped when the handle is destroyed. To
avoid leaking GEM objects, drivers must make sure they drop the
reference(s) they own (such as the initial reference taken at object
creation time) as appropriate, without any special consideration for the
handle. For example, in the particular case of combined GEM object and
handle creation in the implementation of the dumb_create operation,
drivers must drop the initial reference to the GEM object before
returning the handle.</p>
<p>GEM names are similar in purpose to handles but are not local to DRM
files. They can be passed between processes to reference a GEM object
globally. Names can&#8217;t be used directly to refer to objects in the DRM
API, applications must convert handles to names and names to handles
using the DRM_IOCTL_GEM_FLINK and DRM_IOCTL_GEM_OPEN ioctls
respectively. The conversion is handled by the DRM core without any
driver-specific support.</p>
<p>GEM also supports buffer sharing with dma-buf file descriptors through
PRIME. GEM-based drivers must use the provided helpers functions to
implement the exporting and importing correctly. See ?. Since sharing
file descriptors is inherently more secure than the easily guessable and
global GEM names it is the preferred buffer sharing mechanism. Sharing
buffers through GEM names is only supported for legacy userspace.
Furthermore PRIME also allows cross-device buffer sharing since it is
based on dma-bufs.</p>
</div>
<div class="section" id="gem-objects-mapping">
<h3>GEM Objects Mapping<a class="headerlink" href="#gem-objects-mapping" title="Permalink to this headline">Â¶</a></h3>
<p>Because mapping operations are fairly heavyweight GEM favours
read/write-like access to buffers, implemented through driver-specific
ioctls, over mapping buffers to userspace. However, when random access
to the buffer is needed (to perform software rendering for instance),
direct access to the object can be more efficient.</p>
<p>The mmap system call can&#8217;t be used directly to map GEM objects, as they
don&#8217;t have their own file handle. Two alternative methods currently
co-exist to map GEM objects to userspace. The first method uses a
driver-specific ioctl to perform the mapping operation, calling
<code class="xref c c-func docutils literal"><span class="pre">do_mmap()</span></code> under the hood. This is often considered
dubious, seems to be discouraged for new GEM-enabled drivers, and will
thus not be described here.</p>
<p>The second method uses the mmap system call on the DRM file handle. void
*mmap(void *addr, size_t length, int prot, int flags, int fd, off_t
offset); DRM identifies the GEM object to be mapped by a fake offset
passed through the mmap offset argument. Prior to being mapped, a GEM
object must thus be associated with a fake offset. To do so, drivers
must call <a class="reference internal" href="#c.drm_gem_create_mmap_offset" title="drm_gem_create_mmap_offset"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_create_mmap_offset()</span></code></a> on the object.</p>
<p>Once allocated, the fake offset value must be passed to the application
in a driver-specific way and can then be used as the mmap offset
argument.</p>
<p>The GEM core provides a helper method <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_mmap()</span></code></a> to
handle object mapping. The method can be set directly as the mmap file
operation handler. It will look up the GEM object based on the offset
value and set the VMA operations to the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> gem_vm_ops field. Note that
<a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_mmap()</span></code></a> doesn&#8217;t map memory to userspace, but
relies on the driver-provided fault handler to map pages individually.</p>
<p>To use <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_mmap()</span></code></a>, drivers must fill the struct
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a> gem_vm_ops field
with a pointer to VM operations.</p>
<p>The VM operations is a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_operations_struct</span></code>
made up of several fields, the more interesting ones being:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">area</span><span class="p">);</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">area</span><span class="p">);</span>
        <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fault</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The open and close operations must update the GEM object reference
count. Drivers can use the <a class="reference internal" href="#c.drm_gem_vm_open" title="drm_gem_vm_open"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_vm_open()</span></code></a> and
<a class="reference internal" href="#c.drm_gem_vm_close" title="drm_gem_vm_close"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_vm_close()</span></code></a> helper functions directly as open
and close handlers.</p>
<p>The fault operation handler is responsible for mapping individual pages
to userspace when a page fault occurs. Depending on the memory
allocation scheme, drivers can allocate pages at fault time, or can
decide to allocate memory for the GEM object at the time the object is
created.</p>
<p>Drivers that want to map the GEM object upfront instead of handling page
faults can implement their own mmap file operation handler.</p>
<p>For platforms without MMU the GEM core provides a helper method
<a class="reference internal" href="#c.drm_gem_cma_get_unmapped_area" title="drm_gem_cma_get_unmapped_area"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_cma_get_unmapped_area()</span></code></a>. The mmap() routines will call
this to get a proposed address for the mapping.</p>
<p>To use <a class="reference internal" href="#c.drm_gem_cma_get_unmapped_area" title="drm_gem_cma_get_unmapped_area"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_cma_get_unmapped_area()</span></code></a>, drivers must fill the
struct <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> get_unmapped_area
field with a pointer on <a class="reference internal" href="#c.drm_gem_cma_get_unmapped_area" title="drm_gem_cma_get_unmapped_area"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_cma_get_unmapped_area()</span></code></a>.</p>
<p>More detailed information about get_unmapped_area can be found in
Documentation/nommu-mmap.txt</p>
</div>
<div class="section" id="memory-coherency">
<h3>Memory Coherency<a class="headerlink" href="#memory-coherency" title="Permalink to this headline">Â¶</a></h3>
<p>When mapped to the device or used in a command buffer, backing pages for
an object are flushed to memory and marked write combined so as to be
coherent with the GPU. Likewise, if the CPU accesses an object after the
GPU has finished rendering to the object, then the object must be made
coherent with the CPU&#8217;s view of memory, usually involving GPU cache
flushing of various kinds. This core CPU&lt;-&gt;GPU coherency management is
provided by a device-specific ioctl, which evaluates an object&#8217;s current
domain and performs any necessary flushing or synchronization to put the
object into the desired coherency domain (note that the object may be
busy, i.e. an active render target; in that case, setting the domain
blocks the client and waits for rendering to complete before performing
any necessary flushing operations).</p>
</div>
<div class="section" id="command-execution">
<h3>Command Execution<a class="headerlink" href="#command-execution" title="Permalink to this headline">Â¶</a></h3>
<p>Perhaps the most important GEM function for GPU devices is providing a
command execution interface to clients. Client programs construct
command buffers containing references to previously allocated memory
objects, and then submit them to GEM. At that point, GEM takes care to
bind all the objects into the GTT, execute the buffer, and provide
necessary synchronization between clients accessing the same buffers.
This often involves evicting some objects from the GTT and re-binding
others (a fairly expensive operation), and providing relocation support
which hides fixed GTT offsets from clients. Clients must take care not
to submit command buffers that reference more objects than can fit in
the GTT; otherwise, GEM will reject them and no rendering will occur.
Similarly, if several objects in the buffer require fence registers to
be allocated for correct rendering (e.g. 2D blits on pre-965 chips),
care must be taken not to require more fence registers than are
available to the client. Such resource management should be abstracted
from the client in libdrm.</p>
</div>
<div class="section" id="gem-function-reference">
<h3>GEM Function Reference<a class="headerlink" href="#gem-function-reference" title="Permalink to this headline">Â¶</a></h3>
<dl class="type">
<dt id="c.drm_gem_object">
struct <code class="descname">drm_gem_object</code><a class="headerlink" href="#c.drm_gem_object" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GEM buffer object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_gem_object {
  struct kref refcount;
  unsigned handle_count;
  struct drm_device *dev;
  struct file *filp;
  struct drm_vma_offset_node vma_node;
  size_t size;
  int name;
  struct dma_buf *dma_buf;
  struct dma_buf_attachment *import_attach;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd><p class="first">Reference count of this object</p>
<p class="last">Please use <a class="reference internal" href="#c.drm_gem_object_get" title="drm_gem_object_get"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_get()</span></code></a> to acquire and <a class="reference internal" href="#c.drm_gem_object_put" title="drm_gem_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put()</span></code></a>
or <a class="reference internal" href="#c.drm_gem_object_put_unlocked" title="drm_gem_object_put_unlocked"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put_unlocked()</span></code></a> to release a reference to a GEM
buffer object.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">handle_count</span></code></dt>
<dd><p class="first">This is the GEM file_priv handle count of this object.</p>
<p>Each handle also holds a reference. Note that when the handle_count
drops to 0 any global names (e.g. the id in the flink namespace) will
be cleared.</p>
<p class="last">Protected by <code class="xref c c-type docutils literal"><span class="pre">drm_device.object_name_lock</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM dev this object belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">filp</span></code></dt>
<dd>SHMEM file node used as backing storage for swappable buffer objects.
GEM also supports driver private objects with driver-specific backing
storage (contiguous CMA memory, special reserved blocks). In this
case <strong>filp</strong> is NULL.</dd>
<dt><code class="docutils literal"><span class="pre">vma_node</span></code></dt>
<dd><p class="first">Mapping info for this object to support mmap. Drivers are supposed to
allocate the mmap offset using <a class="reference internal" href="#c.drm_gem_create_mmap_offset" title="drm_gem_create_mmap_offset"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_create_mmap_offset()</span></code></a>. The
offset itself can be retrieved using <a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_offset_addr()</span></code></a>.</p>
<p class="last">Memory mapping itself is handled by <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_mmap()</span></code></a>, which also checks
that userspace is allowed to access the object.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>Size of the object, in bytes.  Immutable over the object&#8217;s
lifetime.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Global name for this object, starts at 1. 0 means unnamed.
Access is covered by <code class="xref c c-type docutils literal"><span class="pre">drm_device.object_name_lock</span></code>. This is used by
the GEM_FLINK and GEM_OPEN ioctls.</dd>
<dt><code class="docutils literal"><span class="pre">dma_buf</span></code></dt>
<dd><p class="first">dma-buf associated with this GEM object.</p>
<p>Pointer to the dma-buf associated with this gem object (either
through importing or exporting). We break the resulting reference
loop when the last gem handle for this object is released.</p>
<p class="last">Protected by <code class="xref c c-type docutils literal"><span class="pre">drm_device.object_name_lock</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">import_attach</span></code></dt>
<dd><p class="first">dma-buf attachment backing this object.</p>
<p>Any foreign dma_buf imported as a gem object has this set to the
attachment point for the device. This is invariant over the lifetime
of a gem object.</p>
<p>The <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_free_object</span></code></a> callback is responsible for cleaning
up the dma_buf attachment and references acquired at import time.</p>
<p class="last">Note that the drm gem/prime core does not depend upon drivers setting
this field any more. So for drivers where this doesn&#8217;t make sense
(e.g. virtual devices or a displaylink behind an usb bus) they can
simply leave it as NULL.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure defines the generic parts for GEM buffer objects, which are
mostly around handling mmap and userspace handles.</p>
<p>Buffer objects are often abbreviated to BO.</p>
<dl class="function">
<dt id="c.DEFINE_DRM_GEM_FOPS">
<code class="descname">DEFINE_DRM_GEM_FOPS</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_DRM_GEM_FOPS" title="Permalink to this definition">Â¶</a></dt>
<dd><p>macro to generate file operations for GEM drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name for the generated structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro autogenerates a suitable <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> for GEM based
drivers, which can be assigned to <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.fops</span></code></a>. Note that this structure
cannot be shared between drivers, because it contains a reference to the
current module using THIS_MODULE.</p>
<p>Note that the declaration is already marked as static - if you need a
non-static version of this you&#8217;re probably doing it wrong and will break the
THIS_MODULE reference by accident.</p>
<dl class="function">
<dt id="c.drm_gem_object_get">
void <code class="descname">drm_gem_object_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>acquire a GEM buffer object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function acquires an additional reference to <strong>obj</strong>. It is illegal to
call this without already holding a reference. No locks required.</p>
<dl class="function">
<dt id="c.__drm_gem_object_put">
void <code class="descname">__drm_gem_object_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_gem_object_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>raw function to release a GEM buffer object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is meant to be used by drivers which are not encumbered with
<code class="xref c c-type docutils literal"><span class="pre">drm_device.struct_mutex</span></code> legacy locking and which are using the
gem_free_object_unlocked callback. It avoids all the locking checks and
locking overhead of <a class="reference internal" href="#c.drm_gem_object_put" title="drm_gem_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put()</span></code></a> and <a class="reference internal" href="#c.drm_gem_object_put_unlocked" title="drm_gem_object_put_unlocked"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put_unlocked()</span></code></a>.</p>
<p>Drivers should never call this directly in their code. Instead they should
wrap it up into a <code class="docutils literal"><span class="pre">driver_gem_object_put(struct</span> <span class="pre">driver_gem_object</span> <span class="pre">*obj)</span></code>
wrapper function, and use that. Shared code should never call this, to
avoid breaking drivers by accident which still depend upon
<code class="xref c c-type docutils literal"><span class="pre">drm_device.struct_mutex</span></code> locking.</p>
<dl class="function">
<dt id="c.drm_gem_object_reference">
void <code class="descname">drm_gem_object_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_reference" title="Permalink to this definition">Â¶</a></dt>
<dd><p>acquire a GEM buffer object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_gem_object_get" title="drm_gem_object_get"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.__drm_gem_object_unreference">
void <code class="descname">__drm_gem_object_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_gem_object_unreference" title="Permalink to this definition">Â¶</a></dt>
<dd><p>raw function to release a GEM buffer object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.__drm_gem_object_put" title="__drm_gem_object_put"><code class="xref c c-func docutils literal"><span class="pre">__drm_gem_object_put()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_gem_object_unreference_unlocked">
void <code class="descname">drm_gem_object_unreference_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_unreference_unlocked" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release a GEM buffer object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_gem_object_put_unlocked" title="drm_gem_object_put_unlocked"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put_unlocked()</span></code></a> and should
not be used by new code.</p>
<dl class="function">
<dt id="c.drm_gem_object_unreference">
void <code class="descname">drm_gem_object_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_unreference" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release a GEM buffer object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_gem_object_put" title="drm_gem_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_gem_object_init">
int <code class="descname">drm_gem_object_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize an allocated shmem-backed GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device the object should be initialized for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>drm_gem_object to initialize</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>object size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an already allocated GEM object of the specified size with
shmfs backing store.</p>
<dl class="function">
<dt id="c.drm_gem_private_object_init">
void <code class="descname">drm_gem_private_object_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_private_object_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize an allocated private GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device the object should be initialized for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>drm_gem_object to initialize</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>object size</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize an already allocated GEM object of the specified size with
no GEM provided backing store. Instead the caller is responsible for
backing the object and handling it.</p>
<dl class="function">
<dt id="c.drm_gem_handle_delete">
int <code class="descname">drm_gem_handle_delete</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;filp</em>, u32<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_handle_delete" title="Permalink to this definition">Â¶</a></dt>
<dd><p>deletes the given file-private handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>drm file-private structure to use for the handle look up</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">handle</span></code></dt>
<dd>userspace handle to delete</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the GEM handle from the <strong>filp</strong> lookup table which has been added with
<a class="reference internal" href="#c.drm_gem_handle_create" title="drm_gem_handle_create"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_handle_create()</span></code></a>. If this is the last handle also cleans up linked
resources like GEM names.</p>
<dl class="function">
<dt id="c.drm_gem_dumb_map_offset">
int <code class="descname">drm_gem_dumb_map_offset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file</em>, struct drm_device *<em>&nbsp;dev</em>, u32<em>&nbsp;handle</em>, u64 *<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dumb_map_offset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return the fake mmap offset for a gem object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>drm file-private structure containing the gem object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>corresponding drm_device</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">handle</span></code></dt>
<dd>gem object handle</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">offset</span></code></dt>
<dd>return location for the fake mmap offset</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implements the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_map_offset</span></code></a> kms driver callback for
drivers which use gem to manage their backing storage.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_dumb_destroy">
int <code class="descname">drm_gem_dumb_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file</em>, struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dumb_destroy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dumb fb callback helper for gem based drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>drm file-private structure to remove the dumb handle from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>corresponding drm_device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">handle</span></code></dt>
<dd>the dumb handle to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This implements the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_destroy</span></code></a> kms driver callback for drivers
which use gem to manage their backing storage.</p>
<dl class="function">
<dt id="c.drm_gem_handle_create">
int <code class="descname">drm_gem_handle_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, u32 *<em>&nbsp;handlep</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_handle_create" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a gem handle for an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file-private structure to register the handle for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>object to register</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">handlep</span></code></dt>
<dd>pionter to return the created handle to the caller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a handle for this object. This adds a handle reference to the object,
which includes a regular reference count. Callers will likely want to
dereference the object afterwards.</p>
<p>Since this publishes <strong>obj</strong> to userspace it must be fully set up by this point,
drivers must call this last in their buffer object creation callbacks.</p>
<dl class="function">
<dt id="c.drm_gem_free_mmap_offset">
void <code class="descname">drm_gem_free_mmap_offset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_free_mmap_offset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release a fake mmap offset for an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>obj in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine frees fake offsets allocated by <a class="reference internal" href="#c.drm_gem_create_mmap_offset" title="drm_gem_create_mmap_offset"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_create_mmap_offset()</span></code></a>.</p>
<p>Note that <a class="reference internal" href="#c.drm_gem_object_release" title="drm_gem_object_release"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_release()</span></code></a> already calls this function, so drivers
don&#8217;t have to take care of releasing the mmap offset themselves when freeing
the GEM object.</p>
<dl class="function">
<dt id="c.drm_gem_create_mmap_offset_size">
int <code class="descname">drm_gem_create_mmap_offset_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_create_mmap_offset_size" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a fake mmap offset for an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>obj in question</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>the virtual size</dd>
</dl>
<p><strong>Description</strong></p>
<p>GEM memory mapping works by handing back to userspace a fake mmap offset
it can use in a subsequent mmap(2) call.  The DRM core code then looks
up the object based on the offset and sets up the various memory mapping
structures.</p>
<p>This routine allocates and attaches a fake offset for <strong>obj</strong>, in cases where
the virtual size differs from the physical size (ie. <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal"><span class="pre">drm_gem_object.size</span></code></a>).
Otherwise just use <a class="reference internal" href="#c.drm_gem_create_mmap_offset" title="drm_gem_create_mmap_offset"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_create_mmap_offset()</span></code></a>.</p>
<p>This function is idempotent and handles an already allocated mmap offset
transparently. Drivers do not need to check for this case.</p>
<dl class="function">
<dt id="c.drm_gem_create_mmap_offset">
int <code class="descname">drm_gem_create_mmap_offset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_create_mmap_offset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a fake mmap offset for an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>obj in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>GEM memory mapping works by handing back to userspace a fake mmap offset
it can use in a subsequent mmap(2) call.  The DRM core code then looks
up the object based on the offset and sets up the various memory mapping
structures.</p>
<p>This routine allocates and attaches a fake offset for <strong>obj</strong>.</p>
<p>Drivers can call <a class="reference internal" href="#c.drm_gem_free_mmap_offset" title="drm_gem_free_mmap_offset"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_free_mmap_offset()</span></code></a> before freeing <strong>obj</strong> to release
the fake offset again.</p>
<dl class="function">
<dt id="c.drm_gem_get_pages">
struct page ** <code class="descname">drm_gem_get_pages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_get_pages" title="Permalink to this definition">Â¶</a></dt>
<dd><p>helper to allocate backing pages for a GEM object from shmem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>obj in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>This reads the page-array of the shmem-backing storage of the given gem
object. An array of pages is returned. If a page is not allocated or
swapped-out, this will allocate/swap-in the required pages. Note that the
whole object is covered by the page-array and pinned in memory.</p>
<p>Use <a class="reference internal" href="#c.drm_gem_put_pages" title="drm_gem_put_pages"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_put_pages()</span></code></a> to release the array and unpin all pages.</p>
<p>This uses the GFP-mask set on the shmem-mapping (see <code class="xref c c-func docutils literal"><span class="pre">mapping_set_gfp_mask()</span></code>).
If you require other GFP-masks, you have to do those allocations yourself.</p>
<p>Note that you are not allowed to change gfp-zones during runtime. That is,
<code class="xref c c-func docutils literal"><span class="pre">shmem_read_mapping_page_gfp()</span></code> must be called with the same gfp_zone(gfp) as
set during initialization. If you have special zone constraints, set them
after <a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_init()</span></code></a> via <code class="xref c c-func docutils literal"><span class="pre">mapping_set_gfp_mask()</span></code>. shmem-core takes care
to keep pages in the required zone during swap-in.</p>
<dl class="function">
<dt id="c.drm_gem_put_pages">
void <code class="descname">drm_gem_put_pages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, struct page **<em>&nbsp;pages</em>, bool<em>&nbsp;dirty</em>, bool<em>&nbsp;accessed</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_put_pages" title="Permalink to this definition">Â¶</a></dt>
<dd><p>helper to free backing pages for a GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>obj in question</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>pages to free</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">dirty</span></code></dt>
<dd>if true, pages will be marked as dirty</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">accessed</span></code></dt>
<dd>if true, the pages will be marked as accessed</dd>
</dl>
<dl class="function">
<dt id="c.drm_gem_object_lookup">
struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">drm_gem_object_lookup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;filp</em>, u32<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_lookup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>look up a GEM object from it&#8217;s handle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>DRM file private date</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">handle</span></code></dt>
<dd>userspace handle</dd>
</dl>
<p><strong>Return</strong></p>
<p>A reference to the object named by the handle if such exists on <strong>filp</strong>, NULL
otherwise.</p>
<dl class="function">
<dt id="c.drm_gem_object_release">
void <code class="descname">drm_gem_object_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_release" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release GEM buffer object resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases any structures and resources used by <strong>obj</strong> and is the invers of
<a class="reference internal" href="#c.drm_gem_object_init" title="drm_gem_object_init"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_init()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_gem_object_free">
void <code class="descname">drm_gem_object_free</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_free" title="Permalink to this definition">Â¶</a></dt>
<dd><p>free a GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>kref of the object to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called after the last reference to the object has been lost.
Must be called holding <code class="xref c c-type docutils literal"><span class="pre">drm_device.struct_mutex</span></code>.</p>
<p>Frees the object</p>
<dl class="function">
<dt id="c.drm_gem_object_put_unlocked">
void <code class="descname">drm_gem_object_put_unlocked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_put_unlocked" title="Permalink to this definition">Â¶</a></dt>
<dd><p>drop a GEM buffer object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>obj</strong>. Callers must not hold the
<code class="xref c c-type docutils literal"><span class="pre">drm_device.struct_mutex</span></code> lock when calling this function.</p>
<p>See also <a class="reference internal" href="#c.__drm_gem_object_put" title="__drm_gem_object_put"><code class="xref c c-func docutils literal"><span class="pre">__drm_gem_object_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_gem_object_put">
void <code class="descname">drm_gem_object_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_object_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release a GEM buffer object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>obj</strong>. Callers must hold the
<code class="xref c c-type docutils literal"><span class="pre">drm_device.struct_mutex</span></code> lock when calling this function, even when the
driver doesn&#8217;t use <code class="xref c c-type docutils literal"><span class="pre">drm_device.struct_mutex</span></code> for anything.</p>
<p>For drivers not encumbered with legacy locking use
<a class="reference internal" href="#c.drm_gem_object_put_unlocked" title="drm_gem_object_put_unlocked"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_object_put_unlocked()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.drm_gem_vm_open">
void <code class="descname">drm_gem_vm_open</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vm_open" title="Permalink to this definition">Â¶</a></dt>
<dd><p>vma-&gt;ops-&gt;open implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>VM area structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the #vm_operations_struct <a class="reference internal" href="../media/uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> callback for GEM
drivers. This must be used together with <a class="reference internal" href="#c.drm_gem_vm_close" title="drm_gem_vm_close"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_vm_close()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_gem_vm_close">
void <code class="descname">drm_gem_vm_close</code><span class="sig-paren">(</span>struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_vm_close" title="Permalink to this definition">Â¶</a></dt>
<dd><p>vma-&gt;ops-&gt;close implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>VM area structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the #vm_operations_struct <a class="reference internal" href="../media/uapi/dvb/video-fclose.html#c.close" title="close"><code class="xref c c-func docutils literal"><span class="pre">close()</span></code></a> callback for GEM
drivers. This must be used together with <a class="reference internal" href="#c.drm_gem_vm_open" title="drm_gem_vm_open"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_vm_open()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_gem_mmap_obj">
int <code class="descname">drm_gem_mmap_obj</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, unsigned long<em>&nbsp;obj_size</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_mmap_obj" title="Permalink to this definition">Â¶</a></dt>
<dd><p>memory map a GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>the GEM object to map</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">obj_size</span></code></dt>
<dd>the object size to be mapped, in bytes</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>VMA for the area to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up the VMA to prepare mapping of the GEM object using the gem_vm_ops
provided by the driver. Depending on their requirements, drivers can either
provide a fault handler in their gem_vm_ops (in which case any accesses to
the object will be trapped, to perform migration, GTT binding, surface
register allocation, or performance monitoring), or mmap the buffer memory
synchronously after calling drm_gem_mmap_obj.</p>
<p>This function is mainly intended to implement the DMABUF mmap operation, when
the GEM object is not looked up based on its fake offset. To implement the
DRM mmap operation, drivers should use the <a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_mmap()</span></code></a> function.</p>
<p><a class="reference internal" href="#c.drm_gem_mmap_obj" title="drm_gem_mmap_obj"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_mmap_obj()</span></code></a> assumes the user is granted access to the buffer while
<a class="reference internal" href="#c.drm_gem_mmap" title="drm_gem_mmap"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_mmap()</span></code></a> prevents unprivileged users from mapping random objects. So
callers must verify access restrictions before calling this helper.</p>
<p>Return 0 or success or -EINVAL if the object size is smaller than the VMA
size, or if no gem_vm_ops are provided.</p>
<dl class="function">
<dt id="c.drm_gem_mmap">
int <code class="descname">drm_gem_mmap</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_mmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>memory map routine for GEM objects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>DRM file pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>VMA for the area to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>If a driver supports GEM object mapping, mmap calls on the DRM file
descriptor will end up here.</p>
<p>Look up the GEM object based on the offset passed in (vma-&gt;vm_pgoff will
contain the fake offset we created when the GTT map ioctl was called on
the object) and map it with a call to <a class="reference internal" href="#c.drm_gem_mmap_obj" title="drm_gem_mmap_obj"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_mmap_obj()</span></code></a>.</p>
<p>If the caller is not granted access to the buffer object, the mmap will fail
with EACCES. Please see the vma manager for more information.</p>
</div>
<div class="section" id="gem-cma-helper-functions-reference">
<h3>GEM CMA Helper Functions Reference<a class="headerlink" href="#gem-cma-helper-functions-reference" title="Permalink to this headline">Â¶</a></h3>
<p>The Contiguous Memory Allocator reserves a pool of memory at early boot
that is used to service requests for large blocks of contiguous memory.</p>
<p>The DRM GEM/CMA helpers use this allocator as a means to provide buffer
objects that are physically contiguous in memory. This is useful for
display drivers that are unable to map scattered buffers via an IOMMU.</p>
<dl class="type">
<dt id="c.drm_gem_cma_object">
struct <code class="descname">drm_gem_cma_object</code><a class="headerlink" href="#c.drm_gem_cma_object" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GEM object backed by CMA memory allocations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_gem_cma_object {
  struct drm_gem_object base;
  dma_addr_t paddr;
  struct sg_table *sgt;
  void *vaddr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base GEM object</dd>
<dt><code class="docutils literal"><span class="pre">paddr</span></code></dt>
<dd>physical address of the backing memory</dd>
<dt><code class="docutils literal"><span class="pre">sgt</span></code></dt>
<dd>scatter/gather table for imported PRIME buffers. The table can have
more than one entry but they are guaranteed to have contiguous
DMA addresses.</dd>
<dt><code class="docutils literal"><span class="pre">vaddr</span></code></dt>
<dd>kernel virtual address of the backing memory</dd>
</dl>
<dl class="function">
<dt id="c.DEFINE_DRM_GEM_CMA_FOPS">
<code class="descname">DEFINE_DRM_GEM_CMA_FOPS</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DEFINE_DRM_GEM_CMA_FOPS" title="Permalink to this definition">Â¶</a></dt>
<dd><p>macro to generate file operations for CMA drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name for the generated structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro autogenerates a suitable <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> for CMA based
drivers, which can be assigned to <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.fops</span></code></a>. Note that this structure
cannot be shared between drivers, because it contains a reference to the
current module using THIS_MODULE.</p>
<p>Note that the declaration is already marked as static - if you need a
non-static version of this you&#8217;re probably doing it wrong and will break the
THIS_MODULE reference by accident.</p>
<dl class="function">
<dt id="c.drm_gem_cma_create">
struct <a class="reference internal" href="#c.drm_gem_cma_object" title="drm_gem_cma_object">drm_gem_cma_object</a> * <code class="descname">drm_gem_cma_create</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;drm</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_create" title="Permalink to this definition">Â¶</a></dt>
<dd><p>allocate an object with the given size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">drm</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the object to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a CMA GEM object and allocates a contiguous chunk of
memory as backing store. The backing memory has the writecombine attribute
set.</p>
<p><strong>Return</strong></p>
<p>A struct drm_gem_cma_object * on success or an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>-encoded negative
error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_cma_free_object">
void <code class="descname">drm_gem_cma_free_object</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;gem_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_free_object" title="Permalink to this definition">Â¶</a></dt>
<dd><p>free resources associated with a CMA GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">gem_obj</span></code></dt>
<dd>GEM object to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function frees the backing memory of the CMA GEM object, cleans up the
GEM object state and frees the memory used to store the object itself.
Drivers using the CMA helpers should set this as their
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_free_object_unlocked</span></code></a> callback.</p>
<dl class="function">
<dt id="c.drm_gem_cma_dumb_create_internal">
int <code class="descname">drm_gem_cma_dumb_create_internal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, struct drm_device *<em>&nbsp;drm</em>, struct drm_mode_create_dumb *<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_dumb_create_internal" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a dumb buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file-private structure to create the dumb buffer for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">drm</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span> <span class="pre">*</span> <span class="pre">args</span></code></dt>
<dd>IOCTL data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This aligns the pitch and size arguments to the minimum required. This is
an internal helper that can be wrapped by a driver to account for hardware
with more specific alignment requirements. It should not be used directly
as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_create</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_cma_dumb_create">
int <code class="descname">drm_gem_cma_dumb_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, struct drm_device *<em>&nbsp;drm</em>, struct drm_mode_create_dumb *<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_dumb_create" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a dumb buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>DRM file-private structure to create the dumb buffer for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">drm</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_create_dumb</span> <span class="pre">*</span> <span class="pre">args</span></code></dt>
<dd>IOCTL data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function computes the pitch of the dumb buffer and rounds it up to an
integer number of bytes per pixel. Drivers for hardware that doesn&#8217;t have
any additional restrictions on the pitch can directly use this function as
their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_create</span></code></a> callback.</p>
<p>For hardware with additional restrictions, drivers can adjust the fields
set up by userspace and pass the IOCTL data along to the
<a class="reference internal" href="#c.drm_gem_cma_dumb_create_internal" title="drm_gem_cma_dumb_create_internal"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_cma_dumb_create_internal()</span></code></a> function.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_cma_mmap">
int <code class="descname">drm_gem_cma_mmap</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_mmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>memory-map a CMA GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>VMA for the area to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements an augmented version of the GEM DRM file mmap
operation for CMA objects: In addition to the usual GEM VMA setup it
immediately faults in the entire object instead of using on-demaind
faulting. Drivers which employ the CMA helpers should use this function
as their -&gt;:c:func:<cite>mmap()</cite> handler in the DRM device file&#8217;s file_operations
structure.</p>
<p>Instead of directly referencing this function, drivers should use the
<a class="reference internal" href="#c.DEFINE_DRM_GEM_CMA_FOPS" title="DEFINE_DRM_GEM_CMA_FOPS"><code class="xref c c-func docutils literal"><span class="pre">DEFINE_DRM_GEM_CMA_FOPS()</span></code></a>.macro.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_cma_get_unmapped_area">
unsigned long <code class="descname">drm_gem_cma_get_unmapped_area</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;len</em>, unsigned long<em>&nbsp;pgoff</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_get_unmapped_area" title="Permalink to this definition">Â¶</a></dt>
<dd><p>propose address for mapping in noMMU cases</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>file object</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>memory address</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt>
<dd>buffer size</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt>
<dd>page offset</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>memory flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used in noMMU platforms to propose address mapping
for a given buffer.
It&#8217;s intended to be used as a direct handler for the struct
<code class="xref c c-type docutils literal"><span class="pre">file_operations.get_unmapped_area</span></code> operation.</p>
<p><strong>Return</strong></p>
<p>mapping address on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_cma_print_info">
void <code class="descname">drm_gem_cma_print_info</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer">drm_printer</a> *<em>&nbsp;p</em>, unsigned int<em>&nbsp;indent</em>, const struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_print_info" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Print <a class="reference internal" href="#c.drm_gem_cma_object" title="drm_gem_cma_object"><code class="xref c c-type docutils literal"><span class="pre">drm_gem_cma_object</span></code></a> info for debugfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>DRM printer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">indent</span></code></dt>
<dd>Tab indentation level</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used as the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver-&gt;gem_print_info</span></code></a> callback.
It prints paddr and vaddr for use in e.g. debugfs output.</p>
<dl class="function">
<dt id="c.drm_gem_cma_prime_get_sg_table">
struct sg_table * <code class="descname">drm_gem_cma_prime_get_sg_table</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_prime_get_sg_table" title="Permalink to this definition">Â¶</a></dt>
<dd><p>provide a scatter/gather table of pinned pages for a CMA GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function exports a scatter/gather table suitable for PRIME usage by
calling the standard DMA mapping API. Drivers using the CMA helpers should
set this as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_get_sg_table</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>A pointer to the scatter/gather table of pinned pages or NULL on failure.</p>
<dl class="function">
<dt id="c.drm_gem_cma_prime_import_sg_table">
struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">drm_gem_cma_prime_import_sg_table</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em>, struct sg_table *<em>&nbsp;sgt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_prime_import_sg_table" title="Permalink to this definition">Â¶</a></dt>
<dd><p>produce a CMA GEM object from another driver&#8217;s scatter/gather table of pinned pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to import into</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>DMA-BUF attachment</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">sgt</span></code></dt>
<dd>scatter/gather table of pinned pages</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function imports a scatter/gather table exported via DMA-BUF by
another driver. Imported buffers must be physically contiguous in memory
(i.e. the scatter/gather table must contain a single entry). Drivers that
use the CMA helpers should set this as their
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>A pointer to a newly created GEM object or an ERR_PTR-encoded negative
error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_cma_prime_mmap">
int <code class="descname">drm_gem_cma_prime_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_prime_mmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>memory-map an exported CMA GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>VMA for the area to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function maps a buffer imported via DRM PRIME into a userspace
process&#8217;s address space. Drivers that use the CMA helpers should set this
as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_mmap</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_cma_prime_vmap">
void * <code class="descname">drm_gem_cma_prime_vmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_prime_vmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>map a CMA GEM object into the kernel&#8217;s virtual address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function maps a buffer exported via DRM PRIME into the kernel&#8217;s
virtual address space. Since the CMA buffers are already mapped into the
kernel virtual address space this simply returns the cached virtual
address. Drivers using the CMA helpers should set this as their DRM
driver&#8217;s <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_vmap</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>The kernel virtual address of the CMA GEM object&#8217;s backing store.</p>
<dl class="function">
<dt id="c.drm_gem_cma_prime_vunmap">
void <code class="descname">drm_gem_cma_prime_vunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, void *<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_cma_prime_vunmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unmap a CMA GEM object from the kernel&#8217;s virtual address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>kernel virtual address where the CMA GEM object was mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a buffer exported via DRM PRIME from the kernel&#8217;s
virtual address space. This is a no-op because CMA buffers cannot be
unmapped from kernel space. Drivers using the CMA helpers should set this
as their <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_vunmap</span></code></a> callback.</p>
</div>
</div>
<div class="section" id="vma-offset-manager">
<h2>VMA Offset Manager<a class="headerlink" href="#vma-offset-manager" title="Permalink to this headline">Â¶</a></h2>
<p>The vma-manager is responsible to map arbitrary driver-dependent memory
regions into the linear user address-space. It provides offsets to the
caller which can then be used on the address_space of the drm-device. It
takes care to not overlap regions, size them appropriately and to not
confuse mm-core by inconsistent fake vm_pgoff fields.
Drivers shouldn&#8217;t use this for object placement in VMEM. This manager should
only be used to manage mappings into linear user-space VMs.</p>
<p>We use drm_mm as backend to manage object allocations. But it is highly
optimized for alloc/free calls, not lookups. Hence, we use an rb-tree to
speed up offset lookups.</p>
<p>You must not use multiple offset managers on a single address_space.
Otherwise, mm-core will be unable to tear down memory mappings as the VM will
no longer be linear.</p>
<p>This offset manager works on page-based addresses. That is, every argument
and return code (with the exception of <a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_offset_addr()</span></code></a>) is given
in number of pages, not number of bytes. That means, object sizes and offsets
must always be page-aligned (as usual).
If you want to get a valid byte-based user-space address for a given offset,
please see <a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_offset_addr()</span></code></a>.</p>
<p>Additionally to offset management, the vma offset manager also handles access
management. For every open-file context that is allowed to access a given
node, you must call <a class="reference internal" href="#c.drm_vma_node_allow" title="drm_vma_node_allow"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_allow()</span></code></a>. Otherwise, an <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> call on this
open-file with the offset of the node will fail with -EACCES. To revoke
access again, use <a class="reference internal" href="#c.drm_vma_node_revoke" title="drm_vma_node_revoke"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_revoke()</span></code></a>. However, the caller is responsible
for destroying already existing mappings, if required.</p>
<dl class="function">
<dt id="c.drm_vma_offset_exact_lookup_locked">
struct drm_vma_offset_node * <code class="descname">drm_vma_offset_exact_lookup_locked</code><span class="sig-paren">(</span>struct drm_vma_offset_manager *<em>&nbsp;mgr</em>, unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_exact_lookup_locked" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Look up node by exact address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>Manager object</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>Start address (page-based, not byte-based)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pages</span></code></dt>
<dd>Size of object (page-based)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.drm_vma_offset_lookup_locked" title="drm_vma_offset_lookup_locked"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_lookup_locked()</span></code></a> but does not allow any offset into the node.
It only returns the exact object with the given start address.</p>
<p><strong>Return</strong></p>
<p>Node at exact start address <strong>start</strong>.</p>
<dl class="function">
<dt id="c.drm_vma_offset_lock_lookup">
void <code class="descname">drm_vma_offset_lock_lookup</code><span class="sig-paren">(</span>struct drm_vma_offset_manager *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_lock_lookup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Lock lookup for extended private use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>Manager object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock VMA manager for extended lookups. Only locked VMA function calls
are allowed while holding this lock. All other contexts are blocked from VMA
until the lock is released via <a class="reference internal" href="#c.drm_vma_offset_unlock_lookup" title="drm_vma_offset_unlock_lookup"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_unlock_lookup()</span></code></a>.</p>
<p>Use this if you need to take a reference to the objects returned by
<a class="reference internal" href="#c.drm_vma_offset_lookup_locked" title="drm_vma_offset_lookup_locked"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_lookup_locked()</span></code></a> before releasing this lock again.</p>
<p>This lock must not be used for anything else than extended lookups. You must
not call any other VMA helpers while holding this lock.</p>
<p><strong>Note</strong></p>
<p>You&#8217;re in atomic-context while holding this lock!</p>
<dl class="function">
<dt id="c.drm_vma_offset_unlock_lookup">
void <code class="descname">drm_vma_offset_unlock_lookup</code><span class="sig-paren">(</span>struct drm_vma_offset_manager *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_unlock_lookup" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Unlock lookup for extended private use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>Manager object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release lookup-lock. See <a class="reference internal" href="#c.drm_vma_offset_lock_lookup" title="drm_vma_offset_lock_lookup"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_lock_lookup()</span></code></a> for more information.</p>
<dl class="function">
<dt id="c.drm_vma_node_reset">
void <code class="descname">drm_vma_node_reset</code><span class="sig-paren">(</span>struct drm_vma_offset_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_reset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Initialize or reset node object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Node to initialize or reset</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset a node to its initial state. This must be called before using it with
any VMA offset manager.</p>
<p>This must not be called on an already allocated node, or you will leak
memory.</p>
<dl class="function">
<dt id="c.drm_vma_node_start">
unsigned long <code class="descname">drm_vma_node_start</code><span class="sig-paren">(</span>const struct drm_vma_offset_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_start" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return start address for page-based addressing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Node to inspect</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the start address of the given node. This can be used as offset into
the linear VM space that is provided by the VMA offset manager. Note that
this can only be used for page-based addressing. If you need a proper offset
for user-space mappings, you must apply &#8220;&lt;&lt; PAGE_SHIFT&#8221; or use the
<a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_offset_addr()</span></code></a> helper instead.</p>
<p><strong>Return</strong></p>
<p>Start address of <strong>node</strong> for page-based addressing. 0 if the node does not
have an offset allocated.</p>
<dl class="function">
<dt id="c.drm_vma_node_size">
unsigned long <code class="descname">drm_vma_node_size</code><span class="sig-paren">(</span>struct drm_vma_offset_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_size" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return size (page-based)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Node to inspect</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the size as number of pages for the given node. This is the same size
that was passed to <a class="reference internal" href="#c.drm_vma_offset_add" title="drm_vma_offset_add"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_add()</span></code></a>. If no offset is allocated for the
node, this is 0.</p>
<p><strong>Return</strong></p>
<p>Size of <strong>node</strong> as number of pages. 0 if the node does not have an offset
allocated.</p>
<dl class="function">
<dt id="c.drm_vma_node_offset_addr">
__u64 <code class="descname">drm_vma_node_offset_addr</code><span class="sig-paren">(</span>struct drm_vma_offset_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_offset_addr" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return sanitized offset for user-space mmaps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Linked offset node</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.drm_vma_node_start" title="drm_vma_node_start"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_start()</span></code></a> but returns the address as a valid offset that
can be used for user-space mappings during <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code>.
This must not be called on unlinked nodes.</p>
<p><strong>Return</strong></p>
<p>Offset of <strong>node</strong> for byte-based addressing. 0 if the node does not have an
object allocated.</p>
<dl class="function">
<dt id="c.drm_vma_node_unmap">
void <code class="descname">drm_vma_node_unmap</code><span class="sig-paren">(</span>struct drm_vma_offset_node *<em>&nbsp;node</em>, struct address_space *<em>&nbsp;file_mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_unmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Unmap offset node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Offset node</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span> <span class="pre">*</span> <span class="pre">file_mapping</span></code></dt>
<dd>Address space to unmap <strong>node</strong> from</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmap all userspace mappings for a given offset node. The mappings must be
associated with the <strong>file_mapping</strong> address-space. If no offset exists
nothing is done.</p>
<p>This call is unlocked. The caller must guarantee that <a class="reference internal" href="#c.drm_vma_offset_remove" title="drm_vma_offset_remove"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_remove()</span></code></a>
is not called on this node concurrently.</p>
<dl class="function">
<dt id="c.drm_vma_node_verify_access">
int <code class="descname">drm_vma_node_verify_access</code><span class="sig-paren">(</span>struct drm_vma_offset_node *<em>&nbsp;node</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_verify_access" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Access verification helper for TTM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Offset node</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">tag</span></code></dt>
<dd>Tag of file to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>This checks whether <strong>tag</strong> is granted access to <strong>node</strong>. It is the same as
<a class="reference internal" href="#c.drm_vma_node_is_allowed" title="drm_vma_node_is_allowed"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_is_allowed()</span></code></a> but suitable as drop-in helper for TTM
<code class="xref c c-func docutils literal"><span class="pre">verify_access()</span></code> callbacks.</p>
<p><strong>Return</strong></p>
<p>0 if access is granted, -EACCES otherwise.</p>
<dl class="function">
<dt id="c.drm_vma_offset_manager_init">
void <code class="descname">drm_vma_offset_manager_init</code><span class="sig-paren">(</span>struct drm_vma_offset_manager *<em>&nbsp;mgr</em>, unsigned long<em>&nbsp;page_offset</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_manager_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Initialize new offset-manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>Manager object</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_offset</span></code></dt>
<dd>Offset of available memory area (page-based)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>Size of available address space range (page-based)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a new offset-manager. The offset and area size available for the
manager are given as <strong>page_offset</strong> and <strong>size</strong>. Both are interpreted as
page-numbers, not bytes.</p>
<p>Adding/removing nodes from the manager is locked internally and protected
against concurrent access. However, node allocation and destruction is left
for the caller. While calling into the vma-manager, a given node must
always be guaranteed to be referenced.</p>
<dl class="function">
<dt id="c.drm_vma_offset_manager_destroy">
void <code class="descname">drm_vma_offset_manager_destroy</code><span class="sig-paren">(</span>struct drm_vma_offset_manager *<em>&nbsp;mgr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_manager_destroy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Destroy offset manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>Manager object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Destroy an object manager which was previously created via
<a class="reference internal" href="#c.drm_vma_offset_manager_init" title="drm_vma_offset_manager_init"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_manager_init()</span></code></a>. The caller must remove all allocated nodes
before destroying the manager. Otherwise, drm_mm will refuse to free the
requested resources.</p>
<p>The manager must not be accessed after this function is called.</p>
<dl class="function">
<dt id="c.drm_vma_offset_lookup_locked">
struct drm_vma_offset_node * <code class="descname">drm_vma_offset_lookup_locked</code><span class="sig-paren">(</span>struct drm_vma_offset_manager *<em>&nbsp;mgr</em>, unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_lookup_locked" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find node in offset space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>Manager object</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>Start address for object (page-based)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pages</span></code></dt>
<dd>Size of object (page-based)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a node given a start address and object size. This returns the _best_
match for the given node. That is, <strong>start</strong> may point somewhere into a valid
region and the given node will be returned, as long as the node spans the
whole requested area (given the size in number of pages as <strong>pages</strong>).</p>
<p>Note that before lookup the vma offset manager lookup lock must be acquired
with <a class="reference internal" href="#c.drm_vma_offset_lock_lookup" title="drm_vma_offset_lock_lookup"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_lock_lookup()</span></code></a>. See there for an example. This can then be
used to implement weakly referenced lookups using <code class="xref c c-func docutils literal"><span class="pre">kref_get_unless_zero()</span></code>.</p>
<p><strong>Example</strong></p>
<div class="highlight-none"><div class="highlight"><pre>drm_vma_offset_lock_lookup(mgr);
node = drm_vma_offset_lookup_locked(mgr);
if (node)
    kref_get_unless_zero(container_of(node, sth, entr));
drm_vma_offset_unlock_lookup(mgr);
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>Returns NULL if no suitable node can be found. Otherwise, the best match
is returned. It&#8217;s the caller&#8217;s responsibility to make sure the node doesn&#8217;t
get destroyed before the caller can access it.</p>
<dl class="function">
<dt id="c.drm_vma_offset_add">
int <code class="descname">drm_vma_offset_add</code><span class="sig-paren">(</span>struct drm_vma_offset_manager *<em>&nbsp;mgr</em>, struct drm_vma_offset_node *<em>&nbsp;node</em>, unsigned long<em>&nbsp;pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_add" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add offset node to manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>Manager object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Node to be added</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pages</span></code></dt>
<dd>Allocation size visible to user-space (in number of pages)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a node to the offset-manager. If the node was already added, this does
nothing and return 0. <strong>pages</strong> is the size of the object given in number of
pages.
After this call succeeds, you can access the offset of the node until it
is removed again.</p>
<p>If this call fails, it is safe to retry the operation or call
<a class="reference internal" href="#c.drm_vma_offset_remove" title="drm_vma_offset_remove"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_remove()</span></code></a>, anyway. However, no cleanup is required in that
case.</p>
<p><strong>pages</strong> is not required to be the same size as the underlying memory object
that you want to map. It only limits the size that user-space can map into
their address space.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_vma_offset_remove">
void <code class="descname">drm_vma_offset_remove</code><span class="sig-paren">(</span>struct drm_vma_offset_manager *<em>&nbsp;mgr</em>, struct drm_vma_offset_node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_offset_remove" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove offset node from manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_manager</span> <span class="pre">*</span> <span class="pre">mgr</span></code></dt>
<dd>Manager object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Node to be removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a node from the offset manager. If the node wasn&#8217;t added before, this
does nothing. After this call returns, the offset and size will be 0 until a
new offset is allocated via <a class="reference internal" href="#c.drm_vma_offset_add" title="drm_vma_offset_add"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_add()</span></code></a> again. Helper functions like
<a class="reference internal" href="#c.drm_vma_node_start" title="drm_vma_node_start"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_start()</span></code></a> and <a class="reference internal" href="#c.drm_vma_node_offset_addr" title="drm_vma_node_offset_addr"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_offset_addr()</span></code></a> will return 0 if no
offset is allocated.</p>
<dl class="function">
<dt id="c.drm_vma_node_allow">
int <code class="descname">drm_vma_node_allow</code><span class="sig-paren">(</span>struct drm_vma_offset_node *<em>&nbsp;node</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_allow" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add open-file to list of allowed users</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Node to modify</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">tag</span></code></dt>
<dd>Tag of file to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>tag</strong> to the list of allowed open-files for this node. If <strong>tag</strong> is
already on this list, the ref-count is incremented.</p>
<p>The list of allowed-users is preserved across <a class="reference internal" href="#c.drm_vma_offset_add" title="drm_vma_offset_add"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_add()</span></code></a> and
<a class="reference internal" href="#c.drm_vma_offset_remove" title="drm_vma_offset_remove"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_offset_remove()</span></code></a> calls. You may even call it if the node is currently
not added to any offset-manager.</p>
<p>You must remove all open-files the same number of times as you added them
before destroying the node. Otherwise, you will leak memory.</p>
<p>This is locked against concurrent access internally.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on internal failure (out-of-mem)</p>
<dl class="function">
<dt id="c.drm_vma_node_revoke">
void <code class="descname">drm_vma_node_revoke</code><span class="sig-paren">(</span>struct drm_vma_offset_node *<em>&nbsp;node</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_revoke" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove open-file from list of allowed users</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Node to modify</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">tag</span></code></dt>
<dd>Tag of file to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement the ref-count of <strong>tag</strong> in the list of allowed open-files on <strong>node</strong>.
If the ref-count drops to zero, remove <strong>tag</strong> from the list. You must call
this once for every <a class="reference internal" href="#c.drm_vma_node_allow" title="drm_vma_node_allow"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_allow()</span></code></a> on <strong>tag</strong>.</p>
<p>This is locked against concurrent access internally.</p>
<p>If <strong>tag</strong> is not on the list, nothing is done.</p>
<dl class="function">
<dt id="c.drm_vma_node_is_allowed">
bool <code class="descname">drm_vma_node_is_allowed</code><span class="sig-paren">(</span>struct drm_vma_offset_node *<em>&nbsp;node</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;tag</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vma_node_is_allowed" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Check whether an open-file is granted access</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_vma_offset_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>Node to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">tag</span></code></dt>
<dd>Tag of file to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search the list in <strong>node</strong> whether <strong>tag</strong> is currently on the list of allowed
open-files (see <a class="reference internal" href="#c.drm_vma_node_allow" title="drm_vma_node_allow"><code class="xref c c-func docutils literal"><span class="pre">drm_vma_node_allow()</span></code></a>).</p>
<p>This is locked against concurrent access internally.</p>
<p><strong>Return</strong></p>
<p>true iff <strong>filp</strong> is on the list</p>
</div>
<div class="section" id="prime-buffer-sharing">
<span id="id1"></span><h2>PRIME Buffer Sharing<a class="headerlink" href="#prime-buffer-sharing" title="Permalink to this headline">Â¶</a></h2>
<p>PRIME is the cross device buffer sharing framework in drm, originally
created for the OPTIMUS range of multi-gpu platforms. To userspace PRIME
buffers are dma-buf based file descriptors.</p>
<div class="section" id="overview-and-driver-interface">
<h3>Overview and Driver Interface<a class="headerlink" href="#overview-and-driver-interface" title="Permalink to this headline">Â¶</a></h3>
<p>Similar to GEM global names, PRIME file descriptors are also used to
share buffer objects across processes. They offer additional security:
as file descriptors must be explicitly sent over UNIX domain sockets to
be shared between applications, they can&#8217;t be guessed like the globally
unique GEM names.</p>
<p>Drivers that support the PRIME API must set the DRIVER_PRIME bit in the
struct <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_driver</span></code></a>
driver_features field, and implement the prime_handle_to_fd and
prime_fd_to_handle operations.</p>
<p>int (*prime_handle_to_fd)(struct drm_device *dev, struct drm_file
*file_priv, uint32_t handle, uint32_t flags, int *prime_fd); int
(*prime_fd_to_handle)(struct drm_device *dev, struct drm_file
*file_priv, int prime_fd, uint32_t *handle); Those two operations
convert a handle to a PRIME file descriptor and vice versa. Drivers must
use the kernel dma-buf buffer sharing framework to manage the PRIME file
descriptors. Similar to the mode setting API PRIME is agnostic to the
underlying buffer object manager, as long as handles are 32bit unsigned
integers.</p>
<p>While non-GEM drivers must implement the operations themselves, GEM
drivers must use the <a class="reference internal" href="#c.drm_gem_prime_handle_to_fd" title="drm_gem_prime_handle_to_fd"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_prime_handle_to_fd()</span></code></a> and
<a class="reference internal" href="#c.drm_gem_prime_fd_to_handle" title="drm_gem_prime_fd_to_handle"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_prime_fd_to_handle()</span></code></a> helper functions. Those
helpers rely on the driver gem_prime_export and gem_prime_import
operations to create a dma-buf instance from a GEM object (dma-buf
exporter role) and to create a GEM object from a dma-buf instance
(dma-buf importer role).</p>
<p>struct dma_buf * (*gem_prime_export)(struct drm_device *dev,
struct drm_gem_object *obj, int flags); struct drm_gem_object *
(*gem_prime_import)(struct drm_device *dev, struct dma_buf
*dma_buf); These two operations are mandatory for GEM drivers that
support PRIME.</p>
</div>
<div class="section" id="prime-helper-functions">
<h3>PRIME Helper Functions<a class="headerlink" href="#prime-helper-functions" title="Permalink to this headline">Â¶</a></h3>
<p>Drivers can implement <strong>gem_prime_export</strong> and <strong>gem_prime_import</strong> in terms of
simpler APIs by using the helper functions <strong>drm_gem_prime_export</strong> and
<strong>drm_gem_prime_import</strong>.  These functions implement dma-buf support in terms of
six lower-level driver callbacks:</p>
<p>Export callbacks:</p>
<blockquote>
<div><ul class="simple">
<li><strong>gem_prime_pin</strong> (optional): prepare a GEM object for exporting</li>
<li><strong>gem_prime_get_sg_table</strong>: provide a scatter/gather table of pinned pages</li>
<li><strong>gem_prime_vmap</strong>: vmap a buffer exported by your driver</li>
<li><strong>gem_prime_vunmap</strong>: vunmap a buffer exported by your driver</li>
<li><strong>gem_prime_mmap</strong> (optional): mmap a buffer exported by your driver</li>
</ul>
</div></blockquote>
<p>Import callback:</p>
<blockquote>
<div><ul class="simple">
<li><strong>gem_prime_import_sg_table</strong> (import): produce a GEM object from another
driver&#8217;s scatter/gather table</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="prime-function-references">
<h3>PRIME Function References<a class="headerlink" href="#prime-function-references" title="Permalink to this headline">Â¶</a></h3>
<dl class="type">
<dt id="c.drm_prime_file_private">
struct <code class="descname">drm_prime_file_private</code><a class="headerlink" href="#c.drm_prime_file_private" title="Permalink to this definition">Â¶</a></dt>
<dd><p>per-file tracking for PRIME</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_prime_file_private {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>This just contains the internal <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> and handle caches for each
<a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a> used by the PRIME core code.</p>
<dl class="function">
<dt id="c.drm_gem_map_attach">
int <code class="descname">drm_gem_map_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_map_attach" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dma_buf attach implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>buffer to attach device to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>buffer attachment data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates <code class="xref c c-type docutils literal"><span class="pre">drm_prime_attachment</span></code> and calls <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_pin</span></code></a> for
device specific attachment. This can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.attach</span></code></a>
callback.</p>
<p>Returns 0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_map_detach">
void <code class="descname">drm_gem_map_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_map_detach" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dma_buf detach implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>buffer to detach from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>attachment to be detached</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_attachment</span></code></a>. This can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.detach</span></code></a>
callback.</p>
<dl class="function">
<dt id="c.drm_gem_map_dma_buf">
struct sg_table * <code class="descname">drm_gem_map_dma_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_map_dma_buf" title="Permalink to this definition">Â¶</a></dt>
<dd><p>map_dma_buf implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>attachment whose scatterlist is to be returned</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>direction of DMA transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_get_sg_table</span></code></a> and then maps the scatterlist. This
can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.map_dma_buf</span></code></a> callback.</p>
<p>Returns sg_table containing the scatterlist to be returned; returns ERR_PTR
on error. May return -EINTR if it is interrupted by a signal.</p>
<dl class="function">
<dt id="c.drm_gem_unmap_dma_buf">
void <code class="descname">drm_gem_unmap_dma_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em>, struct sg_table *<em>&nbsp;sgt</em>, enum dma_data_direction<em>&nbsp;dir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_unmap_dma_buf" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unmap_dma_buf implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>attachment to unmap buffer from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">sgt</span></code></dt>
<dd>scatterlist info of the buffer to unmap</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">dir</span></code></dt>
<dd>direction of DMA transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not implemented. The unmap is done at <a class="reference internal" href="#c.drm_gem_map_detach" title="drm_gem_map_detach"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_map_detach()</span></code></a>.  This can be
used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.unmap_dma_buf</span></code></a> callback.</p>
<dl class="function">
<dt id="c.drm_gem_dmabuf_export">
struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="descname">drm_gem_dmabuf_export</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export_info" title="dma_buf_export_info">dma_buf_export_info</a> *<em>&nbsp;exp_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_export" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dma_buf export implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>parent device for the exported dmabuf</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_export_info</span> <span class="pre">*</span> <span class="pre">exp_info</span></code></dt>
<dd>the export information used by <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal"><span class="pre">dma_buf_export()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This wraps <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal"><span class="pre">dma_buf_export()</span></code></a> for use by generic GEM drivers that are using
<a class="reference internal" href="#c.drm_gem_dmabuf_release" title="drm_gem_dmabuf_release"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_dmabuf_release()</span></code></a>. In addition to calling <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export" title="dma_buf_export"><code class="xref c c-func docutils literal"><span class="pre">dma_buf_export()</span></code></a>, we take
a reference to the <code class="xref c c-type docutils literal"><span class="pre">drm_device</span></code> and the exported <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object"><code class="xref c c-type docutils literal"><span class="pre">drm_gem_object</span></code></a> (stored in
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_export_info" title="dma_buf_export_info"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_export_info.priv</span></code></a>) which is released by <a class="reference internal" href="#c.drm_gem_dmabuf_release" title="drm_gem_dmabuf_release"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_dmabuf_release()</span></code></a>.</p>
<p>Returns the new dmabuf.</p>
<dl class="function">
<dt id="c.drm_gem_dmabuf_release">
void <code class="descname">drm_gem_dmabuf_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_release" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dma_buf release implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>buffer to be released</dd>
</dl>
<p><strong>Description</strong></p>
<p>Generic release function for dma_bufs exported as PRIME buffers. GEM drivers
must use this in their dma_buf ops structure as the release callback.
<a class="reference internal" href="#c.drm_gem_dmabuf_release" title="drm_gem_dmabuf_release"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_dmabuf_release()</span></code></a> should be used in conjunction with
<a class="reference internal" href="#c.drm_gem_dmabuf_export" title="drm_gem_dmabuf_export"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_dmabuf_export()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_gem_dmabuf_vmap">
void * <code class="descname">drm_gem_dmabuf_vmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_vmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dma_buf vmap implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>buffer to be mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up a kernel virtual mapping. This can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.vmap</span></code></a>
callback.</p>
<p>Returns the kernel virtual address.</p>
<dl class="function">
<dt id="c.drm_gem_dmabuf_vunmap">
void <code class="descname">drm_gem_dmabuf_vunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, void *<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_vunmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dma_buf vunmap implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>buffer to be unmapped</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>the virtual address of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a kernel virtual mapping. This can be used as the
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.vunmap</span></code></a> callback.</p>
<dl class="function">
<dt id="c.drm_gem_dmabuf_kmap">
void * <code class="descname">drm_gem_dmabuf_kmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, unsigned long<em>&nbsp;page_num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_kmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>map implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>buffer to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_num</span></code></dt>
<dd>page number within the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not implemented. This can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.map</span></code></a> callback.</p>
<dl class="function">
<dt id="c.drm_gem_dmabuf_kunmap">
void <code class="descname">drm_gem_dmabuf_kunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, unsigned long<em>&nbsp;page_num</em>, void *<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_kunmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unmap implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>buffer to be unmapped</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">page_num</span></code></dt>
<dd>page number within the buffer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>virtual address of the buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Not implemented. This can be used as the <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.unmap</span></code></a> callback.</p>
<dl class="function">
<dt id="c.drm_gem_dmabuf_mmap">
int <code class="descname">drm_gem_dmabuf_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_dmabuf_mmap" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dma_buf mmap implementation for GEM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>buffer to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>virtual address range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides memory mapping for the buffer. This can be used as the
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.mmap</span></code></a> callback.</p>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_gem_prime_export">
struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="descname">drm_gem_prime_export</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_export" title="Permalink to this definition">Â¶</a></dt>
<dd><p>helper library implementation of the export callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device to export from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object to export</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags like DRM_CLOEXEC and DRM_RDWR</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the implementation of the gem_prime_export functions for GEM drivers
using the PRIME helpers.</p>
<dl class="function">
<dt id="c.drm_gem_prime_handle_to_fd">
int <code class="descname">drm_gem_prime_handle_to_fd</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;handle</em>, uint32_t<em>&nbsp;flags</em>, int *<em>&nbsp;prime_fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_handle_to_fd" title="Permalink to this definition">Â¶</a></dt>
<dd><p>PRIME export function for GEM drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>dev to export the buffer from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file-private structure</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">handle</span></code></dt>
<dd>buffer handle to export</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt>
<dd>flags like DRM_CLOEXEC</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">prime_fd</span></code></dt>
<dd>pointer to storage for the fd id of the create dma-buf</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the PRIME export function which must be used mandatorily by GEM
drivers to ensure correct lifetime management of the underlying GEM object.
The actual exporting from GEM object to a dma-buf is done through the
gem_prime_export driver callback.</p>
<dl class="function">
<dt id="c.drm_gem_prime_import_dev">
struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">drm_gem_prime_import_dev</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, struct <a class="reference internal" href="../driver-api/infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;attach_dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_import_dev" title="Permalink to this definition">Â¶</a></dt>
<dd><p>core implementation of the import callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device to import into</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>dma-buf object to import</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">attach_dev</span></code></dt>
<dd>struct device to dma_buf attach</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the core of drm_gem_prime_import. It&#8217;s designed to be called by
drivers who want to use a different device structure than dev-&gt;dev for
attaching via dma_buf.</p>
<dl class="function">
<dt id="c.drm_gem_prime_import">
struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">drm_gem_prime_import</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_import" title="Permalink to this definition">Â¶</a></dt>
<dd><p>helper library implementation of the import callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device to import into</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>dma-buf object to import</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the implementation of the gem_prime_import functions for GEM drivers
using the PRIME helpers.</p>
<dl class="function">
<dt id="c.drm_gem_prime_fd_to_handle">
int <code class="descname">drm_gem_prime_fd_to_handle</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, int<em>&nbsp;prime_fd</em>, uint32_t *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gem_prime_fd_to_handle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>PRIME import function for GEM drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>dev to export the buffer from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file-private structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">prime_fd</span></code></dt>
<dd>fd id of the dma-buf which should be imported</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>pointer to storage for the handle of the imported buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the PRIME import function which must be used mandatorily by GEM
drivers to ensure correct lifetime management of the underlying GEM object.
The actual importing of GEM object from the dma-buf is done through the
gem_import_export driver callback.</p>
<dl class="function">
<dt id="c.drm_prime_pages_to_sg">
struct sg_table * <code class="descname">drm_prime_pages_to_sg</code><span class="sig-paren">(</span>struct page **<em>&nbsp;pages</em>, unsigned int<em>&nbsp;nr_pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_prime_pages_to_sg" title="Permalink to this definition">Â¶</a></dt>
<dd><p>converts a page array into an sg list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>pointer to the array of page pointers to convert</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">nr_pages</span></code></dt>
<dd>length of the page vector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper creates an sg table object from a set of pages
the driver is responsible for mapping the pages into the
importers address space for use with dma_buf itself.</p>
<dl class="function">
<dt id="c.drm_prime_sg_to_page_addr_arrays">
int <code class="descname">drm_prime_sg_to_page_addr_arrays</code><span class="sig-paren">(</span>struct sg_table *<em>&nbsp;sgt</em>, struct page **<em>&nbsp;pages</em>, dma_addr_t *<em>&nbsp;addrs</em>, int<em>&nbsp;max_entries</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_prime_sg_to_page_addr_arrays" title="Permalink to this definition">Â¶</a></dt>
<dd><p>convert an sg table into a page array</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">sgt</span></code></dt>
<dd>scatter-gather table to convert</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">**</span> <span class="pre">pages</span></code></dt>
<dd>optional array of page pointers to store the page array in</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">addrs</span></code></dt>
<dd>optional array to store the dma bus address of each page</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_entries</span></code></dt>
<dd>size of both the passed-in arrays</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exports an sg table into an array of pages and addresses. This is currently
required by the TTM driver in order to do correct fault handling.</p>
<dl class="function">
<dt id="c.drm_prime_gem_destroy">
void <code class="descname">drm_prime_gem_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, struct sg_table *<em>&nbsp;sg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_prime_gem_destroy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>helper to clean up a PRIME-imported GEM object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM object which was created from a dma-buf</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>the sg-table which was pinned at import time</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the cleanup functions which GEM drivers need to call when they use
<strong>drm_gem_prime_import</strong> to import dma-bufs.</p>
</div>
</div>
<div class="section" id="drm-mm-range-allocator">
<h2>DRM MM Range Allocator<a class="headerlink" href="#drm-mm-range-allocator" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">Â¶</a></h3>
<p>drm_mm provides a simple range allocator. The drivers are free to use the
resource allocator from the linux core if it suits them, the upside of drm_mm
is that it&#8217;s in the DRM core. Which means that it&#8217;s easier to extend for
some of the crazier special purpose needs of gpus.</p>
<p>The main data struct is <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal"><span class="pre">drm_mm</span></code></a>, allocations are tracked in <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">drm_mm_node</span></code></a>.
Drivers are free to embed either of them into their own suitable
datastructures. drm_mm itself will not do any memory allocations of its own,
so if drivers choose not to embed nodes they need to still allocate them
themselves.</p>
<p>The range allocator also supports reservation of preallocated blocks. This is
useful for taking over initial mode setting configurations from the firmware,
where an object needs to be created which exactly matches the firmware&#8217;s
scanout target. As long as the range is still free it can be inserted anytime
after the allocator is initialized, which helps with avoiding looped
dependencies in the driver load sequence.</p>
<p>drm_mm maintains a stack of most recently freed holes, which of all
simplistic datastructures seems to be a fairly decent approach to clustering
allocations and avoiding too much fragmentation. This means free space
searches are O(num_holes). Given that all the fancy features drm_mm supports
something better would be fairly complex and since gfx thrashing is a fairly
steep cliff not a real concern. Removing a node again is O(1).</p>
<p>drm_mm supports a few features: Alignment and range restrictions can be
supplied. Furthermore every <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">drm_mm_node</span></code></a> has a color value (which is just an
opaque unsigned long) which in conjunction with a driver callback can be used
to implement sophisticated placement restrictions. The i915 DRM driver uses
this to implement guard pages between incompatible caching domains in the
graphics TT.</p>
<p>Two behaviors are supported for searching and allocating: bottom-up and
top-down. The default is bottom-up. Top-down allocation can be used if the
memory area has different restrictions, or just to reduce fragmentation.</p>
<p>Finally iteration helpers to walk all nodes and all holes are provided as are
some basic allocator dumpers for debugging.</p>
<p>Note that this range allocator is not thread-safe, drivers need to protect
modifications with their own locking. The idea behind this is that for a full
memory manager additional data needs to be protected anyway, hence internal
locking would be fully redundant.</p>
</div>
<div class="section" id="lru-scan-eviction-support">
<h3>LRU Scan/Eviction Support<a class="headerlink" href="#lru-scan-eviction-support" title="Permalink to this headline">Â¶</a></h3>
<p>Very often GPUs need to have continuous allocations for a given object. When
evicting objects to make space for a new one it is therefore not most
efficient when we simply start to select all objects from the tail of an LRU
until there&#8217;s a suitable hole: Especially for big objects or nodes that
otherwise have special allocation constraints there&#8217;s a good chance we evict
lots of (smaller) objects unnecessarily.</p>
<p>The DRM range allocator supports this use-case through the scanning
interfaces. First a scan operation needs to be initialized with
<a class="reference internal" href="#c.drm_mm_scan_init" title="drm_mm_scan_init"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_init()</span></code></a> or <a class="reference internal" href="#c.drm_mm_scan_init_with_range" title="drm_mm_scan_init_with_range"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_init_with_range()</span></code></a>. The driver adds
objects to the roster, probably by walking an LRU list, but this can be
freely implemented. Eviction candiates are added using
<a class="reference internal" href="#c.drm_mm_scan_add_block" title="drm_mm_scan_add_block"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_add_block()</span></code></a> until a suitable hole is found or there are no
further evictable objects. Eviction roster metadata is tracked in <a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_mm_scan</span></code></a>.</p>
<p>The driver must walk through all objects again in exactly the reverse
order to restore the allocator state. Note that while the allocator is used
in the scan mode no other operation is allowed.</p>
<p>Finally the driver evicts all objects selected (<a class="reference internal" href="#c.drm_mm_scan_remove_block" title="drm_mm_scan_remove_block"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_remove_block()</span></code></a>
reported true) in the scan, and any overlapping nodes after color adjustment
(<a class="reference internal" href="#c.drm_mm_scan_color_evict" title="drm_mm_scan_color_evict"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_color_evict()</span></code></a>). Adding and removing an object is O(1), and
since freeing a node is also O(1) the overall complexity is
O(scanned_objects). So like the free stack which needs to be walked before a
scan operation even begins this is linear in the number of objects. It
doesn&#8217;t seem to hurt too badly.</p>
</div>
<div class="section" id="drm-mm-range-allocator-function-references">
<h3>DRM MM Range Allocator Function References<a class="headerlink" href="#drm-mm-range-allocator-function-references" title="Permalink to this headline">Â¶</a></h3>
<dl class="type">
<dt id="c.drm_mm_insert_mode">
enum <code class="descname">drm_mm_insert_mode</code><a class="headerlink" href="#c.drm_mm_insert_mode" title="Permalink to this definition">Â¶</a></dt>
<dd><p>control search and allocation behaviour</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_MM_INSERT_BEST</span></code></dt>
<dd><p class="first">Search for the smallest hole (within the search range) that fits
the desired node.</p>
<p class="last">Allocates the node from the bottom of the found hole.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MM_INSERT_LOW</span></code></dt>
<dd><p class="first">Search for the lowest hole (address closest to 0, within the search
range) that fits the desired node.</p>
<p class="last">Allocates the node from the bottom of the found hole.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MM_INSERT_HIGH</span></code></dt>
<dd><p class="first">Search for the highest hole (address closest to U64_MAX, within the
search range) that fits the desired node.</p>
<p class="last">Allocates the node from the <em>top</em> of the found hole. The specified
alignment for the node is applied to the base of the node
(<a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">drm_mm_node.start</span></code></a>).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MM_INSERT_EVICT</span></code></dt>
<dd><p class="first">Search for the most recently evicted hole (within the search range)
that fits the desired node. This is appropriate for use immediately
after performing an eviction scan (see <a class="reference internal" href="#c.drm_mm_scan_init" title="drm_mm_scan_init"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_init()</span></code></a>) and
removing the selected nodes to form a hole.</p>
<p class="last">Allocates the node from the bottom of the found hole.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MM_INSERT_ONCE</span></code></dt>
<dd>Only check the first hole for suitablity and report -ENOSPC
immediately otherwise, rather than check every hole until a
suitable one is found. Can only be used in conjunction with another
search method such as DRM_MM_INSERT_HIGH or DRM_MM_INSERT_LOW.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MM_INSERT_HIGHEST</span></code></dt>
<dd><p class="first">Only check the highest hole (the hole with the largest address) and
insert the node at the top of the hole or report -ENOSPC if
unsuitable.</p>
<p class="last">Does not search all holes.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MM_INSERT_LOWEST</span></code></dt>
<dd><p class="first">Only check the lowest hole (the hole with the smallest address) and
insert the node at the bottom of the hole or report -ENOSPC if
unsuitable.</p>
<p class="last">Does not search all holes.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span></code></a> range manager supports finding a suitable modes using
a number of search trees. These trees are oranised by size, by address and
in most recent eviction order. This allows the user to find either the
smallest hole to reuse, the lowest or highest address to reuse, or simply
reuse the most recent eviction that fits. When allocating the <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">drm_mm_node</span></code></a>
from within the hole, the <a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode"><code class="xref c c-type docutils literal"><span class="pre">drm_mm_insert_mode</span></code></a> also dictate whether to
allocate the lowest matching address or the highest.</p>
<dl class="type">
<dt id="c.drm_mm_node">
struct <code class="descname">drm_mm_node</code><a class="headerlink" href="#c.drm_mm_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>allocated block in the DRM allocator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mm_node {
  unsigned long color;
  u64 start;
  u64 size;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">color</span></code></dt>
<dd>Opaque driver-private tag.</dd>
<dt><code class="docutils literal"><span class="pre">start</span></code></dt>
<dd>Start address of the allocated block.</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>Size of the allocated block.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents an allocated block in a <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal"><span class="pre">drm_mm</span></code></a> allocator. Except for
pre-reserved nodes inserted using <a class="reference internal" href="#c.drm_mm_reserve_node" title="drm_mm_reserve_node"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_reserve_node()</span></code></a> the structure is
entirely opaque and should only be accessed through the provided funcions.
Since allocation of these nodes is entirely handled by the driver they can be
embedded.</p>
<dl class="type">
<dt id="c.drm_mm">
struct <code class="descname">drm_mm</code><a class="headerlink" href="#c.drm_mm" title="Permalink to this definition">Â¶</a></dt>
<dd><p>DRM allocator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mm {
  void (*color_adjust)(const struct drm_mm_node *node,unsigned long color, u64 *start, u64 *end);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">color_adjust</span></code></dt>
<dd>Optional driver callback to further apply restrictions on a hole. The
node argument points at the node containing the hole from which the
block would be allocated (see <a class="reference internal" href="#c.drm_mm_hole_follows" title="drm_mm_hole_follows"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_hole_follows()</span></code></a> and friends). The
other arguments are the size of the block to be allocated. The driver
can adjust the start and end as needed to e.g. insert guard pages.</dd>
</dl>
<p><strong>Description</strong></p>
<p>DRM range allocator with a few special functions and features geared towards
managing GPU memory. Except for the <strong>color_adjust</strong> callback the structure is
entirely opaque and should only be accessed through the provided functions
and macros. This structure can be embedded into larger driver structures.</p>
<dl class="type">
<dt id="c.drm_mm_scan">
struct <code class="descname">drm_mm_scan</code><a class="headerlink" href="#c.drm_mm_scan" title="Permalink to this definition">Â¶</a></dt>
<dd><p>DRM allocator eviction roaster data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mm_scan {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>This structure tracks data needed for the eviction roaster set up using
<a class="reference internal" href="#c.drm_mm_scan_init" title="drm_mm_scan_init"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_init()</span></code></a>, and used with <a class="reference internal" href="#c.drm_mm_scan_add_block" title="drm_mm_scan_add_block"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_add_block()</span></code></a> and
<a class="reference internal" href="#c.drm_mm_scan_remove_block" title="drm_mm_scan_remove_block"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_remove_block()</span></code></a>. The structure is entirely opaque and should only
be accessed through the provided functions and macros. It is meant to be
allocated temporarily by the driver on the stack.</p>
<dl class="function">
<dt id="c.drm_mm_node_allocated">
bool <code class="descname">drm_mm_node_allocated</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_node_allocated" title="Permalink to this definition">Â¶</a></dt>
<dd><p>checks whether a node is allocated</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>drm_mm_node to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers are required to clear a node prior to using it with the
drm_mm range manager.</p>
<p>Drivers should use this helper for proper encapsulation of drm_mm
internals.</p>
<p><strong>Return</strong></p>
<p>True if the <strong>node</strong> is allocated.</p>
<dl class="function">
<dt id="c.drm_mm_initialized">
bool <code class="descname">drm_mm_initialized</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_initialized" title="Permalink to this definition">Â¶</a></dt>
<dd><p>checks whether an allocator is initialized</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should clear the struct drm_mm prior to initialisation if they
want to use this function.</p>
<p>Drivers should use this helper for proper encapsulation of drm_mm
internals.</p>
<p><strong>Return</strong></p>
<p>True if the <strong>mm</strong> is initialized.</p>
<dl class="function">
<dt id="c.drm_mm_hole_follows">
bool <code class="descname">drm_mm_hole_follows</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_hole_follows" title="Permalink to this definition">Â¶</a></dt>
<dd><p>checks whether a hole follows this node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>drm_mm_node to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Holes are embedded into the drm_mm using the tail of a drm_mm_node.
If you wish to know whether a hole follows this particular node,
query this function. See also <a class="reference internal" href="#c.drm_mm_hole_node_start" title="drm_mm_hole_node_start"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_hole_node_start()</span></code></a> and
<a class="reference internal" href="#c.drm_mm_hole_node_end" title="drm_mm_hole_node_end"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_hole_node_end()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>True if a hole follows the <strong>node</strong>.</p>
<dl class="function">
<dt id="c.drm_mm_hole_node_start">
u64 <code class="descname">drm_mm_hole_node_start</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;hole_node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_hole_node_start" title="Permalink to this definition">Â¶</a></dt>
<dd><p>computes the start of the hole following <strong>node</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">hole_node</span></code></dt>
<dd>drm_mm_node which implicitly tracks the following hole</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for driver-specific debug dumpers. Otherwise drivers should
not inspect holes themselves. Drivers must check first whether a hole indeed
follows by looking at <a class="reference internal" href="#c.drm_mm_hole_follows" title="drm_mm_hole_follows"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_hole_follows()</span></code></a></p>
<p><strong>Return</strong></p>
<p>Start of the subsequent hole.</p>
<dl class="function">
<dt id="c.drm_mm_hole_node_end">
u64 <code class="descname">drm_mm_hole_node_end</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;hole_node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_hole_node_end" title="Permalink to this definition">Â¶</a></dt>
<dd><p>computes the end of the hole following <strong>node</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">hole_node</span></code></dt>
<dd>drm_mm_node which implicitly tracks the following hole</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for driver-specific debug dumpers. Otherwise drivers should
not inspect holes themselves. Drivers must check first whether a hole indeed
follows by looking at <a class="reference internal" href="#c.drm_mm_hole_follows" title="drm_mm_hole_follows"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_hole_follows()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>End of the subsequent hole.</p>
<dl class="function">
<dt id="c.drm_mm_nodes">
<code class="descname">drm_mm_nodes</code><span class="sig-paren">(</span><em>mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_nodes" title="Permalink to this definition">Â¶</a></dt>
<dd><p>list of nodes under the drm_mm range manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mm</span></code></dt>
<dd>the struct drm_mm range manger</dd>
</dl>
<p><strong>Description</strong></p>
<p>As the drm_mm range manager hides its node_list deep with its
structure, extracting it looks painful and repetitive. This is
not expected to be used outside of the <a class="reference internal" href="#c.drm_mm_for_each_node" title="drm_mm_for_each_node"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_for_each_node()</span></code></a>
macros and similar internal functions.</p>
<p><strong>Return</strong></p>
<p>The node list, may be empty.</p>
<dl class="function">
<dt id="c.drm_mm_for_each_node">
<code class="descname">drm_mm_for_each_node</code><span class="sig-paren">(</span><em>entry</em>, <em>mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_for_each_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterator to walk over all allocated nodes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">entry</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span></code></a> to assign to in each iteration step</dd>
<dt><code class="docutils literal"><span class="pre">mm</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal"><span class="pre">drm_mm</span></code></a> allocator to walk</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all nodes in the range allocator. It is implemented
with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal"><span class="pre">list_for_each()</span></code></a>, so not save against removal of elements.</p>
<dl class="function">
<dt id="c.drm_mm_for_each_node_safe">
<code class="descname">drm_mm_for_each_node_safe</code><span class="sig-paren">(</span><em>entry</em>, <em>next</em>, <em>mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_for_each_node_safe" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterator to walk over all allocated nodes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">entry</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span></code></a> to assign to in each iteration step</dd>
<dt><code class="docutils literal"><span class="pre">next</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span></code></a> to store the next step</dd>
<dt><code class="docutils literal"><span class="pre">mm</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal"><span class="pre">drm_mm</span></code></a> allocator to walk</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all nodes in the range allocator. It is implemented
with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each_safe" title="list_for_each_safe"><code class="xref c c-func docutils literal"><span class="pre">list_for_each_safe()</span></code></a>, so save against removal of elements.</p>
<dl class="function">
<dt id="c.drm_mm_for_each_hole">
<code class="descname">drm_mm_for_each_hole</code><span class="sig-paren">(</span><em>pos</em>, <em>mm</em>, <em>hole_start</em>, <em>hole_end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_for_each_hole" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterator to walk over all holes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pos</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">drm_mm_node</span></code></a> used internally to track progress</dd>
<dt><code class="docutils literal"><span class="pre">mm</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal"><span class="pre">drm_mm</span></code></a> allocator to walk</dd>
<dt><code class="docutils literal"><span class="pre">hole_start</span></code></dt>
<dd>ulong variable to assign the hole start to on each iteration</dd>
<dt><code class="docutils literal"><span class="pre">hole_end</span></code></dt>
<dd>ulong variable to assign the hole end to on each iteration</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all holes in the range allocator. It is implemented
with <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal"><span class="pre">list_for_each()</span></code></a>, so not save against removal of elements. <strong>entry</strong> is used
internally and will not reflect a real drm_mm_node for the very first hole.
Hence users of this iterator may not access it.</p>
<p>Implementation Note:
We need to inline list_for_each_entry in order to be able to set hole_start
and hole_end on each iteration while keeping the macro sane.</p>
<dl class="function">
<dt id="c.drm_mm_insert_node_generic">
int <code class="descname">drm_mm_insert_node_generic</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em>, struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;node</em>, u64<em>&nbsp;size</em>, u64<em>&nbsp;alignment</em>, unsigned long<em>&nbsp;color</em>, enum <a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode">drm_mm_insert_mode</a><em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_insert_node_generic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>search for space and insert <strong>node</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm to allocate from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>preallocate node to insert</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">size</span></code></dt>
<dd>size of the allocation</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt>
<dd>alignment of the allocation</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt>
<dd>opaque tag value to use for this node</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_mm_insert_mode</span> <span class="pre">mode</span></code></dt>
<dd>fine-tune the allocation search and placement</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified version of <a class="reference internal" href="#c.drm_mm_insert_node_in_range" title="drm_mm_insert_node_in_range"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_insert_node_in_range()</span></code></a> with no
range restrictions applied.</p>
<p>The preallocated node must be cleared to 0.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if there&#8217;s no suitable hole.</p>
<dl class="function">
<dt id="c.drm_mm_insert_node">
int <code class="descname">drm_mm_insert_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em>, struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;node</em>, u64<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_insert_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>search for space and insert <strong>node</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm to allocate from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>preallocate node to insert</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">size</span></code></dt>
<dd>size of the allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified version of <a class="reference internal" href="#c.drm_mm_insert_node_generic" title="drm_mm_insert_node_generic"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_insert_node_generic()</span></code></a> with <strong>color</strong> set
to 0.</p>
<p>The preallocated node must be cleared to 0.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if there&#8217;s no suitable hole.</p>
<dl class="function">
<dt id="c.drm_mm_clean">
bool <code class="descname">drm_mm_clean</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_clean" title="Permalink to this definition">Â¶</a></dt>
<dd><p>checks whether an allocator is clean</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm allocator to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the allocator is completely free, false if there&#8217;s still a node
allocated in it.</p>
<dl class="function">
<dt id="c.drm_mm_for_each_node_in_range">
<code class="descname">drm_mm_for_each_node_in_range</code><span class="sig-paren">(</span><em>node__</em>, <em>mm__</em>, <em>start__</em>, <em>end__</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_for_each_node_in_range" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterator to walk over a range of allocated nodes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node__</span></code></dt>
<dd>drm_mm_node structure to assign to in each iteration step</dd>
<dt><code class="docutils literal"><span class="pre">mm__</span></code></dt>
<dd>drm_mm allocator to walk</dd>
<dt><code class="docutils literal"><span class="pre">start__</span></code></dt>
<dd>starting offset, the first node will overlap this</dd>
<dt><code class="docutils literal"><span class="pre">end__</span></code></dt>
<dd>ending offset, the last node will start before this (but may overlap)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterator walks over all nodes in the range allocator that lie
between <strong>start</strong> and <strong>end</strong>. It is implemented similarly to <a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal"><span class="pre">list_for_each()</span></code></a>,
but using the internal interval tree to accelerate the search for the
starting node, and so not safe against removal of elements. It assumes
that <strong>end</strong> is within (or is the upper limit of) the drm_mm allocator.
If [<strong>start</strong>, <strong>end</strong>] are beyond the range of the drm_mm, the iterator may walk
over the special _unallocated_ <a class="reference internal" href="#c.drm_mm" title="drm_mm"><code class="xref c c-type docutils literal"><span class="pre">drm_mm.head_node</span></code></a>, and may even continue
indefinitely.</p>
<dl class="function">
<dt id="c.drm_mm_scan_init">
void <code class="descname">drm_mm_scan_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan">drm_mm_scan</a> *<em>&nbsp;scan</em>, struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em>, u64<em>&nbsp;size</em>, u64<em>&nbsp;alignment</em>, unsigned long<em>&nbsp;color</em>, enum <a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode">drm_mm_insert_mode</a><em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize lru scanning</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*</span> <span class="pre">scan</span></code></dt>
<dd>scan state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm to scan</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">size</span></code></dt>
<dd>size of the allocation</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt>
<dd>alignment of the allocation</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt>
<dd>opaque tag value to use for the allocation</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_mm_insert_mode</span> <span class="pre">mode</span></code></dt>
<dd>fine-tune the allocation search and placement</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a simplified version of <a class="reference internal" href="#c.drm_mm_scan_init_with_range" title="drm_mm_scan_init_with_range"><code class="xref c c-func docutils literal"><span class="pre">drm_mm_scan_init_with_range()</span></code></a> with no range
restrictions applied.</p>
<p>This simply sets up the scanning routines with the parameters for the desired
hole.</p>
<p>Warning:
As long as the scan list is non-empty, no other operations than
adding/removing nodes to/from the scan list are allowed.</p>
<dl class="function">
<dt id="c.drm_mm_reserve_node">
int <code class="descname">drm_mm_reserve_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em>, struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_reserve_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>insert an pre-initialized node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm allocator to insert <strong>node</strong> into</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>drm_mm_node to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions inserts an already set-up <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node"><code class="xref c c-type docutils literal"><span class="pre">drm_mm_node</span></code></a> into the allocator,
meaning that start, size and color must be set by the caller. All other
fields must be cleared to 0. This is useful to initialize the allocator with
preallocated objects which must be set-up before the range allocator can be
set-up, e.g. when taking over a firmware framebuffer.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if there&#8217;s no hole where <strong>node</strong> is.</p>
<dl class="function">
<dt id="c.drm_mm_insert_node_in_range">
int <code class="descname">drm_mm_insert_node_in_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *const<em>&nbsp;mm</em>, struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *const<em>&nbsp;node</em>, u64<em>&nbsp;size</em>, u64<em>&nbsp;alignment</em>, unsigned long<em>&nbsp;color</em>, u64<em>&nbsp;range_start</em>, u64<em>&nbsp;range_end</em>, enum <a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode">drm_mm_insert_mode</a><em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_insert_node_in_range" title="Permalink to this definition">Â¶</a></dt>
<dd><p>ranged search for space and insert <strong>node</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*const</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm to allocate from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*const</span> <span class="pre">node</span></code></dt>
<dd>preallocate node to insert</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">size</span></code></dt>
<dd>size of the allocation</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt>
<dd>alignment of the allocation</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt>
<dd>opaque tag value to use for this node</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">range_start</span></code></dt>
<dd>start of the allowed range for this node</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">range_end</span></code></dt>
<dd>end of the allowed range for this node</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_mm_insert_mode</span> <span class="pre">mode</span></code></dt>
<dd>fine-tune the allocation search and placement</dd>
</dl>
<p><strong>Description</strong></p>
<p>The preallocated <strong>node</strong> must be cleared to 0.</p>
<p><strong>Return</strong></p>
<p>0 on success, -ENOSPC if there&#8217;s no suitable hole.</p>
<dl class="function">
<dt id="c.drm_mm_remove_node">
void <code class="descname">drm_mm_remove_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_remove_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove a memory node from the allocator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>drm_mm_node to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This just removes a node from its drm_mm allocator. The node does not need to
be cleared again before it can be re-inserted into this or any other drm_mm
allocator. It is a bug to call this function on a unallocated node.</p>
<dl class="function">
<dt id="c.drm_mm_replace_node">
void <code class="descname">drm_mm_replace_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;old</em>, struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;new</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_replace_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>move an allocation from <strong>old</strong> to <strong>new</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">old</span></code></dt>
<dd>drm_mm_node to remove from the allocator</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">new</span></code></dt>
<dd>drm_mm_node which should inherit <strong>old</strong>&#8216;s allocation</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is useful for when drivers embed the drm_mm_node structure and hence
can&#8217;t move allocations by reassigning pointers. It&#8217;s a combination of remove
and insert with the guarantee that the allocation start will match.</p>
<dl class="function">
<dt id="c.drm_mm_scan_init_with_range">
void <code class="descname">drm_mm_scan_init_with_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan">drm_mm_scan</a> *<em>&nbsp;scan</em>, struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em>, u64<em>&nbsp;size</em>, u64<em>&nbsp;alignment</em>, unsigned long<em>&nbsp;color</em>, u64<em>&nbsp;start</em>, u64<em>&nbsp;end</em>, enum <a class="reference internal" href="#c.drm_mm_insert_mode" title="drm_mm_insert_mode">drm_mm_insert_mode</a><em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_init_with_range" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize range-restricted lru scanning</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*</span> <span class="pre">scan</span></code></dt>
<dd>scan state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm to scan</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">size</span></code></dt>
<dd>size of the allocation</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">alignment</span></code></dt>
<dd>alignment of the allocation</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">color</span></code></dt>
<dd>opaque tag value to use for the allocation</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">start</span></code></dt>
<dd>start of the allowed range for the allocation</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">end</span></code></dt>
<dd>end of the allowed range for the allocation</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_mm_insert_mode</span> <span class="pre">mode</span></code></dt>
<dd>fine-tune the allocation search and placement</dd>
</dl>
<p><strong>Description</strong></p>
<p>This simply sets up the scanning routines with the parameters for the desired
hole.</p>
<p>Warning:
As long as the scan list is non-empty, no other operations than
adding/removing nodes to/from the scan list are allowed.</p>
<dl class="function">
<dt id="c.drm_mm_scan_add_block">
bool <code class="descname">drm_mm_scan_add_block</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan">drm_mm_scan</a> *<em>&nbsp;scan</em>, struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_add_block" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a node to the scan list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*</span> <span class="pre">scan</span></code></dt>
<dd>the active drm_mm scanner</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>drm_mm_node to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a node to the scan list that might be freed to make space for the desired
hole.</p>
<p><strong>Return</strong></p>
<p>True if a hole has been found, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mm_scan_remove_block">
bool <code class="descname">drm_mm_scan_remove_block</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan">drm_mm_scan</a> *<em>&nbsp;scan</em>, struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_remove_block" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove a node from the scan list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*</span> <span class="pre">scan</span></code></dt>
<dd>the active drm_mm scanner</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>drm_mm_node to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Nodes <strong>must</strong> be removed in exactly the reverse order from the scan list as
they have been added (e.g. using <a class="reference internal" href="../core-api/kernel-api.html#c.list_add" title="list_add"><code class="xref c c-func docutils literal"><span class="pre">list_add()</span></code></a> as they are added and then
<a class="reference internal" href="../core-api/kernel-api.html#c.list_for_each" title="list_for_each"><code class="xref c c-func docutils literal"><span class="pre">list_for_each()</span></code></a> over that eviction list to remove), otherwise the internal
state of the memory manager will be corrupted.</p>
<p>When the scan list is empty, the selected memory nodes can be freed. An
immediately following <code class="xref c c-func docutils literal"><span class="pre">drm_mm_insert_node_in_range_generic()</span></code> or one of the
simpler versions of that function with !DRM_MM_SEARCH_BEST will then return
the just freed block (because its at the top of the free_stack list).</p>
<p><strong>Return</strong></p>
<p>True if this block should be evicted, false otherwise. Will always
return false when no hole has been found.</p>
<dl class="function">
<dt id="c.drm_mm_scan_color_evict">
struct <a class="reference internal" href="#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> * <code class="descname">drm_mm_scan_color_evict</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm_scan" title="drm_mm_scan">drm_mm_scan</a> *<em>&nbsp;scan</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_scan_color_evict" title="Permalink to this definition">Â¶</a></dt>
<dd><p>evict overlapping nodes on either side of hole</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_scan</span> <span class="pre">*</span> <span class="pre">scan</span></code></dt>
<dd>drm_mm scan with target hole</dd>
</dl>
<p><strong>Description</strong></p>
<p>After completing an eviction scan and removing the selected nodes, we may
need to remove a few more nodes from either side of the target hole if
mm.color_adjust is being used.</p>
<p><strong>Return</strong></p>
<p>A node to evict, or NULL if there are no overlapping nodes.</p>
<dl class="function">
<dt id="c.drm_mm_init">
void <code class="descname">drm_mm_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em>, u64<em>&nbsp;start</em>, u64<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize a drm-mm allocator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>the drm_mm structure to initialize</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">start</span></code></dt>
<dd>start of the range managed by <strong>mm</strong></dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">size</span></code></dt>
<dd>end of the range managed by <strong>mm</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that <strong>mm</strong> must be cleared to 0 before calling this function.</p>
<dl class="function">
<dt id="c.drm_mm_takedown">
void <code class="descname">drm_mm_takedown</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_takedown" title="Permalink to this definition">Â¶</a></dt>
<dd><p>clean up a drm_mm allocator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm allocator to clean up</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that it is a bug to call this function on an allocator which is not
clean.</p>
<dl class="function">
<dt id="c.drm_mm_print">
void <code class="descname">drm_mm_print</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_mm" title="drm_mm">drm_mm</a> *<em>&nbsp;mm</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer">drm_printer</a> *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mm_print" title="Permalink to this definition">Â¶</a></dt>
<dd><p>print allocator state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mm</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>drm_mm allocator to print</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>DRM printer to use</dd>
</dl>
</div>
</div>
<div class="section" id="drm-cache-handling">
<h2>DRM Cache Handling<a class="headerlink" href="#drm-cache-handling" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.drm_clflush_pages">
void <code class="descname">drm_clflush_pages</code><span class="sig-paren">(</span>struct page *<em>&nbsp;pages</em>, unsigned long<em>&nbsp;num_pages</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_clflush_pages" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Flush dcache lines of a set of pages.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span> <span class="pre">*</span> <span class="pre">pages</span></code></dt>
<dd>List of pages to be flushed.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">num_pages</span></code></dt>
<dd>Number of pages in the array.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush every data cache line entry that points to an address belonging
to a page in the array.</p>
<dl class="function">
<dt id="c.drm_clflush_sg">
void <code class="descname">drm_clflush_sg</code><span class="sig-paren">(</span>struct sg_table *<em>&nbsp;st</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_clflush_sg" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Flush dcache lines pointing to a scather-gather.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">st</span></code></dt>
<dd>struct sg_table.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush every data cache line entry that points to an address in the
sg.</p>
<dl class="function">
<dt id="c.drm_clflush_virt_range">
void <code class="descname">drm_clflush_virt_range</code><span class="sig-paren">(</span>void *<em>&nbsp;addr</em>, unsigned long<em>&nbsp;length</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_clflush_virt_range" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Flush dcache lines of a region</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">addr</span></code></dt>
<dd>Initial kernel memory address.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">length</span></code></dt>
<dd>Region size.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush every data cache line entry that points to an address in the
region requested.</p>
</div>
<div class="section" id="drm-sync-objects">
<h2>DRM Sync Objects<a class="headerlink" href="#drm-sync-objects" title="Permalink to this headline">Â¶</a></h2>
<p>DRM synchronisation objects (syncobj, see struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal"><span class="pre">drm_syncobj</span></code></a>) are
persistent objects that contain an optional fence. The fence can be updated
with a new fence, or be NULL.</p>
<p>syncobj&#8217;s can be waited upon, where it will wait for the underlying
fence.</p>
<p>syncobj&#8217;s can be export to fd&#8217;s and back, these fd&#8217;s are opaque and
have no other use case, except passing the syncobj between processes.</p>
<p>Their primary use-case is to implement Vulkan fences and semaphores.</p>
<p>syncobj have a kref reference count, but also have an optional file.
The file is only created once the syncobj is exported.
The file takes a reference on the kref.</p>
<dl class="type">
<dt id="c.drm_syncobj">
struct <code class="descname">drm_syncobj</code><a class="headerlink" href="#c.drm_syncobj" title="Permalink to this definition">Â¶</a></dt>
<dd><p>sync object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_syncobj {
  struct kref refcount;
  struct dma_fence __rcu *fence;
  struct list_head cb_list;
  spinlock_t lock;
  struct file *file;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>Reference count of this object.</dd>
<dt><code class="docutils literal"><span class="pre">fence</span></code></dt>
<dd><p class="first">NULL or a pointer to the fence bound to this object.</p>
<p class="last">This field should not be used directly. Use <a class="reference internal" href="#c.drm_syncobj_fence_get" title="drm_syncobj_fence_get"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_fence_get()</span></code></a>
and <a class="reference internal" href="#c.drm_syncobj_replace_fence" title="drm_syncobj_replace_fence"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_replace_fence()</span></code></a> instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cb_list</span></code></dt>
<dd>List of callbacks to call when the <code class="xref c c-type docutils literal"><span class="pre">fence</span></code> gets replaced.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>Protects <code class="xref c c-type docutils literal"><span class="pre">cb_list</span></code> and write-locks <code class="xref c c-type docutils literal"><span class="pre">fence</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">file</span></code></dt>
<dd>A file backing for this syncobj.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure defines a generic sync object which wraps a <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence"><code class="xref c c-type docutils literal"><span class="pre">dma_fence</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_syncobj_cb">
struct <code class="descname">drm_syncobj_cb</code><a class="headerlink" href="#c.drm_syncobj_cb" title="Permalink to this definition">Â¶</a></dt>
<dd><p>callback for drm_syncobj_add_callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_syncobj_cb {
  struct list_head node;
  drm_syncobj_func_t func;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>used by drm_syncob_add_callback to append this struct to
<a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal"><span class="pre">drm_syncobj.cb_list</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">func</span></code></dt>
<dd>drm_syncobj_func_t to call</dd>
</dl>
<p><strong>Description</strong></p>
<p>This struct will be initialized by drm_syncobj_add_callback, additional
data can be passed along by embedding drm_syncobj_cb in another struct.
The callback will get called the next time drm_syncobj_replace_fence is
called.</p>
<dl class="function">
<dt id="c.drm_syncobj_get">
void <code class="descname">drm_syncobj_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>acquire a syncobj reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>sync object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This acquires an additional reference to <strong>obj</strong>. It is illegal to call this
without already holding a reference. No locks required.</p>
<dl class="function">
<dt id="c.drm_syncobj_put">
void <code class="descname">drm_syncobj_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release a reference to a sync object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>sync object.</dd>
</dl>
<dl class="function">
<dt id="c.drm_syncobj_fence_get">
struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> * <code class="descname">drm_syncobj_fence_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> *<em>&nbsp;syncobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_fence_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get a reference to a fence in a sync object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*</span> <span class="pre">syncobj</span></code></dt>
<dd>sync object.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This acquires additional reference to <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj"><code class="xref c c-type docutils literal"><span class="pre">drm_syncobj.fence</span></code></a> contained in <strong>obj</strong>,
if not NULL. It is illegal to call this without already holding a reference.
No locks required.</p>
<p><strong>Return</strong></p>
<p>Either the fence of <strong>obj</strong> or NULL if there&#8217;s none.</p>
<dl class="function">
<dt id="c.drm_syncobj_find">
struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> * <code class="descname">drm_syncobj_find</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_private</em>, u32<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_find" title="Permalink to this definition">Â¶</a></dt>
<dd><p>lookup and reference a sync object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_private</span></code></dt>
<dd>drm file private pointer</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">handle</span></code></dt>
<dd>sync object handle to lookup.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a reference to the syncobj pointed to by handle or NULL. The
reference must be released by calling <a class="reference internal" href="#c.drm_syncobj_put" title="drm_syncobj_put"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_syncobj_add_callback">
void <code class="descname">drm_syncobj_add_callback</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> *<em>&nbsp;syncobj</em>, struct <a class="reference internal" href="#c.drm_syncobj_cb" title="drm_syncobj_cb">drm_syncobj_cb</a> *<em>&nbsp;cb</em>, drm_syncobj_func_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_add_callback" title="Permalink to this definition">Â¶</a></dt>
<dd><p>adds a callback to syncobj::cb_list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*</span> <span class="pre">syncobj</span></code></dt>
<dd>Sync object to which to add the callback</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj_cb</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt>
<dd>Callback to add</dd>
<dt><code class="docutils literal"><span class="pre">drm_syncobj_func_t</span> <span class="pre">func</span></code></dt>
<dd>Func to use when initializing the drm_syncobj_cb struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds a callback to be called next time the fence is replaced</p>
<dl class="function">
<dt id="c.drm_syncobj_remove_callback">
void <code class="descname">drm_syncobj_remove_callback</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> *<em>&nbsp;syncobj</em>, struct <a class="reference internal" href="#c.drm_syncobj_cb" title="drm_syncobj_cb">drm_syncobj_cb</a> *<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_remove_callback" title="Permalink to this definition">Â¶</a></dt>
<dd><p>removes a callback to syncobj::cb_list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*</span> <span class="pre">syncobj</span></code></dt>
<dd>Sync object from which to remove the callback</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj_cb</span> <span class="pre">*</span> <span class="pre">cb</span></code></dt>
<dd>Callback to remove</dd>
</dl>
<dl class="function">
<dt id="c.drm_syncobj_replace_fence">
void <code class="descname">drm_syncobj_replace_fence</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> *<em>&nbsp;syncobj</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_replace_fence" title="Permalink to this definition">Â¶</a></dt>
<dd><p>replace fence in a sync object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*</span> <span class="pre">syncobj</span></code></dt>
<dd>Sync object to replace fence in</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence to install in sync file.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This replaces the fence on a sync object.</p>
<dl class="function">
<dt id="c.drm_syncobj_find_fence">
int <code class="descname">drm_syncobj_find_fence</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_private</em>, u32<em>&nbsp;handle</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_find_fence" title="Permalink to this definition">Â¶</a></dt>
<dd><p>lookup and reference the fence in a sync object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_private</span></code></dt>
<dd>drm file private pointer</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">handle</span></code></dt>
<dd>sync object handle to lookup.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>out parameter for the fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is just a convenience function that combines <a class="reference internal" href="#c.drm_syncobj_find" title="drm_syncobj_find"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_find()</span></code></a> and
<a class="reference internal" href="#c.drm_syncobj_fence_get" title="drm_syncobj_fence_get"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_fence_get()</span></code></a>.</p>
<p>Returns 0 on success or a negative error value on failure. On success <strong>fence</strong>
contains a reference to the fence, which must be released by calling
<a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_put" title="dma_fence_put"><code class="xref c c-func docutils literal"><span class="pre">dma_fence_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_syncobj_free">
void <code class="descname">drm_syncobj_free</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;kref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_free" title="Permalink to this definition">Â¶</a></dt>
<dd><p>free a sync object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">kref</span></code></dt>
<dd>kref to free.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only to be called from kref_put in drm_syncobj_put.</p>
<dl class="function">
<dt id="c.drm_syncobj_create">
int <code class="descname">drm_syncobj_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> **<em>&nbsp;out_syncobj</em>, uint32_t<em>&nbsp;flags</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_create" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a new syncobj</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">**</span> <span class="pre">out_syncobj</span></code></dt>
<dd>returned syncobj</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt>
<dd>DRM_SYNCOBJ_* flags</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>if non-NULL, the syncobj will represent this fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first function to create a sync object. After creating, drivers
probably want to make it available to userspace, either through
<a class="reference internal" href="#c.drm_syncobj_get_handle" title="drm_syncobj_get_handle"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_get_handle()</span></code></a> or <a class="reference internal" href="#c.drm_syncobj_get_fd" title="drm_syncobj_get_fd"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_get_fd()</span></code></a>.</p>
<p>Returns 0 on success or a negative error value on failure.</p>
<dl class="function">
<dt id="c.drm_syncobj_get_handle">
int <code class="descname">drm_syncobj_get_handle</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_private</em>, struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> *<em>&nbsp;syncobj</em>, u32 *<em>&nbsp;handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_get_handle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get a handle from a syncobj</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_private</span></code></dt>
<dd>drm file private pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*</span> <span class="pre">syncobj</span></code></dt>
<dd>Sync object to export</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">handle</span></code></dt>
<dd>out parameter with the new handle</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exports a sync object created with <a class="reference internal" href="#c.drm_syncobj_create" title="drm_syncobj_create"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_create()</span></code></a> as a handle on
<strong>file_private</strong> to userspace.</p>
<p>Returns 0 on success or a negative error value on failure.</p>
<dl class="function">
<dt id="c.drm_syncobj_get_fd">
int <code class="descname">drm_syncobj_get_fd</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_syncobj" title="drm_syncobj">drm_syncobj</a> *<em>&nbsp;syncobj</em>, int *<em>&nbsp;p_fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_syncobj_get_fd" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get a file descriptor from a syncobj</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_syncobj</span> <span class="pre">*</span> <span class="pre">syncobj</span></code></dt>
<dd>Sync object to export</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">p_fd</span></code></dt>
<dd>out parameter with the new file descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Exports a sync object created with <a class="reference internal" href="#c.drm_syncobj_create" title="drm_syncobj_create"><code class="xref c c-func docutils literal"><span class="pre">drm_syncobj_create()</span></code></a> as a file descriptor.</p>
<p>Returns 0 on success or a negative error value on failure.</p>
</div>
<div class="section" id="gpu-scheduler">
<h2>GPU Scheduler<a class="headerlink" href="#gpu-scheduler" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="id2">
<h3>Overview<a class="headerlink" href="#id2" title="Permalink to this headline">Â¶</a></h3>
<p>The GPU scheduler provides entities which allow userspace to push jobs
into software queues which are then scheduled on a hardware run queue.
The software queues have a priority among them. The scheduler selects the entities
from the run queue using a FIFO. The scheduler provides dependency handling
features among jobs. The driver is supposed to provide callback functions for
backend operations to the scheduler like submitting a job to hardware run queue,
returning the dependencies of a job etc.</p>
<p>The organisation of the scheduler is the following:</p>
<ol class="arabic simple">
<li>Each hw run queue has one scheduler</li>
<li>Each scheduler has multiple run queues with different priorities
(e.g., HIGH_HW,HIGH_SW, KERNEL, NORMAL)</li>
<li>Each scheduler run queue has a queue of entities to schedule</li>
<li>Entities themselves maintain a queue of jobs that will be scheduled on
the hardware.</li>
</ol>
<p>The jobs in a entity are always scheduled in the order that they were pushed.</p>
</div>
<div class="section" id="scheduler-function-references">
<h3>Scheduler Function References<a class="headerlink" href="#scheduler-function-references" title="Permalink to this headline">Â¶</a></h3>
<dl class="type">
<dt id="c.drm_sched_entity">
struct <code class="descname">drm_sched_entity</code><a class="headerlink" href="#c.drm_sched_entity" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A wrapper around a job queue (typically attached to the DRM file_priv).</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_sched_entity {
  struct list_head                list;
  struct drm_sched_rq             *rq;
  spinlock_t rq_lock;
  struct spsc_queue               job_queue;
  atomic_t fence_seq;
  uint64_t fence_context;
  struct dma_fence                *dependency;
  struct dma_fence_cb             cb;
  atomic_t *guilty;
  struct dma_fence                *last_scheduled;
  struct task_struct              *last_user;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>used to append this struct to the list of entities in the
runqueue.</dd>
<dt><code class="docutils literal"><span class="pre">rq</span></code></dt>
<dd>runqueue to which this entity belongs.</dd>
<dt><code class="docutils literal"><span class="pre">rq_lock</span></code></dt>
<dd>lock to modify the runqueue to which this entity belongs.</dd>
<dt><code class="docutils literal"><span class="pre">job_queue</span></code></dt>
<dd>the list of jobs of this entity.</dd>
<dt><code class="docutils literal"><span class="pre">fence_seq</span></code></dt>
<dd>a linearly increasing seqno incremented with each
new <a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal"><span class="pre">drm_sched_fence</span></code></a> which is part of the entity.</dd>
<dt><code class="docutils literal"><span class="pre">fence_context</span></code></dt>
<dd>a unique context for all the fences which belong
to this entity.
The <a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal"><span class="pre">drm_sched_fence.scheduled</span></code></a> uses the
fence_context but <a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal"><span class="pre">drm_sched_fence.finished</span></code></a> uses
fence_context + 1.</dd>
<dt><code class="docutils literal"><span class="pre">dependency</span></code></dt>
<dd>the dependency fence of the job which is on the top
of the job queue.</dd>
<dt><code class="docutils literal"><span class="pre">cb</span></code></dt>
<dd>callback for the dependency fence above.</dd>
<dt><code class="docutils literal"><span class="pre">guilty</span></code></dt>
<dd>points to ctx&#8217;s guilty.</dd>
<dt><code class="docutils literal"><span class="pre">last_scheduled</span></code></dt>
<dd>points to the finished fence of the last scheduled job.</dd>
<dt><code class="docutils literal"><span class="pre">last_user</span></code></dt>
<dd>last group leader pushing a job into the entity.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Entities will emit jobs in order to their corresponding hardware
ring, and the scheduler will alternate between entities based on
scheduling policy.</p>
<dl class="type">
<dt id="c.drm_sched_rq">
struct <code class="descname">drm_sched_rq</code><a class="headerlink" href="#c.drm_sched_rq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>queue of entities to be scheduled.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_sched_rq {
  spinlock_t lock;
  struct drm_gpu_scheduler        *sched;
  struct list_head                entities;
  struct drm_sched_entity         *current_entity;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>to modify the entities list.</dd>
<dt><code class="docutils literal"><span class="pre">sched</span></code></dt>
<dd>the scheduler to which this rq belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">entities</span></code></dt>
<dd>list of the entities to be scheduled.</dd>
<dt><code class="docutils literal"><span class="pre">current_entity</span></code></dt>
<dd>the entity which is to be scheduled.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Run queue is a set of entities scheduling command submissions for
one specific ring. It implements the scheduling policy that selects
the next entity to emit commands from.</p>
<dl class="type">
<dt id="c.drm_sched_fence">
struct <code class="descname">drm_sched_fence</code><a class="headerlink" href="#c.drm_sched_fence" title="Permalink to this definition">Â¶</a></dt>
<dd><p>fences corresponding to the scheduling of a job.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_sched_fence {
  struct dma_fence                scheduled;
  struct dma_fence                finished;
  struct dma_fence_cb             cb;
  struct dma_fence                *parent;
  struct drm_gpu_scheduler        *sched;
  spinlock_t lock;
  void *owner;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">scheduled</span></code></dt>
<dd>this fence is what will be signaled by the scheduler
when the job is scheduled.</dd>
<dt><code class="docutils literal"><span class="pre">finished</span></code></dt>
<dd><p class="first">this fence is what will be signaled by the scheduler
when the job is completed.</p>
<p class="last">When setting up an out fence for the job, you should use
this, since it&#8217;s available immediately upon
<a class="reference internal" href="#c.drm_sched_job_init" title="drm_sched_job_init"><code class="xref c c-func docutils literal"><span class="pre">drm_sched_job_init()</span></code></a>, and the fence returned by the driver
from <code class="xref c c-func docutils literal"><span class="pre">run_job()</span></code> won&#8217;t be created until the dependencies have
resolved.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cb</span></code></dt>
<dd>the callback for the parent fence below.</dd>
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>the fence returned by <a class="reference internal" href="#c.drm_sched_backend_ops" title="drm_sched_backend_ops"><code class="xref c c-type docutils literal"><span class="pre">drm_sched_backend_ops.run_job</span></code></a>
when scheduling the job on hardware. We signal the
<a class="reference internal" href="#c.drm_sched_fence" title="drm_sched_fence"><code class="xref c c-type docutils literal"><span class="pre">drm_sched_fence.finished</span></code></a> fence once parent is signalled.</dd>
<dt><code class="docutils literal"><span class="pre">sched</span></code></dt>
<dd>the scheduler instance to which the job having this struct
belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>the lock used by the scheduled and the finished fences.</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>job owner for debugging</dd>
</dl>
<dl class="type">
<dt id="c.drm_sched_job">
struct <code class="descname">drm_sched_job</code><a class="headerlink" href="#c.drm_sched_job" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A job to be run by an entity.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_sched_job {
  struct spsc_node                queue_node;
  struct drm_gpu_scheduler        *sched;
  struct drm_sched_fence          *s_fence;
  struct dma_fence_cb             finish_cb;
  struct work_struct              finish_work;
  struct list_head                node;
  struct delayed_work             work_tdr;
  uint64_t id;
  atomic_t karma;
  enum drm_sched_priority         s_priority;
  struct drm_sched_entity  *entity;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">queue_node</span></code></dt>
<dd>used to append this struct to the queue of jobs in an entity.</dd>
<dt><code class="docutils literal"><span class="pre">sched</span></code></dt>
<dd>the scheduler instance on which this job is scheduled.</dd>
<dt><code class="docutils literal"><span class="pre">s_fence</span></code></dt>
<dd>contains the fences for the scheduling of job.</dd>
<dt><code class="docutils literal"><span class="pre">finish_cb</span></code></dt>
<dd>the callback for the finished fence.</dd>
<dt><code class="docutils literal"><span class="pre">finish_work</span></code></dt>
<dd>schedules the function <strong>drm_sched_job_finish</strong> once the job has
finished to remove the job from the
<strong>drm_gpu_scheduler.ring_mirror_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>used to append this struct to the <strong>drm_gpu_scheduler.ring_mirror_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">work_tdr</span></code></dt>
<dd>schedules a delayed call to <strong>drm_sched_job_timedout</strong> after the timeout
interval is over.</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>a unique id assigned to each job scheduled on the scheduler.</dd>
<dt><code class="docutils literal"><span class="pre">karma</span></code></dt>
<dd>increment on every hang caused by this job. If this exceeds the hang
limit of the scheduler then the job is marked guilty and will not
be scheduled further.</dd>
<dt><code class="docutils literal"><span class="pre">s_priority</span></code></dt>
<dd>the priority of the job.</dd>
<dt><code class="docutils literal"><span class="pre">entity</span></code></dt>
<dd>the entity to which this job belongs.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A job is created by the driver using <a class="reference internal" href="#c.drm_sched_job_init" title="drm_sched_job_init"><code class="xref c c-func docutils literal"><span class="pre">drm_sched_job_init()</span></code></a>, and
should call <a class="reference internal" href="#c.drm_sched_entity_push_job" title="drm_sched_entity_push_job"><code class="xref c c-func docutils literal"><span class="pre">drm_sched_entity_push_job()</span></code></a> once it wants the scheduler
to schedule the job.</p>
<dl class="type">
<dt id="c.drm_sched_backend_ops">
struct <code class="descname">drm_sched_backend_ops</code><a class="headerlink" href="#c.drm_sched_backend_ops" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_sched_backend_ops {
  struct dma_fence *(*dependency)(struct drm_sched_job *sched_job, struct drm_sched_entity *s_entity);
  struct dma_fence *(*run_job)(struct drm_sched_job *sched_job);
  void (*timedout_job)(struct drm_sched_job *sched_job);
  void (*free_job)(struct drm_sched_job *sched_job);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dependency</span></code></dt>
<dd>Called when the scheduler is considering scheduling
this job next, to get another struct dma_fence for this job to
block on.  Once it returns NULL, <code class="xref c c-func docutils literal"><span class="pre">run_job()</span></code> may be called.</dd>
<dt><code class="docutils literal"><span class="pre">run_job</span></code></dt>
<dd>Called to execute the job once all of the dependencies
have been resolved.  This may be called multiple times, if
<code class="xref c c-func docutils literal"><span class="pre">timedout_job()</span></code> has happened and <a class="reference internal" href="#c.drm_sched_job_recovery" title="drm_sched_job_recovery"><code class="xref c c-func docutils literal"><span class="pre">drm_sched_job_recovery()</span></code></a>
decides to try it again.</dd>
<dt><code class="docutils literal"><span class="pre">timedout_job</span></code></dt>
<dd>Called when a job has taken too long to execute,
to trigger GPU recovery.</dd>
<dt><code class="docutils literal"><span class="pre">free_job</span></code></dt>
<dd>Called once the job&#8217;s finished fence has been signaled
and it&#8217;s time to clean it up.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Define the backend operations called by the scheduler,
these functions should be implemented in driver side.</p>
<dl class="type">
<dt id="c.drm_gpu_scheduler">
struct <code class="descname">drm_gpu_scheduler</code><a class="headerlink" href="#c.drm_gpu_scheduler" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_gpu_scheduler {
  const struct drm_sched_backend_ops      *ops;
  uint32_t hw_submission_limit;
  long timeout;
  const char                      *name;
  struct drm_sched_rq             sched_rq[DRM_SCHED_PRIORITY_MAX];
  wait_queue_head_t wake_up_worker;
  wait_queue_head_t job_scheduled;
  atomic_t hw_rq_count;
  atomic64_t job_id_count;
  struct task_struct              *thread;
  struct list_head                ring_mirror_list;
  spinlock_t job_list_lock;
  int hang_limit;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>backend operations provided by the driver.</dd>
<dt><code class="docutils literal"><span class="pre">hw_submission_limit</span></code></dt>
<dd>the max size of the hardware queue.</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>the time after which a job is removed from the scheduler.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name of the ring for which this scheduler is being used.</dd>
<dt><code class="docutils literal"><span class="pre">sched_rq</span></code></dt>
<dd>priority wise array of run queues.</dd>
<dt><code class="docutils literal"><span class="pre">wake_up_worker</span></code></dt>
<dd>the wait queue on which the scheduler sleeps until a job
is ready to be scheduled.</dd>
<dt><code class="docutils literal"><span class="pre">job_scheduled</span></code></dt>
<dd>once <strong>drm_sched_entity_do_release</strong> is called the scheduler
waits on this wait queue until all the scheduled jobs are
finished.</dd>
<dt><code class="docutils literal"><span class="pre">hw_rq_count</span></code></dt>
<dd>the number of jobs currently in the hardware queue.</dd>
<dt><code class="docutils literal"><span class="pre">job_id_count</span></code></dt>
<dd>used to assign unique id to the each job.</dd>
<dt><code class="docutils literal"><span class="pre">thread</span></code></dt>
<dd>the kthread on which the scheduler which run.</dd>
<dt><code class="docutils literal"><span class="pre">ring_mirror_list</span></code></dt>
<dd>the list of jobs which are currently in the job queue.</dd>
<dt><code class="docutils literal"><span class="pre">job_list_lock</span></code></dt>
<dd>lock to protect the ring_mirror_list.</dd>
<dt><code class="docutils literal"><span class="pre">hang_limit</span></code></dt>
<dd>once the hangs by a job crosses this limit then it is marked
guilty and it will be considered for scheduling further.</dd>
</dl>
<p><strong>Description</strong></p>
<p>One scheduler is implemented for each hardware ring.</p>
<dl class="function">
<dt id="c.drm_sched_entity_init">
int <code class="descname">drm_sched_entity_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity">drm_sched_entity</a> *<em>&nbsp;entity</em>, struct <a class="reference internal" href="#c.drm_sched_rq" title="drm_sched_rq">drm_sched_rq</a> **<em>&nbsp;rq_list</em>, unsigned int<em>&nbsp;num_rq_list</em>, atomic_t *<em>&nbsp;guilty</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Init a context entity used by scheduler when submit to HW ring.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>scheduler entity to init</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_rq</span> <span class="pre">**</span> <span class="pre">rq_list</span></code></dt>
<dd>the list of run queue on which jobs from this
entity can be submitted</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_rq_list</span></code></dt>
<dd>number of run queue in rq_list</dd>
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">guilty</span></code></dt>
<dd>atomic_t set to 1 when a job on this queue
is found to be guilty causing a timeout</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>the rq_list should have atleast one element to schedule</dt>
<dd>the entity</dd>
</dl>
<p>Returns 0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_sched_entity_flush">
long <code class="descname">drm_sched_entity_flush</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity">drm_sched_entity</a> *<em>&nbsp;entity</em>, long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_flush" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Flush a context entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>scheduler entity</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>time to wait in for Q to become empty in jiffies.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Splitting <a class="reference internal" href="#c.drm_sched_entity_fini" title="drm_sched_entity_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_sched_entity_fini()</span></code></a> into two functions, The first one does the waiting,
removes the entity from the runqueue and returns an error when the process was killed.</p>
<p>Returns the remaining time in jiffies left from the input timeout</p>
<dl class="function">
<dt id="c.drm_sched_entity_fini">
void <code class="descname">drm_sched_entity_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity">drm_sched_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_fini" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Destroy a context entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>scheduler entity</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called after <strong>drm_sched_entity_do_release</strong>. It goes over the
entity and signals all jobs with an error code if the process was killed.</p>
<dl class="function">
<dt id="c.drm_sched_entity_destroy">
void <code class="descname">drm_sched_entity_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity">drm_sched_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_destroy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Destroy a context entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>scheduler entity</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <code class="xref c c-func docutils literal"><span class="pre">drm_sched_entity_do_release()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">drm_sched_entity_cleanup()</span></code></p>
<dl class="function">
<dt id="c.drm_sched_entity_set_rq">
void <code class="descname">drm_sched_entity_set_rq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity">drm_sched_entity</a> *<em>&nbsp;entity</em>, struct <a class="reference internal" href="#c.drm_sched_rq" title="drm_sched_rq">drm_sched_rq</a> *<em>&nbsp;rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_set_rq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Sets the run queue for an entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>scheduler entity</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_rq</span> <span class="pre">*</span> <span class="pre">rq</span></code></dt>
<dd>scheduler run queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets the run queue for an entity and removes the entity from the previous
run queue in which was present.</p>
<dl class="function">
<dt id="c.drm_sched_dependency_optimized">
bool <code class="descname">drm_sched_dependency_optimized</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, struct <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity">drm_sched_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_dependency_optimized" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>the dependency fence</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>the entity which depends on the above fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if the dependency can be optimized and false otherwise</p>
<dl class="function">
<dt id="c.drm_sched_entity_push_job">
void <code class="descname">drm_sched_entity_push_job</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job">drm_sched_job</a> *<em>&nbsp;sched_job</em>, struct <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity">drm_sched_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_entity_push_job" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Submit a job to the entity&#8217;s job queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*</span> <span class="pre">sched_job</span></code></dt>
<dd>job to submit</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>scheduler entity</dd>
</dl>
<p><strong>Note</strong></p>
<p>To guarantee that the order of insertion to queue matches
the job&#8217;s fence sequence number this function should be
called with drm_sched_job_init under common lock.</p>
<p>Returns 0 for success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.drm_sched_hw_job_reset">
void <code class="descname">drm_sched_hw_job_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler">drm_gpu_scheduler</a> *<em>&nbsp;sched</em>, struct <a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job">drm_sched_job</a> *<em>&nbsp;bad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_hw_job_reset" title="Permalink to this definition">Â¶</a></dt>
<dd><p>stop the scheduler if it contains the bad job</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*</span> <span class="pre">sched</span></code></dt>
<dd>scheduler instance</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*</span> <span class="pre">bad</span></code></dt>
<dd>bad scheduler job</dd>
</dl>
<dl class="function">
<dt id="c.drm_sched_job_recovery">
void <code class="descname">drm_sched_job_recovery</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler">drm_gpu_scheduler</a> *<em>&nbsp;sched</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_recovery" title="Permalink to this definition">Â¶</a></dt>
<dd><p>recover jobs after a reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*</span> <span class="pre">sched</span></code></dt>
<dd>scheduler instance</dd>
</dl>
<dl class="function">
<dt id="c.drm_sched_job_init">
int <code class="descname">drm_sched_job_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_sched_job" title="drm_sched_job">drm_sched_job</a> *<em>&nbsp;job</em>, struct <a class="reference internal" href="#c.drm_sched_entity" title="drm_sched_entity">drm_sched_entity</a> *<em>&nbsp;entity</em>, void *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_job_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>init a scheduler job</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_job</span> <span class="pre">*</span> <span class="pre">job</span></code></dt>
<dd>scheduler job to init</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_sched_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>scheduler entity to use</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>job owner for debugging</dd>
</dl>
<p><strong>Description</strong></p>
<p>Refer to <a class="reference internal" href="#c.drm_sched_entity_push_job" title="drm_sched_entity_push_job"><code class="xref c c-func docutils literal"><span class="pre">drm_sched_entity_push_job()</span></code></a> documentation
for locking considerations.</p>
<p>Returns 0 for success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.drm_sched_init">
int <code class="descname">drm_sched_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler">drm_gpu_scheduler</a> *<em>&nbsp;sched</em>, const struct <a class="reference internal" href="#c.drm_sched_backend_ops" title="drm_sched_backend_ops">drm_sched_backend_ops</a> *<em>&nbsp;ops</em>, unsigned<em>&nbsp;hw_submission</em>, unsigned<em>&nbsp;hang_limit</em>, long<em>&nbsp;timeout</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Init a gpu scheduler instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*</span> <span class="pre">sched</span></code></dt>
<dd>scheduler instance</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_sched_backend_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>backend operations for this scheduler</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">hw_submission</span></code></dt>
<dd>number of hw submissions that can be in flight</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">hang_limit</span></code></dt>
<dd>number of times to allow a job to hang before dropping it</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout value in jiffies for the scheduler</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name used for debugging</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return 0 on success, otherwise error code.</p>
<dl class="function">
<dt id="c.drm_sched_fini">
void <code class="descname">drm_sched_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_gpu_scheduler" title="drm_gpu_scheduler">drm_gpu_scheduler</a> *<em>&nbsp;sched</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_sched_fini" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Destroy a gpu scheduler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gpu_scheduler</span> <span class="pre">*</span> <span class="pre">sched</span></code></dt>
<dd>scheduler instance</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down and cleans up the scheduler.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-kms.html" class="btn btn-neutral float-right" title="Kernel Mode Setting (KMS)" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-internals.html" class="btn btn-neutral" title="DRM Internals" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>