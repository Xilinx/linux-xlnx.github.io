

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>drm/amdgpu AMDgpu driver &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="GPU Driver Documentation" href="drivers.html"/>
        <link rel="next" title="drm/i915 Intel GFX Driver" href="i915.html"/>
        <link rel="prev" title="GPU Driver Documentation" href="drivers.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms.html">Kernel Mode Setting (KMS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="">drm/amdgpu AMDgpu driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-parameters">Module Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#core-driver-infrastructure">Core Driver Infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gpu-power-thermal-controls-and-monitoring">GPU Power/Thermal Controls and Monitoring</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="i915.html">drm/i915 Intel GFX Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="meson.html">drm/meson AmLogic Meson Video Processing Unit</a></li>
<li class="toctree-l3"><a class="reference internal" href="pl111.html">drm/pl111 ARM PrimeCell PL111 CLCD Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="tegra.html">drm/tegra NVIDIA Tegra GPU and display driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="tinydrm.html">drm/tinydrm Driver library</a></li>
<li class="toctree-l3"><a class="reference internal" href="tve200.html">drm/tve200 Faraday TV Encoder 200</a></li>
<li class="toctree-l3"><a class="reference internal" href="v3d.html">drm/v3d Broadcom V3D Graphics Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="vc4.html">drm/vc4 Broadcom VC4 Graphics Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="bridge/dw-hdmi.html">drm/bridge/dw-hdmi Synopsys DesignWare HDMI Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="xen-front.html">drm/xen-front Xen para-virtualized frontend driver</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
          <li><a href="drivers.html">GPU Driver Documentation</a> &raquo;</li>
      
    <li>drm/amdgpu AMDgpu driver</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/amdgpu.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="drm-amdgpu-amdgpu-driver">
<h1>drm/amdgpu AMDgpu driver<a class="headerlink" href="#drm-amdgpu-amdgpu-driver" title="Permalink to this headline">¶</a></h1>
<p>The drm/amdgpu driver supports all AMD Radeon GPUs based on the Graphics Core
Next (GCN) architecture.</p>
<div class="section" id="module-parameters">
<h2>Module Parameters<a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h2>
<p>The amdgpu driver supports the following module parameters:</p>
<p><strong>vramlimit (int)</strong></p>
<p>Restrict the total amount of VRAM in MiB for testing.  The default is 0 (Use full VRAM).</p>
<p><strong>vis_vramlimit (int)</strong></p>
<p>Restrict the amount of CPU visible VRAM in MiB for testing.  The default is 0 (Use full CPU visible VRAM).</p>
<p><strong>gartsize (uint)</strong></p>
<p>Restrict the size of GART in Mib (32, 64, etc.) for testing. The default is -1 (The size depends on asic).</p>
<p><strong>gttsize (int)</strong></p>
<p>Restrict the size of GTT domain in MiB for testing. The default is -1 (It&#8217;s VRAM size if 3GB &lt; VRAM &lt; 3/4 RAM,
otherwise 3/4 RAM size).</p>
<p><strong>moverate (int)</strong></p>
<p>Set maximum buffer migration rate in MB/s. The default is -1 (8 MB/s).</p>
<p><strong>benchmark (int)</strong></p>
<p>Run benchmarks. The default is 0 (Skip benchmarks).</p>
<p><strong>test (int)</strong></p>
<p>Test BO GTT-&gt;VRAM and VRAM-&gt;GTT GPU copies. The default is 0 (Skip test, only set 1 to run test).</p>
<p><strong>audio (int)</strong></p>
<p>Set HDMI/DPAudio. Only affects non-DC display handling. The default is -1 (Enabled), set 0 to disabled it.</p>
<p><strong>disp_priority (int)</strong></p>
<p>Set display Priority (1 = normal, 2 = high). Only affects non-DC display handling. The default is 0 (auto).</p>
<p><strong>hw_i2c (int)</strong></p>
<p>To enable hw i2c engine. Only affects non-DC display handling. The default is 0 (Disabled).</p>
<p><strong>pcie_gen2 (int)</strong></p>
<p>To disable PCIE Gen2/3 mode (0 = disable, 1 = enable). The default is -1 (auto, enabled).</p>
<p><strong>msi (int)</strong></p>
<p>To disable Message Signaled Interrupts (MSI) functionality (1 = enable, 0 = disable). The default is -1 (auto, enabled).</p>
<p><strong>lockup_timeout (int)</strong></p>
<p>Set GPU scheduler timeout value in ms. Value 0 is invalidated, will be adjusted to 10000.
Negative values mean &#8216;infinite timeout&#8217; (MAX_JIFFY_OFFSET). The default is 10000.</p>
<p><strong>dpm (int)</strong></p>
<p>Override for dynamic power management setting (1 = enable, 0 = disable). The default is -1 (auto).</p>
<p><strong>fw_load_type (int)</strong></p>
<p>Set different firmware loading type for debugging (0 = direct, 1 = SMU, 2 = PSP). The default is -1 (auto).</p>
<p><strong>aspm (int)</strong></p>
<p>To disable ASPM (1 = enable, 0 = disable). The default is -1 (auto, enabled).</p>
<p><strong>runpm (int)</strong></p>
<p>Override for runtime power management control for dGPUs in PX/HG laptops. The amdgpu driver can dynamically power down
the dGPU on PX/HG laptops when it is idle. The default is -1 (auto enable). Setting the value to 0 disables this functionality.</p>
<p><strong>ip_block_mask (uint)</strong></p>
<p>Override what IP blocks are enabled on the GPU. Each GPU is a collection of IP blocks (gfx, display, video, etc.).
Use this parameter to disable specific blocks. Note that the IP blocks do not have a fixed index. Some asics may not have
some IPs or may include multiple instances of an IP so the ordering various from asic to asic. See the driver output in
the kernel log for the list of IPs on the asic. The default is 0xffffffff (enable all blocks on a device).</p>
<p><strong>bapm (int)</strong></p>
<p>Bidirectional Application Power Management (BAPM) used to dynamically share TDP between CPU and GPU. Set value 0 to disable it.
The default -1 (auto, enabled)</p>
<p><strong>deep_color (int)</strong></p>
<p>Set 1 to enable Deep Color support. Only affects non-DC display handling. The default is 0 (disabled).</p>
<p><strong>vm_size (int)</strong></p>
<p>Override the size of the GPU&#8217;s per client virtual address space in GiB.  The default is -1 (automatic for each asic).</p>
<p><strong>vm_fragment_size (int)</strong></p>
<p>Override VM fragment size in bits (4, 5, etc. 4 = 64K, 9 = 2M). The default is -1 (automatic for each asic).</p>
<p><strong>vm_block_size (int)</strong></p>
<p>Override VM page table size in bits (default depending on vm_size and hw setup). The default is -1 (automatic for each asic).</p>
<p><strong>vm_fault_stop (int)</strong></p>
<p>Stop on VM fault for debugging (0 = never, 1 = print first, 2 = always). The default is 0 (No stop).</p>
<p><strong>vm_debug (int)</strong></p>
<p>Debug VM handling (0 = disabled, 1 = enabled). The default is 0 (Disabled).</p>
<p><strong>vm_update_mode (int)</strong></p>
<p>Override VM update mode. VM updated by using CPU (0 = never, 1 = Graphics only, 2 = Compute only, 3 = Both). The default
is -1 (Only in large BAR(LB) systems Compute VM tables will be updated by CPU, otherwise 0, never).</p>
<p><strong>vram_page_split (int)</strong></p>
<p>Override the number of pages after we split VRAM allocations (default 512, -1 = disable). The default is 512.</p>
<p><strong>exp_hw_support (int)</strong></p>
<p>Enable experimental hw support (1 = enable). The default is 0 (disabled).</p>
<p><strong>dc (int)</strong></p>
<p>Disable/Enable Display Core driver for debugging (1 = enable, 0 = disable). The default is -1 (automatic for each asic).</p>
<p><strong>sched_jobs (int)</strong></p>
<p>Override the max number of jobs supported in the sw queue. The default is 32.</p>
<p><strong>sched_hw_submission (int)</strong></p>
<p>Override the max number of HW submissions. The default is 2.</p>
<p><strong>ppfeaturemask (uint)</strong></p>
<p>Override power features enabled. See enum PP_FEATURE_MASK in drivers/gpu/drm/amd/include/amd_shared.h.
The default is the current set of stable power features.</p>
<p><strong>pcie_gen_cap (uint)</strong></p>
<p>Override PCIE gen speed capabilities. See the CAIL flags in drivers/gpu/drm/amd/include/amd_pcie.h.
The default is 0 (automatic for each asic).</p>
<p><strong>pcie_lane_cap (uint)</strong></p>
<p>Override PCIE lanes capabilities. See the CAIL flags in drivers/gpu/drm/amd/include/amd_pcie.h.
The default is 0 (automatic for each asic).</p>
<p><strong>cg_mask (uint)</strong></p>
<p>Override Clockgating features enabled on GPU (0 = disable clock gating). See the AMD_CG_SUPPORT flags in
drivers/gpu/drm/amd/include/amd_shared.h. The default is 0xffffffff (all enabled).</p>
<p><strong>pg_mask (uint)</strong></p>
<p>Override Powergating features enabled on GPU (0 = disable power gating). See the AMD_PG_SUPPORT flags in
drivers/gpu/drm/amd/include/amd_shared.h. The default is 0xffffffff (all enabled).</p>
<p><strong>sdma_phase_quantum (uint)</strong></p>
<p>Override SDMA context switch phase quantum (x 1K GPU clock cycles, 0 = no change). The default is 32.</p>
<p><strong>disable_cu (charp)</strong></p>
<p>Set to disable CUs (It&#8217;s set like se.sh.cu,...). The default is NULL.</p>
<p><strong>virtual_display (charp)</strong></p>
<p>Set to enable virtual display feature. This feature provides a virtual display hardware on headless boards
or in virtualized environments. It will be set like xxxx:xx:xx.x,x;xxxx:xx:xx.x,x. It&#8217;s the pci address of
the device, plus the number of crtcs to expose. E.g., 0000:26:00.0,4 would enable 4 virtual crtcs on the pci
device at 26:00.0. The default is NULL.</p>
<p><strong>ngg (int)</strong></p>
<p>Set to enable Next Generation Graphics (1 = enable). The default is 0 (disabled).</p>
<p><strong>prim_buf_per_se (int)</strong></p>
<p>Override the size of Primitive Buffer per Shader Engine in Byte. The default is 0 (depending on gfx).</p>
<p><strong>pos_buf_per_se (int)</strong></p>
<p>Override the size of Position Buffer per Shader Engine in Byte. The default is 0 (depending on gfx).</p>
<p><strong>cntl_sb_buf_per_se (int)</strong></p>
<p>Override the size of Control Sideband per Shader Engine in Byte. The default is 0 (depending on gfx).</p>
<p><strong>param_buf_per_se (int)</strong></p>
<p>Override the size of Off-Chip Pramater Cache per Shader Engine in Byte. The default is 0 (depending on gfx).</p>
<p><strong>job_hang_limit (int)</strong></p>
<p>Set how much time allow a job hang and not drop it. The default is 0.</p>
<p><strong>lbpw (int)</strong></p>
<p>Override Load Balancing Per Watt (LBPW) support (1 = enable, 0 = disable). The default is -1 (auto, enabled).</p>
<p><strong>gpu_recovery (int)</strong></p>
<p>Set to enable GPU recovery mechanism (1 = enable, 0 = disable). The default is -1 (auto, disabled except SRIOV).</p>
<p><strong>emu_mode (int)</strong></p>
<p>Set value 1 to enable emulation mode. This is only needed when running on an emulator. The default is 0 (disabled).</p>
<p><strong>si_support (int)</strong></p>
<p>Set SI support driver. This parameter works after set config CONFIG_DRM_AMDGPU_SI. For SI asic, when radeon driver is enabled,
set value 0 to use radeon driver, while set value 1 to use amdgpu driver. The default is using radeon driver when it available,
otherwise using amdgpu driver.</p>
<p><strong>cik_support (int)</strong></p>
<p>Set CIK support driver. This parameter works after set config CONFIG_DRM_AMDGPU_CIK. For CIK asic, when radeon driver is enabled,
set value 0 to use radeon driver, while set value 1 to use amdgpu driver. The default is using radeon driver when it available,
otherwise using amdgpu driver.</p>
<p><strong>smu_memory_pool_size (uint)</strong></p>
<p>It is used to reserve gtt for smu debug usage, setting value 0 to disable it. The actual size is value * 256MiB.
E.g. 0x1 = 256Mbyte, 0x2 = 512Mbyte, 0x4 = 1 Gbyte, 0x8 = 2GByte. The default is 0 (disabled).</p>
</div>
<div class="section" id="core-driver-infrastructure">
<h2>Core Driver Infrastructure<a class="headerlink" href="#core-driver-infrastructure" title="Permalink to this headline">¶</a></h2>
<p>This section covers core driver infrastructure.</p>
<div class="section" id="memory-domains">
<span id="amdgpu-memory-domains"></span><h3>Memory Domains<a class="headerlink" href="#memory-domains" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">AMDGPU_GEM_DOMAIN_CPU</span></code>       System memory that is not GPU accessible.
Memory in this pool could be swapped out to disk if there is pressure.</p>
<p><code class="docutils literal"><span class="pre">AMDGPU_GEM_DOMAIN_GTT</span></code>       GPU accessible system memory, mapped into the
GPU&#8217;s virtual address space via gart. Gart memory linearizes non-contiguous
pages of system memory, allows GPU access system memory in a linezrized
fashion.</p>
<p><code class="docutils literal"><span class="pre">AMDGPU_GEM_DOMAIN_VRAM</span></code>      Local video memory. For APUs, it is memory
carved out by the BIOS.</p>
<p><code class="docutils literal"><span class="pre">AMDGPU_GEM_DOMAIN_GDS</span></code>       Global on-chip data storage used to share data
across shader threads.</p>
<p><code class="docutils literal"><span class="pre">AMDGPU_GEM_DOMAIN_GWS</span></code>       Global wave sync, used to synchronize the
execution of all the waves on a device.</p>
<p><code class="docutils literal"><span class="pre">AMDGPU_GEM_DOMAIN_OA</span></code>        Ordered append, used by 3D or Compute engines
for appending data.</p>
</div>
<div class="section" id="buffer-objects">
<h3>Buffer Objects<a class="headerlink" href="#buffer-objects" title="Permalink to this headline">¶</a></h3>
<p>This defines the interfaces to operate on an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object which
represents memory used by driver (VRAM, system memory, etc.). The driver
provides DRM/GEM APIs to userspace. DRM/GEM APIs then use these interfaces
to create/destroy/set buffer object which are then managed by the kernel TTM
memory manager.
The interfaces are also used internally by kernel clients, including gfx,
uvd, etc. for kernel managed allocations used by the GPU.</p>
<dl class="function">
<dt id="c.amdgpu_bo_subtract_pin_size">
void <code class="descname">amdgpu_bo_subtract_pin_size</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_subtract_pin_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove BO from pin_size accounting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called when a BO stops being pinned, and updates the
<code class="xref c c-type docutils literal"><span class="pre">amdgpu_device</span></code> pin_size values accordingly.</p>
<dl class="function">
<dt id="c.amdgpu_bo_is_amdgpu_bo">
bool <code class="descname">amdgpu_bo_is_amdgpu_bo</code><span class="sig-paren">(</span>struct ttm_buffer_object *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_is_amdgpu_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the buffer object is an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>buffer object to be checked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Uses destroy function associated with the object to determine if this is
an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code>.</p>
<p><strong>Return</strong></p>
<p>true if the object belongs to <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code>, false if not.</p>
<dl class="function">
<dt id="c.amdgpu_bo_placement_from_domain">
void <code class="descname">amdgpu_bo_placement_from_domain</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;abo</em>, u32<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_placement_from_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>set buffer&#8217;s placement</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">abo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object whose placement is to be set</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>requested domain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer&#8217;s placement according to requested domain and the buffer&#8217;s
flags.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_reserved">
int <code class="descname">amdgpu_bo_create_reserved</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned long<em>&nbsp;size</em>, int<em>&nbsp;align</em>, u32<em>&nbsp;domain</em>, struct amdgpu_bo **<em>&nbsp;bo_ptr</em>, u64 *<em>&nbsp;gpu_addr</em>, void **<em>&nbsp;cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_reserved" title="Permalink to this definition">¶</a></dt>
<dd><p>create reserved BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size for the new BO</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">align</span></code></dt>
<dd>alignment for the new BO</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>where to place it</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo_ptr</span></code></dt>
<dd>used to initialize BOs in structures</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">gpu_addr</span></code></dt>
<dd>GPU addr of the pinned BO</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">cpu_addr</span></code></dt>
<dd>optional CPU address mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and pins a BO for kernel internal use, and returns it still
reserved.</p>
<p><strong>Note</strong></p>
<p>For bo_ptr new BO is only created if bo_ptr points to NULL.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create_kernel">
int <code class="descname">amdgpu_bo_create_kernel</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned long<em>&nbsp;size</em>, int<em>&nbsp;align</em>, u32<em>&nbsp;domain</em>, struct amdgpu_bo **<em>&nbsp;bo_ptr</em>, u64 *<em>&nbsp;gpu_addr</em>, void **<em>&nbsp;cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>create BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>size for the new BO</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">align</span></code></dt>
<dd>alignment for the new BO</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>where to place it</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo_ptr</span></code></dt>
<dd>used to initialize BOs in structures</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">gpu_addr</span></code></dt>
<dd>GPU addr of the pinned BO</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">cpu_addr</span></code></dt>
<dd>optional CPU address mapping</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates and pins a BO for kernel internal use.</p>
<p><strong>Note</strong></p>
<p>For bo_ptr new BO is only created if bo_ptr points to NULL.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_bo_free_kernel">
void <code class="descname">amdgpu_bo_free_kernel</code><span class="sig-paren">(</span>struct amdgpu_bo **<em>&nbsp;bo</em>, u64 *<em>&nbsp;gpu_addr</em>, void **<em>&nbsp;cpu_addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_free_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>free BO for kernel use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu BO to free</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">gpu_addr</span></code></dt>
<dd>pointer to where the BO&#8217;s GPU memory space address was stored</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">cpu_addr</span></code></dt>
<dd>pointer to where the BO&#8217;s CPU memory space address was stored</dd>
</dl>
<p><strong>Description</strong></p>
<p>unmaps and unpin a BO for kernel internal use.</p>
<dl class="function">
<dt id="c.amdgpu_bo_create">
int <code class="descname">amdgpu_bo_create</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_param *<em>&nbsp;bp</em>, struct amdgpu_bo **<em>&nbsp;bo_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_param</span> <span class="pre">*</span> <span class="pre">bp</span></code></dt>
<dd>parameters to be used for the buffer object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo_ptr</span></code></dt>
<dd>pointer to the buffer object pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object; and if requested, also creates a
shadow object.
Shadow object is used to backup the original buffer object, and is always
in GTT.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_backup_to_shadow">
int <code class="descname">amdgpu_bo_backup_to_shadow</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_ring *<em>&nbsp;ring</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;resv</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em>, bool<em>&nbsp;direct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_backup_to_shadow" title="Permalink to this definition">¶</a></dt>
<dd><p>Backs up an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_ring</span> <span class="pre">*</span> <span class="pre">ring</span></code></dt>
<dd>amdgpu_ring for the engine handling the buffer operations</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer to be backed up</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">resv</span></code></dt>
<dd>reservation object with embedded fence</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>dma_fence associated with the operation</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">direct</span></code></dt>
<dd>whether to submit the job directly</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object to its shadow object.
Not used for now.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_validate">
int <code class="descname">amdgpu_bo_validate</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_validate" title="Permalink to this definition">¶</a></dt>
<dd><p>validate an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>pointer to the buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets placement according to domain; and changes placement and caching
policy of the buffer object according to the placement.
This is used for validating shadow bos.  It calls <code class="xref c c-func docutils literal"><span class="pre">ttm_bo_validate()</span></code> to
make sure the buffer is resident where it needs to be.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_restore_from_shadow">
int <code class="descname">amdgpu_bo_restore_from_shadow</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_ring *<em>&nbsp;ring</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.reservation_object" title="reservation_object">reservation_object</a> *<em>&nbsp;resv</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em>, bool<em>&nbsp;direct</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_restore_from_shadow" title="Permalink to this definition">¶</a></dt>
<dd><p>restore an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_ring</span> <span class="pre">*</span> <span class="pre">ring</span></code></dt>
<dd>amdgpu_ring for the engine handling the buffer operations</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer to be restored</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span> <span class="pre">*</span> <span class="pre">resv</span></code></dt>
<dd>reservation object with embedded fence</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>dma_fence associated with the operation</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">direct</span></code></dt>
<dd>whether to submit the job directly</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copies a buffer object&#8217;s shadow content back to the object.
This is used for recovering a buffer from its shadow in case of a gpu
reset where vram context may be lost.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kmap">
int <code class="descname">amdgpu_bo_kmap</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, void **<em>&nbsp;ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object to be mapped</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">ptr</span></code></dt>
<dd>kernel virtual address to be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <code class="xref c c-func docutils literal"><span class="pre">ttm_bo_kmap()</span></code> to set up the kernel virtual mapping; calls
<a class="reference internal" href="#c.amdgpu_bo_kptr" title="amdgpu_bo_kptr"><code class="xref c c-func docutils literal"><span class="pre">amdgpu_bo_kptr()</span></code></a> to get the kernel virtual address.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kptr">
void * <code class="descname">amdgpu_bo_kptr</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kptr" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a kernel virtual address of the buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <code class="xref c c-func docutils literal"><span class="pre">ttm_kmap_obj_virtual()</span></code> to get the kernel virtual address</p>
<p><strong>Return</strong></p>
<p>the virtual address of a buffer object area.</p>
<dl class="function">
<dt id="c.amdgpu_bo_kunmap">
void <code class="descname">amdgpu_bo_kunmap</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_kunmap" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object to be unmapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unmaps a kernel map set up by <a class="reference internal" href="#c.amdgpu_bo_kmap" title="amdgpu_bo_kmap"><code class="xref c c-func docutils literal"><span class="pre">amdgpu_bo_kmap()</span></code></a>.</p>
<dl class="function">
<dt id="c.amdgpu_bo_ref">
struct amdgpu_bo * <code class="descname">amdgpu_bo_ref</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_ref" title="Permalink to this definition">¶</a></dt>
<dd><p>reference an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>References the contained <code class="xref c c-type docutils literal"><span class="pre">ttm_buffer_object</span></code>.</p>
<p><strong>Return</strong></p>
<p>a refcounted pointer to the <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object.</p>
<dl class="function">
<dt id="c.amdgpu_bo_unref">
void <code class="descname">amdgpu_bo_unref</code><span class="sig-paren">(</span>struct amdgpu_bo **<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_unref" title="Permalink to this definition">¶</a></dt>
<dd><p>unreference an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">**</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unreferences the contained <code class="xref c c-type docutils literal"><span class="pre">ttm_buffer_object</span></code> and clear the pointer</p>
<dl class="function">
<dt id="c.amdgpu_bo_pin_restricted">
int <code class="descname">amdgpu_bo_pin_restricted</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, u32<em>&nbsp;domain</em>, u64<em>&nbsp;min_offset</em>, u64<em>&nbsp;max_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_pin_restricted" title="Permalink to this definition">¶</a></dt>
<dd><p>pin an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object to be pinned</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>domain to be pinned to</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">min_offset</span></code></dt>
<dd>the start of requested address range</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">max_offset</span></code></dt>
<dd>the end of requested address range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pins the buffer object according to requested domain and address range. If
the memory is unbound gart memory, binds the pages into gart table. Adjusts
pin_count and pin_size accordingly.</p>
<p>Pinning means to lock pages in memory along with keeping them at a fixed
offset. It is required when a buffer can not be moved, for example, when
a display buffer is being scanned out.</p>
<p>Compared with <a class="reference internal" href="#c.amdgpu_bo_pin" title="amdgpu_bo_pin"><code class="xref c c-func docutils literal"><span class="pre">amdgpu_bo_pin()</span></code></a>, this function gives more flexibility on
where to pin a buffer if there are specific restrictions on where a buffer
must be located.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_pin">
int <code class="descname">amdgpu_bo_pin</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, u32<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_pin" title="Permalink to this definition">¶</a></dt>
<dd><p>pin an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object to be pinned</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">domain</span></code></dt>
<dd>domain to be pinned to</dd>
</dl>
<p><strong>Description</strong></p>
<p>A simple wrapper to <a class="reference internal" href="#c.amdgpu_bo_pin_restricted" title="amdgpu_bo_pin_restricted"><code class="xref c c-func docutils literal"><span class="pre">amdgpu_bo_pin_restricted()</span></code></a>.
Provides a simpler API for buffers that do not have any strict restrictions
on where a buffer must be located.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_unpin">
int <code class="descname">amdgpu_bo_unpin</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_unpin" title="Permalink to this definition">¶</a></dt>
<dd><p>unpin an <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object to be unpinned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decreases the pin_count, and clears the flags if pin_count reaches 0.
Changes placement and pin size accordingly.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_evict_vram">
int <code class="descname">amdgpu_bo_evict_vram</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_evict_vram" title="Permalink to this definition">¶</a></dt>
<dd><p>evict VRAM buffers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Evicts all VRAM buffers on the lru list of the memory type.
Mainly used for evicting vram at suspend time.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_init">
int <code class="descname">amdgpu_bo_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize memory manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <code class="xref c c-func docutils literal"><span class="pre">amdgpu_ttm_init()</span></code> to initialize amdgpu memory manager.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_late_init">
int <code class="descname">amdgpu_bo_late_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_late_init" title="Permalink to this definition">¶</a></dt>
<dd><p>late init</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <code class="xref c c-func docutils literal"><span class="pre">amdgpu_ttm_late_init()</span></code> to free resources used earlier during
initialization.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fini">
void <code class="descname">amdgpu_bo_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down memory manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reverses <a class="reference internal" href="#c.amdgpu_bo_init" title="amdgpu_bo_init"><code class="xref c c-func docutils literal"><span class="pre">amdgpu_bo_init()</span></code></a> to tear down memory manager.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fbdev_mmap">
int <code class="descname">amdgpu_bo_fbdev_mmap</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fbdev_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>mmap fbdev memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vma as input from the fbdev mmap method</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <code class="xref c c-func docutils literal"><span class="pre">ttm_fbdev_mmap()</span></code> to mmap fbdev memory if it is backed by a bo.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_set_tiling_flags">
int <code class="descname">amdgpu_bo_set_tiling_flags</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, u64<em>&nbsp;tiling_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_set_tiling_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>set tiling flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">tiling_flags</span></code></dt>
<dd>new flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer object&#8217;s tiling flags with the new one. Used by GEM ioctl or
kernel driver to set the tiling flags on a buffer.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_tiling_flags">
void <code class="descname">amdgpu_bo_get_tiling_flags</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, u64 *<em>&nbsp;tiling_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_tiling_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>get tiling flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">*</span> <span class="pre">tiling_flags</span></code></dt>
<dd>returned flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets buffer object&#8217;s tiling flags. Used by GEM ioctl or kernel driver to
set the tiling flags on a buffer.</p>
<dl class="function">
<dt id="c.amdgpu_bo_set_metadata">
int <code class="descname">amdgpu_bo_set_metadata</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, void *<em>&nbsp;metadata</em>, uint32_t<em>&nbsp;metadata_size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_set_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>set metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">metadata</span></code></dt>
<dd>new metadata</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">metadata_size</span></code></dt>
<dd>size of the new metadata</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>flags of the new metadata</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets buffer object&#8217;s metadata, its size and flags.
Used via GEM ioctl.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_metadata">
int <code class="descname">amdgpu_bo_get_metadata</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, void *<em>&nbsp;buffer</em>, size_t<em>&nbsp;buffer_size</em>, uint32_t *<em>&nbsp;metadata_size</em>, uint64_t *<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>get metadata</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt>
<dd>returned metadata</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">buffer_size</span></code></dt>
<dd>size of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">metadata_size</span></code></dt>
<dd>size of the returned metadata</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">flags</span></code></dt>
<dd>flags of the returned metadata</dd>
</dl>
<p><strong>Description</strong></p>
<p>Gets buffer object&#8217;s metadata, its size and flags. buffer_size shall not be
less than metadata_size.
Used via GEM ioctl.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_move_notify">
void <code class="descname">amdgpu_bo_move_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object *<em>&nbsp;bo</em>, bool<em>&nbsp;evict</em>, struct ttm_mem_reg *<em>&nbsp;new_mem</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_move_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notification about a memory move</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>pointer to a buffer object</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">evict</span></code></dt>
<dd>if this move is evicting the buffer from the graphics address space</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ttm_mem_reg</span> <span class="pre">*</span> <span class="pre">new_mem</span></code></dt>
<dd>new information of the bufer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Marks the corresponding <code class="xref c c-type docutils literal"><span class="pre">amdgpu_bo</span></code> buffer object as invalid, also performs
bookkeeping.
TTM driver callback which is called when ttm moves a buffer.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fault_reserve_notify">
int <code class="descname">amdgpu_bo_fault_reserve_notify</code><span class="sig-paren">(</span>struct ttm_buffer_object *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fault_reserve_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>notification about a memory fault</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ttm_buffer_object</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>pointer to a buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notifies the driver we are taking a fault on this BO and have reserved it,
also performs bookkeeping.
TTM driver callback for dealing with vm faults.</p>
<p><strong>Return</strong></p>
<p>0 for success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.amdgpu_bo_fence">
void <code class="descname">amdgpu_bo_fence</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, bool<em>&nbsp;shared</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_fence" title="Permalink to this definition">¶</a></dt>
<dd><p>add fence to buffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>buffer object in question</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence to add</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">shared</span></code></dt>
<dd>true if fence should be added shared</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_bo_gpu_offset">
u64 <code class="descname">amdgpu_bo_gpu_offset</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_gpu_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>return GPU offset of bo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu object for which we query the offset</dd>
</dl>
<p><strong>Note</strong></p>
<p>object should either be pinned or reserved when calling this
function, it might be useful to add check for this for debugging.</p>
<p><strong>Return</strong></p>
<p>current GPU offset of the object.</p>
<dl class="function">
<dt id="c.amdgpu_bo_get_preferred_pin_domain">
uint32_t <code class="descname">amdgpu_bo_get_preferred_pin_domain</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, uint32_t<em>&nbsp;domain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_bo_get_preferred_pin_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>get preferred domain for scanout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device object</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">domain</span></code></dt>
<dd>allowed <a class="reference internal" href="#amdgpu-memory-domains"><span>memory domains</span></a></dd>
</dl>
<p><strong>Return</strong></p>
<p>Which of the allowed domains is preferred for pinning the BO for scanout.</p>
</div>
<div class="section" id="prime-buffer-sharing">
<h3>PRIME Buffer Sharing<a class="headerlink" href="#prime-buffer-sharing" title="Permalink to this headline">¶</a></h3>
<p>The following callback implementations are used for <a class="reference internal" href="drm-mm.html#prime-buffer-sharing"><span>sharing GEM buffer
objects between different devices via PRIME</span></a>.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_get_sg_table">
struct sg_table * <code class="descname">amdgpu_gem_prime_get_sg_table</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_get_sg_table" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_get_sg_table</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Return</strong></p>
<p>A scatter/gather table for the pinned pages of the buffer object&#8217;s memory.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_vmap">
void * <code class="descname">amdgpu_gem_prime_vmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_vmap" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.vmap</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up an in-kernel virtual mapping of the buffer object&#8217;s memory.</p>
<p><strong>Return</strong></p>
<p>The virtual address of the mapping or an error pointer.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_vunmap">
void <code class="descname">amdgpu_gem_prime_vunmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, void *<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_vunmap" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.vunmap</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>virtual address (unused)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down the in-kernel virtual mapping of the buffer object&#8217;s memory.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_mmap">
int <code class="descname">amdgpu_gem_prime_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_mmap</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>virtual memory area</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up a userspace mapping of the buffer object&#8217;s memory in the given
virtual memory area.</p>
<p><strong>Return</strong></p>
<p>0 on success or negative error code.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_import_sg_table">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">amdgpu_gem_prime_import_sg_table</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em>, struct sg_table *<em>&nbsp;sg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_import_sg_table" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_import_sg_table</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>DMA-buf attachment</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_table</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>Scatter/gather table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Import shared DMA buffer memory exported by another device.</p>
<p><strong>Return</strong></p>
<p>A new GEM buffer object of the given DRM device, representing the memory
described by the given DMA-buf attachment and scatter/gather table.</p>
<dl class="function">
<dt id="c.amdgpu_gem_map_attach">
int <code class="descname">amdgpu_gem_map_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_map_attach" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.attach</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>shared DMA buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>DMA-buf attachment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Makes sure that the shared DMA buffer can be accessed by the target device.
For now, simply pins it to the GTT domain, where it should be accessible by
all DMA devices.</p>
<p><strong>Return</strong></p>
<p>0 on success or negative error code.</p>
<dl class="function">
<dt id="c.amdgpu_gem_map_detach">
void <code class="descname">amdgpu_gem_map_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_attachment" title="dma_buf_attachment">dma_buf_attachment</a> *<em>&nbsp;attach</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_map_detach" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.detach</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>shared DMA buffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf_attachment</span> <span class="pre">*</span> <span class="pre">attach</span></code></dt>
<dd>DMA-buf attachment</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called when a shared DMA buffer no longer needs to be accessible by
the other device. For now, simply unpins the buffer from GTT.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_res_obj">
struct <a class="reference internal" href="../driver-api/dma-buf.html#c.reservation_object" title="reservation_object">reservation_object</a> * <code class="descname">amdgpu_gem_prime_res_obj</code><span class="sig-paren">(</span>struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_res_obj" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_res_obj</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>GEM buffer object</dd>
</dl>
<p><strong>Return</strong></p>
<p>The buffer object&#8217;s reservation object.</p>
<dl class="function">
<dt id="c.amdgpu_gem_begin_cpu_access">
int <code class="descname">amdgpu_gem_begin_cpu_access</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em>, enum dma_data_direction<em>&nbsp;direction</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_begin_cpu_access" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf_ops" title="dma_buf_ops"><code class="xref c c-type docutils literal"><span class="pre">dma_buf_ops.begin_cpu_access</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>shared DMA buffer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dma_data_direction</span> <span class="pre">direction</span></code></dt>
<dd>direction of DMA transfer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called before CPU access to the shared DMA buffer&#8217;s memory. If it&#8217;s
a read access, the buffer is moved to the GTT domain if possible, for optimal
CPU read performance.</p>
<p><strong>Return</strong></p>
<p>0 on success or negative error code.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_export">
struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> * <code class="descname">amdgpu_gem_prime_export</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> *<em>&nbsp;gobj</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_export" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_export</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_gem_object</span> <span class="pre">*</span> <span class="pre">gobj</span></code></dt>
<dd>GEM buffer object</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags like DRM_CLOEXEC and DRM_RDWR</dd>
</dl>
<p><strong>Description</strong></p>
<p>The main work is done by the <a class="reference internal" href="drm-mm.html#c.drm_gem_prime_export" title="drm_gem_prime_export"><code class="xref c c-type docutils literal"><span class="pre">drm_gem_prime_export</span></code></a> helper, which in turn
uses <a class="reference internal" href="#c.amdgpu_gem_prime_res_obj" title="amdgpu_gem_prime_res_obj"><code class="xref c c-type docutils literal"><span class="pre">amdgpu_gem_prime_res_obj</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Shared DMA buffer representing the GEM buffer object from the given device.</p>
<dl class="function">
<dt id="c.amdgpu_gem_prime_import">
struct <a class="reference internal" href="drm-mm.html#c.drm_gem_object" title="drm_gem_object">drm_gem_object</a> * <code class="descname">amdgpu_gem_prime_import</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf">dma_buf</a> *<em>&nbsp;dma_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_gem_prime_import" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.gem_prime_import</span></code></a> implementation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span> <span class="pre">*</span> <span class="pre">dma_buf</span></code></dt>
<dd>Shared DMA buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>The main work is done by the <a class="reference internal" href="drm-mm.html#c.drm_gem_prime_import" title="drm_gem_prime_import"><code class="xref c c-type docutils literal"><span class="pre">drm_gem_prime_import</span></code></a> helper, which in turn
uses <a class="reference internal" href="#c.amdgpu_gem_prime_import_sg_table" title="amdgpu_gem_prime_import_sg_table"><code class="xref c c-type docutils literal"><span class="pre">amdgpu_gem_prime_import_sg_table</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>GEM buffer object representing the shared DMA buffer for the given device.</p>
</div>
<div class="section" id="mmu-notifier">
<h3>MMU Notifier<a class="headerlink" href="#mmu-notifier" title="Permalink to this headline">¶</a></h3>
<p>For coherent userptr handling registers an MMU notifier to inform the driver
about updates on the page tables of a process.</p>
<p>When somebody tries to invalidate the page tables we block the update until
all operations on the pages in question are completed, then those pages are
marked as accessed and also dirty if it wasn&#8217;t a read only access.</p>
<p>New command submissions using the userptrs in question are delayed until all
page table invalidation are completed and we once more see a coherent process
address space.</p>
<dl class="type">
<dt id="c.amdgpu_mn">
struct <code class="descname">amdgpu_mn</code><a class="headerlink" href="#c.amdgpu_mn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct amdgpu_mn {
  struct amdgpu_device    *adev;
  struct mm_struct        *mm;
  struct mmu_notifier     mn;
  enum amdgpu_mn_type     type;
  struct work_struct      work;
  struct hlist_node       node;
  struct rw_semaphore     lock;
  struct rb_root_cached   objects;
  struct mutex            read_lock;
  atomic_t recursion;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">mm</span></code></dt>
<dd>process address space</dd>
<dt><code class="docutils literal"><span class="pre">mn</span></code></dt>
<dd>MMU notifier structure</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of MMU notifier</dd>
<dt><code class="docutils literal"><span class="pre">work</span></code></dt>
<dd>destruction work item</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>hash table node to find structure by adev and mn</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>rw semaphore protecting the notifier nodes</dd>
<dt><code class="docutils literal"><span class="pre">objects</span></code></dt>
<dd>interval tree containing amdgpu_mn_nodes</dd>
<dt><code class="docutils literal"><span class="pre">read_lock</span></code></dt>
<dd>mutex for recursive locking of <strong>lock</strong></dd>
<dt><code class="docutils literal"><span class="pre">recursion</span></code></dt>
<dd>depth of recursion</dd>
</dl>
<p><strong>Description</strong></p>
<p>Data for each amdgpu device and process address space.</p>
<dl class="type">
<dt id="c.amdgpu_mn_node">
struct <code class="descname">amdgpu_mn_node</code><a class="headerlink" href="#c.amdgpu_mn_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct amdgpu_mn_node {
  struct interval_tree_node       it;
  struct list_head                bos;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">it</span></code></dt>
<dd>interval node defining start-last of the affected address range</dd>
<dt><code class="docutils literal"><span class="pre">bos</span></code></dt>
<dd>list of all BOs in the affected address range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Manages all BOs which are affected of a certain range of address space.</p>
<dl class="function">
<dt id="c.amdgpu_mn_destroy">
void <code class="descname">amdgpu_mn_destroy</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy the MMU notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>previously sheduled work item</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lazy destroys the notifier from a work item</p>
<dl class="function">
<dt id="c.amdgpu_mn_release">
void <code class="descname">amdgpu_mn_release</code><span class="sig-paren">(</span>struct mmu_notifier *<em>&nbsp;mn</em>, struct mm_struct *<em>&nbsp;mm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_release" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm destruction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mmu_notifier</span> <span class="pre">*</span> <span class="pre">mn</span></code></dt>
<dd>our notifier</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>the mm this callback is about</dd>
</dl>
<p><strong>Description</strong></p>
<p>Shedule a work item to lazy destroy our notifier.</p>
<dl class="function">
<dt id="c.amdgpu_mn_lock">
void <code class="descname">amdgpu_mn_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_mn" title="amdgpu_mn">amdgpu_mn</a> *<em>&nbsp;mn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>take the write side lock for this notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_mn</span> <span class="pre">*</span> <span class="pre">mn</span></code></dt>
<dd>our notifier</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_mn_unlock">
void <code class="descname">amdgpu_mn_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_mn" title="amdgpu_mn">amdgpu_mn</a> *<em>&nbsp;mn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>drop the write side lock for this notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_mn</span> <span class="pre">*</span> <span class="pre">mn</span></code></dt>
<dd>our notifier</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_mn_read_lock">
int <code class="descname">amdgpu_mn_read_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_mn" title="amdgpu_mn">amdgpu_mn</a> *<em>&nbsp;amn</em>, bool<em>&nbsp;blockable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_read_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>take the read side lock for this notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_mn</span> <span class="pre">*</span> <span class="pre">amn</span></code></dt>
<dd>our notifier</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">blockable</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_mn_read_unlock">
void <code class="descname">amdgpu_mn_read_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_mn" title="amdgpu_mn">amdgpu_mn</a> *<em>&nbsp;amn</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_read_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>drop the read side lock for this notifier</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_mn</span> <span class="pre">*</span> <span class="pre">amn</span></code></dt>
<dd>our notifier</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_mn_invalidate_node">
void <code class="descname">amdgpu_mn_invalidate_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_mn_node" title="amdgpu_mn_node">amdgpu_mn_node</a> *<em>&nbsp;node</em>, unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_invalidate_node" title="Permalink to this definition">¶</a></dt>
<dd><p>unmap all BOs of a node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_mn_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>the node with the BOs to unmap</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>start of address range affected</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>end of address range affected</dd>
</dl>
<p><strong>Description</strong></p>
<p>Block for operations on BOs to finish and mark pages as accessed and
potentially dirty.</p>
<dl class="function">
<dt id="c.amdgpu_mn_invalidate_range_start_gfx">
int <code class="descname">amdgpu_mn_invalidate_range_start_gfx</code><span class="sig-paren">(</span>struct mmu_notifier *<em>&nbsp;mn</em>, struct mm_struct *<em>&nbsp;mm</em>, unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em>, bool<em>&nbsp;blockable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_invalidate_range_start_gfx" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mmu_notifier</span> <span class="pre">*</span> <span class="pre">mn</span></code></dt>
<dd>our notifier</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>the mm this callback is about</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>start of updated range</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>end of updated range</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">blockable</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>Block for operations on BOs to finish and mark pages as accessed and
potentially dirty.</p>
<dl class="function">
<dt id="c.amdgpu_mn_invalidate_range_start_hsa">
int <code class="descname">amdgpu_mn_invalidate_range_start_hsa</code><span class="sig-paren">(</span>struct mmu_notifier *<em>&nbsp;mn</em>, struct mm_struct *<em>&nbsp;mm</em>, unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em>, bool<em>&nbsp;blockable</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_invalidate_range_start_hsa" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mmu_notifier</span> <span class="pre">*</span> <span class="pre">mn</span></code></dt>
<dd>our notifier</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>the mm this callback is about</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>start of updated range</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>end of updated range</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">blockable</span></code></dt>
<dd><em>undescribed</em></dd>
</dl>
<p><strong>Description</strong></p>
<p>We temporarily evict all BOs between start and end. This
necessitates evicting all user-mode queues of the process. The BOs
are restorted in amdgpu_mn_invalidate_range_end_hsa.</p>
<dl class="function">
<dt id="c.amdgpu_mn_invalidate_range_end">
void <code class="descname">amdgpu_mn_invalidate_range_end</code><span class="sig-paren">(</span>struct mmu_notifier *<em>&nbsp;mn</em>, struct mm_struct *<em>&nbsp;mm</em>, unsigned long<em>&nbsp;start</em>, unsigned long<em>&nbsp;end</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_invalidate_range_end" title="Permalink to this definition">¶</a></dt>
<dd><p>callback to notify about mm change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mmu_notifier</span> <span class="pre">*</span> <span class="pre">mn</span></code></dt>
<dd>our notifier</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span> <span class="pre">*</span> <span class="pre">mm</span></code></dt>
<dd>the mm this callback is about</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">start</span></code></dt>
<dd>start of updated range</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">end</span></code></dt>
<dd>end of updated range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release the lock again to allow new command submissions.</p>
<dl class="function">
<dt id="c.amdgpu_mn_get">
struct <a class="reference internal" href="#c.amdgpu_mn" title="amdgpu_mn">amdgpu_mn</a> * <code class="descname">amdgpu_mn_get</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, enum amdgpu_mn_type<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_get" title="Permalink to this definition">¶</a></dt>
<dd><p>create notifier context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">amdgpu_mn_type</span> <span class="pre">type</span></code></dt>
<dd>type of MMU notifier context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a notifier context for current-&gt;mm.</p>
<dl class="function">
<dt id="c.amdgpu_mn_register">
int <code class="descname">amdgpu_mn_register</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em>, unsigned long<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a BO for notifier updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>userptr addr we should monitor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers an MMU notifier for the given BO at the specified address.
Returns 0 on success, -ERRNO if anything goes wrong.</p>
<dl class="function">
<dt id="c.amdgpu_mn_unregister">
void <code class="descname">amdgpu_mn_unregister</code><span class="sig-paren">(</span>struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_mn_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a BO for notifier updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove any registration of MMU notifier updates from the buffer object.</p>
</div>
<div class="section" id="amdgpu-virtual-memory">
<h3>AMDGPU Virtual Memory<a class="headerlink" href="#amdgpu-virtual-memory" title="Permalink to this headline">¶</a></h3>
<p>GPUVM is similar to the legacy gart on older asics, however
rather than there being a single global gart table
for the entire GPU, there are multiple VM page tables active
at any given time.  The VM page tables can contain a mix
vram pages and system memory pages and system memory pages
can be mapped as snooped (cached system pages) or unsnooped
(uncached system pages).
Each VM has an ID associated with it and there is a page table
associated with each VMID.  When execting a command buffer,
the kernel tells the the ring what VMID to use for that command
buffer.  VMIDs are allocated dynamically as commands are submitted.
The userspace drivers maintain their own address space and the kernel
sets up their pages tables accordingly when they submit their
command buffers and a VMID is assigned.
Cayman/Trinity support up to 8 active VMs at any given time;
SI supports 16.</p>
<dl class="type">
<dt id="c.amdgpu_pte_update_params">
struct <code class="descname">amdgpu_pte_update_params</code><a class="headerlink" href="#c.amdgpu_pte_update_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Local structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct amdgpu_pte_update_params {
  struct amdgpu_device *adev;
  struct amdgpu_vm *vm;
  uint64_t src;
  struct amdgpu_ib *ib;
  void (*func)(struct amdgpu_pte_update_params *params,struct amdgpu_bo *bo, uint64_t pe,uint64_t addr, unsigned count, uint32_t incr, uint64_t flags);
  dma_addr_t *pages_addr;
  void *kptr;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">adev</span></code></dt>
<dd>amdgpu device we do this update for</dd>
<dt><code class="docutils literal"><span class="pre">vm</span></code></dt>
<dd>optional amdgpu_vm we do this update for</dd>
<dt><code class="docutils literal"><span class="pre">src</span></code></dt>
<dd>address where to copy page table entries from</dd>
<dt><code class="docutils literal"><span class="pre">ib</span></code></dt>
<dd>indirect buffer to fill with commands</dd>
<dt><code class="docutils literal"><span class="pre">func</span></code></dt>
<dd>Function which actually does the update</dd>
<dt><code class="docutils literal"><span class="pre">pages_addr</span></code></dt>
<dd>DMA addresses to use for mapping, used during VM update by CPU</dd>
<dt><code class="docutils literal"><span class="pre">kptr</span></code></dt>
<dd>Kernel pointer of PD/PT BO that needs to be updated,
used during VM update by CPU</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encapsulate some VM table update parameters to reduce
the number of function parameters</p>
<dl class="type">
<dt id="c.amdgpu_prt_cb">
struct <code class="descname">amdgpu_prt_cb</code><a class="headerlink" href="#c.amdgpu_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to disable partial resident texture feature from a fence callback</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct amdgpu_prt_cb {
  struct amdgpu_device *adev;
  struct dma_fence_cb cb;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">adev</span></code></dt>
<dd>amdgpu device</dd>
<dt><code class="docutils literal"><span class="pre">cb</span></code></dt>
<dd>callback</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_bo_base_init">
void <code class="descname">amdgpu_vm_bo_base_init</code><span class="sig-paren">(</span>struct amdgpu_vm_bo_base *<em>&nbsp;base</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_base_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds bo to the list of bos associated with the vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm_bo_base</span> <span class="pre">*</span> <span class="pre">base</span></code></dt>
<dd>base structure for tracking BO usage in a VM</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm to which bo is to be added</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize a bo_va_base structure and add it to the appropriate lists</p>
<dl class="function">
<dt id="c.amdgpu_vm_level_shift">
unsigned <code class="descname">amdgpu_vm_level_shift</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_level_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>return the addr shift for each level</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of bits the pfn needs to be right shifted for a level.</p>
<dl class="function">
<dt id="c.amdgpu_vm_num_entries">
unsigned <code class="descname">amdgpu_vm_num_entries</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_num_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>return the number of entries in a PD/PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of entries in a page directory or page table.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_size">
unsigned <code class="descname">amdgpu_vm_bo_size</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_size" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the size of the BOs in bytes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
</dl>
<p><strong>Return</strong></p>
<p>The size of the BO for a page directory or page table in bytes.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_pd_bo">
void <code class="descname">amdgpu_vm_get_pd_bo</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, struct list_head *<em>&nbsp;validated</em>, struct amdgpu_bo_list_entry *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_pd_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>add the VM PD to a validation list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm providing the BOs</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">validated</span></code></dt>
<dd>head of validation list</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_list_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>entry to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add the page directory to the list of BOs to
validate for command submission.</p>
<dl class="function">
<dt id="c.amdgpu_vm_validate_pt_bos">
int <code class="descname">amdgpu_vm_validate_pt_bos</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, int (*<a class="reference internal" href="../networking/kapi.html#c.validate" title="validate">validate</a>) (void<em>&nbsp;*p</em>, struct amdgpu_bo<em>&nbsp;*bo</em>, void *<em>&nbsp;param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_validate_pt_bos" title="Permalink to this definition">¶</a></dt>
<dd><p>validate the page table BOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm providing the BOs</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*p,</span> <span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*bo)</span> <span class="pre">validate</span></code></dt>
<dd>callback to do the validation</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">param</span></code></dt>
<dd>parameter for the validation callback</dd>
</dl>
<p><strong>Description</strong></p>
<p>Validate the page table BOs on command submission if neccessary.</p>
<p><strong>Return</strong></p>
<p>Validation result.</p>
<dl class="function">
<dt id="c.amdgpu_vm_ready">
bool <code class="descname">amdgpu_vm_ready</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_ready" title="Permalink to this definition">¶</a></dt>
<dd><p>check VM is ready for updates</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if all VM PDs/PTs are ready for updates</p>
<p><strong>Return</strong></p>
<p>True if eviction list is empty.</p>
<dl class="function">
<dt id="c.amdgpu_vm_clear_bo">
int <code class="descname">amdgpu_vm_clear_bo</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, unsigned<em>&nbsp;level</em>, bool<em>&nbsp;pte_support_ats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_clear_bo" title="Permalink to this definition">¶</a></dt>
<dd><p>initially clear the PDs/PTs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM to clear BO from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>BO to clear</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>level this BO is at</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">pte_support_ats</span></code></dt>
<dd>indicate ATS support from PTE</dd>
</dl>
<p><strong>Description</strong></p>
<p>Root PD needs to be reserved when calling this.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_alloc_levels">
int <code class="descname">amdgpu_vm_alloc_levels</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_vm_pt *<em>&nbsp;parent</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;eaddr</em>, unsigned<em>&nbsp;level</em>, bool<em>&nbsp;ats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_alloc_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate the PD/PT levels</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent PT</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>start of the address range</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">eaddr</span></code></dt>
<dd>end of the address range</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>VMPT level</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">ats</span></code></dt>
<dd>indicate ATS support from PTE</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure the page directories and page tables are allocated</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_alloc_pts">
int <code class="descname">amdgpu_vm_alloc_pts</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_alloc_pts" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate page tables.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM to allocate page tables for</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>Start address which needs to be allocated</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>Size from start address we need.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure the page tables are allocated.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_check_compute_bug">
void <code class="descname">amdgpu_vm_check_compute_bug</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_check_compute_bug" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether asic has compute vm bug</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_need_pipeline_sync">
bool <code class="descname">amdgpu_vm_need_pipeline_sync</code><span class="sig-paren">(</span>struct amdgpu_ring *<em>&nbsp;ring</em>, struct amdgpu_job *<em>&nbsp;job</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_need_pipeline_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if pipe sync is needed for job.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_ring</span> <span class="pre">*</span> <span class="pre">ring</span></code></dt>
<dd>ring on which the job will be submitted</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_job</span> <span class="pre">*</span> <span class="pre">job</span></code></dt>
<dd>job to submit</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if sync is needed.</p>
<dl class="function">
<dt id="c.amdgpu_vm_flush">
int <code class="descname">amdgpu_vm_flush</code><span class="sig-paren">(</span>struct amdgpu_ring *<em>&nbsp;ring</em>, struct amdgpu_job *<em>&nbsp;job</em>, bool<em>&nbsp;need_pipe_sync</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_flush" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware flush the vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_ring</span> <span class="pre">*</span> <span class="pre">ring</span></code></dt>
<dd>ring to use for flush</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_job</span> <span class="pre">*</span> <span class="pre">job</span></code></dt>
<dd>related job</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">need_pipe_sync</span></code></dt>
<dd>is pipe sync needed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Emit a VM flush when it is necessary.</p>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_find">
struct amdgpu_bo_va * <code class="descname">amdgpu_vm_bo_find</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find the bo_va for a specific vm &amp; bo</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>requested buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find <strong>bo</strong> inside the requested vm.
Search inside the <strong>bos</strong> vm list for the requested vm
Returns the found bo_va or NULL if none is found</p>
<p>Object has to be reserved!</p>
<p><strong>Return</strong></p>
<p>Found bo_va or NULL.</p>
<dl class="function">
<dt id="c.amdgpu_vm_do_set_ptes">
void <code class="descname">amdgpu_vm_do_set_ptes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_pte_update_params" title="amdgpu_pte_update_params">amdgpu_pte_update_params</a> *<em>&nbsp;params</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, uint64_t<em>&nbsp;pe</em>, uint64_t<em>&nbsp;addr</em>, unsigned<em>&nbsp;count</em>, uint32_t<em>&nbsp;incr</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_do_set_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to call the right asic function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_pte_update_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>see amdgpu_pte_update_params definition</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>PD/PT to update</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">pe</span></code></dt>
<dd>addr of the page entry</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>dst addr to write into pe</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>number of page entries to update</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">incr</span></code></dt>
<dd>increase next addr by incr bytes</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>hw access flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Traces the parameters and calls the right asic functions
to setup the page table using the DMA.</p>
<dl class="function">
<dt id="c.amdgpu_vm_do_copy_ptes">
void <code class="descname">amdgpu_vm_do_copy_ptes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_pte_update_params" title="amdgpu_pte_update_params">amdgpu_pte_update_params</a> *<em>&nbsp;params</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, uint64_t<em>&nbsp;pe</em>, uint64_t<em>&nbsp;addr</em>, unsigned<em>&nbsp;count</em>, uint32_t<em>&nbsp;incr</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_do_copy_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the PTEs from the GART</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_pte_update_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>see amdgpu_pte_update_params definition</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>PD/PT to update</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">pe</span></code></dt>
<dd>addr of the page entry</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>dst addr to write into pe</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>number of page entries to update</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">incr</span></code></dt>
<dd>increase next addr by incr bytes</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>hw access flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Traces the parameters and calls the DMA function to copy the PTEs.</p>
<dl class="function">
<dt id="c.amdgpu_vm_map_gart">
uint64_t <code class="descname">amdgpu_vm_map_gart</code><span class="sig-paren">(</span>const dma_addr_t *<em>&nbsp;pages_addr</em>, uint64_t<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_map_gart" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve gart mapping of addr</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">pages_addr</span></code></dt>
<dd>optional DMA address to use for lookup</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>the unmapped addr</dd>
</dl>
<p><strong>Description</strong></p>
<p>Look up the physical address of the page that the pte resolves
to.</p>
<p><strong>Return</strong></p>
<p>The pointer for the page table entry.</p>
<dl class="function">
<dt id="c.amdgpu_vm_cpu_set_ptes">
void <code class="descname">amdgpu_vm_cpu_set_ptes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_pte_update_params" title="amdgpu_pte_update_params">amdgpu_pte_update_params</a> *<em>&nbsp;params</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, uint64_t<em>&nbsp;pe</em>, uint64_t<em>&nbsp;addr</em>, unsigned<em>&nbsp;count</em>, uint32_t<em>&nbsp;incr</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_cpu_set_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to update page tables via CPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_pte_update_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>see amdgpu_pte_update_params definition</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>PD/PT to update</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">pe</span></code></dt>
<dd>kmap addr of the page entry</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>dst addr to write into pe</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">count</span></code></dt>
<dd>number of page entries to update</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">incr</span></code></dt>
<dd>increase next addr by incr bytes</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>hw access flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Write count number of PT/PD entries directly.</p>
<dl class="function">
<dt id="c.amdgpu_vm_wait_pd">
int <code class="descname">amdgpu_vm_wait_pd</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, void *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_wait_pd" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for PT BOs to be free.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>related vm</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>fence owner</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, errno otherwise.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_entry">
void <code class="descname">amdgpu_vm_get_entry</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_pte_update_params" title="amdgpu_pte_update_params">amdgpu_pte_update_params</a> *<em>&nbsp;p</em>, uint64_t<em>&nbsp;addr</em>, struct amdgpu_vm_pt **<em>&nbsp;entry</em>, struct amdgpu_vm_pt **<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>find the entry for an address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_pte_update_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>see amdgpu_pte_update_params definition</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>virtual address in question</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">**</span> <span class="pre">entry</span></code></dt>
<dd>resulting entry or NULL</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">**</span> <span class="pre">parent</span></code></dt>
<dd>parent entry</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the vm_pt entry and it&#8217;s parent for the given address.</p>
<dl class="function">
<dt id="c.amdgpu_vm_handle_huge_pages">
void <code class="descname">amdgpu_vm_handle_huge_pages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_pte_update_params" title="amdgpu_pte_update_params">amdgpu_pte_update_params</a> *<em>&nbsp;p</em>, struct amdgpu_vm_pt *<em>&nbsp;entry</em>, struct amdgpu_vm_pt *<em>&nbsp;parent</em>, unsigned<em>&nbsp;nptes</em>, uint64_t<em>&nbsp;dst</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_handle_huge_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>handle updating the PD with huge pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_pte_update_params</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>see amdgpu_pte_update_params definition</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>vm_pt entry to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent entry</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">nptes</span></code></dt>
<dd>number of PTEs updated with this operation</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">dst</span></code></dt>
<dd>destination address where the PTEs should point to</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>access flags fro the PTEs</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if we can update the PD with a huge page.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_ptes">
int <code class="descname">amdgpu_vm_update_ptes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.amdgpu_pte_update_params" title="amdgpu_pte_update_params">amdgpu_pte_update_params</a> *<em>&nbsp;params</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;end</em>, uint64_t<em>&nbsp;dst</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_ptes" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure that page tables are valid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_pte_update_params</span> <span class="pre">*</span> <span class="pre">params</span></code></dt>
<dd>see amdgpu_pte_update_params definition</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>start of GPU address range</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">end</span></code></dt>
<dd>end of GPU address range</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">dst</span></code></dt>
<dd>destination address to map to, the next dst inside the function</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>mapping flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update the page tables in the range <strong>start</strong> - <strong>end</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_update_mapping">
int <code class="descname">amdgpu_vm_bo_update_mapping</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;exclusive</em>, dma_addr_t *<em>&nbsp;pages_addr</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, uint64_t<em>&nbsp;start</em>, uint64_t<em>&nbsp;last</em>, uint64_t<em>&nbsp;flags</em>, uint64_t<em>&nbsp;addr</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_update_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>update a mapping in the vm page table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">exclusive</span></code></dt>
<dd>fence we need to sync to</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">pages_addr</span></code></dt>
<dd>DMA addresses to use for mapping</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">start</span></code></dt>
<dd>start of mapped range</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">last</span></code></dt>
<dd>last mapped entry</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>flags for the entries</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>addr to set the area to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>optional resulting fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the page table entries between <strong>start</strong> and <strong>last</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_split_mapping">
int <code class="descname">amdgpu_vm_bo_split_mapping</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;exclusive</em>, dma_addr_t *<em>&nbsp;pages_addr</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo_va_mapping *<em>&nbsp;mapping</em>, uint64_t<em>&nbsp;flags</em>, struct <a class="reference internal" href="drm-mm.html#c.drm_mm_node" title="drm_mm_node">drm_mm_node</a> *<em>&nbsp;nodes</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_split_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>split a mapping into smaller chunks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">exclusive</span></code></dt>
<dd>fence we need to sync to</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">pages_addr</span></code></dt>
<dd>DMA addresses to use for mapping</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va_mapping</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapped range and flags to use for the update</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>HW flags for the mapping</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mm_node</span> <span class="pre">*</span> <span class="pre">nodes</span></code></dt>
<dd>array of drm_mm_nodes with the MC addresses</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>optional resulting fence</dd>
</dl>
<p><strong>Description</strong></p>
<p>Split the mapping into smaller chunks so that each update fits
into a SDMA IB.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_update">
int <code class="descname">amdgpu_vm_bo_update</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, bool<em>&nbsp;clear</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update all BO mappings in the vm page table</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>requested BO and VM object</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">clear</span></code></dt>
<dd>if true clear the entries</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fill in the page table entries for <strong>bo_va</strong>.</p>
<p><strong>Return</strong></p>
<p>0 for success, -EINVAL for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_update_prt_state">
void <code class="descname">amdgpu_vm_update_prt_state</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_update_prt_state" title="Permalink to this definition">¶</a></dt>
<dd><p>update the global PRT state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_get">
void <code class="descname">amdgpu_vm_prt_get</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_get" title="Permalink to this definition">¶</a></dt>
<dd><p>add a PRT user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_put">
void <code class="descname">amdgpu_vm_prt_put</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_put" title="Permalink to this definition">¶</a></dt>
<dd><p>drop a PRT user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_prt_cb">
void <code class="descname">amdgpu_vm_prt_cb</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence_cb" title="dma_fence_cb">dma_fence_cb</a> *<em>&nbsp;_cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>callback for updating the PRT status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence for the callback</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence_cb</span> <span class="pre">*</span> <span class="pre">_cb</span></code></dt>
<dd>the callback function</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_add_prt_cb">
void <code class="descname">amdgpu_vm_add_prt_cb</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_add_prt_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>add callback for updating the PRT status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence for the callback</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_free_mapping">
void <code class="descname">amdgpu_vm_free_mapping</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo_va_mapping *<em>&nbsp;mapping</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_free_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>free a mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va_mapping</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>mapping to be freed</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>fence of the unmap operation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free a mapping and make sure we decrease the PRT usage count if applicable.</p>
<dl class="function">
<dt id="c.amdgpu_vm_prt_fini">
void <code class="descname">amdgpu_vm_prt_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_prt_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>finish all prt mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register a cleanup callback to disable PRT support after VM dies.</p>
<dl class="function">
<dt id="c.amdgpu_vm_clear_freed">
int <code class="descname">amdgpu_vm_clear_freed</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> **<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_clear_freed" title="Permalink to this definition">¶</a></dt>
<dd><p>clear freed BOs in the PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">**</span> <span class="pre">fence</span></code></dt>
<dd>optional resulting fence (unchanged if no work needed to be done
or if an error occurred)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure all freed BOs are cleared in the PT.
PTs have to be reserved and mutex must be locked!</p>
<p><strong>Return</strong></p>
<p>0 for success.</p>
<dl class="function">
<dt id="c.amdgpu_vm_handle_moved">
int <code class="descname">amdgpu_vm_handle_moved</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_handle_moved" title="Permalink to this definition">¶</a></dt>
<dd><p>handle moved BOs in the PT</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make sure all BOs which are moved are updated in the PTs.</p>
<p><strong>Return</strong></p>
<p>0 for success.</p>
<p>PTs have to be reserved!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_add">
struct amdgpu_bo_va * <code class="descname">amdgpu_vm_bo_add</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, struct amdgpu_bo *<em>&nbsp;bo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a bo to a specific vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>bo</strong> into the requested vm.
Add <strong>bo</strong> to the list of bos associated with the vm</p>
<p><strong>Return</strong></p>
<p>Newly added bo_va or NULL for failure</p>
<p>Object has to be reserved!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_insert_map">
void <code class="descname">amdgpu_vm_bo_insert_map</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, struct amdgpu_bo_va_mapping *<em>&nbsp;mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_insert_map" title="Permalink to this definition">¶</a></dt>
<dd><p>insert a new mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va_mapping</span> <span class="pre">*</span> <span class="pre">mapping</span></code></dt>
<dd>the mapping to insert</dd>
</dl>
<p><strong>Description</strong></p>
<p>Insert a new mapping into all structures.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_map">
int <code class="descname">amdgpu_vm_bo_map</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;offset</em>, uint64_t<em>&nbsp;size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_map" title="Permalink to this definition">¶</a></dt>
<dd><p>map bo inside a vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to map the BO</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt>
<dd>requested offset in the BO</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>BO size in bytes</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>attributes of pages (read/write/valid/etc.)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a mapping of the BO at the specefied addr into the VM.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<p>Object has to be reserved and unreserved outside!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_replace_map">
int <code class="descname">amdgpu_vm_bo_replace_map</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;offset</em>, uint64_t<em>&nbsp;size</em>, uint64_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_replace_map" title="Permalink to this definition">¶</a></dt>
<dd><p>map bo inside a vm, replacing existing mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>bo_va to store the address</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to map the BO</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt>
<dd>requested offset in the BO</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>BO size in bytes</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">flags</span></code></dt>
<dd>attributes of pages (read/write/valid/etc.)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a mapping of the BO at the specefied addr into the VM. Replace existing
mappings as we do so.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<p>Object has to be reserved and unreserved outside!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_unmap">
int <code class="descname">amdgpu_vm_bo_unmap</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em>, uint64_t<em>&nbsp;saddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_unmap" title="Permalink to this definition">¶</a></dt>
<dd><p>remove bo mapping from vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>bo_va to remove the address from</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>where to the BO is mapped</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove a mapping of the BO at the specefied addr from the VM.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<p>Object has to be reserved and unreserved outside!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_clear_mappings">
int <code class="descname">amdgpu_vm_bo_clear_mappings</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, uint64_t<em>&nbsp;saddr</em>, uint64_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_clear_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all mappings in a specific range</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>VM structure to use</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">saddr</span></code></dt>
<dd>start of the range</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">size</span></code></dt>
<dd>size of the range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove all mappings in a range, split them as appropriate.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_lookup_mapping">
struct amdgpu_bo_va_mapping * <code class="descname">amdgpu_vm_bo_lookup_mapping</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, uint64_t<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_lookup_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>find mapping by address</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>the requested VM</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">addr</span></code></dt>
<dd>the address</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find a mapping by it&#8217;s address.</p>
<p><strong>Return</strong></p>
<p>The amdgpu_bo_va_mapping matching for addr or NULL</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_trace_cs">
void <code class="descname">amdgpu_vm_bo_trace_cs</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em>, struct ww_acquire_ctx *<em>&nbsp;ticket</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_trace_cs" title="Permalink to this definition">¶</a></dt>
<dd><p>trace all reserved mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>the requested vm</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ww_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ticket</span></code></dt>
<dd>CS ticket</dd>
</dl>
<p><strong>Description</strong></p>
<p>Trace all mappings of BOs reserved during a command submission.</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_rmv">
void <code class="descname">amdgpu_vm_bo_rmv</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo_va *<em>&nbsp;bo_va</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_rmv" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a bo to a specific vm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo_va</span> <span class="pre">*</span> <span class="pre">bo_va</span></code></dt>
<dd>requested bo_va</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove <strong>bo_va</strong>-&gt;bo from the requested vm.</p>
<p>Object have to be reserved!</p>
<dl class="function">
<dt id="c.amdgpu_vm_bo_invalidate">
void <code class="descname">amdgpu_vm_bo_invalidate</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_bo *<em>&nbsp;bo</em>, bool<em>&nbsp;evicted</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_bo_invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>mark the bo as invalid</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_bo</span> <span class="pre">*</span> <span class="pre">bo</span></code></dt>
<dd>amdgpu buffer object</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">evicted</span></code></dt>
<dd>is the BO evicted</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark <strong>bo</strong> as invalid.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_block_size">
uint32_t <code class="descname">amdgpu_vm_get_block_size</code><span class="sig-paren">(</span>uint64_t<em>&nbsp;vm_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_block_size" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate VM page table size as power of two</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">vm_size</span></code></dt>
<dd>VM size</dd>
</dl>
<p><strong>Return</strong></p>
<p>VM page table as power of two</p>
<dl class="function">
<dt id="c.amdgpu_vm_adjust_size">
void <code class="descname">amdgpu_vm_adjust_size</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, uint32_t<em>&nbsp;min_vm_size</em>, uint32_t<em>&nbsp;fragment_size_default</em>, unsigned<em>&nbsp;max_level</em>, unsigned<em>&nbsp;max_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_adjust_size" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust vm size, block size and fragment size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">min_vm_size</span></code></dt>
<dd>the minimum vm size in GB if it&#8217;s set auto</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">fragment_size_default</span></code></dt>
<dd>Default PTE fragment size</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">max_level</span></code></dt>
<dd>max VMPT level</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">max_bits</span></code></dt>
<dd>max address space size in bits</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_init">
int <code class="descname">amdgpu_vm_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em>, int<em>&nbsp;vm_context</em>, unsigned int<em>&nbsp;pasid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a vm instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vm_context</span></code></dt>
<dd>Indicates if it GFX or Compute context</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pasid</span></code></dt>
<dd>Process address space identifier</dd>
</dl>
<p><strong>Description</strong></p>
<p>Init <strong>vm</strong> fields.</p>
<p><strong>Return</strong></p>
<p>0 for success, error for failure.</p>
<dl class="function">
<dt id="c.amdgpu_vm_make_compute">
int <code class="descname">amdgpu_vm_make_compute</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_make_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a GFX VM into a compute VM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>This only works on GFX VMs that don&#8217;t have any BOs added and no
page tables allocated yet.</p>
<p>Changes the following VM parameters:
- use_cpu_for_update
- pte_supports_ats
- pasid (old PASID is released, because compute manages its own PASIDs)</p>
<p>Reinitializes the page directory to reflect the changed ATS
setting.</p>
<p><strong>Return</strong></p>
<p>0 for success, -errno for errors.</p>
<dl class="function">
<dt id="c.amdgpu_vm_free_levels">
void <code class="descname">amdgpu_vm_free_levels</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm_pt *<em>&nbsp;parent</em>, unsigned<em>&nbsp;level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_free_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>free PD/PT levels</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm_pt</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>PD/PT starting level to free</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">level</span></code></dt>
<dd>level of parent structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free the page directory or page table level and all sub levels.</p>
<dl class="function">
<dt id="c.amdgpu_vm_fini">
void <code class="descname">amdgpu_vm_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a vm instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>requested vm</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tear down <strong>vm</strong>.
Unbind the VM and remove all bos from the vm bo list</p>
<dl class="function">
<dt id="c.amdgpu_vm_pasid_fault_credit">
bool <code class="descname">amdgpu_vm_pasid_fault_credit</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned int<em>&nbsp;pasid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_pasid_fault_credit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check fault credit for given PASID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pasid</span></code></dt>
<dd>PASID do identify the VM</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is expected to be called in interrupt context.</p>
<p><strong>Return</strong></p>
<p>True if there was fault credit, false otherwise</p>
<dl class="function">
<dt id="c.amdgpu_vm_manager_init">
void <code class="descname">amdgpu_vm_manager_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_manager_init" title="Permalink to this definition">¶</a></dt>
<dd><p>init the VM manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the VM manager structures</p>
<dl class="function">
<dt id="c.amdgpu_vm_manager_fini">
void <code class="descname">amdgpu_vm_manager_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_manager_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup VM manager</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu_device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup the VM manager and free resources.</p>
<dl class="function">
<dt id="c.amdgpu_vm_ioctl">
int <code class="descname">amdgpu_vm_ioctl</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, void *<em>&nbsp;data</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_ioctl" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages VMID reservation for vm hubs.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device pointer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>drm_amdgpu_vm</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>drm file pointer</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 for success, -errno for errors.</p>
<dl class="function">
<dt id="c.amdgpu_vm_get_task_info">
void <code class="descname">amdgpu_vm_get_task_info</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned int<em>&nbsp;pasid</em>, struct amdgpu_task_info *<em>&nbsp;task_info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_get_task_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts task info for a PASID.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd><em>undescribed</em></dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pasid</span></code></dt>
<dd>PASID identifier for VM</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_task_info</span> <span class="pre">*</span> <span class="pre">task_info</span></code></dt>
<dd>task_info to fill.</dd>
</dl>
<dl class="function">
<dt id="c.amdgpu_vm_set_task_info">
void <code class="descname">amdgpu_vm_set_task_info</code><span class="sig-paren">(</span>struct amdgpu_vm *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_vm_set_task_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets VMs task info.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_vm</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>vm for which to set the info</dd>
</dl>
</div>
<div class="section" id="interrupt-handling">
<h3>Interrupt Handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h3>
<p>Interrupts generated within GPU hardware raise interrupt requests that are
passed to amdgpu IRQ handler which is responsible for detecting source and
type of the interrupt and dispatching matching handlers. If handling an
interrupt requires calling kernel functions that may sleep processing is
dispatched to work handlers.</p>
<p>If MSI functionality is not disabled by module parameter then MSI
support will be enabled.</p>
<p>For GPU interrupt sources that may be driven by another driver, IRQ domain
support is used (with mapping between virtual and hardware IRQs).</p>
<dl class="function">
<dt id="c.amdgpu_hotplug_work_func">
void <code class="descname">amdgpu_hotplug_work_func</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_hotplug_work_func" title="Permalink to this definition">¶</a></dt>
<dd><p>work handler for display hotplug event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work struct pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the hotplug event work handler (all ASICs).
The work gets scheduled from the IRQ handler if there
was a hotplug interrupt.  It walks through the connector table
and calls hotplug handler for each connector. After this, it sends
a DRM hotplug event to alert userspace.</p>
<p>This design approach is required in order to defer hotplug event handling
from the IRQ handler to a work handler because hotplug handler has to use
mutexes which cannot be locked in an IRQ handler (since <a class="reference internal" href="../translations/it_IT/kernel-hacking/locking.html#c.mutex_lock" title="mutex_lock"><code class="xref c c-type docutils literal"><span class="pre">mutex_lock</span></code></a> may
sleep).</p>
<dl class="function">
<dt id="c.amdgpu_irq_reset_work_func">
void <code class="descname">amdgpu_irq_reset_work_func</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_reset_work_func" title="Permalink to this definition">¶</a></dt>
<dd><p>execute GPU reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work struct pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Execute scheduled GPU reset (Cayman+).
This function is called when the IRQ handler thinks we need a GPU reset.</p>
<dl class="function">
<dt id="c.amdgpu_irq_disable_all">
void <code class="descname">amdgpu_irq_disable_all</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>disable <em>all</em> interrupts</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disable all types of interrupts from all sources.</p>
<dl class="function">
<dt id="c.amdgpu_irq_handler">
irqreturn_t <code class="descname">amdgpu_irq_handler</code><span class="sig-paren">(</span>int<em>&nbsp;irq</em>, void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>IRQ handler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>IRQ number (unused)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>pointer to DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>IRQ handler for amdgpu driver (all ASICs).</p>
<p><strong>Return</strong></p>
<p>result of handling the IRQ, as defined by <code class="xref c c-type docutils literal"><span class="pre">irqreturn_t</span></code></p>
<dl class="function">
<dt id="c.amdgpu_msi_ok">
bool <code class="descname">amdgpu_msi_ok</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_msi_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether MSI functionality is enabled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer (unused)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether MSI functionality has been disabled via module parameter
(all ASICs).</p>
<p><strong>Return</strong></p>
<p><em>true</em> if MSIs are allowed to be enabled or <em>false</em> otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_init">
int <code class="descname">amdgpu_irq_init</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize interrupt handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets up work functions for hotplug and reset interrupts, enables MSI
functionality, initializes vblank, hotplug and reset interrupt handling.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code on failure</p>
<dl class="function">
<dt id="c.amdgpu_irq_fini">
void <code class="descname">amdgpu_irq_fini</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>shut down interrupt handling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down work functions for hotplug and reset interrupts, disables MSI
functionality, shuts down vblank, hotplug and reset interrupt handling,
turns off interrupts from all sources (all ASICs).</p>
<dl class="function">
<dt id="c.amdgpu_irq_add_id">
int <code class="descname">amdgpu_irq_add_id</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;client_id</em>, unsigned<em>&nbsp;src_id</em>, struct amdgpu_irq_src *<em>&nbsp;source</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_add_id" title="Permalink to this definition">¶</a></dt>
<dd><p>register IRQ source</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">client_id</span></code></dt>
<dd>client id</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">src_id</span></code></dt>
<dd>source id</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">source</span></code></dt>
<dd>IRQ source pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers IRQ source on a client.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_dispatch">
void <code class="descname">amdgpu_irq_dispatch</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_iv_entry *<em>&nbsp;entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_dispatch" title="Permalink to this definition">¶</a></dt>
<dd><p>dispatch IRQ to IP blocks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_iv_entry</span> <span class="pre">*</span> <span class="pre">entry</span></code></dt>
<dd>interrupt vector pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispatches IRQ to IP blocks.</p>
<dl class="function">
<dt id="c.amdgpu_irq_update">
int <code class="descname">amdgpu_irq_update</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update hardware interrupt state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates interrupt state for the specific source (all ASICs).</p>
<dl class="function">
<dt id="c.amdgpu_irq_gpu_reset_resume_helper">
void <code class="descname">amdgpu_irq_gpu_reset_resume_helper</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_gpu_reset_resume_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>update interrupt states on all sources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates state of all types of interrupts on all sources on resume after
reset.</p>
<dl class="function">
<dt id="c.amdgpu_irq_get">
int <code class="descname">amdgpu_irq_get</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_get" title="Permalink to this definition">¶</a></dt>
<dd><p>enable interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables specified type of interrupt on the specified source (all ASICs).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_put">
int <code class="descname">amdgpu_irq_put</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_put" title="Permalink to this definition">¶</a></dt>
<dd><p>disable interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Enables specified type of interrupt on the specified source (all ASICs).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_enabled">
bool <code class="descname">amdgpu_irq_enabled</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, struct amdgpu_irq_src *<em>&nbsp;src</em>, unsigned<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether interrupt is enabled or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_irq_src</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>interrupt source pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">type</span></code></dt>
<dd>type of interrupt</dd>
</dl>
<p><strong>Description</strong></p>
<p>Checks whether the given type of interrupt is enabled on the given source.</p>
<p><strong>Return</strong></p>
<p><em>true</em> if interrupt is enabled, <em>false</em> if interrupt is disabled or on
invalid parameters</p>
<dl class="function">
<dt id="c.amdgpu_irqdomain_map">
int <code class="descname">amdgpu_irqdomain_map</code><span class="sig-paren">(</span>struct irq_domain *<em>&nbsp;d</em>, unsigned int<em>&nbsp;irq</em>, irq_hw_number_t<em>&nbsp;hwirq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irqdomain_map" title="Permalink to this definition">¶</a></dt>
<dd><p>create mapping between virtual and hardware IRQ numbers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>amdgpu IRQ domain pointer (unused)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>virtual IRQ number</dd>
<dt><code class="docutils literal"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt>
<dd>hardware irq number</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current implementation assigns simple interrupt handler to the given virtual
IRQ.</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_add_domain">
int <code class="descname">amdgpu_irq_add_domain</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_add_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>create a linear IRQ domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates an IRQ domain for GPU interrupt sources
that may be driven by another driver (e.g., ACP).</p>
<p><strong>Return</strong></p>
<p>0 on success or error code otherwise</p>
<dl class="function">
<dt id="c.amdgpu_irq_remove_domain">
void <code class="descname">amdgpu_irq_remove_domain</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_remove_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the IRQ domain</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes the IRQ domain for GPU interrupt sources
that may be driven by another driver (e.g., ACP).</p>
<dl class="function">
<dt id="c.amdgpu_irq_create_mapping">
unsigned <code class="descname">amdgpu_irq_create_mapping</code><span class="sig-paren">(</span>struct amdgpu_device *<em>&nbsp;adev</em>, unsigned<em>&nbsp;src_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.amdgpu_irq_create_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>create mapping between domain Linux IRQs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">amdgpu_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>amdgpu device pointer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">src_id</span></code></dt>
<dd>IH source id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates mapping between a domain IRQ (GPU IH src id) and a Linux IRQ
Use this for components that generate a GPU interrupt, but are driven
by a different driver (e.g., ACP).</p>
<p><strong>Return</strong></p>
<p>Linux IRQ</p>
</div>
</div>
<div class="section" id="gpu-power-thermal-controls-and-monitoring">
<h2>GPU Power/Thermal Controls and Monitoring<a class="headerlink" href="#gpu-power-thermal-controls-and-monitoring" title="Permalink to this headline">¶</a></h2>
<p>This section covers hwmon and power/thermal controls.</p>
<div class="section" id="hwmon-interfaces">
<h3>HWMON Interfaces<a class="headerlink" href="#hwmon-interfaces" title="Permalink to this headline">¶</a></h3>
<p>The amdgpu driver exposes the following sensor interfaces:</p>
<ul class="simple">
<li>GPU temperature (via the on-die sensor)</li>
<li>GPU voltage</li>
<li>Northbridge voltage (APUs only)</li>
<li>GPU power</li>
<li>GPU fan</li>
</ul>
<p>hwmon interfaces for GPU temperature:</p>
<ul class="simple">
<li>temp1_input: the on die GPU temperature in millidegrees Celsius</li>
<li>temp1_crit: temperature critical max value in millidegrees Celsius</li>
<li>temp1_crit_hyst: temperature hysteresis for critical limit in millidegrees Celsius</li>
</ul>
<p>hwmon interfaces for GPU voltage:</p>
<ul class="simple">
<li>in0_input: the voltage on the GPU in millivolts</li>
<li>in1_input: the voltage on the Northbridge in millivolts</li>
</ul>
<p>hwmon interfaces for GPU power:</p>
<ul class="simple">
<li>power1_average: average power used by the GPU in microWatts</li>
<li>power1_cap_min: minimum cap supported in microWatts</li>
<li>power1_cap_max: maximum cap supported in microWatts</li>
<li>power1_cap: selected power cap in microWatts</li>
</ul>
<p>hwmon interfaces for GPU fan:</p>
<ul class="simple">
<li>pwm1: pulse width modulation fan level (0-255)</li>
<li>pwm1_enable: pulse width modulation fan control method (0: no fan speed control, 1: manual fan speed control using pwm interface, 2: automatic fan speed control)</li>
<li>pwm1_min: pulse width modulation fan control minimum level (0)</li>
<li>pwm1_max: pulse width modulation fan control maximum level (255)</li>
<li>fan1_input: fan speed in RPM</li>
</ul>
<p>You can use hwmon tools like sensors to view this information on your system.</p>
</div>
<div class="section" id="gpu-sysfs-power-state-interfaces">
<h3>GPU sysfs Power State Interfaces<a class="headerlink" href="#gpu-sysfs-power-state-interfaces" title="Permalink to this headline">¶</a></h3>
<p>GPU power controls are exposed via sysfs files.</p>
<div class="section" id="power-dpm-state">
<h4>power_dpm_state<a class="headerlink" href="#power-dpm-state" title="Permalink to this headline">¶</a></h4>
<p>The power_dpm_state file is a legacy interface and is only provided for
backwards compatibility. The amdgpu driver provides a sysfs API for adjusting
certain power related parameters.  The file power_dpm_state is used for this.
It accepts the following arguments:</p>
<ul class="simple">
<li>battery</li>
<li>balanced</li>
<li>performance</li>
</ul>
<p>battery</p>
<p>On older GPUs, the vbios provided a special power state for battery
operation.  Selecting battery switched to this state.  This is no
longer provided on newer GPUs so the option does nothing in that case.</p>
<p>balanced</p>
<p>On older GPUs, the vbios provided a special power state for balanced
operation.  Selecting balanced switched to this state.  This is no
longer provided on newer GPUs so the option does nothing in that case.</p>
<p>performance</p>
<p>On older GPUs, the vbios provided a special power state for performance
operation.  Selecting performance switched to this state.  This is no
longer provided on newer GPUs so the option does nothing in that case.</p>
</div>
<div class="section" id="power-dpm-force-performance-level">
<h4>power_dpm_force_performance_level<a class="headerlink" href="#power-dpm-force-performance-level" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for adjusting certain power
related parameters.  The file power_dpm_force_performance_level is
used for this.  It accepts the following arguments:</p>
<ul class="simple">
<li>auto</li>
<li>low</li>
<li>high</li>
<li>manual</li>
<li>profile_standard</li>
<li>profile_min_sclk</li>
<li>profile_min_mclk</li>
<li>profile_peak</li>
</ul>
<p>auto</p>
<p>When auto is selected, the driver will attempt to dynamically select
the optimal power profile for current conditions in the driver.</p>
<p>low</p>
<p>When low is selected, the clocks are forced to the lowest power state.</p>
<p>high</p>
<p>When high is selected, the clocks are forced to the highest power state.</p>
<p>manual</p>
<p>When manual is selected, the user can manually adjust which power states
are enabled for each clock domain via the sysfs pp_dpm_mclk, pp_dpm_sclk,
and pp_dpm_pcie files and adjust the power state transition heuristics
via the pp_power_profile_mode sysfs file.</p>
<p>profile_standard
profile_min_sclk
profile_min_mclk
profile_peak</p>
<p>When the profiling modes are selected, clock and power gating are
disabled and the clocks are set for different profiling cases. This
mode is recommended for profiling specific work loads where you do
not want clock or power gating for clock fluctuation to interfere
with your results. profile_standard sets the clocks to a fixed clock
level which varies from asic to asic.  profile_min_sclk forces the sclk
to the lowest level.  profile_min_mclk forces the mclk to the lowest level.
profile_peak sets all clocks (mclk, sclk, pcie) to the highest levels.</p>
</div>
<div class="section" id="pp-table">
<h4>pp_table<a class="headerlink" href="#pp-table" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for uploading new powerplay
tables.  The file pp_table is used for this.  Reading the file
will dump the current power play table.  Writing to the file
will attempt to upload a new powerplay table and re-initialize
powerplay using that new table.</p>
</div>
<div class="section" id="pp-od-clk-voltage">
<h4>pp_od_clk_voltage<a class="headerlink" href="#pp-od-clk-voltage" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for adjusting the clocks and voltages
in each power level within a power state.  The pp_od_clk_voltage is used for
this.</p>
<p>Reading the file will display:</p>
<ul class="simple">
<li>a list of engine clock levels and voltages labeled OD_SCLK</li>
<li>a list of memory clock levels and voltages labeled OD_MCLK</li>
<li>a list of valid ranges for sclk, mclk, and voltage labeled OD_RANGE</li>
</ul>
<p>To manually adjust these settings, first select manual using
power_dpm_force_performance_level. Enter a new value for each
level by writing a string that contains &#8220;s/m level clock voltage&#8221; to
the file.  E.g., &#8220;s 1 500 820&#8221; will update sclk level 1 to be 500 MHz
at 820 mV; &#8220;m 0 350 810&#8221; will update mclk level 0 to be 350 MHz at
810 mV.  When you have edited all of the states as needed, write
&#8220;c&#8221; (commit) to the file to commit your changes.  If you want to reset to the
default power levels, write &#8220;r&#8221; (reset) to the file to reset them.</p>
</div>
<div class="section" id="pp-dpm-sclk-pp-dpm-mclk-pp-dpm-pcie">
<h4>pp_dpm_sclk pp_dpm_mclk pp_dpm_pcie<a class="headerlink" href="#pp-dpm-sclk-pp-dpm-mclk-pp-dpm-pcie" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for adjusting what power levels
are enabled for a given power state.  The files pp_dpm_sclk, pp_dpm_mclk,
and pp_dpm_pcie are used for this.</p>
<p>Reading back the files will show you the available power levels within
the power state and the clock information for those levels.</p>
<p>To manually adjust these states, first select manual using
power_dpm_force_performance_level.
Secondly,Enter a new value for each level by inputing a string that
contains &#8221; echo xx xx xx &gt; pp_dpm_sclk/mclk/pcie&#8221;
E.g., echo 4 5 6 to &gt; pp_dpm_sclk will enable sclk levels 4, 5, and 6.</p>
</div>
<div class="section" id="pp-power-profile-mode">
<h4>pp_power_profile_mode<a class="headerlink" href="#pp-power-profile-mode" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for adjusting the heuristics
related to switching between power levels in a power state.  The file
pp_power_profile_mode is used for this.</p>
<p>Reading this file outputs a list of all of the predefined power profiles
and the relevant heuristics settings for that profile.</p>
<p>To select a profile or create a custom profile, first select manual using
power_dpm_force_performance_level.  Writing the number of a predefined
profile to pp_power_profile_mode will enable those heuristics.  To
create a custom set of heuristics, write a string of numbers to the file
starting with the number of the custom profile along with a setting
for each heuristic parameter.  Due to differences across asic families
the heuristic parameters vary from family to family.</p>
</div>
<div class="section" id="busy-percent">
<h4>busy_percent<a class="headerlink" href="#busy-percent" title="Permalink to this headline">¶</a></h4>
<p>The amdgpu driver provides a sysfs API for reading how busy the GPU
is as a percentage.  The file gpu_busy_percent is used for this.
The SMU firmware computes a percentage of load based on the
aggregate activity level in the IP cores.</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="i915.html" class="btn btn-neutral float-right" title="drm/i915 Intel GFX Driver" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drivers.html" class="btn btn-neutral" title="GPU Driver Documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>