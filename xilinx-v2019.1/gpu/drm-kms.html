

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernel Mode Setting (KMS) &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="Linux GPU Driver Developer’s Guide" href="index.html"/>
        <link rel="next" title="Mode Setting Helper Functions" href="drm-kms-helpers.html"/>
        <link rel="prev" title="DRM Memory Management" href="drm-mm.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux GPU Driver Developer&#8217;s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-internals.html">DRM Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-mm.html">DRM Memory Management</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Kernel Mode Setting (KMS)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kms-core-structures-and-functions">KMS Core Structures and Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modeset-base-object-abstraction">Modeset Base Object Abstraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomic-mode-setting">Atomic Mode Setting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#handling-driver-private-state">Handling Driver Private State</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-mode-setting-function-reference">Atomic Mode Setting Function Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#crtc-abstraction">CRTC Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#crtc-functions-reference">CRTC Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#frame-buffer-abstraction">Frame Buffer Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#frame-buffer-functions-reference">Frame Buffer Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#drm-format-handling">DRM Format Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dumb-buffer-objects">Dumb Buffer Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plane-abstraction">Plane Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#plane-functions-reference">Plane Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#display-modes-function-reference">Display Modes Function Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connector-abstraction">Connector Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#connector-functions-reference">Connector Functions Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writeback-connectors">Writeback Connectors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#encoder-abstraction">Encoder Abstraction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#encoder-functions-reference">Encoder Functions Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kms-initialization-and-cleanup">KMS Initialization and Cleanup</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#crtcs-struct-drm-crtc">CRTCs (<code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cleanup">Cleanup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-discovery-and-initialization-example">Output discovery and initialization example</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kms-locking">KMS Locking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kms-properties">KMS Properties</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#property-types-and-blob-property-support">Property Types and Blob Property Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standard-connector-properties">Standard Connector Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hdmi-specific-connector-properties">HDMI Specific Connector Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#plane-composition-properties">Plane Composition Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#color-management-properties">Color Management Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tile-group-property">Tile Group Property</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-fencing-properties">Explicit Fencing Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#existing-kms-properties">Existing KMS Properties</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vertical-blanking">Vertical Blanking</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vertical-blanking-and-interrupt-handling-functions-reference">Vertical Blanking and Interrupt Handling Functions Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="drm-kms-helpers.html">Mode Setting Helper Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-uapi.html">Userland interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="drm-client.html">Kernel clients</a></li>
<li class="toctree-l2"><a class="reference internal" href="drivers.html">GPU Driver Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="vga-switcheroo.html">VGA Switcheroo</a></li>
<li class="toctree-l2"><a class="reference internal" href="vgaarbiter.html">VGA Arbiter</a></li>
<li class="toctree-l2"><a class="reference internal" href="todo.html">TODO list</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux GPU Driver Developer&#8217;s Guide</a> &raquo;</li>
      
    <li>Kernel Mode Setting (KMS)</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/gpu/drm-kms.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kernel-mode-setting-kms">
<h1>Kernel Mode Setting (KMS)<a class="headerlink" href="#kernel-mode-setting-kms" title="Permalink to this headline">¶</a></h1>
<p>Drivers must initialize the mode setting core by calling
<a class="reference internal" href="#c.drm_mode_config_init" title="drm_mode_config_init"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_init()</span></code></a> on the DRM device. The function
initializes the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code>
mode_config field and never fails. Once done, mode configuration must
be setup by initializing the following fields.</p>
<ul class="simple">
<li>int min_width, min_height; int max_width, max_height;
Minimum and maximum width and height of the frame buffers in pixel
units.</li>
<li>struct drm_mode_config_funcs *funcs;
Mode setting functions.</li>
</ul>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id1">
<img alt="KMS Display Pipeline" src="../_images/DOT-dade12aa9127c64406e41cdf8d7f80694c134db2.svg" /><p class="caption"><span class="caption-text">KMS Display Pipeline Overview</span></p>
</div>
<p>The basic object structure KMS presents to userspace is fairly simple.
Framebuffers (represented by <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>,
see <a class="reference internal" href="#frame-buffer-abstraction">Frame Buffer Abstraction</a>) feed into planes. Planes are represented by
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a>, see <a class="reference internal" href="#plane-abstraction">Plane Abstraction</a> for more
details. One or more (or even no) planes feed their pixel data into a CRTC
(represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>, see <a class="reference internal" href="#crtc-abstraction">CRTC Abstraction</a>)
for blending. The precise blending step is explained in more detail in <a class="reference internal" href="#plane-composition-properties">Plane
Composition Properties</a> and related chapters.</p>
<p>For the output routing the first step is encoders (represented by
<a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span></code></a>, see <a class="reference internal" href="#encoder-abstraction">Encoder Abstraction</a>). Those
are really just internal artifacts of the helper libraries used to implement KMS
drivers. Besides that they make it unecessarily more complicated for userspace
to figure out which connections between a CRTC and a connector are possible, and
what kind of cloning is supported, they serve no purpose in the userspace API.
Unfortunately encoders have been exposed to userspace, hence can&#8217;t remove them
at this point.  Futhermore the exposed restrictions are often wrongly set by
drivers, and in many cases not powerful enough to express the real restrictions.
A CRTC can be connected to multiple encoders, and for an active CRTC there must
be at least one encoder.</p>
<p>The final, and real, endpoint in the display chain is the connector (represented
by <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>, see <a class="reference internal" href="#connector-abstraction">Connector
Abstraction</a>). Connectors can have different possible encoders, but the kernel
driver selects which encoder to use for each connector. The use case is DVI,
which could switch between an analog and a digital encoder. Encoders can also
drive multiple different connectors. There is exactly one active connector for
every active encoder.</p>
<p>Internally the output pipeline is a bit more complex and matches today&#8217;s
hardware more closely:</p>
<div class="figure" id="id2">
<img alt="KMS Output Pipeline" src="../_images/DOT-6445c75fc4859992454fd377127d4d309e82f09a.svg" /><p class="caption"><span class="caption-text">KMS Output Pipeline</span></p>
</div>
<p>Internally two additional helper objects come into play. First, to be able to
share code for encoders (sometimes on the same SoC, sometimes off-chip) one or
more <a class="reference internal" href="drm-kms-helpers.html#drm-bridges"><span>Framebuffer GEM Helper Reference</span></a> (represented by <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_bridge</span></code></a>) can be linked to an encoder. This link is static and cannot be
changed, which means the cross-bar (if there is any) needs to be mapped between
the CRTC and any encoders. Often for drivers with bridges there&#8217;s no code left
at the encoder level. Atomic drivers can leave out all the encoder callbacks to
essentially only leave a dummy routing object behind, which is needed for
backwards compatibility since encoders are exposed to userspace.</p>
<p>The second object is for panels, represented by <a class="reference internal" href="drm-kms-helpers.html#c.drm_panel" title="drm_panel"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_panel</span></code></a>, see <a class="reference internal" href="drm-kms-helpers.html#drm-panel-helper"><span>Panel Helper Reference</span></a>. Panels do not have a fixed binding
point, but are generally linked to the driver private structure that embeds
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>.</p>
<p>Note that currently the bridge chaining and interactions with connectors and
panels are still in-flux and not really fully sorted out yet.</p>
</div>
<div class="section" id="kms-core-structures-and-functions">
<h2>KMS Core Structures and Functions<a class="headerlink" href="#kms-core-structures-and-functions" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_mode_config_funcs">
struct <code class="descname">drm_mode_config_funcs</code><a class="headerlink" href="#c.drm_mode_config_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>basic driver provided mode setting functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_config_funcs {
  struct drm_framebuffer *(*fb_create)(struct drm_device *dev,struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd);
  const struct drm_format_info *(*get_format_info)(const struct drm_mode_fb_cmd2 *mode_cmd);
  void (*output_poll_changed)(struct drm_device *dev);
  enum drm_mode_status (*mode_valid)(struct drm_device *dev, const struct drm_display_mode *mode);
  int (*atomic_check)(struct drm_device *dev, struct drm_atomic_state *state);
  int (*atomic_commit)(struct drm_device *dev,struct drm_atomic_state *state, bool nonblock);
  struct drm_atomic_state *(*atomic_state_alloc)(struct drm_device *dev);
  void (*atomic_state_clear)(struct drm_atomic_state *state);
  void (*atomic_state_free)(struct drm_atomic_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb_create</span></code></dt>
<dd><p class="first">Create a new framebuffer object. The core does basic checks on the
requested metadata, but most of that is left to the driver. See
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span></code> for details.</p>
<p>If the parameters are deemed valid and the backing storage objects in
the underlying memory manager all exist, then the driver allocates
a new <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> structure, subclassed to contain
driver-specific information (like the internal native buffer object
references). It also needs to fill out all relevant metadata, which
should be done by calling <a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_mode_fill_fb_struct" title="drm_helper_mode_fill_fb_struct"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_mode_fill_fb_struct()</span></code></a>.</p>
<p>The initialization is finalized by calling <a class="reference internal" href="#c.drm_framebuffer_init" title="drm_framebuffer_init"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_init()</span></code></a>,
which registers the framebuffer and makes it accessible to other
threads.</p>
<p>RETURNS:</p>
<p class="last">A new framebuffer with an initial reference count of 1 or a negative
error code encoded with <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_format_info</span></code></dt>
<dd><p class="first">Allows a driver to return custom format information for special
fb layouts (eg. ones with auxiliary compression control planes).</p>
<p>RETURNS:</p>
<p class="last">The format information specific to the given fb metadata, or
NULL if none is found.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">output_poll_changed</span></code></dt>
<dd><p class="first">Callback used by helpers to inform the driver of output configuration
changes.</p>
<p>Drivers implementing fbdev emulation with the helpers can call
drm_fb_helper_hotplug_changed from this hook to inform the fbdev
helper of output changes.</p>
<p>FIXME:</p>
<p class="last">Except that there&#8217;s no vtable for device-level helper callbacks
there&#8217;s no reason this is a core function.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_valid</span></code></dt>
<dd>Device specific validation of display modes. Can be used to reject
modes that can never be supported. Only device wide constraints can
be checked here. crtc/encoder/bridge/connector specific constraints
should be checked in the .:c:func:<cite>mode_valid()</cite> hook for each specific object.</dd>
<dt><code class="docutils literal"><span class="pre">atomic_check</span></code></dt>
<dd><p class="first">This is the only hook to validate an atomic modeset update. This
function must reject any modeset and state changes which the hardware
or driver doesn&#8217;t support. This includes but is of course not limited
to:</p>
<blockquote>
<div><ul class="simple">
<li>Checking that the modes, framebuffers, scaling and placement
requirements and so on are within the limits of the hardware.</li>
<li>Checking that any hidden shared resources are not oversubscribed.
This can be shared PLLs, shared lanes, overall memory bandwidth,
display fifo space (where shared between planes or maybe even
CRTCs).</li>
<li>Checking that virtualized resources exported to userspace are not
oversubscribed. For various reasons it can make sense to expose
more planes, crtcs or encoders than which are physically there. One
example is dual-pipe operations (which generally should be hidden
from userspace if when lockstepped in hardware, exposed otherwise),
where a plane might need 1 hardware plane (if it&#8217;s just on one
pipe), 2 hardware planes (when it spans both pipes) or maybe even
shared a hardware plane with a 2nd plane (if there&#8217;s a compatible
plane requested on the area handled by the other pipe).</li>
<li>Check that any transitional state is possible and that if
requested, the update can indeed be done in the vblank period
without temporarily disabling some functions.</li>
<li>Check any other constraints the driver or hardware might have.</li>
<li>This callback also needs to correctly fill out the <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a>
in this update to make sure that <a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>
reflects the nature of the possible update and returns true if and
only if the update cannot be applied without tearing within one
vblank on that CRTC. The core uses that information to reject
updates which require a full modeset (i.e. blanking the screen, or
at least pausing updates for a substantial amount of time) if
userspace has disallowed that in its request.</li>
<li>The driver also does not need to repeat basic input validation
like done for the corresponding legacy entry points. The core does
that before calling this hook.</li>
</ul>
</div></blockquote>
<p>See the documentation of <strong>atomic_commit</strong> for an exhaustive list of
error conditions which don&#8217;t have to be checked at the in this
callback.</p>
<p>See the documentation for <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> for how exactly
an atomic modeset update is described.</p>
<p>Drivers using the atomic helpers can implement this hook using
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check()</span></code></a>, or one of the exported sub-functions of
it.</p>
<p>RETURNS:</p>
<p>0 on success or one of the below negative error codes:</p>
<blockquote class="last">
<div><ul class="simple">
<li>-EINVAL, if any of the above constraints are violated.</li>
<li>-EDEADLK, when returned from an attempt to acquire an additional
<a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> through <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a>.</li>
<li>-ENOMEM, if allocating additional state sub-structures failed due
to lack of memory.</li>
<li>-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point all errors are
treated equally.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_commit</span></code></dt>
<dd><p class="first">This is the only hook to commit an atomic modeset update. The core
guarantees that <strong>atomic_check</strong> has been called successfully before
calling this function, and that nothing has been changed in the
interim.</p>
<p>See the documentation for <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> for how exactly
an atomic modeset update is described.</p>
<p>Drivers using the atomic helpers can implement this hook using
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_commit" title="drm_atomic_helper_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit()</span></code></a>, or one of the exported sub-functions of
it.</p>
<p>Nonblocking commits (as indicated with the nonblock parameter) must
do any preparatory work which might result in an unsuccessful commit
in the context of this callback. The only exceptions are hardware
errors resulting in -EIO. But even in that case the driver must
ensure that the display pipe is at least running, to avoid
compositors crashing when pageflips don&#8217;t work. Anything else,
specifically committing the update to the hardware, should be done
without blocking the caller. For updates which do not require a
modeset this must be guaranteed.</p>
<p>The driver must wait for any pending rendering to the new
framebuffers to complete before executing the flip. It should also
wait for any pending rendering from other drivers if the underlying
buffer is a shared dma-buf. Nonblocking commits must not wait for
rendering in the context of this callback.</p>
<p>An application can request to be notified when the atomic commit has
completed. These events are per-CRTC and can be distinguished by the
CRTC index supplied in <code class="xref c c-type docutils literal"><span class="pre">drm_event</span></code> to userspace.</p>
<p>The drm core will supply a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_event</span></code> in each CRTC&#8217;s
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a>. See the documentation for
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a> for more details about the precise semantics of
this event.</p>
<p>NOTE:</p>
<p>Drivers are not allowed to shut down any display pipe successfully
enabled through an atomic commit on their own. Doing so can result in
compositors crashing if a page flip is suddenly rejected because the
pipe is off.</p>
<p>RETURNS:</p>
<p>0 on success or one of the below negative error codes:</p>
<blockquote>
<div><ul class="simple">
<li>-EBUSY, if a nonblocking updated is requested and there is
an earlier updated pending. Drivers are allowed to support a queue
of outstanding updates, but currently no driver supports that.
Note that drivers must wait for preceding updates to complete if a
synchronous update is requested, they are not allowed to fail the
commit in that case.</li>
<li>-ENOMEM, if the driver failed to allocate memory. Specifically
this can happen when trying to pin framebuffers, which must only
be done when committing the state.</li>
<li>-ENOSPC, as a refinement of the more generic -ENOMEM to indicate
that the driver has run out of vram, iommu space or similar GPU
address space needed for framebuffer.</li>
<li>-EIO, if the hardware completely died.</li>
<li>-EINTR, -EAGAIN or -ERESTARTSYS, if the IOCTL should be restarted.
This can either be due to a pending signal, or because the driver
needs to completely bail out to recover from an exceptional
situation like a GPU hang. From a userspace point of view all errors are
treated equally.</li>
</ul>
</div></blockquote>
<p class="last">This list is exhaustive. Specifically this hook is not allowed to
return -EINVAL (any invalid requests should be caught in
<strong>atomic_check</strong>) or -EDEADLK (this function must not acquire
additional modeset locks).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_alloc</span></code></dt>
<dd><p class="first">This optional hook can be used by drivers that want to subclass struct
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> to be able to track their own driver-private global
state easily. If this hook is implemented, drivers must also
implement <strong>atomic_state_clear</strong> and <strong>atomic_state_free</strong>.</p>
<p>Subclassing of <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> is deprecated in favour of using
<a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state</span></code></a> and <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal"><span class="pre">drm_private_obj</span></code></a>.</p>
<p>RETURNS:</p>
<p class="last">A new <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> on success or NULL on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_clear</span></code></dt>
<dd><p class="first">This hook must clear any driver private state duplicated into the
passed-in <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>. This hook is called when the caller
encountered a <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> deadlock and needs to drop all
already acquired locks as part of the deadlock avoidance dance
implemented in <a class="reference internal" href="#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p>Any duplicated state must be invalidated since a concurrent atomic
update might change it, and the drm atomic interfaces always apply
updates as relative changes to the current state.</p>
<p>Drivers that implement this must call <a class="reference internal" href="#c.drm_atomic_state_default_clear" title="drm_atomic_state_default_clear"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_default_clear()</span></code></a>
to clear common state.</p>
<p class="last">Subclassing of <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> is deprecated in favour of using
<a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state</span></code></a> and <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal"><span class="pre">drm_private_obj</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_state_free</span></code></dt>
<dd><p class="first">This hook needs driver private resources and the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
itself. Note that the core first calls <a class="reference internal" href="#c.drm_atomic_state_clear" title="drm_atomic_state_clear"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_clear()</span></code></a> to
avoid code duplicate between the clear and free hooks.</p>
<p>Drivers that implement this must call
<a class="reference internal" href="#c.drm_atomic_state_default_release" title="drm_atomic_state_default_release"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_default_release()</span></code></a> to release common resources.</p>
<p class="last">Subclassing of <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> is deprecated in favour of using
<a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state</span></code></a> and <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal"><span class="pre">drm_private_obj</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
involve drivers.</p>
<dl class="type">
<dt id="c.drm_mode_config">
struct <code class="descname">drm_mode_config</code><a class="headerlink" href="#c.drm_mode_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Mode configuration control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_config {
  struct mutex mutex;
  struct drm_modeset_lock connection_mutex;
  struct drm_modeset_acquire_ctx *acquire_ctx;
  struct mutex idr_mutex;
  struct idr crtc_idr;
  struct idr tile_idr;
  struct mutex fb_lock;
  int num_fb;
  struct list_head fb_list;
  spinlock_t connector_list_lock;
  int num_connector;
  struct ida connector_ida;
  struct list_head connector_list;
  struct llist_head connector_free_list;
  struct work_struct connector_free_work;
  int num_encoder;
  struct list_head encoder_list;
  int num_total_plane;
  struct list_head plane_list;
  int num_crtc;
  struct list_head crtc_list;
  struct list_head property_list;
  int min_width, min_height;
  int max_width, max_height;
  const struct drm_mode_config_funcs *funcs;
  resource_size_t fb_base;
  bool poll_enabled;
  bool poll_running;
  bool delayed_event;
  struct delayed_work output_poll_work;
  struct mutex blob_lock;
  struct list_head property_blob_list;
  struct drm_property *edid_property;
  struct drm_property *dpms_property;
  struct drm_property *path_property;
  struct drm_property *tile_property;
  struct drm_property *link_status_property;
  struct drm_property *plane_type_property;
  struct drm_property *prop_src_x;
  struct drm_property *prop_src_y;
  struct drm_property *prop_src_w;
  struct drm_property *prop_src_h;
  struct drm_property *prop_crtc_x;
  struct drm_property *prop_crtc_y;
  struct drm_property *prop_crtc_w;
  struct drm_property *prop_crtc_h;
  struct drm_property *prop_fb_id;
  struct drm_property *prop_in_fence_fd;
  struct drm_property *prop_out_fence_ptr;
  struct drm_property *prop_crtc_id;
  struct drm_property *prop_active;
  struct drm_property *prop_mode_id;
  struct drm_property *dvi_i_subconnector_property;
  struct drm_property *dvi_i_select_subconnector_property;
  struct drm_property *tv_subconnector_property;
  struct drm_property *tv_select_subconnector_property;
  struct drm_property *tv_mode_property;
  struct drm_property *tv_left_margin_property;
  struct drm_property *tv_right_margin_property;
  struct drm_property *tv_top_margin_property;
  struct drm_property *tv_bottom_margin_property;
  struct drm_property *tv_brightness_property;
  struct drm_property *tv_contrast_property;
  struct drm_property *tv_flicker_reduction_property;
  struct drm_property *tv_overscan_property;
  struct drm_property *tv_saturation_property;
  struct drm_property *tv_hue_property;
  struct drm_property *scaling_mode_property;
  struct drm_property *aspect_ratio_property;
  struct drm_property *content_type_property;
  struct drm_property *degamma_lut_property;
  struct drm_property *degamma_lut_size_property;
  struct drm_property *ctm_property;
  struct drm_property *gamma_lut_property;
  struct drm_property *gamma_lut_size_property;
  struct drm_property *suggested_x_property;
  struct drm_property *suggested_y_property;
  struct drm_property *non_desktop_property;
  struct drm_property *panel_orientation_property;
  struct drm_property *writeback_fb_id_property;
  struct drm_property *writeback_pixel_formats_property;
  struct drm_property *writeback_out_fence_ptr_property;
  uint32_t preferred_depth, prefer_shadow;
  bool async_page_flip;
  bool allow_fb_modifiers;
  bool normalize_zpos;
  struct drm_property *modifiers_property;
  uint32_t cursor_width, cursor_height;
  struct drm_atomic_state *suspend_state;
  const struct drm_mode_config_helper_funcs *helper_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">This is the big scary modeset BKL which protects everything that
isn&#8217;t protect otherwise. Scope is unclear and fuzzy, try to remove
anything from under it&#8217;s protection and move it into more well-scoped
locks.</p>
<p class="last">The one important thing this protects is the use of <strong>acquire_ctx</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">connection_mutex</span></code></dt>
<dd><p class="first">This protects connector state and the connector to encoder to CRTC
routing chain.</p>
<p class="last">For atomic drivers specifically this protects <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">acquire_ctx</span></code></dt>
<dd>Global implicit acquire context used by atomic drivers for legacy
IOCTLs. Deprecated, since implicit locking contexts make it
impossible to use driver-private <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span></code></a>. Users of
this must hold <strong>mutex</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">idr_mutex</span></code></dt>
<dd>Mutex for KMS ID allocation and management. Protects both <strong>crtc_idr</strong>
and <strong>tile_idr</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_idr</span></code></dt>
<dd>Main KMS ID tracking object. Use this idr for all IDs, fb, crtc,
connector, modes - just makes life easier to have only one.</dd>
<dt><code class="docutils literal"><span class="pre">tile_idr</span></code></dt>
<dd>Use this idr for allocating new IDs for tiled sinks like use in some
high-res DP MST screens.</dd>
<dt><code class="docutils literal"><span class="pre">fb_lock</span></code></dt>
<dd>Mutex to protect fb the global <strong>fb_list</strong> and <strong>num_fb</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">num_fb</span></code></dt>
<dd>Number of entries on <strong>fb_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">fb_list</span></code></dt>
<dd>List of all <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">connector_list_lock</span></code></dt>
<dd>Protects <strong>num_connector</strong> and
<strong>connector_list</strong> and <strong>connector_free_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">num_connector</span></code></dt>
<dd>Number of connectors on this device. Protected by
<strong>connector_list_lock</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">connector_ida</span></code></dt>
<dd>ID allocator for connector indices.</dd>
<dt><code class="docutils literal"><span class="pre">connector_list</span></code></dt>
<dd>List of connector objects linked with <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.head</span></code></a>. Protected
by <strong>connector_list_lock</strong>. Only use <a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a> to walk this list.</dd>
<dt><code class="docutils literal"><span class="pre">connector_free_list</span></code></dt>
<dd>List of connector objects linked with <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.free_head</span></code></a>.
Protected by <strong>connector_list_lock</strong>. Used by
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a> to savely free connectors using
<strong>connector_free_work</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">connector_free_work</span></code></dt>
<dd>Work to clean up <strong>connector_free_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">num_encoder</span></code></dt>
<dd>Number of encoders on this device. This is invariant over the
lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">encoder_list</span></code></dt>
<dd>List of encoder objects linked with <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn&#8217;t need any
locks.</dd>
<dt><code class="docutils literal"><span class="pre">num_total_plane</span></code></dt>
<dd>Number of universal (i.e. with primary/curso) planes on this device.
This is invariant over the lifetime of a device and hence doesn&#8217;t
need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">plane_list</span></code></dt>
<dd>List of plane objects linked with <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.head</span></code></a>. This is invariant
over the lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">num_crtc</span></code></dt>
<dd>Number of CRTCs on this device linked with <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.head</span></code></a>. This is invariant over the lifetime
of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_list</span></code></dt>
<dd>List of CRTC objects linked with <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.head</span></code></a>. This is invariant
over the lifetime of a device and hence doesn&#8217;t need any locks.</dd>
<dt><code class="docutils literal"><span class="pre">property_list</span></code></dt>
<dd>List of property type objects linked with <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property.head</span></code></a>. This is
invariant over the lifetime of a device and hence doesn&#8217;t need any
locks.</dd>
<dt><code class="docutils literal"><span class="pre">min_width</span></code></dt>
<dd>minimum fb pixel width on this device</dd>
<dt><code class="docutils literal"><span class="pre">min_height</span></code></dt>
<dd>minimum fb pixel height on this device</dd>
<dt><code class="docutils literal"><span class="pre">max_width</span></code></dt>
<dd>maximum fb pixel width on this device</dd>
<dt><code class="docutils literal"><span class="pre">max_height</span></code></dt>
<dd>maximum fb pixel height on this device</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>core driver provided mode setting functions</dd>
<dt><code class="docutils literal"><span class="pre">fb_base</span></code></dt>
<dd>base address of the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">poll_enabled</span></code></dt>
<dd>track polling support for this device</dd>
<dt><code class="docutils literal"><span class="pre">poll_running</span></code></dt>
<dd>track polling status for this device</dd>
<dt><code class="docutils literal"><span class="pre">delayed_event</span></code></dt>
<dd>track delayed poll uevent deliver for this device</dd>
<dt><code class="docutils literal"><span class="pre">output_poll_work</span></code></dt>
<dd>delayed work for polling in process context</dd>
<dt><code class="docutils literal"><span class="pre">blob_lock</span></code></dt>
<dd>Mutex for blob property allocation and management, protects
<strong>property_blob_list</strong> and <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.blobs</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">property_blob_list</span></code></dt>
<dd>List of all the blob property objects linked with
<a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob.head</span></code></a>. Protected by <strong>blob_lock</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">edid_property</span></code></dt>
<dd>Default connector property to hold the EDID of the
currently connected sink, if any.</dd>
<dt><code class="docutils literal"><span class="pre">dpms_property</span></code></dt>
<dd>Default connector property to control the
connector&#8217;s DPMS state.</dd>
<dt><code class="docutils literal"><span class="pre">path_property</span></code></dt>
<dd>Default connector property to hold the DP MST path
for the port.</dd>
<dt><code class="docutils literal"><span class="pre">tile_property</span></code></dt>
<dd>Default connector property to store the tile
position of a tiled screen, for sinks which need to be driven with
multiple CRTCs.</dd>
<dt><code class="docutils literal"><span class="pre">link_status_property</span></code></dt>
<dd>Default connector property for link status
of a connector</dd>
<dt><code class="docutils literal"><span class="pre">plane_type_property</span></code></dt>
<dd>Default plane property to differentiate
CURSOR, PRIMARY and OVERLAY legacy uses of planes.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_x</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_y</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_w</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_src_h</span></code></dt>
<dd>Default atomic plane property for the plane source
position in the connected <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_x</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_y</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_w</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_h</span></code></dt>
<dd>Default atomic plane property for the plane destination
position in the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> is is being shown on.</dd>
<dt><code class="docutils literal"><span class="pre">prop_fb_id</span></code></dt>
<dd>Default atomic plane property to specify the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_in_fence_fd</span></code></dt>
<dd>Sync File fd representing the incoming fences
for a Plane.</dd>
<dt><code class="docutils literal"><span class="pre">prop_out_fence_ptr</span></code></dt>
<dd>Sync File fd pointer representing the
outgoing fences for a CRTC. Userspace should provide a pointer to a
value of type s32, and then cast that pointer to u64.</dd>
<dt><code class="docutils literal"><span class="pre">prop_crtc_id</span></code></dt>
<dd>Default atomic plane property to specify the
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">prop_active</span></code></dt>
<dd>Default atomic CRTC property to control the active
state, which is the simplified implementation for DPMS in atomic
drivers.</dd>
<dt><code class="docutils literal"><span class="pre">prop_mode_id</span></code></dt>
<dd>Default atomic CRTC property to set the mode for a
CRTC. A 0 mode implies that the CRTC is entirely disabled - all
connectors must be of and active must be set to disabled, too.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_i_subconnector_property</span></code></dt>
<dd>Optional DVI-I property to
differentiate between analog or digital mode.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_i_select_subconnector_property</span></code></dt>
<dd>Optional DVI-I property to
select between analog or digital mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_subconnector_property</span></code></dt>
<dd>Optional TV property to differentiate
between different TV connector types.</dd>
<dt><code class="docutils literal"><span class="pre">tv_select_subconnector_property</span></code></dt>
<dd>Optional TV property to select
between different TV connector types.</dd>
<dt><code class="docutils literal"><span class="pre">tv_mode_property</span></code></dt>
<dd>Optional TV property to select
the output TV mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_left_margin_property</span></code></dt>
<dd>Optional TV property to set the left
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_right_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_top_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_bottom_margin_property</span></code></dt>
<dd>Optional TV property to set the right
margin.</dd>
<dt><code class="docutils literal"><span class="pre">tv_brightness_property</span></code></dt>
<dd>Optional TV property to set the
brightness.</dd>
<dt><code class="docutils literal"><span class="pre">tv_contrast_property</span></code></dt>
<dd>Optional TV property to set the
contrast.</dd>
<dt><code class="docutils literal"><span class="pre">tv_flicker_reduction_property</span></code></dt>
<dd>Optional TV property to control the
flicker reduction mode.</dd>
<dt><code class="docutils literal"><span class="pre">tv_overscan_property</span></code></dt>
<dd>Optional TV property to control the overscan
setting.</dd>
<dt><code class="docutils literal"><span class="pre">tv_saturation_property</span></code></dt>
<dd>Optional TV property to set the
saturation.</dd>
<dt><code class="docutils literal"><span class="pre">tv_hue_property</span></code></dt>
<dd>Optional TV property to set the hue.</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode_property</span></code></dt>
<dd>Optional connector property to control the
upscaling, mostly used for built-in panels.</dd>
<dt><code class="docutils literal"><span class="pre">aspect_ratio_property</span></code></dt>
<dd>Optional connector property to control the
HDMI infoframe aspect ratio setting.</dd>
<dt><code class="docutils literal"><span class="pre">content_type_property</span></code></dt>
<dd>Optional connector property to control the
HDMI infoframe content type setting.</dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut_property</span></code></dt>
<dd>Optional CRTC property to set the LUT used to
convert the framebuffer&#8217;s colors to linear gamma.</dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut_size_property</span></code></dt>
<dd>Optional CRTC property for the size of
the degamma LUT as supported by the driver (read-only).</dd>
<dt><code class="docutils literal"><span class="pre">ctm_property</span></code></dt>
<dd>Optional CRTC property to set the
matrix used to convert colors after the lookup in the
degamma LUT.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut_property</span></code></dt>
<dd>Optional CRTC property to set the LUT used to
convert the colors, after the CTM matrix, to the gamma space of the
connected screen.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut_size_property</span></code></dt>
<dd>Optional CRTC property for the size of the
gamma LUT as supported by the driver (read-only).</dd>
<dt><code class="docutils literal"><span class="pre">suggested_x_property</span></code></dt>
<dd>Optional connector property with a hint for
the position of the output on the host&#8217;s screen.</dd>
<dt><code class="docutils literal"><span class="pre">suggested_y_property</span></code></dt>
<dd>Optional connector property with a hint for
the position of the output on the host&#8217;s screen.</dd>
<dt><code class="docutils literal"><span class="pre">non_desktop_property</span></code></dt>
<dd>Optional connector property with a hint
that device isn&#8217;t a standard display, and the console/desktop,
should not be displayed on it.</dd>
<dt><code class="docutils literal"><span class="pre">panel_orientation_property</span></code></dt>
<dd>Optional connector property indicating
how the lcd-panel is mounted inside the casing (e.g. normal or
upside-down).</dd>
<dt><code class="docutils literal"><span class="pre">writeback_fb_id_property</span></code></dt>
<dd>Property for writeback connectors, storing
the ID of the output framebuffer.
See also: <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_connector_init()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">writeback_pixel_formats_property</span></code></dt>
<dd>Property for writeback connectors,
storing an array of the supported pixel formats for the writeback
engine (read-only).
See also: <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_connector_init()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">writeback_out_fence_ptr_property</span></code></dt>
<dd>Property for writeback connectors,
fd pointer representing the outgoing fences for a writeback
connector. Userspace should provide a pointer to a value of type s32,
and then cast that pointer to u64.
See also: <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_connector_init()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">preferred_depth</span></code></dt>
<dd>preferred RBG pixel depth, used by fb helpers</dd>
<dt><code class="docutils literal"><span class="pre">prefer_shadow</span></code></dt>
<dd>hint to userspace to prefer shadow-fb rendering</dd>
<dt><code class="docutils literal"><span class="pre">async_page_flip</span></code></dt>
<dd>Does this device support async flips on the primary
plane?</dd>
<dt><code class="docutils literal"><span class="pre">allow_fb_modifiers</span></code></dt>
<dd>Whether the driver supports fb modifiers in the ADDFB2.1 ioctl call.</dd>
<dt><code class="docutils literal"><span class="pre">normalize_zpos</span></code></dt>
<dd>If true the drm core will call <a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_normalize_zpos()</span></code></a> as part of
atomic mode checking from <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check" title="drm_atomic_helper_check"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">modifiers_property</span></code></dt>
<dd>Plane property to list support modifier/format
combination.</dd>
<dt><code class="docutils literal"><span class="pre">cursor_width</span></code></dt>
<dd>hint to userspace for max cursor width</dd>
<dt><code class="docutils literal"><span class="pre">cursor_height</span></code></dt>
<dd>hint to userspace for max cursor height</dd>
<dt><code class="docutils literal"><span class="pre">suspend_state</span></code></dt>
<dd>Atomic state when suspended.
Set by <a class="reference internal" href="drm-kms-helpers.html#c.drm_mode_config_helper_suspend" title="drm_mode_config_helper_suspend"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_helper_suspend()</span></code></a> and cleared by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_mode_config_helper_resume" title="drm_mode_config_helper_resume"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_helper_resume()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Core mode resource tracking structure.  All CRTC, encoders, and connectors
enumerated by the driver are added here, as are global properties.  Some
global restrictions are also here, e.g. dimension restrictions.</p>
<dl class="function">
<dt id="c.drm_mode_config_reset">
void <code class="descname">drm_mode_config_reset</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>call -&gt;reset callbacks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions calls all the crtc&#8217;s, encoder&#8217;s and connector&#8217;s -&gt;reset
callback. Drivers can use this in e.g. their driver load or resume code to
reset hardware and software state.</p>
<dl class="function">
<dt id="c.drm_mode_config_init">
void <code class="descname">drm_mode_config_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize DRM mode_configuration structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize <strong>dev</strong>&#8216;s mode_config structure, used for tracking the graphics
configuration of <strong>dev</strong>.</p>
<p>Since this initializes the modeset locks, no locking is possible. Which is no
problem, since this should happen single threaded at init time. It is the
driver&#8217;s problem to ensure this guarantee.</p>
<dl class="function">
<dt id="c.drm_mode_config_cleanup">
void <code class="descname">drm_mode_config_cleanup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_config_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>free up DRM mode_config info</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free up all the connectors and CRTCs associated with this DRM device, then
free up the framebuffers and associated buffer objects.</p>
<p>Note that since this /should/ happen single-threaded at driver/device
teardown time, no locking is required. It&#8217;s the driver&#8217;s job to ensure that
this guarantee actually holds true.</p>
<p>FIXME: cleanup any dangling user buffer objects too</p>
</div>
<div class="section" id="modeset-base-object-abstraction">
<h2>Modeset Base Object Abstraction<a class="headerlink" href="#modeset-base-object-abstraction" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id3">
<img alt="Mode Objects and Properties" src="../_images/DOT-1eee3f74bb2de20b2b68c4aa6c9c1cabe5078857.svg" /><p class="caption"><span class="caption-text">Mode Objects and Properties</span></p>
</div>
<p>The base structure for all KMS objects is <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span></code></a>. One of the base services it provides is tracking properties,
which are especially important for the atomic IOCTL (see <a class="reference internal" href="#atomic-mode-setting">Atomic Mode
Setting</a>). The somewhat surprising part here is that properties are not
directly instantiated on each object, but free-standing mode objects themselves,
represented by <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span></code></a>, which only specify
the type and value range of a property. Any given property can be attached
multiple times to different objects using <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_mode_object">
struct <code class="descname">drm_mode_object</code><a class="headerlink" href="#c.drm_mode_object" title="Permalink to this definition">¶</a></dt>
<dd><p>base structure for modeset objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_object {
  uint32_t id;
  uint32_t type;
  struct drm_object_properties *properties;
  struct kref refcount;
  void (*free_cb)(struct kref *kref);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>userspace visible identifier</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>type of the object, one of DRM_MODE_OBJECT_*</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>properties attached to this object, including values</dd>
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>reference count for objects which with dynamic lifetime</dd>
<dt><code class="docutils literal"><span class="pre">free_cb</span></code></dt>
<dd>free function callback, only set for objects with dynamic lifetime</dd>
</dl>
<p><strong>Description</strong></p>
<p>Base structure for modeset objects visible to userspace. Objects can be
looked up using <a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code></a>. Besides basic uapi interface
properties like <strong>id</strong> and <strong>type</strong> it provides two services:</p>
<ul class="simple">
<li>It tracks attached properties and their values. This is used by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>,
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>. Properties are attached by calling
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a> before the object is visible to userspace.</li>
<li>For objects with dynamic lifetimes (as indicated by a non-NULL <strong>free_cb</strong>) it
provides reference counting through <a class="reference internal" href="#c.drm_mode_object_get" title="drm_mode_object_get"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_get()</span></code></a> and
<a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code></a>. This is used by <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>
and <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob</span></code></a>. These objects provide specialized reference
counting wrappers.</li>
</ul>
<dl class="type">
<dt id="c.drm_object_properties">
struct <code class="descname">drm_object_properties</code><a class="headerlink" href="#c.drm_object_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>property tracking for <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_object_properties {
  int count;
  struct drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
  uint64_t values[DRM_OBJECT_MAX_PROPERTY];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">count</span></code></dt>
<dd>number of valid properties, must be less than or equal to
DRM_OBJECT_MAX_PROPERTY.</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd><p class="first">Array of pointers to <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<p class="last">NOTE: if we ever start dynamically destroying properties (ie.
not at <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a> time), then we&#8217;d have to do
a better job of detaching property from mode objects to avoid
dangling property pointers:</p>
</dd>
<dt><code class="docutils literal"><span class="pre">values</span></code></dt>
<dd><p class="first">Array to store the property values, matching <strong>properties</strong>. Do
not read/write values directly, but use
<a class="reference internal" href="#c.drm_object_property_get_value" title="drm_object_property_get_value"><code class="xref c c-func docutils literal"><span class="pre">drm_object_property_get_value()</span></code></a> and <a class="reference internal" href="#c.drm_object_property_set_value" title="drm_object_property_set_value"><code class="xref c c-func docutils literal"><span class="pre">drm_object_property_set_value()</span></code></a>.</p>
<p>Note that atomic drivers do not store mutable properties in this
array, but only the decoded values in the corresponding state
structure. The decoding is done using the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.atomic_set_property</span></code></a> hooks for <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>. For
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> the hooks are <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_set_property</span></code></a>. And for <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>
the hooks are <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_get_property</span></code></a> and
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_set_property</span></code></a> .</p>
<p class="last">Hence atomic drivers should not use <a class="reference internal" href="#c.drm_object_property_set_value" title="drm_object_property_set_value"><code class="xref c c-func docutils literal"><span class="pre">drm_object_property_set_value()</span></code></a>
and <a class="reference internal" href="#c.drm_object_property_get_value" title="drm_object_property_get_value"><code class="xref c c-func docutils literal"><span class="pre">drm_object_property_get_value()</span></code></a> on mutable objects, i.e. those
without the DRM_MODE_PROP_IMMUTABLE flag set.</p>
</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_object_find">
struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> * <code class="descname">drm_mode_object_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em>, uint32_t<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_find" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a drm object with static lifetime</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>id of the mode object</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt>
<dd>type of the mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to look up a modeset object. It will acquire a
reference for reference counted objects. This reference must be dropped again
by callind <a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_mode_object_put">
void <code class="descname">drm_mode_object_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>DRM mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the object&#8217;s refcount if it is a refcounted modeset
object. It is a no-op on any other object. This is used to drop references
acquired with <a class="reference internal" href="#c.drm_mode_object_get" title="drm_mode_object_get"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_get()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_mode_object_get">
void <code class="descname">drm_mode_object_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_object_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a mode object reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>DRM mode object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the object&#8217;s refcount if it is a refcounted modeset
object. It is a no-op on any other object. References should be dropped again
by calling <a class="reference internal" href="#c.drm_mode_object_put" title="drm_mode_object_put"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_object_attach_property">
void <code class="descname">drm_object_attach_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;init_val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_attach_property" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a property to a modeset object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>drm modeset object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to attach</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">init_val</span></code></dt>
<dd>initial value of the property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This attaches the given property to the modeset object with the given initial
value. Currently this function cannot fail since the properties are stored in
a statically sized array.</p>
<dl class="function">
<dt id="c.drm_object_property_set_value">
int <code class="descname">drm_object_property_set_value</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_property_set_value" title="Permalink to this definition">¶</a></dt>
<dd><p>set the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>drm mode object to set property value for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>value the property should be set to</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sets a given property on a given object. This function only
changes the software state of the property, it does not call into the
driver&#8217;s -&gt;set_property callback.</p>
<p>Note that atomic drivers should not have any need to call this, the core will
ensure consistency of values reported back to userspace through the
appropriate -&gt;atomic_get_property callback. Only legacy drivers should call
this function to update the tracked value (after clamping and other
restrictions have been applied).</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_object_property_get_value">
int <code class="descname">drm_object_property_get_value</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_object_property_get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>drm mode object to get property value from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>storage for the property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function retrieves the softare state of the given property for the given
property. Since there is no driver callback to retrieve the current property
value this might be out of sync with the hardware, depending upon the driver
and property.</p>
<p>Atomic drivers should never call this function directly, the core will read
out property values through the various -&gt;atomic_get_property callbacks.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
<div class="section" id="atomic-mode-setting">
<h2>Atomic Mode Setting<a class="headerlink" href="#atomic-mode-setting" title="Permalink to this headline">¶</a></h2>
<div class="figure" id="id4">
<img alt="Mode Objects and Properties" src="../_images/DOT-69c6997054dbfdfb0892fa0cab076cfd8074c7ed.svg" /><p class="caption"><span class="caption-text">Mode Objects and Properties</span></p>
</div>
<p>Atomic provides transactional modeset (including planes) updates, but a
bit differently from the usual transactional approach of try-commit and
rollback:</p>
<ul class="simple">
<li>Firstly, no hardware changes are allowed when the commit would fail. This
allows us to implement the DRM_MODE_ATOMIC_TEST_ONLY mode, which allows
userspace to explore whether certain configurations would work or not.</li>
<li>This would still allow setting and rollback of just the software state,
simplifying conversion of existing drivers. But auditing drivers for
correctness of the atomic_check code becomes really hard with that: Rolling
back changes in data structures all over the place is hard to get right.</li>
<li>Lastly, for backwards compatibility and to support all use-cases, atomic
updates need to be incremental and be able to execute in parallel. Hardware
doesn&#8217;t always allow it, but where possible plane updates on different CRTCs
should not interfere, and not get stalled due to output routing changing on
different CRTCs.</li>
</ul>
<p>Taken all together there&#8217;s two consequences for the atomic design:</p>
<ul class="simple">
<li>The overall state is split up into per-object state structures:
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> for planes, <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_crtc_state</span></code></a> for CRTCs and <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_connector_state</span></code></a> for connectors. These are the only
objects with userspace-visible and settable state. For internal state drivers
can subclass these structures through embeddeding, or add entirely new state
structures for their globally shared hardware functions.</li>
<li>An atomic update is assembled and validated as an entirely free-standing pile
of structures within the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>
container. Driver private state structures are also tracked in the same
structure; see the next chapter.  Only when a state is committed is it applied
to the driver and modeset objects. This way rolling back an update boils down
to releasing memory and unreferencing objects like framebuffers.</li>
</ul>
<p>Read on in this chapter, and also in <a class="reference internal" href="drm-kms-helpers.html#drm-atomic-helper"><span>Atomic Modeset Helper Functions Reference</span></a> for more detailed
coverage of specific topics.</p>
<div class="section" id="handling-driver-private-state">
<h3>Handling Driver Private State<a class="headerlink" href="#handling-driver-private-state" title="Permalink to this headline">¶</a></h3>
<p>Very often the DRM objects exposed to userspace in the atomic modeset api
(<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>, <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>) do not map neatly to the
underlying hardware. Especially for any kind of shared resources (e.g. shared
clocks, scaler units, bandwidth and fifo limits shared among a group of
planes or CRTCs, and so on) it makes sense to model these as independent
objects. Drivers then need to do similar state tracking and commit ordering for
such private (since not exposed to userpace) objects as the atomic core and
helpers already provide for connectors, planes and CRTCs.</p>
<p>To make this easier on drivers the atomic core provides some support to track
driver private state objects using struct <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal"><span class="pre">drm_private_obj</span></code></a>, with the
associated state struct <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state</span></code></a>.</p>
<p>Similar to userspace-exposed objects, private state structures can be
acquired by calling <a class="reference internal" href="#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a>. Since this function
does not take care of locking, drivers should wrap it for each type of
private state object they have with the required call to <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a>
for the corresponding <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a>.</p>
<p>All private state structures contained in a <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> update can be
iterated using <a class="reference internal" href="#c.for_each_oldnew_private_obj_in_state" title="for_each_oldnew_private_obj_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_private_obj_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_new_private_obj_in_state" title="for_each_new_private_obj_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_private_obj_in_state()</span></code></a> and <a class="reference internal" href="#c.for_each_old_private_obj_in_state" title="for_each_old_private_obj_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_private_obj_in_state()</span></code></a>.
Drivers are recommended to wrap these for each type of driver private state
object they have, filtering on <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal"><span class="pre">drm_private_obj.funcs</span></code></a> using <code class="xref c c-func docutils literal"><span class="pre">for_each_if()</span></code>, at
least if they want to iterate over all objects of a given type.</p>
<p>An earlier way to handle driver private state was by subclassing struct
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>. But since that encourages non-standard ways to implement
the check/commit split atomic requires (by using e.g. &#8220;check and rollback or
commit instead&#8221; of &#8220;duplicate state, check, then either commit or release
duplicated state) it is deprecated in favour of using <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state</span></code></a>.</p>
</div>
<div class="section" id="atomic-mode-setting-function-reference">
<h3>Atomic Mode Setting Function Reference<a class="headerlink" href="#atomic-mode-setting-function-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_crtc_commit">
struct <code class="descname">drm_crtc_commit</code><a class="headerlink" href="#c.drm_crtc_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>track modeset commits on a CRTC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc_commit {
  struct drm_crtc *crtc;
  struct kref ref;
  struct completion flip_done;
  struct completion hw_done;
  struct completion cleanup_done;
  struct list_head commit_entry;
  struct drm_pending_vblank_event *event;
  bool abort_completion;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>DRM CRTC for this commit.</dd>
<dt><code class="docutils literal"><span class="pre">ref</span></code></dt>
<dd>Reference count for this structure. Needed to allow blocking on
completions without the risk of the completion disappearing
meanwhile.</dd>
<dt><code class="docutils literal"><span class="pre">flip_done</span></code></dt>
<dd>Will be signaled when the hardware has flipped to the new set of
buffers. Signals at the same time as when the drm event for this
commit is sent to userspace, or when an out-fence is singalled. Note
that for most hardware, in most cases this happens after <strong>hw_done</strong> is
signalled.</dd>
<dt><code class="docutils literal"><span class="pre">hw_done</span></code></dt>
<dd><p class="first">Will be signalled when all hw register changes for this commit have
been written out. Especially when disabling a pipe this can be much
later than than <strong>flip_done</strong>, since that can signal already when the
screen goes black, whereas to fully shut down a pipe more register
I/O is required.</p>
<p class="last">Note that this does not need to include separately reference-counted
resources like backing storage buffer pinning, or runtime pm
management.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cleanup_done</span></code></dt>
<dd>Will be signalled after old buffers have been cleaned up by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_cleanup_planes" title="drm_atomic_helper_cleanup_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_cleanup_planes()</span></code></a>. Since this can only happen after
a vblank wait completed it might be a bit later. This completion is
useful to throttle updates and avoid hardware updates getting ahead
of the buffer cleanup too much.</dd>
<dt><code class="docutils literal"><span class="pre">commit_entry</span></code></dt>
<dd>Entry on the per-CRTC <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.commit_list</span></code></a>. Protected by
$drm_crtc.commit_lock.</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd><a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal"><span class="pre">drm_pending_vblank_event</span></code></a> pointer to clean up private events.</dd>
<dt><code class="docutils literal"><span class="pre">abort_completion</span></code></dt>
<dd>A flag that&#8217;s set after drm_atomic_helper_setup_commit takes a second
reference for the completion of $drm_crtc_state.event. It&#8217;s used by
the free code to remove the second reference if commit fails.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure is used to track pending modeset changes and atomic commit on
a per-CRTC basis. Since updating the list should never block this structure
is reference counted to allow waiters to safely wait on an event to complete,
without holding any locks.</p>
<p>It has 3 different events in total to allow a fine-grained synchronization
between outstanding updates:</p>
<div class="highlight-none"><div class="highlight"><pre>atomic commit thread                    hardware

write new state into hardware   ----&gt;   ...
signal hw_done
                                        switch to new state on next
...                                     v/hblank

wait for buffers to show up             ...

...                                     send completion irq
                                        irq handler signals flip_done
cleanup old buffers

signal cleanup_done

wait for flip_done              &lt;----
clean up atomic state
</pre></div>
</div>
<p>The important bit to know is that cleanup_done is the terminal event, but the
ordering between flip_done and hw_done is entirely up to the specific driver
and modeset state change.</p>
<p>For an implementation of how to use this look at
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_setup_commit" title="drm_atomic_helper_setup_commit"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_setup_commit()</span></code></a> from the atomic helper library.</p>
<dl class="type">
<dt id="c.drm_private_state_funcs">
struct <code class="descname">drm_private_state_funcs</code><a class="headerlink" href="#c.drm_private_state_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>atomic state functions for private objects</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_private_state_funcs {
  struct drm_private_state *(*atomic_duplicate_state)(struct drm_private_obj *obj);
  void (*atomic_destroy_state)(struct drm_private_obj *obj, struct drm_private_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current state of the private object and return it. It
is an error to call this before obj-&gt;state has been initialized.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when obj-&gt;state is not
initialized or allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd>Frees the private object state created with <strong>atomic_duplicate_state</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>These hooks are used by atomic helpers to create, swap and destroy states of
private objects. The structure itself is used as a vtable to identify the
associated private object type. Each private object type that needs to be
added to the atomic states is expected to have an implementation of these
hooks and pass a pointer to it&#8217;s drm_private_state_funcs struct to
<a class="reference internal" href="#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_private_obj">
struct <code class="descname">drm_private_obj</code><a class="headerlink" href="#c.drm_private_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>base struct for driver private atomic object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_private_obj {
  struct drm_private_state *state;
  const struct drm_private_state_funcs *funcs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>Current atomic state for this driver private object.</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>Functions to manipulate the state of this driver private object, see
<a class="reference internal" href="#c.drm_private_state_funcs" title="drm_private_state_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state_funcs</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A driver private object is initialized by calling
<a class="reference internal" href="#c.drm_atomic_private_obj_init" title="drm_atomic_private_obj_init"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_private_obj_init()</span></code></a> and cleaned up by calling
<a class="reference internal" href="#c.drm_atomic_private_obj_fini" title="drm_atomic_private_obj_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_private_obj_fini()</span></code></a>.</p>
<p>Currently only tracks the state update functions and the opaque driver
private state itself, but in the future might also track which
<a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">drm_modeset_lock</span></code></a> is required to duplicate and update this object&#8217;s state.</p>
<dl class="type">
<dt id="c.drm_private_state">
struct <code class="descname">drm_private_state</code><a class="headerlink" href="#c.drm_private_state" title="Permalink to this definition">¶</a></dt>
<dd><p>base struct for driver private object state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_private_state {
  struct drm_atomic_state *state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Currently only contains a backpointer to the overall atomic update, but in
the future also might hold synchronization information similar to e.g.
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.commit</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_atomic_state">
struct <code class="descname">drm_atomic_state</code><a class="headerlink" href="#c.drm_atomic_state" title="Permalink to this definition">¶</a></dt>
<dd><p>the global state object for atomic updates</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_atomic_state {
  struct kref ref;
  struct drm_device *dev;
  bool allow_modeset : 1;
  bool legacy_cursor_update : 1;
  bool async_update : 1;
  struct __drm_planes_state *planes;
  struct __drm_crtcs_state *crtcs;
  int num_connector;
  struct __drm_connnectors_state *connectors;
  int num_private_objs;
  struct __drm_private_objs_state *private_objs;
  struct drm_modeset_acquire_ctx *acquire_ctx;
  struct drm_crtc_commit *fake_commit;
  struct work_struct commit_work;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ref</span></code></dt>
<dd>count of all references to this state (will not be freed until zero)</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">allow_modeset</span></code></dt>
<dd>allow full modeset</dd>
<dt><code class="docutils literal"><span class="pre">legacy_cursor_update</span></code></dt>
<dd>hint to enforce legacy cursor IOCTL semantics</dd>
<dt><code class="docutils literal"><span class="pre">async_update</span></code></dt>
<dd>hint for asynchronous plane update</dd>
<dt><code class="docutils literal"><span class="pre">planes</span></code></dt>
<dd>pointer to array of structures with per-plane data</dd>
<dt><code class="docutils literal"><span class="pre">crtcs</span></code></dt>
<dd>pointer to array of CRTC pointers</dd>
<dt><code class="docutils literal"><span class="pre">num_connector</span></code></dt>
<dd>size of the <strong>connectors</strong> and <strong>connector_states</strong> arrays</dd>
<dt><code class="docutils literal"><span class="pre">connectors</span></code></dt>
<dd>pointer to array of structures with per-connector data</dd>
<dt><code class="docutils literal"><span class="pre">num_private_objs</span></code></dt>
<dd>size of the <strong>private_objs</strong> array</dd>
<dt><code class="docutils literal"><span class="pre">private_objs</span></code></dt>
<dd>pointer to array of private object pointers</dd>
<dt><code class="docutils literal"><span class="pre">acquire_ctx</span></code></dt>
<dd>acquire context for this atomic modeset state update</dd>
<dt><code class="docutils literal"><span class="pre">fake_commit</span></code></dt>
<dd><p class="first">Used for signaling unbound planes/connectors.
When a connector or plane is not bound to any CRTC, it&#8217;s still important
to preserve linearity to prevent the atomic states from being freed to early.</p>
<p class="last">This commit (if set) is not bound to any crtc, but will be completed when
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_commit_hw_done" title="drm_atomic_helper_commit_hw_done"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_commit_hw_done()</span></code></a> is called.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit_work</span></code></dt>
<dd>Work item which can be used by the driver or helpers to execute the
commit without blocking.</dd>
</dl>
<p><strong>Description</strong></p>
<p>States are added to an atomic update by calling <a class="reference internal" href="#c.drm_atomic_get_crtc_state" title="drm_atomic_get_crtc_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_crtc_state()</span></code></a>,
<a class="reference internal" href="#c.drm_atomic_get_plane_state" title="drm_atomic_get_plane_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_plane_state()</span></code></a>, <a class="reference internal" href="#c.drm_atomic_get_connector_state" title="drm_atomic_get_connector_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_connector_state()</span></code></a>, or for
private state structures, <a class="reference internal" href="#c.drm_atomic_get_private_obj_state" title="drm_atomic_get_private_obj_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_get_private_obj_state()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_commit_get">
struct <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> * <code class="descname">drm_crtc_commit_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<em>&nbsp;commit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_commit_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a reference to the CRTC commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span> <span class="pre">*</span> <span class="pre">commit</span></code></dt>
<dd>CRTC commit</dd>
</dl>
<p><strong>Description</strong></p>
<p>Increases the reference of <strong>commit</strong>.</p>
<p><strong>Return</strong></p>
<p>The pointer to <strong>commit</strong>, with reference increased.</p>
<dl class="function">
<dt id="c.drm_crtc_commit_put">
void <code class="descname">drm_crtc_commit_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit">drm_crtc_commit</a> *<em>&nbsp;commit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_commit_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to the CRTC commmit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span> <span class="pre">*</span> <span class="pre">commit</span></code></dt>
<dd>CRTC commit</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>commit</strong> which is freed after removing the
final reference. No locking required and callable from any context.</p>
<dl class="function">
<dt id="c.drm_atomic_state_get">
struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="descname">drm_atomic_state_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a reference to the atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>The atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a new reference to the <strong>state</strong></p>
<dl class="function">
<dt id="c.drm_atomic_state_put">
void <code class="descname">drm_atomic_state_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a reference to the atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>The atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>This releases a reference to <strong>state</strong> which is freed after removing the
final reference. No locking required and callable from any context.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_existing_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the crtc state for the given crtc, or NULL
if the crtc is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_crtc_state</strong> or
<strong>drm_atomic_get_new_crtc_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_old_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get old crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old crtc state for the given crtc, or
NULL if the crtc is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_new_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get new crtc state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new crtc state for the given crtc, or
NULL if the crtc is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_existing_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, or NULL
if the plane is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_plane_state</strong> or
<strong>drm_atomic_get_new_plane_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_old_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old plane state for the given plane, or
NULL if the plane is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_new_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new plane state for the given plane, or
NULL if the plane is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_existing_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_existing_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_existing_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<p>This function is deprecated, <strong>drm_atomic_get_old_connector_state</strong> or
<strong>drm_atomic_get_new_connector_state</strong> should be used instead.</p>
<dl class="function">
<dt id="c.drm_atomic_get_old_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_old_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_old_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the old connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_get_new_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_new_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_new_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state, if it exists</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the new connector state for the given connector,
or NULL if the connector is not part of the global atomic state.</p>
<dl class="function">
<dt id="c.__drm_atomic_get_current_plane_state">
const struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">__drm_atomic_get_current_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_get_current_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get current plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to grab</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, either from
<strong>state</strong>, or if the plane isn&#8217;t part of the atomic state update, from <strong>plane</strong>.
This is useful in atomic check callbacks, when drivers need to peek at, but
not change, state of other planes, since it avoids threading an error code
back up the call chain.</p>
<p>WARNING:</p>
<p>Note that this function is in general unsafe since it doesn&#8217;t check for the
required locking for access state structures. Drivers must ensure that it is
safe to access the returned state structure through other means. One common
example is when planes are fixed to a single CRTC, and the driver knows that
the CRTC lock is held already. In that case holding the CRTC lock gives a
read-lock on all planes connected to that CRTC. But if planes can be
reassigned things get more tricky. In that case it&#8217;s better to use
drm_atomic_get_plane_state and wire up full error handling.</p>
<p><strong>Return</strong></p>
<p>Read-only pointer to the current plane state.</p>
<dl class="function">
<dt id="c.for_each_oldnew_connector_in_state">
<code class="descname">for_each_oldnew_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>old_connector_state</em>, <em>new_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
old state</dd>
<dt><code class="docutils literal"><span class="pre">new_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_connector_in_state">
<code class="descname">for_each_old_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>old_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_connector_in_state">
<code class="descname">for_each_new_connector_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>connector</em>, <em>new_connector_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_connector_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all connectors in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_connector_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> iteration cursor for the
new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all connectors in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.for_each_oldnew_crtc_in_state">
<code class="descname">for_each_oldnew_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>old_crtc_state</em>, <em>new_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_crtc_in_state">
<code class="descname">for_each_old_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>old_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_crtc_in_state">
<code class="descname">for_each_new_crtc_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>crtc</em>, <em>new_crtc_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_crtc_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_crtc_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all CRTCs in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.for_each_oldnew_plane_in_state">
<code class="descname">for_each_oldnew_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>old_plane_state</em>, <em>new_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking both old and
new state. This is useful in places where the state delta needs to be
considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_oldnew_plane_in_state_reverse">
<code class="descname">for_each_oldnew_plane_in_state_reverse</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>old_plane_state</em>, <em>new_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_plane_in_state_reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update in reverse order</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update in reverse order,
tracking both old and  new state. This is useful in places where the
state delta needs to be considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_plane_in_state">
<code class="descname">for_each_old_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>old_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking only the old
state. This is useful in disable functions, where we need the old state the
hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_plane_in_state">
<code class="descname">for_each_new_plane_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>plane</em>, <em>new_plane_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_plane_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_plane_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all planes in an atomic update, tracking only the new
state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.for_each_oldnew_private_obj_in_state">
<code class="descname">for_each_oldnew_private_obj_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>obj</em>, <em>old_obj_state</em>, <em>new_obj_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_oldnew_private_obj_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all private objects in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_obj_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">new_obj_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking both
old and new state. This is useful in places where the state delta needs
to be considered, for example in atomic check functions.</p>
<dl class="function">
<dt id="c.for_each_old_private_obj_in_state">
<code class="descname">for_each_old_private_obj_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>obj</em>, <em>old_obj_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_old_private_obj_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all private objects in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">old_obj_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code></a> iteration cursor for the old state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking only
the old state. This is useful in disable functions, where we need the old
state the hardware is still in.</p>
<dl class="function">
<dt id="c.for_each_new_private_obj_in_state">
<code class="descname">for_each_new_private_obj_in_state</code><span class="sig-paren">(</span><em>__state</em>, <em>obj</em>, <em>new_obj_state</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.for_each_new_private_obj_in_state" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all private objects in an atomic update</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span></code></a> iteration cursor</dd>
<dt><code class="docutils literal"><span class="pre">new_obj_state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span></code></a> iteration cursor for the new state</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This iterates over all private objects in an atomic update, tracking only
the new state. This is useful in enable functions, where we need the new state the
hardware should be in when the atomic commit operation has completed.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_needs_modeset">
bool <code class="descname">drm_atomic_crtc_needs_modeset</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_needs_modeset" title="Permalink to this definition">¶</a></dt>
<dd><p>compute combined modeset need</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a> for the CRTC</dd>
</dl>
<p><strong>Description</strong></p>
<p>To give drivers flexibility <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> has 3 booleans to track
whether the state CRTC changed enough to need a full modeset cycle:
mode_changed, active_changed and connectors_changed. This helper simply
combines these three to compute the overall need for a modeset for <strong>state</strong>.</p>
<p>The atomic helper code sets these booleans, but drivers can and should
change them appropriately to accurately represent whether a modeset is
really needed. In general, drivers should avoid full modesets whenever
possible.</p>
<p>For example if the CRTC mode has changed, and the hardware is able to enact
the requested mode change without going through a full modeset, the driver
should clear mode_changed in its <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>
implementation.</p>
<dl class="function">
<dt id="c.drm_atomic_state_default_release">
void <code class="descname">drm_atomic_state_default_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_default_release" title="Permalink to this definition">¶</a></dt>
<dd><p>release memory initialized by drm_atomic_state_init</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all the memory allocated by drm_atomic_state_init.
This should only be used by drivers which are still subclassing
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> and haven&#8217;t switched to <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state</span></code></a> yet.</p>
<dl class="function">
<dt id="c.drm_atomic_state_init">
int <code class="descname">drm_atomic_state_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_init" title="Permalink to this definition">¶</a></dt>
<dd><p>init new atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default implementation for filling in a new atomic state.
This should only be used by drivers which are still subclassing
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> and haven&#8217;t switched to <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state</span></code></a> yet.</p>
<dl class="function">
<dt id="c.drm_atomic_state_alloc">
struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> * <code class="descname">drm_atomic_state_alloc</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_alloc" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allocates an empty atomic state to track updates.</p>
<dl class="function">
<dt id="c.drm_atomic_state_default_clear">
void <code class="descname">drm_atomic_state_default_clear</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_default_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear base atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Default implementation for clearing atomic state.
This should only be used by drivers which are still subclassing
<a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a> and haven&#8217;t switched to <a class="reference internal" href="#c.drm_private_state" title="drm_private_state"><code class="xref c c-type docutils literal"><span class="pre">drm_private_state</span></code></a> yet.</p>
<dl class="function">
<dt id="c.drm_atomic_state_clear">
void <code class="descname">drm_atomic_state_clear</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_state_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear state object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the w/w mutex algorithm detects a deadlock we need to back off and drop
all locks. So someone else could sneak in and change the current modeset
configuration. Which means that all the state assembled in <strong>state</strong> is no
longer an atomic update to the current state, but to some arbitrary earlier
state. Which could break assumptions the driver&#8217;s
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> likely relies on.</p>
<p>Hence we must clear all cached state and completely start over, using this
function.</p>
<dl class="function">
<dt id="c.__drm_atomic_state_free">
void <code class="descname">__drm_atomic_state_free</code><span class="sig-paren">(</span>struct kref *<em>&nbsp;ref</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__drm_atomic_state_free" title="Permalink to this definition">¶</a></dt>
<dd><p>free all memory for an atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kref</span> <span class="pre">*</span> <span class="pre">ref</span></code></dt>
<dd>This atomic state to deallocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>This frees all memory associated with an atomic state, including all the
per-object state for planes, crtcs and connectors.</p>
<dl class="function">
<dt id="c.drm_atomic_get_crtc_state">
struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> * <code class="descname">drm_atomic_get_crtc_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get crtc state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to get state object for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the crtc state for the given crtc, allocating it if
needed. It will also grab the relevant crtc lock to make sure that the state
is consistent.</p>
<p><strong>Return</strong></p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_set_mode_for_crtc">
int <code class="descname">drm_atomic_set_mode_for_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_mode_for_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>set mode for CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the CRTC whose incoming state to update</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>kernel-internal mode to use for the CRTC, or NULL to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a mode (originating from the kernel) on the desired CRTC state and update
the enable property.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure. Cannot return -EDEADLK.</p>
<dl class="function">
<dt id="c.drm_atomic_set_mode_prop_for_crtc">
int <code class="descname">drm_atomic_set_mode_prop_for_crtc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_mode_prop_for_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>set mode for CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the CRTC whose incoming state to update</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>pointer to blob property to use for mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set a mode (originating from a blob property) on the desired CRTC state.
This function will take a reference on the blob property for the CRTC state,
and release the reference held on the state&#8217;s existing mode property, if any
was set.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure. Cannot return -EDEADLK.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_set_property">
int <code class="descname">drm_atomic_crtc_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set property on CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the drm CRTC to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to update with the new property value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>the new property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.atomic_set_property</span></code></a> for driver properties. To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_get_plane_state">
struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> * <code class="descname">drm_atomic_get_plane_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to get state object for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the plane state for the given plane, allocating it if
needed. It will also grab the relevant plane lock to make sure that the state
is consistent.</p>
<p><strong>Return</strong></p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_private_obj_init">
void <code class="descname">drm_atomic_private_obj_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em>&nbsp;obj</em>, struct <a class="reference internal" href="#c.drm_private_state" title="drm_private_state">drm_private_state</a> *<em>&nbsp;state</em>, const struct <a class="reference internal" href="#c.drm_private_state_funcs" title="drm_private_state_funcs">drm_private_state_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_private_obj_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize private object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>private object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>initial private object state</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_private_state_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>pointer to the struct of function pointers that identify the object
type</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize the private object, which can be embedded into any
driver private object that needs its own atomic state.</p>
<dl class="function">
<dt id="c.drm_atomic_private_obj_fini">
void <code class="descname">drm_atomic_private_obj_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_private_obj_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>finalize private object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>private object</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finalize the private object.</p>
<dl class="function">
<dt id="c.drm_atomic_get_private_obj_state">
struct <a class="reference internal" href="#c.drm_private_state" title="drm_private_state">drm_private_state</a> * <code class="descname">drm_atomic_get_private_obj_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_private_obj" title="drm_private_obj">drm_private_obj</a> *<em>&nbsp;obj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_private_obj_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get private object state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_private_obj</span> <span class="pre">*</span> <span class="pre">obj</span></code></dt>
<dd>private object to get the state for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the private object state for the given private object,
allocating the state if needed. It does not grab any locks as the caller is
expected to care of any required locking.</p>
<p><strong>Return</strong></p>
<p>Either the allocated state or the error code encoded into a pointer.</p>
<dl class="function">
<dt id="c.drm_atomic_get_connector_state">
struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> * <code class="descname">drm_atomic_get_connector_state</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_get_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>get connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>global atomic state object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to get state object for</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns the connector state for the given connector,
allocating it if needed. It will also grab the relevant connector lock to
make sure that the state is consistent.</p>
<p><strong>Return</strong></p>
<p>Either the allocated state or the error code encoded into the pointer. When
the error is EDEADLK then the w/w mutex code has detected a deadlock and the
entire atomic sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_set_crtc_for_plane">
int <code class="descname">drm_atomic_set_crtc_for_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;plane_state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_crtc_for_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>set crtc for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt>
<dd>the plane whose incoming state to update</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to use for the plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned crtc for a plane requires us to grab the lock and state
for the new crtc, as needed. This function takes care of all these details
besides updating the pointer in the state object itself.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_set_fb_for_plane">
void <code class="descname">drm_atomic_set_fb_for_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;plane_state</em>, struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_fb_for_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>set framebuffer for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt>
<dd>atomic state object for the plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>fb to use for the plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned framebuffer for a plane requires us to grab a reference
to the new fb and drop the reference to the old fb, if there is one. This
function takes care of all these details besides updating the pointer in the
state object itself.</p>
<dl class="function">
<dt id="c.drm_atomic_set_fence_for_plane">
void <code class="descname">drm_atomic_set_fence_for_plane</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;plane_state</em>, struct <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_fence" title="dma_fence">dma_fence</a> *<em>&nbsp;fence</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_fence_for_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>set fence for plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">plane_state</span></code></dt>
<dd>atomic state object for the plane</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_fence</span> <span class="pre">*</span> <span class="pre">fence</span></code></dt>
<dd>dma_fence to use for the plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper to setup the plane_state fence in case it is not set yet.
By using this drivers doesn&#8217;t need to worry if the user choose
implicit or explicit fencing.</p>
<p>This function will not set the fence to the state if it was set
via explicit fencing interfaces on the atomic ioctl. In that case it will
drop the reference to the fence as we are not storing it anywhere.
Otherwise, if <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.fence</span></code></a> is not set this function we just set it
with the received implicit fence. In both cases this function consumes a
reference for <strong>fence</strong>.</p>
<p>This way explicit fencing can be used to overrule implicit fencing, which is
important to make explicit fencing use-cases work: One example is using one
buffer for 2 screens with different refresh rates. Implicit fencing will
clamp rendering to the refresh rate of the slower screen, whereas explicit
fence allows 2 independent render and display loops on a single buffer. If a
driver allows obeys both implicit and explicit fences for plane updates, then
it will break all the benefits of explicit fencing.</p>
<dl class="function">
<dt id="c.drm_atomic_set_crtc_for_connector">
int <code class="descname">drm_atomic_set_crtc_for_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;conn_state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_crtc_for_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>set crtc for connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt>
<dd>atomic state object for the connector</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to use for the connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>Changing the assigned crtc for a connector requires us to grab the lock and
state for the new crtc, as needed. This function takes care of all these
details besides updating the pointer in the state object itself.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_set_writeback_fb_for_connector">
int <code class="descname">drm_atomic_set_writeback_fb_for_connector</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;conn_state</em>, struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_set_writeback_fb_for_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>set writeback framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt>
<dd>atomic state object for the connector</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>fb to use for the connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to set the framebuffer for a writeback connector, which outputs
to a buffer instead of an actual physical connector.
Changing the assigned framebuffer requires us to grab a reference to the new
fb and drop the reference to the old fb, if there is one. This function
takes care of all these details besides updating the pointer in the
state object itself.</p>
<p><strong>Note</strong></p>
<p>The only way conn_state can already have an fb set is if the commit
sets the property more than once.</p>
<p>See also: <a class="reference internal" href="#c.drm_writeback_connector_init" title="drm_writeback_connector_init"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_connector_init()</span></code></a></p>
<p><strong>Return</strong></p>
<p>0 on success</p>
<dl class="function">
<dt id="c.drm_atomic_add_affected_connectors">
int <code class="descname">drm_atomic_add_affected_connectors</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_add_affected_connectors" title="Permalink to this definition">¶</a></dt>
<dd><p>add connectors for crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the current configuration and adds all connectors
currently using <strong>crtc</strong> to the atomic configuration <strong>state</strong>. Note that this
function must acquire the connection mutex. This can potentially cause
unneeded seralization if the update is just for the planes on one crtc. Hence
drivers and helpers should only call this when really needed (e.g. when a
full modeset needs to happen due to some change).</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_add_affected_planes">
int <code class="descname">drm_atomic_add_affected_planes</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_add_affected_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>add planes for crtc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function walks the current configuration and adds all planes
currently used by <strong>crtc</strong> to the atomic configuration <strong>state</strong>. This is useful
when an atomic commit also needs to check all currently enabled plane on
<strong>crtc</strong>, e.g. when changing the mode. It&#8217;s also useful when re-enabling a CRTC
to avoid special code to force-enable all planes.</p>
<p>Since acquiring a plane state will always also acquire the w/w mutex of the
current CRTC for that plane (if there is any) adding all the plane states for
a CRTC will not reduce parallism of atomic updates.</p>
<p><strong>Return</strong></p>
<p>0 on success or can fail with -EDEADLK or -ENOMEM. When the error is EDEADLK
then the w/w mutex code has detected a deadlock and the entire atomic
sequence must be restarted. All other errors are fatal.</p>
<dl class="function">
<dt id="c.drm_atomic_check_only">
int <code class="descname">drm_atomic_check_only</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_check_only" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether a given config would work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic configuration to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_commit">
int <code class="descname">drm_atomic_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>commit configuration atomically</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic configuration to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p>This function will take its own reference on <strong>state</strong>.
Callers should always release their reference with <a class="reference internal" href="#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_nonblocking_commit">
int <code class="descname">drm_atomic_nonblocking_commit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_nonblocking_commit" title="Permalink to this definition">¶</a></dt>
<dd><p>atomic nonblocking commit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic configuration to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function can return -EDEADLK if the driver needed to acquire
more locks but encountered a deadlock. The caller must then do the usual w/w
backoff dance and restart. All other errors are fatal.</p>
<p>This function will take its own reference on <strong>state</strong>.
Callers should always release their reference with <a class="reference internal" href="#c.drm_atomic_state_put" title="drm_atomic_state_put"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_state_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_state_dump">
void <code class="descname">drm_state_dump</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_printer" title="drm_printer">drm_printer</a> *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_state_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>dump entire device atomic state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_printer</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>where to print the state to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just for debugging.  Drivers might want an option to dump state
to dmesg in case of error irq&#8217;s.  (Hint, you probably want to
ratelimit this!)</p>
<p>The caller must <a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_all()</span></code></a>, or if this is called
from error irq handler, it should not be enabled by default.
(Ie. if you are debugging errors you might not care that this
is racey.  But calling this without all modeset locks held is
not inherently safe.)</p>
<dl class="function">
<dt id="c.drm_atomic_replace_property_blob_from_id">
int <code class="descname">drm_atomic_replace_property_blob_from_id</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> **<em>&nbsp;blob</em>, uint64_t<em>&nbsp;blob_id</em>, ssize_t<em>&nbsp;expected_size</em>, ssize_t<em>&nbsp;expected_elem_size</em>, bool *<em>&nbsp;replaced</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_replace_property_blob_from_id" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup the new blob and replace the old one with it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">**</span> <span class="pre">blob</span></code></dt>
<dd>a pointer to the member blob to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">blob_id</span></code></dt>
<dd>ID of the new blob</dd>
<dt><code class="docutils literal"><span class="pre">ssize_t</span> <span class="pre">expected_size</span></code></dt>
<dd>total expected size of the blob data (in bytes)</dd>
<dt><code class="docutils literal"><span class="pre">ssize_t</span> <span class="pre">expected_elem_size</span></code></dt>
<dd>expected element size of the blob data (in bytes)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">replaced</span></code></dt>
<dd>did the blob get replaced?</dd>
</dl>
<p><strong>Description</strong></p>
<p>Replace <strong>blob</strong> with another blob with the ID <strong>blob_id</strong>. If <strong>blob_id</strong> is zero
<strong>blob</strong> becomes NULL.</p>
<p>If <strong>expected_size</strong> is positive the new blob length is expected to be equal
to <strong>expected_size</strong> bytes. If <strong>expected_elem_size</strong> is positive the new blob
length is expected to be a multiple of <strong>expected_elem_size</strong> bytes. Otherwise
an error is returned.</p>
<p><strong>replaced</strong> will indicate to the caller whether the blob was replaced or not.
If the old and new blobs were in fact the same blob <strong>replaced</strong> will be false
otherwise it will be true.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_get_property">
int <code class="descname">drm_atomic_crtc_get_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, const struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_get_property" title="Permalink to this definition">¶</a></dt>
<dd><p>get property value from CRTC state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the drm CRTC to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to get the property value from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>return location for the property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.atomic_get_property</span></code></a> for driver properties. To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_crtc_check">
int <code class="descname">drm_atomic_crtc_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state">drm_crtc_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_crtc_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check crtc state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>crtc state to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides core sanity checks for crtc state.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_connector_check">
int <code class="descname">drm_atomic_connector_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_connector_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>connector state to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides core sanity checks for connector state.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_plane_set_property">
int <code class="descname">drm_atomic_plane_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_plane_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set property on plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>the drm plane to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to update with the new property value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>the new property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_set_property</span></code></a> for driver properties.  To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_plane_get_property">
int <code class="descname">drm_atomic_plane_get_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, const struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_plane_get_property" title="Permalink to this definition">¶</a></dt>
<dd><p>get property value from plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>the drm plane to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to get the property value from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>return location for the property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_funcs.atomic_get_property</span></code></a> for driver properties.  To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_plane_check">
int <code class="descname">drm_atomic_plane_check</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state">drm_plane_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_plane_check" title="Permalink to this definition">¶</a></dt>
<dd><p>check plane state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>plane state to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>Provides core sanity checks for plane state.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_connector_set_property">
int <code class="descname">drm_atomic_connector_set_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_connector_set_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set property on connector.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the drm connector to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to update with the new property value</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">val</span></code></dt>
<dd>the new property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_set_property</span></code></a> for driver properties.  To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
<dl class="function">
<dt id="c.drm_atomic_connector_get_property">
int <code class="descname">drm_atomic_connector_get_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;state</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t *<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_connector_get_property" title="Permalink to this definition">¶</a></dt>
<dd><p>get property value from connector state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the drm connector to set a property on</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>the state object to get the property value from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>the property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">val</span></code></dt>
<dd>return location for the property value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function handles generic/core properties and calls out to driver&#8217;s
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.atomic_get_property</span></code></a> for driver properties.  To ensure
consistent behavior you must call this function rather than the driver hook
directly.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure</p>
</div>
</div>
<div class="section" id="crtc-abstraction">
<h2>CRTC Abstraction<a class="headerlink" href="#crtc-abstraction" title="Permalink to this headline">¶</a></h2>
<p>A CRTC represents the overall display pipeline. It receives pixel data from
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> and blends them together. The <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">drm_display_mode</span></code></a> is also attached
to the CRTC, specifying display timings. On the output side the data is fed
to one or more <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a>, which are then each connected to one
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>.</p>
<p>To create a CRTC, a KMS drivers allocates and zeroes an instances of
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> (possibly as part of a larger structure) and registers it
with a call to <a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>The CRTC is also the entry point for legacy modeset operations, see
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.set_config</span></code></a>, legacy plane operations, see
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> and <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.cursor_set2</span></code></a>, and other legacy
operations like <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.gamma_set</span></code></a>. For atomic drivers all these
features are controlled through <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a> and
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> and <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>.</p>
<div class="section" id="crtc-functions-reference">
<h3>CRTC Functions Reference<a class="headerlink" href="#crtc-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_crtc_state">
struct <code class="descname">drm_crtc_state</code><a class="headerlink" href="#c.drm_crtc_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable CRTC state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc_state {
  struct drm_crtc *crtc;
  bool enable;
  bool active;
  bool planes_changed : 1;
  bool mode_changed : 1;
  bool active_changed : 1;
  bool connectors_changed : 1;
  bool zpos_changed : 1;
  bool color_mgmt_changed : 1;
  bool no_vblank : 1;
  u32 plane_mask;
  u32 connector_mask;
  u32 encoder_mask;
  struct drm_display_mode adjusted_mode;
  struct drm_display_mode mode;
  struct drm_property_blob *mode_blob;
  struct drm_property_blob *degamma_lut;
  struct drm_property_blob *ctm;
  struct drm_property_blob *gamma_lut;
  u32 target_vblank;
  u32 pageflip_flags;
  struct drm_pending_vblank_event *event;
  struct drm_crtc_commit *commit;
  struct drm_atomic_state *state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>backpointer to the CRTC</dd>
<dt><code class="docutils literal"><span class="pre">enable</span></code></dt>
<dd>Whether the CRTC should be enabled, gates all other state.
This controls reservations of shared resources. Actual hardware state
is controlled by <strong>active</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">active</span></code></dt>
<dd><p class="first">Whether the CRTC is actively displaying (used for DPMS).
Implies that <strong>enable</strong> is set. The driver must not release any shared
resources if <strong>active</strong> is set to false but <strong>enable</strong> still true, because
userspace expects that a DPMS ON always succeeds.</p>
<p class="last">Hence drivers must not consult <strong>active</strong> in their various
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a> callback to reject an atomic
commit. They can consult it to aid in the computation of derived
hardware state, since even in the DPMS OFF state the display hardware
should be as much powered down as when the CRTC is completely
disabled through setting <strong>enable</strong> to false.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">planes_changed</span></code></dt>
<dd>Planes on this crtc are updated. Used by the atomic
helpers and drivers to steer the atomic commit control flow.</dd>
<dt><code class="docutils literal"><span class="pre">mode_changed</span></code></dt>
<dd><p class="first"><strong>mode</strong> or <strong>enable</strong> has been changed. Used by the atomic
helpers and drivers to steer the atomic commit control flow. See also
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>.</p>
<p class="last">Drivers are supposed to set this for any CRTC state changes that
require a full modeset. They can also reset it to false if e.g. a
<strong>mode</strong> change can be done without a full modeset by only changing
scaler settings.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">active_changed</span></code></dt>
<dd><strong>active</strong> has been toggled. Used by the atomic
helpers and drivers to steer the atomic commit control flow. See also
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">connectors_changed</span></code></dt>
<dd><p class="first">Connectors to this crtc have been updated,
either in their state or routing. Used by the atomic
helpers and drivers to steer the atomic commit control flow. See also
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a>.</p>
<p class="last">Drivers are supposed to set this as-needed from their own atomic
check code, e.g. from <a class="reference internal" href="drm-kms-helpers.html#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_helper_funcs.atomic_check</span></code></a></p>
</dd>
<dt><code class="docutils literal"><span class="pre">zpos_changed</span></code></dt>
<dd>zpos values of planes on this crtc have been updated.
Used by the atomic helpers and drivers to steer the atomic commit
control flow.</dd>
<dt><code class="docutils literal"><span class="pre">color_mgmt_changed</span></code></dt>
<dd>Color management properties have changed
(<strong>gamma_lut</strong>, <strong>degamma_lut</strong> or <strong>ctm</strong>). Used by the atomic helpers and
drivers to steer the atomic commit control flow.</dd>
<dt><code class="docutils literal"><span class="pre">no_vblank</span></code></dt>
<dd><p class="first">Reflects the ability of a CRTC to send VBLANK events. This state
usually depends on the pipeline configuration, and the main usuage
is CRTCs feeding a writeback connector operating in oneshot mode.
In this case the VBLANK event is only generated when a job is queued
to the writeback connector, and we want the core to fake VBLANK
events when this part of the pipeline hasn&#8217;t changed but others had
or when the CRTC and connectors are being disabled.</p>
<p><a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_crtc_duplicate_state" title="__drm_atomic_helper_crtc_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_crtc_duplicate_state()</span></code></a> will not reset the value
from the current state, the CRTC driver is then responsible for
updating this field when needed.</p>
<p class="last">Note that the combination of <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a> == NULL and
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.no_blank</span></code></a> == true is valid and usually used when the
writeback connector attached to the CRTC has a new job queued. In
this case the driver will send the VBLANK event on its own when the
writeback job is complete.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">plane_mask</span></code></dt>
<dd>Bitmask of drm_plane_mask(plane) of planes attached to
this CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">connector_mask</span></code></dt>
<dd>Bitmask of drm_connector_mask(connector) of
connectors attached to this CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">encoder_mask</span></code></dt>
<dd>Bitmask of drm_encoder_mask(encoder) of encoders
attached to this CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">adjusted_mode</span></code></dt>
<dd><p class="first">Internal display timings which can be used by the driver to handle
differences between the mode requested by userspace in <strong>mode</strong> and what
is actually programmed into the hardware.</p>
<p class="last">For drivers using <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge</span></code></a>, this stores hardware display timings
used between the CRTC and the first bridge. For other drivers, the
meaning of the adjusted_mode field is purely driver implementation
defined information, and will usually be used to store the hardware
display timings used between the CRTC and encoder blocks.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd><p class="first">Display timings requested by userspace. The driver should try to
match the refresh rate as close as possible (but note that it&#8217;s
undefined what exactly is close enough, e.g. some of the HDMI modes
only differ in less than 1% of the refresh rate). The active width
and height as observed by userspace for positioning planes must match
exactly.</p>
<p class="last">For external connectors where the sink isn&#8217;t fixed (like with a
built-in panel), this mode here should match the physical mode on the
wire to the last details (i.e. including sync polarities and
everything).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mode_blob</span></code></dt>
<dd><a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob</span></code></a> for <strong>mode</strong>, for exposing the mode to
atomic userspace.</dd>
<dt><code class="docutils literal"><span class="pre">degamma_lut</span></code></dt>
<dd>Lookup table for converting framebuffer pixel data before apply the
color conversion matrix <strong>ctm</strong>. See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The
blob (if not NULL) is an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">ctm</span></code></dt>
<dd>Color transformation matrix. See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The
blob (if not NULL) is a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_ctm</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_lut</span></code></dt>
<dd>Lookup table for converting pixel data after the color conversion
matrix <strong>ctm</strong>.  See <a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>. The blob (if not
NULL) is an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">target_vblank</span></code></dt>
<dd>Target vertical blank period when a page flip
should take effect.</dd>
<dt><code class="docutils literal"><span class="pre">pageflip_flags</span></code></dt>
<dd>DRM_MODE_PAGE_FLIP_* flags, as passed to the page flip ioctl.
Zero in any other case.</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd><p class="first">Optional pointer to a DRM event to signal upon completion of the
state update. The driver must send out the event when the atomic
commit operation completes. There are two cases:</p>
<blockquote>
<div><ul class="simple">
<li>The event is for a CRTC which is being disabled through this
atomic commit. In that case the event can be send out any time
after the hardware has stopped scanning out the current
framebuffers. It should contain the timestamp and counter for the
last vblank before the display pipeline was shut off. The simplest
way to achieve that is calling <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a>
somewhen after <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> has been called.</li>
<li>For a CRTC which is enabled at the end of the commit (even when it
undergoes an full modeset) the vblank timestamp and counter must
be for the vblank right before the first frame that scans out the
new set of buffers. Again the event can only be sent out after the
hardware has stopped scanning out the old buffers.</li>
<li>Events for disabled CRTCs are not allowed, and drivers can ignore
that case.</li>
</ul>
</div></blockquote>
<p>This can be handled by the <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> function,
which the driver should call on the provided event upon completion of
the atomic commit. Note that if the driver supports vblank signalling
and timestamping the vblank counters and timestamps must agree with
the ones returned from page flip events. With the current vblank
helper infrastructure this can be achieved by holding a vblank
reference while the page flip is pending, acquired through
<a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_get()</span></code></a> and released with <a class="reference internal" href="#c.drm_crtc_vblank_put" title="drm_crtc_vblank_put"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_put()</span></code></a>.
Drivers are free to implement their own vblank counter and timestamp
tracking though, e.g. if they have accurate timestamp registers in
hardware.</p>
<p>For hardware which supports some means to synchronize vblank
interrupt delivery with committing display state there&#8217;s also
<a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>. See the documentation of that function
for a detailed discussion of the constraints it needs to be used
safely.</p>
<p class="last">If the device can&#8217;t notify of flip completion in a race-free way
at all, then the event should be armed just after the page flip is
committed. In the worst case the driver will send the event to
userspace one frame too late. This doesn&#8217;t allow for a real atomic
update, but it should avoid tearing.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd>This tracks how the commit for this update proceeds through the
various phases. This is never cleared, except when we destroy the
state, so that subsequent commits can synchronize with previous ones.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the distinction between <strong>enable</strong> and <strong>active</strong> is rather subtile:
Flipping <strong>active</strong> while <strong>enable</strong> is set without changing anything else may
never return in a failure from the <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check</span></code></a>
callback. Userspace assumes that a DPMS On will always succeed. In other
words: <strong>enable</strong> controls resource assignment, <strong>active</strong> controls the actual
hardware state.</p>
<p>The three booleans active_changed, connectors_changed and mode_changed are
intended to indicate whether a full modeset is needed, rather than strictly
describing what has changed in a commit. See also:
<a class="reference internal" href="#c.drm_atomic_crtc_needs_modeset" title="drm_atomic_crtc_needs_modeset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_needs_modeset()</span></code></a></p>
<p>WARNING: Transitional helpers (like <a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_crtc_mode_set" title="drm_helper_crtc_mode_set"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_crtc_mode_set()</span></code></a> or
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_crtc_mode_set_base" title="drm_helper_crtc_mode_set_base"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_crtc_mode_set_base()</span></code></a>) do not maintain many of the derived control
state like <strong>plane_mask</strong> so drivers not converted over to atomic helpers should
not rely on these being accurate!</p>
<dl class="type">
<dt id="c.drm_crtc_funcs">
struct <code class="descname">drm_crtc_funcs</code><a class="headerlink" href="#c.drm_crtc_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>control CRTCs for a given device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc_funcs {
  void (*reset)(struct drm_crtc *crtc);
  int (*cursor_set)(struct drm_crtc *crtc, struct drm_file *file_priv, uint32_t handle, uint32_t width, uint32_t height);
  int (*cursor_set2)(struct drm_crtc *crtc, struct drm_file *file_priv,uint32_t handle, uint32_t width, uint32_t height, int32_t hot_x, int32_t hot_y);
  int (*cursor_move)(struct drm_crtc *crtc, int x, int y);
  int (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,uint32_t size, struct drm_modeset_acquire_ctx *ctx);
  void (*destroy)(struct drm_crtc *crtc);
  int (*set_config)(struct drm_mode_set *set, struct drm_modeset_acquire_ctx *ctx);
  int (*page_flip)(struct drm_crtc *crtc,struct drm_framebuffer *fb,struct drm_pending_vblank_event *event,uint32_t flags, struct drm_modeset_acquire_ctx *ctx);
  int (*page_flip_target)(struct drm_crtc *crtc,struct drm_framebuffer *fb,struct drm_pending_vblank_event *event,uint32_t flags, uint32_t target, struct drm_modeset_acquire_ctx *ctx);
  int (*set_property)(struct drm_crtc *crtc, struct drm_property *property, uint64_t val);
  struct drm_crtc_state *(*atomic_duplicate_state)(struct drm_crtc *crtc);
  void (*atomic_destroy_state)(struct drm_crtc *crtc, struct drm_crtc_state *state);
  int (*atomic_set_property)(struct drm_crtc *crtc,struct drm_crtc_state *state,struct drm_property *property, uint64_t val);
  int (*atomic_get_property)(struct drm_crtc *crtc,const struct drm_crtc_state *state,struct drm_property *property, uint64_t *val);
  int (*late_register)(struct drm_crtc *crtc);
  void (*early_unregister)(struct drm_crtc *crtc);
  int (*set_crc_source)(struct drm_crtc *crtc, const char *source, size_t *values_cnt);
  void (*atomic_print_state)(struct drm_printer *p, const struct drm_crtc_state *state);
  u32 (*get_vblank_counter)(struct drm_crtc *crtc);
  int (*enable_vblank)(struct drm_crtc *crtc);
  void (*disable_vblank)(struct drm_crtc *crtc);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset CRTC hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_crtc_reset" title="drm_atomic_helper_crtc_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_crtc_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_set</span></code></dt>
<dd><p class="first">Update the cursor image. The cursor position is relative to the CRTC
and can be partially or fully outside of the visible area.</p>
<p>Note that contrary to all other KMS functions the legacy cursor entry
points don&#8217;t take a framebuffer object, but instead take directly a
raw buffer object id from the driver&#8217;s buffer manager (which is
either GEM or TTM for current drivers).</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_set2</span></code></dt>
<dd><p class="first">Update the cursor image, including hotspot information. The hotspot
must not affect the cursor position in CRTC coordinates, but is only
meant as a hint for virtualized display hardware to coordinate the
guests and hosts cursor position. The cursor hotspot is relative to
the cursor image. Otherwise this works exactly like <strong>cursor_set</strong>.</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">cursor_move</span></code></dt>
<dd><p class="first">Update the cursor position. The cursor does not need to be visible
when this hook is called.</p>
<p>This entry point is deprecated, drivers should instead implement
universal plane support and register a proper cursor plane using
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>This callback is optional.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">gamma_set</span></code></dt>
<dd><p class="first">Set gamma on the CRTC.</p>
<p>This callback is optional.</p>
<p class="last">Atomic drivers who want to support gamma tables should implement the
atomic color management support, enabled by calling
<a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>, which then supports the legacy gamma
interface through the <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_legacy_gamma_set" title="drm_atomic_helper_legacy_gamma_set"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code></a>
compatibility implementation.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up plane resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a> since a CRTC cannot be hotplugged
in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">set_config</span></code></dt>
<dd><p class="first">This is the main legacy entry point to change the modeset state on a
CRTC. All the details of the desired configuration are passed in a
<a class="reference internal" href="#c.drm_mode_set" title="drm_mode_set"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_set</span></code></a> - see there for details.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_set_config" title="drm_atomic_helper_set_config"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_set_config()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">page_flip</span></code></dt>
<dd><p class="first">Legacy entry point to schedule a flip to the given framebuffer.</p>
<p>Page flipping is a synchronization mechanism that replaces the frame
buffer being scanned out by the CRTC with a new frame buffer during
vertical blanking, avoiding tearing (except when requested otherwise
through the DRM_MODE_PAGE_FLIP_ASYNC flag). When an application
requests a page flip the DRM core verifies that the new frame buffer
is large enough to be scanned out by the CRTC in the currently
configured mode and then calls this hook with a pointer to the new
frame buffer.</p>
<p>The driver must wait for any pending rendering to the new framebuffer
to complete before executing the flip. It should also wait for any
pending rendering from other drivers if the underlying buffer is a
shared dma-buf.</p>
<p>An application can request to be notified when the page flip has
completed. The drm core will supply a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_event</span></code> in the event
parameter in this case. This can be handled by the
<a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> function, which the driver should call on
the provided event upon completion of the flip. Note that if
the driver supports vblank signalling and timestamping the vblank
counters and timestamps must agree with the ones returned from page
flip events. With the current vblank helper infrastructure this can
be achieved by holding a vblank reference while the page flip is
pending, acquired through <a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_get()</span></code></a> and released with
<a class="reference internal" href="#c.drm_crtc_vblank_put" title="drm_crtc_vblank_put"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_put()</span></code></a>. Drivers are free to implement their own vblank
counter and timestamp tracking though, e.g. if they have accurate
timestamp registers in hardware.</p>
<p>This callback is optional.</p>
<p>NOTE:</p>
<p>Very early versions of the KMS ABI mandated that the driver must
block (but not reject) any rendering to the old framebuffer until the
flip operation has completed and the old framebuffer is no longer
visible. This requirement has been lifted, and userspace is instead
expected to request delivery of an event and wait with recycling old
buffers until such has been received.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure. Note that if a
page flip operation is already pending the callback should return
-EBUSY. Pageflips on a disabled CRTC (either by setting a NULL mode
or just runtime disabled through DPMS respectively the new atomic
&#8220;ACTIVE&#8221; state) should result in an -EINVAL error code. Note that
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_page_flip" title="drm_atomic_helper_page_flip"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_page_flip()</span></code></a> checks this already for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">page_flip_target</span></code></dt>
<dd><p class="first">Same as <strong>page_flip</strong> but with an additional parameter specifying the
absolute target vertical blank period (as reported by
<a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_count()</span></code></a>) when the flip should take effect.</p>
<p class="last">Note that the core code calls drm_crtc_vblank_get before this entry
point, and will call drm_crtc_vblank_put if this entry point returns
any non-0 error code. It&#8217;s the driver&#8217;s responsibility to call
drm_crtc_vblank_put after this entry point returns 0, typically when
the flip completes.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
CRTC.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this CRTC and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>This callback is mandatory for atomic drivers.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_crtc_duplicate_state" title="drm_atomic_helper_crtc_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_crtc_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_crtc_duplicate_state" title="__drm_atomic_helper_crtc_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_crtc_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd><p class="first">Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</p>
<p class="last">This callback is mandatory for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_crtc_set_property" title="drm_atomic_crtc_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_set_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which should never happen, the core only
asks for properties attached to this CRTC). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETCRTC IOCTL.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_crtc_get_property" title="drm_atomic_crtc_get_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_get_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which should never happen, the core only asks for
properties attached to this CRTC).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the crtc like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the crtc from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
<dt><code class="docutils literal"><span class="pre">set_crc_source</span></code></dt>
<dd><p class="first">Changes the source of CRC checksums of frames at the request of
userspace, typically for testing purposes. The sources available are
specific of each driver and a <code class="docutils literal"><span class="pre">NULL</span></code> value indicates that CRC
generation is to be switched off.</p>
<p>When CRC generation is enabled, the driver should call
<a class="reference internal" href="drm-uapi.html#c.drm_crtc_add_crc_entry" title="drm_crtc_add_crc_entry"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_add_crc_entry()</span></code></a> at each frame, providing any information
that characterizes the frame contents in the crcN arguments, as
provided from the configured source. Drivers must accept an &#8220;auto&#8221;
source name that will select a default source for this CRTC.</p>
<p>Note that &#8220;auto&#8221; can depend upon the current modeset configuration,
e.g. it could pick an encoder or output specific CRC sampling point.</p>
<p>This callback is optional if the driver does not support any CRC
generation functionality.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_crtc_print_state()</span></code>
instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">get_vblank_counter</span></code></dt>
<dd><p class="first">Driver callback for fetching a raw hardware vblank counter for the
CRTC. It&#8217;s meant to be used by new drivers as the replacement of
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.get_vblank_counter</span></code></a> hook.</p>
<p>This callback is optional. If a device doesn&#8217;t have a hardware
counter, the driver can simply leave the hook as NULL. The DRM core
will account for missed vblank events while interrupts where disabled
based on system timestamps.</p>
<p>Wraparound handling and loss of events due to modesetting is dealt
with in the DRM core code, as long as drivers call
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> and <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code></a> when disabling or
enabling a CRTC.</p>
<p>See also <code class="xref c c-type docutils literal"><span class="pre">drm_device.vblank_disable_immediate</span></code> and
<code class="xref c c-type docutils literal"><span class="pre">drm_device.max_vblank_count</span></code>.</p>
<p>Returns:</p>
<p class="last">Raw vblank counter value.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">enable_vblank</span></code></dt>
<dd><p class="first">Enable vblank interrupts for the CRTC. It&#8217;s meant to be used by
new drivers as the replacement of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.enable_vblank</span></code></a> hook.</p>
<p>Returns:</p>
<p class="last">Zero on success, appropriate errno if the vblank interrupt cannot
be enabled.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable_vblank</span></code></dt>
<dd>Disable vblank interrupts for the CRTC. It&#8217;s meant to be used by
new drivers as the replacement of <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.disable_vblank</span></code></a> hook.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The drm_crtc_funcs structure is the central CRTC management structure
in the DRM.  Each CRTC controls one or more connectors (note that the name
CRTC is simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc.
connectors, not just CRTs).</p>
<p>Each driver is responsible for filling out this structure at startup time,
in addition to providing other modesetting features, like i2c and DDC
bus accessors.</p>
<dl class="type">
<dt id="c.drm_crtc">
struct <code class="descname">drm_crtc</code><a class="headerlink" href="#c.drm_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>central CRTC control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_crtc {
  struct drm_device *dev;
  struct device_node *port;
  struct list_head head;
  char *name;
  struct drm_modeset_lock mutex;
  struct drm_mode_object base;
  struct drm_plane *primary;
  struct drm_plane *cursor;
  unsigned index;
  int cursor_x;
  int cursor_y;
  bool enabled;
  struct drm_display_mode mode;
  struct drm_display_mode hwmode;
  int x;
  int y;
  const struct drm_crtc_funcs *funcs;
  uint32_t gamma_size;
  uint16_t *gamma_store;
  const struct drm_crtc_helper_funcs *helper_private;
  struct drm_object_properties properties;
  struct drm_crtc_state *state;
  struct list_head commit_list;
  spinlock_t commit_lock;
#ifdef CONFIG_DEBUG_FS;
  struct dentry *debugfs_entry;
#endif;
  struct drm_crtc_crc crc;
  unsigned int fence_context;
  spinlock_t fence_lock;
  unsigned long fence_seqno;
  char timeline_name[32];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">port</span></code></dt>
<dd>OF node used by <a class="reference internal" href="drm-kms-helpers.html#c.drm_of_find_possible_crtcs" title="drm_of_find_possible_crtcs"><code class="xref c c-func docutils literal"><span class="pre">drm_of_find_possible_crtcs()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>List of all CRTCs on <strong>dev</strong>, linked from <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.crtc_list</span></code></a>.
Invariant over the lifetime of <strong>dev</strong> and therefore does not need
locking.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">This provides a read lock for the overall CRTC state (mode, dpms
state, ...) and a write lock for everything which can be update
without a full modeset (fb, cursor data, CRTC properties ...). A full
modeset also need to grab <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>.</p>
<p class="last">For atomic drivers specifically this protects <strong>state</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object for ID tracking etc.</dd>
<dt><code class="docutils literal"><span class="pre">primary</span></code></dt>
<dd>Primary plane for this CRTC. Note that this is only
relevant for legacy IOCTL, it specifies the plane implicitly used by
the SETCRTC and PAGE_FLIP IOCTLs. It does not have any significance
beyond that.</dd>
<dt><code class="docutils literal"><span class="pre">cursor</span></code></dt>
<dd>Cursor plane for this CRTC. Note that this is only relevant for
legacy IOCTL, it specifies the plane implicitly used by the SETCURSOR
and SETCURSOR2 IOCTLs. It does not have any significance
beyond that.</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">cursor_x</span></code></dt>
<dd>Current x position of the cursor, used for universal
cursor planes because the SETCURSOR IOCTL only can update the
framebuffer without supplying the coordinates. Drivers should not use
this directly, atomic drivers should look at <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.crtc_x</span></code></a>
of the cursor plane instead.</dd>
<dt><code class="docutils literal"><span class="pre">cursor_y</span></code></dt>
<dd>Current y position of the cursor, used for universal
cursor planes because the SETCURSOR IOCTL only can update the
framebuffer without supplying the coordinates. Drivers should not use
this directly, atomic drivers should look at <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.crtc_y</span></code></a>
of the cursor plane instead.</dd>
<dt><code class="docutils literal"><span class="pre">enabled</span></code></dt>
<dd>Is this CRTC enabled? Should only be used by legacy drivers, atomic
drivers should instead consult <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.enable</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.active</span></code></a>. Atomic drivers can update this by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>Current mode timings. Should only be used by legacy drivers, atomic
drivers should instead consult <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.mode</span></code></a>. Atomic drivers
can update this by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">hwmode</span></code></dt>
<dd><p class="first">Programmed mode in hw, after adjustments for encoders, crtc, panel
scaling etc. Should only be used by legacy drivers, for high
precision vblank timestamps in
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a>.</p>
<p class="last">Note that atomic drivers should not use this, but instead use
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a>. And for high-precision timestamps
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a> used <a class="reference internal" href="#c.drm_vblank_crtc" title="drm_vblank_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_vblank_crtc.hwmode</span></code></a>,
which is filled out by calling <a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>x position on screen. Should only be used by legacy drivers, atomic
drivers should look at <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.crtc_x</span></code></a> of the primary plane
instead. Updated by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>y position on screen. Should only be used by legacy drivers, atomic
drivers should look at <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.crtc_y</span></code></a> of the primary plane
instead. Updated by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>CRTC control functions</dd>
<dt><code class="docutils literal"><span class="pre">gamma_size</span></code></dt>
<dd>Size of legacy gamma ramp reported to userspace. Set up
by calling <a class="reference internal" href="#c.drm_mode_crtc_set_gamma_size" title="drm_mode_crtc_set_gamma_size"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_crtc_set_gamma_size()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">gamma_store</span></code></dt>
<dd>Gamma ramp values used by the legacy SETGAMMA and
GETGAMMA IOCTls. Set up by calling <a class="reference internal" href="#c.drm_mode_crtc_set_gamma_size" title="drm_mode_crtc_set_gamma_size"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_crtc_set_gamma_size()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this CRTC</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this CRTC.</p>
<p class="last">This is protected by <strong>mutex</strong>. Note that nonblocking atomic commits
access the current CRTC state without taking locks. Either by going
through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointers, see
<a class="reference internal" href="#c.for_each_oldnew_crtc_in_state" title="for_each_oldnew_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_crtc_in_state()</span></code></a>, <a class="reference internal" href="#c.for_each_old_crtc_in_state" title="for_each_old_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_crtc_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_crtc_in_state" title="for_each_new_crtc_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_crtc_in_state()</span></code></a>. Or through careful ordering of atomic
commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit_list</span></code></dt>
<dd><p class="first">List of <a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_commit</span></code></a> structures tracking pending commits.
Protected by <strong>commit_lock</strong>. This list holds its own full reference,
as does the ongoing commit.</p>
<p class="last">&#8220;Note that the commit for a state change is also tracked in
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.commit</span></code></a>. For accessing the immediately preceding
commit in an atomic update it is recommended to just use that
pointer in the old CRTC state, since accessing that doesn&#8217;t need
any locking or list-walking. <strong>commit_list</strong> should only be used to
stall for framebuffer cleanup that&#8217;s signalled through
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_commit.cleanup_done</span></code></a>.&#8221;</p>
</dd>
<dt><code class="docutils literal"><span class="pre">commit_lock</span></code></dt>
<dd>Spinlock to protect <strong>commit_list</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_entry</span></code></dt>
<dd>Debugfs directory for this CRTC.</dd>
<dt><code class="docutils literal"><span class="pre">crc</span></code></dt>
<dd>Configuration settings of CRC capture.</dd>
<dt><code class="docutils literal"><span class="pre">fence_context</span></code></dt>
<dd>timeline context used for fence operations.</dd>
<dt><code class="docutils literal"><span class="pre">fence_lock</span></code></dt>
<dd>spinlock to protect the fences in the fence_context.</dd>
<dt><code class="docutils literal"><span class="pre">fence_seqno</span></code></dt>
<dd>Seqno variable used as monotonic counter for the fences
created on the CRTC&#8217;s timeline.</dd>
<dt><code class="docutils literal"><span class="pre">timeline_name</span></code></dt>
<dd>The name of the CRTC&#8217;s fence timeline.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each CRTC may have one or more connectors associated with it.  This structure
allows the CRTC to be controlled.</p>
<dl class="type">
<dt id="c.drm_mode_set">
struct <code class="descname">drm_mode_set</code><a class="headerlink" href="#c.drm_mode_set" title="Permalink to this definition">¶</a></dt>
<dd><p>new values for a CRTC config change</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_mode_set {
  struct drm_framebuffer *fb;
  struct drm_crtc *crtc;
  struct drm_display_mode *mode;
  uint32_t x;
  uint32_t y;
  struct drm_connector **connectors;
  size_t num_connectors;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>framebuffer to use for new config</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>CRTC whose configuration we&#8217;re about to change</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>mode timings to use</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>position of this CRTC relative to <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>position of this CRTC relative to <strong>fb</strong></dd>
<dt><code class="docutils literal"><span class="pre">connectors</span></code></dt>
<dd>array of connectors to drive with this CRTC if possible</dd>
<dt><code class="docutils literal"><span class="pre">num_connectors</span></code></dt>
<dd>size of <strong>connectors</strong> array</dd>
</dl>
<p><strong>Description</strong></p>
<p>This represents a modeset configuration for the legacy SETCRTC ioctl and is
also used internally. Atomic drivers instead use <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">drm_atomic_state</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_index">
unsigned int <code class="descname">drm_crtc_index</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered CRTC, return the index of that CRTC within a DRM
device&#8217;s list of CRTCs.</p>
<dl class="function">
<dt id="c.drm_crtc_mask">
uint32_t <code class="descname">drm_crtc_mask</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>find the mask of a registered CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to find mask for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered CRTC, return the mask bit of that CRTC for the
<a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder.possible_crtcs</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.possible_crtcs</span></code></a> fields.</p>
<dl class="function">
<dt id="c.drm_crtc_find">
struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> * <code class="descname">drm_crtc_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_find" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a CRTC object from its ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd><a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a> ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to look up a CRTC from its userspace ID. Only used by
drivers for legacy IOCTLs and interface, nowadays extensions to the KMS
userspace interface should be done using <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_crtc">
<code class="descname">drm_for_each_crtc</code><span class="sig-paren">(</span><em>crtc</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> as the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all CRTCs of <strong>dev</strong>.</p>
<dl class="function">
<dt id="c.drm_crtc_from_index">
struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> * <code class="descname">drm_crtc_from_index</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_from_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the registered CRTC at an index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>index of registered CRTC to find for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a CRTC index, return the registered CRTC from DRM device&#8217;s
list of CRTCs with matching index. This is the inverse of <a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a>.
It&#8217;s useful in the vblank callbacks (like <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.enable_vblank</span></code></a> or
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.disable_vblank</span></code></a>), since that still deals with indices instead
of pointers to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>.&#8221;</p>
<dl class="function">
<dt id="c.drm_crtc_force_disable">
int <code class="descname">drm_crtc_force_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_force_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcibly turn off a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to turn off</dd>
</dl>
<p><strong>Note</strong></p>
<p>This should only be used by non-atomic legacy drivers.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_force_disable_all">
int <code class="descname">drm_crtc_force_disable_all</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_force_disable_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcibly turn off all enabled CRTCs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device whose CRTCs to turn off</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers may want to call this on unload to ensure that all displays are
unlit and the GPU is in a consistent, low power state. Takes modeset locks.</p>
<p><strong>Note</strong></p>
<p>This should only be used by non-atomic legacy drivers. For an atomic
version look at <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_shutdown" title="drm_atomic_helper_shutdown"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_shutdown()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_init_with_planes">
int <code class="descname">drm_crtc_init_with_planes</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;primary</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;cursor</em>, const struct <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs">drm_crtc_funcs</a> *<em>&nbsp;funcs</em>, const char *<em>&nbsp;name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_init_with_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise a new CRTC object with specified primary and cursor planes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC object to init</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">primary</span></code></dt>
<dd>Primary plane for CRTC</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">cursor</span></code></dt>
<dd>Cursor plane for CRTC</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for the new CRTC</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>printf style format string for the CRTC name, or NULL for default name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Inits a new object created as base part of a driver crtc object. Drivers
should use this function instead of <a class="reference internal" href="drm-kms-helpers.html#c.drm_crtc_init" title="drm_crtc_init"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init()</span></code></a>, which is only provided
for backwards compatibility with drivers which do not yet support universal
planes). For really simple hardware which has only 1 plane look at
<a class="reference internal" href="drm-kms-helpers.html#c.drm_simple_display_pipe_init" title="drm_simple_display_pipe_init"><code class="xref c c-func docutils literal"><span class="pre">drm_simple_display_pipe_init()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_cleanup">
void <code class="descname">drm_crtc_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up the core crtc usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up <strong>crtc</strong> and removes it from the DRM mode setting
core. Note that the function does <em>not</em> free the crtc structure itself,
this is the responsibility of the caller.</p>
<dl class="function">
<dt id="c.drm_mode_set_config_internal">
int <code class="descname">drm_mode_set_config_internal</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_mode_set" title="drm_mode_set">drm_mode_set</a> *<em>&nbsp;set</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_config_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to call <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.set_config</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_set</span> <span class="pre">*</span> <span class="pre">set</span></code></dt>
<dd>modeset config to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a little helper to wrap internal calls to the
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.set_config</span></code></a> driver interface. The only thing it adds is
correct refcounting dance.</p>
<p>This should only be used by non-atomic legacy drivers.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_check_viewport">
int <code class="descname">drm_crtc_check_viewport</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, int<em>&nbsp;x</em>, int<em>&nbsp;y</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, const struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_check_viewport" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a framebuffer is big enough for the CRTC viewport</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC that framebuffer will be displayed on</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">x</span></code></dt>
<dd>x panning</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">y</span></code></dt>
<dd>y panning</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode that framebuffer will be displayed under</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to check size of</dd>
</dl>
</div>
</div>
<div class="section" id="frame-buffer-abstraction">
<h2>Frame Buffer Abstraction<a class="headerlink" href="#frame-buffer-abstraction" title="Permalink to this headline">¶</a></h2>
<p>Frame buffers are abstract memory objects that provide a source of pixels to
scanout to a CRTC. Applications explicitly request the creation of frame
buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and receive an opaque
handle that can be passed to the KMS CRTC control, plane configuration and
page flip functions.</p>
<p>Frame buffers rely on the underlying memory manager for allocating backing
storage. When creating a frame buffer applications pass a memory handle
(or a list of memory handles for multi-planar formats) through the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span></code> argument. For drivers using GEM as their userspace
buffer management interface this would be a GEM handle.  Drivers are however
free to use their own backing storage object handles, e.g. vmwgfx directly
exposes special TTM handles to userspace and so expects TTM handles in the
create ioctl and not GEM handles.</p>
<p>Framebuffers are tracked with <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a>. They are published
using <a class="reference internal" href="#c.drm_framebuffer_init" title="drm_framebuffer_init"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_init()</span></code></a> - after calling that function userspace can use
and access the framebuffer object. The helper function
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_mode_fill_fb_struct" title="drm_helper_mode_fill_fb_struct"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_mode_fill_fb_struct()</span></code></a> can be used to pre-fill the required
metadata fields.</p>
<p>The lifetime of a drm framebuffer is controlled with a reference count,
drivers can grab additional references with <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_get()</span></code></a> and drop
them again with <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a>. For driver-private framebuffers for
which the last reference is never dropped (e.g. for the fbdev framebuffer
when the struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span></code></a> is embedded into the fbdev helper
struct) drivers can manually clean up a framebuffer at module unload time
with <a class="reference internal" href="#c.drm_framebuffer_unregister_private" title="drm_framebuffer_unregister_private"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_unregister_private()</span></code></a>. But doing this is not
recommended, and it&#8217;s better to have a normal free-standing <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_framebuffer</span></code></a>.</p>
<div class="section" id="frame-buffer-functions-reference">
<h3>Frame Buffer Functions Reference<a class="headerlink" href="#frame-buffer-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_framebuffer_funcs">
struct <code class="descname">drm_framebuffer_funcs</code><a class="headerlink" href="#c.drm_framebuffer_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>framebuffer hooks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_framebuffer_funcs {
  void (*destroy)(struct drm_framebuffer *framebuffer);
  int (*create_handle)(struct drm_framebuffer *fb,struct drm_file *file_priv, unsigned int *handle);
  int (*dirty)(struct drm_framebuffer *framebuffer,struct drm_file *file_priv, unsigned flags,unsigned color, struct drm_clip_rect *clips, unsigned num_clips);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up framebuffer resources, specifically also unreference the
backing storage. The core guarantees to call this function for every
framebuffer successfully created by calling
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.fb_create</span></code></a>. Drivers must also call
<a class="reference internal" href="#c.drm_framebuffer_cleanup" title="drm_framebuffer_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_cleanup()</span></code></a> to release DRM core resources for this
framebuffer.</dd>
<dt><code class="docutils literal"><span class="pre">create_handle</span></code></dt>
<dd><p class="first">Create a buffer handle in the driver-specific buffer manager (either
GEM or TTM) valid for the passed-in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span></code></a>. This is used by
the core to implement the GETFB IOCTL, which returns (for
sufficiently priviledged user) also a native buffer handle. This can
be used for seamless transitions between modesetting clients by
copying the current screen contents to a private buffer and blending
between that and the new contents.</p>
<p>GEM based drivers should call <a class="reference internal" href="drm-mm.html#c.drm_gem_handle_create" title="drm_gem_handle_create"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_handle_create()</span></code></a> to create the
handle.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dirty</span></code></dt>
<dd><p class="first">Optional callback for the dirty fb IOCTL.</p>
<p>Userspace can notify the driver via this callback that an area of the
framebuffer has changed and should be flushed to the display
hardware. This can also be used internally, e.g. by the fbdev
emulation, though that&#8217;s not the case currently.</p>
<p>See documentation in drm_mode.h for the struct drm_mode_fb_dirty_cmd
for more information as all the semantics and arguments have a one to
one mapping on this function.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_framebuffer">
struct <code class="descname">drm_framebuffer</code><a class="headerlink" href="#c.drm_framebuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>frame buffer object</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_framebuffer {
  struct drm_device *dev;
  struct list_head head;
  struct drm_mode_object base;
  char comm[TASK_COMM_LEN];
  const struct drm_format_info *format;
  const struct drm_framebuffer_funcs *funcs;
  unsigned int pitches[4];
  unsigned int offsets[4];
  uint64_t modifier;
  unsigned int width;
  unsigned int height;
  int flags;
  int hot_x;
  int hot_y;
  struct list_head filp_head;
  struct drm_gem_object *obj[4];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device this framebuffer belongs to</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>Place on the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.fb_list</span></code></a>, access protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.fb_lock</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base modeset object structure, contains the reference count.</dd>
<dt><code class="docutils literal"><span class="pre">comm</span></code></dt>
<dd>Name of the process allocating the fb, used for fb dumping.</dd>
<dt><code class="docutils literal"><span class="pre">format</span></code></dt>
<dd>framebuffer format information</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>framebuffer vfunc table</dd>
<dt><code class="docutils literal"><span class="pre">pitches</span></code></dt>
<dd>Line stride per buffer. For userspace created object this
is copied from drm_mode_fb_cmd2.</dd>
<dt><code class="docutils literal"><span class="pre">offsets</span></code></dt>
<dd><p class="first">Offset from buffer start to the actual pixel data in bytes,
per buffer. For userspace created object this is copied from
drm_mode_fb_cmd2.</p>
<p>Note that this is a linear offset and does not take into account
tiling or buffer laytou per <strong>modifier</strong>. It meant to be used when the
actual pixel data for this framebuffer plane starts at an offset,
e.g.  when multiple planes are allocated within the same backing
storage buffer object. For tiled layouts this generally means it
<strong>offsets</strong> must at least be tile-size aligned, but hardware often has
stricter requirements.</p>
<p class="last">This should not be used to specifiy x/y pixel offsets into the buffer
data (even for linear buffers). Specifying an x/y pixel offset is
instead done through the source rectangle in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">modifier</span></code></dt>
<dd>Data layout modifier. This is used to describe
tiling, or also special layouts (like compression) of auxiliary
buffers. For userspace created object this is copied from
drm_mode_fb_cmd2.</dd>
<dt><code class="docutils literal"><span class="pre">width</span></code></dt>
<dd>Logical width of the visible area of the framebuffer, in
pixels.</dd>
<dt><code class="docutils literal"><span class="pre">height</span></code></dt>
<dd>Logical height of the visible area of the framebuffer, in
pixels.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>Framebuffer flags like DRM_MODE_FB_INTERLACED or
DRM_MODE_FB_MODIFIERS.</dd>
<dt><code class="docutils literal"><span class="pre">hot_x</span></code></dt>
<dd>X coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM_PLANE_TYPE_CURSOR
universal plane.</dd>
<dt><code class="docutils literal"><span class="pre">hot_y</span></code></dt>
<dd>Y coordinate of the cursor hotspot. Used by the legacy cursor
IOCTL when the driver supports cursor through a DRM_PLANE_TYPE_CURSOR
universal plane.</dd>
<dt><code class="docutils literal"><span class="pre">filp_head</span></code></dt>
<dd>Placed on <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.fbs</span></code></a>, protected by <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.fbs_lock</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">obj</span></code></dt>
<dd><p class="first">GEM objects backing the framebuffer, one per plane (optional).</p>
<p class="last">This is used by the GEM framebuffer helpers, see e.g.
<a class="reference internal" href="drm-kms-helpers.html#c.drm_gem_fb_create" title="drm_gem_fb_create"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_fb_create()</span></code></a>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the fb is refcounted for the benefit of driver internals,
for example some hw, disabling a CRTC/plane is asynchronous, and
scanout does not actually complete until the next vblank.  So some
cleanup (like releasing the reference(s) on the backing GEM bo(s))
should be deferred.  In cases like this, the driver would like to
hold a ref to the fb even though it has already been removed from
userspace perspective. See <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_get()</span></code></a> and
<a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a>.</p>
<p>The refcount is stored inside the mode object <strong>base</strong>.</p>
<dl class="function">
<dt id="c.drm_framebuffer_get">
void <code class="descname">drm_framebuffer_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the framebuffer&#8217;s reference count.</p>
<dl class="function">
<dt id="c.drm_framebuffer_put">
void <code class="descname">drm_framebuffer_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the framebuffer&#8217;s reference count and frees the
framebuffer if the reference count drops to zero.</p>
<dl class="function">
<dt id="c.drm_framebuffer_reference">
void <code class="descname">drm_framebuffer_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_framebuffer_get" title="drm_framebuffer_get"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_framebuffer_unreference">
void <code class="descname">drm_framebuffer_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_unreference" title="Permalink to this definition">¶</a></dt>
<dd><p>release a framebuffer reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>DRM framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_framebuffer_read_refcount">
uint32_t <code class="descname">drm_framebuffer_read_refcount</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_read_refcount" title="Permalink to this definition">¶</a></dt>
<dd><p>read the framebuffer reference count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions returns the framebuffer&#8217;s reference count.</p>
<dl class="function">
<dt id="c.drm_framebuffer_assign">
void <code class="descname">drm_framebuffer_assign</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> **<em>&nbsp;p</em>, struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>store a reference to the fb</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">**</span> <span class="pre">p</span></code></dt>
<dd>location to store framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>new framebuffer (maybe NULL)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions sets the location to store a reference to the framebuffer,
unreferencing the framebuffer that was previously stored in that location.</p>
<dl class="function">
<dt id="c.drm_framebuffer_init">
int <code class="descname">drm_framebuffer_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, const struct <a class="reference internal" href="#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs">drm_framebuffer_funcs</a> *<em>&nbsp;funcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a framebuffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to be initialized</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>... with these functions</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocates an ID for the framebuffer&#8217;s parent mode object, sets its mode
functions &amp; device file and adds it to the master fd list.</p>
<p>IMPORTANT:
This functions publishes the fb and makes it available for concurrent access
by other users. Which means by this point the fb _must_ be fully set up -
since all the fb attributes are invariant over its lifetime, no further
locking but only correct reference counting is required.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_framebuffer_lookup">
struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> * <code class="descname">drm_framebuffer_lookup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a drm framebuffer and grab a reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>id of the fb object</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, this grabs an additional reference to the framebuffer -
callers need to make sure to eventually unreference the returned framebuffer
again, using <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_framebuffer_unregister_private">
void <code class="descname">drm_framebuffer_unregister_private</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_unregister_private" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a private fb from the lookup idr</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>fb to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers need to call this when cleaning up driver-private framebuffers, e.g.
those used for fbdev. Note that the caller must hold a reference of it&#8217;s own,
i.e. the object may not be destroyed through this call (since it&#8217;ll lead to a
locking inversion).</p>
<p><strong>NOTE</strong></p>
<p>This function is deprecated. For driver-private framebuffers it is not
recommended to embed a framebuffer struct info fbdev struct, instead, a
framebuffer pointer is preferred and <a class="reference internal" href="#c.drm_framebuffer_put" title="drm_framebuffer_put"><code class="xref c c-func docutils literal"><span class="pre">drm_framebuffer_put()</span></code></a> should be called
when the framebuffer is to be cleaned up.</p>
<dl class="function">
<dt id="c.drm_framebuffer_cleanup">
void <code class="descname">drm_framebuffer_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a framebuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleanup framebuffer. This function is intended to be used from the drivers
<a class="reference internal" href="#c.drm_framebuffer_funcs" title="drm_framebuffer_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer_funcs.destroy</span></code></a> callback. It can also be used to clean up
driver private framebuffers embedded into a larger structure.</p>
<p>Note that this function does not remove the fb from active usage - if it is
still used anywhere, hilarity can ensue since userspace could call getfb on
the id and get back -EINVAL. Obviously no concern at driver unload time.</p>
<p>Also, the framebuffer will not be removed from the lookup idr - for
user-created framebuffers this will happen in in the rmfb ioctl. For
driver-private objects (e.g. for fbdev) drivers need to explicitly call
drm_framebuffer_unregister_private.</p>
<dl class="function">
<dt id="c.drm_framebuffer_remove">
void <code class="descname">drm_framebuffer_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>remove and unreference a framebuffer object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>framebuffer to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Scans all the CRTCs and planes in <strong>dev</strong>&#8216;s mode_config.  If they&#8217;re
using <strong>fb</strong>, removes it, setting it to NULL. Then drops the reference to the
passed-in framebuffer. Might take the modeset locks.</p>
<p>Note that this function optimizes the cleanup away if the caller holds the
last reference to the framebuffer. It is also guaranteed to not take the
modeset locks in this case.</p>
<dl class="function">
<dt id="c.drm_framebuffer_plane_width">
int <code class="descname">drm_framebuffer_plane_width</code><span class="sig-paren">(</span>int<em>&nbsp;width</em>, const struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_plane_width" title="Permalink to this definition">¶</a></dt>
<dd><p>width of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>width of the first plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of <strong>plane</strong>, given that the width of the first plane is <strong>width</strong>.</p>
<dl class="function">
<dt id="c.drm_framebuffer_plane_height">
int <code class="descname">drm_framebuffer_plane_height</code><span class="sig-paren">(</span>int<em>&nbsp;height</em>, const struct <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer">drm_framebuffer</a> *<em>&nbsp;fb</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_framebuffer_plane_height" title="Permalink to this definition">¶</a></dt>
<dd><p>height of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">height</span></code></dt>
<dd>height of the first plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_framebuffer</span> <span class="pre">*</span> <span class="pre">fb</span></code></dt>
<dd>the framebuffer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of <strong>plane</strong>, given that the height of the first plane is <strong>height</strong>.</p>
</div>
</div>
<div class="section" id="drm-format-handling">
<h2>DRM Format Handling<a class="headerlink" href="#drm-format-handling" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_format_info">
struct <code class="descname">drm_format_info</code><a class="headerlink" href="#c.drm_format_info" title="Permalink to this definition">¶</a></dt>
<dd><p>information about a DRM format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_format_info {
  u32 format;
  u8 depth;
  u8 num_planes;
  u8 cpp[3];
  u8 pixels_per_macropixel[3];
  u8 bytes_per_macropixel[3];
  u8 hsub;
  u8 vsub;
  bool has_alpha;
  bool is_yuv;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">format</span></code></dt>
<dd>4CC format identifier (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">depth</span></code></dt>
<dd>Color depth (number of bits per pixel excluding padding bits),
valid for a subset of RGB formats only. This is a legacy field, do not
use in new code and set to 0 for new formats.</dd>
<dt><code class="docutils literal"><span class="pre">num_planes</span></code></dt>
<dd>Number of color planes (1 to 3)</dd>
<dt><code class="docutils literal"><span class="pre">cpp</span></code></dt>
<dd>Number of bytes per pixel (per plane)</dd>
<dt><code class="docutils literal"><span class="pre">pixels_per_macropixel</span></code></dt>
<dd>Number of pixels per macro-pixel (per plane). A macro-pixel is
composed of multiple pixels, and there can be extra bits between
pixels. This must be used along with <strong>bytes_per_macropixel</strong>, only
when single pixel size is not byte-aligned. In this case, <strong>cpp</strong>
is not valid and should be 0.</dd>
<dt><code class="docutils literal"><span class="pre">bytes_per_macropixel</span></code></dt>
<dd>Number of bytes per macro-pixel (per plane). A macro-pixel is
composed of multiple pixels. The size of single macro-pixel should
be byte-aligned. This should be used with <strong>pixels_per_macropixel</strong>,
and <strong>cpp</strong> should be 0.</dd>
<dt><code class="docutils literal"><span class="pre">hsub</span></code></dt>
<dd>Horizontal chroma subsampling factor</dd>
<dt><code class="docutils literal"><span class="pre">vsub</span></code></dt>
<dd>Vertical chroma subsampling factor</dd>
<dt><code class="docutils literal"><span class="pre">has_alpha</span></code></dt>
<dd>Does the format embeds an alpha component?</dd>
<dt><code class="docutils literal"><span class="pre">is_yuv</span></code></dt>
<dd>Is it a YUV format?</dd>
</dl>
<dl class="type">
<dt id="c.drm_format_name_buf">
struct <code class="descname">drm_format_name_buf</code><a class="headerlink" href="#c.drm_format_name_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>name of a DRM format</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_format_name_buf {
  char str[32];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">str</span></code></dt>
<dd>string buffer containing the format name</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_legacy_fb_format">
uint32_t <code class="descname">drm_mode_legacy_fb_format</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;bpp</em>, uint32_t<em>&nbsp;depth</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_legacy_fb_format" title="Permalink to this definition">¶</a></dt>
<dd><p>compute drm fourcc code from legacy description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">bpp</span></code></dt>
<dd>bits per pixels</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">depth</span></code></dt>
<dd>bit depth per pixel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Computes a drm fourcc pixel format code for the given <strong>bpp</strong>/<strong>depth</strong> values.
Useful in fbdev emulation code, since that deals in those values.</p>
<dl class="function">
<dt id="c.drm_get_format_name">
const char * <code class="descname">drm_get_format_name</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em>, struct <a class="reference internal" href="#c.drm_format_name_buf" title="drm_format_name_buf">drm_format_name_buf</a> *<em>&nbsp;buf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_format_name" title="Permalink to this definition">¶</a></dt>
<dd><p>fill a string with a drm fourcc format&#8217;s name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>format to compute name of</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_format_name_buf</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>caller-supplied buffer</dd>
</dl>
<dl class="function">
<dt>
const struct <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> * <code class="descname">drm_format_info</code><span class="sig-paren">(</span>u32<em>&nbsp;format</em><span class="sig-paren">)</span></dt>
<dd><p>query information for a given format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller should only pass a supported pixel format to this function.
Unsupported pixel formats will generate a warning in the kernel log.</p>
<p><strong>Return</strong></p>
<p>The instance of struct drm_format_info that describes the pixel format, or
NULL if the format is unsupported.</p>
<dl class="function">
<dt id="c.drm_get_format_info">
const struct <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> * <code class="descname">drm_get_format_info</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, const struct drm_mode_fb_cmd2 *<em>&nbsp;mode_cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_format_info" title="Permalink to this definition">¶</a></dt>
<dd><p>query information for a given framebuffer configuration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_mode_fb_cmd2</span> <span class="pre">*</span> <span class="pre">mode_cmd</span></code></dt>
<dd>metadata from the userspace fb creation request</dd>
</dl>
<p><strong>Return</strong></p>
<p>The instance of struct drm_format_info that describes the pixel format, or
NULL if the format is unsupported.</p>
<dl class="function">
<dt id="c.drm_format_num_planes">
int <code class="descname">drm_format_num_planes</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_num_planes" title="Permalink to this definition">¶</a></dt>
<dd><p>get the number of planes for format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
</dl>
<p><strong>Return</strong></p>
<p>The number of planes used by the specified pixel format.</p>
<dl class="function">
<dt id="c.drm_format_plane_cpp">
int <code class="descname">drm_format_plane_cpp</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_plane_cpp" title="Permalink to this definition">¶</a></dt>
<dd><p>determine the bytes per pixel value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The bytes per pixel value for the specified plane.</p>
<dl class="function">
<dt id="c.drm_format_horz_chroma_subsampling">
int <code class="descname">drm_format_horz_chroma_subsampling</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_horz_chroma_subsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>get the horizontal chroma subsampling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
</dl>
<p><strong>Return</strong></p>
<p>The horizontal chroma subsampling factor for the
specified pixel format.</p>
<dl class="function">
<dt id="c.drm_format_vert_chroma_subsampling">
int <code class="descname">drm_format_vert_chroma_subsampling</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;format</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_vert_chroma_subsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>get the vertical chroma subsampling factor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format (DRM_FORMAT_*)</dd>
</dl>
<p><strong>Return</strong></p>
<p>The vertical chroma subsampling factor for the
specified pixel format.</p>
<dl class="function">
<dt id="c.drm_format_plane_width">
int <code class="descname">drm_format_plane_width</code><span class="sig-paren">(</span>int<em>&nbsp;width</em>, uint32_t<em>&nbsp;format</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_plane_width" title="Permalink to this definition">¶</a></dt>
<dd><p>width of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>width of the first plane</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The width of <strong>plane</strong>, given that the width of the first plane is <strong>width</strong>.</p>
<dl class="function">
<dt id="c.drm_format_plane_height">
int <code class="descname">drm_format_plane_height</code><span class="sig-paren">(</span>int<em>&nbsp;height</em>, uint32_t<em>&nbsp;format</em>, int<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_plane_height" title="Permalink to this definition">¶</a></dt>
<dd><p>height of the plane given the first plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">height</span></code></dt>
<dd>height of the first plane</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">format</span></code></dt>
<dd>pixel format</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
</dl>
<p><strong>Return</strong></p>
<p>The height of <strong>plane</strong>, given that the height of the first plane is <strong>height</strong>.</p>
<dl class="function">
<dt id="c.drm_format_plane_width_bytes">
int <code class="descname">drm_format_plane_width_bytes</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_format_info" title="drm_format_info">drm_format_info</a> *<em>&nbsp;info</em>, int<em>&nbsp;plane</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_format_plane_width_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>bytes of the given width of the plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_format_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>DRM format information</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>plane index</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>width to get the number of bytes</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns the number of bytes for given <strong>width</strong> and <strong>plane</strong>.
The <strong>cpp</strong> or macro pixel information should be valid.</p>
<p><strong>Return</strong></p>
<p>The bytes of <strong>width</strong> of <strong>plane</strong>. 0 for invalid format info.</p>
</div>
<div class="section" id="dumb-buffer-objects">
<h2>Dumb Buffer Objects<a class="headerlink" href="#dumb-buffer-objects" title="Permalink to this headline">¶</a></h2>
<p>The KMS API doesn&#8217;t standardize backing storage object creation and leaves it
to driver-specific ioctls. Furthermore actually creating a buffer object even
for GEM-based drivers is done through a driver-specific ioctl - GEM only has
a common userspace interface for sharing and destroying objects. While not an
issue for full-fledged graphics stacks that include device-specific userspace
components (in libdrm for instance), this limit makes DRM-based early boot
graphics unnecessarily complex.</p>
<p>Dumb objects partly alleviate the problem by providing a standard API to
create dumb buffers suitable for scanout, which can then be used to create
KMS frame buffers.</p>
<p>To support dumb objects drivers must implement the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_create</span></code></a>
operation. <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_destroy</span></code></a> defaults to <a class="reference internal" href="drm-mm.html#c.drm_gem_dumb_destroy" title="drm_gem_dumb_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_dumb_destroy()</span></code></a> if
not set and <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.dumb_map_offset</span></code></a> defaults to
<a class="reference internal" href="drm-mm.html#c.drm_gem_dumb_map_offset" title="drm_gem_dumb_map_offset"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_dumb_map_offset()</span></code></a>. See the callbacks for further details.</p>
<p>Note that dumb objects may not be used for gpu acceleration, as has been
attempted on some ARM embedded platforms. Such drivers really must have
a hardware-specific ioctl to allocate suitable buffer objects.</p>
</div>
<div class="section" id="plane-abstraction">
<h2>Plane Abstraction<a class="headerlink" href="#plane-abstraction" title="Permalink to this headline">¶</a></h2>
<p>A plane represents an image source that can be blended with or overlayed on
top of a CRTC during the scanout process. Planes take their input data from a
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> object. The plane itself specifies the cropping and scaling
of that image, and where it is placed on the visible are of a display
pipeline, represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>. A plane can also have additional
properties that specify how the pixels are positioned and blended, like
rotation or Z-position. All these properties are stored in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a>.</p>
<p>To create a plane, a KMS drivers allocates and zeroes an instances of
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span></code></a> (possibly as part of a larger structure) and registers it
with a call to <a class="reference internal" href="#c.drm_universal_plane_init" title="drm_universal_plane_init"><code class="xref c c-func docutils literal"><span class="pre">drm_universal_plane_init()</span></code></a>.</p>
<p>Cursor and overlay planes are optional. All drivers should provide one
primary plane per CRTC to avoid surprising userspace too much. See enum
drm_plane_type for a more in-depth discussion of these special uapi-relevant
plane types. Special planes are associated with their CRTC by calling
<a class="reference internal" href="#c.drm_crtc_init_with_planes" title="drm_crtc_init_with_planes"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init_with_planes()</span></code></a>.</p>
<p>The type of a plane is exposed in the immutable &#8220;type&#8221; enumeration property,
which has one of the following values: &#8220;Overlay&#8221;, &#8220;Primary&#8221;, &#8220;Cursor&#8221;.</p>
<div class="section" id="plane-functions-reference">
<h3>Plane Functions Reference<a class="headerlink" href="#plane-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_plane_state">
struct <code class="descname">drm_plane_state</code><a class="headerlink" href="#c.drm_plane_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable plane state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_plane_state {
  struct drm_plane *plane;
  struct drm_crtc *crtc;
  struct drm_framebuffer *fb;
  struct dma_fence *fence;
  int32_t crtc_x;
  int32_t crtc_y;
  uint32_t crtc_w, crtc_h;
  uint32_t src_x;
  uint32_t src_y;
  uint32_t src_h, src_w;
  u16 alpha;
  unsigned int rotation;
  unsigned int zpos;
  unsigned int normalized_zpos;
  enum drm_color_encoding color_encoding;
  enum drm_color_range color_range;
  struct drm_rect src, dst;
  bool visible;
  struct drm_crtc_commit *commit;
  struct drm_atomic_state *state;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>backpointer to the plane</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>Currently bound CRTC, NULL if disabled. Do not this write directly,
use <a class="reference internal" href="#c.drm_atomic_set_crtc_for_plane" title="drm_atomic_set_crtc_for_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_crtc_for_plane()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>Currently bound framebuffer. Do not write this directly, use
<a class="reference internal" href="#c.drm_atomic_set_fb_for_plane" title="drm_atomic_set_fb_for_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_fb_for_plane()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">fence</span></code></dt>
<dd><p class="first">Optional fence to wait for before scanning out <strong>fb</strong>. The core atomic
code will set this when userspace is using explicit fencing. Do not
write this directly for a driver&#8217;s implicit fence, use
<a class="reference internal" href="#c.drm_atomic_set_fence_for_plane" title="drm_atomic_set_fence_for_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></a> to ensure that an explicit fence is
preserved.</p>
<p class="last">Drivers should store any implicit fence in this from their
<a class="reference internal" href="drm-kms-helpers.html#c.drm_plane_helper_funcs" title="drm_plane_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_helper_funcs.prepare_fb</span></code></a> callback. See <a class="reference internal" href="drm-kms-helpers.html#c.drm_gem_fb_prepare_fb" title="drm_gem_fb_prepare_fb"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_fb_prepare_fb()</span></code></a>
and <a class="reference internal" href="drm-kms-helpers.html#c.drm_gem_fb_simple_display_pipe_prepare_fb" title="drm_gem_fb_simple_display_pipe_prepare_fb"><code class="xref c c-func docutils literal"><span class="pre">drm_gem_fb_simple_display_pipe_prepare_fb()</span></code></a> for suitable helpers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">crtc_x</span></code></dt>
<dd>Left position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_y</span></code></dt>
<dd>Upper position of visible portion of plane on crtc, signed dest
location allows it to be partially off screen.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_w</span></code></dt>
<dd>width of visible portion of plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">crtc_h</span></code></dt>
<dd>height of visible portion of plane on crtc</dd>
<dt><code class="docutils literal"><span class="pre">src_x</span></code></dt>
<dd>left position of visible portion of plane within plane (in
16.16 fixed point).</dd>
<dt><code class="docutils literal"><span class="pre">src_y</span></code></dt>
<dd>upper position of visible portion of plane within plane (in
16.16 fixed point).</dd>
<dt><code class="docutils literal"><span class="pre">src_h</span></code></dt>
<dd>height of visible portion of plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">src_w</span></code></dt>
<dd>width of visible portion of plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">alpha</span></code></dt>
<dd>Opacity of the plane with 0 as completely transparent and 0xffff as
completely opaque. See <a class="reference internal" href="#c.drm_plane_create_alpha_property" title="drm_plane_create_alpha_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_alpha_property()</span></code></a> for more
details.</dd>
<dt><code class="docutils literal"><span class="pre">rotation</span></code></dt>
<dd>Rotation of the plane. See <a class="reference internal" href="#c.drm_plane_create_rotation_property" title="drm_plane_create_rotation_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_rotation_property()</span></code></a> for
more details.</dd>
<dt><code class="docutils literal"><span class="pre">zpos</span></code></dt>
<dd><p class="first">Priority of the given plane on crtc (optional).</p>
<p>Note that multiple active planes on the same crtc can have an
identical zpos value. The rule to solving the conflict is to compare
the plane object IDs; the plane with a higher ID must be stacked on
top of a plane with a lower ID.</p>
<p class="last">See <a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_property()</span></code></a> and
<a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a> for more details.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">normalized_zpos</span></code></dt>
<dd>Normalized value of zpos: unique, range from 0 to N-1 where N is the
number of active planes for given crtc. Note that the driver must set
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.normalize_zpos</span></code></a> or call <a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_normalize_zpos()</span></code></a> to
update this before it can be trusted.</dd>
<dt><code class="docutils literal"><span class="pre">color_encoding</span></code></dt>
<dd>Color encoding for non RGB formats</dd>
<dt><code class="docutils literal"><span class="pre">color_range</span></code></dt>
<dd>Color range for non RGB formats</dd>
<dt><code class="docutils literal"><span class="pre">src</span></code></dt>
<dd>clipped source coordinates of the plane (in 16.16)</dd>
<dt><code class="docutils literal"><span class="pre">dst</span></code></dt>
<dd>clipped destination coordinates of the plane</dd>
<dt><code class="docutils literal"><span class="pre">visible</span></code></dt>
<dd>Visibility of the plane. This can be false even if fb!=NULL and
crtc!=NULL, due to clipping.</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd><p class="first">Tracks the pending commit to prevent use-after-free conditions,
and for async plane updates.</p>
<p class="last">May be NULL.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
</dl>
<p><strong>Description</strong></p>
<p>Please not that the destination coordinates <strong>crtc_x</strong>, <strong>crtc_y</strong>, <strong>crtc_h</strong> and
<strong>crtc_w</strong> and the source coordinates <strong>src_x</strong>, <strong>src_y</strong>, <strong>src_h</strong> and <strong>src_w</strong> are the
raw coordinates provided by userspace. Drivers should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_check_plane_state" title="drm_atomic_helper_check_plane_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_check_plane_state()</span></code></a> and only use the derived rectangles in
<strong>src</strong> and <strong>dst</strong> to program the hardware.</p>
<dl class="type">
<dt id="c.drm_plane_funcs">
struct <code class="descname">drm_plane_funcs</code><a class="headerlink" href="#c.drm_plane_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>driver plane control functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_plane_funcs {
  int (*update_plane)(struct drm_plane *plane,struct drm_crtc *crtc, struct drm_framebuffer *fb,int crtc_x, int crtc_y,unsigned int crtc_w, unsigned int crtc_h,uint32_t src_x, uint32_t src_y,uint32_t src_w, uint32_t src_h, struct drm_modeset_acquire_ctx *ctx);
  int (*disable_plane)(struct drm_plane *plane, struct drm_modeset_acquire_ctx *ctx);
  void (*destroy)(struct drm_plane *plane);
  void (*reset)(struct drm_plane *plane);
  int (*set_property)(struct drm_plane *plane, struct drm_property *property, uint64_t val);
  struct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane *plane);
  void (*atomic_destroy_state)(struct drm_plane *plane, struct drm_plane_state *state);
  int (*atomic_set_property)(struct drm_plane *plane,struct drm_plane_state *state,struct drm_property *property, uint64_t val);
  int (*atomic_get_property)(struct drm_plane *plane,const struct drm_plane_state *state,struct drm_property *property, uint64_t *val);
  int (*late_register)(struct drm_plane *plane);
  void (*early_unregister)(struct drm_plane *plane);
  void (*atomic_print_state)(struct drm_printer *p, const struct drm_plane_state *state);
  bool (*format_mod_supported)(struct drm_plane *plane, uint32_t format, uint64_t modifier);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">update_plane</span></code></dt>
<dd><p class="first">This is the legacy entry point to enable and configure the plane for
the given CRTC and framebuffer. It is never called to disable the
plane, i.e. the passed-in crtc and fb paramters are never NULL.</p>
<p>The source rectangle in frame buffer memory coordinates is given by
the src_x, src_y, src_w and src_h parameters (as 16.16 fixed point
values). Devices that don&#8217;t support subpixel plane coordinates can
ignore the fractional part.</p>
<p>The destination rectangle in CRTC coordinates is given by the
crtc_x, crtc_y, crtc_w and crtc_h parameters (as integer values).
Devices scale the source rectangle to the destination rectangle. If
scaling is not supported, and the source rectangle size doesn&#8217;t match
the destination rectangle size, the driver must return a
-&lt;errorname&gt;EINVAL&lt;/errorname&gt; error.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_plane" title="drm_atomic_helper_update_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_plane()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">disable_plane</span></code></dt>
<dd><p class="first">This is the legacy entry point to disable the plane. The DRM core
calls this method in response to a DRM_IOCTL_MODE_SETPLANE IOCTL call
with the frame buffer ID set to 0.  Disabled planes must not be
processed by the CRTC.</p>
<p>Drivers implementing atomic modeset should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a> to implement this hook.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up plane resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a> since a plane cannot be hotplugged
in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset plane hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_plane_reset" title="drm_atomic_helper_plane_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_plane_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
plane.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this plane and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>This callback is mandatory for atomic drivers.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_plane_duplicate_state" title="drm_atomic_helper_plane_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_plane_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_plane_duplicate_state" title="__drm_atomic_helper_plane_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_plane_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd><p class="first">Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</p>
<p class="last">This callback is mandatory for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_plane_set_property" title="drm_atomic_plane_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_set_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which shouldn&#8217;t ever happen, the core only
asks for properties attached to this plane). No other validation is
allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETPLANE IOCTL.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_plane_get_property" title="drm_atomic_plane_get_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_get_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which should never happen, the core only asks for
properties attached to this plane).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the plane like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the plane from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_plane_print_state()</span></code>
instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">format_mod_supported</span></code></dt>
<dd><p class="first">This optional hook is used for the DRM to determine if the given
format/modifier combination is valid for the plane. This allows the
DRM to generate the correct format bitmask (which formats apply to
which modifier), and to valdiate modifiers at atomic_check time.</p>
<p>If not present, then any modifier in the plane&#8217;s modifier
list is allowed with any of the plane&#8217;s formats.</p>
<p>Returns:</p>
<p class="last">True if the given modifier is valid for that format on the plane.
False otherwise.</p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_plane_type">
enum <code class="descname">drm_plane_type</code><a class="headerlink" href="#c.drm_plane_type" title="Permalink to this definition">¶</a></dt>
<dd><p>uapi plane type enumeration</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_OVERLAY</span></code></dt>
<dd>Overlay planes represent all non-primary, non-cursor planes. Some
drivers refer to these types of planes as &#8220;sprites&#8221; internally.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_PRIMARY</span></code></dt>
<dd>Primary planes represent a &#8220;main&#8221; plane for a CRTC.  Primary planes
are the planes operated upon by CRTC modesetting and flipping
operations described in the <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.page_flip</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.set_config</span></code></a> hooks.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_PLANE_TYPE_CURSOR</span></code></dt>
<dd>Cursor planes represent a &#8220;cursor&#8221; plane for a CRTC.  Cursor planes
are the planes operated upon by the DRM_IOCTL_MODE_CURSOR and
DRM_IOCTL_MODE_CURSOR2 IOCTLs.</dd>
</dl>
<p><strong>Description</strong></p>
<p>For historical reasons not all planes are made the same. This enumeration is
used to tell the different types of planes apart to implement the different
uapi semantics for them. For userspace which is universal plane aware and
which is using that atomic IOCTL there&#8217;s no difference between these planes
(beyong what the driver and hardware can support of course).</p>
<p>For compatibility with legacy userspace, only overlay planes are made
available to userspace by default. Userspace clients may set the
DRM_CLIENT_CAP_UNIVERSAL_PLANES client capability bit to indicate that they
wish to receive a universal plane list containing all plane types. See also
<a class="reference internal" href="#c.drm_for_each_legacy_plane" title="drm_for_each_legacy_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_legacy_plane()</span></code></a>.</p>
<p>WARNING: The values of this enum is UABI since they&#8217;re exposed in the &#8220;type&#8221;
property.</p>
<dl class="type">
<dt id="c.drm_plane">
struct <code class="descname">drm_plane</code><a class="headerlink" href="#c.drm_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM plane control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_plane {
  struct drm_device *dev;
  struct list_head head;
  char *name;
  struct drm_modeset_lock mutex;
  struct drm_mode_object base;
  uint32_t possible_crtcs;
  uint32_t *format_types;
  unsigned int format_count;
  bool format_default;
  uint64_t *modifiers;
  unsigned int modifier_count;
  struct drm_crtc *crtc;
  struct drm_framebuffer *fb;
  struct drm_framebuffer *old_fb;
  const struct drm_plane_funcs *funcs;
  struct drm_object_properties properties;
  enum drm_plane_type type;
  unsigned index;
  const struct drm_plane_helper_funcs *helper_private;
  struct drm_plane_state *state;
  struct drm_property *alpha_property;
  struct drm_property *zpos_property;
  struct drm_property *rotation_property;
  struct drm_property *color_encoding_property;
  struct drm_property *color_range_property;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device this plane belongs to</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>List of all planes on <strong>dev</strong>, linked from <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.plane_list</span></code></a>.
Invariant over the lifetime of <strong>dev</strong> and therefore does not need
locking.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd><p class="first">Protects modeset plane state, together with the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc.mutex</span></code></a> of
CRTC this plane is linked to (when active, getting activated or
getting disabled).</p>
<p class="last">For atomic drivers specifically this protects <strong>state</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base mode object</dd>
<dt><code class="docutils literal"><span class="pre">possible_crtcs</span></code></dt>
<dd>pipes this plane can be bound to constructed from
<a class="reference internal" href="#c.drm_crtc_mask" title="drm_crtc_mask"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_mask()</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">format_types</span></code></dt>
<dd>array of formats supported by this plane</dd>
<dt><code class="docutils literal"><span class="pre">format_count</span></code></dt>
<dd>Size of the array pointed at by <strong>format_types</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">format_default</span></code></dt>
<dd>driver hasn&#8217;t supplied supported formats for the
plane. Used by the drm_plane_init compatibility wrapper only.</dd>
<dt><code class="docutils literal"><span class="pre">modifiers</span></code></dt>
<dd>array of modifiers supported by this plane</dd>
<dt><code class="docutils literal"><span class="pre">modifier_count</span></code></dt>
<dd>Size of the array pointed at by <strong>modifier_count</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>Currently bound CRTC, only meaningful for non-atomic drivers. For
atomic drivers this is forced to be NULL, atomic drivers should
instead check <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.crtc</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">fb</span></code></dt>
<dd>Currently bound framebuffer, only meaningful for non-atomic drivers.
For atomic drivers this is forced to be NULL, atomic drivers should
instead check <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.fb</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">old_fb</span></code></dt>
<dd>Temporary tracking of the old fb while a modeset is ongoing. Only
used by non-atomic drivers, forced to be NULL for atomic drivers.</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>plane control functions</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this plane</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Type of plane, see <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">drm_plane_type</span></code></a> for details.</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the plane.</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this plane.</p>
<p class="last">This is protected by <strong>mutex</strong>. Note that nonblocking atomic commits
access the current plane state without taking locks. Either by going
through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a> pointers, see
<a class="reference internal" href="#c.for_each_oldnew_plane_in_state" title="for_each_oldnew_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_plane_in_state()</span></code></a>, <a class="reference internal" href="#c.for_each_old_plane_in_state" title="for_each_old_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_plane_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_plane_in_state" title="for_each_new_plane_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_plane_in_state()</span></code></a>. Or through careful ordering of atomic
commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">alpha_property</span></code></dt>
<dd>Optional alpha property for this plane. See
<a class="reference internal" href="#c.drm_plane_create_alpha_property" title="drm_plane_create_alpha_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_alpha_property()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">zpos_property</span></code></dt>
<dd>Optional zpos property for this plane. See
<a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_property()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">rotation_property</span></code></dt>
<dd>Optional rotation property for this plane. See
<a class="reference internal" href="#c.drm_plane_create_rotation_property" title="drm_plane_create_rotation_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_rotation_property()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">color_encoding_property</span></code></dt>
<dd>Optional &#8220;COLOR_ENCODING&#8221; enum property for specifying
color encoding for non RGB formats.
See <a class="reference internal" href="#c.drm_plane_create_color_properties" title="drm_plane_create_color_properties"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_color_properties()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">color_range_property</span></code></dt>
<dd>Optional &#8220;COLOR_RANGE&#8221; enum property for specifying
color range for non RGB formats.
See <a class="reference internal" href="#c.drm_plane_create_color_properties" title="drm_plane_create_color_properties"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_color_properties()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Planes represent the scanout hardware of a display block. They receive their
input data from a <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> and feed it to a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>. Planes control
the color conversion, see <a class="reference internal" href="#plane-composition-properties">Plane Composition Properties</a> for more details,
and are also involved in the color conversion of input pixels, see <a class="reference internal" href="#color-management-properties">Color
Management Properties</a> for details on that.</p>
<dl class="function">
<dt id="c.drm_plane_index">
unsigned int <code class="descname">drm_plane_index</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered plane, return the index of that plane within a DRM
device&#8217;s list of planes.</p>
<dl class="function">
<dt id="c.drm_plane_mask">
u32 <code class="descname">drm_plane_mask</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>find the mask of a registered plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to find mask for</dd>
</dl>
<dl class="function">
<dt id="c.drm_plane_find">
struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> * <code class="descname">drm_plane_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>plane id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the plane with <strong>id</strong>, NULL if it doesn&#8217;t exist. Simple wrapper around
<a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_plane_mask">
<code class="descname">drm_for_each_plane_mask</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em>, <em>plane_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_plane_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over planes specified by bitmask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">plane_mask</span></code></dt>
<dd>bitmask of plane indices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all planes specified by bitmask.</p>
<dl class="function">
<dt id="c.drm_for_each_legacy_plane">
<code class="descname">drm_for_each_legacy_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_legacy_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes for legacy userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all legacy planes of <strong>dev</strong>, excluding primary and cursor planes.
This is useful for implementing userspace apis when userspace is not
universal plane aware. See also <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">drm_plane_type</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_plane">
<code class="descname">drm_for_each_plane</code><span class="sig-paren">(</span><em>plane</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all planes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">plane</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all planes of <strong>dev</strong>, include primary and cursor planes.</p>
<dl class="function">
<dt id="c.drm_universal_plane_init">
int <code class="descname">drm_universal_plane_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, uint32_t<em>&nbsp;possible_crtcs</em>, const struct <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs">drm_plane_funcs</a> *<em>&nbsp;funcs</em>, const uint32_t *<em>&nbsp;formats</em>, unsigned int<em>&nbsp;format_count</em>, const uint64_t *<em>&nbsp;format_modifiers</em>, enum <a class="reference internal" href="#c.drm_plane_type" title="drm_plane_type">drm_plane_type</a><em>&nbsp;type</em>, const char *<em>&nbsp;name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_universal_plane_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a new universal plane object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object to init</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">possible_crtcs</span></code></dt>
<dd>bitmask of possible CRTCs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for the new plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt>
<dd>array of supported formats (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt>
<dd>number of elements in <strong>formats</strong></dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint64_t</span> <span class="pre">*</span> <span class="pre">format_modifiers</span></code></dt>
<dd>array of struct drm_format modifiers terminated by
DRM_FORMAT_MOD_INVALID</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_plane_type</span> <span class="pre">type</span></code></dt>
<dd>type of plane (overlay, primary, cursor)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>printf style format string for the plane name, or NULL for default name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initializes a plane object of type <strong>type</strong>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_plane_init">
int <code class="descname">drm_plane_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, uint32_t<em>&nbsp;possible_crtcs</em>, const struct <a class="reference internal" href="#c.drm_plane_funcs" title="drm_plane_funcs">drm_plane_funcs</a> *<em>&nbsp;funcs</em>, const uint32_t *<em>&nbsp;formats</em>, unsigned int<em>&nbsp;format_count</em>, bool<em>&nbsp;is_primary</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a legacy plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object to init</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">possible_crtcs</span></code></dt>
<dd>bitmask of possible CRTCs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_plane_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for the new plane</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">uint32_t</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt>
<dd>array of supported formats (DRM_FORMAT_*)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">format_count</span></code></dt>
<dd>number of elements in <strong>formats</strong></dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">is_primary</span></code></dt>
<dd>plane type (primary vs overlay)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Legacy API to initialize a DRM plane.</p>
<p>New drivers should call <a class="reference internal" href="#c.drm_universal_plane_init" title="drm_universal_plane_init"><code class="xref c c-func docutils literal"><span class="pre">drm_universal_plane_init()</span></code></a> instead.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_plane_cleanup">
void <code class="descname">drm_plane_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up the core plane usage</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function cleans up <strong>plane</strong> and removes it from the DRM mode setting
core. Note that the function does <em>not</em> free the plane structure itself,
this is the responsibility of the caller.</p>
<dl class="function">
<dt id="c.drm_plane_from_index">
struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> * <code class="descname">drm_plane_from_index</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;idx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_from_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the registered plane at an index</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>index of registered plane to find for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a plane index, return the registered plane from DRM device&#8217;s
list of planes with matching index. This is the inverse of <a class="reference internal" href="#c.drm_plane_index" title="drm_plane_index"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_index()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_plane_force_disable">
void <code class="descname">drm_plane_force_disable</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_force_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Forcibly disable a plane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane to disable</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces the plane to be disabled.</p>
<p>Used when the plane&#8217;s current framebuffer is destroyed,
and when restoring fbdev mode.</p>
<p>Note that this function is not suitable for atomic drivers, since it doesn&#8217;t
wire through the lock acquisition context properly and hence can&#8217;t handle
retries or driver private locks. You probably want to use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_plane" title="drm_atomic_helper_disable_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_plane()</span></code></a> or
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_disable_planes_on_crtc" title="drm_atomic_helper_disable_planes_on_crtc"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_disable_planes_on_crtc()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.drm_mode_plane_set_obj_prop">
int <code class="descname">drm_mode_plane_set_obj_prop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_plane_set_obj_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>set the value of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane object to set property value for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to set</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">value</span></code></dt>
<dd>value the property should be set to</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions sets a given property on a given plane object. This function
calls the driver&#8217;s -&gt;set_property callback and changes the software state of
the property if the callback succeeds.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
</div>
</div>
<div class="section" id="display-modes-function-reference">
<h2>Display Modes Function Reference<a class="headerlink" href="#display-modes-function-reference" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.drm_mode_status">
enum <code class="descname">drm_mode_status</code><a class="headerlink" href="#c.drm_mode_status" title="Permalink to this definition">¶</a></dt>
<dd><p>hardware support status of a mode</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MODE_OK</span></code></dt>
<dd>Mode OK</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC</span></code></dt>
<dd>hsync out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC</span></code></dt>
<dd>vsync out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_H_ILLEGAL</span></code></dt>
<dd>mode has illegal horizontal timings</dd>
<dt><code class="docutils literal"><span class="pre">MODE_V_ILLEGAL</span></code></dt>
<dd>mode has illegal horizontal timings</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_WIDTH</span></code></dt>
<dd>requires an unsupported linepitch</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NOMODE</span></code></dt>
<dd>no mode with a matching name</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_INTERLACE</span></code></dt>
<dd>interlaced mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_DBLESCAN</span></code></dt>
<dd>doublescan mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_VSCAN</span></code></dt>
<dd>multiscan mode not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_MEM</span></code></dt>
<dd>insufficient video memory</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VIRTUAL_X</span></code></dt>
<dd>mode width too large for specified virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VIRTUAL_Y</span></code></dt>
<dd>mode height too large for specified virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_MEM_VIRT</span></code></dt>
<dd>insufficient video memory given virtual size</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NOCLOCK</span></code></dt>
<dd>no fixed clock available</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_HIGH</span></code></dt>
<dd>clock required is too high</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_LOW</span></code></dt>
<dd>clock required is too low</dd>
<dt><code class="docutils literal"><span class="pre">MODE_CLOCK_RANGE</span></code></dt>
<dd>clock/mode isn&#8217;t in a ClockRange</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_HVALUE</span></code></dt>
<dd>horizontal timing was out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_VVALUE</span></code></dt>
<dd>vertical timing was out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD_VSCAN</span></code></dt>
<dd>VScan value out of range</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC_NARROW</span></code></dt>
<dd>horizontal sync too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HSYNC_WIDE</span></code></dt>
<dd>horizontal sync too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HBLANK_NARROW</span></code></dt>
<dd>horizontal blanking too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_HBLANK_WIDE</span></code></dt>
<dd>horizontal blanking too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC_NARROW</span></code></dt>
<dd>vertical sync too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VSYNC_WIDE</span></code></dt>
<dd>vertical sync too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VBLANK_NARROW</span></code></dt>
<dd>vertical blanking too narrow</dd>
<dt><code class="docutils literal"><span class="pre">MODE_VBLANK_WIDE</span></code></dt>
<dd>vertical blanking too wide</dd>
<dt><code class="docutils literal"><span class="pre">MODE_PANEL</span></code></dt>
<dd>exceeds panel dimensions</dd>
<dt><code class="docutils literal"><span class="pre">MODE_INTERLACE_WIDTH</span></code></dt>
<dd>width too large for interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_WIDTH</span></code></dt>
<dd>only one width is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_HEIGHT</span></code></dt>
<dd>only one height is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ONE_SIZE</span></code></dt>
<dd>only one resolution is supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_REDUCED</span></code></dt>
<dd>monitor doesn&#8217;t accept reduced blanking</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_STEREO</span></code></dt>
<dd>stereo modes not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_NO_420</span></code></dt>
<dd>ycbcr 420 modes not supported</dd>
<dt><code class="docutils literal"><span class="pre">MODE_STALE</span></code></dt>
<dd>mode has become stale</dd>
<dt><code class="docutils literal"><span class="pre">MODE_BAD</span></code></dt>
<dd>unspecified reason</dd>
<dt><code class="docutils literal"><span class="pre">MODE_ERROR</span></code></dt>
<dd>error condition</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to filter out modes not supported by the driver/hardware
combination.</p>
<dl class="type">
<dt id="c.drm_display_mode">
struct <code class="descname">drm_display_mode</code><a class="headerlink" href="#c.drm_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>DRM kernel-internal display mode structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_display_mode {
  struct list_head head;
  struct drm_mode_object base;
  char name[DRM_DISPLAY_MODE_LEN];
  enum drm_mode_status status;
  unsigned int type;
  int clock;
  int hdisplay;
  int hsync_start;
  int hsync_end;
  int htotal;
  int hskew;
  int vdisplay;
  int vsync_start;
  int vsync_end;
  int vtotal;
  int vscan;
  unsigned int flags;
  int width_mm;
  int height_mm;
  int crtc_clock;
  int crtc_hdisplay;
  int crtc_hblank_start;
  int crtc_hblank_end;
  int crtc_hsync_start;
  int crtc_hsync_end;
  int crtc_htotal;
  int crtc_hskew;
  int crtc_vdisplay;
  int crtc_vblank_start;
  int crtc_vblank_end;
  int crtc_vsync_start;
  int crtc_vsync_end;
  int crtc_vtotal;
  int *private;
  int private_flags;
  int vrefresh;
  int hsync;
  enum hdmi_picture_aspect picture_aspect_ratio;
  struct list_head export_head;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>struct list_head for mode lists.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd><p class="first">A display mode is a normal modeset object, possibly including public
userspace id.</p>
<p>FIXME:</p>
<p class="last">This can probably be removed since the entire concept of userspace
managing modes explicitly has never landed in upstream kernel mode
setting support.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Human-readable name of the mode, filled out with <a class="reference internal" href="#c.drm_mode_set_name" title="drm_mode_set_name"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_set_name()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>Status of the mode, used to filter out modes not supported by the
hardware. See enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_status</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd><p class="first">A bitmask of flags, mostly about the source of a mode. Possible flags
are:</p>
<blockquote>
<div><ul class="simple">
<li>DRM_MODE_TYPE_PREFERRED: Preferred mode, usually the native
resolution of an LCD panel. There should only be one preferred
mode per connector at any given time.</li>
<li>DRM_MODE_TYPE_DRIVER: Mode created by the driver, which is all of
them really. Drivers must set this bit for all modes they create
and expose to userspace.</li>
<li>DRM_MODE_TYPE_USERDEF: Mode defined via kernel command line</li>
</ul>
</div></blockquote>
<p>Plus a big list of flags which shouldn&#8217;t be used at all, but are
still around since these flags are also used in the userspace ABI.
We no longer accept modes with these types though:</p>
<blockquote class="last">
<div><ul class="simple">
<li>DRM_MODE_TYPE_BUILTIN: Meant for hard-coded modes, unused.
Use DRM_MODE_TYPE_DRIVER instead.</li>
<li>DRM_MODE_TYPE_DEFAULT: Again a leftover, use
DRM_MODE_TYPE_PREFERRED instead.</li>
<li>DRM_MODE_TYPE_CLOCK_C and DRM_MODE_TYPE_CRTC_C: Define leftovers
which are stuck around for hysterical raisins only. No one has an
idea what they were meant for. Don&#8217;t use.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">clock</span></code></dt>
<dd>Pixel clock in kHz.</dd>
<dt><code class="docutils literal"><span class="pre">hdisplay</span></code></dt>
<dd>horizontal display size</dd>
<dt><code class="docutils literal"><span class="pre">hsync_start</span></code></dt>
<dd>horizontal sync start</dd>
<dt><code class="docutils literal"><span class="pre">hsync_end</span></code></dt>
<dd>horizontal sync end</dd>
<dt><code class="docutils literal"><span class="pre">htotal</span></code></dt>
<dd>horizontal total size</dd>
<dt><code class="docutils literal"><span class="pre">hskew</span></code></dt>
<dd>horizontal skew?!</dd>
<dt><code class="docutils literal"><span class="pre">vdisplay</span></code></dt>
<dd>vertical display size</dd>
<dt><code class="docutils literal"><span class="pre">vsync_start</span></code></dt>
<dd>vertical sync start</dd>
<dt><code class="docutils literal"><span class="pre">vsync_end</span></code></dt>
<dd>vertical sync end</dd>
<dt><code class="docutils literal"><span class="pre">vtotal</span></code></dt>
<dd>vertical total size</dd>
<dt><code class="docutils literal"><span class="pre">vscan</span></code></dt>
<dd>vertical scan?!</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd><p class="first">Sync and timing flags:</p>
<blockquote>
<div><ul class="simple">
<li>DRM_MODE_FLAG_PHSYNC: horizontal sync is active high.</li>
<li>DRM_MODE_FLAG_NHSYNC: horizontal sync is active low.</li>
<li>DRM_MODE_FLAG_PVSYNC: vertical sync is active high.</li>
<li>DRM_MODE_FLAG_NVSYNC: vertical sync is active low.</li>
<li>DRM_MODE_FLAG_INTERLACE: mode is interlaced.</li>
<li>DRM_MODE_FLAG_DBLSCAN: mode uses doublescan.</li>
<li>DRM_MODE_FLAG_CSYNC: mode uses composite sync.</li>
<li>DRM_MODE_FLAG_PCSYNC: composite sync is active high.</li>
<li>DRM_MODE_FLAG_NCSYNC: composite sync is active low.</li>
<li>DRM_MODE_FLAG_HSKEW: hskew provided (not used?).</li>
<li>DRM_MODE_FLAG_BCAST: &lt;deprecated&gt;</li>
<li>DRM_MODE_FLAG_PIXMUX: &lt;deprecated&gt;</li>
<li>DRM_MODE_FLAG_DBLCLK: double-clocked mode.</li>
<li>DRM_MODE_FLAG_CLKDIV2: half-clocked mode.</li>
</ul>
</div></blockquote>
<p>Additionally there&#8217;s flags to specify how 3D modes are packed:</p>
<blockquote class="last">
<div><ul class="simple">
<li>DRM_MODE_FLAG_3D_NONE: normal, non-3D mode.</li>
<li>DRM_MODE_FLAG_3D_FRAME_PACKING: 2 full frames for left and right.</li>
<li>DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: interleaved like fields.</li>
<li>DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: interleaved lines.</li>
<li>DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: side-by-side full frames.</li>
<li>DRM_MODE_FLAG_3D_L_DEPTH: ?</li>
<li>DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: ?</li>
<li>DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: frame split into top and bottom
parts.</li>
<li>DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: frame split into left and
right parts.</li>
</ul>
</div></blockquote>
</dd>
<dt><code class="docutils literal"><span class="pre">width_mm</span></code></dt>
<dd>Addressable size of the output in mm, projectors should set this to
0.</dd>
<dt><code class="docutils literal"><span class="pre">height_mm</span></code></dt>
<dd>Addressable size of the output in mm, projectors should set this to
0.</dd>
<dt><code class="docutils literal"><span class="pre">crtc_clock</span></code></dt>
<dd><p class="first">Actual pixel or dot clock in the hardware. This differs from the
logical <strong>clock</strong> when e.g. using interlacing, double-clocking, stereo
modes or other fancy stuff that changes the timings and signals
actually sent over the wire.</p>
<p>This is again in kHz.</p>
<p class="last">Note that with digital outputs like HDMI or DP there&#8217;s usually a
massive confusion between the dot clock and the signal clock at the
bit encoding level. Especially when a 8b/10b encoding is used and the
difference is exactly a factor of 10.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hdisplay</span></code></dt>
<dd>hardware mode horizontal display size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hblank_start</span></code></dt>
<dd>hardware mode horizontal blank start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hblank_end</span></code></dt>
<dd>hardware mode horizontal blank end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hsync_start</span></code></dt>
<dd>hardware mode horizontal sync start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hsync_end</span></code></dt>
<dd>hardware mode horizontal sync end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_htotal</span></code></dt>
<dd>hardware mode horizontal total size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_hskew</span></code></dt>
<dd>hardware mode horizontal skew?!</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vdisplay</span></code></dt>
<dd>hardware mode vertical display size</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vblank_start</span></code></dt>
<dd>hardware mode vertical blank start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vblank_end</span></code></dt>
<dd>hardware mode vertical blank end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vsync_start</span></code></dt>
<dd>hardware mode vertical sync start</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vsync_end</span></code></dt>
<dd>hardware mode vertical sync end</dd>
<dt><code class="docutils literal"><span class="pre">crtc_vtotal</span></code></dt>
<dd>hardware mode vertical total size</dd>
<dt><code class="docutils literal"><span class="pre">private</span></code></dt>
<dd>Pointer for driver private data. This can only be used for mode
objects passed to drivers in modeset operations. It shouldn&#8217;t be used
by atomic drivers since they can store any additional data by
subclassing state structures.</dd>
<dt><code class="docutils literal"><span class="pre">private_flags</span></code></dt>
<dd>Similar to <strong>private</strong>, but just an integer.</dd>
<dt><code class="docutils literal"><span class="pre">vrefresh</span></code></dt>
<dd><p class="first">Vertical refresh rate, for debug output in human readable form. Not
used in a functional way.</p>
<p class="last">This value is in Hz.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">hsync</span></code></dt>
<dd><p class="first">Horizontal refresh rate, for debug output in human readable form. Not
used in a functional way.</p>
<p class="last">This value is in kHz.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">picture_aspect_ratio</span></code></dt>
<dd>Field for setting the HDMI picture aspect ratio of a mode.</dd>
<dt><code class="docutils literal"><span class="pre">export_head</span></code></dt>
<dd>struct list_head for modes to be exposed to the userspace.
This is to maintain a list of exposed modes while preparing
user-mode&#8217;s list in drm_mode_getconnector ioctl. The purpose of this
list_head only lies in the ioctl function, and is not expected to be
used outside the function.
Once used, the stale pointers are not reset, but left as it is, to
avoid overhead of protecting it by mode_config.mutex.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The horizontal and vertical timings are defined per the following diagram.</p>
<div class="highlight-none"><div class="highlight"><pre>          Active                 Front           Sync           Back
         Region                 Porch                          Porch
&lt;-----------------------&gt;&lt;----------------&gt;&lt;-------------&gt;&lt;--------------&gt;
  //////////////////////|
 ////////////////////// |
//////////////////////  |..................               ................
                                           _______________
&lt;----- [hv]display -----&gt;
&lt;------------- [hv]sync_start ------------&gt;
&lt;--------------------- [hv]sync_end ---------------------&gt;
&lt;-------------------------------- [hv]total -----------------------------&gt;*
</pre></div>
</div>
<p>This structure contains two copies of timings. First are the plain timings,
which specify the logical mode, as it would be for a progressive 1:1 scanout
at the refresh rate userspace can observe through vblank timestamps. Then
there&#8217;s the hardware timings, which are corrected for interlacing,
double-clocking and similar things. They are provided as a convenience, and
can be appropriately computed using <a class="reference internal" href="#c.drm_mode_set_crtcinfo" title="drm_mode_set_crtcinfo"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_set_crtcinfo()</span></code></a>.</p>
<p>For printing you can use <code class="docutils literal"><span class="pre">DRM_MODE_FMT</span></code> and <a class="reference internal" href="#c.DRM_MODE_ARG" title="DRM_MODE_ARG"><code class="xref c c-func docutils literal"><span class="pre">DRM_MODE_ARG()</span></code></a>.</p>
<dl class="function">
<dt id="c.DRM_MODE_FMT">
<code class="descname">DRM_MODE_FMT</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_FMT" title="Permalink to this definition">¶</a></dt>
<dd><p>printf string for <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="function">
<dt id="c.DRM_MODE_ARG">
<code class="descname">DRM_MODE_ARG</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DRM_MODE_ARG" title="Permalink to this definition">¶</a></dt>
<dd><p>printf arguments for <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">m</span></code></dt>
<dd>display mode</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_is_stereo">
bool <code class="descname">drm_mode_is_stereo</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_stereo" title="Permalink to this definition">¶</a></dt>
<dd><p>check for stereo mode flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>drm_display_mode to check</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if the mode is one of the stereo modes (like side-by-side), false if
not.</p>
<dl class="function">
<dt id="c.drm_mode_debug_printmodeline">
void <code class="descname">drm_mode_debug_printmodeline</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_debug_printmodeline" title="Permalink to this definition">¶</a></dt>
<dd><p>print a mode to dmesg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to print</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describe <strong>mode</strong> using DRM_DEBUG.</p>
<dl class="function">
<dt id="c.drm_mode_create">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_mode_create</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a new, cleared drm_display_mode with kzalloc, allocate an ID for it
and return it.</p>
<p><strong>Return</strong></p>
<p>Pointer to new mode on success, NULL on error.</p>
<dl class="function">
<dt id="c.drm_mode_destroy">
void <code class="descname">drm_mode_destroy</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release <strong>mode</strong>&#8216;s unique ID, then free it <strong>mode</strong> structure itself using kfree.</p>
<dl class="function">
<dt id="c.drm_mode_probed_add">
void <code class="descname">drm_mode_probed_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_probed_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add a mode to a connector&#8217;s probed_mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector the new mode</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add <strong>mode</strong> to <strong>connector</strong>&#8216;s probed_mode list for later use. This list should
then in a second step get filtered and all the modes actually supported by
the hardware moved to the <strong>connector</strong>&#8216;s modes list.</p>
<dl class="function">
<dt id="c.drm_cvt_mode">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_cvt_mode</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;hdisplay</em>, int<em>&nbsp;vdisplay</em>, int<em>&nbsp;vrefresh</em>, bool<em>&nbsp;reduced</em>, bool<em>&nbsp;interlaced</em>, bool<em>&nbsp;margins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_cvt_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>create a modeline based on the CVT algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt>
<dd>hdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt>
<dd>vdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt>
<dd>vrefresh rate</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">reduced</span></code></dt>
<dd>whether to use reduced blanking</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt>
<dd>whether to compute an interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">margins</span></code></dt>
<dd>whether to add margins (borders)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is called to generate the modeline based on CVT algorithm
according to the hdisplay, vdisplay, vrefresh.
It is based from the VESA(TM) Coordinated Video Timing Generator by
Graham Loveridge April 9, 2003 available at
<a class="reference external" href="http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls">http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls</a></p>
<p>And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
What I have done is to translate it by using integer calculation.</p>
<p><strong>Return</strong></p>
<p>The modeline based on the CVT algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="function">
<dt id="c.drm_gtf_mode_complex">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_gtf_mode_complex</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;hdisplay</em>, int<em>&nbsp;vdisplay</em>, int<em>&nbsp;vrefresh</em>, bool<em>&nbsp;interlaced</em>, int<em>&nbsp;margins</em>, int<em>&nbsp;GTF_M</em>, int<em>&nbsp;GTF_2C</em>, int<em>&nbsp;GTF_K</em>, int<em>&nbsp;GTF_2J</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gtf_mode_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>create the modeline based on the full GTF algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt>
<dd>hdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt>
<dd>vdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt>
<dd>vrefresh rate.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt>
<dd>whether to compute an interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">margins</span></code></dt>
<dd>desired margin (borders) size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">GTF_M</span></code></dt>
<dd>extended GTF formula parameters</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">GTF_2C</span></code></dt>
<dd>extended GTF formula parameters</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">GTF_K</span></code></dt>
<dd>extended GTF formula parameters</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">GTF_2J</span></code></dt>
<dd>extended GTF formula parameters</dd>
</dl>
<p><strong>Description</strong></p>
<p>GTF feature blocks specify C and J in multiples of 0.5, so we pass them
in here multiplied by two.  For a C of 40, pass in 80.</p>
<p><strong>Return</strong></p>
<p>The modeline based on the full GTF algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="function">
<dt id="c.drm_gtf_mode">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_gtf_mode</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, int<em>&nbsp;hdisplay</em>, int<em>&nbsp;vdisplay</em>, int<em>&nbsp;vrefresh</em>, bool<em>&nbsp;interlaced</em>, int<em>&nbsp;margins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_gtf_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>create the modeline based on the GTF algorithm</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">hdisplay</span></code></dt>
<dd>hdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vdisplay</span></code></dt>
<dd>vdisplay size</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">vrefresh</span></code></dt>
<dd>vrefresh rate.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">interlaced</span></code></dt>
<dd>whether to compute an interlaced mode</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">margins</span></code></dt>
<dd>desired margin (borders) size</dd>
</dl>
<p><strong>Description</strong></p>
<p>return the modeline based on GTF algorithm</p>
<p>This function is to create the modeline based on the GTF algorithm.
Generalized Timing Formula is derived from:</p>
<blockquote>
<div>GTF Spreadsheet by Andy Morrish (1/5/97)
available at <a class="reference external" href="http://www.vesa.org">http://www.vesa.org</a></div></blockquote>
<p>And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.
What I have done is to translate it by using integer calculation.
I also refer to the function of fb_get_mode in the file of
drivers/video/fbmon.c</p>
<p>Standard GTF parameters:</p>
<div class="highlight-none"><div class="highlight"><pre>M = 600
C = 40
K = 128
J = 20
</pre></div>
</div>
<p><strong>Return</strong></p>
<p>The modeline based on the GTF algorithm stored in a drm_display_mode object.
The display mode object is allocated with <a class="reference internal" href="#c.drm_mode_create" title="drm_mode_create"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create()</span></code></a>. Returns NULL
when no mode could be allocated.</p>
<dl class="function">
<dt id="c.drm_display_mode_from_videomode">
void <code class="descname">drm_display_mode_from_videomode</code><span class="sig-paren">(</span>const struct videomode *<em>&nbsp;vm</em>, struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;dmode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_mode_from_videomode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in <strong>dmode</strong> using <strong>vm</strong>,</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>videomode structure to use as source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">dmode</span></code></dt>
<dd>drm_display_mode structure to use as destination</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills out <strong>dmode</strong> using the display mode specified in <strong>vm</strong>.</p>
<dl class="function">
<dt id="c.drm_display_mode_to_videomode">
void <code class="descname">drm_display_mode_to_videomode</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;dmode</em>, struct videomode *<em>&nbsp;vm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_mode_to_videomode" title="Permalink to this definition">¶</a></dt>
<dd><p>fill in <strong>vm</strong> using <strong>dmode</strong>,</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">dmode</span></code></dt>
<dd>drm_display_mode structure to use as source</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>videomode structure to use as destination</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fills out <strong>vm</strong> using the display mode specified in <strong>dmode</strong>.</p>
<dl class="function">
<dt id="c.drm_bus_flags_from_videomode">
void <code class="descname">drm_bus_flags_from_videomode</code><span class="sig-paren">(</span>const struct videomode *<em>&nbsp;vm</em>, u32 *<em>&nbsp;bus_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_bus_flags_from_videomode" title="Permalink to this definition">¶</a></dt>
<dd><p>extract information about pixelclk and DE polarity from videomode and store it in a separate variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">videomode</span> <span class="pre">*</span> <span class="pre">vm</span></code></dt>
<dd>videomode structure to use</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bus_flags</span></code></dt>
<dd>information about pixelclk, sync and DE polarity will be stored
here</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets DRM_BUS_FLAG_DE_(LOW|HIGH),  DRM_BUS_FLAG_PIXDATA_(POS|NEG)EDGE and
DISPLAY_FLAGS_SYNC_(POS|NEG)EDGE in <strong>bus_flags</strong> according to DISPLAY_FLAGS
found in <strong>vm</strong></p>
<dl class="function">
<dt id="c.of_get_drm_display_mode">
int <code class="descname">of_get_drm_display_mode</code><span class="sig-paren">(</span>struct device_node *<em>&nbsp;np</em>, struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;dmode</em>, u32 *<em>&nbsp;bus_flags</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_get_drm_display_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>get a drm_display_mode from devicetree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>device_node with the timing specification</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">dmode</span></code></dt>
<dd>will be set to the return value</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">bus_flags</span></code></dt>
<dd>information about pixelclk, sync and DE polarity</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index into the list of display timings in devicetree</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is expensive and should only be used, if only one mode is to be
read from DT. To get multiple modes start with of_get_display_timings and
work with that instead.</p>
<p><strong>Return</strong></p>
<p>0 on success, a negative errno code when no of videomode node was found.</p>
<dl class="function">
<dt id="c.drm_mode_set_name">
void <code class="descname">drm_mode_set_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>set the name on a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>name will be set in this mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the name of <strong>mode</strong> to a standard format which is &lt;hdisplay&gt;x&lt;vdisplay&gt;
with an optional &#8216;i&#8217; suffix for interlaced modes.</p>
<dl class="function">
<dt id="c.drm_mode_hsync">
int <code class="descname">drm_mode_hsync</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_hsync" title="Permalink to this definition">¶</a></dt>
<dd><p>get the hsync of a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode</dd>
</dl>
<p><strong>Return</strong></p>
<p><strong>modes</strong>&#8216;s hsync rate in kHz, rounded to the nearest integer. Calculates the
value first if it is not yet set.</p>
<dl class="function">
<dt id="c.drm_mode_vrefresh">
int <code class="descname">drm_mode_vrefresh</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_vrefresh" title="Permalink to this definition">¶</a></dt>
<dd><p>get the vrefresh of a mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode</dd>
</dl>
<p><strong>Return</strong></p>
<p><strong>modes</strong>&#8216;s vrefresh rate in Hz, rounded to the nearest integer. Calculates the
value first if it is not yet set.</p>
<dl class="function">
<dt id="c.drm_mode_get_hv_timing">
void <code class="descname">drm_mode_get_hv_timing</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, int *<em>&nbsp;hdisplay</em>, int *<em>&nbsp;vdisplay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_get_hv_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetches hdisplay/vdisplay for given mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to query</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">hdisplay</span></code></dt>
<dd>hdisplay value to fill in</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">vdisplay</span></code></dt>
<dd>vdisplay value to fill in</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vdisplay value will be doubled if the specified mode is a stereo mode of
the appropriate layout.</p>
<dl class="function">
<dt id="c.drm_mode_set_crtcinfo">
void <code class="descname">drm_mode_set_crtcinfo</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;p</em>, int<em>&nbsp;adjust_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_set_crtcinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>set CRTC modesetting timing parameters</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>mode</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">adjust_flags</span></code></dt>
<dd>a combination of adjustment flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Setup the CRTC modesetting timing parameters for <strong>p</strong>, adjusting if necessary.</p>
<ul class="simple">
<li>The CRTC_INTERLACE_HALVE_V flag can be used to halve vertical timings of
interlaced modes.</li>
<li>The CRTC_STEREO_DOUBLE flag can be used to compute the timings for
buffers containing two eyes (only adjust the timings when needed, eg. for
&#8220;frame packing&#8221; or &#8220;side by side full&#8221;).</li>
<li>The CRTC_NO_DBLSCAN and CRTC_NO_VSCAN flags request that adjustment <em>not</em>
be performed for doublescan and vscan &gt; 1 modes respectively.</li>
</ul>
<dl class="function">
<dt id="c.drm_mode_copy">
void <code class="descname">drm_mode_copy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;dst</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;src</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>copy the mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt>
<dd>mode to overwrite</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>mode to copy</dd>
</dl>
<p><strong>Description</strong></p>
<p>Copy an existing mode into another mode, preserving the object id and
list head of the destination mode.</p>
<dl class="function">
<dt id="c.drm_mode_duplicate">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_mode_duplicate</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate and duplicate an existing mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm_device to allocate the duplicated mode for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to duplicate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just allocate a new mode, copy the existing mode into it, and return
a pointer to it.  Used to create new instances of established modes.</p>
<p><strong>Return</strong></p>
<p>Pointer to duplicated mode on success, NULL on error.</p>
<dl class="function">
<dt id="c.drm_mode_match">
bool <code class="descname">drm_mode_match</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode1</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode2</em>, unsigned int<em>&nbsp;match_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_match" title="Permalink to this definition">¶</a></dt>
<dd><p>test modes for (partial) equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode1</span></code></dt>
<dd>first mode</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode2</span></code></dt>
<dd>second mode</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">match_flags</span></code></dt>
<dd>which parts need to match (DRM_MODE_MATCH_*)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent.</p>
<p><strong>Return</strong></p>
<p>True if the modes are (partially) equal, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_equal">
bool <code class="descname">drm_mode_equal</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode1</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode1</span></code></dt>
<dd>first mode</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode2</span></code></dt>
<dd>second mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_equal_no_clocks">
bool <code class="descname">drm_mode_equal_no_clocks</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode1</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal_no_clocks" title="Permalink to this definition">¶</a></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode1</span></code></dt>
<dd>first mode</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode2</span></code></dt>
<dd>second mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent, but
don&#8217;t check the pixel clocks.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_equal_no_clocks_no_stereo">
bool <code class="descname">drm_mode_equal_no_clocks_no_stereo</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode1</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_equal_no_clocks_no_stereo" title="Permalink to this definition">¶</a></dt>
<dd><p>test modes for equality</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode1</span></code></dt>
<dd>first mode</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode2</span></code></dt>
<dd>second mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check to see if <strong>mode1</strong> and <strong>mode2</strong> are equivalent, but
don&#8217;t check the pixel clocks nor the stereo layout.</p>
<p><strong>Return</strong></p>
<p>True if the modes are equal, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_validate_driver">
enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="descname">drm_mode_validate_driver</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_validate_driver" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure the mode is somewhat sane</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to check</dd>
</dl>
<p><strong>Description</strong></p>
<p>First do basic validation on the mode, and then allow the driver
to check for device/driver specific limitations via the optional
<a class="reference internal" href="drm-kms-helpers.html#c.drm_mode_config_helper_funcs" title="drm_mode_config_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_helper_funcs.mode_valid</span></code></a> hook.</p>
<p><strong>Return</strong></p>
<p>The mode status</p>
<dl class="function">
<dt id="c.drm_mode_validate_size">
enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="descname">drm_mode_validate_size</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, int<em>&nbsp;maxX</em>, int<em>&nbsp;maxY</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_validate_size" title="Permalink to this definition">¶</a></dt>
<dd><p>make sure modes adhere to size constraints</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to check</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">maxX</span></code></dt>
<dd>maximum width</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">maxY</span></code></dt>
<dd>maximum height</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a helper which can be used to validate modes against size
limitations of the DRM device/connector. If a mode is too big its status
member is updated with the appropriate validation failure code. The list
itself is not changed.</p>
<p><strong>Return</strong></p>
<p>The mode status</p>
<dl class="function">
<dt id="c.drm_mode_validate_ycbcr420">
enum <a class="reference internal" href="#c.drm_mode_status" title="drm_mode_status">drm_mode_status</a> <code class="descname">drm_mode_validate_ycbcr420</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_validate_ycbcr420" title="Permalink to this definition">¶</a></dt>
<dd><p>add &#8216;ycbcr420-only&#8217; modes only when allowed</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>mode to check</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector under action</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is a helper which can be used to filter out any YCBCR420
only mode, when the source doesn&#8217;t support it.</p>
<p><strong>Return</strong></p>
<p>The mode status</p>
<dl class="function">
<dt id="c.drm_mode_prune_invalid">
void <code class="descname">drm_mode_prune_invalid</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct list_head *<em>&nbsp;mode_list</em>, bool<em>&nbsp;verbose</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_prune_invalid" title="Permalink to this definition">¶</a></dt>
<dd><p>remove invalid modes from mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">mode_list</span></code></dt>
<dd>list of modes to check</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">verbose</span></code></dt>
<dd>be verbose about it</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function can be used to prune a display mode list after
validation has been completed. All modes who&#8217;s status is not MODE_OK will be
removed from the list, and if <strong>verbose</strong> the status code and mode name is also
printed to dmesg.</p>
<dl class="function">
<dt id="c.drm_mode_sort">
void <code class="descname">drm_mode_sort</code><span class="sig-paren">(</span>struct list_head *<em>&nbsp;mode_list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>sort mode list</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*</span> <span class="pre">mode_list</span></code></dt>
<dd>list of drm_display_mode structures to sort</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sort <strong>mode_list</strong> by favorability, moving good modes to the head of the list.</p>
<dl class="function">
<dt id="c.drm_connector_list_update">
void <code class="descname">drm_connector_list_update</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update the mode list for the connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector to update</dd>
</dl>
<p><strong>Description</strong></p>
<p>This moves the modes from the <strong>connector</strong> probed_modes list
to the actual mode list. It compares the probed mode against the current
list and only adds different/new modes.</p>
<p>This is just a helper functions doesn&#8217;t validate any modes itself and also
doesn&#8217;t prune any invalid modes. Callers need to do that themselves.</p>
<dl class="function">
<dt id="c.drm_mode_parse_command_line_for_connector">
bool <code class="descname">drm_mode_parse_command_line_for_connector</code><span class="sig-paren">(</span>const char *<em>&nbsp;mode_option</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct drm_cmdline_mode *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_parse_command_line_for_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>parse command line modeline for connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">mode_option</span></code></dt>
<dd>optional per connector mode option</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to parse modeline for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_cmdline_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>preallocated drm_cmdline_mode structure to fill out</dd>
</dl>
<p><strong>Description</strong></p>
<p>This parses <strong>mode_option</strong> command line modeline for modes and options to
configure the connector. If <strong>mode_option</strong> is NULL the default command line
modeline in fb_mode_option will be parsed instead.</p>
<p>This uses the same parameters as the fb modedb.c, except for an extra
force-enable, force-enable-digital and force-disable bit at the end:</p>
<div class="highlight-none"><div class="highlight"><pre>&lt;xres&gt;x&lt;yres&gt;[M][R][-&lt;bpp&gt;][@&lt;refresh&gt;][i][m][eDd]
</pre></div>
</div>
<p>The intermediate drm_cmdline_mode structure is required to store additional
options from the command line modline like the force-enable/disable flag.</p>
<p><strong>Return</strong></p>
<p>True if a valid modeline has been parsed, false otherwise.</p>
<dl class="function">
<dt id="c.drm_mode_create_from_cmdline_mode">
struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> * <code class="descname">drm_mode_create_from_cmdline_mode</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct drm_cmdline_mode *<em>&nbsp;cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_from_cmdline_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a command line modeline into a DRM display mode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device to create the new mode for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_cmdline_mode</span> <span class="pre">*</span> <span class="pre">cmd</span></code></dt>
<dd>input command line modeline</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to converted mode on success, NULL on error.</p>
<dl class="function">
<dt id="c.drm_mode_is_420_only">
bool <code class="descname">drm_mode_is_420_only</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>&nbsp;display</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_420_only" title="Permalink to this definition">¶</a></dt>
<dd><p>if a given videomode can be only supported in YCBCR420 output format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*</span> <span class="pre">display</span></code></dt>
<dd>display under action</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>video mode to be tested.</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the mode can be supported in YCBCR420 format
false if not.</p>
<dl class="function">
<dt id="c.drm_mode_is_420_also">
bool <code class="descname">drm_mode_is_420_also</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>&nbsp;display</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_420_also" title="Permalink to this definition">¶</a></dt>
<dd><p>if a given videomode can be supported in YCBCR420 output format also (along with RGB/YCBCR444/422)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*</span> <span class="pre">display</span></code></dt>
<dd>display under action.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>video mode to be tested.</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the mode can be support YCBCR420 format
false if not.</p>
<dl class="function">
<dt id="c.drm_mode_is_420">
bool <code class="descname">drm_mode_is_420</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>&nbsp;display</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_is_420" title="Permalink to this definition">¶</a></dt>
<dd><p>if a given videomode can be supported in YCBCR420 output format</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*</span> <span class="pre">display</span></code></dt>
<dd>display under action.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>video mode to be tested.</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the mode can be supported in YCBCR420 format
false if not.</p>
</div>
<div class="section" id="connector-abstraction">
<h2>Connector Abstraction<a class="headerlink" href="#connector-abstraction" title="Permalink to this headline">¶</a></h2>
<p>In DRM connectors are the general abstraction for display sinks, and include
als fixed panels or anything else that can display pixels in some form. As
opposed to all other KMS objects representing hardware (like CRTC, encoder or
plane abstractions) connectors can be hotplugged and unplugged at runtime.
Hence they are reference-counted using <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_get()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_put" title="drm_connector_put"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_put()</span></code></a>.</p>
<p>KMS driver must create, initialize, register and attach at a <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_connector</span></code></a> for each such sink. The instance is created as other KMS
objects and initialized by setting the following fields. The connector is
initialized with a call to <a class="reference internal" href="#c.drm_connector_init" title="drm_connector_init"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_init()</span></code></a> with a pointer to the
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_funcs</span></code></a> and a connector type, and then exposed to
userspace with a call to <a class="reference internal" href="#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_register()</span></code></a>.</p>
<p>Connectors must be attached to an encoder to be used. For devices that map
connectors to encoders 1:1, the connector should be attached at
initialization time with a call to <a class="reference internal" href="#c.drm_connector_attach_encoder" title="drm_connector_attach_encoder"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_attach_encoder()</span></code></a>. The
driver must also set the <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.encoder</span></code></a> field to point to the
attached encoder.</p>
<p>For connectors which are not fixed (like built-in panels) the driver needs to
support hotplug notifications. The simplest way to do that is by using the
probe helpers, see <a class="reference internal" href="drm-kms-helpers.html#c.drm_kms_helper_poll_init" title="drm_kms_helper_poll_init"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_poll_init()</span></code></a> for connectors which don&#8217;t have
hardware support for hotplug interrupts. Connectors with hardware hotplug
support can instead use e.g. <a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_hpd_irq_event" title="drm_helper_hpd_irq_event"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_hpd_irq_event()</span></code></a>.</p>
<div class="section" id="connector-functions-reference">
<h3>Connector Functions Reference<a class="headerlink" href="#connector-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_connector_status">
enum <code class="descname">drm_connector_status</code><a class="headerlink" href="#c.drm_connector_status" title="Permalink to this definition">¶</a></dt>
<dd><p>status for a <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector_status_connected</span></code></dt>
<dd>The connector is definitely connected to
a sink device, and can be enabled.</dd>
<dt><code class="docutils literal"><span class="pre">connector_status_disconnected</span></code></dt>
<dd>The connector isn&#8217;t connected to a
sink device which can be autodetect. For digital outputs like DP or
HDMI (which can be realiable probed) this means there&#8217;s really
nothing there. It is driver-dependent whether a connector with this
status can be lit up or not.</dd>
<dt><code class="docutils literal"><span class="pre">connector_status_unknown</span></code></dt>
<dd>The connector&#8217;s status could not be
reliably detected. This happens when probing would either cause
flicker (like load-detection when the connector is in use), or when a
hardware resource isn&#8217;t available (like when load-detection needs a
free CRTC). It should be possible to light up the connector with one
of the listed fallback modes. For default configuration userspace
should only try to light up connectors with unknown status when
there&#8217;s not connector with <strong>connector_status_connected</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to track the connector status. There are no separate
#defines for the uapi!</p>
<dl class="type">
<dt id="c.drm_scrambling">
struct <code class="descname">drm_scrambling</code><a class="headerlink" href="#c.drm_scrambling" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_scrambling {
  bool supported;
  bool low_rates;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">supported</span></code></dt>
<dd>scrambling supported for rates &gt; 340 Mhz.</dd>
<dt><code class="docutils literal"><span class="pre">low_rates</span></code></dt>
<dd>scrambling supported for rates &lt;= 340 Mhz.</dd>
</dl>
<dl class="type">
<dt id="c.drm_hdmi_info">
struct <code class="descname">drm_hdmi_info</code><a class="headerlink" href="#c.drm_hdmi_info" title="Permalink to this definition">¶</a></dt>
<dd><p>runtime information about the connected HDMI sink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_hdmi_info {
  struct drm_scdc scdc;
  unsigned long y420_vdb_modes[BITS_TO_LONGS(128)];
  unsigned long y420_cmdb_modes[BITS_TO_LONGS(128)];
  u64 y420_cmdb_map;
  u8 y420_dc_modes;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">scdc</span></code></dt>
<dd>sink&#8217;s scdc support and capabilities</dd>
<dt><code class="docutils literal"><span class="pre">y420_vdb_modes</span></code></dt>
<dd>bitmap of modes which can support ycbcr420
output only (not normal RGB/YCBCR444/422 outputs). There are total
107 VICs defined by CEA-861-F spec, so the size is 128 bits to map
upto 128 VICs;</dd>
<dt><code class="docutils literal"><span class="pre">y420_cmdb_modes</span></code></dt>
<dd>bitmap of modes which can support ycbcr420
output also, along with normal HDMI outputs. There are total 107
VICs defined by CEA-861-F spec, so the size is 128 bits to map upto
128 VICs;</dd>
<dt><code class="docutils literal"><span class="pre">y420_cmdb_map</span></code></dt>
<dd>bitmap of SVD index, to extraxt vcb modes</dd>
<dt><code class="docutils literal"><span class="pre">y420_dc_modes</span></code></dt>
<dd>bitmap of deep color support index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes if a given display supports advanced HDMI 2.0 features.
This information is available in CEA-861-F extension blocks (like HF-VSDB).</p>
<dl class="type">
<dt id="c.drm_link_status">
enum <code class="descname">drm_link_status</code><a class="headerlink" href="#c.drm_link_status" title="Permalink to this definition">¶</a></dt>
<dd><p>connector&#8217;s link_status property value</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_LINK_STATUS_GOOD</span></code></dt>
<dd>DP Link is Good as a result of successful
link training</dd>
<dt><code class="docutils literal"><span class="pre">DRM_LINK_STATUS_BAD</span></code></dt>
<dd>DP Link is BAD as a result of link training
failure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used as the connector&#8217;s link status property value.
It is set to the values defined in uapi.</p>
<dl class="type">
<dt id="c.drm_panel_orientation">
enum <code class="descname">drm_panel_orientation</code><a class="headerlink" href="#c.drm_panel_orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>panel_orientation info for <a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal"><span class="pre">drm_display_info</span></code></a></p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DRM_MODE_PANEL_ORIENTATION_UNKNOWN</span></code></dt>
<dd>The drm driver has not provided any
panel orientation information (normal
for non panels) in this case the &#8220;panel
orientation&#8221; connector prop will not be
attached.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MODE_PANEL_ORIENTATION_NORMAL</span></code></dt>
<dd>The top side of the panel matches the
top side of the device&#8217;s casing.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP</span></code></dt>
<dd>The top side of the panel matches the
bottom side of the device&#8217;s casing, iow
the panel is mounted upside-down.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MODE_PANEL_ORIENTATION_LEFT_UP</span></code></dt>
<dd>The left side of the panel matches the
top side of the device&#8217;s casing.</dd>
<dt><code class="docutils literal"><span class="pre">DRM_MODE_PANEL_ORIENTATION_RIGHT_UP</span></code></dt>
<dd>The right side of the panel matches the
top side of the device&#8217;s casing.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This enum is used to track the (LCD) panel orientation. There are no
separate #defines for the uapi!</p>
<dl class="type">
<dt id="c.drm_display_info">
struct <code class="descname">drm_display_info</code><a class="headerlink" href="#c.drm_display_info" title="Permalink to this definition">¶</a></dt>
<dd><p>runtime data about the connected sink</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_display_info {
  char name[DRM_DISPLAY_INFO_LEN];
  unsigned int width_mm;
  unsigned int height_mm;
  unsigned int pixel_clock;
  unsigned int bpc;
  enum subpixel_order subpixel_order;
#define DRM_COLOR_FORMAT_RGB444         (1&lt;&lt;0);
#define DRM_COLOR_FORMAT_YCRCB444       (1&lt;&lt;1);
#define DRM_COLOR_FORMAT_YCRCB422       (1&lt;&lt;2);
#define DRM_COLOR_FORMAT_YCRCB420       (1&lt;&lt;3);
  int panel_orientation;
  u32 color_formats;
  const u32 *bus_formats;
  unsigned int num_bus_formats;
#define DRM_BUS_FLAG_DE_LOW             (1&lt;&lt;0);
#define DRM_BUS_FLAG_DE_HIGH            (1&lt;&lt;1);
#define DRM_BUS_FLAG_PIXDATA_POSEDGE    (1&lt;&lt;2);
#define DRM_BUS_FLAG_PIXDATA_NEGEDGE    (1&lt;&lt;3);
#define DRM_BUS_FLAG_DATA_MSB_TO_LSB    (1&lt;&lt;4);
#define DRM_BUS_FLAG_DATA_LSB_TO_MSB    (1&lt;&lt;5);
#define DRM_BUS_FLAG_SYNC_POSEDGE       (1&lt;&lt;6);
#define DRM_BUS_FLAG_SYNC_NEGEDGE       (1&lt;&lt;7);
  u32 bus_flags;
  int max_tmds_clock;
  bool dvi_dual;
  bool has_hdmi_infoframe;
  u8 edid_hdmi_dc_modes;
  u8 cea_rev;
  struct drm_hdmi_info hdmi;
  bool non_desktop;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the display.</dd>
<dt><code class="docutils literal"><span class="pre">width_mm</span></code></dt>
<dd>Physical width in mm.</dd>
<dt><code class="docutils literal"><span class="pre">height_mm</span></code></dt>
<dd>Physical height in mm.</dd>
<dt><code class="docutils literal"><span class="pre">pixel_clock</span></code></dt>
<dd>Maximum pixel clock supported by the sink, in units of
100Hz. This mismatches the clock in <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode"><code class="xref c c-type docutils literal"><span class="pre">drm_display_mode</span></code></a> (which is in
kHZ), because that&#8217;s what the EDID uses as base unit.</dd>
<dt><code class="docutils literal"><span class="pre">bpc</span></code></dt>
<dd>Maximum bits per color channel. Used by HDMI and DP outputs.</dd>
<dt><code class="docutils literal"><span class="pre">subpixel_order</span></code></dt>
<dd>Subpixel order of LCD panels.</dd>
<dt><code class="docutils literal"><span class="pre">panel_orientation</span></code></dt>
<dd>Read only connector property for built-in panels,
indicating the orientation of the panel vs the device&#8217;s casing.
<a class="reference internal" href="#c.drm_connector_init" title="drm_connector_init"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_init()</span></code></a> sets this to DRM_MODE_PANEL_ORIENTATION_UNKNOWN.
When not UNKNOWN this gets used by the drm_fb_helpers to rotate the
fb to compensate and gets exported as prop to userspace.</dd>
<dt><code class="docutils literal"><span class="pre">color_formats</span></code></dt>
<dd>HDMI Color formats, selects between RGB and YCrCb
modes. Used DRM_COLOR_FORMAT_ defines, which are _not_ the same ones
as used to describe the pixel format in framebuffers, and also don&#8217;t
match the formats in <strong>bus_formats</strong> which are shared with v4l.</dd>
<dt><code class="docutils literal"><span class="pre">bus_formats</span></code></dt>
<dd>Pixel data format on the wire, somewhat redundant with
<strong>color_formats</strong>. Array of size <strong>num_bus_formats</strong> encoded using
MEDIA_BUS_FMT_ defines shared with v4l and media drivers.</dd>
<dt><code class="docutils literal"><span class="pre">num_bus_formats</span></code></dt>
<dd>Size of <strong>bus_formats</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">bus_flags</span></code></dt>
<dd>Additional information (like pixel signal polarity) for
the pixel data on the bus, using DRM_BUS_FLAGS_ defines.</dd>
<dt><code class="docutils literal"><span class="pre">max_tmds_clock</span></code></dt>
<dd>Maximum TMDS clock rate supported by the
sink in kHz. 0 means undefined.</dd>
<dt><code class="docutils literal"><span class="pre">dvi_dual</span></code></dt>
<dd>Dual-link DVI sink?</dd>
<dt><code class="docutils literal"><span class="pre">has_hdmi_infoframe</span></code></dt>
<dd>Does the sink support the HDMI infoframe?</dd>
<dt><code class="docutils literal"><span class="pre">edid_hdmi_dc_modes</span></code></dt>
<dd>Mask of supported hdmi deep color modes. Even
more stuff redundant with <strong>bus_formats</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">cea_rev</span></code></dt>
<dd>CEA revision of the HDMI sink.</dd>
<dt><code class="docutils literal"><span class="pre">hdmi</span></code></dt>
<dd>advance features of a HDMI sink.</dd>
<dt><code class="docutils literal"><span class="pre">non_desktop</span></code></dt>
<dd>Non desktop display (HMD).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Describes a given display (e.g. CRT or flat panel) and its limitations. For
fixed display sinks like built-in panels there&#8217;s not much difference between
this and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>. But for sinks with a real cable this
structure is meant to describe all the things at the other end of the cable.</p>
<p>For sinks which provide an EDID this can be filled out by calling
<a class="reference internal" href="drm-kms-helpers.html#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_add_edid_modes()</span></code></a>.</p>
<dl class="type">
<dt id="c.drm_tv_connector_state">
struct <code class="descname">drm_tv_connector_state</code><a class="headerlink" href="#c.drm_tv_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>TV connector related states</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_tv_connector_state {
  enum drm_mode_subconnector subconnector;
  struct {
    unsigned int left;
    unsigned int right;
    unsigned int top;
    unsigned int bottom;
  } margins;
  unsigned int mode;
  unsigned int brightness;
  unsigned int contrast;
  unsigned int flicker_reduction;
  unsigned int overscan;
  unsigned int saturation;
  unsigned int hue;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">subconnector</span></code></dt>
<dd>selected subconnector</dd>
<dt><code class="docutils literal"><span class="pre">margins</span></code></dt>
<dd>margins</dd>
<dt><code class="docutils literal"><span class="pre">margins.left</span></code></dt>
<dd>left margin</dd>
<dt><code class="docutils literal"><span class="pre">margins.right</span></code></dt>
<dd>right margin</dd>
<dt><code class="docutils literal"><span class="pre">margins.top</span></code></dt>
<dd>top margin</dd>
<dt><code class="docutils literal"><span class="pre">margins.bottom</span></code></dt>
<dd>bottom margin</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>TV mode</dd>
<dt><code class="docutils literal"><span class="pre">brightness</span></code></dt>
<dd>brightness in percent</dd>
<dt><code class="docutils literal"><span class="pre">contrast</span></code></dt>
<dd>contrast in percent</dd>
<dt><code class="docutils literal"><span class="pre">flicker_reduction</span></code></dt>
<dd>flicker reduction in percent</dd>
<dt><code class="docutils literal"><span class="pre">overscan</span></code></dt>
<dd>overscan in percent</dd>
<dt><code class="docutils literal"><span class="pre">saturation</span></code></dt>
<dd>saturation in percent</dd>
<dt><code class="docutils literal"><span class="pre">hue</span></code></dt>
<dd>hue in percent</dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_state">
struct <code class="descname">drm_connector_state</code><a class="headerlink" href="#c.drm_connector_state" title="Permalink to this definition">¶</a></dt>
<dd><p>mutable connector state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector_state {
  struct drm_connector *connector;
  struct drm_crtc *crtc;
  struct drm_encoder *best_encoder;
  enum drm_link_status link_status;
  struct drm_atomic_state *state;
  struct drm_crtc_commit *commit;
  struct drm_tv_connector_state tv;
  enum hdmi_picture_aspect picture_aspect_ratio;
  unsigned int content_type;
  unsigned int scaling_mode;
  unsigned int content_protection;
  struct drm_writeback_job *writeback_job;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd>backpointer to the connector</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd><p class="first">CRTC to connect connector to, NULL if disabled.</p>
<p class="last">Do not change this directly, use <a class="reference internal" href="#c.drm_atomic_set_crtc_for_connector" title="drm_atomic_set_crtc_for_connector"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_crtc_for_connector()</span></code></a>
instead.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">best_encoder</span></code></dt>
<dd>Used by the atomic helpers to select the encoder, through the
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.atomic_best_encoder</span></code></a> or
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.best_encoder</span></code></a> callbacks.</dd>
<dt><code class="docutils literal"><span class="pre">link_status</span></code></dt>
<dd>Connector link_status to keep track of whether link is
GOOD or BAD to notify userspace if retraining is necessary.</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>backpointer to global drm_atomic_state</dd>
<dt><code class="docutils literal"><span class="pre">commit</span></code></dt>
<dd><p class="first">Tracks the pending commit to prevent use-after-free conditions.</p>
<p class="last">Is only set when <strong>crtc</strong> is NULL.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">tv</span></code></dt>
<dd>TV connector state</dd>
<dt><code class="docutils literal"><span class="pre">picture_aspect_ratio</span></code></dt>
<dd><p class="first">Connector property to control the
HDMI infoframe aspect ratio setting.</p>
<p class="last">The <code class="docutils literal"><span class="pre">DRM_MODE_PICTURE_ASPECT_</span></code>* values much match the
values for <code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">hdmi_picture_aspect</span></code></p>
</dd>
<dt><code class="docutils literal"><span class="pre">content_type</span></code></dt>
<dd>Connector property to control the
HDMI infoframe content type setting.
The <code class="docutils literal"><span class="pre">DRM_MODE_CONTENT_TYPE_</span></code>* values much
match the values.</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode</span></code></dt>
<dd>Connector property to control the
upscaling, mostly used for built-in panels.</dd>
<dt><code class="docutils literal"><span class="pre">content_protection</span></code></dt>
<dd>Connector property to request content
protection. This is most commonly used for HDCP.</dd>
<dt><code class="docutils literal"><span class="pre">writeback_job</span></code></dt>
<dd><p class="first">Writeback job for writeback connectors</p>
<p>Holds the framebuffer and out-fence for a writeback connector. As
the writeback completion may be asynchronous to the normal commit
cycle, the writeback job lifetime is managed separately from the
normal atomic state by this object.</p>
<p class="last">See also: <a class="reference internal" href="#c.drm_writeback_queue_job" title="drm_writeback_queue_job"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_queue_job()</span></code></a> and
<a class="reference internal" href="#c.drm_writeback_signal_completion" title="drm_writeback_signal_completion"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_signal_completion()</span></code></a></p>
</dd>
</dl>
<dl class="type">
<dt id="c.drm_connector_funcs">
struct <code class="descname">drm_connector_funcs</code><a class="headerlink" href="#c.drm_connector_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>control connectors on a given device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector_funcs {
  int (*dpms)(struct drm_connector *connector, int mode);
  void (*reset)(struct drm_connector *connector);
  enum drm_connector_status (*detect)(struct drm_connector *connector, bool force);
  void (*force)(struct drm_connector *connector);
  int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
  int (*set_property)(struct drm_connector *connector, struct drm_property *property, uint64_t val);
  int (*late_register)(struct drm_connector *connector);
  void (*early_unregister)(struct drm_connector *connector);
  void (*destroy)(struct drm_connector *connector);
  struct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector *connector);
  void (*atomic_destroy_state)(struct drm_connector *connector, struct drm_connector_state *state);
  int (*atomic_set_property)(struct drm_connector *connector,struct drm_connector_state *state,struct drm_property *property, uint64_t val);
  int (*atomic_get_property)(struct drm_connector *connector,const struct drm_connector_state *state,struct drm_property *property, uint64_t *val);
  void (*atomic_print_state)(struct drm_printer *p, const struct drm_connector_state *state);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd><p class="first">Legacy entry point to set the per-connector DPMS state. Legacy DPMS
is exposed as a standard property on the connector, but diverted to
this callback in the drm core. Note that atomic drivers don&#8217;t
implement the 4 level DPMS support on the connector any more, but
instead only have an on/off &#8220;ACTIVE&#8221; property on the CRTC object.</p>
<p>This hook is not used by atomic drivers, remapping of the legacy DPMS
property is entirely handled in the DRM core.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd><p class="first">Reset connector hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>.
It&#8217;s not a helper hook only for historical reasons.</p>
<p class="last">Atomic drivers can use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_reset" title="drm_atomic_helper_connector_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_reset()</span></code></a> to reset
atomic state using this hook.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">detect</span></code></dt>
<dd><p class="first">Check to see if anything is attached to the connector. The parameter
force is set to false whilst polling, true when checking the
connector due to a user request. force can be used by the driver to
avoid expensive, destructive operations during automated probing.</p>
<p>This callback is optional, if not implemented the connector will be
considered as always being attached.</p>
<p>FIXME:</p>
<p>Note that this hook is only called by the probe helper. It&#8217;s not in
the helper library vtable purely for historical reasons. The only DRM
core entry point to probe connector state is <strong>fill_modes</strong>.</p>
<p>Note that the helper library will already hold
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>. Drivers which need to grab additional
locks to avoid races with concurrent modeset changes need to use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs.detect_ctx</span></code></a> instead.</p>
<p>RETURNS:</p>
<p class="last">drm_connector_status indicating the connector&#8217;s status.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">force</span></code></dt>
<dd><p class="first">This function is called to update internal encoder state when the
connector is forced to a certain state by userspace, either through
the sysfs interfaces or on the kernel cmdline. In that case the
<strong>detect</strong> callback isn&#8217;t called.</p>
<p>FIXME:</p>
<p class="last">Note that this hook is only called by the probe helper. It&#8217;s not in
the helper library vtable purely for historical reasons. The only DRM
core entry point to probe connector state is <strong>fill_modes</strong>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">fill_modes</span></code></dt>
<dd><p class="first">Entry point for output detection and basic mode validation. The
driver should reprobe the output if needed (e.g. when hotplug
handling is unreliable), add all detected modes to <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>
and filter out any the device can&#8217;t support in any configuration. It
also needs to filter out any modes wider or higher than the
parameters max_width and max_height indicate.</p>
<p>The drivers must also prune any modes no longer valid from
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>. Furthermore it must update
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.status</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.edid</span></code></a>.  If no EDID has been
received for this output connector-&gt;edid must be NULL.</p>
<p>Drivers using the probe helpers should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> to implement this
function.</p>
<p>RETURNS:</p>
<p class="last">The number of modes detected and filled into <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.modes</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">set_property</span></code></dt>
<dd><p class="first">This is the legacy entry point to update a property attached to the
connector.</p>
<p>This callback is optional if the driver does not support any legacy
driver-private properties. For atomic drivers it is not used because
property handling is done entirely in the DRM core.</p>
<p>RETURNS:</p>
<p class="last">0 on success or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the connector, light backlight control, i2c,
DP aux or similar interfaces. It is called late in the driver load
sequence from <a class="reference internal" href="#c.drm_connector_register" title="drm_connector_register"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_register()</span></code></a> when registering all the
core drm connector interfaces. Everything added from this callback
should be unregistered in the early_unregister callback.</p>
<p>This is called while holding <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.mutex</span></code></a>.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd><p class="first">This optional hook should be used to unregister the additional
userspace interfaces attached to the connector from
<code class="xref c c-func docutils literal"><span class="pre">late_register()</span></code>. It is called from <a class="reference internal" href="#c.drm_connector_unregister" title="drm_connector_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</p>
<p class="last">This is called while holding <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up connector resources. This is called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>. It can also be called at runtime
when a connector is being hot-unplugged for drivers that support
connector hotplugging (e.g. DisplayPort MST).</dd>
<dt><code class="docutils literal"><span class="pre">atomic_duplicate_state</span></code></dt>
<dd><p class="first">Duplicate the current atomic state for this connector and return it.
The core and helpers guarantee that any atomic state duplicated with
this hook and still owned by the caller (i.e. not transferred to the
driver by calling <a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_commit</span></code></a>) will be
cleaned up by calling the <strong>atomic_destroy_state</strong> hook in this
structure.</p>
<p>This callback is mandatory for atomic drivers.</p>
<p>Atomic drivers which don&#8217;t subclass <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a> should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_connector_duplicate_state" title="drm_atomic_helper_connector_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_connector_duplicate_state()</span></code></a>. Drivers that subclass the
state structure to extend it with driver-private state should use
<a class="reference internal" href="drm-kms-helpers.html#c.__drm_atomic_helper_connector_duplicate_state" title="__drm_atomic_helper_connector_duplicate_state"><code class="xref c c-func docutils literal"><span class="pre">__drm_atomic_helper_connector_duplicate_state()</span></code></a> to make sure shared state is
duplicated in a consistent fashion across drivers.</p>
<p>It is an error to call this hook before <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector.state</span></code></a> has been
initialized correctly.</p>
<p>NOTE:</p>
<p>If the duplicate state references refcounted resources this hook must
acquire a reference for each of them. The driver must release these
references again in <strong>atomic_destroy_state</strong>.</p>
<p>RETURNS:</p>
<p class="last">Duplicated atomic state or NULL when the allocation failed.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_destroy_state</span></code></dt>
<dd><p class="first">Destroy a state duplicated with <strong>atomic_duplicate_state</strong> and release
or unreference all resources it references</p>
<p class="last">This callback is mandatory for atomic drivers.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_set_property</span></code></dt>
<dd><p class="first">Decode a driver-private property value and store the decoded value
into the passed-in state structure. Since the atomic core decodes all
standardized properties (even for extensions beyond the core set of
properties which might not be implemented by all drivers) this
requires drivers to subclass the state structure.</p>
<p>Such driver-private properties should really only be implemented for
truly hardware/vendor specific state. Instead it is preferred to
standardize atomic extension and decode the properties used to expose
such an extension in the core.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_connector_set_property" title="drm_atomic_connector_set_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_set_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>NOTE:</p>
<p>This function is called in the state assembly phase of atomic
modesets, which can be aborted for any reason (including on
userspace&#8217;s request to just check whether a configuration would be
possible). Drivers MUST NOT touch any persistent state (hardware or
software) or data structures except the passed in <strong>state</strong> parameter.</p>
<p>Also since userspace controls in which order properties are set this
function must not do any input validation (since the state update is
incomplete and hence likely inconsistent). Instead any such input
validation must be done in the various atomic_check callbacks.</p>
<p>RETURNS:</p>
<p class="last">0 if the property has been found, -EINVAL if the property isn&#8217;t
implemented by the driver (which shouldn&#8217;t ever happen, the core only
asks for properties attached to this connector). No other validation
is allowed by the driver. The core already checks that the property
value is within the range (integer, valid enum value, ...) the driver
set when registering the property.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_get_property</span></code></dt>
<dd><p class="first">Reads out the decoded driver-private property. This is used to
implement the GETCONNECTOR IOCTL.</p>
<p>Do not call this function directly, use
<a class="reference internal" href="#c.drm_atomic_connector_get_property" title="drm_atomic_connector_get_property"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_get_property()</span></code></a> instead.</p>
<p>This callback is optional if the driver does not support any
driver-private atomic properties.</p>
<p>RETURNS:</p>
<p class="last">0 on success, -EINVAL if the property isn&#8217;t implemented by the
driver (which shouldn&#8217;t ever happen, the core only asks for
properties attached to this connector).</p>
</dd>
<dt><code class="docutils literal"><span class="pre">atomic_print_state</span></code></dt>
<dd><p class="first">If driver subclasses <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_state</span></code></a>, it should implement
this optional hook for printing additional driver specific state.</p>
<p class="last">Do not call this directly, use <code class="xref c c-func docutils literal"><span class="pre">drm_atomic_connector_print_state()</span></code>
instead.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each CRTC may have one or more connectors attached to it.  The functions
below allow the core DRM code to control connectors, enumerate available modes,
etc.</p>
<dl class="type">
<dt id="c.drm_connector">
struct <code class="descname">drm_connector</code><a class="headerlink" href="#c.drm_connector" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM connector control structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector {
  struct drm_device *dev;
  struct device *kdev;
  struct device_attribute *attr;
  struct list_head head;
  struct drm_mode_object base;
  char *name;
  struct mutex mutex;
  unsigned index;
  int connector_type;
  int connector_type_id;
  bool interlace_allowed;
  bool doublescan_allowed;
  bool stereo_allowed;
  bool ycbcr_420_allowed;
  bool registered;
  struct list_head modes;
  enum drm_connector_status status;
  struct list_head probed_modes;
  struct drm_display_info display_info;
  const struct drm_connector_funcs *funcs;
  struct drm_property_blob *edid_blob_ptr;
  struct drm_object_properties properties;
  struct drm_property *scaling_mode_property;
  struct drm_property *content_protection_property;
  struct drm_property_blob *path_blob_ptr;
#define DRM_CONNECTOR_POLL_HPD (1 &lt;&lt; 0);
#define DRM_CONNECTOR_POLL_CONNECT (1 &lt;&lt; 1);
#define DRM_CONNECTOR_POLL_DISCONNECT (1 &lt;&lt; 2);
  uint8_t polled;
  int dpms;
  const struct drm_connector_helper_funcs *helper_private;
  struct drm_cmdline_mode cmdline_mode;
  enum drm_connector_force force;
  bool override_edid;
#define DRM_CONNECTOR_MAX_ENCODER 3;
  uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
  struct drm_encoder *encoder;
#define MAX_ELD_BYTES   128;
  uint8_t eld[MAX_ELD_BYTES];
  bool latency_present[2];
  int video_latency[2];
  int audio_latency[2];
  int null_edid_counter;
  unsigned bad_edid_counter;
  bool edid_corrupt;
  struct dentry *debugfs_entry;
  struct drm_connector_state *state;
  struct drm_property_blob *tile_blob_ptr;
  bool has_tile;
  struct drm_tile_group *tile_group;
  bool tile_is_single_monitor;
  uint8_t num_h_tile, num_v_tile;
  uint8_t tile_h_loc, tile_v_loc;
  uint16_t tile_h_size, tile_v_size;
  struct llist_node free_node;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">kdev</span></code></dt>
<dd>kernel device for sysfs attributes</dd>
<dt><code class="docutils literal"><span class="pre">attr</span></code></dt>
<dd>sysfs attributes</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>List of all connectors on a <strong>dev</strong>, linked from
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connector_list</span></code></a>. Protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connector_list_lock</span></code></a>, but please only use
<a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_list_iter</span></code></a> to walk this list.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>Lock for general connector state, but currently only protects
<strong>registered</strong>. Most of the connector state is still protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Compacted connector index, which matches the position inside
the mode_config.list for drivers not supporting hot-add/removing. Can
be used as an array index. It is invariant over the lifetime of the
connector.</dd>
<dt><code class="docutils literal"><span class="pre">connector_type</span></code></dt>
<dd>one of the DRM_MODE_CONNECTOR_&lt;foo&gt; types from drm_mode.h</dd>
<dt><code class="docutils literal"><span class="pre">connector_type_id</span></code></dt>
<dd>index into connector type enum</dd>
<dt><code class="docutils literal"><span class="pre">interlace_allowed</span></code></dt>
<dd>Can this connector handle interlaced modes? Only used by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> for mode filtering.</dd>
<dt><code class="docutils literal"><span class="pre">doublescan_allowed</span></code></dt>
<dd>Can this connector handle doublescan? Only used by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> for mode filtering.</dd>
<dt><code class="docutils literal"><span class="pre">stereo_allowed</span></code></dt>
<dd>Can this connector handle stereo modes? Only used by
<a class="reference internal" href="drm-kms-helpers.html#c.drm_helper_probe_single_connector_modes" title="drm_helper_probe_single_connector_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_helper_probe_single_connector_modes()</span></code></a> for mode filtering.</dd>
<dt><code class="docutils literal"><span class="pre">ycbcr_420_allowed</span></code></dt>
<dd>This bool indicates if this connector is
capable of handling YCBCR 420 output. While parsing the EDID
blocks, its very helpful to know, if the source is capable of
handling YCBCR 420 outputs.</dd>
<dt><code class="docutils literal"><span class="pre">registered</span></code></dt>
<dd>Is this connector exposed (registered) with userspace?
Protected by <strong>mutex</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">modes</span></code></dt>
<dd>Modes available on this connector (from <code class="xref c c-func docutils literal"><span class="pre">fill_modes()</span></code> + user).
Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>One of the drm_connector_status enums (connected, not, or unknown).
Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">probed_modes</span></code></dt>
<dd>These are modes added by probing with DDC or the BIOS, before
filtering is applied. Used by the probe helpers. Protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">display_info</span></code></dt>
<dd><p class="first">Display information is filled from EDID information
when a display is detected. For non hot-pluggable displays such as
flat panels in embedded systems, the driver should initialize the
<a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal"><span class="pre">drm_display_info.width_mm</span></code></a> and <a class="reference internal" href="#c.drm_display_info" title="drm_display_info"><code class="xref c c-type docutils literal"><span class="pre">drm_display_info.height_mm</span></code></a> fields
with the physical size of the display.</p>
<p class="last">Protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>connector control functions</dd>
<dt><code class="docutils literal"><span class="pre">edid_blob_ptr</span></code></dt>
<dd>DRM property containing EDID if present. Protected by
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>. This should be updated only by calling
<a class="reference internal" href="#c.drm_connector_update_edid_property" title="drm_connector_update_edid_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_update_edid_property()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">properties</span></code></dt>
<dd>property tracking for this connector</dd>
<dt><code class="docutils literal"><span class="pre">scaling_mode_property</span></code></dt>
<dd>Optional atomic property to control the
upscaling. See <a class="reference internal" href="#c.drm_connector_attach_content_protection_property" title="drm_connector_attach_content_protection_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_attach_content_protection_property()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">content_protection_property</span></code></dt>
<dd>DRM ENUM property for content
protection. See <a class="reference internal" href="#c.drm_connector_attach_content_protection_property" title="drm_connector_attach_content_protection_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_attach_content_protection_property()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">path_blob_ptr</span></code></dt>
<dd>DRM blob property data for the DP MST path property. This should only
be updated by calling <a class="reference internal" href="#c.drm_connector_set_path_property" title="drm_connector_set_path_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_set_path_property()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">polled</span></code></dt>
<dd><p class="first">Connector polling mode, a combination of</p>
<dl class="docutils">
<dt>DRM_CONNECTOR_POLL_HPD</dt>
<dd>The connector generates hotplug events and doesn&#8217;t need to be
periodically polled. The CONNECT and DISCONNECT flags must not
be set together with the HPD flag.</dd>
<dt>DRM_CONNECTOR_POLL_CONNECT</dt>
<dd>Periodically poll the connector for connection.</dd>
<dt>DRM_CONNECTOR_POLL_DISCONNECT</dt>
<dd>Periodically poll the connector for disconnection, without
causing flickering even when the connector is in use. DACs should
rarely do this without a lot of testing.</dd>
</dl>
<p class="last">Set to 0 for connectors that don&#8217;t support connection status
discovery.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">dpms</span></code></dt>
<dd>Current dpms state. For legacy drivers the
<a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.dpms</span></code></a> callback must update this. For atomic
drivers, this is handled by the core atomic code, and drivers must
only take <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.active</span></code></a> into account.</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
<dt><code class="docutils literal"><span class="pre">cmdline_mode</span></code></dt>
<dd>mode line parsed from the kernel cmdline for this connector</dd>
<dt><code class="docutils literal"><span class="pre">force</span></code></dt>
<dd>a DRM_FORCE_&lt;foo&gt; state for forced mode sets</dd>
<dt><code class="docutils literal"><span class="pre">override_edid</span></code></dt>
<dd>has the EDID been overwritten through debugfs for testing?</dd>
<dt><code class="docutils literal"><span class="pre">encoder_ids</span></code></dt>
<dd>Valid encoders for this connector. Please only use
<a class="reference internal" href="#c.drm_connector_for_each_possible_encoder" title="drm_connector_for_each_possible_encoder"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_for_each_possible_encoder()</span></code></a> to enumerate these.</dd>
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>Currently bound encoder driving this connector, if any.
Only really meaningful for non-atomic drivers. Atomic drivers should
instead look at <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_state.best_encoder</span></code></a>, and in case they
need the CRTC driving this output, <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_state.crtc</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">eld</span></code></dt>
<dd>EDID-like data, if present</dd>
<dt><code class="docutils literal"><span class="pre">latency_present</span></code></dt>
<dd>AV delay info from ELD, if found</dd>
<dt><code class="docutils literal"><span class="pre">video_latency</span></code></dt>
<dd>Video latency info from ELD, if found.
[0]: progressive, [1]: interlaced</dd>
<dt><code class="docutils literal"><span class="pre">audio_latency</span></code></dt>
<dd>audio latency info from ELD, if found
[0]: progressive, [1]: interlaced</dd>
<dt><code class="docutils literal"><span class="pre">null_edid_counter</span></code></dt>
<dd>track sinks that give us all zeros for the EDID.
Needed to workaround some HW bugs where we get all 0s</dd>
<dt><code class="docutils literal"><span class="pre">bad_edid_counter</span></code></dt>
<dd>track sinks that give us an EDID with invalid checksum</dd>
<dt><code class="docutils literal"><span class="pre">edid_corrupt</span></code></dt>
<dd>Indicates whether the last read EDID was corrupt. Used
in Displayport compliance testing - Displayport Link CTS Core 1.2
rev1.1 4.2.2.6</dd>
<dt><code class="docutils literal"><span class="pre">debugfs_entry</span></code></dt>
<dd>debugfs directory for this connector</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd><p class="first">Current atomic state for this connector.</p>
<p class="last">This is protected by <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connection_mutex</span></code></a>. Note that
nonblocking atomic commits access the current connector state without
taking locks. Either by going through the <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span></code></a>
pointers, see <a class="reference internal" href="#c.for_each_oldnew_connector_in_state" title="for_each_oldnew_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_oldnew_connector_in_state()</span></code></a>,
<a class="reference internal" href="#c.for_each_old_connector_in_state" title="for_each_old_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_old_connector_in_state()</span></code></a> and
<a class="reference internal" href="#c.for_each_new_connector_in_state" title="for_each_new_connector_in_state"><code class="xref c c-func docutils literal"><span class="pre">for_each_new_connector_in_state()</span></code></a>. Or through careful ordering of
atomic commit operations as implemented in the atomic helpers, see
<a class="reference internal" href="#c.drm_crtc_commit" title="drm_crtc_commit"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc_commit</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">tile_blob_ptr</span></code></dt>
<dd><p class="first">DRM blob property data for the tile property (used mostly by DP MST).
This is meant for screens which are driven through separate display
pipelines represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>, which might not be running with
genlocked clocks. For tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose
the tiling and virtualize both <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> if needed.</p>
<p class="last">This should only be updated by calling
<a class="reference internal" href="#c.drm_connector_set_tile_property" title="drm_connector_set_tile_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_set_tile_property()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">has_tile</span></code></dt>
<dd>is this connector connected to a tiled monitor</dd>
<dt><code class="docutils literal"><span class="pre">tile_group</span></code></dt>
<dd>tile group for the connected monitor</dd>
<dt><code class="docutils literal"><span class="pre">tile_is_single_monitor</span></code></dt>
<dd>whether the tile is one monitor housing</dd>
<dt><code class="docutils literal"><span class="pre">num_h_tile</span></code></dt>
<dd>number of horizontal tiles in the tile group</dd>
<dt><code class="docutils literal"><span class="pre">num_v_tile</span></code></dt>
<dd>number of vertical tiles in the tile group</dd>
<dt><code class="docutils literal"><span class="pre">tile_h_loc</span></code></dt>
<dd>horizontal location of this tile</dd>
<dt><code class="docutils literal"><span class="pre">tile_v_loc</span></code></dt>
<dd>vertical location of this tile</dd>
<dt><code class="docutils literal"><span class="pre">tile_h_size</span></code></dt>
<dd>horizontal size of this tile.</dd>
<dt><code class="docutils literal"><span class="pre">tile_v_size</span></code></dt>
<dd>vertical size of this tile.</dd>
<dt><code class="docutils literal"><span class="pre">free_node</span></code></dt>
<dd>List used only by <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_list_iter</span></code></a> to be able to clean up a
connector from any context, in conjunction with
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connector_free_work</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each connector may be connected to one or more CRTCs, or may be clonable by
another connector if they can share a CRTC.  Each connector also has a specific
position in the broader display (referred to as a &#8216;screen&#8217; though it could
span multiple monitors).</p>
<dl class="function">
<dt id="c.drm_connector_lookup">
struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="descname">drm_connector_lookup</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>lookup connector object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>connector object id</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the connector object specified by id
add takes a reference to it.</p>
<dl class="function">
<dt id="c.drm_connector_get">
void <code class="descname">drm_connector_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function increments the connector&#8217;s refcount.</p>
<dl class="function">
<dt id="c.drm_connector_put">
void <code class="descname">drm_connector_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function decrements the connector&#8217;s reference count and frees the
object if the reference count drops to zero.</p>
<dl class="function">
<dt id="c.drm_connector_reference">
void <code class="descname">drm_connector_reference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_get()</span></code></a> and should not be
used by new code.</p>
<dl class="function">
<dt id="c.drm_connector_unreference">
void <code class="descname">drm_connector_unreference</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_unreference" title="Permalink to this definition">¶</a></dt>
<dd><p>release a connector reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>DRM connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a compatibility alias for <a class="reference internal" href="#c.drm_connector_put" title="drm_connector_put"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_put()</span></code></a> and should not be
used by new code.</p>
<dl class="type">
<dt id="c.drm_tile_group">
struct <code class="descname">drm_tile_group</code><a class="headerlink" href="#c.drm_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Tile group metadata</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_tile_group {
  struct kref refcount;
  struct drm_device *dev;
  int id;
  u8 group_data[8];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>reference count</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>tile group id exposed to userspace</dd>
<dt><code class="docutils literal"><span class="pre">group_data</span></code></dt>
<dd>Sink-private data identifying this group</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>group_data</strong> corresponds to displayid vend/prod/serial for external screens
with an EDID.</p>
<dl class="type">
<dt id="c.drm_connector_list_iter">
struct <code class="descname">drm_connector_list_iter</code><a class="headerlink" href="#c.drm_connector_list_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>connector_list iterator</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_connector_list_iter {
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<p><strong>Description</strong></p>
<p>This iterator tracks state needed to be able to walk the connector_list
within struct drm_mode_config. Only use together with
<a class="reference internal" href="#c.drm_connector_list_iter_begin" title="drm_connector_list_iter_begin"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_begin()</span></code></a>, <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_end()</span></code></a> and
<a class="reference internal" href="#c.drm_connector_list_iter_next" title="drm_connector_list_iter_next"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_next()</span></code></a> respectively the convenience macro
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_connector_iter">
<code class="descname">drm_for_each_connector_iter</code><span class="sig-paren">(</span><em>connector</em>, <em>iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_connector_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>connector_list iterator macro</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> pointer used as cursor</dd>
<dt><code class="docutils literal"><span class="pre">iter</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that <strong>connector</strong> is only valid within the list body, if you want to use
<strong>connector</strong> after calling <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_end()</span></code></a> then you need to grab
your own reference first using <a class="reference internal" href="#c.drm_connector_get" title="drm_connector_get"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_get()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_connector_for_each_possible_encoder">
<code class="descname">drm_connector_for_each_possible_encoder</code><span class="sig-paren">(</span><em>connector</em>, <em>encoder</em>, <em>__i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_for_each_possible_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate connector&#8217;s possible encoders</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">connector</span></code></dt>
<dd><a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a> pointer</dd>
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd><a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span></code></a> pointer used as cursor</dd>
<dt><code class="docutils literal"><span class="pre">__i</span></code></dt>
<dd>int iteration cursor, for macro-internal use</dd>
</dl>
<dl class="function">
<dt id="c.drm_connector_init">
int <code class="descname">drm_connector_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const struct <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs">drm_connector_funcs</a> *<em>&nbsp;funcs</em>, int<em>&nbsp;connector_type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Init a preallocated connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector to init</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for this connector</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">connector_type</span></code></dt>
<dd>user visible type of the connector</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated connector. Connectors should be
subclassed as part of driver connector objects.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_connector_attach_encoder">
int <code class="descname">drm_connector_attach_encoder</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>attach a connector to an encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to attach</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to attach <strong>connector</strong> to</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function links up a connector to an encoder. Note that the routing
restrictions between encoders and crtcs are exposed to userspace through the
possible_clones and possible_crtcs bitmasks.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_connector_has_possible_encoder">
bool <code class="descname">drm_connector_has_possible_encoder</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_has_possible_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the connector and encoder are assosicated with each other</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>the encoder</dd>
</dl>
<p><strong>Return</strong></p>
<p>True if <strong>encoder</strong> is one of the possible encoders for <strong>connector</strong>.</p>
<dl class="function">
<dt id="c.drm_connector_cleanup">
void <code class="descname">drm_connector_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up an initialised connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up the connector but doesn&#8217;t free the object.</p>
<dl class="function">
<dt id="c.drm_connector_register">
int <code class="descname">drm_connector_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register userspace interfaces for a connector</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_connector_unregister">
void <code class="descname">drm_connector_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>the connector to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister userspace interfaces for a connector</p>
<dl class="function">
<dt id="c.drm_get_connector_status_name">
const char * <code class="descname">drm_get_connector_status_name</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.drm_connector_status" title="drm_connector_status">drm_connector_status</a><em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_connector_status_name" title="Permalink to this definition">¶</a></dt>
<dd><p>return a string for connector status</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_connector_status</span> <span class="pre">status</span></code></dt>
<dd>connector status to compute name of</dd>
</dl>
<p><strong>Description</strong></p>
<p>In contrast to the other drm_get_*_name functions this one here returns a
const pointer and hence is threadsafe.</p>
<dl class="function">
<dt id="c.drm_connector_list_iter_begin">
void <code class="descname">drm_connector_list_iter_begin</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_begin" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a connector_list iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>connector_list iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <strong>iter</strong> up to walk the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.connector_list</span></code></a> of <strong>dev</strong>. <strong>iter</strong>
must always be cleaned up again by calling <a class="reference internal" href="#c.drm_connector_list_iter_end" title="drm_connector_list_iter_end"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_end()</span></code></a>.
Iteration itself happens using <a class="reference internal" href="#c.drm_connector_list_iter_next" title="drm_connector_list_iter_next"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_list_iter_next()</span></code></a> or
<a class="reference internal" href="#c.drm_for_each_connector_iter" title="drm_for_each_connector_iter"><code class="xref c c-func docutils literal"><span class="pre">drm_for_each_connector_iter()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_connector_list_iter_next">
struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> * <code class="descname">drm_connector_list_iter_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_next" title="Permalink to this definition">¶</a></dt>
<dd><p>return next connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>connector_list iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the next connector for <strong>iter</strong>, or NULL when the list walk has
completed.</p>
<dl class="function">
<dt id="c.drm_connector_list_iter_end">
void <code class="descname">drm_connector_list_iter_end</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector_list_iter" title="drm_connector_list_iter">drm_connector_list_iter</a> *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_list_iter_end" title="Permalink to this definition">¶</a></dt>
<dd><p>tear down a connector_list iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector_list_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>connector_list iterator</dd>
</dl>
<p><strong>Description</strong></p>
<p>Tears down <strong>iter</strong> and releases any resources (like <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> references)
acquired while walking the list. This must always be called, both when the
iteration completes fully or when it was aborted without walking the entire
list.</p>
<dl class="function">
<dt id="c.drm_get_subpixel_order_name">
const char * <code class="descname">drm_get_subpixel_order_name</code><span class="sig-paren">(</span>enum subpixel_order<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_get_subpixel_order_name" title="Permalink to this definition">¶</a></dt>
<dd><p>return a string for a given subpixel enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">subpixel_order</span> <span class="pre">order</span></code></dt>
<dd>enum of subpixel_order</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note you could abuse this and return something out of bounds, but that
would be a caller error.  No unscrubbed user data should make it here.</p>
<dl class="function">
<dt id="c.drm_display_info_set_bus_formats">
int <code class="descname">drm_display_info_set_bus_formats</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_display_info" title="drm_display_info">drm_display_info</a> *<em>&nbsp;info</em>, const u32 *<em>&nbsp;formats</em>, unsigned int<em>&nbsp;num_formats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_display_info_set_bus_formats" title="Permalink to this definition">¶</a></dt>
<dd><p>set the supported bus formats</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_display_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>display info to store bus formats in</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt>
<dd>array containing the supported bus formats</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_formats</span></code></dt>
<dd>the number of entries in the fmts array</dd>
</dl>
<p><strong>Description</strong></p>
<p>Store the supported bus formats in display info structure.
See MEDIA_BUS_FMT_* definitions in include/uapi/linux/media-bus-format.h for
a full list of available formats.</p>
<dl class="function">
<dt id="c.drm_mode_create_dvi_i_properties">
int <code class="descname">drm_mode_create_dvi_i_properties</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_dvi_i_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>create DVI-I specific connector properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time a DVI-I connector is made.</p>
<dl class="function">
<dt id="c.drm_connector_attach_content_type_property">
int <code class="descname">drm_connector_attach_content_type_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_content_type_property" title="Permalink to this definition">¶</a></dt>
<dd><p>attach content-type property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to attach content type property on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time a HDMI connector is made.</p>
<dl class="function">
<dt id="c.drm_hdmi_avi_infoframe_content_type">
void <code class="descname">drm_hdmi_avi_infoframe_content_type</code><span class="sig-paren">(</span>struct hdmi_avi_infoframe *<em>&nbsp;frame</em>, const struct <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state">drm_connector_state</a> *<em>&nbsp;conn_state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_hdmi_avi_infoframe_content_type" title="Permalink to this definition">¶</a></dt>
<dd><p>fill the HDMI AVI infoframe content type information, based on correspondent DRM property.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hdmi_avi_infoframe</span> <span class="pre">*</span> <span class="pre">frame</span></code></dt>
<dd>HDMI AVI infoframe</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_state</span> <span class="pre">*</span> <span class="pre">conn_state</span></code></dt>
<dd>DRM display connector state</dd>
</dl>
<dl class="function">
<dt id="c.drm_mode_create_tv_properties">
int <code class="descname">drm_mode_create_tv_properties</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;num_modes</em>, const char *const<em>&nbsp;modes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_tv_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>create TV specific connector properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_modes</span></code></dt>
<dd>number of different TV formats (modes) supported</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*const</span> <span class="pre">modes</span></code></dt>
<dd>array of pointers to strings containing name of each format</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver&#8217;s TV initialization routine, this function creates
the TV specific connector properties for a given device.  Caller is
responsible for allocating a list of format names and passing them to
this routine.</p>
<dl class="function">
<dt id="c.drm_mode_create_scaling_mode_property">
int <code class="descname">drm_mode_create_scaling_mode_property</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_scaling_mode_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create scaling mode property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it&#8217;s needed, must be attached to desired
connectors.</p>
<p>Atomic drivers should use <a class="reference internal" href="#c.drm_connector_attach_scaling_mode_property" title="drm_connector_attach_scaling_mode_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_attach_scaling_mode_property()</span></code></a>
instead to correctly assign <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_state.picture_aspect_ratio</span></code></a>
in the atomic state.</p>
<dl class="function">
<dt id="c.drm_connector_attach_scaling_mode_property">
int <code class="descname">drm_connector_attach_scaling_mode_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, u32<em>&nbsp;scaling_mode_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_scaling_mode_property" title="Permalink to this definition">¶</a></dt>
<dd><p>attach atomic scaling mode property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to attach scaling mode property on.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">scaling_mode_mask</span></code></dt>
<dd>or&#8217;ed mask of BIT(<code class="docutils literal"><span class="pre">DRM_MODE_SCALE_</span></code>*).</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to add support for scaling mode to atomic drivers.
The scaling mode will be set to <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_state.picture_aspect_ratio</span></code></a>
and can be used from <a class="reference internal" href="drm-kms-helpers.html#c.drm_connector_helper_funcs" title="drm_connector_helper_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_helper_funcs-&gt;atomic_check</span></code></a> for validation.</p>
<p>This is the atomic version of <a class="reference internal" href="#c.drm_mode_create_scaling_mode_property" title="drm_mode_create_scaling_mode_property"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create_scaling_mode_property()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_connector_attach_content_protection_property">
int <code class="descname">drm_connector_attach_content_protection_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_attach_content_protection_property" title="Permalink to this definition">¶</a></dt>
<dd><p>attach content protection property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to attach CP property on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to add support for content protection on select connectors.
Content Protection is intentionally vague to allow for different underlying
technologies, however it is most implemented by HDCP.</p>
<p>The content protection will be set to <a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_state.content_protection</span></code></a></p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_create_aspect_ratio_property">
int <code class="descname">drm_mode_create_aspect_ratio_property</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_aspect_ratio_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create aspect ratio property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it&#8217;s needed, must be attached to desired
connectors.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_create_content_type_property">
int <code class="descname">drm_mode_create_content_type_property</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_content_type_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create content type property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Called by a driver the first time it&#8217;s needed, must be attached to desired
connectors.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_create_suggested_offset_properties">
int <code class="descname">drm_mode_create_suggested_offset_properties</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_suggested_offset_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>create suggests offset properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create the the suggested x/y offset property for connectors.</p>
<dl class="function">
<dt id="c.drm_connector_set_path_property">
int <code class="descname">drm_connector_set_path_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const char *<em>&nbsp;path</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_path_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set tile property on connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to set property on.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">path</span></code></dt>
<dd>path to use for property; must not be NULL.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a property to expose to userspace to specify a
connector path. This is mainly used for DisplayPort MST where
connectors have a topology and we want to allow userspace to give
them more meaningful names.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_connector_set_tile_property">
int <code class="descname">drm_connector_set_tile_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_tile_property" title="Permalink to this definition">¶</a></dt>
<dd><p>set tile property on connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector to set property on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This looks up the tile information for a connector, and creates a
property for userspace to parse if it exists. The property is of
the form of 8 integers using &#8216;:&#8217; as a separator.</p>
<p><strong>Return</strong></p>
<p>Zero on success, errno on failure.</p>
<dl class="function">
<dt id="c.drm_connector_update_edid_property">
int <code class="descname">drm_connector_update_edid_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, const struct edid *<em>&nbsp;edid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_update_edid_property" title="Permalink to this definition">¶</a></dt>
<dd><p>update the edid property of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">edid</span> <span class="pre">*</span> <span class="pre">edid</span></code></dt>
<dd>new value of the edid property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a new blob modeset object and assigns its id to the
connector&#8217;s edid property.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_connector_set_link_status_property">
void <code class="descname">drm_connector_set_link_status_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, uint64_t<em>&nbsp;link_status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_set_link_status_property" title="Permalink to this definition">¶</a></dt>
<dd><p>Set link status property of a connector</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>drm connector</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">link_status</span></code></dt>
<dd>new value of link status property (0: Good, 1: Bad)</dd>
</dl>
<p><strong>Description</strong></p>
<p>In usual working scenario, this link status property will always be set to
&#8220;GOOD&#8221;. If something fails during or after a mode set, the kernel driver
may set this link status property to &#8220;BAD&#8221;. The caller then needs to send a
hotplug uevent for userspace to re-check the valid modes through
GET_CONNECTOR_IOCTL and retry modeset.</p>
<p><strong>Note</strong></p>
<p>Drivers cannot rely on userspace to support this property and
issue a modeset. As such, they may choose to handle issues (like
re-training a link) without userspace&#8217;s intervention.</p>
<p>The reason for adding this property is to handle link training failures, but
it is not limited to DP or link training. For example, if we implement
asynchronous setcrtc, this property can be used to report any failures in that.</p>
<dl class="function">
<dt id="c.drm_connector_init_panel_orientation_property">
int <code class="descname">drm_connector_init_panel_orientation_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_connector" title="drm_connector">drm_connector</a> *<em>&nbsp;connector</em>, int<em>&nbsp;width</em>, int<em>&nbsp;height</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_connector_init_panel_orientation_property" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the connecters panel_orientation property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span> <span class="pre">*</span> <span class="pre">connector</span></code></dt>
<dd>connector for which to init the panel-orientation property.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">width</span></code></dt>
<dd>width in pixels of the panel, used for panel quirk detection</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">height</span></code></dt>
<dd>height in pixels of the panel, used for panel quirk detection</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should only be called for built-in panels, after setting
connector-&gt;display_info.panel_orientation first (if known).</p>
<p>This function will check for platform specific (e.g. DMI based) quirks
overriding display_info.panel_orientation first, then if panel_orientation
is not DRM_MODE_PANEL_ORIENTATION_UNKNOWN it will attach the
&#8220;panel orientation&#8221; property to the connector.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_mode_put_tile_group">
void <code class="descname">drm_mode_put_tile_group</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> *<em>&nbsp;tg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_put_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>drop a reference to a tile group.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_tile_group</span> <span class="pre">*</span> <span class="pre">tg</span></code></dt>
<dd>tile group to drop reference to.</dd>
</dl>
<p><strong>Description</strong></p>
<p>drop reference to tile group and free if 0.</p>
<dl class="function">
<dt id="c.drm_mode_get_tile_group">
struct <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> * <code class="descname">drm_mode_get_tile_group</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, char<em>&nbsp;topology</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_get_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference to an existing tile group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">topology</span></code></dt>
<dd>8-bytes unique per monitor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use the unique bytes to get a reference to an existing tile group.</p>
<p><strong>Return</strong></p>
<p>tile group or NULL if not found.</p>
<dl class="function">
<dt id="c.drm_mode_create_tile_group">
struct <a class="reference internal" href="#c.drm_tile_group" title="drm_tile_group">drm_tile_group</a> * <code class="descname">drm_mode_create_tile_group</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, char<em>&nbsp;topology</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_create_tile_group" title="Permalink to this definition">¶</a></dt>
<dd><p>create a tile group from a displayid description</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">topology</span></code></dt>
<dd>8-bytes unique per monitor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a tile group for the unique monitor, and get a unique
identifier for the tile group.</p>
<p><strong>Return</strong></p>
<p>new tile group or error.</p>
</div>
<div class="section" id="writeback-connectors">
<h3>Writeback Connectors<a class="headerlink" href="#writeback-connectors" title="Permalink to this headline">¶</a></h3>
<p>Writeback connectors are used to expose hardware which can write the output
from a CRTC to a memory buffer. They are used and act similarly to other
types of connectors, with some important differences:</p>
<ul class="simple">
<li>Writeback connectors don&#8217;t provide a way to output visually to the user.</li>
<li>Writeback connectors are visible to userspace only when the client sets
DRM_CLIENT_CAP_WRITEBACK_CONNECTORS.</li>
<li>Writeback connectors don&#8217;t have EDID.</li>
</ul>
<p>A framebuffer may only be attached to a writeback connector when the
connector is attached to a CRTC. The WRITEBACK_FB_ID property which sets the
framebuffer applies only to a single commit (see below). A framebuffer may
not be attached while the CRTC is off.</p>
<p>Unlike with planes, when a writeback framebuffer is removed by userspace DRM
makes no attempt to remove it from active use by the connector. This is
because no method is provided to abort a writeback operation, and in any
case making a new commit whilst a writeback is ongoing is undefined (see
WRITEBACK_OUT_FENCE_PTR below). As soon as the current writeback is finished,
the framebuffer will automatically no longer be in active use. As it will
also have already been removed from the framebuffer list, there will be no
way for any userspace application to retrieve a reference to it in the
intervening period.</p>
<p>Writeback connectors have some additional properties, which userspace
can use to query and control them:</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8220;WRITEBACK_FB_ID&#8221;:</dt>
<dd>Write-only object property storing a DRM_MODE_OBJECT_FB: it stores the
framebuffer to be written by the writeback connector. This property is
similar to the FB_ID property on planes, but will always read as zero
and is not preserved across commits.
Userspace must set this property to an output buffer every time it
wishes the buffer to get filled.</dd>
<dt>&#8220;WRITEBACK_PIXEL_FORMATS&#8221;:</dt>
<dd>Immutable blob property to store the supported pixel formats table. The
data is an array of u32 DRM_FORMAT_* fourcc values.
Userspace can use this blob to find out what pixel formats are supported
by the connector&#8217;s writeback engine.</dd>
<dt>&#8220;WRITEBACK_OUT_FENCE_PTR&#8221;:</dt>
<dd>Userspace can use this property to provide a pointer for the kernel to
fill with a sync_file file descriptor, which will signal once the
writeback is finished. The value should be the address of a 32-bit
signed integer, cast to a u64.
Userspace should wait for this fence to signal before making another
commit affecting any of the same CRTCs, Planes or Connectors.
<strong>Failure to do so will result in undefined behaviour.</strong>
For this reason it is strongly recommended that all userspace
applications making use of writeback connectors <em>always</em> retrieve an
out-fence for the commit and use it appropriately.
From userspace, this property will always read as zero.</dd>
</dl>
</div></blockquote>
<dl class="function">
<dt id="c.drm_writeback_connector_init">
int <code class="descname">drm_writeback_connector_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct drm_writeback_connector *<em>&nbsp;wb_connector</em>, const struct <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs">drm_connector_funcs</a> *<em>&nbsp;con_funcs</em>, const struct <a class="reference internal" href="drm-kms-helpers.html#c.drm_encoder_helper_funcs" title="drm_encoder_helper_funcs">drm_encoder_helper_funcs</a> *<em>&nbsp;enc_helper_funcs</em>, const u32 *<em>&nbsp;formats</em>, int<em>&nbsp;n_formats</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_writeback_connector_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a writeback connector and its properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_writeback_connector</span> <span class="pre">*</span> <span class="pre">wb_connector</span></code></dt>
<dd>Writeback connector to initialize</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_connector_funcs</span> <span class="pre">*</span> <span class="pre">con_funcs</span></code></dt>
<dd>Connector funcs vtable</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_helper_funcs</span> <span class="pre">*</span> <span class="pre">enc_helper_funcs</span></code></dt>
<dd>Encoder helper funcs vtable to be used by the internal encoder</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">*</span> <span class="pre">formats</span></code></dt>
<dd>Array of supported pixel formats for the writeback engine</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">n_formats</span></code></dt>
<dd>Length of the formats array</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates the writeback-connector-specific properties if they
have not been already created, initializes the connector as
type DRM_MODE_CONNECTOR_WRITEBACK, and correctly initializes the property
values. It will also create an internal encoder associated with the
drm_writeback_connector and set it to use the <strong>enc_helper_funcs</strong> vtable for
the encoder helper.</p>
<p>Drivers should always use this function instead of <a class="reference internal" href="#c.drm_connector_init" title="drm_connector_init"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_init()</span></code></a> to
set up writeback connectors.</p>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error code</p>
<dl class="function">
<dt id="c.drm_writeback_queue_job">
void <code class="descname">drm_writeback_queue_job</code><span class="sig-paren">(</span>struct drm_writeback_connector *<em>&nbsp;wb_connector</em>, struct drm_writeback_job *<em>&nbsp;job</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_writeback_queue_job" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a writeback job for later signalling</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_writeback_connector</span> <span class="pre">*</span> <span class="pre">wb_connector</span></code></dt>
<dd>The writeback connector to queue a job on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_writeback_job</span> <span class="pre">*</span> <span class="pre">job</span></code></dt>
<dd>The job to queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function adds a job to the job_queue for a writeback connector. It
should be considered to take ownership of the writeback job, and so any other
references to the job must be cleared after calling this function.</p>
<p>Drivers must ensure that for a given writeback connector, jobs are queued in
exactly the same order as they will be completed by the hardware (and
signaled via drm_writeback_signal_completion).</p>
<p>For every call to <a class="reference internal" href="#c.drm_writeback_queue_job" title="drm_writeback_queue_job"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_queue_job()</span></code></a> there must be exactly one call to
<a class="reference internal" href="#c.drm_writeback_signal_completion" title="drm_writeback_signal_completion"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_signal_completion()</span></code></a></p>
<p>See also: <a class="reference internal" href="#c.drm_writeback_signal_completion" title="drm_writeback_signal_completion"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_signal_completion()</span></code></a></p>
<dl class="function">
<dt id="c.drm_writeback_signal_completion">
void <code class="descname">drm_writeback_signal_completion</code><span class="sig-paren">(</span>struct drm_writeback_connector *<em>&nbsp;wb_connector</em>, int<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_writeback_signal_completion" title="Permalink to this definition">¶</a></dt>
<dd><p>Signal the completion of a writeback job</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_writeback_connector</span> <span class="pre">*</span> <span class="pre">wb_connector</span></code></dt>
<dd>The writeback connector whose job is complete</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">status</span></code></dt>
<dd>Status code to set in the writeback out_fence (0 for success)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should call this to signal the completion of a previously queued
writeback job. It should be called as soon as possible after the hardware
has finished writing, and may be called from interrupt context.
It is the driver&#8217;s responsibility to ensure that for a given connector, the
hardware completes writeback jobs in the same order as they are queued.</p>
<p>Unless the driver is holding its own reference to the framebuffer, it must
not be accessed after calling this function.</p>
<p>See also: <a class="reference internal" href="#c.drm_writeback_queue_job" title="drm_writeback_queue_job"><code class="xref c c-func docutils literal"><span class="pre">drm_writeback_queue_job()</span></code></a></p>
</div>
</div>
<div class="section" id="encoder-abstraction">
<h2>Encoder Abstraction<a class="headerlink" href="#encoder-abstraction" title="Permalink to this headline">¶</a></h2>
<p>Encoders represent the connecting element between the CRTC (as the overall
pixel pipeline, represented by <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>) and the connectors (as the
generic sink entity, represented by <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_connector</span></code></a>). An encoder takes
pixel data from a CRTC and converts it to a format suitable for any attached
connector. Encoders are objects exposed to userspace, originally to allow
userspace to infer cloning and connector/CRTC restrictions. Unfortunately
almost all drivers get this wrong, making the uabi pretty much useless. On
top of that the exposed restrictions are too simple for today&#8217;s hardware, and
the recommended way to infer restrictions is by using the
DRM_MODE_ATOMIC_TEST_ONLY flag for the atomic IOCTL.</p>
<p>Otherwise encoders aren&#8217;t used in the uapi at all (any modeset request from
userspace directly connects a connector with a CRTC), drivers are therefore
free to use them however they wish. Modeset helper libraries make strong use
of encoders to facilitate code sharing. But for more complex settings it is
usually better to move shared code into a separate <a class="reference internal" href="drm-kms-helpers.html#c.drm_bridge" title="drm_bridge"><code class="xref c c-type docutils literal"><span class="pre">drm_bridge</span></code></a>. Compared to
encoders, bridges also have the benefit of being purely an internal
abstraction since they are not exposed to userspace at all.</p>
<p>Encoders are initialized with <a class="reference internal" href="#c.drm_encoder_init" title="drm_encoder_init"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_init()</span></code></a> and cleaned up using
<a class="reference internal" href="#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_cleanup()</span></code></a>.</p>
<div class="section" id="encoder-functions-reference">
<h3>Encoder Functions Reference<a class="headerlink" href="#encoder-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_encoder_funcs">
struct <code class="descname">drm_encoder_funcs</code><a class="headerlink" href="#c.drm_encoder_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>encoder controls</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_encoder_funcs {
  void (*reset)(struct drm_encoder *encoder);
  void (*destroy)(struct drm_encoder *encoder);
  int (*late_register)(struct drm_encoder *encoder);
  void (*early_unregister)(struct drm_encoder *encoder);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">reset</span></code></dt>
<dd>Reset encoder hardware and software state to off. This function isn&#8217;t
called by the core directly, only through <a class="reference internal" href="#c.drm_mode_config_reset" title="drm_mode_config_reset"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_reset()</span></code></a>.
It&#8217;s not a helper hook only for historical reasons.</dd>
<dt><code class="docutils literal"><span class="pre">destroy</span></code></dt>
<dd>Clean up encoder resources. This is only called at driver unload time
through <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a> since an encoder cannot be
hotplugged in DRM.</dd>
<dt><code class="docutils literal"><span class="pre">late_register</span></code></dt>
<dd><p class="first">This optional hook can be used to register additional userspace
interfaces attached to the encoder like debugfs interfaces.
It is called late in the driver load sequence from <a class="reference internal" href="drm-internals.html#c.drm_dev_register" title="drm_dev_register"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_register()</span></code></a>.
Everything added from this callback should be unregistered in
the early_unregister callback.</p>
<p>Returns:</p>
<p class="last">0 on success, or a negative error code on failure.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">early_unregister</span></code></dt>
<dd>This optional hook should be used to unregister the additional
userspace interfaces attached to the encoder from
<strong>late_register</strong>. It is called from <a class="reference internal" href="drm-internals.html#c.drm_dev_unregister" title="drm_dev_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_unregister()</span></code></a>,
early in the driver unload sequence to disable userspace access
before data structures are torndown.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Encoders sit between CRTCs and connectors.</p>
<dl class="type">
<dt id="c.drm_encoder">
struct <code class="descname">drm_encoder</code><a class="headerlink" href="#c.drm_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>central DRM encoder structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_encoder {
  struct drm_device *dev;
  struct list_head head;
  struct drm_mode_object base;
  char *name;
  int encoder_type;
  unsigned index;
  uint32_t possible_crtcs;
  uint32_t possible_clones;
  struct drm_crtc *crtc;
  struct drm_bridge *bridge;
  const struct drm_encoder_funcs *funcs;
  const struct drm_encoder_helper_funcs *helper_private;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>parent DRM device</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list management</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>human readable name, can be overwritten by the driver</dd>
<dt><code class="docutils literal"><span class="pre">encoder_type</span></code></dt>
<dd><p class="first">One of the DRM_MODE_ENCODER_&lt;foo&gt; types in drm_mode.h. The following
encoder types are defined thus far:</p>
<ul class="last simple">
<li>DRM_MODE_ENCODER_DAC for VGA and analog on DVI-I/DVI-A.</li>
<li>DRM_MODE_ENCODER_TMDS for DVI, HDMI and (embedded) DisplayPort.</li>
<li>DRM_MODE_ENCODER_LVDS for display panels, or in general any panel
with a proprietary parallel connector.</li>
<li>DRM_MODE_ENCODER_TVDAC for TV output (Composite, S-Video,
Component, SCART).</li>
<li>DRM_MODE_ENCODER_VIRTUAL for virtual machine displays</li>
<li>DRM_MODE_ENCODER_DSI for panels connected using the DSI serial bus.</li>
<li>DRM_MODE_ENCODER_DPI for panels connected using the DPI parallel
bus.</li>
<li>DRM_MODE_ENCODER_DPMST for special fake encoders used to allow
mutliple DP MST streams to share one physical encoder.</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Position inside the mode_config.list, can be used as an array
index. It is invariant over the lifetime of the encoder.</dd>
<dt><code class="docutils literal"><span class="pre">possible_crtcs</span></code></dt>
<dd><p class="first">Bitmask of potential CRTC bindings, using
<a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> as the index into the bitfield. The driver must set
the bits for all <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> objects this encoder can be connected to
before calling <a class="reference internal" href="#c.drm_encoder_init" title="drm_encoder_init"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_init()</span></code></a>.</p>
<p>In reality almost every driver gets this wrong.</p>
<p class="last">Note that since CRTC objects can&#8217;t be hotplugged the assigned indices
are stable and hence known before registering all objects.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">possible_clones</span></code></dt>
<dd><p class="first">Bitmask of potential sibling encoders for cloning,
using <a class="reference internal" href="#c.drm_encoder_index" title="drm_encoder_index"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_index()</span></code></a> as the index into the bitfield. The driver
must set the bits for all <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a> objects which can clone a
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> together with this encoder before calling
<a class="reference internal" href="#c.drm_encoder_init" title="drm_encoder_init"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_init()</span></code></a>. Drivers should set the bit representing the
encoder itself, too. Cloning bits should be set such that when two
encoders can be used in a cloned configuration, they both should have
each another bits set.</p>
<p>In reality almost every driver gets this wrong.</p>
<p class="last">Note that since encoder objects can&#8217;t be hotplugged the assigned indices
are stable and hence known before registering all objects.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">crtc</span></code></dt>
<dd>Currently bound CRTC, only really meaningful for non-atomic
drivers.  Atomic drivers should instead check
<a class="reference internal" href="#c.drm_connector_state" title="drm_connector_state"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_state.crtc</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">bridge</span></code></dt>
<dd>bridge associated to the encoder</dd>
<dt><code class="docutils literal"><span class="pre">funcs</span></code></dt>
<dd>control functions</dd>
<dt><code class="docutils literal"><span class="pre">helper_private</span></code></dt>
<dd>mid-layer private data</dd>
</dl>
<p><strong>Description</strong></p>
<p>CRTCs drive pixels to encoders, which convert them into signals
appropriate for a given connector or set of connectors.</p>
<dl class="function">
<dt id="c.drm_encoder_index">
unsigned int <code class="descname">drm_encoder_index</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_index" title="Permalink to this definition">¶</a></dt>
<dd><p>find the index of a registered encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to find index for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered encoder, return the index of that encoder within a DRM
device&#8217;s list of encoders.</p>
<dl class="function">
<dt id="c.drm_encoder_mask">
u32 <code class="descname">drm_encoder_mask</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>find the mask of a registered ENCODER</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to find mask for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Given a registered encoder, return the mask bit of that encoder for an
encoder&#8217;s possible_clones field.</p>
<dl class="function">
<dt id="c.drm_encoder_crtc_ok">
bool <code class="descname">drm_encoder_crtc_ok</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em>, struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_crtc_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>can a given crtc drive a given encoder?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to test</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>crtc to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns false if <strong>encoder</strong> can&#8217;t be driven by <strong>crtc</strong>, true otherwise.</p>
<dl class="function">
<dt id="c.drm_encoder_find">
struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> * <code class="descname">drm_encoder_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find a <a class="reference internal" href="#c.drm_encoder" title="drm_encoder"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>encoder id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns the encoder with <strong>id</strong>, NULL if it doesn&#8217;t exist. Simple wrapper around
<a class="reference internal" href="#c.drm_mode_object_find" title="drm_mode_object_find"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_object_find()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_for_each_encoder_mask">
<code class="descname">drm_for_each_encoder_mask</code><span class="sig-paren">(</span><em>encoder</em>, <em>dev</em>, <em>encoder_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_encoder_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over encoders specified by bitmask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
<dt><code class="docutils literal"><span class="pre">encoder_mask</span></code></dt>
<dd>bitmask of encoder indices</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all encoders specified by bitmask.</p>
<dl class="function">
<dt id="c.drm_for_each_encoder">
<code class="descname">drm_for_each_encoder</code><span class="sig-paren">(</span><em>encoder</em>, <em>dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_for_each_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>iterate over all encoders</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">encoder</span></code></dt>
<dd>the loop cursor</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>the DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over all encoders of <strong>dev</strong>.</p>
<dl class="function">
<dt id="c.drm_encoder_init">
int <code class="descname">drm_encoder_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em>, const struct <a class="reference internal" href="#c.drm_encoder_funcs" title="drm_encoder_funcs">drm_encoder_funcs</a> *<em>&nbsp;funcs</em>, int<em>&nbsp;encoder_type</em>, const char *<em>&nbsp;name</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Init a preallocated encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>the encoder to init</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_encoder_funcs</span> <span class="pre">*</span> <span class="pre">funcs</span></code></dt>
<dd>callbacks for this encoder</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">encoder_type</span></code></dt>
<dd>user visible type of the encoder</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>printf style format string for the encoder name, or NULL for default name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialises a preallocated encoder. Encoder should be subclassed as part of
driver encoder objects. At driver unload time <a class="reference internal" href="#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_cleanup()</span></code></a> should be
called from the driver&#8217;s <a class="reference internal" href="#c.drm_encoder_funcs" title="drm_encoder_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_encoder_funcs.destroy</span></code></a> hook.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_encoder_cleanup">
void <code class="descname">drm_encoder_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_encoder" title="drm_encoder">drm_encoder</a> *<em>&nbsp;encoder</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_encoder_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>cleans up an initialised encoder</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_encoder</span> <span class="pre">*</span> <span class="pre">encoder</span></code></dt>
<dd>encoder to cleanup</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cleans up the encoder but doesn&#8217;t free the object.</p>
</div>
</div>
<div class="section" id="kms-initialization-and-cleanup">
<h2>KMS Initialization and Cleanup<a class="headerlink" href="#kms-initialization-and-cleanup" title="Permalink to this headline">¶</a></h2>
<p>A KMS device is abstracted and exposed as a set of planes, CRTCs,
encoders and connectors. KMS drivers must thus create and initialize all
those objects at load time after initializing mode setting.</p>
<div class="section" id="crtcs-struct-drm-crtc">
<h3>CRTCs (<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>)<a class="headerlink" href="#crtcs-struct-drm-crtc" title="Permalink to this headline">¶</a></h3>
<p>A CRTC is an abstraction representing a part of the chip that contains a
pointer to a scanout buffer. Therefore, the number of CRTCs available
determines how many independent scanout buffers can be active at any
given time. The CRTC structure contains several fields to support this:
a pointer to some video memory (abstracted as a frame buffer object), a
display mode, and an (x, y) offset into the video memory to support
panning or configurations where one piece of video memory spans multiple
CRTCs.</p>
<div class="section" id="crtc-initialization">
<h4>CRTC Initialization<a class="headerlink" href="#crtc-initialization" title="Permalink to this headline">¶</a></h4>
<p>A KMS device must create and register at least one struct
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> instance. The instance is
allocated and zeroed by the driver, possibly as part of a larger
structure, and registered with a call to <a class="reference internal" href="drm-kms-helpers.html#c.drm_crtc_init" title="drm_crtc_init"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_init()</span></code></a>
with a pointer to CRTC functions.</p>
</div>
</div>
<div class="section" id="cleanup">
<h3>Cleanup<a class="headerlink" href="#cleanup" title="Permalink to this headline">¶</a></h3>
<p>The DRM core manages its objects&#8217; lifetime. When an object is not needed
anymore the core calls its destroy function, which must clean up and
free every resource allocated for the object. Every
<code class="xref c c-func docutils literal"><span class="pre">drm_*_init()</span></code> call must be matched with a corresponding
<code class="xref c c-func docutils literal"><span class="pre">drm_*_cleanup()</span></code> call to cleanup CRTCs
(<a class="reference internal" href="#c.drm_crtc_cleanup" title="drm_crtc_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_cleanup()</span></code></a>), planes
(<a class="reference internal" href="#c.drm_plane_cleanup" title="drm_plane_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_cleanup()</span></code></a>), encoders
(<a class="reference internal" href="#c.drm_encoder_cleanup" title="drm_encoder_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_encoder_cleanup()</span></code></a>) and connectors
(<a class="reference internal" href="#c.drm_connector_cleanup" title="drm_connector_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_cleanup()</span></code></a>). Furthermore, connectors that
have been added to sysfs must be removed by a call to
<a class="reference internal" href="#c.drm_connector_unregister" title="drm_connector_unregister"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_unregister()</span></code></a> before calling
<a class="reference internal" href="#c.drm_connector_cleanup" title="drm_connector_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_cleanup()</span></code></a>.</p>
<p>Connectors state change detection must be cleanup up with a call to
<a class="reference internal" href="drm-kms-helpers.html#c.drm_kms_helper_poll_fini" title="drm_kms_helper_poll_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_kms_helper_poll_fini()</span></code></a>.</p>
</div>
<div class="section" id="output-discovery-and-initialization-example">
<h3>Output discovery and initialization example<a class="headerlink" href="#output-discovery-and-initialization-example" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">intel_crt_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">drm_connector</span> <span class="o">*</span><span class="n">connector</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">intel_output</span> <span class="o">*</span><span class="n">intel_output</span><span class="p">;</span>

    <span class="n">intel_output</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">intel_output</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_output</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">connector</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="n">drm_connector_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
               <span class="o">&amp;</span><span class="n">intel_crt_connector_funcs</span><span class="p">,</span> <span class="n">DRM_MODE_CONNECTOR_VGA</span><span class="p">);</span>

    <span class="n">drm_encoder_init</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_enc_funcs</span><span class="p">,</span>
             <span class="n">DRM_MODE_ENCODER_DAC</span><span class="p">);</span>

    <span class="n">drm_connector_attach_encoder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
                      <span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">);</span>

    <span class="cm">/* Set up the DDC bus. */</span>
    <span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">ddc_bus</span> <span class="o">=</span> <span class="n">intel_i2c_create</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">GPIOA</span><span class="p">,</span> <span class="s">&quot;CRTDDC_A&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">ddc_bus</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DDC bus registration &quot;</span>
               <span class="s">&quot;failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">INTEL_OUTPUT_ANALOG</span><span class="p">;</span>
    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">interlace_allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">connector</span><span class="o">-&gt;</span><span class="n">doublescan_allowed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">drm_encoder_helper_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intel_output</span><span class="o">-&gt;</span><span class="n">enc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_helper_funcs</span><span class="p">);</span>
    <span class="n">drm_connector_helper_add</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intel_crt_connector_helper_funcs</span><span class="p">);</span>

    <span class="n">drm_connector_register</span><span class="p">(</span><span class="n">connector</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above (taken from the i915 driver), a CRTC, connector and
encoder combination is created. A device-specific i2c bus is also
created for fetching EDID data and performing monitor detection. Once
the process is complete, the new connector is registered with sysfs to
make its properties available to applications.</p>
</div>
</div>
<div class="section" id="kms-locking">
<h2>KMS Locking<a class="headerlink" href="#kms-locking" title="Permalink to this headline">¶</a></h2>
<p>As KMS moves toward more fine grained locking, and atomic ioctl where
userspace can indirectly control locking order, it becomes necessary
to use <code class="xref c c-type docutils literal"><span class="pre">ww_mutex</span></code> and acquire-contexts to avoid deadlocks.  But because
the locking is more distributed around the driver code, we want a bit
of extra utility/tracking out of our acquire-ctx.  This is provided
by <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span></code></a> and <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span></code></a>.</p>
<p>For basic principles of <code class="xref c c-type docutils literal"><span class="pre">ww_mutex</span></code>, see: Documentation/locking/ww-mutex-design.txt</p>
<p>The basic usage pattern is to:</p>
<div class="highlight-none"><div class="highlight"><pre>drm_modeset_acquire_init(ctx, DRM_MODESET_ACQUIRE_INTERRUPTIBLE)
retry:
foreach (lock in random_ordered_set_of_locks) {
    ret = drm_modeset_lock(lock, ctx)
    if (ret == -EDEADLK) {
        ret = drm_modeset_backoff(ctx);
        if (!ret)
            goto retry;
    }
    if (ret)
        goto out;
}
... do stuff ...
out:
drm_modeset_drop_locks(ctx);
drm_modeset_acquire_fini(ctx);
</pre></div>
</div>
<p>If all that is needed is a single modeset lock, then the <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">drm_modeset_acquire_ctx</span></code></a> is not needed and the locking can be simplified
by passing a NULL instead of ctx in the <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a> call or
calling  <a class="reference internal" href="#c.drm_modeset_lock_single_interruptible" title="drm_modeset_lock_single_interruptible"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_single_interruptible()</span></code></a>. To unlock afterwards
call <a class="reference internal" href="#c.drm_modeset_unlock" title="drm_modeset_unlock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_unlock()</span></code></a>.</p>
<p>On top of these per-object locks using <code class="xref c c-type docutils literal"><span class="pre">ww_mutex</span></code> there&#8217;s also an overall
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>, for protecting everything else. Mostly this means
probe state of connectors, and preventing hotplug add/removal of connectors.</p>
<p>Finally there&#8217;s a bunch of dedicated locks to protect drm core internal
lists and lookup data structures.</p>
<dl class="type">
<dt id="c.drm_modeset_acquire_ctx">
struct <code class="descname">drm_modeset_acquire_ctx</code><a class="headerlink" href="#c.drm_modeset_acquire_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>locking context (see ww_acquire_ctx)</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_modeset_acquire_ctx {
  struct ww_acquire_ctx ww_ctx;
  struct drm_modeset_lock *contended;
  struct list_head locked;
  bool trylock_only;
  bool interruptible;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ww_ctx</span></code></dt>
<dd>base acquire ctx</dd>
<dt><code class="docutils literal"><span class="pre">contended</span></code></dt>
<dd>used internally for -EDEADLK handling</dd>
<dt><code class="docutils literal"><span class="pre">locked</span></code></dt>
<dd>list of held locks</dd>
<dt><code class="docutils literal"><span class="pre">trylock_only</span></code></dt>
<dd>trylock mode used in atomic contexts/panic notifiers</dd>
<dt><code class="docutils literal"><span class="pre">interruptible</span></code></dt>
<dd>whether interruptible locking should be used.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Each thread competing for a set of locks must use one acquire
ctx.  And if any lock fxn returns -EDEADLK, it must backoff and
retry.</p>
<dl class="type">
<dt id="c.drm_modeset_lock">
struct <code class="descname">drm_modeset_lock</code><a class="headerlink" href="#c.drm_modeset_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>used for locking modeset resources.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_modeset_lock {
  struct ww_mutex mutex;
  struct list_head head;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>resource locking</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>used to hold it&#8217;s place on <code class="xref c c-type docutils literal"><span class="pre">drm_atomi_state.locked</span></code> list when
part of an atomic update</dd>
</dl>
<p><strong>Description</strong></p>
<p>Used for locking CRTCs and other modeset resources.</p>
<dl class="function">
<dt id="c.drm_modeset_lock_fini">
void <code class="descname">drm_modeset_lock_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to cleanup</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_is_locked">
bool <code class="descname">drm_modeset_is_locked</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_is_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>equivalent to <a class="reference internal" href="../translations/it_IT/kernel-hacking/locking.html#c.mutex_is_locked" title="mutex_is_locked"><code class="xref c c-func docutils literal"><span class="pre">mutex_is_locked()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to check</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_lock_all">
void <code class="descname">drm_modeset_lock_all</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_all" title="Permalink to this definition">¶</a></dt>
<dd><p>take all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes all modeset locks, suitable where a more fine-grained
scheme isn&#8217;t (yet) implemented. Locks must be dropped by calling the
<a class="reference internal" href="#c.drm_modeset_unlock_all" title="drm_modeset_unlock_all"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_unlock_all()</span></code></a> function.</p>
<p>This function is deprecated. It allocates a lock acquisition context and
stores it in <code class="xref c c-type docutils literal"><span class="pre">drm_device.mode_config</span></code>. This facilitate conversion of
existing code because it removes the need to manually deal with the
acquisition context, but it is also brittle because the context is global
and care must be taken not to nest calls. New code should use the
<a class="reference internal" href="#c.drm_modeset_lock_all_ctx" title="drm_modeset_lock_all_ctx"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_all_ctx()</span></code></a> function and pass in the context explicitly.</p>
<dl class="function">
<dt id="c.drm_modeset_unlock_all">
void <code class="descname">drm_modeset_unlock_all</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_unlock_all" title="Permalink to this definition">¶</a></dt>
<dd><p>drop all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function drops all modeset locks taken by a previous call to the
<a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_all()</span></code></a> function.</p>
<p>This function is deprecated. It uses the lock acquisition context stored
in <code class="xref c c-type docutils literal"><span class="pre">drm_device.mode_config</span></code>. This facilitates conversion of existing
code because it removes the need to manually deal with the acquisition
context, but it is also brittle because the context is global and care must
be taken not to nest calls. New code should pass the acquisition context
directly to the <a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_drop_locks()</span></code></a> function.</p>
<dl class="function">
<dt id="c.drm_warn_on_modeset_not_all_locked">
void <code class="descname">drm_warn_on_modeset_not_all_locked</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_warn_on_modeset_not_all_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>check that all modeset locks are locked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Useful as a debug assert.</p>
<dl class="function">
<dt id="c.drm_modeset_acquire_init">
void <code class="descname">drm_modeset_acquire_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em>, uint32_t<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_acquire_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize acquire context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">flags</span></code></dt>
<dd>0 or <code class="docutils literal"><span class="pre">DRM_MODESET_ACQUIRE_INTERRUPTIBLE</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>When passing <code class="docutils literal"><span class="pre">DRM_MODESET_ACQUIRE_INTERRUPTIBLE</span></code> to <strong>flags</strong>,
all calls to <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a> will perform an interruptible
wait.</p>
<dl class="function">
<dt id="c.drm_modeset_acquire_fini">
void <code class="descname">drm_modeset_acquire_fini</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_acquire_fini" title="Permalink to this definition">¶</a></dt>
<dd><p>cleanup acquire context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_drop_locks">
void <code class="descname">drm_modeset_drop_locks</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_drop_locks" title="Permalink to this definition">¶</a></dt>
<dd><p>drop all locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drop all locks currently held against this acquire context.</p>
<dl class="function">
<dt id="c.drm_modeset_backoff">
int <code class="descname">drm_modeset_backoff</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_backoff" title="Permalink to this definition">¶</a></dt>
<dd><p>deadlock avoidance backoff</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>the acquire context</dd>
</dl>
<p><strong>Description</strong></p>
<p>If deadlock is detected (ie. <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a> returns -EDEADLK),
you must call this function to drop all currently held locks and
block until the contended lock becomes available.</p>
<p>This function returns 0 on success, or -ERESTARTSYS if this context
is initialized with <code class="docutils literal"><span class="pre">DRM_MODESET_ACQUIRE_INTERRUPTIBLE</span></code> and the
wait has been interrupted.</p>
<dl class="function">
<dt id="c.drm_modeset_lock_init">
void <code class="descname">drm_modeset_lock_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to init</dd>
</dl>
<dl class="function">
<dt>
int <code class="descname">drm_modeset_lock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em>, struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span></dt>
<dd><p>take modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to take</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>acquire ctx</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>ctx</strong> is not NULL, then its ww acquire context is used and the
lock will be tracked by the context and can be released by calling
<a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_drop_locks()</span></code></a>.  If -EDEADLK is returned, this means a
deadlock scenario has been detected and it is an error to attempt
to take any more locks without first calling <a class="reference internal" href="#c.drm_modeset_backoff" title="drm_modeset_backoff"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_backoff()</span></code></a>.</p>
<p>If the <strong>ctx</strong> is not NULL and initialized with
<code class="docutils literal"><span class="pre">DRM_MODESET_ACQUIRE_INTERRUPTIBLE</span></code>, this function will fail with
-ERESTARTSYS when interrupted.</p>
<p>If <strong>ctx</strong> is NULL then the function call behaves like a normal,
uninterruptible non-nesting <a class="reference internal" href="../translations/it_IT/kernel-hacking/locking.html#c.mutex_lock" title="mutex_lock"><code class="xref c c-func docutils literal"><span class="pre">mutex_lock()</span></code></a> call.</p>
<dl class="function">
<dt id="c.drm_modeset_lock_single_interruptible">
int <code class="descname">drm_modeset_lock_single_interruptible</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_single_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>take a single modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to take</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function behaves as <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock()</span></code></a> with a NULL context,
but performs interruptible waits.</p>
<p>This function returns 0 on success, or -ERESTARTSYS when interrupted.</p>
<dl class="function">
<dt id="c.drm_modeset_unlock">
void <code class="descname">drm_modeset_unlock</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_modeset_lock" title="drm_modeset_lock">drm_modeset_lock</a> *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>drop modeset lock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_lock</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>lock to release</dd>
</dl>
<dl class="function">
<dt id="c.drm_modeset_lock_all_ctx">
int <code class="descname">drm_modeset_lock_all_ctx</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_modeset_acquire_ctx" title="drm_modeset_acquire_ctx">drm_modeset_acquire_ctx</a> *<em>&nbsp;ctx</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_modeset_lock_all_ctx" title="Permalink to this definition">¶</a></dt>
<dd><p>take all modeset locks</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_modeset_acquire_ctx</span> <span class="pre">*</span> <span class="pre">ctx</span></code></dt>
<dd>lock acquisition context</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function takes all modeset locks, suitable where a more fine-grained
scheme isn&#8217;t (yet) implemented.</p>
<p>Unlike <a class="reference internal" href="#c.drm_modeset_lock_all" title="drm_modeset_lock_all"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_lock_all()</span></code></a>, it doesn&#8217;t take the <a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.mutex</span></code></a>
since that lock isn&#8217;t required for modeset state changes. Callers which
need to grab that lock too need to do so outside of the acquire context
<strong>ctx</strong>.</p>
<p>Locks acquired with this function should be released by calling the
<a class="reference internal" href="#c.drm_modeset_drop_locks" title="drm_modeset_drop_locks"><code class="xref c c-func docutils literal"><span class="pre">drm_modeset_drop_locks()</span></code></a> function on <strong>ctx</strong>.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error-code on failure.</p>
</div>
<div class="section" id="kms-properties">
<h2>KMS Properties<a class="headerlink" href="#kms-properties" title="Permalink to this headline">¶</a></h2>
<div class="section" id="property-types-and-blob-property-support">
<h3>Property Types and Blob Property Support<a class="headerlink" href="#property-types-and-blob-property-support" title="Permalink to this headline">¶</a></h3>
<p>Properties as represented by <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a> are used to extend the modeset
interface exposed to userspace. For the atomic modeset IOCTL properties are
even the only way to transport metadata about the desired new modeset
configuration from userspace to the kernel. Properties have a well-defined
value range, which is enforced by the drm core. See the documentation of the
flags member of <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span></code></a> for an overview of the different
property types and ranges.</p>
<p>Properties don&#8217;t store the current value directly, but need to be
instatiated by attaching them to a <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a> with
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>.</p>
<p>Property values are only 64bit. To support bigger piles of data (like gamma
tables, color correction matrices or large structures) a property can instead
point at a <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob"><code class="xref c c-type docutils literal"><span class="pre">drm_property_blob</span></code></a> with that additional data.</p>
<p>Properties are defined by their symbolic name, userspace must keep a
per-object mapping from those names to the property ID used in the atomic
IOCTL and in the get/set property IOCTL.</p>
<dl class="type">
<dt id="c.drm_property_enum">
struct <code class="descname">drm_property_enum</code><a class="headerlink" href="#c.drm_property_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>symbolic values for enumerations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_property_enum {
  uint64_t value;
  struct list_head head;
  char name[DRM_PROP_NAME_LEN];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">value</span></code></dt>
<dd>numeric property value for this enum entry</dd>
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>list of enum values, linked to <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property.enum_list</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>symbolic name for the enum</dd>
</dl>
<p><strong>Description</strong></p>
<p>For enumeration and bitmask properties this structure stores the symbolic
decoding for each value. This is used for example for the rotation property.</p>
<dl class="type">
<dt id="c.drm_property">
struct <code class="descname">drm_property</code><a class="headerlink" href="#c.drm_property" title="Permalink to this definition">¶</a></dt>
<dd><p>modeset object property</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_property {
  struct list_head head;
  struct drm_mode_object base;
  uint32_t flags;
  char name[DRM_PROP_NAME_LEN];
  uint32_t num_values;
  uint64_t *values;
  struct drm_device *dev;
  struct list_head enum_list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">head</span></code></dt>
<dd>per-device list of properties, for cleanup.</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd><p class="first">Property flags and type. A property needs to be one of the following
types:</p>
<dl class="docutils">
<dt>DRM_MODE_PROP_RANGE</dt>
<dd>Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is unsigned. Range properties are created using
<a class="reference internal" href="#c.drm_property_create_range" title="drm_property_create_range"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_range()</span></code></a>.</dd>
<dt>DRM_MODE_PROP_SIGNED_RANGE</dt>
<dd>Range properties report their minimum and maximum admissible unsigned values.
The KMS core verifies that values set by application fit in that
range. The range is signed. Range properties are created using
<a class="reference internal" href="#c.drm_property_create_signed_range" title="drm_property_create_signed_range"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_signed_range()</span></code></a>.</dd>
<dt>DRM_MODE_PROP_ENUM</dt>
<dd>Enumerated properties take a numerical value that ranges from 0 to
the number of enumerated values defined by the property minus one,
and associate a free-formed string name to each value. Applications
can retrieve the list of defined value-name pairs and use the
numerical value to get and set property instance values. Enum
properties are created using <a class="reference internal" href="#c.drm_property_create_enum" title="drm_property_create_enum"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_enum()</span></code></a>.</dd>
<dt>DRM_MODE_PROP_BITMASK</dt>
<dd>Bitmask properties are enumeration properties that additionally
restrict all enumerated values to the 0..63 range. Bitmask property
instance values combine one or more of the enumerated bits defined
by the property. Bitmask properties are created using
<a class="reference internal" href="#c.drm_property_create_bitmask" title="drm_property_create_bitmask"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_bitmask()</span></code></a>.</dd>
<dt>DRM_MODE_PROB_OBJECT</dt>
<dd><p class="first">Object properties are used to link modeset objects. This is used
extensively in the atomic support to create the display pipeline,
by linking <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> to <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>, <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> to
<a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a> to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>. An object property can
only link to a specific type of <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_object</span></code></a>, this limit is
enforced by the core. Object properties are created using
<a class="reference internal" href="#c.drm_property_create_object" title="drm_property_create_object"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_object()</span></code></a>.</p>
<p class="last">Object properties work like blob properties, but in a more
general fashion. They are limited to atomic drivers and must have
the DRM_MODE_PROP_ATOMIC flag set.</p>
</dd>
<dt>DRM_MODE_PROP_BLOB</dt>
<dd><p class="first">Blob properties store a binary blob without any format restriction.
The binary blobs are created as KMS standalone objects, and blob
property instance values store the ID of their associated blob
object. Blob properties are created by calling
<a class="reference internal" href="#c.drm_property_create" title="drm_property_create"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create()</span></code></a> with DRM_MODE_PROP_BLOB as the type.</p>
<p>Actual blob objects to contain blob data are created using
<a class="reference internal" href="#c.drm_property_create_blob" title="drm_property_create_blob"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_blob()</span></code></a>, or through the corresponding IOCTL.</p>
<p class="last">Besides the built-in limit to only accept blob objects blob
properties work exactly like object properties. The only reasons
blob properties exist is backwards compatibility with existing
userspace.</p>
</dd>
</dl>
<p>In addition a property can have any combination of the below flags:</p>
<dl class="last docutils">
<dt>DRM_MODE_PROP_ATOMIC</dt>
<dd>Set for properties which encode atomic modeset state. Such
properties are not exposed to legacy userspace.</dd>
<dt>DRM_MODE_PROP_IMMUTABLE</dt>
<dd>Set for properties whose values cannot be changed by
userspace. The kernel is allowed to update the value of these
properties. This is generally used to expose probe state to
userspace, e.g. the EDID, or the connector path property on DP
MST sinks.</dd>
</dl>
</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>symbolic name of the properties</dd>
<dt><code class="docutils literal"><span class="pre">num_values</span></code></dt>
<dd>size of the <strong>values</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">values</span></code></dt>
<dd>Array with limits and values for the property. The
interpretation of these limits is dependent upon the type per <strong>flags</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">enum_list</span></code></dt>
<dd>List of <code class="xref c c-type docutils literal"><span class="pre">drm_prop_enum_list</span></code> structures with the symbolic names for
enum and bitmask values.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represent a modeset object property. It combines both the name
of the property with the set of permissible values. This means that when a
driver wants to use a property with the same name on different objects, but
with different value ranges, then it must create property for each one. An
example would be rotation of <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>, when e.g. the primary plane cannot
be rotated. But if both the name and the value range match, then the same
property structure can be instantiated multiple times for the same object.
Userspace must be able to cope with this and cannot assume that the same
symbolic property will have the same modeset object ID on all modeset
objects.</p>
<p>Properties are created by one of the special functions, as explained in
detail in the <strong>flags</strong> structure member.</p>
<p>To actually expose a property it must be attached to each object using
<a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. Currently properties can only be attached to
<a class="reference internal" href="#c.drm_connector" title="drm_connector"><code class="xref c c-type docutils literal"><span class="pre">drm_connector</span></code></a>, <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a>.</p>
<p>Properties are also used as the generic metadatatransport for the atomic
IOCTL. Everything that was set directly in structures in the legacy modeset
IOCTLs (like the plane source or destination windows, or e.g. the links to
the CRTC) is exposed as a property with the DRM_MODE_PROP_ATOMIC flag set.</p>
<dl class="type">
<dt id="c.drm_property_blob">
struct <code class="descname">drm_property_blob</code><a class="headerlink" href="#c.drm_property_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Blob data for <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a></p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_property_blob {
  struct drm_mode_object base;
  struct drm_device *dev;
  struct list_head head_global;
  struct list_head head_file;
  size_t length;
  void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>base KMS object</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">head_global</span></code></dt>
<dd>entry on the global blob list in
<a class="reference internal" href="#c.drm_mode_config" title="drm_mode_config"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config.property_blob_list</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">head_file</span></code></dt>
<dd>entry on the per-file blob list in <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file"><code class="xref c c-type docutils literal"><span class="pre">drm_file.blobs</span></code></a> list.</dd>
<dt><code class="docutils literal"><span class="pre">length</span></code></dt>
<dd>size of the blob in bytes, invariant over the lifetime of the object</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>actual data, embedded at the end of this structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Blobs are used to store bigger values than what fits directly into the 64
bits available for a <a class="reference internal" href="#c.drm_property" title="drm_property"><code class="xref c c-type docutils literal"><span class="pre">drm_property</span></code></a>.</p>
<p>Blobs are reference counted using <a class="reference internal" href="#c.drm_property_blob_get" title="drm_property_blob_get"><code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_get()</span></code></a> and
<a class="reference internal" href="#c.drm_property_blob_put" title="drm_property_blob_put"><code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_put()</span></code></a>. They are created using <a class="reference internal" href="#c.drm_property_create_blob" title="drm_property_create_blob"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_blob()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_property_type_is">
bool <code class="descname">drm_property_type_is</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint32_t<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_type_is" title="Permalink to this definition">¶</a></dt>
<dd><p>check the type of a property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to check</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt>
<dd>property type to compare with</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is a helper function becauase the uapi encoding of property types is
a bit special for historical reasons.</p>
<dl class="function">
<dt id="c.drm_property_find">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_find</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="drm-internals.html#c.drm_file" title="drm_file">drm_file</a> *<em>&nbsp;file_priv</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find property object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_file</span> <span class="pre">*</span> <span class="pre">file_priv</span></code></dt>
<dd>drm file to check for lease against.</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>property object id</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function looks up the property object specified by id and returns it.</p>
<dl class="function">
<dt id="c.drm_property_create">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, u32<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;num_values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_values</span></code></dt>
<dd>number of pre-defined values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_enum">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_enum</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, u32<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, const struct drm_prop_enum_list *<em>&nbsp;props</em>, int<em>&nbsp;num_values</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new enumeration property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_prop_enum_list</span> <span class="pre">*</span> <span class="pre">props</span></code></dt>
<dd>enumeration lists with property values</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_values</span></code></dt>
<dd>number of pre-defined values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is only allowed to set one of the predefined values for enumeration
properties.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_bitmask">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_bitmask</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, u32<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, const struct drm_prop_enum_list *<em>&nbsp;props</em>, int<em>&nbsp;num_props</em>, uint64_t<em>&nbsp;supported_bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_bitmask" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new bitmask property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_prop_enum_list</span> <span class="pre">*</span> <span class="pre">props</span></code></dt>
<dd>enumeration lists with property bitflags</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num_props</span></code></dt>
<dd>size of the <strong>props</strong> array</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">supported_bits</span></code></dt>
<dd>bitmask of all supported enumeration values</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new bitmask drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Compared to plain enumeration properties userspace is allowed to set any
or&#8217;ed together combination of the predefined property bitflag values</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_range">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_range</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, u32<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, uint64_t<em>&nbsp;min</em>, uint64_t<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_range" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new unsigned ranged property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">min</span></code></dt>
<dd>minimum value of the property</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">max</span></code></dt>
<dd>maximum value of the property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is allowed to set any unsigned integer value in the (min, max)
range inclusive.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_signed_range">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_signed_range</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, u32<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, int64_t<em>&nbsp;min</em>, int64_t<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_signed_range" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new signed ranged property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">int64_t</span> <span class="pre">min</span></code></dt>
<dd>minimum value of the property</dd>
<dt><code class="docutils literal"><span class="pre">int64_t</span> <span class="pre">max</span></code></dt>
<dd>maximum value of the property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is allowed to set any signed integer value in the (min, max)
range inclusive.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_object">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_object</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, u32<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, uint32_t<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_object" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new object property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">type</span></code></dt>
<dd>object type from DRM_MODE_OBJECT_* defines</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>Userspace is only allowed to set this to any property value of the given
<strong>type</strong>. Only useful for atomic properties, which is enforced.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_create_bool">
struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> * <code class="descname">drm_property_create_bool</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, u32<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_bool" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new boolean property type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>flags specifying the property type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new generic drm property which can then be attached to a drm
object with <a class="reference internal" href="#c.drm_object_attach_property" title="drm_object_attach_property"><code class="xref c c-func docutils literal"><span class="pre">drm_object_attach_property()</span></code></a>. The returned property object must
be freed with <a class="reference internal" href="#c.drm_property_destroy" title="drm_property_destroy"><code class="xref c c-func docutils literal"><span class="pre">drm_property_destroy()</span></code></a>, which is done automatically when
calling <a class="reference internal" href="#c.drm_mode_config_cleanup" title="drm_mode_config_cleanup"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_config_cleanup()</span></code></a>.</p>
<p>This is implemented as a ranged property with only {0, 1} as valid values.</p>
<p><strong>Return</strong></p>
<p>A pointer to the newly created property on success, NULL on failure.</p>
<dl class="function">
<dt id="c.drm_property_add_enum">
int <code class="descname">drm_property_add_enum</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em>, uint64_t<em>&nbsp;value</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_add_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>add a possible value to an enumeration property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>enumeration property to change</dd>
<dt><code class="docutils literal"><span class="pre">uint64_t</span> <span class="pre">value</span></code></dt>
<dd>value of the new enumeration</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>symbolic name of the new enumeration</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions adds enumerations to a property.</p>
<p>It&#8217;s use is deprecated, drivers should use one of the more specific helpers
to directly create the property with all enumerations already attached.</p>
<p><strong>Return</strong></p>
<p>Zero on success, error code on failure.</p>
<dl class="function">
<dt id="c.drm_property_destroy">
void <code class="descname">drm_property_destroy</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;property</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a drm property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">property</span></code></dt>
<dd>property to destry</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function frees a property including any attached resources like
enumeration values.</p>
<dl class="function">
<dt id="c.drm_property_create_blob">
struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> * <code class="descname">drm_property_create_blob</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, size_t<em>&nbsp;length</em>, const void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_create_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new blob property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device to create property for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">length</span></code></dt>
<dd>Length to allocate for blob data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>If specified, copies data into blob</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new blob property for a specified DRM device, optionally
copying data. Note that blob properties are meant to be invariant, hence the
data must be filled out before the blob is used as the value of any property.</p>
<p><strong>Return</strong></p>
<p>New blob property with a single reference on success, or an ERR_PTR
value on failure.</p>
<dl class="function">
<dt id="c.drm_property_blob_put">
void <code class="descname">drm_property_blob_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_blob_put" title="Permalink to this definition">¶</a></dt>
<dd><p>release a blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>DRM blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases a reference to a blob property. May free the object.</p>
<dl class="function">
<dt id="c.drm_property_blob_get">
struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> * <code class="descname">drm_property_blob_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_blob_get" title="Permalink to this definition">¶</a></dt>
<dd><p>acquire blob property reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">blob</span></code></dt>
<dd>DRM blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires a reference to an existing blob property. Returns <strong>blob</strong>, which
allows this to be used as a shorthand in assignments.</p>
<dl class="function">
<dt id="c.drm_property_lookup_blob">
struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> * <code class="descname">drm_property_lookup_blob</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, uint32_t<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_lookup_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>look up a blob property and take a reference</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">id</span></code></dt>
<dd>id of the blob property</dd>
</dl>
<p><strong>Description</strong></p>
<p>If successful, this takes an additional reference to the blob property.
callers need to make sure to eventually unreference the returned property
again, using <a class="reference internal" href="#c.drm_property_blob_put" title="drm_property_blob_put"><code class="xref c c-func docutils literal"><span class="pre">drm_property_blob_put()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>NULL on failure, pointer to the blob on success.</p>
<dl class="function">
<dt id="c.drm_property_replace_global_blob">
int <code class="descname">drm_property_replace_global_blob</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> **<em>&nbsp;replace</em>, size_t<em>&nbsp;length</em>, const void *<em>&nbsp;data</em>, struct <a class="reference internal" href="#c.drm_mode_object" title="drm_mode_object">drm_mode_object</a> *<em>&nbsp;obj_holds_id</em>, struct <a class="reference internal" href="#c.drm_property" title="drm_property">drm_property</a> *<em>&nbsp;prop_holds_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_replace_global_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>replace existing blob property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>drm device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">**</span> <span class="pre">replace</span></code></dt>
<dd>location of blob property pointer to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">length</span></code></dt>
<dd>length of data for new blob, or 0 for no data</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>content for new blob, or NULL for no data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_mode_object</span> <span class="pre">*</span> <span class="pre">obj_holds_id</span></code></dt>
<dd>optional object for property holding blob ID</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property</span> <span class="pre">*</span> <span class="pre">prop_holds_id</span></code></dt>
<dd>optional property holding blob ID
<strong>return</strong> 0 on success or error on failure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will replace a global property in the blob list, optionally
updating a property which holds the ID of that property.</p>
<p>If length is 0 or data is NULL, no new blob will be created, and the holding
property, if specified, will be set to 0.</p>
<p>Access to the replace pointer is assumed to be protected by the caller, e.g.
by holding the relevant modesetting object lock for its parent.</p>
<p>For example, a drm_connector has a &#8216;PATH&#8217; property, which contains the ID
of a blob property with the value of the MST path information. Calling this
function with replace pointing to the connector&#8217;s path_blob_ptr, length and
data set for the new path information, obj_holds_id set to the connector&#8217;s
base object, and prop_holds_id set to the path property name, will perform
a completely atomic update. The access to path_blob_ptr is protected by the
caller holding a lock on the connector.</p>
<dl class="function">
<dt id="c.drm_property_replace_blob">
bool <code class="descname">drm_property_replace_blob</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> **<em>&nbsp;blob</em>, struct <a class="reference internal" href="#c.drm_property_blob" title="drm_property_blob">drm_property_blob</a> *<em>&nbsp;new_blob</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_property_replace_blob" title="Permalink to this definition">¶</a></dt>
<dd><p>replace a blob property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">**</span> <span class="pre">blob</span></code></dt>
<dd>a pointer to the member blob to be replaced</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_property_blob</span> <span class="pre">*</span> <span class="pre">new_blob</span></code></dt>
<dd>the new blob to replace with</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if the blob was in fact replaced.</p>
</div>
<div class="section" id="standard-connector-properties">
<h3>Standard Connector Properties<a class="headerlink" href="#standard-connector-properties" title="Permalink to this headline">¶</a></h3>
<p>DRM connectors have a few standardized properties:</p>
<dl class="docutils">
<dt>EDID:</dt>
<dd>Blob property which contains the current EDID read from the sink. This
is useful to parse sink identification information like vendor, model
and serial. Drivers should update this property by calling
<a class="reference internal" href="#c.drm_connector_update_edid_property" title="drm_connector_update_edid_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_update_edid_property()</span></code></a>, usually after having parsed
the EDID using <a class="reference internal" href="drm-kms-helpers.html#c.drm_add_edid_modes" title="drm_add_edid_modes"><code class="xref c c-func docutils literal"><span class="pre">drm_add_edid_modes()</span></code></a>. Userspace cannot change this
property.</dd>
<dt>DPMS:</dt>
<dd><p class="first">Legacy property for setting the power state of the connector. For atomic
drivers this is only provided for backwards compatibility with existing
drivers, it remaps to controlling the &#8220;ACTIVE&#8221; property on the CRTC the
connector is linked to. Drivers should never set this property directly,
it is handled by the DRM core by calling the <a class="reference internal" href="#c.drm_connector_funcs" title="drm_connector_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_connector_funcs.dpms</span></code></a>
callback. For atomic drivers the remapping to the &#8220;ACTIVE&#8221; property is
implemented in the DRM core.  This is the only standard connector
property that userspace can change.</p>
<p>Note that this property cannot be set through the MODE_ATOMIC ioctl,
userspace must use &#8220;ACTIVE&#8221; on the CRTC instead.</p>
<p>WARNING:</p>
<p>For userspace also running on legacy drivers the &#8220;DPMS&#8221; semantics are a
lot more complicated. First, userspace cannot rely on the &#8220;DPMS&#8221; value
returned by the GETCONNECTOR actually reflecting reality, because many
drivers fail to update it. For atomic drivers this is taken care of in
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</p>
<p>The second issue is that the DPMS state is only well-defined when the
connector is connected to a CRTC. In atomic the DRM core enforces that
&#8220;ACTIVE&#8221; is off in such a case, no such checks exists for &#8220;DPMS&#8221;.</p>
<p>Finally, when enabling an output using the legacy SETCONFIG ioctl then
&#8220;DPMS&#8221; is forced to ON. But see above, that might not be reflected in
the software value on legacy drivers.</p>
<p class="last">Summarizing: Only set &#8220;DPMS&#8221; when the connector is known to be enabled,
assume that a successful SETCONFIG call also sets &#8220;DPMS&#8221; to on, and
never read back the value of &#8220;DPMS&#8221; because it can be incorrect.</p>
</dd>
<dt>PATH:</dt>
<dd>Connector path property to identify how this sink is physically
connected. Used by DP MST. This should be set by calling
<a class="reference internal" href="#c.drm_connector_set_path_property" title="drm_connector_set_path_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_set_path_property()</span></code></a>, in the case of DP MST with the
path property the MST manager created. Userspace cannot change this
property.</dd>
<dt>TILE:</dt>
<dd>Connector tile group property to indicate how a set of DRM connector
compose together into one logical screen. This is used by both high-res
external screens (often only using a single cable, but exposing multiple
DP MST sinks), or high-res integrated panels (like dual-link DSI) which
are not gen-locked. Note that for tiled panels which are genlocked, like
dual-link LVDS or dual-link DSI, the driver should try to not expose the
tiling and virtualize both <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> and <a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> if needed. Drivers
should update this value using <a class="reference internal" href="#c.drm_connector_set_tile_property" title="drm_connector_set_tile_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_set_tile_property()</span></code></a>.
Userspace cannot change this property.</dd>
<dt>link-status:</dt>
<dd>Connector link-status property to indicate the status of link. The
default value of link-status is &#8220;GOOD&#8221;. If something fails during or
after modeset, the kernel driver may set this to &#8220;BAD&#8221; and issue a
hotplug uevent. Drivers should update this value using
<a class="reference internal" href="#c.drm_connector_set_link_status_property" title="drm_connector_set_link_status_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_set_link_status_property()</span></code></a>.</dd>
<dt>non_desktop:</dt>
<dd>Indicates the output should be ignored for purposes of displaying a
standard desktop environment or console. This is most likely because
the output device is not rectilinear.</dd>
<dt>Content Protection:</dt>
<dd><p class="first">This property is used by userspace to request the kernel protect future
content communicated over the link. When requested, kernel will apply
the appropriate means of protection (most often HDCP), and use the
property to tell userspace the protection is active.</p>
<p>Drivers can set this up by calling
<a class="reference internal" href="#c.drm_connector_attach_content_protection_property" title="drm_connector_attach_content_protection_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_attach_content_protection_property()</span></code></a> on initialization.</p>
<p>The value of this property can be one of the following:</p>
<dl class="docutils">
<dt>DRM_MODE_CONTENT_PROTECTION_UNDESIRED = 0</dt>
<dd>The link is not protected, content is transmitted in the clear.</dd>
<dt>DRM_MODE_CONTENT_PROTECTION_DESIRED = 1</dt>
<dd>Userspace has requested content protection, but the link is not
currently protected. When in this state, kernel should enable
Content Protection as soon as possible.</dd>
<dt>DRM_MODE_CONTENT_PROTECTION_ENABLED = 2</dt>
<dd>Userspace has requested content protection, and the link is
protected. Only the driver can set the property to this value.
If userspace attempts to set to ENABLED, kernel will return
-EINVAL.</dd>
</dl>
<p>A few guidelines:</p>
<ul class="last simple">
<li>DESIRED state should be preserved until userspace de-asserts it by
setting the property to UNDESIRED. This means ENABLED should only
transition to UNDESIRED when the user explicitly requests it.</li>
<li>If the state is DESIRED, kernel should attempt to re-authenticate the
link whenever possible. This includes across disable/enable, dpms,
hotplug, downstream device changes, link status failures, etc..</li>
<li>Userspace is responsible for polling the property to determine when
the value transitions from ENABLED to DESIRED. This signifies the link
is no longer protected and userspace should take appropriate action
(whatever that might be).</li>
</ul>
</dd>
</dl>
<p>Connectors also have one standardized atomic property:</p>
<dl class="docutils">
<dt>CRTC_ID:</dt>
<dd>Mode object ID of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> this connector should be connected to.</dd>
</dl>
<p>Connectors for LCD panels may also have one standardized property:</p>
<dl class="docutils">
<dt>panel orientation:</dt>
<dd>On some devices the LCD panel is mounted in the casing in such a way
that the up/top side of the panel does not match with the top side of
the device. Userspace can use this property to check for this.
Note that input coordinates from touchscreens (input devices with
INPUT_PROP_DIRECT) will still map 1:1 to the actual LCD panel
coordinates, so if userspace rotates the picture to adjust for
the orientation it must also apply the same transformation to the
touchscreen input coordinates. This property is initialized by calling
<a class="reference internal" href="#c.drm_connector_init_panel_orientation_property" title="drm_connector_init_panel_orientation_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_init_panel_orientation_property()</span></code></a>.</dd>
<dt>scaling mode:</dt>
<dd><p class="first">This property defines how a non-native mode is upscaled to the native
mode of an LCD panel:</p>
<dl class="docutils">
<dt>None:</dt>
<dd>No upscaling happens, scaling is left to the panel. Not all
drivers expose this mode.</dd>
<dt>Full:</dt>
<dd>The output is upscaled to the full resolution of the panel,
ignoring the aspect ratio.</dd>
<dt>Center:</dt>
<dd>No upscaling happens, the output is centered within the native
resolution the panel.</dd>
<dt>Full aspect:</dt>
<dd>The output is upscaled to maximize either the width or height
while retaining the aspect ratio.</dd>
</dl>
<p class="last">This property should be set up by calling
<a class="reference internal" href="#c.drm_connector_attach_scaling_mode_property" title="drm_connector_attach_scaling_mode_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_attach_scaling_mode_property()</span></code></a>. Note that drivers
can also expose this property to external outputs, in which case they
must support &#8220;None&#8221;, which should be the default (since external screens
have a built-in scaler).</p>
</dd>
</dl>
</div>
<div class="section" id="hdmi-specific-connector-properties">
<h3>HDMI Specific Connector Properties<a class="headerlink" href="#hdmi-specific-connector-properties" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>content type (HDMI specific):</dt>
<dd><p class="first">Indicates content type setting to be used in HDMI infoframes to indicate
content type for the external device, so that it adjusts it&#8217;s display
settings accordingly.</p>
<p>The value of this property can be one of the following:</p>
<dl class="docutils">
<dt>No Data:</dt>
<dd>Content type is unknown</dd>
<dt>Graphics:</dt>
<dd>Content type is graphics</dd>
<dt>Photo:</dt>
<dd>Content type is photo</dd>
<dt>Cinema:</dt>
<dd>Content type is cinema</dd>
<dt>Game:</dt>
<dd>Content type is game</dd>
</dl>
<p class="last">Drivers can set up this property by calling
<a class="reference internal" href="#c.drm_connector_attach_content_type_property" title="drm_connector_attach_content_type_property"><code class="xref c c-func docutils literal"><span class="pre">drm_connector_attach_content_type_property()</span></code></a>. Decoding to
infoframe values is done through <a class="reference internal" href="#c.drm_hdmi_avi_infoframe_content_type" title="drm_hdmi_avi_infoframe_content_type"><code class="xref c c-func docutils literal"><span class="pre">drm_hdmi_avi_infoframe_content_type()</span></code></a>.</p>
</dd>
</dl>
</div>
<div class="section" id="plane-composition-properties">
<h3>Plane Composition Properties<a class="headerlink" href="#plane-composition-properties" title="Permalink to this headline">¶</a></h3>
<p>The basic plane composition model supported by standard plane properties only
has a source rectangle (in logical pixels within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>), with
sub-pixel accuracy, which is scaled up to a pixel-aligned destination
rectangle in the visible area of a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>. The visible area of a CRTC is
defined by the horizontal and vertical visible pixels (stored in <strong>hdisplay</strong>
and <strong>vdisplay</strong>) of the requested mode (stored in <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.mode</span></code></a>). These
two rectangles are both stored in the <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state</span></code></a>.</p>
<p>For the atomic ioctl the following standard (atomic) properties on the plane object
encode the basic plane composition model:</p>
<dl class="docutils">
<dt>SRC_X:</dt>
<dd>X coordinate offset for the source rectangle within the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, in 16.16 fixed point. Must be positive.</dd>
<dt>SRC_Y:</dt>
<dd>Y coordinate offset for the source rectangle within the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, in 16.16 fixed point. Must be positive.</dd>
<dt>SRC_W:</dt>
<dd>Width for the source rectangle within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, in 16.16
fixed point. SRC_X plus SRC_W must be within the width of the source
framebuffer. Must be positive.</dd>
<dt>SRC_H:</dt>
<dd>Height for the source rectangle within the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>, in 16.16
fixed point. SRC_Y plus SRC_H must be within the height of the source
framebuffer. Must be positive.</dd>
<dt>CRTC_X:</dt>
<dd>X coordinate offset for the destination rectangle. Can be negative.</dd>
<dt>CRTC_Y:</dt>
<dd>Y coordinate offset for the destination rectangle. Can be negative.</dd>
<dt>CRTC_W:</dt>
<dd>Width for the destination rectangle. CRTC_X plus CRTC_W can extend past
the currently visible horizontal area of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>.</dd>
<dt>CRTC_H:</dt>
<dd>Height for the destination rectangle. CRTC_Y plus CRTC_H can extend past
the currently visible vertical area of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a>.</dd>
<dt>FB_ID:</dt>
<dd>Mode object ID of the <a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a> this plane should scan out.</dd>
<dt>CRTC_ID:</dt>
<dd>Mode object ID of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> this plane should be connected to.</dd>
</dl>
<p>Note that the source rectangle must fully lie within the bounds of the
<a class="reference internal" href="#c.drm_framebuffer" title="drm_framebuffer"><code class="xref c c-type docutils literal"><span class="pre">drm_framebuffer</span></code></a>. The destination rectangle can lie outside of the visible
area of the current mode of the CRTC. It must be apprpriately clipped by the
driver, which can be done by calling <a class="reference internal" href="drm-kms-helpers.html#c.drm_plane_helper_check_update" title="drm_plane_helper_check_update"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_helper_check_update()</span></code></a>. Drivers
are also allowed to round the subpixel sampling positions appropriately, but
only to the next full pixel. No pixel outside of the source rectangle may
ever be sampled, which is important when applying more sophisticated
filtering than just a bilinear one when scaling. The filtering mode when
scaling is unspecified.</p>
<p>On top of this basic transformation additional properties can be exposed by
the driver:</p>
<dl class="docutils">
<dt>alpha:</dt>
<dd>Alpha is setup with <a class="reference internal" href="#c.drm_plane_create_alpha_property" title="drm_plane_create_alpha_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_alpha_property()</span></code></a>. It controls the
plane-wide opacity, from transparent (0) to opaque (0xffff). It can be
combined with pixel alpha.
The pixel values in the framebuffers are expected to not be
pre-multiplied by the global alpha associated to the plane.</dd>
<dt>rotation:</dt>
<dd>Rotation is set up with <a class="reference internal" href="#c.drm_plane_create_rotation_property" title="drm_plane_create_rotation_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_rotation_property()</span></code></a>. It adds a
rotation and reflection step between the source and destination rectangles.
Without this property the rectangle is only scaled, but not rotated or
reflected.</dd>
<dt>zpos:</dt>
<dd>Z position is set up with <a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a> and
<a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_property()</span></code></a>. It controls the visibility of overlapping
planes. Without this property the primary plane is always below the cursor
plane, and ordering between all other planes is undefined.</dd>
</dl>
<p>Note that all the property extensions described here apply either to the
plane or the CRTC (e.g. for the background color, which currently is not
exposed and assumed to be black).</p>
<dl class="function">
<dt id="c.drm_plane_create_alpha_property">
int <code class="descname">drm_plane_create_alpha_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_alpha_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new alpha property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a generic, mutable, alpha property and enables support
for it in the DRM core. It is attached to <strong>plane</strong>.</p>
<p>The alpha property will be allowed to be within the bounds of 0
(transparent) to 0xffff (opaque).</p>
<p><strong>Return</strong></p>
<p>0 on success, negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_plane_create_rotation_property">
int <code class="descname">drm_plane_create_rotation_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, unsigned int<em>&nbsp;rotation</em>, unsigned int<em>&nbsp;supported_rotations</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_rotation_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create a new rotation property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt>
<dd>initial value of the rotation property</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">supported_rotations</span></code></dt>
<dd>bitmask of supported rotations and reflections</dd>
</dl>
<p><strong>Description</strong></p>
<p>This creates a new property with the selected support for transformations.</p>
<p>Since a rotation by 180° degress is the same as reflecting both along the x
and the y axis the rotation property is somewhat redundant. Drivers can use
<a class="reference internal" href="#c.drm_rotation_simplify" title="drm_rotation_simplify"><code class="xref c c-func docutils literal"><span class="pre">drm_rotation_simplify()</span></code></a> to normalize values of this property.</p>
<p>The property exposed to userspace is a bitmask property (see
<a class="reference internal" href="#c.drm_property_create_bitmask" title="drm_property_create_bitmask"><code class="xref c c-func docutils literal"><span class="pre">drm_property_create_bitmask()</span></code></a>) called &#8220;rotation&#8221; and has the following
bitmask enumaration values:</p>
<dl class="docutils">
<dt>DRM_MODE_ROTATE_0:</dt>
<dd>&#8220;rotate-0&#8221;</dd>
<dt>DRM_MODE_ROTATE_90:</dt>
<dd>&#8220;rotate-90&#8221;</dd>
<dt>DRM_MODE_ROTATE_180:</dt>
<dd>&#8220;rotate-180&#8221;</dd>
<dt>DRM_MODE_ROTATE_270:</dt>
<dd>&#8220;rotate-270&#8221;</dd>
<dt>DRM_MODE_REFLECT_X:</dt>
<dd>&#8220;reflect-x&#8221;</dd>
<dt>DRM_MODE_REFLECT_Y:</dt>
<dd>&#8220;reflect-y&#8221;</dd>
</dl>
<p>Rotation is the specified amount in degrees in counter clockwise direction,
the X and Y axis are within the source rectangle, i.e.  the X/Y axis before
rotation. After reflection, the rotation is applied to the image sampled from
the source rectangle, before scaling it to fit the destination rectangle.</p>
<dl class="function">
<dt id="c.drm_rotation_simplify">
unsigned int <code class="descname">drm_rotation_simplify</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;rotation</em>, unsigned int<em>&nbsp;supported_rotations</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_rotation_simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to simplify the rotation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">rotation</span></code></dt>
<dd>Rotation to be simplified</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">supported_rotations</span></code></dt>
<dd>Supported rotations</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to simplify the rotation to a form that is supported.
Eg. if the hardware supports everything except DRM_MODE_REFLECT_X
one could call this function like this:</p>
<dl class="docutils">
<dt>drm_rotation_simplify(rotation, DRM_MODE_ROTATE_0 |</dt>
<dd>DRM_MODE_ROTATE_90 | DRM_MODE_ROTATE_180 |
DRM_MODE_ROTATE_270 | DRM_MODE_REFLECT_Y);</dd>
</dl>
<p>to eliminate the DRM_MODE_ROTATE_X flag. Depending on what kind of
transforms the hardware supports, this function may not
be able to produce a supported transform, so the caller should
check the result afterwards.</p>
<dl class="function">
<dt id="c.drm_plane_create_zpos_property">
int <code class="descname">drm_plane_create_zpos_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, unsigned int<em>&nbsp;zpos</em>, unsigned int<em>&nbsp;min</em>, unsigned int<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_zpos_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create mutable zpos property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">zpos</span></code></dt>
<dd>initial value of zpos property</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">min</span></code></dt>
<dd>minimal possible value of zpos property</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">max</span></code></dt>
<dd>maximal possible value of zpos property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes generic mutable zpos property and enables support
for it in drm core. Drivers can then attach this property to planes to enable
support for configurable planes arrangement during blending operation.
Drivers that attach a mutable zpos property to any plane should call the
<a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_normalize_zpos()</span></code></a> helper during their implementation of
<a class="reference internal" href="#c.drm_mode_config_funcs" title="drm_mode_config_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_mode_config_funcs.atomic_check()</span></code></a>, which will update the normalized zpos
values and store them in <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.normalized_zpos</span></code></a>. Usually min
should be set to 0 and max to maximal number of planes for given crtc - 1.</p>
<p>If zpos of some planes cannot be changed (like fixed background or
cursor/topmost planes), driver should adjust min/max values and assign those
planes immutable zpos property with lower or higher values (for more
information, see <a class="reference internal" href="#c.drm_plane_create_zpos_immutable_property" title="drm_plane_create_zpos_immutable_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_immutable_property()</span></code></a> function). In such
case driver should also assign proper initial zpos values for all planes in
its <code class="xref c c-func docutils literal"><span class="pre">plane_reset()</span></code> callback, so the planes will be always sorted properly.</p>
<p>See also <a class="reference internal" href="#c.drm_atomic_normalize_zpos" title="drm_atomic_normalize_zpos"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_normalize_zpos()</span></code></a>.</p>
<p>The property exposed to userspace is called &#8220;zpos&#8221;.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_plane_create_zpos_immutable_property">
int <code class="descname">drm_plane_create_zpos_immutable_property</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, unsigned int<em>&nbsp;zpos</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_zpos_immutable_property" title="Permalink to this definition">¶</a></dt>
<dd><p>create immuttable zpos property</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>drm plane</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">zpos</span></code></dt>
<dd>value of zpos property</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes generic immutable zpos property and enables
support for it in drm core. Using this property driver lets userspace
to get the arrangement of the planes for blending operation and notifies
it that the hardware (or driver) doesn&#8217;t support changing of the planes&#8217;
order. For mutable zpos see <a class="reference internal" href="#c.drm_plane_create_zpos_property" title="drm_plane_create_zpos_property"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_zpos_property()</span></code></a>.</p>
<p>The property exposed to userspace is called &#8220;zpos&#8221;.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_atomic_normalize_zpos">
int <code class="descname">drm_atomic_normalize_zpos</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.drm_atomic_state" title="drm_atomic_state">drm_atomic_state</a> *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_atomic_normalize_zpos" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate normalized zpos values for all crtcs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_atomic_state</span> <span class="pre">*</span> <span class="pre">state</span></code></dt>
<dd>atomic state of DRM device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function calculates normalized zpos value for all modified planes in
the provided atomic state of DRM device.</p>
<p>For every CRTC this function checks new states of all planes assigned to
it and calculates normalized zpos value for these planes. Planes are compared
first by their zpos values, then by plane id (if zpos is equal). The plane
with lowest zpos value is at the bottom. The <a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">drm_plane_state.normalized_zpos</span></code></a>
is then filled with unique values from 0 to number of active planes in crtc
minus one.</p>
<p>RETURNS
Zero for success or -errno</p>
</div>
<div class="section" id="color-management-properties">
<h3>Color Management Properties<a class="headerlink" href="#color-management-properties" title="Permalink to this headline">¶</a></h3>
<p>Color management or color space adjustments is supported through a set of 5
properties on the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> object. They are set up by calling
<a class="reference internal" href="#c.drm_crtc_enable_color_mgmt" title="drm_crtc_enable_color_mgmt"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_enable_color_mgmt()</span></code></a>.</p>
<dl class="docutils">
<dt>&#8220;DEGAMMA_LUT”:</dt>
<dd><p class="first">Blob property to set the degamma lookup table (LUT) mapping pixel data
from the framebuffer before it is given to the transformation matrix.
The data is interpreted as an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code> elements.
Hardware might choose not to use the full precision of the LUT elements
nor use all the elements of the LUT (for example the hardware might
choose to interpolate between LUT[0] and LUT[4]).</p>
<p class="last">Setting this to NULL (blob property value set to 0) means a
linear/pass-thru gamma table should be used. This is generally the
driver boot-up state too. Drivers can access this blob through
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.degamma_lut</span></code></a>.</p>
</dd>
<dt>“DEGAMMA_LUT_SIZE”:</dt>
<dd>Unsinged range property to give the size of the lookup table to be set
on the DEGAMMA_LUT property (the size depends on the underlying
hardware). If drivers support multiple LUT sizes then they should
publish the largest size, and sub-sample smaller sized LUTs (e.g. for
split-gamma modes) appropriately.</dd>
<dt>“CTM”:</dt>
<dd><p class="first">Blob property to set the current transformation matrix (CTM) apply to
pixel data after the lookup through the degamma LUT and before the
lookup through the gamma LUT. The data is interpreted as a struct
<code class="xref c c-type docutils literal"><span class="pre">drm_color_ctm</span></code>.</p>
<p class="last">Setting this to NULL (blob property value set to 0) means a
unit/pass-thru matrix should be used. This is generally the driver
boot-up state too. Drivers can access the blob for the color conversion
matrix through <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.ctm</span></code></a>.</p>
</dd>
<dt>“GAMMA_LUT”:</dt>
<dd><p class="first">Blob property to set the gamma lookup table (LUT) mapping pixel data
after the transformation matrix to data sent to the connector. The
data is interpreted as an array of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_color_lut</span></code> elements.
Hardware might choose not to use the full precision of the LUT elements
nor use all the elements of the LUT (for example the hardware might
choose to interpolate between LUT[0] and LUT[4]).</p>
<p class="last">Setting this to NULL (blob property value set to 0) means a
linear/pass-thru gamma table should be used. This is generally the
driver boot-up state too. Drivers can access this blob through
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.gamma_lut</span></code></a>.</p>
</dd>
<dt>“GAMMA_LUT_SIZE”:</dt>
<dd>Unsigned range property to give the size of the lookup table to be set
on the GAMMA_LUT property (the size depends on the underlying hardware).
If drivers support multiple LUT sizes then they should publish the
largest size, and sub-sample smaller sized LUTs (e.g. for split-gamma
modes) appropriately.</dd>
</dl>
<p>There is also support for a legacy gamma table, which is set up by calling
<a class="reference internal" href="#c.drm_mode_crtc_set_gamma_size" title="drm_mode_crtc_set_gamma_size"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_crtc_set_gamma_size()</span></code></a>. Drivers which support both should use
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_legacy_gamma_set" title="drm_atomic_helper_legacy_gamma_set"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code></a> to alias the legacy gamma ramp with the
&#8220;GAMMA_LUT&#8221; property above.</p>
<p>Support for different non RGB color encodings is controlled through
<a class="reference internal" href="#c.drm_plane" title="drm_plane"><code class="xref c c-type docutils literal"><span class="pre">drm_plane</span></code></a> specific COLOR_ENCODING and COLOR_RANGE properties. They
are set up by calling <a class="reference internal" href="#c.drm_plane_create_color_properties" title="drm_plane_create_color_properties"><code class="xref c c-func docutils literal"><span class="pre">drm_plane_create_color_properties()</span></code></a>.</p>
<dl class="docutils">
<dt>&#8220;COLOR_ENCODING&#8221;</dt>
<dd>Optional plane enum property to support different non RGB
color encodings. The driver can provide a subset of standard
enum values supported by the DRM plane.</dd>
<dt>&#8220;COLOR_RANGE&#8221;</dt>
<dd>Optional plane enum property to support different non RGB
color parameter ranges. The driver can provide a subset of
standard enum values supported by the DRM plane.</dd>
</dl>
<dl class="function">
<dt id="c.drm_color_lut_extract">
uint32_t <code class="descname">drm_color_lut_extract</code><span class="sig-paren">(</span>uint32_t<em>&nbsp;user_input</em>, uint32_t<em>&nbsp;bit_precision</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_color_lut_extract" title="Permalink to this definition">¶</a></dt>
<dd><p>clamp and round LUT entries</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">user_input</span></code></dt>
<dd>input value</dd>
<dt><code class="docutils literal"><span class="pre">uint32_t</span> <span class="pre">bit_precision</span></code></dt>
<dd>number of bits the hw LUT supports</dd>
</dl>
<p><strong>Description</strong></p>
<p>Extract a degamma/gamma LUT value provided by user (in the form of
<code class="xref c c-type docutils literal"><span class="pre">drm_color_lut</span></code> entries) and round it to the precision supported by the
hardware.</p>
<dl class="function">
<dt id="c.drm_crtc_enable_color_mgmt">
void <code class="descname">drm_crtc_enable_color_mgmt</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, uint<em>&nbsp;degamma_lut_size</em>, bool<em>&nbsp;has_ctm</em>, uint<em>&nbsp;gamma_lut_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_enable_color_mgmt" title="Permalink to this definition">¶</a></dt>
<dd><p>enable color management properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM CRTC</dd>
<dt><code class="docutils literal"><span class="pre">uint</span> <span class="pre">degamma_lut_size</span></code></dt>
<dd>the size of the degamma lut (before CSC)</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">has_ctm</span></code></dt>
<dd>whether to attach ctm_property for CSC matrix</dd>
<dt><code class="docutils literal"><span class="pre">uint</span> <span class="pre">gamma_lut_size</span></code></dt>
<dd>the size of the gamma lut (after CSC)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function lets the driver enable the color correction
properties on a CRTC. This includes 3 degamma, csc and gamma
properties that userspace can set and 2 size properties to inform
the userspace of the lut sizes. Each of the properties are
optional. The gamma and degamma properties are only attached if
their size is not 0 and ctm_property is only attached if has_ctm is
true.</p>
<p>Drivers should use <a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_legacy_gamma_set" title="drm_atomic_helper_legacy_gamma_set"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_legacy_gamma_set()</span></code></a> to implement the
legacy <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.gamma_set</span></code></a> callback.</p>
<dl class="function">
<dt id="c.drm_mode_crtc_set_gamma_size">
int <code class="descname">drm_mode_crtc_set_gamma_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, int<em>&nbsp;gamma_size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_mode_crtc_set_gamma_size" title="Permalink to this definition">¶</a></dt>
<dd><p>set the gamma table size</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC to set the gamma table size for</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">gamma_size</span></code></dt>
<dd>size of the gamma table</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers which support gamma tables should set this to the supported gamma
table size when initializing the CRTC. Currently the drm core only supports a
fixed gamma table size.</p>
<p><strong>Return</strong></p>
<p>Zero on success, negative errno on failure.</p>
<dl class="function">
<dt id="c.drm_plane_create_color_properties">
int <code class="descname">drm_plane_create_color_properties</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_plane" title="drm_plane">drm_plane</a> *<em>&nbsp;plane</em>, u32<em>&nbsp;supported_encodings</em>, u32<em>&nbsp;supported_ranges</em>, enum drm_color_encoding<em>&nbsp;default_encoding</em>, enum drm_color_range<em>&nbsp;default_range</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_plane_create_color_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>color encoding related plane properties</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane</span> <span class="pre">*</span> <span class="pre">plane</span></code></dt>
<dd>plane object</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">supported_encodings</span></code></dt>
<dd>bitfield indicating supported color encodings</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">supported_ranges</span></code></dt>
<dd>bitfileld indicating supported color ranges</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_color_encoding</span> <span class="pre">default_encoding</span></code></dt>
<dd>default color encoding</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">drm_color_range</span> <span class="pre">default_range</span></code></dt>
<dd>default color range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create and attach plane specific COLOR_ENCODING and COLOR_RANGE
properties to <strong>plane</strong>. The supported encodings and ranges should
be provided in supported_encodings and supported_ranges bitmasks.
Each bit set in the bitmask indicates that its number as enum
value is supported.</p>
</div>
<div class="section" id="tile-group-property">
<h3>Tile Group Property<a class="headerlink" href="#tile-group-property" title="Permalink to this headline">¶</a></h3>
<p>Tile groups are used to represent tiled monitors with a unique integer
identifier. Tiled monitors using DisplayID v1.3 have a unique 8-byte handle,
we store this in a tile group, so we have a common identifier for all tiles
in a monitor group. The property is called &#8220;TILE&#8221;. Drivers can manage tile
groups using <a class="reference internal" href="#c.drm_mode_create_tile_group" title="drm_mode_create_tile_group"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_create_tile_group()</span></code></a>, <a class="reference internal" href="#c.drm_mode_put_tile_group" title="drm_mode_put_tile_group"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_put_tile_group()</span></code></a> and
<a class="reference internal" href="#c.drm_mode_get_tile_group" title="drm_mode_get_tile_group"><code class="xref c c-func docutils literal"><span class="pre">drm_mode_get_tile_group()</span></code></a>. But this is only needed for internal panels where
the tile group information is exposed through a non-standard way.</p>
</div>
<div class="section" id="explicit-fencing-properties">
<h3>Explicit Fencing Properties<a class="headerlink" href="#explicit-fencing-properties" title="Permalink to this headline">¶</a></h3>
<p>Explicit fencing allows userspace to control the buffer synchronization
between devices. A Fence or a group of fences are transfered to/from
userspace using Sync File fds and there are two DRM properties for that.
IN_FENCE_FD on each DRM Plane to send fences to the kernel and
OUT_FENCE_PTR on each DRM CRTC to receive fences from the kernel.</p>
<p>As a contrast, with implicit fencing the kernel keeps track of any
ongoing rendering, and automatically ensures that the atomic update waits
for any pending rendering to complete. For shared buffers represented with
a <a class="reference internal" href="../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> this is tracked in <a class="reference internal" href="../driver-api/dma-buf.html#c.reservation_object" title="reservation_object"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">reservation_object</span></code></a>.
Implicit syncing is how Linux traditionally worked (e.g. DRI2/3 on X.org),
whereas explicit fencing is what Android wants.</p>
<dl class="docutils">
<dt>&#8220;IN_FENCE_FD”:</dt>
<dd><p class="first">Use this property to pass a fence that DRM should wait on before
proceeding with the Atomic Commit request and show the framebuffer for
the plane on the screen. The fence can be either a normal fence or a
merged one, the sync_file framework will handle both cases and use a
fence_array if a merged fence is received. Passing -1 here means no
fences to wait on.</p>
<p>If the Atomic Commit request has the DRM_MODE_ATOMIC_TEST_ONLY flag
it will only check if the Sync File is a valid one.</p>
<p class="last">On the driver side the fence is stored on the <strong>fence</strong> parameter of
<a class="reference internal" href="#c.drm_plane_state" title="drm_plane_state"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_plane_state</span></code></a>. Drivers which also support implicit fencing
should set the implicit fence using <a class="reference internal" href="#c.drm_atomic_set_fence_for_plane" title="drm_atomic_set_fence_for_plane"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_set_fence_for_plane()</span></code></a>,
to make sure there&#8217;s consistent behaviour between drivers in precedence
of implicit vs. explicit fencing.</p>
</dd>
<dt>&#8220;OUT_FENCE_PTR”:</dt>
<dd><p class="first">Use this property to pass a file descriptor pointer to DRM. Once the
Atomic Commit request call returns OUT_FENCE_PTR will be filled with
the file descriptor number of a Sync File. This Sync File contains the
CRTC fence that will be signaled when all framebuffers present on the
Atomic Commit * request for that given CRTC are scanned out on the
screen.</p>
<p>The Atomic Commit request fails if a invalid pointer is passed. If the
Atomic Commit request fails for any other reason the out fence fd
returned will be -1. On a Atomic Commit with the
DRM_MODE_ATOMIC_TEST_ONLY flag the out fence will also be set to -1.</p>
<p class="last">Note that out-fences don&#8217;t have a special interface to drivers and are
internally represented by a <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span></code></a> in struct
<a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state</span></code></a>, which is also used by the nonblocking atomic commit
helpers and for the DRM event handling for existing userspace.</p>
</dd>
</dl>
</div>
<div class="section" id="existing-kms-properties">
<h3>Existing KMS Properties<a class="headerlink" href="#existing-kms-properties" title="Permalink to this headline">¶</a></h3>
<p>The following table gives description of drm properties exposed by various
modules/drivers. Because this table is very unwieldy, do not add any new
properties here. Instead document them in a section above.</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Owner Module/Drivers</th>
<th class="head">Group</th>
<th class="head">Property Name</th>
<th class="head">Type</th>
<th class="head">Property Values</th>
<th class="head">Object attached</th>
<th class="head">Description/Restrictions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&nbsp;</td>
<td>DVI-I</td>
<td>“subconnector”</td>
<td>ENUM</td>
<td>{ “Unknown”, “DVI-D”, “DVI-A” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“select subconnector”</td>
<td>ENUM</td>
<td>{ “Automatic”, “DVI-D”, “DVI-A” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>TV</td>
<td>“subconnector”</td>
<td>ENUM</td>
<td>{ &#8220;Unknown&#8221;, &#8220;Composite&#8221;, &#8220;SVIDEO&#8221;, &#8220;Component&#8221;, &#8220;SCART&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“select subconnector”</td>
<td>ENUM</td>
<td>{ &#8220;Automatic&#8221;, &#8220;Composite&#8221;, &#8220;SVIDEO&#8221;, &#8220;Component&#8221;, &#8220;SCART&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“left margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“right margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“top margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“bottom margin”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker reduction”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“overscan”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Virtual GPU</td>
<td>“suggested X”</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffffff</td>
<td>Connector</td>
<td>property to suggest an X offset for a connector</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“suggested Y”</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffffff</td>
<td>Connector</td>
<td>property to suggest an Y offset for a connector</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Optional</td>
<td>&#8220;aspect ratio&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;None&#8221;, &#8220;4:3&#8221;, &#8220;16:9&#8221; }</td>
<td>Connector</td>
<td>TDB</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Optional</td>
<td>&#8220;content type&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;No Data&#8221;, &#8220;Graphics&#8221;, &#8220;Photo&#8221;, &#8220;Cinema&#8221;, &#8220;Game&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>i915</td>
<td>Generic</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Automatic&#8221;, &#8220;Full&#8221;, &#8220;Limited 16:235&#8221; }</td>
<td>Connector</td>
<td>When this property is set to Limited 16:235 and CTM is set, the hardware will be programmed with the result of the multiplication of CTM by the limited range matrix to ensure the pixels normaly in the range 0..1.0 are remapped to the range 16/255..235/255.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“audio”</td>
<td>ENUM</td>
<td>{ &#8220;force-dvi&#8221;, &#8220;off&#8221;, &#8220;auto&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>SDVO-TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;left_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;right_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;top_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;bottom_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“vpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“sharpness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter_adaptive”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter_2d”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“tv_chroma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“tv_luma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“dot_crawl”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>SDVO-TV/LVDS</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>CDV gma-500</td>
<td>Generic</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ “Full”, “Limited 16:235” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;Broadcast RGB&#8221;</td>
<td>ENUM</td>
<td>{ “off”, “auto”, “on” }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>Poulsbo</td>
<td>Generic</td>
<td>“backlight”</td>
<td>RANGE</td>
<td>Min=0, Max=100</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>SDVO-TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;NTSC_M&#8221;, &#8220;NTSC_J&#8221;, &#8220;NTSC_443&#8221;, &#8220;PAL_B&#8221; } etc.</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;left_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;right_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;top_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;bottom_margin&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“vpos”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“sharpness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter_adaptive”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“flicker_filter_2d”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“tv_chroma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“tv_luma_filter”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“dot_crawl”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>SDVO-TV/LVDS</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max= SDVO dependent</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>armada</td>
<td>CRTC</td>
<td>&#8220;CSC_YUV&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Auto&#8221; , &#8220;CCIR601&#8221;, &#8220;CCIR709&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;CSC_RGB&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;Auto&#8221;, &#8220;Computer system&#8221;, &#8220;Studio&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Overlay</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_min&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_max&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_val&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_alpha&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0xffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey_mode&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;disabled&#8221;, &#8220;Y component&#8221;, &#8220;U component&#8221; , &#8220;V component&#8221;, &#8220;RGB&#8221;, “R component&#8221;, &#8220;G component&#8221;, &#8220;B component&#8221; }</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;brightness&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=256 + 255</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;contrast&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x7fff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;saturation&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x7fff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>exynos</td>
<td>CRTC</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;normal&#8221;, &#8220;blank&#8221; }</td>
<td>CRTC</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>i2c/ch7006_drv</td>
<td>Generic</td>
<td>“scale”</td>
<td>RANGE</td>
<td>Min=0, Max=2</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>TV</td>
<td>“mode”</td>
<td>ENUM</td>
<td>{ &#8220;PAL&#8221;, &#8220;PAL-M&#8221;,&#8221;PAL-N&#8221;}, ”PAL-Nc&#8221; , &#8220;PAL-60&#8221;, &#8220;NTSC-M&#8221;, &#8220;NTSC-J&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>nouveau</td>
<td>NV10 Overlay</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“contrast”</td>
<td>RANGE</td>
<td>Min=0, Max=8192-1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=1024</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“hue”</td>
<td>RANGE</td>
<td>Min=0, Max=359</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“saturation”</td>
<td>RANGE</td>
<td>Min=0, Max=8192-1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“iturbt_709”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Nv04 Overlay</td>
<td>“colorkey”</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“brightness”</td>
<td>RANGE</td>
<td>Min=0, Max=1024</td>
<td>Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Display</td>
<td>“dithering mode”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;off&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“dithering depth”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;off&#8221;, &#8220;on&#8221;, &#8220;static 2x2&#8221;, &#8220;dynamic 2x2&#8221;, &#8220;temporal&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“underscan”</td>
<td>ENUM</td>
<td>{ &#8220;auto&#8221;, &#8220;6 bpc&#8221;, &#8220;8 bpc&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“underscan hborder”</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“underscan vborder”</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“vibrant hue”</td>
<td>RANGE</td>
<td>Min=0, Max=180</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>“color vibrance”</td>
<td>RANGE</td>
<td>Min=0, Max=200</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>omap</td>
<td>Generic</td>
<td>“zorder”</td>
<td>RANGE</td>
<td>Min=0, Max=3</td>
<td>CRTC, Plane</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>qxl</td>
<td>Generic</td>
<td>“hotplug_mode_update&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>radeon</td>
<td>DVI-I</td>
<td>“coherent”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>DAC enable load detect</td>
<td>“load detection”</td>
<td>RANGE</td>
<td>Min=0, Max=1</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>TV Standard</td>
<td>&#8220;tv standard&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;ntsc&#8221;, &#8220;pal&#8221;, &#8220;pal-m&#8221;, &#8220;pal-60&#8221;, &#8220;ntsc-j&#8221; , &#8220;scart-pal&#8221;, &#8220;pal-cn&#8221;, &#8220;secam&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>legacy TMDS PLL detect</td>
<td>&#8220;tmds_pll&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;driver&#8221;, &#8220;bios&#8221; }</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>Underscan</td>
<td>&#8220;underscan&#8221;</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221;, &#8220;auto&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;underscan hborder&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;underscan vborder&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=128</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>Audio</td>
<td>“audio”</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221;, &#8220;auto&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>FMT Dithering</td>
<td>“dither”</td>
<td>ENUM</td>
<td>{ &#8220;off&#8221;, &#8220;on&#8221; }</td>
<td>Connector</td>
<td>TBD</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&#8220;colorkey&#8221;</td>
<td>RANGE</td>
<td>Min=0, Max=0x01ffffff</td>
<td>Plane</td>
<td>TBD</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="vertical-blanking">
<h2>Vertical Blanking<a class="headerlink" href="#vertical-blanking" title="Permalink to this headline">¶</a></h2>
<p>Vertical blanking plays a major role in graphics rendering. To achieve
tear-free display, users must synchronize page flips and/or rendering to
vertical blanking. The DRM API offers ioctls to perform page flips
synchronized to vertical blanking and wait for vertical blanking.</p>
<p>The DRM core handles most of the vertical blanking management logic, which
involves filtering out spurious interrupts, keeping race-free blanking
counters, coping with counter wrap-around and resets and keeping use counts.
It relies on the driver to generate vertical blanking interrupts and
optionally provide a hardware vertical blanking counter.</p>
<p>Drivers must initialize the vertical blanking handling core with a call to
<a class="reference internal" href="#c.drm_vblank_init" title="drm_vblank_init"><code class="xref c c-func docutils literal"><span class="pre">drm_vblank_init()</span></code></a>. Minimally, a driver needs to implement
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> and <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> plus call
<a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_handle_vblank()</span></code></a> in it&#8217;s vblank interrupt handler for working vblank
support.</p>
<p>Vertical blanking interrupts can be enabled by the DRM core or by drivers
themselves (for instance to handle page flipping operations).  The DRM core
maintains a vertical blanking use count to ensure that the interrupts are not
disabled while a user still needs them. To increment the use count, drivers
call <a class="reference internal" href="#c.drm_crtc_vblank_get" title="drm_crtc_vblank_get"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_get()</span></code></a> and release the vblank reference again with
<a class="reference internal" href="#c.drm_crtc_vblank_put" title="drm_crtc_vblank_put"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_put()</span></code></a>. In between these two calls vblank interrupts are
guaranteed to be enabled.</p>
<p>On many hardware disabling the vblank interrupt cannot be done in a race-free
manner, see <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.vblank_disable_immediate</span></code></a> and
<a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.max_vblank_count</span></code></a>. In that case the vblank core only disables the
vblanks after a timer has expired, which can be configured through the
<code class="docutils literal"><span class="pre">vblankoffdelay</span></code> module parameter.</p>
<div class="section" id="vertical-blanking-and-interrupt-handling-functions-reference">
<h3>Vertical Blanking and Interrupt Handling Functions Reference<a class="headerlink" href="#vertical-blanking-and-interrupt-handling-functions-reference" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="c.drm_pending_vblank_event">
struct <code class="descname">drm_pending_vblank_event</code><a class="headerlink" href="#c.drm_pending_vblank_event" title="Permalink to this definition">¶</a></dt>
<dd><p>pending vblank event tracking</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_pending_vblank_event {
  struct drm_pending_event base;
  unsigned int pipe;
  u64 sequence;
  union {
    struct drm_event base;
    struct drm_event_vblank vbl;
    struct drm_event_crtc_sequence seq;
  } event;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>Base structure for tracking pending DRM events.</dd>
<dt><code class="docutils literal"><span class="pre">pipe</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> this event is for.</dd>
<dt><code class="docutils literal"><span class="pre">sequence</span></code></dt>
<dd>frame event should be triggered at</dd>
<dt><code class="docutils literal"><span class="pre">event</span></code></dt>
<dd>Actual event which will be sent to userspace.</dd>
<dt><code class="docutils literal"><span class="pre">event.base</span></code></dt>
<dd>DRM event base class.</dd>
<dt><code class="docutils literal"><span class="pre">event.vbl</span></code></dt>
<dd>Event payload for vblank events, requested through
either the MODE_PAGE_FLIP or MODE_ATOMIC IOCTL. Also
generated by the legacy WAIT_VBLANK IOCTL, but new userspace
should use MODE_QUEUE_SEQUENCE and <code class="xref c c-type docutils literal"><span class="pre">event.seq</span></code> instead.</dd>
<dt><code class="docutils literal"><span class="pre">event.seq</span></code></dt>
<dd>Event payload for the MODE_QUEUEU_SEQUENCE IOCTL.</dd>
</dl>
<dl class="type">
<dt id="c.drm_vblank_crtc">
struct <code class="descname">drm_vblank_crtc</code><a class="headerlink" href="#c.drm_vblank_crtc" title="Permalink to this definition">¶</a></dt>
<dd><p>vblank tracking for a CRTC</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct drm_vblank_crtc {
  struct drm_device *dev;
  wait_queue_head_t queue;
  struct timer_list disable_timer;
  seqlock_t seqlock;
  u64 count;
  ktime_t time;
  atomic_t refcount;
  u32 last;
  unsigned int inmodeset;
  unsigned int pipe;
  int framedur_ns;
  int linedur_ns;
  struct drm_display_mode hwmode;
  bool enabled;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Pointer to the <code class="xref c c-type docutils literal"><span class="pre">drm_device</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">queue</span></code></dt>
<dd>Wait queue for vblank waiters.</dd>
<dt><code class="docutils literal"><span class="pre">disable_timer</span></code></dt>
<dd>Disable timer for the delayed vblank disabling
hysteresis logic. Vblank disabling is controlled through the
drm_vblank_offdelay module option and the setting of the
<code class="xref c c-type docutils literal"><span class="pre">drm_device.max_vblank_count</span></code> value.</dd>
<dt><code class="docutils literal"><span class="pre">seqlock</span></code></dt>
<dd>Protect vblank count and time.</dd>
<dt><code class="docutils literal"><span class="pre">count</span></code></dt>
<dd>Current software vblank counter.</dd>
<dt><code class="docutils literal"><span class="pre">time</span></code></dt>
<dd>Vblank timestamp corresponding to <strong>count</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>Number of users/waiters of the vblank interrupt. Only when
this refcount reaches 0 can the hardware interrupt be disabled using
<strong>disable_timer</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">last</span></code></dt>
<dd>Protected by <code class="xref c c-type docutils literal"><span class="pre">drm_device.vbl_lock</span></code>, used for wraparound handling.</dd>
<dt><code class="docutils literal"><span class="pre">inmodeset</span></code></dt>
<dd>Tracks whether the vblank is disabled due to a modeset.
For legacy driver bit 2 additionally tracks whether an additional
temporary vblank reference has been acquired to paper over the
hardware counter resetting/jumping. KMS drivers should instead just
call <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> and <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code></a>, which explicitly
save and restore the vblank count.</dd>
<dt><code class="docutils literal"><span class="pre">pipe</span></code></dt>
<dd><a class="reference internal" href="#c.drm_crtc_index" title="drm_crtc_index"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_index()</span></code></a> of the <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> corresponding to this
structure.</dd>
<dt><code class="docutils literal"><span class="pre">framedur_ns</span></code></dt>
<dd>Frame/Field duration in ns, used by
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a> and computed by
<a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">linedur_ns</span></code></dt>
<dd>Line duration in ns, used by
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a> and computed by
<a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">hwmode</span></code></dt>
<dd>Cache of the current hardware display mode. Only valid when <strong>enabled</strong>
is set. This is used by helpers like
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a>. We can&#8217;t just access the
hardware mode by e.g. looking at <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted_mode</span></code></a>,
because that one is really hard to get from interrupt context.</dd>
<dt><code class="docutils literal"><span class="pre">enabled</span></code></dt>
<dd>Tracks the enabling state of the corresponding <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc</span></code></a> to
avoid double-disabling and hence corrupting saved state. Needed by
drivers not using atomic KMS, since those might go through their CRTC
disabling functions multiple times.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure tracks the vblank state for one CRTC.</p>
<p>Note that for historical reasons - the vblank handling code is still shared
with legacy/non-kms drivers - this is a free-standing structure not directly
connected to <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a>. But all public interface functions are taking
a <a class="reference internal" href="#c.drm_crtc" title="drm_crtc"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span></code></a> to hide this implementation detail.</p>
<dl class="function">
<dt id="c.drm_crtc_accurate_vblank_count">
u64 <code class="descname">drm_crtc_accurate_vblank_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_accurate_vblank_count" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve the master vblank counter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which counter to retrieve</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar to <a class="reference internal" href="#c.drm_crtc_vblank_count" title="drm_crtc_vblank_count"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_count()</span></code></a> but this function
interpolates to handle a race with vblank interrupts using the high precision
timestamping support.</p>
<p>This is mostly useful for hardware that can obtain the scanout position, but
doesn&#8217;t have a hardware frame counter.</p>
<dl class="function">
<dt id="c.drm_vblank_init">
int <code class="descname">drm_vblank_init</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;num_crtcs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize vblank support</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_crtcs</span></code></dt>
<dd>number of CRTCs supported by <strong>dev</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes vblank support for <strong>num_crtcs</strong> display pipelines.
Cleanup is handled by the DRM core, or through calling <a class="reference internal" href="drm-internals.html#c.drm_dev_fini" title="drm_dev_fini"><code class="xref c c-func docutils literal"><span class="pre">drm_dev_fini()</span></code></a> for
drivers with a <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.release</span></code></a> callback.</p>
<p><strong>Return</strong></p>
<p>Zero on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_waitqueue">
wait_queue_head_t * <code class="descname">drm_crtc_vblank_waitqueue</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_waitqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>get vblank waitqueue for the CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which CRTC&#8217;s vblank waitqueue to retrieve</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a pointer to the vblank waitqueue for the CRTC.
Drivers can use this to implement vblank waits using <a class="reference internal" href="../driver-api/basics.html#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal"><span class="pre">wait_event()</span></code></a> and related
functions.</p>
<dl class="function">
<dt id="c.drm_calc_timestamping_constants">
void <code class="descname">drm_calc_timestamping_constants</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, const struct <a class="reference internal" href="#c.drm_display_mode" title="drm_display_mode">drm_display_mode</a> *<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_calc_timestamping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate vblank timestamp constants</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>drm_crtc whose timestamp constants should be updated.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">drm_display_mode</span> <span class="pre">*</span> <span class="pre">mode</span></code></dt>
<dd>display mode containing the scanout timings</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calculate and store various constants which are later needed by vblank and
swap-completion timestamping, e.g, by
<a class="reference internal" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="drm_calc_vbltimestamp_from_scanoutpos"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_vbltimestamp_from_scanoutpos()</span></code></a>. They are derived from CRTC&#8217;s true
scanout timing, so they take things like panel scaling or other adjustments
into account.</p>
<dl class="function">
<dt id="c.drm_calc_vbltimestamp_from_scanoutpos">
bool <code class="descname">drm_calc_vbltimestamp_from_scanoutpos</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;pipe</em>, int *<em>&nbsp;max_error</em>, ktime_t *<em>&nbsp;vblank_time</em>, bool<em>&nbsp;in_vblank_irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_calc_vbltimestamp_from_scanoutpos" title="Permalink to this definition">¶</a></dt>
<dd><p>precise vblank timestamp helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt>
<dd>index of CRTC whose vblank timestamp to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">max_error</span></code></dt>
<dd>Desired maximum allowable error in timestamps (nanosecs)
On return contains true maximum error of timestamp</dd>
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">*</span> <span class="pre">vblank_time</span></code></dt>
<dd>Pointer to time which should receive the timestamp</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">in_vblank_irq</span></code></dt>
<dd>True when called from <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.  Some drivers
need to apply some workarounds for gpu-specific vblank irq quirks
if flag is set.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Implements calculation of exact vblank timestamps from given drm_display_mode
timings and current video scanout position of a CRTC. This can be directly
used as the <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.get_vblank_timestamp</span></code></a> implementation of a kms driver
if <a class="reference internal" href="drm-internals.html#c.drm_driver" title="drm_driver"><code class="xref c c-type docutils literal"><span class="pre">drm_driver.get_scanout_position</span></code></a> is implemented.</p>
<p>The current implementation only handles standard video modes. For double scan
and interlaced modes the driver is supposed to adjust the hardware mode
(taken from <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.adjusted</span></code></a> mode for atomic modeset drivers) to
match the scanout position reported.</p>
<p>Note that atomic drivers must call <a class="reference internal" href="#c.drm_calc_timestamping_constants" title="drm_calc_timestamping_constants"><code class="xref c c-func docutils literal"><span class="pre">drm_calc_timestamping_constants()</span></code></a> before
enabling a CRTC. The atomic helpers already take care of that in
<a class="reference internal" href="drm-kms-helpers.html#c.drm_atomic_helper_update_legacy_modeset_state" title="drm_atomic_helper_update_legacy_modeset_state"><code class="xref c c-func docutils literal"><span class="pre">drm_atomic_helper_update_legacy_modeset_state()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>Returns true on success, and false on failure, i.e. when no accurate
timestamp could be acquired.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_count">
u64 <code class="descname">drm_crtc_vblank_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_count" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve &#8220;cooked&#8221; vblank counter value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which counter to retrieve</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fetches the &#8220;cooked&#8221; vblank count value that represents the number of
vblank events since the system was booted, including lost events due to
modesetting activity. Note that this timer isn&#8217;t correct against a racing
vblank interrupt (since it only reports the software vblank counter), see
<a class="reference internal" href="#c.drm_crtc_accurate_vblank_count" title="drm_crtc_accurate_vblank_count"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_accurate_vblank_count()</span></code></a> for such use-cases.</p>
<p><strong>Return</strong></p>
<p>The software vblank counter.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_count_and_time">
u64 <code class="descname">drm_crtc_vblank_count_and_time</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, ktime_t *<em>&nbsp;vblanktime</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_count_and_time" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve &#8220;cooked&#8221; vblank counter value and the system timestamp corresponding to that vblank counter value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which counter to retrieve</dd>
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">*</span> <span class="pre">vblanktime</span></code></dt>
<dd>Pointer to time to receive the vblank timestamp.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Fetches the &#8220;cooked&#8221; vblank count value that represents the number of
vblank events since the system was booted, including lost events due to
modesetting activity. Returns corresponding system timestamp of the time
of the vblank interval that corresponds to the current vblank counter value.</p>
<dl class="function">
<dt id="c.drm_crtc_arm_vblank_event">
void <code class="descname">drm_crtc_arm_vblank_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em>&nbsp;e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_arm_vblank_event" title="Permalink to this definition">¶</a></dt>
<dd><p>arm vblank event after pageflip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the source CRTC of the vblank event</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*</span> <span class="pre">e</span></code></dt>
<dd>the event to send</dd>
</dl>
<p><strong>Description</strong></p>
<p>A lot of drivers need to generate vblank events for the very next vblank
interrupt. For example when the page flip interrupt happens when the page
flip gets armed, but not when it actually executes within the next vblank
period. This helper function implements exactly the required vblank arming
behaviour.</p>
<p><strong>NOTE</strong></p>
<p>Drivers using this to send out the <a class="reference internal" href="#c.drm_crtc_state" title="drm_crtc_state"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_state.event</span></code></a> as part of an
atomic commit must ensure that the next vblank happens at exactly the same
time as the atomic commit is committed to the hardware. This function itself
does <strong>not</strong> protect against the next vblank interrupt racing with either this
function call or the atomic commit operation. A possible sequence could be:</p>
<ol class="arabic simple">
<li>Driver commits new hardware state into vblank-synchronized registers.</li>
<li>A vblank happens, committing the hardware state. Also the corresponding
vblank interrupt is fired off and fully processed by the interrupt
handler.</li>
<li>The atomic commit operation proceeds to call <a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a>.</li>
<li>The event is only send out for the next vblank, which is wrong.</li>
</ol>
<p>An equivalent race can happen when the driver calls
<a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a> before writing out the new hardware state.</p>
<p>The only way to make this work safely is to prevent the vblank from firing
(and the hardware from committing anything else) until the entire atomic
commit sequence has run to completion. If the hardware does not have such a
feature (e.g. using a &#8220;go&#8221; bit), then it is unsafe to use this functions.
Instead drivers need to manually send out the event from their interrupt
handler by calling <a class="reference internal" href="#c.drm_crtc_send_vblank_event" title="drm_crtc_send_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_send_vblank_event()</span></code></a> and make sure that there&#8217;s no
possible race with the hardware committing the atomic update.</p>
<p>Caller must hold a vblank reference for the event <strong>e</strong>, which will be dropped
when the next vblank arrives.</p>
<dl class="function">
<dt id="c.drm_crtc_send_vblank_event">
void <code class="descname">drm_crtc_send_vblank_event</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em>, struct <a class="reference internal" href="#c.drm_pending_vblank_event" title="drm_pending_vblank_event">drm_pending_vblank_event</a> *<em>&nbsp;e</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_send_vblank_event" title="Permalink to this definition">¶</a></dt>
<dd><p>helper to send vblank event after pageflip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>the source CRTC of the vblank event</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_pending_vblank_event</span> <span class="pre">*</span> <span class="pre">e</span></code></dt>
<dd>the event to send</dd>
</dl>
<p><strong>Description</strong></p>
<p>Updates sequence # and timestamp on event for the most recently processed
vblank, and sends it to userspace.  Caller must hold event lock.</p>
<p>See <a class="reference internal" href="#c.drm_crtc_arm_vblank_event" title="drm_crtc_arm_vblank_event"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_arm_vblank_event()</span></code></a> for a helper which can be used in certain
situation, especially to send out events for atomic commit operations.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_get">
int <code class="descname">drm_crtc_vblank_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_get" title="Permalink to this definition">¶</a></dt>
<dd><p>get a reference count on vblank events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which CRTC to own</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquire a reference count on vblank events to avoid having them disabled
while in use.</p>
<p><strong>Return</strong></p>
<p>Zero on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_put">
void <code class="descname">drm_crtc_vblank_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_put" title="Permalink to this definition">¶</a></dt>
<dd><p>give up ownership of vblank events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>which counter to give up</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release ownership of a given vblank counter, turning off interrupts
if possible. Disable interrupts after drm_vblank_offdelay milliseconds.</p>
<dl class="function">
<dt id="c.drm_wait_one_vblank">
void <code class="descname">drm_wait_one_vblank</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_wait_one_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for one vblank</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt>
<dd>CRTC index</dd>
</dl>
<p><strong>Description</strong></p>
<p>This waits for one vblank to pass on <strong>pipe</strong>, using the irq driver interfaces.
It is a failure to call this when the vblank irq for <strong>pipe</strong> is disabled, e.g.
due to lack of driver support or because the crtc is off.</p>
<p>This is the legacy version of <a class="reference internal" href="#c.drm_crtc_wait_one_vblank" title="drm_crtc_wait_one_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_wait_one_vblank()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_wait_one_vblank">
void <code class="descname">drm_crtc_wait_one_vblank</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_wait_one_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for one vblank</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>DRM crtc</dd>
</dl>
<p><strong>Description</strong></p>
<p>This waits for one vblank to pass on <strong>crtc</strong>, using the irq driver interfaces.
It is a failure to call this when the vblank irq for <strong>crtc</strong> is disabled, e.g.
due to lack of driver support or because the crtc is off.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_off">
void <code class="descname">drm_crtc_vblank_off</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_off" title="Permalink to this definition">¶</a></dt>
<dd><p>disable vblank events on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function to shut down the vblank interrupt handling when
disabling a crtc. This function ensures that the latest vblank frame count is
stored so that drm_vblank_on can restore it again.</p>
<p>Drivers must use this function when the hardware vblank counter can get
reset, e.g. when suspending or disabling the <strong>crtc</strong> in general.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_reset">
void <code class="descname">drm_crtc_vblank_reset</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset vblank state to off on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers can use this function to reset the vblank state to off at load time.
Drivers should use this together with the <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> and
<a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code></a> functions. The difference compared to
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> is that this function doesn&#8217;t save the vblank counter
and hence doesn&#8217;t need to call any driver hooks.</p>
<p>This is useful for recovering driver state e.g. on driver load, or on resume.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_on">
void <code class="descname">drm_crtc_vblank_on</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_on" title="Permalink to this definition">¶</a></dt>
<dd><p>enable vblank events on a CRTC</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>This functions restores the vblank interrupt state captured with
<a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> again and is generally called when enabling <strong>crtc</strong>. Note
that calls to <a class="reference internal" href="#c.drm_crtc_vblank_on" title="drm_crtc_vblank_on"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_on()</span></code></a> and <a class="reference internal" href="#c.drm_crtc_vblank_off" title="drm_crtc_vblank_off"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_off()</span></code></a> can be
unbalanced and so can also be unconditionally called in driver load code to
reflect the current hardware state of the crtc.</p>
<dl class="function">
<dt id="c.drm_vblank_restore">
void <code class="descname">drm_vblank_restore</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_vblank_restore" title="Permalink to this definition">¶</a></dt>
<dd><p>estimate missed vblanks and update vblank count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt>
<dd>CRTC index</dd>
</dl>
<p><strong>Description</strong></p>
<p>Power manamement features can cause frame counter resets between vblank
disable and enable. Drivers can use this function in their
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> implementation to estimate missed vblanks since
the last <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> using timestamps and update the
vblank counter.</p>
<p>This function is the legacy version of <a class="reference internal" href="#c.drm_crtc_vblank_restore" title="drm_crtc_vblank_restore"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_vblank_restore()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_vblank_restore">
void <code class="descname">drm_crtc_vblank_restore</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_vblank_restore" title="Permalink to this definition">¶</a></dt>
<dd><p>estimate missed vblanks and update vblank count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>CRTC in question</dd>
</dl>
<p><strong>Description</strong></p>
<p>Power manamement features can cause frame counter resets between vblank
disable and enable. Drivers can use this function in their
<a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.enable_vblank</span></code></a> implementation to estimate missed vblanks since
the last <a class="reference internal" href="#c.drm_crtc_funcs" title="drm_crtc_funcs"><code class="xref c c-type docutils literal"><span class="pre">drm_crtc_funcs.disable_vblank</span></code></a> using timestamps and update the
vblank counter.</p>
<dl class="function">
<dt id="c.drm_handle_vblank">
bool <code class="descname">drm_handle_vblank</code><span class="sig-paren">(</span>struct drm_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_handle_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a vblank event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>DRM device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pipe</span></code></dt>
<dd>index of CRTC where this event occurred</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should call this routine in their vblank interrupt handlers to
update the vblank counter and send any signals that may be pending.</p>
<p>This is the legacy version of <a class="reference internal" href="#c.drm_crtc_handle_vblank" title="drm_crtc_handle_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_crtc_handle_vblank()</span></code></a>.</p>
<dl class="function">
<dt id="c.drm_crtc_handle_vblank">
bool <code class="descname">drm_crtc_handle_vblank</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.drm_crtc" title="drm_crtc">drm_crtc</a> *<em>&nbsp;crtc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drm_crtc_handle_vblank" title="Permalink to this definition">¶</a></dt>
<dd><p>handle a vblank event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">drm_crtc</span> <span class="pre">*</span> <span class="pre">crtc</span></code></dt>
<dd>where this event occurred</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers should call this routine in their vblank interrupt handlers to
update the vblank counter and send any signals that may be pending.</p>
<p>This is the native KMS version of <a class="reference internal" href="#c.drm_handle_vblank" title="drm_handle_vblank"><code class="xref c c-func docutils literal"><span class="pre">drm_handle_vblank()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>True if the event was successfully handled, false on failure.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="drm-kms-helpers.html" class="btn btn-neutral float-right" title="Mode Setting Helper Functions" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="drm-mm.html" class="btn btn-neutral" title="DRM Memory Management" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>