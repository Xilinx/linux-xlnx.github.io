

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Driver Basics &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="The Linux driver implementer’s API guide" href="index.html"/>
        <link rel="next" title="Device drivers infrastructure" href="infrastructure.html"/>
        <link rel="prev" title="The Linux driver implementer’s API guide" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="">Driver Basics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver-entry-and-exit-points">Driver Entry and Exit points</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-device-table">Driver device table</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delaying-scheduling-and-timer-routines">Delaying, scheduling, and timer routines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wait-queues-and-wake-events">Wait queues and Wake events</a></li>
<li class="toctree-l3"><a class="reference internal" href="#high-resolution-timers">High-resolution timers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#workqueues-and-kevents">Workqueues and Kevents</a></li>
<li class="toctree-l3"><a class="reference internal" href="#internal-functions">Internal Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference-counting">Reference counting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#atomics">Atomics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-objects-manipulation">Kernel objects manipulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-utility-functions">Kernel utility functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-resource-management">Device Resource Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas&#8217; 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
    <li>Driver Basics</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/basics.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="driver-basics">
<h1>Driver Basics<a class="headerlink" href="#driver-basics" title="Permalink to this headline">¶</a></h1>
<div class="section" id="driver-entry-and-exit-points">
<h2>Driver Entry and Exit points<a class="headerlink" href="#driver-entry-and-exit-points" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.module_init">
<code class="descname">module_init</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_init" title="Permalink to this definition">¶</a></dt>
<dd><p>driver initialization entry point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>function to be run at kernel boot time or module insertion</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.module_init" title="module_init"><code class="xref c c-func docutils literal"><span class="pre">module_init()</span></code></a> will either be called during <code class="xref c c-func docutils literal"><span class="pre">do_initcalls()</span></code> (if
builtin) or at module insertion time (if a module).  There can only
be one per module.</p>
<dl class="function">
<dt id="c.module_exit">
<code class="descname">module_exit</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_exit" title="Permalink to this definition">¶</a></dt>
<dd><p>driver exit entry point</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>function to be run when driver is removed</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code></a> will wrap the driver clean-up code
with <code class="xref c c-func docutils literal"><span class="pre">cleanup_module()</span></code> when used with rmmod when
the driver is a module.  If the driver is statically
compiled into the kernel, <a class="reference internal" href="#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code></a> has no effect.
There can only be one per module.</p>
</div>
<div class="section" id="driver-device-table">
<h2>Driver device table<a class="headerlink" href="#driver-device-table" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.usb_device_id">
struct <code class="descname">usb_device_id</code><a class="headerlink" href="#c.usb_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identifies USB devices for probing and hotplugging</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct usb_device_id {
  __u16 match_flags;
  __u16 idVendor;
  __u16 idProduct;
  __u16 bcdDevice_lo;
  __u16 bcdDevice_hi;
  __u8 bDeviceClass;
  __u8 bDeviceSubClass;
  __u8 bDeviceProtocol;
  __u8 bInterfaceClass;
  __u8 bInterfaceSubClass;
  __u8 bInterfaceProtocol;
  __u8 bInterfaceNumber;
  kernel_ulong_t driver_info ;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">match_flags</span></code></dt>
<dd>Bit mask controlling which of the other fields are used to
match against new devices. Any field except for driver_info may be
used, although some only make sense in conjunction with other fields.
This is usually set by a USB_DEVICE_*() macro, which sets all
other fields in this structure except for driver_info.</dd>
<dt><code class="docutils literal"><span class="pre">idVendor</span></code></dt>
<dd>USB vendor ID for a device; numbers are assigned
by the USB forum to its members.</dd>
<dt><code class="docutils literal"><span class="pre">idProduct</span></code></dt>
<dd>Vendor-assigned product ID.</dd>
<dt><code class="docutils literal"><span class="pre">bcdDevice_lo</span></code></dt>
<dd>Low end of range of vendor-assigned product version numbers.
This is also used to identify individual product versions, for
a range consisting of a single device.</dd>
<dt><code class="docutils literal"><span class="pre">bcdDevice_hi</span></code></dt>
<dd>High end of version number range.  The range of product
versions is inclusive.</dd>
<dt><code class="docutils literal"><span class="pre">bDeviceClass</span></code></dt>
<dd>Class of device; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Device classes specify behavior of all
the interfaces on a device.</dd>
<dt><code class="docutils literal"><span class="pre">bDeviceSubClass</span></code></dt>
<dd>Subclass of device; associated with bDeviceClass.</dd>
<dt><code class="docutils literal"><span class="pre">bDeviceProtocol</span></code></dt>
<dd>Protocol of device; associated with bDeviceClass.</dd>
<dt><code class="docutils literal"><span class="pre">bInterfaceClass</span></code></dt>
<dd>Class of interface; numbers are assigned
by the USB forum.  Products may choose to implement classes,
or be vendor-specific.  Interface classes specify behavior only
of a given interface; other interfaces may support other classes.</dd>
<dt><code class="docutils literal"><span class="pre">bInterfaceSubClass</span></code></dt>
<dd>Subclass of interface; associated with bInterfaceClass.</dd>
<dt><code class="docutils literal"><span class="pre">bInterfaceProtocol</span></code></dt>
<dd>Protocol of interface; associated with bInterfaceClass.</dd>
<dt><code class="docutils literal"><span class="pre">bInterfaceNumber</span></code></dt>
<dd>Number of interface; composite devices may use
fixed interface numbers to differentiate between vendor-specific
interfaces.</dd>
<dt><code class="docutils literal"><span class="pre">driver_info</span></code></dt>
<dd>Holds information used by the driver.  Usually it holds
a pointer to a descriptor understood by the driver, or perhaps
device flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>In most cases, drivers will create a table of device IDs by using
<a class="reference internal" href="usb/usb.html#c.USB_DEVICE" title="USB_DEVICE"><code class="xref c c-func docutils literal"><span class="pre">USB_DEVICE()</span></code></a>, or similar macros designed for that purpose.
They will then export it to userspace using <code class="xref c c-func docutils literal"><span class="pre">MODULE_DEVICE_TABLE()</span></code>,
and provide it to the USB core through their usb_driver structure.</p>
<p>See the <a class="reference internal" href="usb/usb.html#c.usb_match_id" title="usb_match_id"><code class="xref c c-func docutils literal"><span class="pre">usb_match_id()</span></code></a> function for information about how matches are
performed.  Briefly, you will normally use one of several macros to help
construct these entries.  Each entry you provide will either identify
one or more specific products, or will identify a class of products
which have agreed to behave the same.  You should put the more specific
matches towards the beginning of your table, so that driver_info can
record quirks of specific products.</p>
<dl class="type">
<dt id="c.mdio_device_id">
struct <code class="descname">mdio_device_id</code><a class="headerlink" href="#c.mdio_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identifies PHY devices on an MDIO/MII bus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mdio_device_id {
  __u32 phy_id;
  __u32 phy_id_mask;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">phy_id</span></code></dt>
<dd>The result of
(mdio_read(<code class="xref c c-type docutils literal"><span class="pre">MII_PHYSID1</span></code>) &lt;&lt; 16 | mdio_read(<code class="xref c c-type docutils literal"><span class="pre">PHYSID2</span></code>)) &amp; <strong>phy_id_mask</strong>
for this PHY type</dd>
<dt><code class="docutils literal"><span class="pre">phy_id_mask</span></code></dt>
<dd>Defines the significant bits of <strong>phy_id</strong>.  A value of 0
is used to terminate an array of struct mdio_device_id.</dd>
</dl>
<dl class="type">
<dt id="c.amba_id">
struct <code class="descname">amba_id</code><a class="headerlink" href="#c.amba_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identifies a device on an AMBA bus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct amba_id {
  unsigned int            id;
  unsigned int            mask;
  void *data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>The significant bits if the hardware device ID</dd>
<dt><code class="docutils literal"><span class="pre">mask</span></code></dt>
<dd>Bitmask specifying which bits of the id field are significant when
matching.  A driver binds to a device when ((hardware device ID) &amp; mask)
== id.</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>Private data used by the driver.</dd>
</dl>
<dl class="type">
<dt id="c.mips_cdmm_device_id">
struct <code class="descname">mips_cdmm_device_id</code><a class="headerlink" href="#c.mips_cdmm_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>identifies devices in MIPS CDMM bus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mips_cdmm_device_id {
  __u8 type;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Device type identifier.</dd>
</dl>
<dl class="type">
<dt id="c.mei_cl_device_id">
struct <code class="descname">mei_cl_device_id</code><a class="headerlink" href="#c.mei_cl_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>MEI client device identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct mei_cl_device_id {
  char name[MEI_CL_NAME_SIZE];
  uuid_le uuid;
  __u8 version;
  kernel_ulong_t driver_info;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>helper name</dd>
<dt><code class="docutils literal"><span class="pre">uuid</span></code></dt>
<dd>client uuid</dd>
<dt><code class="docutils literal"><span class="pre">version</span></code></dt>
<dd>client protocol version</dd>
<dt><code class="docutils literal"><span class="pre">driver_info</span></code></dt>
<dd>information used by the driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>identifies mei client device by uuid and name</p>
<dl class="type">
<dt id="c.rio_device_id">
struct <code class="descname">rio_device_id</code><a class="headerlink" href="#c.rio_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>RIO device identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct rio_device_id {
  __u16 did, vid;
  __u16 asm_did, asm_vid;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">did</span></code></dt>
<dd>RapidIO device ID</dd>
<dt><code class="docutils literal"><span class="pre">vid</span></code></dt>
<dd>RapidIO vendor ID</dd>
<dt><code class="docutils literal"><span class="pre">asm_did</span></code></dt>
<dd>RapidIO assembly device ID</dd>
<dt><code class="docutils literal"><span class="pre">asm_vid</span></code></dt>
<dd>RapidIO assembly vendor ID</dd>
</dl>
<p><strong>Description</strong></p>
<p>Identifies a RapidIO device based on both the device/vendor IDs and
the assembly device/vendor IDs.</p>
<dl class="type">
<dt id="c.fsl_mc_device_id">
struct <code class="descname">fsl_mc_device_id</code><a class="headerlink" href="#c.fsl_mc_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>MC object device identifier</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct fsl_mc_device_id {
  __u16 vendor;
  const char obj_type[16];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vendor</span></code></dt>
<dd>vendor ID</dd>
<dt><code class="docutils literal"><span class="pre">obj_type</span></code></dt>
<dd>MC object type</dd>
</dl>
<p><strong>Description</strong></p>
<p>Type of entries in the &#8220;device Id&#8221; table for MC object devices supported by
a MC object device driver. The last entry of the table has vendor set to 0x0</p>
<dl class="type">
<dt id="c.tb_service_id">
struct <code class="descname">tb_service_id</code><a class="headerlink" href="#c.tb_service_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Thunderbolt service identifiers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct tb_service_id {
  __u32 match_flags;
  char protocol_key[8 + 1];
  __u32 protocol_id;
  __u32 protocol_version;
  __u32 protocol_revision;
  kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">match_flags</span></code></dt>
<dd>Flags used to match the structure</dd>
<dt><code class="docutils literal"><span class="pre">protocol_key</span></code></dt>
<dd>Protocol key the service supports</dd>
<dt><code class="docutils literal"><span class="pre">protocol_id</span></code></dt>
<dd>Protocol id the service supports</dd>
<dt><code class="docutils literal"><span class="pre">protocol_version</span></code></dt>
<dd>Version of the protocol</dd>
<dt><code class="docutils literal"><span class="pre">protocol_revision</span></code></dt>
<dd>Revision of the protocol software</dd>
<dt><code class="docutils literal"><span class="pre">driver_data</span></code></dt>
<dd>Driver specific data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Thunderbolt XDomain services are exposed as devices where each device
carries the protocol information the service supports. Thunderbolt
XDomain service drivers match against that information.</p>
<dl class="type">
<dt id="c.typec_device_id">
struct <code class="descname">typec_device_id</code><a class="headerlink" href="#c.typec_device_id" title="Permalink to this definition">¶</a></dt>
<dd><p>USB Type-C alternate mode identifiers</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct typec_device_id {
  __u16 svid;
  __u8 mode;
  kernel_ulong_t driver_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">svid</span></code></dt>
<dd>Standard or Vendor ID</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>Mode index</dd>
<dt><code class="docutils literal"><span class="pre">driver_data</span></code></dt>
<dd>Driver specific data</dd>
</dl>
</div>
<div class="section" id="delaying-scheduling-and-timer-routines">
<h2>Delaying, scheduling, and timer routines<a class="headerlink" href="#delaying-scheduling-and-timer-routines" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.prev_cputime">
struct <code class="descname">prev_cputime</code><a class="headerlink" href="#c.prev_cputime" title="Permalink to this definition">¶</a></dt>
<dd><p>snapshot of system and user cputime</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct prev_cputime {
#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE;
  u64 utime;
  u64 stime;
  raw_spinlock_t lock;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">utime</span></code></dt>
<dd>time spent in user mode</dd>
<dt><code class="docutils literal"><span class="pre">stime</span></code></dt>
<dd>time spent in system mode</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>protects the above two fields</dd>
</dl>
<p><strong>Description</strong></p>
<p>Stores previous user/system time values such that we can guarantee
monotonicity.</p>
<dl class="type">
<dt id="c.task_cputime">
struct <code class="descname">task_cputime</code><a class="headerlink" href="#c.task_cputime" title="Permalink to this definition">¶</a></dt>
<dd><p>collected CPU time counts</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct task_cputime {
  u64 utime;
  u64 stime;
  unsigned long long              sum_exec_runtime;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">utime</span></code></dt>
<dd>time spent in user mode, in nanoseconds</dd>
<dt><code class="docutils literal"><span class="pre">stime</span></code></dt>
<dd>time spent in kernel mode, in nanoseconds</dd>
<dt><code class="docutils literal"><span class="pre">sum_exec_runtime</span></code></dt>
<dd>total time spent on the CPU, in nanoseconds</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure groups together three kinds of CPU time that are tracked for
threads and thread groups.  Most things considering CPU time want to group
these counts together and treat all three of them in parallel.</p>
<dl class="type">
<dt id="c.util_est">
struct <code class="descname">util_est</code><a class="headerlink" href="#c.util_est" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimation utilization of FAIR tasks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct util_est {
  unsigned int                    enqueued;
  unsigned int                    ewma;
#define UTIL_EST_WEIGHT_SHIFT           2;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enqueued</span></code></dt>
<dd>instantaneous estimated utilization of a task/cpu</dd>
<dt><code class="docutils literal"><span class="pre">ewma</span></code></dt>
<dd>the Exponential Weighted Moving Average (EWMA)
utilization of a task</dd>
</dl>
<p><strong>Description</strong></p>
<p>Support data structure to track an Exponential Weighted Moving Average
(EWMA) of a FAIR task&#8217;s utilization. New samples are added to the moving
average each time a task completes an activation. Sample&#8217;s weight is chosen
so that the EWMA will be relatively insensitive to transient changes to the
task&#8217;s workload.</p>
<p>The enqueued attribute has a slightly different meaning for tasks and cpus:
- task:   the task&#8217;s util_avg at last task dequeue time
- cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU
Thus, the util_est.enqueued of a task represents the contribution on the
estimated utilization of the CPU where that task is currently enqueued.</p>
<p>Only for tasks we track a moving average of the past instantaneous
estimated utilization. This allows to absorb sporadic drops in utilization
of an otherwise almost periodic task.</p>
<dl class="function">
<dt id="c.pid_alive">
int <code class="descname">pid_alive</code><span class="sig-paren">(</span>const struct task_struct *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pid_alive" title="Permalink to this definition">¶</a></dt>
<dd><p>check that a task structure is not stale</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>Task structure to be checked.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test if a process is not yet dead (at most zombie state)
If pid_alive fails, then pointers within the task structure
can be stale and must not be dereferenced.</p>
<p><strong>Return</strong></p>
<p>1 if the process is alive. 0 otherwise.</p>
<dl class="function">
<dt id="c.is_global_init">
int <code class="descname">is_global_init</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;tsk</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_global_init" title="Permalink to this definition">¶</a></dt>
<dd><p>check if a task structure is init. Since init is free to have sub-threads we need to check tgid.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt>
<dd>Task structure to be checked.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check if a task structure is the first user space task the kernel created.</p>
<p><strong>Return</strong></p>
<p>1 if the task structure is init. 0 otherwise.</p>
<dl class="function">
<dt id="c.task_nice">
int <code class="descname">task_nice</code><span class="sig-paren">(</span>const struct task_struct *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_nice" title="Permalink to this definition">¶</a></dt>
<dd><p>return the nice value of a given task.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the task in question.</dd>
</dl>
<p><strong>Return</strong></p>
<p>The nice value [ -20 ... 0 ... 19 ].</p>
<dl class="function">
<dt id="c.is_idle_task">
bool <code class="descname">is_idle_task</code><span class="sig-paren">(</span>const struct task_struct *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_idle_task" title="Permalink to this definition">¶</a></dt>
<dd><p>is the specified task an idle task?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the task in question.</dd>
</dl>
<p><strong>Return</strong></p>
<p>1 if <strong>p</strong> is an idle task. 0 otherwise.</p>
<dl class="function">
<dt id="c.wake_up_process">
int <code class="descname">wake_up_process</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wake_up_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Wake up a specific process</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>The process to be woken up.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Attempt to wake up the nominated process and move it to the set of runnable
processes.</p>
<p><strong>Return</strong></p>
<p>1 if the process was woken up, 0 if it was already running.</p>
<p>This function executes a full memory barrier before accessing the task state.</p>
<dl class="function">
<dt id="c.preempt_notifier_register">
void <code class="descname">preempt_notifier_register</code><span class="sig-paren">(</span>struct preempt_notifier *<em>&nbsp;notifier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_notifier_register" title="Permalink to this definition">¶</a></dt>
<dd><p>tell me when current is being preempted &amp; rescheduled</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">preempt_notifier</span> <span class="pre">*</span> <span class="pre">notifier</span></code></dt>
<dd>notifier struct to register</dd>
</dl>
<dl class="function">
<dt id="c.preempt_notifier_unregister">
void <code class="descname">preempt_notifier_unregister</code><span class="sig-paren">(</span>struct preempt_notifier *<em>&nbsp;notifier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_notifier_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>no longer interested in preemption notifications</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">preempt_notifier</span> <span class="pre">*</span> <span class="pre">notifier</span></code></dt>
<dd>notifier struct to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <em>not</em> safe to call from within a preemption notifier.</p>
<dl class="function">
<dt id="c.preempt_schedule_notrace">
__visible void notrace <code class="descname">preempt_schedule_notrace</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.preempt_schedule_notrace" title="Permalink to this definition">¶</a></dt>
<dd><p>preempt_schedule called by tracing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The tracing infrastructure uses preempt_enable_notrace to prevent
recursion and tracing preempt enabling caused by the tracing
infrastructure itself. But as tracing can happen in areas coming
from userspace or just about to enter userspace, a preempt enable
can occur before <code class="xref c c-func docutils literal"><span class="pre">user_exit()</span></code> is called. This will cause the scheduler
to be called when the system is still in usermode.</p>
<p>To prevent this, the preempt_enable_notrace will use this function
instead of <code class="xref c c-func docutils literal"><span class="pre">preempt_schedule()</span></code> to exit user context if needed before
calling the scheduler.</p>
<dl class="function">
<dt id="c.sched_setscheduler">
int <code class="descname">sched_setscheduler</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;p</em>, int<em>&nbsp;policy</em>, const struct sched_param *<em>&nbsp;param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sched_setscheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>change the scheduling policy and/or RT priority of a thread.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the task in question.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">policy</span></code></dt>
<dd>new policy.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sched_param</span> <span class="pre">*</span> <span class="pre">param</span></code></dt>
<dd>structure containing the new RT priority.</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success. An error code otherwise.</p>
<p>NOTE that the task may be already dead.</p>
<dl class="function">
<dt id="c.sched_setscheduler_nocheck">
int <code class="descname">sched_setscheduler_nocheck</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;p</em>, int<em>&nbsp;policy</em>, const struct sched_param *<em>&nbsp;param</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sched_setscheduler_nocheck" title="Permalink to this definition">¶</a></dt>
<dd><p>change the scheduling policy and/or RT priority of a thread from kernelspace.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>the task in question.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">policy</span></code></dt>
<dd>new policy.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sched_param</span> <span class="pre">*</span> <span class="pre">param</span></code></dt>
<dd>structure containing the new RT priority.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Just like sched_setscheduler, only don&#8217;t bother checking if the
current context has permission.  For example, this is needed in
<code class="xref c c-func docutils literal"><span class="pre">stop_machine()</span></code>: we create temporary high priority worker threads,
but our caller might not have that capability.</p>
<p><strong>Return</strong></p>
<p>0 on success. An error code otherwise.</p>
<dl class="function">
<dt id="c.yield">
void <code class="descname">yield</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.yield" title="Permalink to this definition">¶</a></dt>
<dd><p>yield the current processor to other threads.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Do not ever use this function, there&#8217;s a 99% chance you&#8217;re doing it wrong.</p>
<p>The scheduler is at all times free to pick the calling task as the most
eligible task to run, if removing the <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal"><span class="pre">yield()</span></code></a> call from your code breaks
it, its already broken.</p>
<p>Typical broken usage is:</p>
<dl class="docutils">
<dt>while (!event)</dt>
<dd><a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal"><span class="pre">yield()</span></code></a>;</dd>
</dl>
<p>where one assumes that <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal"><span class="pre">yield()</span></code></a> will let &#8216;the other&#8217; process run that will
make event true. If the current task is a SCHED_FIFO task that will never
happen. Never use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal"><span class="pre">yield()</span></code></a> as a progress guarantee!!</p>
<p>If you want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal"><span class="pre">yield()</span></code></a> to wait for something, use <a class="reference internal" href="#c.wait_event" title="wait_event"><code class="xref c c-func docutils literal"><span class="pre">wait_event()</span></code></a>.
If you want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal"><span class="pre">yield()</span></code></a> to be &#8216;nice&#8217; for others, use <code class="xref c c-func docutils literal"><span class="pre">cond_resched()</span></code>.
If you still want to use <a class="reference internal" href="#c.yield" title="yield"><code class="xref c c-func docutils literal"><span class="pre">yield()</span></code></a>, do not!</p>
<dl class="function">
<dt id="c.yield_to">
int <code class="descname">yield_to</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;p</em>, bool<em>&nbsp;preempt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.yield_to" title="Permalink to this definition">¶</a></dt>
<dd><p>yield the current processor to another thread in your thread group, or accelerate that thread toward the processor it&#8217;s on.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>target task</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">preempt</span></code></dt>
<dd>whether task preemption is allowed or not</dd>
</dl>
<p><strong>Description</strong></p>
<p>It&#8217;s the caller&#8217;s job to ensure that the target task struct
can&#8217;t go away on us before we can do any checks.</p>
<p><strong>Return</strong></p>
<blockquote>
<div>true (&gt;0) if we indeed boosted the target task.
false (0) if we failed to boost the target.
-ESRCH if there&#8217;s no task to yield to.</div></blockquote>
<dl class="function">
<dt id="c.cpupri_find">
int <code class="descname">cpupri_find</code><span class="sig-paren">(</span>struct cpupri *<em>&nbsp;cp</em>, struct task_struct *<em>&nbsp;p</em>, struct cpumask *<em>&nbsp;lowest_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_find" title="Permalink to this definition">¶</a></dt>
<dd><p>find the best (lowest-pri) CPU in the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The cpupri context</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>The task</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cpumask</span> <span class="pre">*</span> <span class="pre">lowest_mask</span></code></dt>
<dd>A mask to fill in with selected CPUs (or NULL)</dd>
</dl>
<p><strong>Note</strong></p>
<p>This function returns the recommended CPUs as calculated during the
current invocation.  By the time the call returns, the CPUs may have in
fact changed priorities any number of times.  While not ideal, it is not
an issue of correctness since the normal rebalancer logic will correct
any discrepancies created by racing against the uncertainty of the current
priority configuration.</p>
<p><strong>Return</strong></p>
<p>(int)bool - CPUs were found</p>
<dl class="function">
<dt id="c.cpupri_set">
void <code class="descname">cpupri_set</code><span class="sig-paren">(</span>struct cpupri *<em>&nbsp;cp</em>, int<em>&nbsp;cpu</em>, int<em>&nbsp;newpri</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_set" title="Permalink to this definition">¶</a></dt>
<dd><p>update the CPU priority setting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The cpupri context</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>The target CPU</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">newpri</span></code></dt>
<dd>The priority (INVALID-RT99) to assign to this CPU</dd>
</dl>
<p><strong>Note</strong></p>
<p>Assumes cpu_rq(cpu)-&gt;lock is locked</p>
<p><strong>Return</strong></p>
<p>(void)</p>
<dl class="function">
<dt id="c.cpupri_init">
int <code class="descname">cpupri_init</code><span class="sig-paren">(</span>struct cpupri *<em>&nbsp;cp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the cpupri structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The cpupri context</dd>
</dl>
<p><strong>Return</strong></p>
<p>-ENOMEM on memory allocation failure.</p>
<dl class="function">
<dt id="c.cpupri_cleanup">
void <code class="descname">cpupri_cleanup</code><span class="sig-paren">(</span>struct cpupri *<em>&nbsp;cp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpupri_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>clean up the cpupri structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cpupri</span> <span class="pre">*</span> <span class="pre">cp</span></code></dt>
<dd>The cpupri context</dd>
</dl>
<dl class="function">
<dt id="c.update_tg_load_avg">
void <code class="descname">update_tg_load_avg</code><span class="sig-paren">(</span>struct cfs_rq *<em>&nbsp;cfs_rq</em>, int<em>&nbsp;force</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_tg_load_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>update the tg&#8217;s load avg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*</span> <span class="pre">cfs_rq</span></code></dt>
<dd>the cfs_rq whose avg changed</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">force</span></code></dt>
<dd>update regardless of how small the difference</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function &#8216;ensures&#8217;: tg-&gt;load_avg := Sum tg-&gt;cfs_rq[]-&gt;avg.load.
However, because tg-&gt;load_avg is a global value there are performance
considerations.</p>
<p>In order to avoid having to look at the other cfs_rq&#8217;s, we use a
differential update where we store the last value we propagated. This in
turn allows skipping updates if the differential is &#8216;small&#8217;.</p>
<p>Updating tg&#8217;s load_avg is necessary before <code class="xref c c-func docutils literal"><span class="pre">update_cfs_share()</span></code>.</p>
<dl class="function">
<dt id="c.update_cfs_rq_load_avg">
int <code class="descname">update_cfs_rq_load_avg</code><span class="sig-paren">(</span>u64<em>&nbsp;now</em>, struct cfs_rq *<em>&nbsp;cfs_rq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_cfs_rq_load_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>update the cfs_rq&#8217;s load/util averages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">now</span></code></dt>
<dd>current time, as per <code class="xref c c-func docutils literal"><span class="pre">cfs_rq_clock_task()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*</span> <span class="pre">cfs_rq</span></code></dt>
<dd>cfs_rq to update</dd>
</dl>
<p><strong>Description</strong></p>
<p>The cfs_rq avg is the direct sum of all its entities (blocked and runnable)
avg. The immediate corollary is that all (fair) tasks must be attached, see
<code class="xref c c-func docutils literal"><span class="pre">post_init_entity_util_avg()</span></code>.</p>
<p>cfs_rq-&gt;avg is used for <code class="xref c c-func docutils literal"><span class="pre">task_h_load()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">update_cfs_share()</span></code> for example.</p>
<p>Returns true if the load decayed or we removed load.</p>
<p>Since both these conditions indicate a changed cfs_rq-&gt;avg.load we should
call <a class="reference internal" href="#c.update_tg_load_avg" title="update_tg_load_avg"><code class="xref c c-func docutils literal"><span class="pre">update_tg_load_avg()</span></code></a> when this function returns true.</p>
<dl class="function">
<dt id="c.attach_entity_load_avg">
void <code class="descname">attach_entity_load_avg</code><span class="sig-paren">(</span>struct cfs_rq *<em>&nbsp;cfs_rq</em>, struct sched_entity *<em>&nbsp;se</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.attach_entity_load_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>attach this entity to its cfs_rq load avg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*</span> <span class="pre">cfs_rq</span></code></dt>
<dd>cfs_rq to attach to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sched_entity</span> <span class="pre">*</span> <span class="pre">se</span></code></dt>
<dd>sched_entity to attach</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>migration hints</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="update_cfs_rq_load_avg"><code class="xref c c-func docutils literal"><span class="pre">update_cfs_rq_load_avg()</span></code></a> before this, since we rely on
cfs_rq-&gt;avg.last_update_time being current.</p>
<dl class="function">
<dt id="c.detach_entity_load_avg">
void <code class="descname">detach_entity_load_avg</code><span class="sig-paren">(</span>struct cfs_rq *<em>&nbsp;cfs_rq</em>, struct sched_entity *<em>&nbsp;se</em><span class="sig-paren">)</span><a class="headerlink" href="#c.detach_entity_load_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>detach this entity from its cfs_rq load avg</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cfs_rq</span> <span class="pre">*</span> <span class="pre">cfs_rq</span></code></dt>
<dd>cfs_rq to detach from</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sched_entity</span> <span class="pre">*</span> <span class="pre">se</span></code></dt>
<dd>sched_entity to detach</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must call <a class="reference internal" href="#c.update_cfs_rq_load_avg" title="update_cfs_rq_load_avg"><code class="xref c c-func docutils literal"><span class="pre">update_cfs_rq_load_avg()</span></code></a> before this, since we rely on
cfs_rq-&gt;avg.last_update_time being current.</p>
<dl class="function">
<dt id="c.cpu_load_update">
void <code class="descname">cpu_load_update</code><span class="sig-paren">(</span>struct rq *<em>&nbsp;this_rq</em>, unsigned long<em>&nbsp;this_load</em>, unsigned long<em>&nbsp;pending_updates</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpu_load_update" title="Permalink to this definition">¶</a></dt>
<dd><p>update the rq-&gt;cpu_load[] statistics</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rq</span> <span class="pre">*</span> <span class="pre">this_rq</span></code></dt>
<dd>The rq to update statistics for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">this_load</span></code></dt>
<dd>The current load</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pending_updates</span></code></dt>
<dd>The number of missed updates</dd>
</dl>
<p><strong>Description</strong></p>
<p>Update rq-&gt;cpu_load[] statistics. This function is usually called every
scheduler tick (TICK_NSEC).</p>
<p>This function computes a decaying average:</p>
<blockquote>
<div>load[i]&#8217; = (1 - 1/2^i) * load[i] + (1/2^i) * load</div></blockquote>
<p>Because of NOHZ it might not get called on every tick which gives need for
the <strong>pending_updates</strong> argument.</p>
<blockquote>
<div><dl class="docutils">
<dt>load[i]_n = (1 - 1/2^i) * load[i]_n-1 + (1/2^i) * load_n-1</dt>
<dd>= A * load[i]_n-1 + B ; A := (1 - 1/2^i), B := (1/2^i) * load
= A * (A * load[i]_n-2 + B) + B
= A * (A * (A * load[i]_n-3 + B) + B) + B
= A^3 * load[i]_n-3 + (A^2 + A + 1) * B
= A^n * load[i]_0 + (A^(n-1) + A^(n-2) + ... + 1) * B
= A^n * load[i]_0 + ((1 - A^n) / (1 - A)) * B
= (1 - 1/2^i)^n * (load[i]_0 - load) + load</dd>
</dl>
</div></blockquote>
<p>In the above we&#8217;ve assumed load_n := load, which is true for NOHZ_FULL as
any change in load would have resulted in the tick being turned back on.</p>
<p>For regular NOHZ, this reduces to:</p>
<blockquote>
<div>load[i]_n = (1 - 1/2^i)^n * load[i]_0</div></blockquote>
<p>see <code class="xref c c-func docutils literal"><span class="pre">decay_load_misses()</span></code>. For NOHZ_FULL we get to subtract and add the extra
term.</p>
<dl class="function">
<dt id="c.cpu_util">
unsigned long <code class="descname">cpu_util</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cpu_util" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the CPU to get the utilization of</dd>
</dl>
<p><strong>Description</strong></p>
<p>The unit of the return value must be the one of capacity so we can compare
the utilization with the capacity of the CPU that is available for CFS task
(ie cpu_capacity).</p>
<p>cfs_rq.avg.util_avg is the sum of running time of runnable tasks plus the
recent utilization of currently non-runnable tasks on a CPU. It represents
the amount of utilization of a CPU in the range [0..capacity_orig] where
capacity_orig is the cpu_capacity available at the highest frequency
(<code class="xref c c-func docutils literal"><span class="pre">arch_scale_freq_capacity()</span></code>).
The utilization of a CPU converges towards a sum equal to or less than the
current capacity (capacity_curr &lt;= capacity_orig) of the CPU because it is
the running time on this CPU scaled by capacity_curr.</p>
<p>The estimated utilization of a CPU is defined to be the maximum between its
cfs_rq.avg.util_avg and the sum of the estimated utilization of the tasks
currently RUNNABLE on that CPU.
This allows to properly represent the expected utilization of a CPU which
has just got a big task running since a long sleep period. At the same time
however it preserves the benefits of the &#8220;blocked utilization&#8221; in
describing the potential for other tasks waking up on the same CPU.</p>
<p>Nevertheless, cfs_rq.avg.util_avg can be higher than capacity_curr or even
higher than capacity_orig because of unfortunate rounding in
cfs.avg.util_avg or just after migrating tasks and new task wakeups until
the average stabilizes with the new running time. We need to check that the
utilization stays within the range of [0..capacity_orig] and cap it if
necessary. Without utilization capping, a group could be seen as overloaded
(CPU0 utilization at 121% + CPU1 utilization at 80%) whereas CPU1 has 20% of
available capacity. We allow utilization to overshoot capacity_curr (but not
capacity_orig) as it useful for predicting the capacity required after task
migrations (scheduler-driven DVFS).</p>
<p><strong>Return</strong></p>
<p>the (estimated) utilization for the specified CPU</p>
<dl class="function">
<dt id="c.get_sd_load_idx">
int <code class="descname">get_sd_load_idx</code><span class="sig-paren">(</span>struct sched_domain *<em>&nbsp;sd</em>, enum cpu_idle_type<em>&nbsp;idle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_sd_load_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the load index for a given sched domain.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sched_domain</span> <span class="pre">*</span> <span class="pre">sd</span></code></dt>
<dd>The sched_domain whose load_idx is to be obtained.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">cpu_idle_type</span> <span class="pre">idle</span></code></dt>
<dd>The idle status of the CPU for whose sd load_idx is obtained.</dd>
</dl>
<p><strong>Return</strong></p>
<p>The load index.</p>
<dl class="function">
<dt id="c.update_sg_lb_stats">
void <code class="descname">update_sg_lb_stats</code><span class="sig-paren">(</span>struct lb_env *<em>&nbsp;env</em>, struct sched_group *<em>&nbsp;group</em>, int<em>&nbsp;load_idx</em>, int<em>&nbsp;local_group</em>, struct sg_lb_stats *<em>&nbsp;sgs</em>, bool *<em>&nbsp;overload</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sg_lb_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Update sched_group&#8217;s statistics for load balancing.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*</span> <span class="pre">env</span></code></dt>
<dd>The load balancing environment.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*</span> <span class="pre">group</span></code></dt>
<dd>sched_group whose statistics are to be updated.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">load_idx</span></code></dt>
<dd>Load index of sched_domain of this_cpu for load calc.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">local_group</span></code></dt>
<dd>Does group contain this_cpu.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*</span> <span class="pre">sgs</span></code></dt>
<dd>variable to hold the statistics for this group.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">overload</span></code></dt>
<dd>Indicate more than one runnable task for any CPU.</dd>
</dl>
<dl class="function">
<dt id="c.update_sd_pick_busiest">
bool <code class="descname">update_sd_pick_busiest</code><span class="sig-paren">(</span>struct lb_env *<em>&nbsp;env</em>, struct sd_lb_stats *<em>&nbsp;sds</em>, struct sched_group *<em>&nbsp;sg</em>, struct sg_lb_stats *<em>&nbsp;sgs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sd_pick_busiest" title="Permalink to this definition">¶</a></dt>
<dd><p>return 1 on busiest group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*</span> <span class="pre">env</span></code></dt>
<dd>The load balancing environment.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*</span> <span class="pre">sds</span></code></dt>
<dd>sched_domain statistics</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sched_group</span> <span class="pre">*</span> <span class="pre">sg</span></code></dt>
<dd>sched_group candidate to be checked for being the busiest</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sg_lb_stats</span> <span class="pre">*</span> <span class="pre">sgs</span></code></dt>
<dd>sched_group statistics</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if <strong>sg</strong> is a busier group than the previously selected
busiest group.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>sg</strong> is a busier group than the previously selected
busiest group. <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.update_sd_lb_stats">
void <code class="descname">update_sd_lb_stats</code><span class="sig-paren">(</span>struct lb_env *<em>&nbsp;env</em>, struct sd_lb_stats *<em>&nbsp;sds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.update_sd_lb_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Update sched_domain&#8217;s statistics for load balancing.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*</span> <span class="pre">env</span></code></dt>
<dd>The load balancing environment.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*</span> <span class="pre">sds</span></code></dt>
<dd>variable to hold the statistics for this sched_domain.</dd>
</dl>
<dl class="function">
<dt id="c.check_asym_packing">
int <code class="descname">check_asym_packing</code><span class="sig-paren">(</span>struct lb_env *<em>&nbsp;env</em>, struct sd_lb_stats *<em>&nbsp;sds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.check_asym_packing" title="Permalink to this definition">¶</a></dt>
<dd><p>Check to see if the group is packed into the sched domain.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*</span> <span class="pre">env</span></code></dt>
<dd>The load balancing environment.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*</span> <span class="pre">sds</span></code></dt>
<dd>Statistics of the sched_domain which is to be packed</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is primarily intended to used at the sibling level.  Some
cores like POWER7 prefer to use lower numbered SMT threads.  In the
case of POWER7, it can move to lower SMT modes only when higher
threads are idle.  When in lower SMT modes, the threads will
perform better since they share less core resources.  Hence when we
have idle threads, we want them to be the higher ones.</p>
<p>This packing function is run on idle threads.  It checks to see if
the busiest CPU in this domain (core in the P7 case) has a higher
CPU number than the packing function is being run on.  Here we are
assuming lower CPU number will be equivalent to lower a SMT thread
number.</p>
<p><strong>Return</strong></p>
<p>1 when packing is required and a task should be moved to
this CPU.  The amount of the imbalance is returned in env-&gt;imbalance.</p>
<dl class="function">
<dt id="c.fix_small_imbalance">
void <code class="descname">fix_small_imbalance</code><span class="sig-paren">(</span>struct lb_env *<em>&nbsp;env</em>, struct sd_lb_stats *<em>&nbsp;sds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fix_small_imbalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the minor imbalance that exists amongst the groups of a sched_domain, during load balancing.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*</span> <span class="pre">env</span></code></dt>
<dd>The load balancing environment.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*</span> <span class="pre">sds</span></code></dt>
<dd>Statistics of the sched_domain whose imbalance is to be calculated.</dd>
</dl>
<dl class="function">
<dt id="c.calculate_imbalance">
void <code class="descname">calculate_imbalance</code><span class="sig-paren">(</span>struct lb_env *<em>&nbsp;env</em>, struct sd_lb_stats *<em>&nbsp;sds</em><span class="sig-paren">)</span><a class="headerlink" href="#c.calculate_imbalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the amount of imbalance present within the groups of a given sched_domain during load balance.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*</span> <span class="pre">env</span></code></dt>
<dd>load balance environment</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sd_lb_stats</span> <span class="pre">*</span> <span class="pre">sds</span></code></dt>
<dd>statistics of the sched_domain whose imbalance is to be calculated.</dd>
</dl>
<dl class="function">
<dt id="c.find_busiest_group">
struct sched_group * <code class="descname">find_busiest_group</code><span class="sig-paren">(</span>struct lb_env *<em>&nbsp;env</em><span class="sig-paren">)</span><a class="headerlink" href="#c.find_busiest_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the busiest group within the sched_domain if there is an imbalance.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lb_env</span> <span class="pre">*</span> <span class="pre">env</span></code></dt>
<dd>The load balancing environment.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Also calculates the amount of weighted load which should be moved
to restore balance.</p>
<p><strong>Return</strong></p>
<ul class="simple">
<li>The busiest group if imbalance exists.</li>
</ul>
<dl class="function">
<dt id="c.DECLARE_COMPLETION">
<code class="descname">DECLARE_COMPLETION</code><span class="sig-paren">(</span><em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_COMPLETION" title="Permalink to this definition">¶</a></dt>
<dd><p>declare and initialize a completion structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">work</span></code></dt>
<dd>identifier for the completion structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro declares and initializes a completion structure. Generally used
for static declarations. You should use the _ONSTACK variant for automatic
variables.</p>
<dl class="function">
<dt id="c.DECLARE_COMPLETION_ONSTACK">
<code class="descname">DECLARE_COMPLETION_ONSTACK</code><span class="sig-paren">(</span><em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.DECLARE_COMPLETION_ONSTACK" title="Permalink to this definition">¶</a></dt>
<dd><p>declare and initialize a completion structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">work</span></code></dt>
<dd>identifier for the completion structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro declares and initializes a completion structure on the kernel
stack.</p>
<dl class="function">
<dt id="c.__init_completion">
void <code class="descname">__init_completion</code><span class="sig-paren">(</span>struct completion *<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__init_completion" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a dynamically allocated completion</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*</span> <span class="pre">x</span></code></dt>
<dd>pointer to completion structure that is to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>This inline function will initialize a dynamically created completion
structure.</p>
<dl class="function">
<dt id="c.reinit_completion">
void <code class="descname">reinit_completion</code><span class="sig-paren">(</span>struct completion *<em>&nbsp;x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reinit_completion" title="Permalink to this definition">¶</a></dt>
<dd><p>reinitialize a completion structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">completion</span> <span class="pre">*</span> <span class="pre">x</span></code></dt>
<dd>pointer to completion structure that is to be reinitialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>This inline function should be used to reinitialize a completion structure so it can
be reused. This is especially important after <code class="xref c c-func docutils literal"><span class="pre">complete_all()</span></code> is used.</p>
<dl class="function">
<dt id="c.__round_jiffies">
unsigned long <code class="descname">__round_jiffies</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;j</em>, int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt>
<dd>the time in (absolute) jiffies that should be rounded</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the processor number on which the timeout will happen</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.__round_jiffies" title="__round_jiffies"><code class="xref c c-func docutils literal"><span class="pre">__round_jiffies()</span></code></a> rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
<dl class="function">
<dt id="c.__round_jiffies_relative">
unsigned long <code class="descname">__round_jiffies_relative</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;j</em>, int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt>
<dd>the time in (relative) jiffies that should be rounded</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the processor number on which the timeout will happen</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.__round_jiffies_relative" title="__round_jiffies_relative"><code class="xref c c-func docutils literal"><span class="pre">__round_jiffies_relative()</span></code></a> rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The exact rounding is skewed for each processor to avoid all
processors firing at the exact same time, which could lead
to lock contention or spurious cache line bouncing.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
<dl class="function">
<dt id="c.round_jiffies">
unsigned long <code class="descname">round_jiffies</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt>
<dd>the time in (absolute) jiffies that should be rounded</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.round_jiffies" title="round_jiffies"><code class="xref c c-func docutils literal"><span class="pre">round_jiffies()</span></code></a> rounds an absolute time in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
<dl class="function">
<dt id="c.round_jiffies_relative">
unsigned long <code class="descname">round_jiffies_relative</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt>
<dd>the time in (relative) jiffies that should be rounded</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.round_jiffies_relative" title="round_jiffies_relative"><code class="xref c c-func docutils literal"><span class="pre">round_jiffies_relative()</span></code></a> rounds a time delta  in the future (in jiffies)
up or down to (approximately) full seconds. This is useful for timers
for which the exact time they fire does not matter too much, as long as
they fire approximately every X seconds.</p>
<p>By rounding these timers to whole seconds, all such timers will fire
at the same time, rather than at various times spread out. The goal
of this is to have the CPU wake up less, which saves power.</p>
<p>The return value is the rounded version of the <strong>j</strong> parameter.</p>
<dl class="function">
<dt id="c.__round_jiffies_up">
unsigned long <code class="descname">__round_jiffies_up</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;j</em>, int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_up" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt>
<dd>the time in (absolute) jiffies that should be rounded</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the processor number on which the timeout will happen</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.__round_jiffies" title="__round_jiffies"><code class="xref c c-func docutils literal"><span class="pre">__round_jiffies()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don&#8217;t fire too
early.</p>
<dl class="function">
<dt id="c.__round_jiffies_up_relative">
unsigned long <code class="descname">__round_jiffies_up_relative</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;j</em>, int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__round_jiffies_up_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt>
<dd>the time in (relative) jiffies that should be rounded</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the processor number on which the timeout will happen</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.__round_jiffies_relative" title="__round_jiffies_relative"><code class="xref c c-func docutils literal"><span class="pre">__round_jiffies_relative()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don&#8217;t fire too
early.</p>
<dl class="function">
<dt id="c.round_jiffies_up">
unsigned long <code class="descname">round_jiffies_up</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_up" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt>
<dd>the time in (absolute) jiffies that should be rounded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.round_jiffies" title="round_jiffies"><code class="xref c c-func docutils literal"><span class="pre">round_jiffies()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don&#8217;t fire too
early.</p>
<dl class="function">
<dt id="c.round_jiffies_up_relative">
unsigned long <code class="descname">round_jiffies_up_relative</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;j</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_jiffies_up_relative" title="Permalink to this definition">¶</a></dt>
<dd><p>function to round jiffies up to a full second</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">j</span></code></dt>
<dd>the time in (relative) jiffies that should be rounded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the same as <a class="reference internal" href="#c.round_jiffies_relative" title="round_jiffies_relative"><code class="xref c c-func docutils literal"><span class="pre">round_jiffies_relative()</span></code></a> except that it will never
round down.  This is useful for timeouts for which the exact time
of firing does not matter too much, as long as they don&#8217;t fire too
early.</p>
<dl class="function">
<dt id="c.init_timer_key">
void <code class="descname">init_timer_key</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em>, void (*func) (struct timer_list<em>&nbsp;*</em>, unsigned int<em>&nbsp;flags</em>, const char *<em>&nbsp;name</em>, struct lock_class_key *<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_timer_key" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be initialized</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">timer_list</span> <span class="pre">*)</span> <span class="pre">func</span></code></dt>
<dd>timer callback function</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>timer flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the timer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>lockdep class key of the fake lock used for tracking timer
sync lock dependencies</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.init_timer_key" title="init_timer_key"><code class="xref c c-func docutils literal"><span class="pre">init_timer_key()</span></code></a> must be done to a timer prior calling <em>any</em> of the
other timer functions.</p>
<dl class="function">
<dt id="c.mod_timer_pending">
int <code class="descname">mod_timer_pending</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em>, unsigned long<em>&nbsp;expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_timer_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>modify a pending timer&#8217;s timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the pending timer to be modified</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt>
<dd>new timeout in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mod_timer_pending" title="mod_timer_pending"><code class="xref c c-func docutils literal"><span class="pre">mod_timer_pending()</span></code></a> is the same for pending timers as <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal"><span class="pre">mod_timer()</span></code></a>,
but will not re-activate and modify already deleted timers.</p>
<p>It is useful for unserialized use of timers.</p>
<dl class="function">
<dt id="c.mod_timer">
int <code class="descname">mod_timer</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em>, unsigned long<em>&nbsp;expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>modify a timer&#8217;s timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be modified</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt>
<dd>new timeout in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal"><span class="pre">mod_timer()</span></code></a> is a more efficient way to update the expire field of an
active timer (if the timer is inactive it will be activated)</p>
<p>mod_timer(timer, expires) is equivalent to:</p>
<blockquote>
<div>del_timer(timer); timer-&gt;expires = expires; add_timer(timer);</div></blockquote>
<p>Note that if there are multiple unserialized concurrent users of the
same timer, then <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal"><span class="pre">mod_timer()</span></code></a> is the only safe way to modify the timeout,
since <a class="reference internal" href="#c.add_timer" title="add_timer"><code class="xref c c-func docutils literal"><span class="pre">add_timer()</span></code></a> cannot modify an already running timer.</p>
<p>The function returns whether it has modified a pending timer or not.
(ie. <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal"><span class="pre">mod_timer()</span></code></a> of an inactive timer returns 0, <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal"><span class="pre">mod_timer()</span></code></a> of an
active timer returns 1.)</p>
<dl class="function">
<dt id="c.timer_reduce">
int <code class="descname">timer_reduce</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em>, unsigned long<em>&nbsp;expires</em><span class="sig-paren">)</span><a class="headerlink" href="#c.timer_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify a timer&#8217;s timeout if it would reduce the timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>The timer to be modified</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">expires</span></code></dt>
<dd>New timeout in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.timer_reduce" title="timer_reduce"><code class="xref c c-func docutils literal"><span class="pre">timer_reduce()</span></code></a> is very similar to <a class="reference internal" href="#c.mod_timer" title="mod_timer"><code class="xref c c-func docutils literal"><span class="pre">mod_timer()</span></code></a>, except that it will only
modify a running timer if that would reduce the expiration time (it will
start a timer that isn&#8217;t running).</p>
<dl class="function">
<dt id="c.add_timer">
void <code class="descname">add_timer</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>start a timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be added</dd>
</dl>
<p><strong>Description</strong></p>
<p>The kernel will do a -&gt;function(<strong>timer</strong>) callback from the
timer interrupt at the -&gt;expires point in the future. The
current time is &#8216;jiffies&#8217;.</p>
<p>The timer&#8217;s -&gt;expires, -&gt;function fields must be set prior calling this
function.</p>
<p>Timers with an -&gt;expires field in the past will be executed in the next
timer tick.</p>
<dl class="function">
<dt id="c.add_timer_on">
void <code class="descname">add_timer_on</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em>, int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_timer_on" title="Permalink to this definition">¶</a></dt>
<dd><p>start a timer on a particular CPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be added</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the CPU to start it on</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is not very scalable on SMP. Double adds are not possible.</p>
<dl class="function">
<dt id="c.del_timer">
int <code class="descname">del_timer</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.del_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>deactivate a timer.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be deactivated</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal"><span class="pre">del_timer()</span></code></a> deactivates a timer - this works on both active and inactive
timers.</p>
<p>The function returns whether it has deactivated a pending timer or not.
(ie. <a class="reference internal" href="#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal"><span class="pre">del_timer()</span></code></a> of an inactive timer returns 0, <a class="reference internal" href="#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal"><span class="pre">del_timer()</span></code></a> of an
active timer returns 1.)</p>
<dl class="function">
<dt id="c.try_to_del_timer_sync">
int <code class="descname">try_to_del_timer_sync</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.try_to_del_timer_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to deactivate a timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>timer to delete</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function tries to deactivate a timer. Upon successful (ret &gt;= 0)
exit the timer is not queued and the handler is not running on any CPU.</p>
<dl class="function">
<dt id="c.del_timer_sync">
int <code class="descname">del_timer_sync</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.del_timer_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>deactivate a timer and wait for the handler to finish.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be deactivated</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function only differs from <a class="reference internal" href="#c.del_timer" title="del_timer"><code class="xref c c-func docutils literal"><span class="pre">del_timer()</span></code></a> on SMP: besides deactivating
the timer it also makes sure the handler has finished executing on other
CPUs.</p>
<p>Synchronization rules: Callers must prevent restarting of the timer,
otherwise this function is meaningless. It must not be called from
interrupt contexts unless the timer is an irqsafe one. The caller must
not hold locks which would prevent completion of the timer&#8217;s
handler. The timer&#8217;s handler must not call <a class="reference internal" href="#c.add_timer_on" title="add_timer_on"><code class="xref c c-func docutils literal"><span class="pre">add_timer_on()</span></code></a>. Upon exit the
timer is not queued and the handler is not running on any CPU.</p>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>For !irqsafe timers, you must not hold locks that are held in</dt>
<dd><p class="first">interrupt context while calling this function. Even if the lock has
nothing to do with the timer in question.  Here&#8217;s why:</p>
<div class="last highlight-none"><div class="highlight"><pre>CPU0                             CPU1
----                             ----
                                 &lt;SOFTIRQ&gt;
                                   call_timer_fn();
                                   base-&gt;running_timer = mytimer;
spin_lock_irq(somelock);
                                 &lt;IRQ&gt;
                                    spin_lock(somelock);
del_timer_sync(mytimer);
while (base-&gt;running_timer == mytimer);
</pre></div>
</div>
</dd>
</dl>
<p>Now <a class="reference internal" href="#c.del_timer_sync" title="del_timer_sync"><code class="xref c c-func docutils literal"><span class="pre">del_timer_sync()</span></code></a> will never return and never release somelock.
The interrupt on the other CPU is waiting to grab somelock but
it has interrupted the softirq that CPU0 is waiting to finish.</p>
<p>The function returns whether it has deactivated a pending timer or not.</p>
<dl class="function">
<dt id="c.schedule_timeout">
signed long <code class="descname">schedule_timeout</code><span class="sig-paren">(</span>signed long<em>&nbsp;timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">timeout</span></code></dt>
<dd>timeout value in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until <strong>timeout</strong> jiffies have
elapsed. The routine will return immediately unless
the current task state has been set (see <code class="xref c c-func docutils literal"><span class="pre">set_current_state()</span></code>).</p>
<p>You can set the task state as follows -</p>
<p><code class="docutils literal"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> jiffies are guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code></a>)&#8221;.</p>
<p><code class="docutils literal"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be TASK_RUNNING when this
routine returns.</p>
<p>Specifying a <strong>timeout</strong> value of <code class="docutils literal"><span class="pre">MAX_SCHEDULE_TIMEOUT</span></code> will schedule
the CPU away without a bound on the timeout. In this case the return
value will be <code class="docutils literal"><span class="pre">MAX_SCHEDULE_TIMEOUT</span></code>.</p>
<p>Returns 0 when the timer has expired otherwise the remaining time in
jiffies will be returned.  In all cases the return value is guaranteed
to be non-negative.</p>
<dl class="function">
<dt id="c.msleep">
void <code class="descname">msleep</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.msleep" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep safely even with waitqueue interruptions</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msecs</span></code></dt>
<dd>Time in milliseconds to sleep for</dd>
</dl>
<dl class="function">
<dt id="c.msleep_interruptible">
unsigned long <code class="descname">msleep_interruptible</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.msleep_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep waiting for signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">msecs</span></code></dt>
<dd>Time in milliseconds to sleep for</dd>
</dl>
<dl class="function">
<dt id="c.usleep_range">
void <code class="descname">usleep_range</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;min</em>, unsigned long<em>&nbsp;max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.usleep_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Sleep for an approximate time</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">min</span></code></dt>
<dd>Minimum time in usecs to sleep</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">max</span></code></dt>
<dd>Maximum time in usecs to sleep</dd>
</dl>
<p><strong>Description</strong></p>
<p>In non-atomic context where the exact wakeup time is flexible, use
<a class="reference internal" href="#c.usleep_range" title="usleep_range"><code class="xref c c-func docutils literal"><span class="pre">usleep_range()</span></code></a> instead of <code class="xref c c-func docutils literal"><span class="pre">udelay()</span></code>.  The sleep improves responsiveness
by avoiding the CPU-hogging busy-wait of <code class="xref c c-func docutils literal"><span class="pre">udelay()</span></code>, and the range reduces
power usage by allowing hrtimers to take advantage of an already-
scheduled interrupt instead of scheduling a new one just for this sleep.</p>
</div>
<div class="section" id="wait-queues-and-wake-events">
<h2>Wait queues and Wake events<a class="headerlink" href="#wait-queues-and-wake-events" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.waitqueue_active">
int <code class="descname">waitqueue_active</code><span class="sig-paren">(</span>struct wait_queue_head *<em>&nbsp;wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.waitqueue_active" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>locklessly test for waiters on the queue</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*</span> <span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to test for waiters</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns true if the wait list is not empty</p>
<p><strong>NOTE</strong></p>
<p>this function is lockless and requires care, incorrect usage _will_
lead to sporadic and non-obvious failure.</p>
<p>Use either while holding wait_queue_head::lock or when used for wakeups
with an extra <code class="xref c c-func docutils literal"><span class="pre">smp_mb()</span></code> like:</p>
<blockquote>
<div><p>CPU0 - waker                    CPU1 - waiter</p>
<blockquote>
<div>for (;;) {</div></blockquote>
<p><strong>cond</strong> = true;                     prepare_to_wait(<code class="xref c c-type docutils literal"><span class="pre">wq_head</span></code>, <code class="xref c c-type docutils literal"><span class="pre">wait</span></code>, state);
<code class="xref c c-func docutils literal"><span class="pre">smp_mb()</span></code>;                         // <code class="xref c c-func docutils literal"><span class="pre">smp_mb()</span></code> from <code class="xref c c-func docutils literal"><span class="pre">set_current_state()</span></code>
if (waitqueue_active(wq_head))         if (<strong>cond</strong>)</p>
<blockquote>
<div><dl class="docutils">
<dt>wake_up(wq_head);                      break;</dt>
<dd><blockquote class="first">
<div><code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code>;</div></blockquote>
<p class="last">}
finish_wait(<code class="xref c c-type docutils literal"><span class="pre">wq_head</span></code>, <code class="xref c c-type docutils literal"><span class="pre">wait</span></code>);</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>Because without the explicit <code class="xref c c-func docutils literal"><span class="pre">smp_mb()</span></code> it&#8217;s possible for the
<a class="reference internal" href="#c.waitqueue_active" title="waitqueue_active"><code class="xref c c-func docutils literal"><span class="pre">waitqueue_active()</span></code></a> load to get hoisted over the <strong>cond</strong> store such that we&#8217;ll
observe an empty wait list while the waiter might not observe <strong>cond</strong>.</p>
<p>Also note that this &#8216;optimization&#8217; trades a <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> for an <code class="xref c c-func docutils literal"><span class="pre">smp_mb()</span></code>,
which (when the lock is uncontended) are of roughly equal cost.</p>
<dl class="function">
<dt id="c.wq_has_sleeper">
bool <code class="descname">wq_has_sleeper</code><span class="sig-paren">(</span>struct wait_queue_head *<em>&nbsp;wq_head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wq_has_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>check if there are any waiting processes</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*</span> <span class="pre">wq_head</span></code></dt>
<dd>wait queue head</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns true if wq_head has waiting processes</p>
<p>Please refer to the comment for waitqueue_active.</p>
<dl class="function">
<dt id="c.wait_event">
<code class="descname">wait_event</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="function">
<dt id="c.wait_event_freezable">
<code class="descname">wait_event_freezable</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_freezable" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep (or freeze) until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE &#8211; so as not to contribute
to system load) until the <strong>condition</strong> evaluates to true. The
<strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="function">
<dt id="c.wait_event_timeout">
<code class="descname">wait_event_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>timeout, in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
<dl class="function">
<dt id="c.wait_event_cmd">
<code class="descname">wait_event_cmd</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>cmd1</em>, <em>cmd2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">cmd1</span></code></dt>
<dd>the command will be executed before sleep</dd>
<dt><code class="docutils literal"><span class="pre">cmd2</span></code></dt>
<dd>the command will be executed after sleep</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="function">
<dt id="c.wait_event_interruptible">
<code class="descname">wait_event_interruptible</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_timeout">
<code class="descname">wait_event_interruptible_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>timeout, in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed, or -<code class="docutils literal"><span class="pre">ERESTARTSYS</span></code> if it was
interrupted by a signal.</p>
<dl class="function">
<dt id="c.wait_event_hrtimeout">
<code class="descname">wait_event_hrtimeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_hrtimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>timeout, as a ktime_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function returns 0 if <strong>condition</strong> became true, or -ETIME if the timeout
elapsed.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_hrtimeout">
<code class="descname">wait_event_interruptible_hrtimeout</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_hrtimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>timeout, as a ktime_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function returns 0 if <strong>condition</strong> became true, -ERESTARTSYS if it was
interrupted by a signal, or -ETIME if the timeout elapsed.</p>
<dl class="function">
<dt id="c.wait_event_idle">
<code class="descname">wait_event_idle</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_idle" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for a condition without contributing to system load</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="function">
<dt id="c.wait_event_idle_exclusive">
<code class="descname">wait_event_idle_exclusive</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_idle_exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for a condition with contributing to system load</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus if other processes wait on the same list, when this
process is woken further processes are not considered.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<dl class="function">
<dt id="c.wait_event_idle_timeout">
<code class="descname">wait_event_idle_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_idle_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep without load until a condition becomes true or a timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>timeout, in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
<dl class="function">
<dt id="c.wait_event_idle_exclusive_timeout">
<code class="descname">wait_event_idle_exclusive_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_idle_exclusive_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep without load until a condition becomes true or a timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>timeout, in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_IDLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus if other processes wait on the same list, when this
process is woken further processes are not considered.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
or the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_locked">
<code class="descname">wait_event_interruptible_locked</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code>/<code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code>
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up_locked()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_locked_irq">
<code class="descname">wait_event_interruptible_locked_irq</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_locked_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code>/<code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irq()</span></code>
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up_locked()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_exclusive_locked">
<code class="descname">wait_event_interruptible_exclusive_locked</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_exclusive_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep exclusively until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code>/<code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code>
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up_locked()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_exclusive_locked_irq">
<code class="descname">wait_event_interruptible_exclusive_locked_irq</code><span class="sig-paren">(</span><em>wq</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_exclusive_locked_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq</strong> is woken up.</p>
<p>It must be called with wq.lock being held.  This spinlock is
unlocked while sleeping but <strong>condition</strong> testing is done while lock
is held and when this macro exits the lock is held.</p>
<p>The lock is locked/unlocked using <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code>/<code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irq()</span></code>
functions which must match the way they are locked/unlocked outside
of this macro.</p>
<p>The process is put on the wait queue with an WQ_FLAG_EXCLUSIVE flag
set thus when other process waits process on the list if this
process is awaken further processes are not considered.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up_locked()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="function">
<dt id="c.wait_event_killable">
<code class="descname">wait_event_killable</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_killable" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_KILLABLE) until the
<strong>condition</strong> evaluates to true or a signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>The function will return -ERESTARTSYS if it was interrupted by a
signal and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="function">
<dt id="c.wait_event_killable_timeout">
<code class="descname">wait_event_killable_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_killable_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>timeout, in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_KILLABLE) until the
<strong>condition</strong> evaluates to true or a kill signal is received.
The <strong>condition</strong> is checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p><strong>Return</strong></p>
<p>0 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">false</span></code> after the <strong>timeout</strong> elapsed,
1 if the <strong>condition</strong> evaluated to <code class="docutils literal"><span class="pre">true</span></code> after the <strong>timeout</strong> elapsed,
the remaining jiffies (at least 1) if the <strong>condition</strong> evaluated
to <code class="docutils literal"><span class="pre">true</span></code> before the <strong>timeout</strong> elapsed, or -<code class="docutils literal"><span class="pre">ERESTARTSYS</span></code> if it was
interrupted by a kill signal.</p>
<p>Only kill signals interrupt this process.</p>
<dl class="function">
<dt id="c.wait_event_lock_irq_cmd">
<code class="descname">wait_event_lock_irq_cmd</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em>, <em>cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_lock_irq_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>a locked spinlock_t, which will be released before cmd
and <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code> and reacquired afterwards.</dd>
<dt><code class="docutils literal"><span class="pre">cmd</span></code></dt>
<dd>a command which is invoked outside the critical section before
sleep</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.</p>
<dl class="function">
<dt id="c.wait_event_lock_irq">
<code class="descname">wait_event_lock_irq</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_lock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>a locked spinlock_t, which will be released before <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code>
and reacquired afterwards.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true. The <strong>condition</strong> is checked each time
the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_lock_irq_cmd">
<code class="descname">wait_event_interruptible_lock_irq_cmd</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em>, <em>cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>a locked spinlock_t, which will be released before cmd and
<code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code> and reacquired afterwards.</dd>
<dt><code class="docutils literal"><span class="pre">cmd</span></code></dt>
<dd>a command which is invoked outside the critical section before
sleep</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or a signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before invoking the cmd and going to sleep and is reacquired
afterwards.</p>
<p>The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_lock_irq">
<code class="descname">wait_event_interruptible_lock_irq</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>a locked spinlock_t, which will be released before <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code>
and reacquired afterwards.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<p>The macro will return -ERESTARTSYS if it was interrupted by a signal
and 0 if <strong>condition</strong> evaluated to true.</p>
<dl class="function">
<dt id="c.wait_event_interruptible_lock_irq_timeout">
<code class="descname">wait_event_interruptible_lock_irq_timeout</code><span class="sig-paren">(</span><em>wq_head</em>, <em>condition</em>, <em>lock</em>, <em>timeout</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_event_interruptible_lock_irq_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until a condition gets true or a timeout elapses. The condition is checked under the lock. This is expected to be called with the lock taken.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">wq_head</span></code></dt>
<dd>the waitqueue to wait on</dd>
<dt><code class="docutils literal"><span class="pre">condition</span></code></dt>
<dd>a C expression for the event to wait for</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>a locked spinlock_t, which will be released before <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code>
and reacquired afterwards.</dd>
<dt><code class="docutils literal"><span class="pre">timeout</span></code></dt>
<dd>timeout, in jiffies</dd>
</dl>
<p><strong>Description</strong></p>
<p>The process is put to sleep (TASK_INTERRUPTIBLE) until the
<strong>condition</strong> evaluates to true or signal is received. The <strong>condition</strong> is
checked each time the waitqueue <strong>wq_head</strong> is woken up.</p>
<p><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> has to be called after changing any variable that could
change the result of the wait condition.</p>
<p>This is supposed to be called while holding the lock. The lock is
dropped before going to sleep and is reacquired afterwards.</p>
<p>The function returns 0 if the <strong>timeout</strong> elapsed, -ERESTARTSYS if it
was interrupted by a signal, and the remaining jiffies otherwise
if the condition evaluated to true before the timeout elapsed.</p>
<dl class="function">
<dt id="c.__wake_up">
void <code class="descname">__wake_up</code><span class="sig-paren">(</span>struct wait_queue_head *<em>&nbsp;wq_head</em>, unsigned int<em>&nbsp;mode</em>, int<em>&nbsp;nr_exclusive</em>, void *<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up threads blocked on a waitqueue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*</span> <span class="pre">wq_head</span></code></dt>
<dd>the waitqueue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt>
<dd>which threads</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_exclusive</span></code></dt>
<dd>how many wake-one or wake-many threads to wake up</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>is directly passed to the wakeup function</dd>
</dl>
<p><strong>Description</strong></p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
<dl class="function">
<dt id="c.__wake_up_sync_key">
void <code class="descname">__wake_up_sync_key</code><span class="sig-paren">(</span>struct wait_queue_head *<em>&nbsp;wq_head</em>, unsigned int<em>&nbsp;mode</em>, int<em>&nbsp;nr_exclusive</em>, void *<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__wake_up_sync_key" title="Permalink to this definition">¶</a></dt>
<dd><p>wake up threads blocked on a waitqueue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*</span> <span class="pre">wq_head</span></code></dt>
<dd>the waitqueue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">mode</span></code></dt>
<dd>which threads</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nr_exclusive</span></code></dt>
<dd>how many wake-one or wake-many threads to wake up</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>opaque value to be passed to wakeup targets</dd>
</dl>
<p><strong>Description</strong></p>
<p>The sync wakeup differs that the waker knows that it will schedule
away soon, so while the target thread will be woken up, it will not
be migrated to another CPU - ie. the two threads are &#8216;synchronized&#8217;
with each other. This can prevent needless bouncing between CPUs.</p>
<p>On UP it can prevent extra preemption.</p>
<p>If this function wakes up a task, it executes a full memory barrier before
accessing the task state.</p>
<dl class="function">
<dt id="c.finish_wait">
void <code class="descname">finish_wait</code><span class="sig-paren">(</span>struct wait_queue_head *<em>&nbsp;wq_head</em>, struct wait_queue_entry *<em>&nbsp;wq_entry</em><span class="sig-paren">)</span><a class="headerlink" href="#c.finish_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>clean up after waiting in a queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wait_queue_head</span> <span class="pre">*</span> <span class="pre">wq_head</span></code></dt>
<dd>waitqueue waited on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wait_queue_entry</span> <span class="pre">*</span> <span class="pre">wq_entry</span></code></dt>
<dd>wait descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets current thread back to running state and removes
the wait descriptor from the given waitqueue if still
queued.</p>
</div>
<div class="section" id="high-resolution-timers">
<h2>High-resolution timers<a class="headerlink" href="#high-resolution-timers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.ktime_set">
ktime_t <code class="descname">ktime_set</code><span class="sig-paren">(</span>const s64<em>&nbsp;secs</em>, const unsigned long<em>&nbsp;nsecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a ktime_t variable from a seconds/nanoseconds value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">s64</span> <span class="pre">secs</span></code></dt>
<dd>seconds to set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">nsecs</span></code></dt>
<dd>nanoseconds to set</dd>
</dl>
<p><strong>Return</strong></p>
<p>The ktime_t representation of the value.</p>
<dl class="function">
<dt id="c.ktime_compare">
int <code class="descname">ktime_compare</code><span class="sig-paren">(</span>const ktime_t<em>&nbsp;cmp1</em>, const ktime_t<em>&nbsp;cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_compare" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two ktime_t variables for less, greater or equal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt>
<dd>comparable1</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt>
<dd>comparable2</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>...</dt>
<dd>cmp1  &lt; cmp2: return &lt;0
cmp1 == cmp2: return 0
cmp1  &gt; cmp2: return &gt;0</dd>
</dl>
<dl class="function">
<dt id="c.ktime_after">
bool <code class="descname">ktime_after</code><span class="sig-paren">(</span>const ktime_t<em>&nbsp;cmp1</em>, const ktime_t<em>&nbsp;cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_after" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare if a ktime_t value is bigger than another one.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt>
<dd>comparable1</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt>
<dd>comparable2</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if cmp1 happened after cmp2.</p>
<dl class="function">
<dt id="c.ktime_before">
bool <code class="descname">ktime_before</code><span class="sig-paren">(</span>const ktime_t<em>&nbsp;cmp1</em>, const ktime_t<em>&nbsp;cmp2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_before" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare if a ktime_t value is smaller than another one.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp1</span></code></dt>
<dd>comparable1</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">cmp2</span></code></dt>
<dd>comparable2</dd>
</dl>
<p><strong>Return</strong></p>
<p>true if cmp1 happened before cmp2.</p>
<dl class="function">
<dt id="c.ktime_to_timespec_cond">
bool <code class="descname">ktime_to_timespec_cond</code><span class="sig-paren">(</span>const ktime_t<em>&nbsp;kt</em>, struct timespec *<em>&nbsp;ts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_to_timespec_cond" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a ktime_t variable to timespec format only if the variable contains data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">kt</span></code></dt>
<dd>the ktime_t variable to convert</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timespec</span> <span class="pre">*</span> <span class="pre">ts</span></code></dt>
<dd>the timespec variable to store the result in</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if there was a successful conversion, <code class="docutils literal"><span class="pre">false</span></code> if kt was 0.</p>
<dl class="function">
<dt id="c.ktime_to_timespec64_cond">
bool <code class="descname">ktime_to_timespec64_cond</code><span class="sig-paren">(</span>const ktime_t<em>&nbsp;kt</em>, struct timespec64 *<em>&nbsp;ts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ktime_to_timespec64_cond" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a ktime_t variable to timespec64 format only if the variable contains data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">ktime_t</span> <span class="pre">kt</span></code></dt>
<dd>the ktime_t variable to convert</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timespec64</span> <span class="pre">*</span> <span class="pre">ts</span></code></dt>
<dd>the timespec variable to store the result in</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if there was a successful conversion, <code class="docutils literal"><span class="pre">false</span></code> if kt was 0.</p>
<dl class="type">
<dt id="c.hrtimer">
struct <code class="descname">hrtimer</code><a class="headerlink" href="#c.hrtimer" title="Permalink to this definition">¶</a></dt>
<dd><p>the basic hrtimer structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct hrtimer {
  struct timerqueue_node          node;
  ktime_t _softexpires;
  enum hrtimer_restart            (*function)(struct hrtimer *);
  struct hrtimer_clock_base       *base;
  u8 state;
  u8 is_rel;
  u8 is_soft;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>timerqueue node, which also manages node.expires,
the absolute expiry time in the hrtimers internal
representation. The time is related to the clock on
which the timer is based. Is setup by adding
slack to the _softexpires value. For non range timers
identical to _softexpires.</dd>
<dt><code class="docutils literal"><span class="pre">_softexpires</span></code></dt>
<dd>the absolute earliest expiry time of the hrtimer.
The time which was given as expiry time when the timer
was armed.</dd>
<dt><code class="docutils literal"><span class="pre">function</span></code></dt>
<dd>timer expiry callback function</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>pointer to the timer base (per cpu and per clock)</dd>
<dt><code class="docutils literal"><span class="pre">state</span></code></dt>
<dd>state information (See bit values above)</dd>
<dt><code class="docutils literal"><span class="pre">is_rel</span></code></dt>
<dd>Set if the timer was armed relative</dd>
<dt><code class="docutils literal"><span class="pre">is_soft</span></code></dt>
<dd>Set if hrtimer will be expired in soft interrupt context.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The hrtimer structure must be initialized by <a class="reference internal" href="#c.hrtimer_init" title="hrtimer_init"><code class="xref c c-func docutils literal"><span class="pre">hrtimer_init()</span></code></a></p>
<dl class="type">
<dt id="c.hrtimer_sleeper">
struct <code class="descname">hrtimer_sleeper</code><a class="headerlink" href="#c.hrtimer_sleeper" title="Permalink to this definition">¶</a></dt>
<dd><p>simple sleeper structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct hrtimer_sleeper {
  struct hrtimer timer;
  struct task_struct *task;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">timer</span></code></dt>
<dd>embedded timer structure</dd>
<dt><code class="docutils literal"><span class="pre">task</span></code></dt>
<dd>task to wake up</dd>
</dl>
<p><strong>Description</strong></p>
<p>task is set to NULL, when the timer expires.</p>
<dl class="type">
<dt id="c.hrtimer_clock_base">
struct <code class="descname">hrtimer_clock_base</code><a class="headerlink" href="#c.hrtimer_clock_base" title="Permalink to this definition">¶</a></dt>
<dd><p>the timer base for a specific clock</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct hrtimer_clock_base {
  struct hrtimer_cpu_base *cpu_base;
  unsigned int            index;
  clockid_t clockid;
  seqcount_t seq;
  struct hrtimer          *running;
  struct timerqueue_head  active;
  ktime_t (*get_time)(void);
  ktime_t offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cpu_base</span></code></dt>
<dd>per cpu clock base</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>clock type index for per_cpu support when moving a
timer to a base on another cpu.</dd>
<dt><code class="docutils literal"><span class="pre">clockid</span></code></dt>
<dd>clock id for per_cpu support</dd>
<dt><code class="docutils literal"><span class="pre">seq</span></code></dt>
<dd>seqcount around __run_hrtimer</dd>
<dt><code class="docutils literal"><span class="pre">running</span></code></dt>
<dd>pointer to the currently running hrtimer</dd>
<dt><code class="docutils literal"><span class="pre">active</span></code></dt>
<dd>red black tree root node for the active timers</dd>
<dt><code class="docutils literal"><span class="pre">get_time</span></code></dt>
<dd>function to retrieve the current time of the clock</dd>
<dt><code class="docutils literal"><span class="pre">offset</span></code></dt>
<dd>offset of this clock to the monotonic base</dd>
</dl>
<dl class="type">
<dt id="c.hrtimer_cpu_base">
struct <code class="descname">hrtimer_cpu_base</code><a class="headerlink" href="#c.hrtimer_cpu_base" title="Permalink to this definition">¶</a></dt>
<dd><p>the per cpu clock bases</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct hrtimer_cpu_base {
  raw_spinlock_t lock;
  unsigned int                    cpu;
  unsigned int                    active_bases;
  unsigned int                    clock_was_set_seq;
  unsigned int                    hres_active             : 1,in_hrtirq               : 1,hang_detected           : 1, softirq_activated       : 1;
#ifdef CONFIG_HIGH_RES_TIMERS;
  unsigned int                    nr_events;
  unsigned short                  nr_retries;
  unsigned short                  nr_hangs;
  unsigned int                    max_hang_time;
#endif;
  ktime_t expires_next;
  struct hrtimer                  *next_timer;
  ktime_t softirq_expires_next;
  struct hrtimer                  *softirq_next_timer;
  struct hrtimer_clock_base       clock_base[HRTIMER_MAX_CLOCK_BASES];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>lock protecting the base and associated clock bases
and timers</dd>
<dt><code class="docutils literal"><span class="pre">cpu</span></code></dt>
<dd>cpu number</dd>
<dt><code class="docutils literal"><span class="pre">active_bases</span></code></dt>
<dd>Bitfield to mark bases with active timers</dd>
<dt><code class="docutils literal"><span class="pre">clock_was_set_seq</span></code></dt>
<dd>Sequence counter of clock was set events</dd>
<dt><code class="docutils literal"><span class="pre">hres_active</span></code></dt>
<dd>State of high resolution mode</dd>
<dt><code class="docutils literal"><span class="pre">in_hrtirq</span></code></dt>
<dd><code class="xref c c-func docutils literal"><span class="pre">hrtimer_interrupt()</span></code> is currently executing</dd>
<dt><code class="docutils literal"><span class="pre">hang_detected</span></code></dt>
<dd>The last hrtimer interrupt detected a hang</dd>
<dt><code class="docutils literal"><span class="pre">softirq_activated</span></code></dt>
<dd>displays, if the softirq is raised - update of softirq
related settings is not required then.</dd>
<dt><code class="docutils literal"><span class="pre">nr_events</span></code></dt>
<dd>Total number of hrtimer interrupt events</dd>
<dt><code class="docutils literal"><span class="pre">nr_retries</span></code></dt>
<dd>Total number of hrtimer interrupt retries</dd>
<dt><code class="docutils literal"><span class="pre">nr_hangs</span></code></dt>
<dd>Total number of hrtimer interrupt hangs</dd>
<dt><code class="docutils literal"><span class="pre">max_hang_time</span></code></dt>
<dd>Maximum time spent in hrtimer_interrupt</dd>
<dt><code class="docutils literal"><span class="pre">expires_next</span></code></dt>
<dd>absolute time of the next event, is required for remote
hrtimer enqueue; it is the total first expiry time (hard
and soft hrtimer are taken into account)</dd>
<dt><code class="docutils literal"><span class="pre">next_timer</span></code></dt>
<dd>Pointer to the first expiring timer</dd>
<dt><code class="docutils literal"><span class="pre">softirq_expires_next</span></code></dt>
<dd>Time to check, if soft queues needs also to be expired</dd>
<dt><code class="docutils literal"><span class="pre">softirq_next_timer</span></code></dt>
<dd>Pointer to the first expiring softirq based timer</dd>
<dt><code class="docutils literal"><span class="pre">clock_base</span></code></dt>
<dd>array of clock bases for this cpu</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>next_timer is just an optimization for <code class="xref c c-func docutils literal"><span class="pre">__remove_hrtimer()</span></code>.</dt>
<dd>Do not dereference the pointer because it is not reliable on
cross cpu removals.</dd>
</dl>
<dl class="function">
<dt id="c.hrtimer_start">
void <code class="descname">hrtimer_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>&nbsp;timer</em>, ktime_t<em>&nbsp;tim</em>, const enum hrtimer_mode<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(re)start an hrtimer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be added</dd>
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">tim</span></code></dt>
<dd>expiry time</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt>
<dd>timer mode: absolute (HRTIMER_MODE_ABS) or
relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);
softirq based mode is considered for debug purpose only!</dd>
</dl>
<dl class="function">
<dt id="c.hrtimer_forward_now">
u64 <code class="descname">hrtimer_forward_now</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>&nbsp;timer</em>, ktime_t<em>&nbsp;interval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_forward_now" title="Permalink to this definition">¶</a></dt>
<dd><p>forward the timer expiry so it expires after now</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>hrtimer to forward</dd>
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">interval</span></code></dt>
<dd>the interval to forward</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forward the timer expiry so it will expire after the current time
of the hrtimer clock base. Returns the number of overruns.</p>
<p>Can be safely called from the callback function of <strong>timer</strong>. If
called from other contexts <strong>timer</strong> must neither be enqueued nor
running the callback and the caller needs to take care of
serialization.</p>
<p><strong>Note</strong></p>
<p>This only updates the timer expiry value and does not requeue
the timer.</p>
<dl class="function">
<dt id="c.hrtimer_forward">
u64 <code class="descname">hrtimer_forward</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>&nbsp;timer</em>, ktime_t<em>&nbsp;now</em>, ktime_t<em>&nbsp;interval</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_forward" title="Permalink to this definition">¶</a></dt>
<dd><p>forward the timer expiry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>hrtimer to forward</dd>
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">now</span></code></dt>
<dd>forward past this time</dd>
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">interval</span></code></dt>
<dd>the interval to forward</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forward the timer expiry so it will expire in the future.
Returns the number of overruns.</p>
<p>Can be safely called from the callback function of <strong>timer</strong>. If
called from other contexts <strong>timer</strong> must neither be enqueued nor
running the callback and the caller needs to take care of
serialization.</p>
<p><strong>Note</strong></p>
<p>This only updates the timer expiry value and does not requeue
the timer.</p>
<dl class="function">
<dt id="c.hrtimer_start_range_ns">
void <code class="descname">hrtimer_start_range_ns</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>&nbsp;timer</em>, ktime_t<em>&nbsp;tim</em>, u64<em>&nbsp;delta_ns</em>, const enum hrtimer_mode<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_start_range_ns" title="Permalink to this definition">¶</a></dt>
<dd><p>(re)start an hrtimer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be added</dd>
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">tim</span></code></dt>
<dd>expiry time</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">delta_ns</span></code></dt>
<dd>&#8220;slack&#8221; range for the timer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt>
<dd>timer mode: absolute (HRTIMER_MODE_ABS) or
relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);
softirq based mode is considered for debug purpose only!</dd>
</dl>
<dl class="function">
<dt id="c.hrtimer_try_to_cancel">
int <code class="descname">hrtimer_try_to_cancel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>&nbsp;timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_try_to_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>try to deactivate a timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>hrtimer to stop</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div>0 when the timer was not active
1 when the timer was active</div></blockquote>
<dl class="docutils">
<dt>-1 when the timer is currently executing the callback function and</dt>
<dd>cannot be stopped</dd>
</dl>
<dl class="function">
<dt id="c.hrtimer_cancel">
int <code class="descname">hrtimer_cancel</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>&nbsp;timer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a timer and wait for the handler to finish.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be cancelled</dd>
</dl>
<p><strong>Return</strong></p>
<blockquote>
<div>0 when the timer was not active
1 when the timer was active</div></blockquote>
<dl class="function">
<dt id="c.__hrtimer_get_remaining">
ktime_t <code class="descname">__hrtimer_get_remaining</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>&nbsp;timer</em>, bool<em>&nbsp;adjust</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__hrtimer_get_remaining" title="Permalink to this definition">¶</a></dt>
<dd><p>get remaining time for the timer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to read</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">adjust</span></code></dt>
<dd>adjust relative timers when CONFIG_TIME_LOW_RES=y</dd>
</dl>
<dl class="function">
<dt id="c.hrtimer_init">
void <code class="descname">hrtimer_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.hrtimer" title="hrtimer">hrtimer</a> *<em>&nbsp;timer</em>, clockid_t<em>&nbsp;clock_id</em>, enum hrtimer_mode<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.hrtimer_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a timer to the given clock</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">hrtimer</span> <span class="pre">*</span> <span class="pre">timer</span></code></dt>
<dd>the timer to be initialized</dd>
<dt><code class="docutils literal"><span class="pre">clockid_t</span> <span class="pre">clock_id</span></code></dt>
<dd>the clock to be used</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt>
<dd>The modes which are relevant for intitialization:
HRTIMER_MODE_ABS, HRTIMER_MODE_REL, HRTIMER_MODE_ABS_SOFT,
HRTIMER_MODE_REL_SOFT</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>The PINNED variants of the above can be handed in,
but the PINNED bit is ignored as pinning happens
when the hrtimer is started</div></blockquote>
<dl class="function">
<dt id="c.schedule_hrtimeout_range">
int <code class="descname">schedule_hrtimeout_range</code><span class="sig-paren">(</span>ktime_t *<em>&nbsp;expires</em>, u64<em>&nbsp;delta</em>, const enum hrtimer_mode<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_hrtimeout_range" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">*</span> <span class="pre">expires</span></code></dt>
<dd>timeout value (ktime_t)</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">delta</span></code></dt>
<dd>slack in expires timeout (ktime_t)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt>
<dd>timer mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until the given expiry time has
elapsed. The routine will return immediately unless
the current task state has been set (see <code class="xref c c-func docutils literal"><span class="pre">set_current_state()</span></code>).</p>
<p>The <strong>delta</strong> argument gives the kernel the freedom to schedule the
actual wakeup to a time that is both power and performance friendly.
The kernel give the normal best effort behavior for &#8220;<strong>expires**+**delta</strong>&#8221;,
but may decide to fire the timer earlier, but no earlier than <strong>expires</strong>.</p>
<p>You can set the task state as follows -</p>
<p><code class="docutils literal"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> time is guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code></a>).</p>
<p><code class="docutils literal"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be TASK_RUNNING when this
routine returns.</p>
<p>Returns 0 when the timer has expired. If the task was woken before the
timer expired by a signal (only possible in state TASK_INTERRUPTIBLE) or
by an explicit wakeup, it returns -EINTR.</p>
<dl class="function">
<dt id="c.schedule_hrtimeout">
int <code class="descname">schedule_hrtimeout</code><span class="sig-paren">(</span>ktime_t *<em>&nbsp;expires</em>, const enum hrtimer_mode<em>&nbsp;mode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_hrtimeout" title="Permalink to this definition">¶</a></dt>
<dd><p>sleep until timeout</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">*</span> <span class="pre">expires</span></code></dt>
<dd>timeout value (ktime_t)</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">enum</span> <span class="pre">hrtimer_mode</span> <span class="pre">mode</span></code></dt>
<dd>timer mode</dd>
</dl>
<p><strong>Description</strong></p>
<p>Make the current task sleep until the given expiry time has
elapsed. The routine will return immediately unless
the current task state has been set (see <code class="xref c c-func docutils literal"><span class="pre">set_current_state()</span></code>).</p>
<p>You can set the task state as follows -</p>
<p><code class="docutils literal"><span class="pre">TASK_UNINTERRUPTIBLE</span></code> - at least <strong>timeout</strong> time is guaranteed to
pass before the routine returns unless the current task is explicitly
woken up, (e.g. by <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code></a>).</p>
<p><code class="docutils literal"><span class="pre">TASK_INTERRUPTIBLE</span></code> - the routine may return early if a signal is
delivered to the current task or the current task is explicitly woken
up.</p>
<p>The current task state is guaranteed to be TASK_RUNNING when this
routine returns.</p>
<p>Returns 0 when the timer has expired. If the task was woken before the
timer expired by a signal (only possible in state TASK_INTERRUPTIBLE) or
by an explicit wakeup, it returns -EINTR.</p>
</div>
<div class="section" id="workqueues-and-kevents">
<h2>Workqueues and Kevents<a class="headerlink" href="#workqueues-and-kevents" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.workqueue_attrs">
struct <code class="descname">workqueue_attrs</code><a class="headerlink" href="#c.workqueue_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>A struct for workqueue attributes.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct workqueue_attrs {
  int nice;
  cpumask_var_t cpumask;
  bool no_numa;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">nice</span></code></dt>
<dd>nice level</dd>
<dt><code class="docutils literal"><span class="pre">cpumask</span></code></dt>
<dd>allowed CPUs</dd>
<dt><code class="docutils literal"><span class="pre">no_numa</span></code></dt>
<dd><p class="first">disable NUMA affinity</p>
<p class="last">Unlike other fields, <code class="docutils literal"><span class="pre">no_numa</span></code> isn&#8217;t a property of a worker_pool. It
only modifies how <a class="reference internal" href="#c.apply_workqueue_attrs" title="apply_workqueue_attrs"><code class="xref c c-func docutils literal"><span class="pre">apply_workqueue_attrs()</span></code></a> select pools and thus
doesn&#8217;t participate in pool hash calculations or equality comparisons.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This can be used to change attributes of an unbound workqueue.</p>
<dl class="function">
<dt id="c.work_pending">
<code class="descname">work_pending</code><span class="sig-paren">(</span><em>work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.work_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>Find out whether a work item is currently pending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">work</span></code></dt>
<dd>The work item in question</dd>
</dl>
<dl class="function">
<dt id="c.delayed_work_pending">
<code class="descname">delayed_work_pending</code><span class="sig-paren">(</span><em>w</em><span class="sig-paren">)</span><a class="headerlink" href="#c.delayed_work_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>Find out whether a delayable work item is currently pending</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">w</span></code></dt>
<dd>The work item in question</dd>
</dl>
<dl class="function">
<dt id="c.alloc_workqueue">
<code class="descname">alloc_workqueue</code><span class="sig-paren">(</span><em>fmt</em>, <em>flags</em>, <em>max_active</em>, <em>args...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_workqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate a workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fmt</span></code></dt>
<dd>printf format for the name of the workqueue</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>WQ_* flags</dd>
<dt><code class="docutils literal"><span class="pre">max_active</span></code></dt>
<dd>max in-flight work items, 0 for default</dd>
<dt><code class="docutils literal"><span class="pre">args...</span></code></dt>
<dd>args for <strong>fmt</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate a workqueue with the specified parameters.  For detailed
information on WQ_* flags, please refer to
Documentation/core-api/workqueue.rst.</p>
<p>The __lock_name macro dance is to guarantee that single lock_class_key
doesn&#8217;t end up with different namesm, which isn&#8217;t allowed by lockdep.</p>
<p><strong>Return</strong></p>
<p>Pointer to the allocated workqueue on success, <code class="docutils literal"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.alloc_ordered_workqueue">
<code class="descname">alloc_ordered_workqueue</code><span class="sig-paren">(</span><em>fmt</em>, <em>flags</em>, <em>args...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.alloc_ordered_workqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>allocate an ordered workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fmt</span></code></dt>
<dd>printf format for the name of the workqueue</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>WQ_* flags (only WQ_FREEZABLE and WQ_MEM_RECLAIM are meaningful)</dd>
<dt><code class="docutils literal"><span class="pre">args...</span></code></dt>
<dd>args for <strong>fmt</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate an ordered workqueue.  An ordered workqueue executes at
most one work item at any given time in the queued order.  They are
implemented as unbound workqueues with <strong>max_active</strong> of one.</p>
<p><strong>Return</strong></p>
<p>Pointer to the allocated workqueue on success, <code class="docutils literal"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.queue_work">
bool <code class="descname">queue_work</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em>, struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_work" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work on a workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work to queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal"><span class="pre">false</span></code> if <strong>work</strong> was already on a queue, <code class="docutils literal"><span class="pre">true</span></code> otherwise.</p>
<p>We queue the work to the CPU on which it was submitted, but if the CPU dies
it can be processed by another CPU.</p>
<dl class="function">
<dt id="c.queue_delayed_work">
bool <code class="descname">queue_delayed_work</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em>, struct delayed_work *<em>&nbsp;dwork</em>, unsigned long<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work on a workqueue after delay</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>delayable work to queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt>
<dd>number of jiffies to wait before queueing</dd>
</dl>
<p><strong>Description</strong></p>
<p>Equivalent to <a class="reference internal" href="#c.queue_delayed_work_on" title="queue_delayed_work_on"><code class="xref c c-func docutils literal"><span class="pre">queue_delayed_work_on()</span></code></a> but tries to use the local CPU.</p>
<dl class="function">
<dt id="c.mod_delayed_work">
bool <code class="descname">mod_delayed_work</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em>, struct delayed_work *<em>&nbsp;dwork</em>, unsigned long<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>modify delay of or queue a delayed work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>work to queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt>
<dd>number of jiffies to wait before queueing</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.mod_delayed_work_on" title="mod_delayed_work_on"><code class="xref c c-func docutils literal"><span class="pre">mod_delayed_work_on()</span></code></a> on local CPU.</p>
<dl class="function">
<dt id="c.schedule_work_on">
bool <code class="descname">schedule_work_on</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_work_on" title="Permalink to this definition">¶</a></dt>
<dd><p>put work task on a specific cpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>cpu to put the work task on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>job to be done</dd>
</dl>
<p><strong>Description</strong></p>
<p>This puts a job on a specific cpu</p>
<dl class="function">
<dt id="c.schedule_work">
bool <code class="descname">schedule_work</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_work" title="Permalink to this definition">¶</a></dt>
<dd><p>put work task in global workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>job to be done</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal"><span class="pre">false</span></code> if <strong>work</strong> was already on the kernel-global workqueue and
<code class="docutils literal"><span class="pre">true</span></code> otherwise.</p>
<p>This puts a job in the kernel-global workqueue if it was not already
queued and leaves it in the same position on the kernel-global
workqueue otherwise.</p>
<dl class="function">
<dt id="c.flush_scheduled_work">
void <code class="descname">flush_scheduled_work</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.flush_scheduled_work" title="Permalink to this definition">¶</a></dt>
<dd><p>ensure that any scheduled work has run to completion.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Forces execution of the kernel-global workqueue and blocks until its
completion.</p>
<p>Think twice before calling this function!  It&#8217;s very easy to get into
trouble if you don&#8217;t take great care.  Either of the following situations
will lead to deadlock:</p>
<blockquote>
<div><p>One of the work items currently on the workqueue needs to acquire
a lock held by your code or its caller.</p>
<p>Your code is running in the context of a work routine.</p>
</div></blockquote>
<p>They will be detected by lockdep when they occur, but the first might not
occur very often.  It depends on what work items are on the workqueue and
what locks they need, which you have no control over.</p>
<p>In most situations flushing the entire workqueue is overkill; you merely
need to know that a particular work item isn&#8217;t queued and isn&#8217;t running.
In such cases you should use <a class="reference internal" href="#c.cancel_delayed_work_sync" title="cancel_delayed_work_sync"><code class="xref c c-func docutils literal"><span class="pre">cancel_delayed_work_sync()</span></code></a> or
<a class="reference internal" href="#c.cancel_work_sync" title="cancel_work_sync"><code class="xref c c-func docutils literal"><span class="pre">cancel_work_sync()</span></code></a> instead.</p>
<dl class="function">
<dt id="c.schedule_delayed_work_on">
bool <code class="descname">schedule_delayed_work_on</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, struct delayed_work *<em>&nbsp;dwork</em>, unsigned long<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_delayed_work_on" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work in global workqueue on CPU after delay</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>cpu to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>job to be done</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt>
<dd>number of jiffies to wait</dd>
</dl>
<p><strong>Description</strong></p>
<p>After waiting for a given time this puts a job in the kernel-global
workqueue on the specified CPU.</p>
<dl class="function">
<dt id="c.schedule_delayed_work">
bool <code class="descname">schedule_delayed_work</code><span class="sig-paren">(</span>struct delayed_work *<em>&nbsp;dwork</em>, unsigned long<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.schedule_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>put work task in global workqueue after delay</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>job to be done</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt>
<dd>number of jiffies to wait or 0 for immediate execution</dd>
</dl>
<p><strong>Description</strong></p>
<p>After waiting for a given time this puts a job in the kernel-global
workqueue.</p>
<dl class="function">
<dt id="c.queue_work_on">
bool <code class="descname">queue_work_on</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, struct workqueue_struct *<em>&nbsp;wq</em>, struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_work_on" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work on specific cpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>CPU number to execute work on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work to queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>We queue the work to a specific CPU, the caller must ensure it
can&#8217;t go away.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">false</span></code> if <strong>work</strong> was already on a queue, <code class="docutils literal"><span class="pre">true</span></code> otherwise.</p>
<dl class="function">
<dt id="c.queue_delayed_work_on">
bool <code class="descname">queue_delayed_work_on</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, struct workqueue_struct *<em>&nbsp;wq</em>, struct delayed_work *<em>&nbsp;dwork</em>, unsigned long<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_delayed_work_on" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work on specific CPU after delay</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>CPU number to execute work on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>work to queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt>
<dd>number of jiffies to wait before queueing</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">false</span></code> if <strong>work</strong> was already on a queue, <code class="docutils literal"><span class="pre">true</span></code> otherwise.  If
<strong>delay</strong> is zero and <strong>dwork</strong> is idle, it will be scheduled for immediate
execution.</p>
<dl class="function">
<dt id="c.mod_delayed_work_on">
bool <code class="descname">mod_delayed_work_on</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, struct workqueue_struct *<em>&nbsp;wq</em>, struct delayed_work *<em>&nbsp;dwork</em>, unsigned long<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.mod_delayed_work_on" title="Permalink to this definition">¶</a></dt>
<dd><p>modify delay of or queue a delayed work on specific CPU</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>CPU number to execute work on</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>work to queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt>
<dd>number of jiffies to wait before queueing</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>dwork</strong> is idle, equivalent to <a class="reference internal" href="#c.queue_delayed_work_on" title="queue_delayed_work_on"><code class="xref c c-func docutils literal"><span class="pre">queue_delayed_work_on()</span></code></a>; otherwise,
modify <strong>dwork</strong>&#8216;s timer so that it expires after <strong>delay</strong>.  If <strong>delay</strong> is
zero, <strong>work</strong> is guaranteed to be scheduled immediately regardless of its
current state.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">false</span></code> if <strong>dwork</strong> was idle and queued, <code class="docutils literal"><span class="pre">true</span></code> if <strong>dwork</strong> was
pending and its timer was modified.</p>
<p>This function is safe to call from any context including IRQ handler.
See <code class="xref c c-func docutils literal"><span class="pre">try_to_grab_pending()</span></code> for details.</p>
<dl class="function">
<dt id="c.queue_rcu_work">
bool <code class="descname">queue_rcu_work</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em>, struct rcu_work *<em>&nbsp;rwork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.queue_rcu_work" title="Permalink to this definition">¶</a></dt>
<dd><p>queue work after a RCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_work</span> <span class="pre">*</span> <span class="pre">rwork</span></code></dt>
<dd>work to queue</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">false</span></code> if <strong>rwork</strong> was already pending, <code class="docutils literal"><span class="pre">true</span></code> otherwise.  Note
that a full RCU grace period is guaranteed only after a <code class="docutils literal"><span class="pre">true</span></code> return.
While <strong>rwork</strong> is guarnateed to be executed after a <code class="docutils literal"><span class="pre">false</span></code> return, the
execution may happen before a full RCU grace period has passed.</p>
<dl class="function">
<dt id="c.flush_workqueue">
void <code class="descname">flush_workqueue</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flush_workqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>ensure that any scheduled work has run to completion.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function sleeps until all work items which were queued on entry
have finished execution, but it is not livelocked by new incoming ones.</p>
<dl class="function">
<dt id="c.drain_workqueue">
void <code class="descname">drain_workqueue</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.drain_workqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>drain a workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>workqueue to drain</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until the workqueue becomes empty.  While draining is in progress,
only chain queueing is allowed.  IOW, only currently pending or running
work items on <strong>wq</strong> can queue further work items on it.  <strong>wq</strong> is flushed
repeatedly until it becomes empty.  The number of flushing is determined
by the depth of chaining and should be relatively short.  Whine if it
takes too long.</p>
<dl class="function">
<dt id="c.flush_work">
bool <code class="descname">flush_work</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flush_work" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for a work to finish executing the last queueing instance</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the work to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until <strong>work</strong> has finished execution.  <strong>work</strong> is guaranteed to be idle
on return if it hasn&#8217;t been requeued since flush started.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <a class="reference internal" href="#c.flush_work" title="flush_work"><code class="xref c c-func docutils literal"><span class="pre">flush_work()</span></code></a> waited for the work to finish execution,
<code class="docutils literal"><span class="pre">false</span></code> if it was already idle.</p>
<dl class="function">
<dt id="c.cancel_work_sync">
bool <code class="descname">cancel_work_sync</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cancel_work_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a work and wait for it to finish</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the work to cancel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cancel <strong>work</strong> and wait for its execution to finish.  This function
can be used even if the work re-queues itself or migrates to
another workqueue.  On return from this function, <strong>work</strong> is
guaranteed to be not pending or executing on any CPU.</p>
<p>cancel_work_sync(<code class="xref c c-type docutils literal"><span class="pre">delayed_work-&gt;work</span></code>) must not be used for
delayed_work&#8217;s.  Use <a class="reference internal" href="#c.cancel_delayed_work_sync" title="cancel_delayed_work_sync"><code class="xref c c-func docutils literal"><span class="pre">cancel_delayed_work_sync()</span></code></a> instead.</p>
<p>The caller must ensure that the workqueue on which <strong>work</strong> was last
queued can&#8217;t be destroyed before this function returns.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>work</strong> was pending, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.flush_delayed_work">
bool <code class="descname">flush_delayed_work</code><span class="sig-paren">(</span>struct delayed_work *<em>&nbsp;dwork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flush_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for a dwork to finish executing the last queueing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>the delayed work to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>Delayed timer is cancelled and the pending work is queued for
immediate execution.  Like <a class="reference internal" href="#c.flush_work" title="flush_work"><code class="xref c c-func docutils literal"><span class="pre">flush_work()</span></code></a>, this function only
considers the last queueing instance of <strong>dwork</strong>.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <a class="reference internal" href="#c.flush_work" title="flush_work"><code class="xref c c-func docutils literal"><span class="pre">flush_work()</span></code></a> waited for the work to finish execution,
<code class="docutils literal"><span class="pre">false</span></code> if it was already idle.</p>
<dl class="function">
<dt id="c.flush_rcu_work">
bool <code class="descname">flush_rcu_work</code><span class="sig-paren">(</span>struct rcu_work *<em>&nbsp;rwork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.flush_rcu_work" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for a rwork to finish executing the last queueing</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_work</span> <span class="pre">*</span> <span class="pre">rwork</span></code></dt>
<dd>the rcu work to flush</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <a class="reference internal" href="#c.flush_rcu_work" title="flush_rcu_work"><code class="xref c c-func docutils literal"><span class="pre">flush_rcu_work()</span></code></a> waited for the work to finish execution,
<code class="docutils literal"><span class="pre">false</span></code> if it was already idle.</p>
<dl class="function">
<dt id="c.cancel_delayed_work">
bool <code class="descname">cancel_delayed_work</code><span class="sig-paren">(</span>struct delayed_work *<em>&nbsp;dwork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cancel_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a delayed work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>delayed_work to cancel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Kill off a pending delayed_work.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>dwork</strong> was pending and canceled; <code class="docutils literal"><span class="pre">false</span></code> if it wasn&#8217;t
pending.</p>
<p><strong>Note</strong></p>
<p>The work callback function may still be running on return, unless
it returns <code class="docutils literal"><span class="pre">true</span></code> and the work doesn&#8217;t re-arm itself.  Explicitly flush or
use <a class="reference internal" href="#c.cancel_delayed_work_sync" title="cancel_delayed_work_sync"><code class="xref c c-func docutils literal"><span class="pre">cancel_delayed_work_sync()</span></code></a> to wait on it.</p>
<p>This function is safe to call from any context including IRQ handler.</p>
<dl class="function">
<dt id="c.cancel_delayed_work_sync">
bool <code class="descname">cancel_delayed_work_sync</code><span class="sig-paren">(</span>struct delayed_work *<em>&nbsp;dwork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cancel_delayed_work_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a delayed work and wait for it to finish</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>the delayed work cancel</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <a class="reference internal" href="#c.cancel_work_sync" title="cancel_work_sync"><code class="xref c c-func docutils literal"><span class="pre">cancel_work_sync()</span></code></a> for delayed works.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>dwork</strong> was pending, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.execute_in_process_context">
int <code class="descname">execute_in_process_context</code><span class="sig-paren">(</span>work_func_t<em>&nbsp;fn</em>, struct execute_work *<em>&nbsp;ew</em><span class="sig-paren">)</span><a class="headerlink" href="#c.execute_in_process_context" title="Permalink to this definition">¶</a></dt>
<dd><p>reliably execute the routine with user context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">work_func_t</span> <span class="pre">fn</span></code></dt>
<dd>the function to execute</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">execute_work</span> <span class="pre">*</span> <span class="pre">ew</span></code></dt>
<dd>guaranteed storage for the execute work structure (must
be available when the work executes)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Executes the function immediately if process context is available,
otherwise schedules the function for delayed execution.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>0 - function was executed</dt>
<dd>1 - function was scheduled for execution</dd>
</dl>
<dl class="function">
<dt id="c.apply_workqueue_attrs">
int <code class="descname">apply_workqueue_attrs</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em>, const struct <a class="reference internal" href="#c.workqueue_attrs" title="workqueue_attrs">workqueue_attrs</a> *<em>&nbsp;attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.apply_workqueue_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>apply new workqueue_attrs to an unbound workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>the target workqueue</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">workqueue_attrs</span> <span class="pre">*</span> <span class="pre">attrs</span></code></dt>
<dd>the workqueue_attrs to apply, allocated with <code class="xref c c-func docutils literal"><span class="pre">alloc_workqueue_attrs()</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Apply <strong>attrs</strong> to an unbound workqueue <strong>wq</strong>.  Unless disabled, on NUMA
machines, this function maps a separate pwq to each NUMA node with
possibles CPUs in <strong>attrs</strong>-&gt;cpumask so that work items are affine to the
NUMA node it was issued on.  Older pwqs are released as in-flight work
items finish.  Note that a work item which repeatedly requeues itself
back-to-back will stay on its current pwq.</p>
<p>Performs GFP_KERNEL allocations.</p>
<p><strong>Return</strong></p>
<p>0 on success and -errno on failure.</p>
<dl class="function">
<dt id="c.destroy_workqueue">
void <code class="descname">destroy_workqueue</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.destroy_workqueue" title="Permalink to this definition">¶</a></dt>
<dd><p>safely terminate a workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>target workqueue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Safely destroy a workqueue. All work currently pending will be done first.</p>
<dl class="function">
<dt id="c.workqueue_set_max_active">
void <code class="descname">workqueue_set_max_active</code><span class="sig-paren">(</span>struct workqueue_struct *<em>&nbsp;wq</em>, int<em>&nbsp;max_active</em><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_set_max_active" title="Permalink to this definition">¶</a></dt>
<dd><p>adjust max_active of a workqueue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>target workqueue</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">max_active</span></code></dt>
<dd>new max_active value.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set max_active of <strong>wq</strong> to <strong>max_active</strong>.</p>
<p><strong>Context</strong></p>
<p>Don&#8217;t call from IRQ context.</p>
<dl class="function">
<dt id="c.current_work">
struct work_struct * <code class="descname">current_work</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.current_work" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve <code class="docutils literal"><span class="pre">current</span></code> task&#8217;s work struct</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Determine if <code class="docutils literal"><span class="pre">current</span></code> task is a workqueue worker and what it&#8217;s working on.
Useful to find out the context that the <code class="docutils literal"><span class="pre">current</span></code> task is running in.</p>
<p><strong>Return</strong></p>
<p>work struct if <code class="docutils literal"><span class="pre">current</span></code> task is a workqueue worker, <code class="docutils literal"><span class="pre">NULL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.workqueue_congested">
bool <code class="descname">workqueue_congested</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, struct workqueue_struct *<em>&nbsp;wq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.workqueue_congested" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether a workqueue is congested</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>CPU in question</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span> <span class="pre">*</span> <span class="pre">wq</span></code></dt>
<dd>target workqueue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test whether <strong>wq</strong>&#8216;s cpu workqueue for <strong>cpu</strong> is congested.  There is
no synchronization around this function and the test result is
unreliable and only useful as advisory hints or for debugging.</p>
<p>If <strong>cpu</strong> is WORK_CPU_UNBOUND, the test is performed on the local CPU.
Note that both per-cpu and unbound workqueues may be associated with
multiple pool_workqueues which have separate congested states.  A
workqueue being congested on one CPU doesn&#8217;t mean the workqueue is also
contested on other CPUs / NUMA nodes.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if congested, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.work_busy">
unsigned int <code class="descname">work_busy</code><span class="sig-paren">(</span>struct work_struct *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.work_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether a work is currently pending or running</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the work to be tested</dd>
</dl>
<p><strong>Description</strong></p>
<p>Test whether <strong>work</strong> is currently pending or running.  There is no
synchronization around this function and the test result is
unreliable and only useful as advisory hints or for debugging.</p>
<p><strong>Return</strong></p>
<p>OR&#8217;d bitmask of WORK_BUSY_* bits.</p>
<dl class="function">
<dt id="c.set_worker_desc">
void <code class="descname">set_worker_desc</code><span class="sig-paren">(</span>const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.set_worker_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>set description for the current work item</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>printf-style format string</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>arguments for the format string</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be called by a running work function to describe what
the work item is about.  If the worker task gets dumped, this
information will be printed out together to help debugging.  The
description can be at most WORKER_DESC_LEN including the trailing &#8216;0&#8217;.</p>
<dl class="function">
<dt id="c.work_on_cpu">
long <code class="descname">work_on_cpu</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, long (*fn) (void<em>&nbsp;*</em>, void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.work_on_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>run a function in thread context on a particular cpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the cpu to run on</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>the function to run</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>the function arg</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is up to the caller to ensure that the cpu doesn&#8217;t go offline.
The caller must not hold any locks which would prevent <strong>fn</strong> from completing.</p>
<p><strong>Return</strong></p>
<p>The value <strong>fn</strong> returns.</p>
<dl class="function">
<dt id="c.work_on_cpu_safe">
long <code class="descname">work_on_cpu_safe</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, long (*fn) (void<em>&nbsp;*</em>, void *<em>&nbsp;arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.work_on_cpu_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>run a function in thread context on a particular cpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>the cpu to run on</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>the function to run</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">arg</span></code></dt>
<dd>the function argument</dd>
</dl>
<p><strong>Description</strong></p>
<p>Disables CPU hotplug and calls <a class="reference internal" href="#c.work_on_cpu" title="work_on_cpu"><code class="xref c c-func docutils literal"><span class="pre">work_on_cpu()</span></code></a>. The caller must not hold
any locks which would prevent <strong>fn</strong> from completing.</p>
<p><strong>Return</strong></p>
<p>The value <strong>fn</strong> returns.</p>
</div>
<div class="section" id="internal-functions">
<h2>Internal Functions<a class="headerlink" href="#internal-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.wait_task_stopped">
int <code class="descname">wait_task_stopped</code><span class="sig-paren">(</span>struct wait_opts *<em>&nbsp;wo</em>, int<em>&nbsp;ptrace</em>, struct task_struct *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wait_task_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for <code class="docutils literal"><span class="pre">TASK_STOPPED</span></code> or <code class="docutils literal"><span class="pre">TASK_TRACED</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">wait_opts</span> <span class="pre">*</span> <span class="pre">wo</span></code></dt>
<dd>wait options</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">ptrace</span></code></dt>
<dd>is the wait for ptrace</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>task to wait for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Handle <code class="xref c c-func docutils literal"><span class="pre">sys_wait4()</span></code> work for <code class="docutils literal"><span class="pre">p</span></code> in state <code class="docutils literal"><span class="pre">TASK_STOPPED</span></code> or <code class="docutils literal"><span class="pre">TASK_TRACED</span></code>.</p>
<p><strong>Context</strong></p>
<p>read_lock(<code class="xref c c-type docutils literal"><span class="pre">tasklist_lock</span></code>), which is released if return value is
non-zero.  Also, grabs and releases <strong>p</strong>-&gt;sighand-&gt;siglock.</p>
<p><strong>Return</strong></p>
<p>0 if wait condition didn&#8217;t exist and search for other wait conditions
should continue.  Non-zero return, -errno on failure and <strong>p</strong>&#8216;s pid on
success, implies that tasklist_lock is released and wait condition
search should terminate.</p>
<dl class="function">
<dt id="c.task_set_jobctl_pending">
bool <code class="descname">task_set_jobctl_pending</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;task</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_set_jobctl_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>set jobctl pending bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>target task</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>pending bits to set</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>mask</strong> from <strong>task</strong>-&gt;jobctl.  <strong>mask</strong> must be subset of
<code class="docutils literal"><span class="pre">JOBCTL_PENDING_MASK</span></code> | <code class="docutils literal"><span class="pre">JOBCTL_STOP_CONSUME</span></code> | <code class="docutils literal"><span class="pre">JOBCTL_STOP_SIGMASK</span></code> |
<code class="docutils literal"><span class="pre">JOBCTL_TRAPPING</span></code>.  If stop signo is being set, the existing signo is
cleared.  If <strong>task</strong> is already being killed or exiting, this function
becomes noop.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task</strong>-&gt;sighand-&gt;siglock held.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>mask</strong> is set, <code class="docutils literal"><span class="pre">false</span></code> if made noop because <strong>task</strong> was dying.</p>
<dl class="function">
<dt id="c.task_clear_jobctl_trapping">
void <code class="descname">task_clear_jobctl_trapping</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_clear_jobctl_trapping" title="Permalink to this definition">¶</a></dt>
<dd><p>clear jobctl trapping bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>target task</dd>
</dl>
<p><strong>Description</strong></p>
<p>If JOBCTL_TRAPPING is set, a ptracer is waiting for us to enter TRACED.
Clear it and wake up the ptracer.  Note that we don&#8217;t need any further
locking.  <strong>task</strong>-&gt;siglock guarantees that <strong>task</strong>-&gt;parent points to the
ptracer.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task</strong>-&gt;sighand-&gt;siglock held.</p>
<dl class="function">
<dt id="c.task_clear_jobctl_pending">
void <code class="descname">task_clear_jobctl_pending</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;task</em>, unsigned long<em>&nbsp;mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_clear_jobctl_pending" title="Permalink to this definition">¶</a></dt>
<dd><p>clear jobctl pending bits</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>target task</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">mask</span></code></dt>
<dd>pending bits to clear</dd>
</dl>
<p><strong>Description</strong></p>
<p>Clear <strong>mask</strong> from <strong>task</strong>-&gt;jobctl.  <strong>mask</strong> must be subset of
<code class="docutils literal"><span class="pre">JOBCTL_PENDING_MASK</span></code>.  If <code class="docutils literal"><span class="pre">JOBCTL_STOP_PENDING</span></code> is being cleared, other
STOP bits are cleared together.</p>
<p>If clearing of <strong>mask</strong> leaves no stop or trap pending, this function calls
<a class="reference internal" href="#c.task_clear_jobctl_trapping" title="task_clear_jobctl_trapping"><code class="xref c c-func docutils literal"><span class="pre">task_clear_jobctl_trapping()</span></code></a>.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task</strong>-&gt;sighand-&gt;siglock held.</p>
<dl class="function">
<dt id="c.task_participate_group_stop">
bool <code class="descname">task_participate_group_stop</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;task</em><span class="sig-paren">)</span><a class="headerlink" href="#c.task_participate_group_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>participate in a group stop</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">task</span></code></dt>
<dd>task participating in a group stop</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>task</strong> has <code class="docutils literal"><span class="pre">JOBCTL_STOP_PENDING</span></code> set and is participating in a group stop.
Group stop states are cleared and the group stop count is consumed if
<code class="docutils literal"><span class="pre">JOBCTL_STOP_CONSUME</span></code> was set.  If the consumption completes the group
stop, the appropriate <a href="#id1"><span class="problematic" id="id2">``</span></a>SIGNAL_``* flags are set.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task</strong>-&gt;sighand-&gt;siglock held.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if group stop completion should be notified to the parent, <code class="docutils literal"><span class="pre">false</span></code>
otherwise.</p>
<dl class="function">
<dt id="c.ptrace_trap_notify">
void <code class="descname">ptrace_trap_notify</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ptrace_trap_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>schedule trap to notify ptracer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>tracee wanting to notify tracer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function schedules sticky ptrace trap which is cleared on the next
TRAP_STOP to notify ptracer of an event.  <strong>t</strong> must have been seized by
ptracer.</p>
<p>If <strong>t</strong> is running, STOP trap will be taken.  If trapped for STOP and
ptracer is listening for events, tracee is woken up so that it can
re-trap for the new event.  If trapped otherwise, STOP trap will be
eventually taken without returning to userland after the existing traps
are finished by PTRACE_CONT.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>task</strong>-&gt;sighand-&gt;siglock held.</p>
<dl class="function">
<dt id="c.do_notify_parent_cldstop">
void <code class="descname">do_notify_parent_cldstop</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;tsk</em>, bool<em>&nbsp;for_ptracer</em>, int<em>&nbsp;why</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_notify_parent_cldstop" title="Permalink to this definition">¶</a></dt>
<dd><p>notify parent of stopped/continued state change</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">tsk</span></code></dt>
<dd>task reporting the state change</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">for_ptracer</span></code></dt>
<dd>the notification is for ptracer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">why</span></code></dt>
<dd>CLD_{CONTINUED|STOPPED|TRAPPED} to report</dd>
</dl>
<p><strong>Description</strong></p>
<p>Notify <strong>tsk</strong>&#8216;s parent that the stopped/continued state has changed.  If
<strong>for_ptracer</strong> is <code class="docutils literal"><span class="pre">false</span></code>, <strong>tsk</strong>&#8216;s group leader notifies to its real parent.
If <code class="docutils literal"><span class="pre">true</span></code>, <strong>tsk</strong> reports to <strong>tsk</strong>-&gt;parent which should be the ptracer.</p>
<p><strong>Context</strong></p>
<p>Must be called with tasklist_lock at least read locked.</p>
<dl class="function">
<dt id="c.do_signal_stop">
bool <code class="descname">do_signal_stop</code><span class="sig-paren">(</span>int<em>&nbsp;signr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_signal_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>handle group stop for SIGSTOP and other stop signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">signr</span></code></dt>
<dd>signr causing group stop if initiating</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <code class="docutils literal"><span class="pre">JOBCTL_STOP_PENDING</span></code> is not set yet, initiate group stop with <strong>signr</strong>
and participate in it.  If already set, participate in the existing
group stop.  If participated in a group stop (and thus slept), <code class="docutils literal"><span class="pre">true</span></code> is
returned with siglock released.</p>
<p>If ptraced, this function doesn&#8217;t handle stop itself.  Instead,
<code class="docutils literal"><span class="pre">JOBCTL_TRAP_STOP</span></code> is scheduled and <code class="docutils literal"><span class="pre">false</span></code> is returned with siglock
untouched.  The caller must ensure that INTERRUPT trap handling takes
places afterwards.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current</strong>-&gt;sighand-&gt;siglock held, which is released
on <code class="docutils literal"><span class="pre">true</span></code> return.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">false</span></code> if group stop is already cancelled or ptrace trap is scheduled.
<code class="docutils literal"><span class="pre">true</span></code> if participated in group stop.</p>
<dl class="function">
<dt id="c.do_jobctl_trap">
void <code class="descname">do_jobctl_trap</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.do_jobctl_trap" title="Permalink to this definition">¶</a></dt>
<dd><p>take care of ptrace jobctl traps</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>When PT_SEIZED, it&#8217;s used for both group stop and explicit
SEIZE/INTERRUPT traps.  Both generate PTRACE_EVENT_STOP trap with
accompanying siginfo.  If stopped, lower eight bits of exit_code contain
the stop signal; otherwise, <code class="docutils literal"><span class="pre">SIGTRAP</span></code>.</p>
<p>When !PT_SEIZED, it&#8217;s used only for group stop trap with stop signal
number as exit_code and no siginfo.</p>
<p><strong>Context</strong></p>
<p>Must be called with <strong>current</strong>-&gt;sighand-&gt;siglock held, which may be
released and re-acquired before returning with intervening sleep.</p>
<dl class="function">
<dt id="c.signal_delivered">
void <code class="descname">signal_delivered</code><span class="sig-paren">(</span>struct ksignal *<em>&nbsp;ksig</em>, int<em>&nbsp;stepping</em><span class="sig-paren">)</span><a class="headerlink" href="#c.signal_delivered" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">ksignal</span> <span class="pre">*</span> <span class="pre">ksig</span></code></dt>
<dd>kernel signal struct</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">stepping</span></code></dt>
<dd>nonzero if debugger single-step or block-step in use</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called when a signal has successfully been
delivered. It updates the blocked signals accordingly (<strong>ksig</strong>-&gt;ka.sa.sa_mask
is always blocked, and the signal itself is blocked unless <code class="docutils literal"><span class="pre">SA_NODEFER</span></code>
is set in <strong>ksig</strong>-&gt;ka.sa.sa_flags.  Tracing is notified.</p>
<dl class="function">
<dt id="c.sys_restart_syscall">
long <code class="descname">sys_restart_syscall</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.sys_restart_syscall" title="Permalink to this definition">¶</a></dt>
<dd><p>restart a system call</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.set_current_blocked">
void <code class="descname">set_current_blocked</code><span class="sig-paren">(</span>sigset_t *<em>&nbsp;newset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_current_blocked" title="Permalink to this definition">¶</a></dt>
<dd><p>change current-&gt;blocked mask</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sigset_t</span> <span class="pre">*</span> <span class="pre">newset</span></code></dt>
<dd>new mask</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is wrong to change -&gt;blocked directly, this helper should be used
to ensure the process can&#8217;t miss a shared signal we are going to block.</p>
<dl class="function">
<dt id="c.sys_rt_sigprocmask">
long <code class="descname">sys_rt_sigprocmask</code><span class="sig-paren">(</span>int<em>&nbsp;how</em>, sigset_t __user *<em>&nbsp;nset</em>, sigset_t __user *<em>&nbsp;oset</em>, size_t<em>&nbsp;sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigprocmask" title="Permalink to this definition">¶</a></dt>
<dd><p>change the list of currently blocked signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">how</span></code></dt>
<dd>whether to add, remove, or set signals</dd>
<dt><code class="docutils literal"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">nset</span></code></dt>
<dd>stores pending signals</dd>
<dt><code class="docutils literal"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oset</span></code></dt>
<dd>previous value of signal mask if non-null</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt>
<dd>size of sigset_t type</dd>
</dl>
<dl class="function">
<dt id="c.sys_rt_sigpending">
long <code class="descname">sys_rt_sigpending</code><span class="sig-paren">(</span>sigset_t __user *<em>&nbsp;uset</em>, size_t<em>&nbsp;sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigpending" title="Permalink to this definition">¶</a></dt>
<dd><p>examine a pending signal that has been raised while blocked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uset</span></code></dt>
<dd>stores pending signals</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt>
<dd>size of sigset_t type or larger</dd>
</dl>
<dl class="function">
<dt id="c.do_sigtimedwait">
int <code class="descname">do_sigtimedwait</code><span class="sig-paren">(</span>const sigset_t *<em>&nbsp;which</em>, siginfo_t *<em>&nbsp;info</em>, const struct timespec *<em>&nbsp;ts</em><span class="sig-paren">)</span><a class="headerlink" href="#c.do_sigtimedwait" title="Permalink to this definition">¶</a></dt>
<dd><p>wait for queued signals specified in <strong>which</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">sigset_t</span> <span class="pre">*</span> <span class="pre">which</span></code></dt>
<dd>queued signals to wait for</dd>
<dt><code class="docutils literal"><span class="pre">siginfo_t</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>if non-null, the signal&#8217;s siginfo is returned here</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec</span> <span class="pre">*</span> <span class="pre">ts</span></code></dt>
<dd>upper bound on process time suspension</dd>
</dl>
<dl class="function">
<dt id="c.sys_rt_sigtimedwait">
long <code class="descname">sys_rt_sigtimedwait</code><span class="sig-paren">(</span>const sigset_t __user *<em>&nbsp;uthese</em>, siginfo_t __user *<em>&nbsp;uinfo</em>, const struct timespec __user *<em>&nbsp;uts</em>, size_t<em>&nbsp;sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigtimedwait" title="Permalink to this definition">¶</a></dt>
<dd><p>synchronously wait for queued signals specified in <strong>uthese</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uthese</span></code></dt>
<dd>queued signals to wait for</dd>
<dt><code class="docutils literal"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>if non-null, the signal&#8217;s siginfo is returned here</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">timespec</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uts</span></code></dt>
<dd>upper bound on process time suspension</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt>
<dd>size of sigset_t type</dd>
</dl>
<dl class="function">
<dt id="c.sys_kill">
long <code class="descname">sys_kill</code><span class="sig-paren">(</span>pid_t<em>&nbsp;pid</em>, int<em>&nbsp;sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_kill" title="Permalink to this definition">¶</a></dt>
<dd><p>send a signal to a process</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt>
<dd>the PID of the process</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig</span></code></dt>
<dd>signal to be sent</dd>
</dl>
<dl class="function">
<dt id="c.sys_tgkill">
long <code class="descname">sys_tgkill</code><span class="sig-paren">(</span>pid_t<em>&nbsp;tgid</em>, pid_t<em>&nbsp;pid</em>, int<em>&nbsp;sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_tgkill" title="Permalink to this definition">¶</a></dt>
<dd><p>send signal to one specific thread</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pid_t</span> <span class="pre">tgid</span></code></dt>
<dd>the thread group ID of the thread</dd>
<dt><code class="docutils literal"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt>
<dd>the PID of the thread</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig</span></code></dt>
<dd>signal to be sent</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>This syscall also checks the <strong>tgid</strong> and returns -ESRCH even if the PID
exists but it&#8217;s not belonging to the target process anymore. This
method solves the problem of threads exiting and PIDs getting reused.</div></blockquote>
<dl class="function">
<dt id="c.sys_tkill">
long <code class="descname">sys_tkill</code><span class="sig-paren">(</span>pid_t<em>&nbsp;pid</em>, int<em>&nbsp;sig</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_tkill" title="Permalink to this definition">¶</a></dt>
<dd><p>send signal to one specific task</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt>
<dd>the PID of the task</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig</span></code></dt>
<dd>signal to be sent</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Send a signal to only one task, even if it&#8217;s a CLONE_THREAD task.</div></blockquote>
<dl class="function">
<dt id="c.sys_rt_sigqueueinfo">
long <code class="descname">sys_rt_sigqueueinfo</code><span class="sig-paren">(</span>pid_t<em>&nbsp;pid</em>, int<em>&nbsp;sig</em>, siginfo_t __user *<em>&nbsp;uinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigqueueinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>send signal information to a signal</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">pid_t</span> <span class="pre">pid</span></code></dt>
<dd>the PID of the thread</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig</span></code></dt>
<dd>signal to be sent</dd>
<dt><code class="docutils literal"><span class="pre">siginfo_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uinfo</span></code></dt>
<dd>signal info to be sent</dd>
</dl>
<dl class="function">
<dt id="c.sys_sigpending">
long <code class="descname">sys_sigpending</code><span class="sig-paren">(</span>old_sigset_t __user *<em>&nbsp;uset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_sigpending" title="Permalink to this definition">¶</a></dt>
<dd><p>examine pending signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">uset</span></code></dt>
<dd>where mask of pending signal is returned</dd>
</dl>
<dl class="function">
<dt id="c.sys_sigprocmask">
long <code class="descname">sys_sigprocmask</code><span class="sig-paren">(</span>int<em>&nbsp;how</em>, old_sigset_t __user *<em>&nbsp;nset</em>, old_sigset_t __user *<em>&nbsp;oset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_sigprocmask" title="Permalink to this definition">¶</a></dt>
<dd><p>examine and change blocked signals</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">how</span></code></dt>
<dd>whether to add, remove, or set signals</dd>
<dt><code class="docutils literal"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">nset</span></code></dt>
<dd>signals to add or remove (if non-null)</dd>
<dt><code class="docutils literal"><span class="pre">old_sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oset</span></code></dt>
<dd>previous value of signal mask if non-null</dd>
</dl>
<p><strong>Description</strong></p>
<p>Some platforms have their own version with special arguments;
others support only sys_rt_sigprocmask.</p>
<dl class="function">
<dt id="c.sys_rt_sigaction">
long <code class="descname">sys_rt_sigaction</code><span class="sig-paren">(</span>int<em>&nbsp;sig</em>, const struct sigaction __user *<em>&nbsp;act</em>, struct sigaction __user *<em>&nbsp;oact</em>, size_t<em>&nbsp;sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigaction" title="Permalink to this definition">¶</a></dt>
<dd><p>alter an action taken by a process</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">sig</span></code></dt>
<dd>signal to be sent</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">sigaction</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">act</span></code></dt>
<dd>new sigaction</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sigaction</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">oact</span></code></dt>
<dd>used to save the previous sigaction</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt>
<dd>size of sigset_t type</dd>
</dl>
<dl class="function">
<dt id="c.sys_rt_sigsuspend">
long <code class="descname">sys_rt_sigsuspend</code><span class="sig-paren">(</span>sigset_t __user *<em>&nbsp;unewset</em>, size_t<em>&nbsp;sigsetsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.sys_rt_sigsuspend" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the signal mask for a value with the <strong>unewset</strong> value until a signal is received</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">sigset_t</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">unewset</span></code></dt>
<dd>new signal mask value</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">sigsetsize</span></code></dt>
<dd>size of sigset_t type</dd>
</dl>
<dl class="function">
<dt id="c.kthread_create">
<code class="descname">kthread_create</code><span class="sig-paren">(</span><em>threadfn</em>, <em>data</em>, <em>namefmt</em>, <em>arg...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create a kthread on the current node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">threadfn</span></code></dt>
<dd>the function to run in the thread</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>data pointer for <strong>threadfn()</strong></dd>
<dt><code class="docutils literal"><span class="pre">namefmt</span></code></dt>
<dd>printf-style format string for the thread name</dd>
<dt><code class="docutils literal"><span class="pre">arg...</span></code></dt>
<dd>arguments for <strong>namefmt</strong>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro will create a kthread on the current node, leaving it in
the stopped state.  This is just a helper for <a class="reference internal" href="#c.kthread_create_on_node" title="kthread_create_on_node"><code class="xref c c-func docutils literal"><span class="pre">kthread_create_on_node()</span></code></a>;
see the documentation there for more details.</p>
<dl class="function">
<dt id="c.kthread_run">
<code class="descname">kthread_run</code><span class="sig-paren">(</span><em>threadfn</em>, <em>data</em>, <em>namefmt</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_run" title="Permalink to this definition">¶</a></dt>
<dd><p>create and wake a thread.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">threadfn</span></code></dt>
<dd>the function to run until signal_pending(current).</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>data ptr for <strong>threadfn</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">namefmt</span></code></dt>
<dd>printf-style name for the thread.</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Convenient wrapper for <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a> followed by
<a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code></a>.  Returns the kthread or ERR_PTR(-ENOMEM).</p>
<dl class="function">
<dt id="c.kthread_should_stop">
bool <code class="descname">kthread_should_stop</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_should_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>should this kthread return now?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>When someone calls <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_stop()</span></code></a> on your kthread, it will be woken
and this will return true.  You should then return, and your return
value will be passed through to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_stop()</span></code></a>.</p>
<dl class="function">
<dt id="c.kthread_should_park">
bool <code class="descname">kthread_should_park</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_should_park" title="Permalink to this definition">¶</a></dt>
<dd><p>should this kthread park now?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>When someone calls <a class="reference internal" href="#c.kthread_park" title="kthread_park"><code class="xref c c-func docutils literal"><span class="pre">kthread_park()</span></code></a> on your kthread, it will be woken
and this will return true.  You should then do the necessary
cleanup and call <code class="xref c c-func docutils literal"><span class="pre">kthread_parkme()</span></code></p>
<p>Similar to <a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_should_stop()</span></code></a>, but this keeps the thread alive
and in a park position. <a class="reference internal" href="#c.kthread_unpark" title="kthread_unpark"><code class="xref c c-func docutils literal"><span class="pre">kthread_unpark()</span></code></a> &#8220;restarts&#8221; the thread and
calls the thread function again.</p>
<dl class="function">
<dt id="c.kthread_freezable_should_stop">
bool <code class="descname">kthread_freezable_should_stop</code><span class="sig-paren">(</span>bool *<em>&nbsp;was_frozen</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_freezable_should_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>should this freezable kthread return now?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">*</span> <span class="pre">was_frozen</span></code></dt>
<dd>optional out parameter, indicates whether <code class="docutils literal"><span class="pre">current</span></code> was frozen</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_should_stop()</span></code></a> for freezable kthreads, which will enter
refrigerator if necessary.  This function is safe from <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_stop()</span></code></a> /
freezer deadlock and freezable kthreads should use this function instead
of calling <code class="xref c c-func docutils literal"><span class="pre">try_to_freeze()</span></code> directly.</p>
<dl class="function">
<dt id="c.kthread_create_on_node">
struct task_struct * <code class="descname">kthread_create_on_node</code><span class="sig-paren">(</span>int (*threadfn) (void<em>&nbsp;*data</em>, void *<em>&nbsp;data</em>, int<em>&nbsp;node</em>, const char<em>&nbsp;namefmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_on_node" title="Permalink to this definition">¶</a></dt>
<dd><p>create a kthread.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(void</span> <span class="pre">*data)</span> <span class="pre">threadfn</span></code></dt>
<dd>the function to run until signal_pending(current).</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data ptr for <strong>threadfn</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">node</span></code></dt>
<dd>task and thread structures for the thread are allocated on this node</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt</span></code></dt>
<dd>printf-style name for the thread.</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function creates and names a kernel
thread.  The thread will be stopped: use <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code></a> to start
it.  See also <a class="reference internal" href="#c.kthread_run" title="kthread_run"><code class="xref c c-func docutils literal"><span class="pre">kthread_run()</span></code></a>.  The new thread has SCHED_NORMAL policy and
is affine to all CPUs.</p>
<p>If thread is going to be bound on a particular cpu, give its node
in <strong>node</strong>, to get NUMA affinity for kthread stack, or else give NUMA_NO_NODE.
When woken, the thread will run <strong>threadfn()</strong> with <strong>data</strong> as its
argument. <strong>threadfn()</strong> can either call <code class="xref c c-func docutils literal"><span class="pre">do_exit()</span></code> directly if it is a
standalone thread for which no one will call <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_stop()</span></code></a>, or
return when &#8216;<a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_should_stop()</span></code></a>&#8216; is true (which means
<a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_stop()</span></code></a> has been called).  The return value should be zero
or a negative error number; it will be passed to <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_stop()</span></code></a>.</p>
<p>Returns a task_struct or ERR_PTR(-ENOMEM) or ERR_PTR(-EINTR).</p>
<dl class="function">
<dt id="c.kthread_bind">
void <code class="descname">kthread_bind</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;p</em>, unsigned int<em>&nbsp;cpu</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_bind" title="Permalink to this definition">¶</a></dt>
<dd><p>bind a just-created kthread to a cpu.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>cpu (might not be online, must be possible) for <strong>k</strong> to run on.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is equivalent to <code class="xref c c-func docutils literal"><span class="pre">set_cpus_allowed()</span></code>,
except that <strong>cpu</strong> doesn&#8217;t need to be online, and the thread must be
stopped (i.e., just returned from <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>).</p>
<dl class="function">
<dt id="c.kthread_unpark">
void <code class="descname">kthread_unpark</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_unpark" title="Permalink to this definition">¶</a></dt>
<dd><p>unpark a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">k</span></code></dt>
<dd>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_park" title="kthread_should_park"><code class="xref c c-func docutils literal"><span class="pre">kthread_should_park()</span></code></a> for <strong>k</strong> to return false, wakes it, and
waits for it to return. If the thread is marked percpu then its
bound to the cpu again.</p>
<dl class="function">
<dt id="c.kthread_park">
int <code class="descname">kthread_park</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_park" title="Permalink to this definition">¶</a></dt>
<dd><p>park a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">k</span></code></dt>
<dd>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_park" title="kthread_should_park"><code class="xref c c-func docutils literal"><span class="pre">kthread_should_park()</span></code></a> for <strong>k</strong> to return true, wakes it, and
waits for it to return. This can also be called after <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>
instead of calling <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code></a>: the thread will park without
calling <code class="xref c c-func docutils literal"><span class="pre">threadfn()</span></code>.</p>
<p>Returns 0 if the thread is parked, -ENOSYS if the thread exited.
If called by the kthread itself just the park bit is set.</p>
<dl class="function">
<dt id="c.kthread_stop">
int <code class="descname">kthread_stop</code><span class="sig-paren">(</span>struct task_struct *<em>&nbsp;k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop a thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span> <span class="pre">*</span> <span class="pre">k</span></code></dt>
<dd>thread created by <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Sets <a class="reference internal" href="#c.kthread_should_stop" title="kthread_should_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_should_stop()</span></code></a> for <strong>k</strong> to return true, wakes it, and
waits for it to exit. This can also be called after <a class="reference internal" href="#c.kthread_create" title="kthread_create"><code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code></a>
instead of calling <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code></a>: the thread will exit without
calling <code class="xref c c-func docutils literal"><span class="pre">threadfn()</span></code>.</p>
<p>If <code class="xref c c-func docutils literal"><span class="pre">threadfn()</span></code> may call <code class="xref c c-func docutils literal"><span class="pre">do_exit()</span></code> itself, the caller must ensure
task_struct can&#8217;t go away.</p>
<p>Returns the result of <code class="xref c c-func docutils literal"><span class="pre">threadfn()</span></code>, or <code class="docutils literal"><span class="pre">-EINTR</span></code> if <a class="reference internal" href="#c.wake_up_process" title="wake_up_process"><code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code></a>
was never called.</p>
<dl class="function">
<dt id="c.kthread_worker_fn">
int <code class="descname">kthread_worker_fn</code><span class="sig-paren">(</span>void *<em>&nbsp;worker_ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_worker_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>kthread function to process kthread_worker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">worker_ptr</span></code></dt>
<dd>pointer to initialized kthread_worker</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements the main cycle of kthread worker. It processes
work_list until it is stopped with <a class="reference internal" href="#c.kthread_stop" title="kthread_stop"><code class="xref c c-func docutils literal"><span class="pre">kthread_stop()</span></code></a>. It sleeps when the queue
is empty.</p>
<p>The works are not allowed to keep any locks, disable preemption or interrupts
when they finish. There is defined a safe point for freezing when one work
finishes and before a new one is started.</p>
<p>Also the works must not be handled by more than one worker at the same time,
see also <a class="reference internal" href="#c.kthread_queue_work" title="kthread_queue_work"><code class="xref c c-func docutils literal"><span class="pre">kthread_queue_work()</span></code></a>.</p>
<dl class="function">
<dt id="c.kthread_create_worker">
struct kthread_worker * <code class="descname">kthread_create_worker</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;flags</em>, const char<em>&nbsp;namefmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>create a kthread worker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags modifying the default behavior of the worker</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt</span></code></dt>
<dd>printf-style name for the kthread worker (task).</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the allocated worker on success, ERR_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR_PTR(-EINTR)
when the worker was SIGKILLed.</p>
<dl class="function">
<dt id="c.kthread_create_worker_on_cpu">
struct kthread_worker * <code class="descname">kthread_create_worker_on_cpu</code><span class="sig-paren">(</span>int<em>&nbsp;cpu</em>, unsigned int<em>&nbsp;flags</em>, const char<em>&nbsp;namefmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_create_worker_on_cpu" title="Permalink to this definition">¶</a></dt>
<dd><p>create a kthread worker and bind it it to a given CPU and the associated NUMA node.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">cpu</span></code></dt>
<dd>CPU number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>flags modifying the default behavior of the worker</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">namefmt</span></code></dt>
<dd>printf-style name for the kthread worker (task).</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use a valid CPU number if you want to bind the kthread worker
to the given CPU and the associated NUMA node.</p>
<p>A good practice is to add the cpu number also into the worker name.
For example, use kthread_create_worker_on_cpu(cpu, &#8220;helper/<code class="docutils literal"><span class="pre">d</span></code>&#8221;, cpu).</p>
<p>Returns a pointer to the allocated worker on success, ERR_PTR(-ENOMEM)
when the needed structures could not get allocated, and ERR_PTR(-EINTR)
when the worker was SIGKILLed.</p>
<dl class="function">
<dt id="c.kthread_queue_work">
bool <code class="descname">kthread_queue_work</code><span class="sig-paren">(</span>struct kthread_worker *<em>&nbsp;worker</em>, struct kthread_work *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_queue_work" title="Permalink to this definition">¶</a></dt>
<dd><p>queue a kthread_work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*</span> <span class="pre">worker</span></code></dt>
<dd>target kthread_worker</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>kthread_work to queue</dd>
</dl>
<p><strong>Description</strong></p>
<p>Queue <strong>work</strong> to work processor <strong>task</strong> for async execution.  <strong>task</strong>
must have been created with <code class="xref c c-func docutils literal"><span class="pre">kthread_worker_create()</span></code>.  Returns <code class="docutils literal"><span class="pre">true</span></code>
if <strong>work</strong> was successfully queued, <code class="docutils literal"><span class="pre">false</span></code> if it was already pending.</p>
<p>Reinitialize the work if it needs to be used by another worker.
For example, when the worker was stopped and started again.</p>
<dl class="function">
<dt id="c.kthread_delayed_work_timer_fn">
void <code class="descname">kthread_delayed_work_timer_fn</code><span class="sig-paren">(</span>struct timer_list *<em>&nbsp;t</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_delayed_work_timer_fn" title="Permalink to this definition">¶</a></dt>
<dd><p>callback that queues the associated kthread delayed work when the timer expires.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span> <span class="pre">*</span> <span class="pre">t</span></code></dt>
<dd>pointer to the expired timer</dd>
</dl>
<p><strong>Description</strong></p>
<p>The format of the function is defined by struct timer_list.
It should have been called from irqsafe timer with irq already off.</p>
<dl class="function">
<dt id="c.kthread_queue_delayed_work">
bool <code class="descname">kthread_queue_delayed_work</code><span class="sig-paren">(</span>struct kthread_worker *<em>&nbsp;worker</em>, struct kthread_delayed_work *<em>&nbsp;dwork</em>, unsigned long<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_queue_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>queue the associated kthread work after a delay.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*</span> <span class="pre">worker</span></code></dt>
<dd>target kthread_worker</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>kthread_delayed_work to queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt>
<dd>number of jiffies to wait before queuing</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the work has not been pending it starts a timer that will queue
the work after the given <strong>delay</strong>. If <strong>delay</strong> is zero, it queues the
work immediately.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">false</span></code> if the <strong>work</strong> has already been pending. It means that
either the timer was running or the work was queued. It returns <code class="docutils literal"><span class="pre">true</span></code>
otherwise.</p>
<dl class="function">
<dt id="c.kthread_flush_work">
void <code class="descname">kthread_flush_work</code><span class="sig-paren">(</span>struct kthread_work *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_flush_work" title="Permalink to this definition">¶</a></dt>
<dd><p>flush a kthread_work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>work to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>work</strong> is queued or executing, wait for it to finish execution.</p>
<dl class="function">
<dt id="c.kthread_mod_delayed_work">
bool <code class="descname">kthread_mod_delayed_work</code><span class="sig-paren">(</span>struct kthread_worker *<em>&nbsp;worker</em>, struct kthread_delayed_work *<em>&nbsp;dwork</em>, unsigned long<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_mod_delayed_work" title="Permalink to this definition">¶</a></dt>
<dd><p>modify delay of or queue a kthread delayed work</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*</span> <span class="pre">worker</span></code></dt>
<dd>kthread worker to use</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>kthread delayed work to queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">delay</span></code></dt>
<dd>number of jiffies to wait before queuing</dd>
</dl>
<p><strong>Description</strong></p>
<p>If <strong>dwork</strong> is idle, equivalent to <a class="reference internal" href="#c.kthread_queue_delayed_work" title="kthread_queue_delayed_work"><code class="xref c c-func docutils literal"><span class="pre">kthread_queue_delayed_work()</span></code></a>. Otherwise,
modify <strong>dwork</strong>&#8216;s timer so that it expires after <strong>delay</strong>. If <strong>delay</strong> is zero,
<strong>work</strong> is guaranteed to be queued immediately.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>dwork</strong> was pending and its timer was modified,
<code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<p>A special case is when the work is being canceled in parallel.
It might be caused either by the real <a class="reference internal" href="#c.kthread_cancel_delayed_work_sync" title="kthread_cancel_delayed_work_sync"><code class="xref c c-func docutils literal"><span class="pre">kthread_cancel_delayed_work_sync()</span></code></a>
or yet another <a class="reference internal" href="#c.kthread_mod_delayed_work" title="kthread_mod_delayed_work"><code class="xref c c-func docutils literal"><span class="pre">kthread_mod_delayed_work()</span></code></a> call. We let the other command
win and return <code class="docutils literal"><span class="pre">false</span></code> here. The caller is supposed to synchronize these
operations a reasonable way.</p>
<p>This function is safe to call from any context including IRQ handler.
See <code class="xref c c-func docutils literal"><span class="pre">__kthread_cancel_work()</span></code> and <a class="reference internal" href="#c.kthread_delayed_work_timer_fn" title="kthread_delayed_work_timer_fn"><code class="xref c c-func docutils literal"><span class="pre">kthread_delayed_work_timer_fn()</span></code></a>
for details.</p>
<dl class="function">
<dt id="c.kthread_cancel_work_sync">
bool <code class="descname">kthread_cancel_work_sync</code><span class="sig-paren">(</span>struct kthread_work *<em>&nbsp;work</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_cancel_work_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a kthread work and wait for it to finish</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_work</span> <span class="pre">*</span> <span class="pre">work</span></code></dt>
<dd>the kthread work to cancel</dd>
</dl>
<p><strong>Description</strong></p>
<p>Cancel <strong>work</strong> and wait for its execution to finish.  This function
can be used even if the work re-queues itself. On return from this
function, <strong>work</strong> is guaranteed to be not pending or executing on any CPU.</p>
<p>kthread_cancel_work_sync(<code class="xref c c-type docutils literal"><span class="pre">delayed_work-&gt;work</span></code>) must not be used for
delayed_work&#8217;s. Use <a class="reference internal" href="#c.kthread_cancel_delayed_work_sync" title="kthread_cancel_delayed_work_sync"><code class="xref c c-func docutils literal"><span class="pre">kthread_cancel_delayed_work_sync()</span></code></a> instead.</p>
<p>The caller must ensure that the worker on which <strong>work</strong> was last
queued can&#8217;t be destroyed before this function returns.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>work</strong> was pending, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.kthread_cancel_delayed_work_sync">
bool <code class="descname">kthread_cancel_delayed_work_sync</code><span class="sig-paren">(</span>struct kthread_delayed_work *<em>&nbsp;dwork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_cancel_delayed_work_sync" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel a kthread delayed work and wait for it to finish.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_delayed_work</span> <span class="pre">*</span> <span class="pre">dwork</span></code></dt>
<dd>the kthread delayed work to cancel</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <a class="reference internal" href="#c.kthread_cancel_work_sync" title="kthread_cancel_work_sync"><code class="xref c c-func docutils literal"><span class="pre">kthread_cancel_work_sync()</span></code></a> for delayed works.</p>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if <strong>dwork</strong> was pending, <code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.kthread_flush_worker">
void <code class="descname">kthread_flush_worker</code><span class="sig-paren">(</span>struct kthread_worker *<em>&nbsp;worker</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_flush_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>flush all current works on a kthread_worker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*</span> <span class="pre">worker</span></code></dt>
<dd>worker to flush</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait until all currently executing or pending works on <strong>worker</strong> are
finished.</p>
<dl class="function">
<dt id="c.kthread_destroy_worker">
void <code class="descname">kthread_destroy_worker</code><span class="sig-paren">(</span>struct kthread_worker *<em>&nbsp;worker</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_destroy_worker" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy a kthread worker</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kthread_worker</span> <span class="pre">*</span> <span class="pre">worker</span></code></dt>
<dd>worker to be destroyed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flush and destroy <strong>worker</strong>.  The simple flush is enough because the kthread
worker API is used only in trivial scenarios.  There are no multi-step state
machines needed.</p>
<dl class="function">
<dt id="c.kthread_associate_blkcg">
void <code class="descname">kthread_associate_blkcg</code><span class="sig-paren">(</span>struct cgroup_subsys_state *<em>&nbsp;css</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_associate_blkcg" title="Permalink to this definition">¶</a></dt>
<dd><p>associate blkcg to current kthread</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">cgroup_subsys_state</span> <span class="pre">*</span> <span class="pre">css</span></code></dt>
<dd>the cgroup info</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current thread must be a kthread. The thread is running jobs on behalf of
other threads. In some cases, we expect the jobs attach cgroup info of
original threads instead of that of current thread. This function stores
original thread&#8217;s cgroup info in current kthread context for later
retrieval.</p>
<dl class="function">
<dt id="c.kthread_blkcg">
struct cgroup_subsys_state * <code class="descname">kthread_blkcg</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.kthread_blkcg" title="Permalink to this definition">¶</a></dt>
<dd><p>get associated blkcg css of current kthread</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Current thread must be a kthread.</p>
</div>
<div class="section" id="reference-counting">
<h2>Reference counting<a class="headerlink" href="#reference-counting" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.refcount_struct">
struct <code class="descname">refcount_struct</code><a class="headerlink" href="#c.refcount_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>variant of atomic_t specialized for reference counts</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct refcount_struct {
  atomic_t refs;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refs</span></code></dt>
<dd>atomic_t counter field</dd>
</dl>
<p><strong>Description</strong></p>
<p>The counter saturates at UINT_MAX and will not move once
there. This avoids wrapping the counter and causing &#8216;spurious&#8217;
use-after-free bugs.</p>
<dl class="function">
<dt id="c.refcount_set">
void <code class="descname">refcount_set</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em>, unsigned int<em>&nbsp;n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set a refcount&#8217;s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n</span></code></dt>
<dd>value to which the refcount will be set</dd>
</dl>
<dl class="function">
<dt id="c.refcount_read">
unsigned int <code class="descname">refcount_read</code><span class="sig-paren">(</span>const refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_read" title="Permalink to this definition">¶</a></dt>
<dd><p>get a refcount&#8217;s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
</dl>
<p><strong>Return</strong></p>
<p>the refcount&#8217;s value</p>
<dl class="function">
<dt id="c.refcount_add_not_zero_checked">
bool <code class="descname">refcount_add_not_zero_checked</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;i</em>, refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add_not_zero_checked" title="Permalink to this definition">¶</a></dt>
<dd><p>add a value to a refcount unless it is 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>the value to add to the refcount</dd>
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will saturate at UINT_MAX and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <code class="xref c c-func docutils literal"><span class="pre">refcount_inc()</span></code>, or one of its variants, should instead be used to
increment a reference count.</p>
<p><strong>Return</strong></p>
<p>false if the passed refcount is 0, true otherwise</p>
<dl class="function">
<dt id="c.refcount_add_checked">
void <code class="descname">refcount_add_checked</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;i</em>, refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_add_checked" title="Permalink to this definition">¶</a></dt>
<dd><p>add a value to a refcount</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>the value to add to the refcount</dd>
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">atomic_add()</span></code>, but will saturate at UINT_MAX and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <code class="xref c c-func docutils literal"><span class="pre">refcount_inc()</span></code>, or one of its variants, should instead be used to
increment a reference count.</p>
<dl class="function">
<dt id="c.refcount_inc_not_zero_checked">
bool <code class="descname">refcount_inc_not_zero_checked</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc_not_zero_checked" title="Permalink to this definition">¶</a></dt>
<dd><p>increment a refcount unless it is 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount to increment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">atomic_inc_not_zero()</span></code>, but will saturate at UINT_MAX and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller has guaranteed the
object memory to be stable (RCU, etc.). It does provide a control dependency
and thereby orders future stores. See the comment on top.</p>
<p><strong>Return</strong></p>
<p>true if the increment was successful, false otherwise</p>
<dl class="function">
<dt id="c.refcount_inc_checked">
void <code class="descname">refcount_inc_checked</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_inc_checked" title="Permalink to this definition">¶</a></dt>
<dd><p>increment a refcount</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount to increment</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">atomic_inc()</span></code>, but will saturate at UINT_MAX and WARN.</p>
<p>Provides no memory ordering, it is assumed the caller already has a
reference on the object.</p>
<p>Will WARN if the refcount is 0, as this represents a possible use-after-free
condition.</p>
<dl class="function">
<dt id="c.refcount_sub_and_test_checked">
bool <code class="descname">refcount_sub_and_test_checked</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;i</em>, refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_sub_and_test_checked" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract from a refcount and test if it is 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>amount to subtract from the refcount</dd>
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">atomic_dec_and_test()</span></code>, but it will WARN, return false and
ultimately leak on underflow and will fail to decrement when saturated
at UINT_MAX.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> must come after.
See the comment on top.</p>
<p>Use of this function is not recommended for the normal reference counting
use case in which references are taken and released one at a time.  In these
cases, <code class="xref c c-func docutils literal"><span class="pre">refcount_dec()</span></code>, or one of its variants, should instead be used to
decrement a reference count.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
<dl class="function">
<dt id="c.refcount_dec_and_test_checked">
bool <code class="descname">refcount_dec_and_test_checked</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_test_checked" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a refcount and test if it is 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">atomic_dec_and_test()</span></code>, it will WARN on underflow and fail to
decrement when saturated at UINT_MAX.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
<dl class="function">
<dt id="c.refcount_dec_checked">
void <code class="descname">refcount_dec_checked</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_checked" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a refcount</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">atomic_dec()</span></code>, it will WARN on underflow and fail to decrement
when saturated at UINT_MAX.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before.</p>
<dl class="function">
<dt id="c.refcount_dec_if_one">
bool <code class="descname">refcount_dec_if_one</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_if_one" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a refcount if it is 1</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
</dl>
<p><strong>Description</strong></p>
<p>No atomic_t counterpart, it attempts a 1 -&gt; 0 transition and returns the
success thereof.</p>
<p>Like all decrement operations, it provides release memory order and provides
a control dependency.</p>
<p>It can be used like a try-delete operator; this explicit case is provided
and not cmpxchg in generic, because that would allow implementing unsafe
operations.</p>
<p><strong>Return</strong></p>
<p>true if the resulting refcount is 0, false otherwise</p>
<dl class="function">
<dt id="c.refcount_dec_not_one">
bool <code class="descname">refcount_dec_not_one</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_not_one" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement a refcount if it is not 1</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
</dl>
<p><strong>Description</strong></p>
<p>No atomic_t counterpart, it decrements unless the value is 1, in which case
it will return false.</p>
<p>Was often done like: atomic_add_unless(<code class="xref c c-type docutils literal"><span class="pre">var</span></code>, -1, 1)</p>
<p><strong>Return</strong></p>
<p>true if the decrement operation was successful, false otherwise</p>
<dl class="function">
<dt id="c.refcount_dec_and_mutex_lock">
bool <code class="descname">refcount_dec_and_mutex_lock</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em>, struct mutex *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_mutex_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding mutex if able to decrement refcount to 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the mutex to be locked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <a class="reference internal" href="../translations/it_IT/kernel-hacking/locking.html#c.atomic_dec_and_mutex_lock" title="atomic_dec_and_mutex_lock"><code class="xref c c-func docutils literal"><span class="pre">atomic_dec_and_mutex_lock()</span></code></a>, it will WARN on underflow and fail
to decrement when saturated at UINT_MAX.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>true and hold mutex if able to decrement refcount to 0, false</dt>
<dd>otherwise</dd>
</dl>
<dl class="function">
<dt id="c.refcount_dec_and_lock">
bool <code class="descname">refcount_dec_and_lock</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em>, spinlock_t *<em>&nbsp;lock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding spinlock if able to decrement refcount to 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the spinlock to be locked</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to <code class="xref c c-func docutils literal"><span class="pre">atomic_dec_and_lock()</span></code>, it will WARN on underflow and fail to
decrement when saturated at UINT_MAX.</p>
<p>Provides release memory ordering, such that prior loads and stores are done
before, and provides a control dependency such that <code class="xref c c-func docutils literal"><span class="pre">free()</span></code> must come after.
See the comment on top.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>true and hold spinlock if able to decrement refcount to 0, false</dt>
<dd>otherwise</dd>
</dl>
<dl class="function">
<dt id="c.refcount_dec_and_lock_irqsave">
bool <code class="descname">refcount_dec_and_lock_irqsave</code><span class="sig-paren">(</span>refcount_t *<em>&nbsp;r</em>, spinlock_t *<em>&nbsp;lock</em>, unsigned long *<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.refcount_dec_and_lock_irqsave" title="Permalink to this definition">¶</a></dt>
<dd><p>return holding spinlock with disabled interrupts if able to decrement refcount to 0</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount_t</span> <span class="pre">*</span> <span class="pre">r</span></code></dt>
<dd>the refcount</dd>
<dt><code class="docutils literal"><span class="pre">spinlock_t</span> <span class="pre">*</span> <span class="pre">lock</span></code></dt>
<dd>the spinlock to be locked</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">flags</span></code></dt>
<dd>saved IRQ-flags if the is acquired</dd>
</dl>
<p><strong>Description</strong></p>
<p>Same as <a class="reference internal" href="#c.refcount_dec_and_lock" title="refcount_dec_and_lock"><code class="xref c c-func docutils literal"><span class="pre">refcount_dec_and_lock()</span></code></a> above except that the spinlock is acquired
with disabled interupts.</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>true and hold spinlock if able to decrement refcount to 0, false</dt>
<dd>otherwise</dd>
</dl>
</div>
<div class="section" id="atomics">
<h2>Atomics<a class="headerlink" href="#atomics" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.arch_atomic_read">
int <code class="descname">arch_atomic_read</code><span class="sig-paren">(</span>const atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_read" title="Permalink to this definition">¶</a></dt>
<dd><p>read atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically reads the value of <strong>v</strong>.</p>
<dl class="function">
<dt id="c.arch_atomic_set">
void <code class="descname">arch_atomic_set</code><span class="sig-paren">(</span>atomic_t *<em>&nbsp;v</em>, int<em>&nbsp;i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_set" title="Permalink to this definition">¶</a></dt>
<dd><p>set atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>required value</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically sets the value of <strong>v</strong> to <strong>i</strong>.</p>
<dl class="function">
<dt id="c.arch_atomic_add">
void <code class="descname">arch_atomic_add</code><span class="sig-paren">(</span>int<em>&nbsp;i</em>, atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add integer to atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>integer value to add</dd>
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong>.</p>
<dl class="function">
<dt id="c.arch_atomic_sub">
void <code class="descname">arch_atomic_sub</code><span class="sig-paren">(</span>int<em>&nbsp;i</em>, atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract integer from atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>integer value to subtract</dd>
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong>.</p>
<dl class="function">
<dt id="c.arch_atomic_sub_and_test">
bool <code class="descname">arch_atomic_sub_and_test</code><span class="sig-paren">(</span>int<em>&nbsp;i</em>, atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub_and_test" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract value from variable and test result</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>integer value to subtract</dd>
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong> and returns
true if the result is zero, or false for all
other cases.</p>
<dl class="function">
<dt id="c.arch_atomic_inc">
void <code class="descname">arch_atomic_inc</code><span class="sig-paren">(</span>atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>increment atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically increments <strong>v</strong> by 1.</p>
<dl class="function">
<dt id="c.arch_atomic_dec">
void <code class="descname">arch_atomic_dec</code><span class="sig-paren">(</span>atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement atomic variable</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically decrements <strong>v</strong> by 1.</p>
<dl class="function">
<dt id="c.arch_atomic_dec_and_test">
bool <code class="descname">arch_atomic_dec_and_test</code><span class="sig-paren">(</span>atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_dec_and_test" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement and test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically decrements <strong>v</strong> by 1 and
returns true if the result is 0, or false for all other
cases.</p>
<dl class="function">
<dt id="c.arch_atomic_inc_and_test">
bool <code class="descname">arch_atomic_inc_and_test</code><span class="sig-paren">(</span>atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_inc_and_test" title="Permalink to this definition">¶</a></dt>
<dd><p>increment and test</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically increments <strong>v</strong> by 1
and returns true if the result is zero, or false for all
other cases.</p>
<dl class="function">
<dt id="c.arch_atomic_add_negative">
bool <code class="descname">arch_atomic_add_negative</code><span class="sig-paren">(</span>int<em>&nbsp;i</em>, atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>add and test if negative</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>integer value to add</dd>
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong> and returns true
if the result is negative, or false when
result is greater than or equal to zero.</p>
<dl class="function">
<dt id="c.arch_atomic_add_return">
int <code class="descname">arch_atomic_add_return</code><span class="sig-paren">(</span>int<em>&nbsp;i</em>, atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_add_return" title="Permalink to this definition">¶</a></dt>
<dd><p>add integer and return</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>integer value to add</dd>
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically adds <strong>i</strong> to <strong>v</strong> and returns <strong>i</strong> + <strong>v</strong></p>
<dl class="function">
<dt id="c.arch_atomic_sub_return">
int <code class="descname">arch_atomic_sub_return</code><span class="sig-paren">(</span>int<em>&nbsp;i</em>, atomic_t *<em>&nbsp;v</em><span class="sig-paren">)</span><a class="headerlink" href="#c.arch_atomic_sub_return" title="Permalink to this definition">¶</a></dt>
<dd><p>subtract integer and return</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">i</span></code></dt>
<dd>integer value to subtract</dd>
<dt><code class="docutils literal"><span class="pre">atomic_t</span> <span class="pre">*</span> <span class="pre">v</span></code></dt>
<dd>pointer of type atomic_t</dd>
</dl>
<p><strong>Description</strong></p>
<p>Atomically subtracts <strong>i</strong> from <strong>v</strong> and returns <strong>v</strong> - <strong>i</strong></p>
</div>
<div class="section" id="kernel-objects-manipulation">
<h2>Kernel objects manipulation<a class="headerlink" href="#kernel-objects-manipulation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.kobject_get_path">
char * <code class="descname">kobject_get_path</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, gfp_t<em>&nbsp;gfp_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_get_path" title="Permalink to this definition">¶</a></dt>
<dd><p>generate and return the path associated with a given kobj and kset pair.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>kobject in question, with which to build the path</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>the allocation type used to allocate the path</dd>
</dl>
<p><strong>Description</strong></p>
<p>The result must be freed by the caller with <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a>.</p>
<dl class="function">
<dt id="c.kobject_set_name">
int <code class="descname">kobject_set_name</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the name of a kobject</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>struct kobject to set the name of</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string used to build the name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This sets the name of the kobject.  If you have already added the
kobject to the system, you must call <a class="reference internal" href="#c.kobject_rename" title="kobject_rename"><code class="xref c c-func docutils literal"><span class="pre">kobject_rename()</span></code></a> in order to
change the name of the kobject.</p>
<dl class="function">
<dt id="c.kobject_init">
void <code class="descname">kobject_init</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobj_type *<em>&nbsp;ktype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a kobject structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>pointer to the kobject to initialize</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobj_type</span> <span class="pre">*</span> <span class="pre">ktype</span></code></dt>
<dd>pointer to the ktype for this kobject.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will properly initialize a kobject such that it can then
be passed to the <a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal"><span class="pre">kobject_add()</span></code></a> call.</p>
<p>After this function is called, the kobject MUST be cleaned up by a call
to <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal"><span class="pre">kobject_put()</span></code></a>, not by a call to kfree directly to ensure that all of
the memory is cleaned up properly.</p>
<dl class="function">
<dt id="c.kobject_add">
int <code class="descname">kobject_add</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobject *<em>&nbsp;parent</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_add" title="Permalink to this definition">¶</a></dt>
<dd><p>the main kobject add function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>the kobject to add</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>pointer to the parent of the kobject.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format to name the kobject with.</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>The kobject name is set and added to the kobject hierarchy in this
function.</p>
<p>If <strong>parent</strong> is set, then the parent of the <strong>kobj</strong> will be set to it.
If <strong>parent</strong> is NULL, then the parent of the <strong>kobj</strong> will be set to the
kobject associated with the kset assigned to this kobject.  If no kset
is assigned to the kobject, then the kobject will be located in the
root of the sysfs tree.</p>
<p>If this function returns an error, <a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal"><span class="pre">kobject_put()</span></code></a> must be called to
properly clean up the memory associated with the object.
Under no instance should the kobject that is passed to this function
be directly freed with a call to <a class="reference internal" href="../core-api/mm-api.html#c.kfree" title="kfree"><code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code></a>, that can leak memory.</p>
<p>Note, no &#8220;add&#8221; uevent will be created with this call, the caller should set
up all of the necessary sysfs files for the object and then call
<code class="xref c c-func docutils literal"><span class="pre">kobject_uevent()</span></code> with the UEVENT_ADD parameter to ensure that
userspace is properly notified of this kobject&#8217;s creation.</p>
<dl class="function">
<dt id="c.kobject_init_and_add">
int <code class="descname">kobject_init_and_add</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobj_type *<em>&nbsp;ktype</em>, struct kobject *<em>&nbsp;parent</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_init_and_add" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a kobject structure and add it to the kobject hierarchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>pointer to the kobject to initialize</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobj_type</span> <span class="pre">*</span> <span class="pre">ktype</span></code></dt>
<dd>pointer to the ktype for this kobject.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>pointer to the parent of this kobject.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>the name of the kobject.</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function combines the call to <a class="reference internal" href="#c.kobject_init" title="kobject_init"><code class="xref c c-func docutils literal"><span class="pre">kobject_init()</span></code></a> and
<a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal"><span class="pre">kobject_add()</span></code></a>.  The same type of error handling after a call to
<a class="reference internal" href="#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal"><span class="pre">kobject_add()</span></code></a> and kobject lifetime rules are the same here.</p>
<dl class="function">
<dt id="c.kobject_rename">
int <code class="descname">kobject_rename</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, const char *<em>&nbsp;new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_rename" title="Permalink to this definition">¶</a></dt>
<dd><p>change the name of an object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object in question.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">new_name</span></code></dt>
<dd>object&#8217;s new name</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the responsibility of the caller to provide mutual
exclusion between two different calls of kobject_rename
on the same kobject and to ensure that new_name is valid and
won&#8217;t conflict with other kobjects.</p>
<dl class="function">
<dt id="c.kobject_move">
int <code class="descname">kobject_move</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em>, struct kobject *<em>&nbsp;new_parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_move" title="Permalink to this definition">¶</a></dt>
<dd><p>move object to another parent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object in question.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">new_parent</span></code></dt>
<dd>object&#8217;s new parent (can be NULL)</dd>
</dl>
<dl class="function">
<dt id="c.kobject_del">
void <code class="descname">kobject_del</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_del" title="Permalink to this definition">¶</a></dt>
<dd><p>unlink kobject from hierarchy.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
</dl>
<dl class="function">
<dt id="c.kobject_get">
struct kobject * <code class="descname">kobject_get</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_get" title="Permalink to this definition">¶</a></dt>
<dd><p>increment refcount for object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
</dl>
<dl class="function">
<dt id="c.kobject_put">
void <code class="descname">kobject_put</code><span class="sig-paren">(</span>struct kobject *<em>&nbsp;kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_put" title="Permalink to this definition">¶</a></dt>
<dd><p>decrement refcount for object.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">kobj</span></code></dt>
<dd>object.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Decrement the refcount, and if 0, call <code class="xref c c-func docutils literal"><span class="pre">kobject_cleanup()</span></code>.</p>
<dl class="function">
<dt id="c.kobject_create_and_add">
struct kobject * <code class="descname">kobject_create_and_add</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct kobject *<em>&nbsp;parent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kobject_create_and_add" title="Permalink to this definition">¶</a></dt>
<dd><p>create a struct kobject dynamically and register it with sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name for the kobject</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>the parent kobject of this kobject, if any.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a kobject structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
<a class="reference internal" href="#c.kobject_put" title="kobject_put"><code class="xref c c-func docutils literal"><span class="pre">kobject_put()</span></code></a> and the structure will be dynamically freed when
it is no longer being used.</p>
<p>If the kobject was not able to be created, NULL will be returned.</p>
<dl class="function">
<dt id="c.kset_register">
int <code class="descname">kset_register</code><span class="sig-paren">(</span>struct kset *<em>&nbsp;k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_register" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize and add a kset.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*</span> <span class="pre">k</span></code></dt>
<dd>kset.</dd>
</dl>
<dl class="function">
<dt id="c.kset_unregister">
void <code class="descname">kset_unregister</code><span class="sig-paren">(</span>struct kset *<em>&nbsp;k</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a kset.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*</span> <span class="pre">k</span></code></dt>
<dd>kset.</dd>
</dl>
<dl class="function">
<dt id="c.kset_find_obj">
struct kobject * <code class="descname">kset_find_obj</code><span class="sig-paren">(</span>struct kset *<em>&nbsp;kset</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_find_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>search for object in kset.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kset</span> <span class="pre">*</span> <span class="pre">kset</span></code></dt>
<dd>kset we&#8217;re looking in.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>object&#8217;s name.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Lock kset via <strong>kset</strong>-&gt;subsys, and iterate over <strong>kset</strong>-&gt;list,
looking for a matching kobject. If matching object is found
take a reference and return the object.</p>
<dl class="function">
<dt id="c.kset_create_and_add">
struct kset * <code class="descname">kset_create_and_add</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, const struct kset_uevent_ops *<em>&nbsp;uevent_ops</em>, struct kobject *<em>&nbsp;parent_kobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kset_create_and_add" title="Permalink to this definition">¶</a></dt>
<dd><p>create a struct kset dynamically and add it to sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name for the kset</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">kset_uevent_ops</span> <span class="pre">*</span> <span class="pre">uevent_ops</span></code></dt>
<dd>a struct kset_uevent_ops for the kset</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kobject</span> <span class="pre">*</span> <span class="pre">parent_kobj</span></code></dt>
<dd>the parent kobject of this kset, if any.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a kset structure dynamically and registers it
with sysfs.  When you are finished with this structure, call
<a class="reference internal" href="#c.kset_unregister" title="kset_unregister"><code class="xref c c-func docutils literal"><span class="pre">kset_unregister()</span></code></a> and the structure will be dynamically freed when it
is no longer being used.</p>
<p>If the kset was not able to be created, NULL will be returned.</p>
</div>
<div class="section" id="kernel-utility-functions">
<h2>Kernel utility functions<a class="headerlink" href="#kernel-utility-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.REPEAT_BYTE">
<code class="descname">REPEAT_BYTE</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.REPEAT_BYTE" title="Permalink to this definition">¶</a></dt>
<dd><p>repeat the value <strong>x</strong> multiple times as an unsigned long value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>value to repeat</dd>
</dl>
<p><strong>NOTE</strong></p>
<p><strong>x</strong> is not checked for &gt; 0xff; larger values produce odd results.</p>
<dl class="function">
<dt id="c.ARRAY_SIZE">
<code class="descname">ARRAY_SIZE</code><span class="sig-paren">(</span><em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.ARRAY_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>get the number of elements in array <strong>arr</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">arr</span></code></dt>
<dd>array to be sized</dd>
</dl>
<dl class="function">
<dt id="c.round_up">
<code class="descname">round_up</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_up" title="Permalink to this definition">¶</a></dt>
<dd><p>round up to next specified power of 2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>the value to round</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>multiple to round up to (must be a power of 2)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rounds <strong>x</strong> up to next multiple of <strong>y</strong> (which must be a power of 2).
To perform arbitrary rounding up, use <a class="reference internal" href="#c.roundup" title="roundup"><code class="xref c c-func docutils literal"><span class="pre">roundup()</span></code></a> below.</p>
<dl class="function">
<dt id="c.round_down">
<code class="descname">round_down</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.round_down" title="Permalink to this definition">¶</a></dt>
<dd><p>round down to next specified power of 2</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>the value to round</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>multiple to round down to (must be a power of 2)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rounds <strong>x</strong> down to next multiple of <strong>y</strong> (which must be a power of 2).
To perform arbitrary rounding down, use <a class="reference internal" href="#c.rounddown" title="rounddown"><code class="xref c c-func docutils literal"><span class="pre">rounddown()</span></code></a> below.</p>
<dl class="function">
<dt id="c.FIELD_SIZEOF">
<code class="descname">FIELD_SIZEOF</code><span class="sig-paren">(</span><em>t</em>, <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#c.FIELD_SIZEOF" title="Permalink to this definition">¶</a></dt>
<dd><p>get the size of a struct&#8217;s field</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">t</span></code></dt>
<dd>the target struct</dd>
<dt><code class="docutils literal"><span class="pre">f</span></code></dt>
<dd>the target struct&#8217;s field</dd>
</dl>
<p><strong>Return</strong></p>
<p>the size of <strong>f</strong> in the struct definition without having a
declared instance of <strong>t</strong>.</p>
<dl class="function">
<dt id="c.roundup">
<code class="descname">roundup</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.roundup" title="Permalink to this definition">¶</a></dt>
<dd><p>round up to the next specified multiple</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>the value to up</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>multiple to round up to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rounds <strong>x</strong> up to next multiple of <strong>y</strong>. If <strong>y</strong> will always be a power
of 2, consider using the faster <a class="reference internal" href="#c.round_up" title="round_up"><code class="xref c c-func docutils literal"><span class="pre">round_up()</span></code></a>.</p>
<p>The <a href="#id3"><span class="problematic" id="id4">`</span></a>const&#8217; here prevents gcc-3.3 from calling __divdi3</p>
<dl class="function">
<dt id="c.rounddown">
<code class="descname">rounddown</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.rounddown" title="Permalink to this definition">¶</a></dt>
<dd><p>round down to next specified multiple</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>the value to round</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>multiple to round down to</dd>
</dl>
<p><strong>Description</strong></p>
<p>Rounds <strong>x</strong> down to next multiple of <strong>y</strong>. If <strong>y</strong> will always be a power
of 2, consider using the faster <a class="reference internal" href="#c.round_down" title="round_down"><code class="xref c c-func docutils literal"><span class="pre">round_down()</span></code></a>.</p>
<dl class="function">
<dt id="c.upper_32_bits">
<code class="descname">upper_32_bits</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.upper_32_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>return bits 32-63 of a number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>the number we&#8217;re accessing</dd>
</dl>
<p><strong>Description</strong></p>
<p>A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress
the &#8220;right shift count &gt;= width of type&#8221; warning when that quantity is
32-bits.</p>
<dl class="function">
<dt id="c.lower_32_bits">
<code class="descname">lower_32_bits</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.lower_32_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>return bits 0-31 of a number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">n</span></code></dt>
<dd>the number we&#8217;re accessing</dd>
</dl>
<dl class="function">
<dt id="c.might_sleep">
<code class="descname">might_sleep</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.might_sleep" title="Permalink to this definition">¶</a></dt>
<dd><p>annotation for functions that can sleep</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Description</strong></p>
<p>this macro will print a stack trace if it is executed in an atomic
context (spinlock, irq-handler, ...).</p>
<p>This is a useful debugging help to be able to catch problems early and not
be bitten later when the calling function happens to sleep when it is not
supposed to.</p>
<dl class="function">
<dt id="c.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#c.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>return absolute value of an argument</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>the value.  If it is unsigned type, it is converted to signed type first.
char is treated as if it was signed (regardless of whether it really is)
but the macro&#8217;s return type is preserved as char.</dd>
</dl>
<p><strong>Return</strong></p>
<p>an absolute value of x.</p>
<dl class="function">
<dt id="c.reciprocal_scale">
u32 <code class="descname">reciprocal_scale</code><span class="sig-paren">(</span>u32<em>&nbsp;val</em>, u32<em>&nbsp;ep_ro</em><span class="sig-paren">)</span><a class="headerlink" href="#c.reciprocal_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;scale&#8221; a value into range [0, ep_ro)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">val</span></code></dt>
<dd>value</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">ep_ro</span></code></dt>
<dd>right open interval endpoint</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a &#8220;reciprocal multiplication&#8221; in order to &#8220;scale&#8221; a value into
range [0, <strong>ep_ro</strong>), where the upper interval endpoint is right-open.
This is useful, e.g. for accessing a index of an array containing
<strong>ep_ro</strong> elements, for example. Think of it as sort of modulus, only that
the result isn&#8217;t that of modulo. ;) Note that if initial input is a
small value, then result will return 0.</p>
<p><strong>Return</strong></p>
<p>a result based on <strong>val</strong> in interval [0, <strong>ep_ro</strong>).</p>
<dl class="function">
<dt id="c.kstrtoul">
int <code class="descname">kstrtoul</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, unsigned long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtoul" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to an unsigned long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign, but not a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.kstrtol">
int <code class="descname">kstrtol</code><span class="sig-paren">(</span>const char *<em>&nbsp;s</em>, unsigned int<em>&nbsp;base</em>, long *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kstrtol" title="Permalink to this definition">¶</a></dt>
<dd><p>convert a string to a long</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>The start of the string. The string must be null-terminated, and may also
include a single newline before its terminating null. The first character
may also be a plus sign or a minus sign.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">base</span></code></dt>
<dd>The number base to use. The maximum supported base is 16. If base is
given as 0, then the base of the string is automatically detected with the
conventional semantics - If it begins with 0x the number will be parsed as a
hexadecimal (case insensitive), if it otherwise begins with 0, it will be
parsed as an octal number. Otherwise it will be parsed as a decimal.</dd>
<dt><code class="docutils literal"><span class="pre">long</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Where to write the result of the conversion on success.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.
Used as a replacement for the obsolete simple_strtoull. Return code must
be checked.</p>
<dl class="function">
<dt id="c.trace_printk">
<code class="descname">trace_printk</code><span class="sig-paren">(</span><em>fmt</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.trace_printk" title="Permalink to this definition">¶</a></dt>
<dd><p>printf formatting in the ftrace buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">fmt</span></code></dt>
<dd>the printf format for printing</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>__trace_printk is an internal function for <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal"><span class="pre">trace_printk()</span></code></a> and</dt>
<dd>the <strong>ip</strong> is passed in via the <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal"><span class="pre">trace_printk()</span></code></a> macro.</dd>
</dl>
<p>This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.</p>
<p>This is intended as a debugging tool for the developer only.
Please refrain from leaving trace_printks scattered around in
your code. (Extra memory is used for special buffers that are
allocated when <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal"><span class="pre">trace_printk()</span></code></a> is used.)</p>
<p>A little optimization trick is done here. If there&#8217;s only one
argument, there&#8217;s no need to scan the string for printf formats.
The <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal"><span class="pre">trace_puts()</span></code></a> will suffice. But how can we take advantage of
using <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal"><span class="pre">trace_puts()</span></code></a> when <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal"><span class="pre">trace_printk()</span></code></a> has only one argument?
By stringifying the args and checking the size we can tell
whether or not there are args. __stringify((__VA_ARGS__)) will
turn into &#8220;()0&#8221; with a size of 3 when there are no args, anything
else will be bigger. All we need to do is define a string to this,
and then take its size and compare to 3. If it&#8217;s bigger, use
<code class="xref c c-func docutils literal"><span class="pre">do_trace_printk()</span></code> otherwise, optimize it to <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal"><span class="pre">trace_puts()</span></code></a>. Then just
let gcc optimize the rest.</p>
<dl class="function">
<dt id="c.trace_puts">
<code class="descname">trace_puts</code><span class="sig-paren">(</span><em>str</em><span class="sig-paren">)</span><a class="headerlink" href="#c.trace_puts" title="Permalink to this definition">¶</a></dt>
<dd><p>write a string into the ftrace buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">str</span></code></dt>
<dd>the string to record</dd>
</dl>
<p><strong>Note</strong></p>
<dl class="docutils">
<dt>__trace_bputs is an internal function for trace_puts and</dt>
<dd>the <strong>ip</strong> is passed in via the trace_puts macro.</dd>
</dl>
<p>This is similar to <a class="reference internal" href="#c.trace_printk" title="trace_printk"><code class="xref c c-func docutils literal"><span class="pre">trace_printk()</span></code></a> but is made for those really fast
paths that a developer wants the least amount of &#8220;Heisenbug&#8221; effects,
where the processing of the print format is still too much.</p>
<p>This function allows a kernel developer to debug fast path sections
that printk is not appropriate for. By scattering in various
printk like tracing in the code, a developer can quickly see
where problems are occurring.</p>
<p>This is intended as a debugging tool for the developer only.
Please refrain from leaving trace_puts scattered around in
your code. (Extra memory is used for special buffers that are
allocated when <a class="reference internal" href="#c.trace_puts" title="trace_puts"><code class="xref c c-func docutils literal"><span class="pre">trace_puts()</span></code></a> is used.)</p>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>0 if nothing was written, positive # if string was.</dt>
<dd>(1 when __trace_bputs is used, strlen(str) when __trace_puts is used)</dd>
</dl>
<dl class="function">
<dt id="c.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.min" title="Permalink to this definition">¶</a></dt>
<dd><p>return minimum of two values of the same or compatible types</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>first value</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>second value</dd>
</dl>
<dl class="function">
<dt id="c.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.max" title="Permalink to this definition">¶</a></dt>
<dd><p>return maximum of two values of the same or compatible types</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>first value</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>second value</dd>
</dl>
<dl class="function">
<dt id="c.min3">
<code class="descname">min3</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#c.min3" title="Permalink to this definition">¶</a></dt>
<dd><p>return minimum of three values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>first value</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>second value</dd>
<dt><code class="docutils literal"><span class="pre">z</span></code></dt>
<dd>third value</dd>
</dl>
<dl class="function">
<dt id="c.max3">
<code class="descname">max3</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#c.max3" title="Permalink to this definition">¶</a></dt>
<dd><p>return maximum of three values</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>first value</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>second value</dd>
<dt><code class="docutils literal"><span class="pre">z</span></code></dt>
<dd>third value</dd>
</dl>
<dl class="function">
<dt id="c.min_not_zero">
<code class="descname">min_not_zero</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.min_not_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>return the minimum that is _not_ zero, unless both are zero</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>value1</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>value2</dd>
</dl>
<dl class="function">
<dt id="c.clamp">
<code class="descname">clamp</code><span class="sig-paren">(</span><em>val</em>, <em>lo</em>, <em>hi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clamp" title="Permalink to this definition">¶</a></dt>
<dd><p>return a value clamped to a given range with strict typechecking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>current value</dd>
<dt><code class="docutils literal"><span class="pre">lo</span></code></dt>
<dd>lowest allowable value</dd>
<dt><code class="docutils literal"><span class="pre">hi</span></code></dt>
<dd>highest allowable value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro does strict typechecking of <strong>lo</strong>/<strong>hi</strong> to make sure they are of the
same type as <strong>val</strong>.  See the unnecessary pointer comparisons.</p>
<dl class="function">
<dt id="c.min_t">
<code class="descname">min_t</code><span class="sig-paren">(</span><em>type</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.min_t" title="Permalink to this definition">¶</a></dt>
<dd><p>return minimum of two values, using the specified type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>data type to use</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>first value</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>second value</dd>
</dl>
<dl class="function">
<dt id="c.max_t">
<code class="descname">max_t</code><span class="sig-paren">(</span><em>type</em>, <em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#c.max_t" title="Permalink to this definition">¶</a></dt>
<dd><p>return maximum of two values, using the specified type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>data type to use</dd>
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>first value</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>second value</dd>
</dl>
<dl class="function">
<dt id="c.clamp_t">
<code class="descname">clamp_t</code><span class="sig-paren">(</span><em>type</em>, <em>val</em>, <em>lo</em>, <em>hi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clamp_t" title="Permalink to this definition">¶</a></dt>
<dd><p>return a value clamped to a given range using a given type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of variable to use</dd>
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>current value</dd>
<dt><code class="docutils literal"><span class="pre">lo</span></code></dt>
<dd>minimum allowable value</dd>
<dt><code class="docutils literal"><span class="pre">hi</span></code></dt>
<dd>maximum allowable value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro does no typechecking and uses temporary variables of type
<strong>type</strong> to make all the comparisons.</p>
<dl class="function">
<dt id="c.clamp_val">
<code class="descname">clamp_val</code><span class="sig-paren">(</span><em>val</em>, <em>lo</em>, <em>hi</em><span class="sig-paren">)</span><a class="headerlink" href="#c.clamp_val" title="Permalink to this definition">¶</a></dt>
<dd><p>return a value clamped to a given range using val&#8217;s type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">val</span></code></dt>
<dd>current value</dd>
<dt><code class="docutils literal"><span class="pre">lo</span></code></dt>
<dd>minimum allowable value</dd>
<dt><code class="docutils literal"><span class="pre">hi</span></code></dt>
<dd>maximum allowable value</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro does no typechecking and uses temporary variables of whatever
type the input argument <strong>val</strong> is.  This is useful when <strong>val</strong> is an unsigned
type and <strong>lo</strong> and <strong>hi</strong> are literals that will otherwise be assigned a signed
integer type.</p>
<dl class="function">
<dt id="c.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>swap values of <strong>a</strong> and <strong>b</strong></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">a</span></code></dt>
<dd>first value</dd>
<dt><code class="docutils literal"><span class="pre">b</span></code></dt>
<dd>second value</dd>
</dl>
<dl class="function">
<dt id="c.container_of">
<code class="descname">container_of</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.container_of" title="Permalink to this definition">¶</a></dt>
<dd><p>cast a member of a structure out to the containing structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the pointer to the member.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the container struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the member within the struct.</dd>
</dl>
<dl class="function">
<dt id="c.container_of_safe">
<code class="descname">container_of_safe</code><span class="sig-paren">(</span><em>ptr</em>, <em>type</em>, <em>member</em><span class="sig-paren">)</span><a class="headerlink" href="#c.container_of_safe" title="Permalink to this definition">¶</a></dt>
<dd><p>cast a member of a structure out to the containing structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ptr</span></code></dt>
<dd>the pointer to the member.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>the type of the container struct this is embedded in.</dd>
<dt><code class="docutils literal"><span class="pre">member</span></code></dt>
<dd>the name of the member within the struct.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.</p>
<dl class="function">
<dt id="c.printk">
__visible int <code class="descname">printk</code><span class="sig-paren">(</span>const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.printk" title="Permalink to this definition">¶</a></dt>
<dd><p>print a kernel message</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is <a class="reference internal" href="#c.printk" title="printk"><code class="xref c c-func docutils literal"><span class="pre">printk()</span></code></a>. It can be called from any context. We want it to work.</p>
<p>We try to grab the console_lock. If we succeed, it&#8217;s easy - we log the
output and call the console drivers.  If we fail to get the semaphore, we
place the output into the log buffer and return. The current holder of
the console_sem will notice the new output in <a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal"><span class="pre">console_unlock()</span></code></a>; and will
send it to the consoles before releasing the lock.</p>
<p>One effect of this deferred printing is that code which calls <a class="reference internal" href="#c.printk" title="printk"><code class="xref c c-func docutils literal"><span class="pre">printk()</span></code></a> and
then changes console_loglevel may break. This is because console_loglevel
is inspected when the actual printing occurs.</p>
<p>See also:
printf(3)</p>
<p>See the <a class="reference internal" href="../core-api/kernel-api.html#c.vsnprintf" title="vsnprintf"><code class="xref c c-func docutils literal"><span class="pre">vsnprintf()</span></code></a> documentation for format string extensions over C99.</p>
<dl class="function">
<dt id="c.console_lock">
void <code class="descname">console_lock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>lock the console system for exclusive use.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Acquires a lock which guarantees that the caller has
exclusive access to the console system and the console_drivers list.</p>
<p>Can sleep, returns nothing.</p>
<dl class="function">
<dt id="c.console_trylock">
int <code class="descname">console_trylock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_trylock" title="Permalink to this definition">¶</a></dt>
<dd><p>try to lock the console system for exclusive use.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Try to acquire a lock which guarantees that the caller has exclusive
access to the console system and the console_drivers list.</p>
<p>returns 1 on success, and 0 on failure to acquire the lock.</p>
<dl class="function">
<dt id="c.console_unlock">
void <code class="descname">console_unlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>unlock the console system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Releases the console_lock which the caller holds on the console system
and the console driver list.</p>
<p>While the console_lock was held, console output may have been buffered
by <a class="reference internal" href="#c.printk" title="printk"><code class="xref c c-func docutils literal"><span class="pre">printk()</span></code></a>.  If this is the case, <a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal"><span class="pre">console_unlock()</span></code></a>; emits
the output prior to releasing the lock.</p>
<p>If there is output waiting, we wake /dev/kmsg and <code class="xref c c-func docutils literal"><span class="pre">syslog()</span></code> users.</p>
<p><a class="reference internal" href="#c.console_unlock" title="console_unlock"><code class="xref c c-func docutils literal"><span class="pre">console_unlock()</span></code></a>; may be called from any context.</p>
<dl class="function">
<dt id="c.console_conditional_schedule">
void <code class="descname">console_conditional_schedule</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.console_conditional_schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>yield the CPU if required</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the console code is currently allowed to sleep, and
if this CPU should yield the CPU to another task, do
so here.</p>
<p>Must be called within <a class="reference internal" href="#c.console_lock" title="console_lock"><code class="xref c c-func docutils literal"><span class="pre">console_lock()</span></code></a>;.</p>
<dl class="function">
<dt id="c.printk_timed_ratelimit">
bool <code class="descname">printk_timed_ratelimit</code><span class="sig-paren">(</span>unsigned long *<em>&nbsp;caller_jiffies</em>, unsigned int<em>&nbsp;interval_msecs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.printk_timed_ratelimit" title="Permalink to this definition">¶</a></dt>
<dd><p>caller-controlled printk ratelimiting</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">*</span> <span class="pre">caller_jiffies</span></code></dt>
<dd>pointer to caller&#8217;s state</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">interval_msecs</span></code></dt>
<dd>minimum interval between prints</dd>
</dl>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.printk_timed_ratelimit" title="printk_timed_ratelimit"><code class="xref c c-func docutils literal"><span class="pre">printk_timed_ratelimit()</span></code></a> returns true if more than <strong>interval_msecs</strong>
milliseconds have elapsed since the last time <a class="reference internal" href="#c.printk_timed_ratelimit" title="printk_timed_ratelimit"><code class="xref c c-func docutils literal"><span class="pre">printk_timed_ratelimit()</span></code></a>
returned true.</p>
<dl class="function">
<dt id="c.kmsg_dump_register">
int <code class="descname">kmsg_dump_register</code><span class="sig-paren">(</span>struct kmsg_dumper *<em>&nbsp;dumper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a kernel log dumper.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*</span> <span class="pre">dumper</span></code></dt>
<dd>pointer to the kmsg_dumper structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Adds a kernel log dumper to the system. The dump callback in the
structure will be called when the kernel oopses or panics and must be
set. Returns zero on success and <code class="docutils literal"><span class="pre">-EINVAL</span></code> or <code class="docutils literal"><span class="pre">-EBUSY</span></code> otherwise.</p>
<dl class="function">
<dt id="c.kmsg_dump_unregister">
int <code class="descname">kmsg_dump_unregister</code><span class="sig-paren">(</span>struct kmsg_dumper *<em>&nbsp;dumper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a kmsg dumper.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*</span> <span class="pre">dumper</span></code></dt>
<dd>pointer to the kmsg_dumper structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes a dump device from the system. Returns zero on success and
<code class="docutils literal"><span class="pre">-EINVAL</span></code> otherwise.</p>
<dl class="function">
<dt id="c.kmsg_dump_get_line">
bool <code class="descname">kmsg_dump_get_line</code><span class="sig-paren">(</span>struct kmsg_dumper *<em>&nbsp;dumper</em>, bool<em>&nbsp;syslog</em>, char *<em>&nbsp;line</em>, size_t<em>&nbsp;size</em>, size_t *<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_get_line" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve one kmsg log line</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*</span> <span class="pre">dumper</span></code></dt>
<dd>registered kmsg dumper</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">syslog</span></code></dt>
<dd>include the &#8220;&lt;4&gt;&#8221; prefixes</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">line</span></code></dt>
<dd>buffer to copy the line to</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>maximum size of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">len</span></code></dt>
<dd>length of line placed into buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start at the beginning of the kmsg buffer, with the oldest kmsg
record, and copy one record into the provided buffer.</p>
<p>Consecutive calls will return the next available record moving
towards the end of the buffer with the youngest messages.</p>
<p>A return value of FALSE indicates that there are no more records to
read.</p>
<dl class="function">
<dt id="c.kmsg_dump_get_buffer">
bool <code class="descname">kmsg_dump_get_buffer</code><span class="sig-paren">(</span>struct kmsg_dumper *<em>&nbsp;dumper</em>, bool<em>&nbsp;syslog</em>, char *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em>, size_t *<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_get_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>copy kmsg log lines</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*</span> <span class="pre">dumper</span></code></dt>
<dd>registered kmsg dumper</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">syslog</span></code></dt>
<dd>include the &#8220;&lt;4&gt;&#8221; prefixes</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>buffer to copy the line to</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>maximum size of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">len</span></code></dt>
<dd>length of line placed into buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Start at the end of the kmsg buffer and fill the provided buffer
with as many of the the <em>youngest</em> kmsg records that fit into it.
If the buffer is large enough, all available kmsg records will be
copied with a single call.</p>
<p>Consecutive calls will fill the buffer with the next block of
available older records, not including the earlier retrieved ones.</p>
<p>A return value of FALSE indicates that there are no more records to
read.</p>
<dl class="function">
<dt id="c.kmsg_dump_rewind">
void <code class="descname">kmsg_dump_rewind</code><span class="sig-paren">(</span>struct kmsg_dumper *<em>&nbsp;dumper</em><span class="sig-paren">)</span><a class="headerlink" href="#c.kmsg_dump_rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the interator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">kmsg_dumper</span> <span class="pre">*</span> <span class="pre">dumper</span></code></dt>
<dd>registered kmsg dumper</dd>
</dl>
<p><strong>Description</strong></p>
<p>Reset the dumper&#8217;s iterator so that <a class="reference internal" href="#c.kmsg_dump_get_line" title="kmsg_dump_get_line"><code class="xref c c-func docutils literal"><span class="pre">kmsg_dump_get_line()</span></code></a> and
<a class="reference internal" href="#c.kmsg_dump_get_buffer" title="kmsg_dump_get_buffer"><code class="xref c c-func docutils literal"><span class="pre">kmsg_dump_get_buffer()</span></code></a> can be called again and used multiple
times within the same dumper.:c:func:<cite>dump()</cite> callback.</p>
<dl class="function">
<dt id="c.panic">
void <code class="descname">panic</code><span class="sig-paren">(</span>const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.panic" title="Permalink to this definition">¶</a></dt>
<dd><p>halt the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The text string to print</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Display a message, then perform cleanups.</p>
<p>This function never returns.</p>
</div></blockquote>
<dl class="function">
<dt id="c.add_taint">
void <code class="descname">add_taint</code><span class="sig-paren">(</span>unsigned<em>&nbsp;flag</em>, enum lockdep_ok<em>&nbsp;lockdep_ok</em><span class="sig-paren">)</span><a class="headerlink" href="#c.add_taint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">flag</span></code></dt>
<dd>one of the TAINT_* constants.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">lockdep_ok</span> <span class="pre">lockdep_ok</span></code></dt>
<dd>whether lock debugging is still OK.</dd>
</dl>
<p><strong>Description</strong></p>
<p>If something bad has gone wrong, you&#8217;ll want <strong>lockdebug_ok</strong> = false, but for
some notewortht-but-not-corrupting cases, it can be set to true.</p>
<dl class="function">
<dt id="c.rcu_is_watching">
bool notrace <code class="descname">rcu_is_watching</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_is_watching" title="Permalink to this definition">¶</a></dt>
<dd><p>see if RCU thinks that the current CPU is idle</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return true if RCU is watching the running CPU, which means that this
CPU can safely enter RCU read-side critical sections.  In other words,
if the current CPU is in its idle loop and is neither in an interrupt
or NMI handler, return true.</p>
<dl class="function">
<dt id="c.call_rcu_sched">
void <code class="descname">call_rcu_sched</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation after sched grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a> assumes
that the read-side critical sections end on enabling of preemption
or on voluntary preemption.
RCU read-side critical sections are delimited by:</p>
<ul class="simple">
<li><a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code>, OR</li>
<li>anything that disables preemption.</li>
</ul>
<blockquote>
<div>These may be nested.</div></blockquote>
<p>See the description of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.call_rcu_bh">
void <code class="descname">call_rcu_bh</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation after a quicker grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> assumes
that the read-side critical sections end on completion of a softirq
handler. This means that read-side critical sections in process
context must not be interrupted by softirqs. This interface is to be
used when most of the read-side critical sections are in softirq context.
RCU read-side critical sections are delimited by:</p>
<ul class="simple">
<li><a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and  <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>, if in interrupt context, OR</li>
<li><a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code>, if in process context.</li>
</ul>
<p>These may be nested.</p>
<p>See the description of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.synchronize_sched">
void <code class="descname">synchronize_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu-sched grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu-sched
grace period has elapsed, in other words after all currently executing
rcu-sched read-side critical sections have completed.   These read-side
critical sections are delimited by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a> and
<code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_sched()</span></code>, and may be nested.  Note that <code class="xref c c-func docutils literal"><span class="pre">preempt_disable()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">local_irq_disable()</span></code>, and so on may be used in place of
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_sched" title="rcu_read_lock_sched"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_sched()</span></code></a>.</p>
<p>This means that all preempt_disable code sequences, including NMI and
non-threaded hardware-interrupt handlers, in progress on entry will
have completed before this primitive returns.  However, this does not
guarantee that softirq handlers will have completed, since in some
kernels, these handlers can run in process context, and can block.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-sched read-side critical section whose beginning
preceded the call to <a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>.  In addition, each CPU having
an RCU read-side critical section that extends beyond the return from
<a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> is guaranteed to have executed a full memory barrier
after the beginning of <a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> and before the beginning of
that RCU read-side critical section.  Note that these guarantees include
CPUs that are offline, idle, or executing in user mode, as well as CPUs
that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> &#8211; even if CPU A and CPU B are the same CPU (but
again only if the system has more than one CPU).</p>
<dl class="function">
<dt id="c.synchronize_rcu_bh">
void <code class="descname">synchronize_rcu_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu_bh grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu_bh grace
period has elapsed, in other words after all currently executing rcu_bh
read-side critical sections have completed.  RCU read-side critical
sections are delimited by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a> and <code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock_bh()</span></code>,
and may be nested.</p>
<p>See the description of <a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> for more detailed information
on memory ordering guarantees.</p>
<dl class="function">
<dt id="c.get_state_synchronize_rcu">
unsigned long <code class="descname">get_state_synchronize_rcu</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Snapshot current RCU state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="#c.cond_synchronize_rcu" title="cond_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">cond_synchronize_rcu()</span></code></a>
to determine whether or not a full grace period has elapsed in the
meantime.</p>
<dl class="function">
<dt id="c.cond_synchronize_rcu">
void <code class="descname">cond_synchronize_rcu</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;oldstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally wait for an RCU grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt>
<dd>return value from earlier call to <a class="reference internal" href="#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_rcu()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU grace period has elapsed since the earlier call to
<a class="reference internal" href="#c.get_state_synchronize_rcu" title="get_state_synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_rcu()</span></code></a>, just return.  Otherwise, invoke
<a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.</p>
<dl class="function">
<dt id="c.get_state_synchronize_sched">
unsigned long <code class="descname">get_state_synchronize_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.get_state_synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Snapshot current RCU-sched state</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a cookie that is used by a later call to <a class="reference internal" href="#c.cond_synchronize_sched" title="cond_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">cond_synchronize_sched()</span></code></a>
to determine whether or not a full grace period has elapsed in the
meantime.</p>
<dl class="function">
<dt id="c.cond_synchronize_sched">
void <code class="descname">cond_synchronize_sched</code><span class="sig-paren">(</span>unsigned long<em>&nbsp;oldstate</em><span class="sig-paren">)</span><a class="headerlink" href="#c.cond_synchronize_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Conditionally wait for an RCU-sched grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">oldstate</span></code></dt>
<dd>return value from earlier call to <a class="reference internal" href="#c.get_state_synchronize_sched" title="get_state_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_sched()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>If a full RCU-sched grace period has elapsed since the earlier call to
<a class="reference internal" href="#c.get_state_synchronize_sched" title="get_state_synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">get_state_synchronize_sched()</span></code></a>, just return.  Otherwise, invoke
<a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> to wait for a full grace period.</p>
<p>Yes, this function does not take counter wrap into account.  But
counter wrap is harmless.  If the counter wraps, we have waited for
more than 2 billion grace periods (and way more on a 64-bit system!),
so waiting for one additional grace period should be just fine.</p>
<dl class="function">
<dt id="c.rcu_barrier_bh">
void <code class="descname">rcu_barrier_bh</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_bh" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="#c.call_rcu_bh" title="call_rcu_bh"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_bh()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.rcu_barrier_sched">
void <code class="descname">rcu_barrier_sched</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_sched" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="#c.call_rcu_sched" title="call_rcu_sched"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_sched()</span></code></a> callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<dl class="function">
<dt id="c.call_rcu">
void <code class="descname">call_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU callback for invocation after a grace period.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all pre-existing RCU read-side
critical sections have completed.  However, the callback function
might well execute concurrently with RCU read-side critical sections
that started after <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> was invoked.  RCU read-side critical
sections are delimited by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>,
and may be nested.</p>
<p>Note that all CPUs must agree that the grace period extended beyond
all pre-existing RCU read-side critical section.  On systems with more
than one CPU, this means that when &#8220;<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>&#8221; is invoked, each CPU is
guaranteed to have executed a full memory barrier since the end of its
last RCU read-side critical section whose beginning preceded the call
to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a>.  It also means that each CPU executing an RCU read-side
critical section that continues beyond the start of &#8220;<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>&#8221; must have
executed a memory barrier after the <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> but before the beginning
of that RCU read-side critical section.  Note that these guarantees
include CPUs that are offline, idle, or executing in user mode, as
well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> and CPU B invoked the
resulting RCU callback function &#8220;<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>&#8221;, then both CPU A and CPU B are
guaranteed to execute a full memory barrier during the time interval
between the call to <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> and the invocation of &#8220;<code class="xref c c-func docutils literal"><span class="pre">func()</span></code>&#8221; &#8211; even
if CPU A and CPU B are the same CPU (but again only if the system has
more than one CPU).</p>
<dl class="function">
<dt id="c.synchronize_rcu">
void <code class="descname">synchronize_rcu</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until a grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full grace
period has elapsed, in other words after all currently executing RCU
read-side critical sections have completed.  Note, however, that
upon return from <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a>, the caller might well be executing
concurrently with new RCU read-side critical sections that began while
<a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> was waiting.  RCU read-side critical sections are
delimited by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a>, and may be nested.</p>
<p>See the description of <a class="reference internal" href="#c.synchronize_sched" title="synchronize_sched"><code class="xref c c-func docutils literal"><span class="pre">synchronize_sched()</span></code></a> for more detailed
information on memory-ordering guarantees.  However, please note
that -only- the memory-ordering guarantees apply.  For example,
<a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is -not- guaranteed to wait on things like code
protected by <code class="xref c c-func docutils literal"><span class="pre">preempt_disable()</span></code>, instead, <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> is -only-
guaranteed to wait on RCU read-side critical sections, that is, sections
of code protected by <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.</p>
<dl class="function">
<dt id="c.rcu_barrier">
void <code class="descname">rcu_barrier</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until all in-flight <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> callbacks complete.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this primitive does not necessarily wait for an RCU grace period
to complete.  For example, if there are no RCU callbacks queued anywhere
in the system, then <a class="reference internal" href="#c.rcu_barrier" title="rcu_barrier"><code class="xref c c-func docutils literal"><span class="pre">rcu_barrier()</span></code></a> is within its rights to return
immediately, without waiting for anything, much less an RCU grace period.</p>
<dl class="function">
<dt id="c.rcu_read_lock_sched_held">
int <code class="descname">rcu_read_lock_sched_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_sched_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU-sched read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an
RCU-sched read-side critical section.  In absence of
CONFIG_DEBUG_LOCK_ALLOC, this assumes we are in an RCU-sched read-side
critical section unless it can prove otherwise.  Note that disabling
of preemption (including disabling irqs) counts as an RCU-sched
read-side critical section.  This is useful for debug checks in functions
that required that they be called within an RCU-sched read-side
critical section.</p>
<p>Check <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that if the CPU is in the idle loop from an RCU point of
view (ie: that we are in the section between <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_idle_enter" title="rcu_idle_enter"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_enter()</span></code></a> and
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_idle_exit" title="rcu_idle_exit"><code class="xref c c-func docutils literal"><span class="pre">rcu_idle_exit()</span></code></a>) then <a class="reference internal" href="#c.rcu_read_lock_held" title="rcu_read_lock_held"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_held()</span></code></a> returns false even if the CPU
did an <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>.  The reason for this is that RCU ignores CPUs
that are in such a section, considering these as in extended quiescent
state, so such a CPU is effectively never in an RCU read-side critical
section regardless of what RCU primitives it invokes.  This state of
affairs is required &#8212; we need to keep an RCU-free window in idle
where the CPU may possibly enter into low power mode. This way we can
notice an extended quiescent state to other CPUs that started a grace
period. Otherwise we would delay any grace period as long as we run in
the idle task.</p>
<p>Similarly, we avoid claiming an SRCU read lock held if the current
CPU is offline.</p>
<dl class="function">
<dt id="c.rcu_expedite_gp">
void <code class="descname">rcu_expedite_gp</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_expedite_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Expedite future RCU grace periods</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>After a call to this function, future calls to <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> and
friends act as the corresponding <a class="reference internal" href="../core-api/kernel-api.html#c.synchronize_rcu_expedited" title="synchronize_rcu_expedited"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_expedited()</span></code></a> function
had instead been called.</p>
<dl class="function">
<dt id="c.rcu_unexpedite_gp">
void <code class="descname">rcu_unexpedite_gp</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_unexpedite_gp" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel prior <a class="reference internal" href="#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a> invocation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undo a prior call to <a class="reference internal" href="#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a>.  If all prior calls to
<a class="reference internal" href="#c.rcu_expedite_gp" title="rcu_expedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_expedite_gp()</span></code></a> are undone by a subsequent call to <a class="reference internal" href="#c.rcu_unexpedite_gp" title="rcu_unexpedite_gp"><code class="xref c c-func docutils literal"><span class="pre">rcu_unexpedite_gp()</span></code></a>,
and if the rcu_expedited sysfs/boot parameter is not set, then all
subsequent calls to <a class="reference internal" href="#c.synchronize_rcu" title="synchronize_rcu"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu()</span></code></a> and friends will return to
their normal non-expedited behavior.</p>
<dl class="function">
<dt id="c.rcu_read_lock_held">
int <code class="descname">rcu_read_lock_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>If CONFIG_DEBUG_LOCK_ALLOC is selected, returns nonzero iff in an RCU
read-side critical section.  In absence of CONFIG_DEBUG_LOCK_ALLOC,
this assumes we are in an RCU read-side critical section unless it can
prove otherwise.  This is useful for debug checks in functions that
require that they be called within an RCU read-side critical section.</p>
<p>Checks <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot
and while lockdep is disabled.</p>
<p>Note that <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and the matching <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> must
occur in the same context, for example, it is illegal to invoke
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> in process context if the matching <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a>
was invoked from within an irq handler.</p>
<p>Note that <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
<dl class="function">
<dt id="c.rcu_read_lock_bh_held">
int <code class="descname">rcu_read_lock_bh_held</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_read_lock_bh_held" title="Permalink to this definition">¶</a></dt>
<dd><p>might we be in RCU-bh read-side critical section?</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check for bottom half being disabled, which covers both the
CONFIG_PROVE_RCU and not cases.  Note that if someone uses
<a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock_bh" title="rcu_read_lock_bh"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock_bh()</span></code></a>, but then later enables BH, lockdep (if enabled)
will show the situation.  This is useful for debug checks in functions
that require that they be called within an RCU read-side critical
section.</p>
<p>Check <code class="xref c c-func docutils literal"><span class="pre">debug_lockdep_rcu_enabled()</span></code> to prevent false positives during boot.</p>
<p>Note that <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> is disallowed if the CPU is either idle or
offline from an RCU perspective, so check for those as well.</p>
<dl class="function">
<dt id="c.wakeme_after_rcu">
void <code class="descname">wakeme_after_rcu</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.wakeme_after_rcu" title="Permalink to this definition">¶</a></dt>
<dd><p>Callback function to awaken a task after grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>Pointer to rcu_head member within rcu_synchronize structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Awaken the corresponding task now that a grace period has elapsed.</p>
<dl class="function">
<dt id="c.init_rcu_head_on_stack">
void <code class="descname">init_rcu_head_on_stack</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.init_rcu_head_on_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize on-stack rcu_head for debugobjects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to rcu_head structure to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects of a new rcu_head structure that
has been allocated as an auto variable on the stack.  This function
is not required for rcu_head structures that are statically defined or
that are dynamically allocated on the heap.  This function has no
effect for !CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
<dl class="function">
<dt id="c.destroy_rcu_head_on_stack">
void <code class="descname">destroy_rcu_head_on_stack</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;head</em><span class="sig-paren">)</span><a class="headerlink" href="#c.destroy_rcu_head_on_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>destroy on-stack rcu_head for debugobjects</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">head</span></code></dt>
<dd>pointer to rcu_head structure to be initialized</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function informs debugobjects that an on-stack rcu_head structure
is about to go out of scope.  As with <a class="reference internal" href="#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this
function is not required for rcu_head structures that are statically
defined or that are dynamically allocated on the heap.  Also as with
<a class="reference internal" href="#c.init_rcu_head_on_stack" title="init_rcu_head_on_stack"><code class="xref c c-func docutils literal"><span class="pre">init_rcu_head_on_stack()</span></code></a>, this function has no effect for
!CONFIG_DEBUG_OBJECTS_RCU_HEAD kernel builds.</p>
<dl class="function">
<dt id="c.call_rcu_tasks">
void <code class="descname">call_rcu_tasks</code><span class="sig-paren">(</span>struct rcu_head *<em>&nbsp;rhp</em>, rcu_callback_t<em>&nbsp;func</em><span class="sig-paren">)</span><a class="headerlink" href="#c.call_rcu_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue an RCU for invocation task-based grace period</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">rcu_head</span> <span class="pre">*</span> <span class="pre">rhp</span></code></dt>
<dd>structure to be used for queueing the RCU updates.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_callback_t</span> <span class="pre">func</span></code></dt>
<dd>actual callback function to be invoked after the grace period</dd>
</dl>
<p><strong>Description</strong></p>
<p>The callback function will be invoked some time after a full grace
period elapses, in other words after all currently executing RCU
read-side critical sections have completed. <a class="reference internal" href="#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_tasks()</span></code></a> assumes
that the read-side critical sections end at a voluntary context
switch (not a preemption!), <code class="xref c c-func docutils literal"><span class="pre">cond_resched_rcu_qs()</span></code>, entry into idle,
or transition to usermode execution.  As such, there are no read-side
primitives analogous to <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_lock" title="rcu_read_lock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_lock()</span></code></a> and <a class="reference internal" href="../core-api/kernel-api.html#c.rcu_read_unlock" title="rcu_read_unlock"><code class="xref c c-func docutils literal"><span class="pre">rcu_read_unlock()</span></code></a> because
this primitive is intended to determine that all tasks have passed
through a safe state, not so much for data-strcuture synchronization.</p>
<p>See the description of <a class="reference internal" href="#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal"><span class="pre">call_rcu()</span></code></a> for more detailed information on
memory ordering guarantees.</p>
<dl class="function">
<dt id="c.synchronize_rcu_tasks">
void <code class="descname">synchronize_rcu_tasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.synchronize_rcu_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until an rcu-tasks grace period has elapsed.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Control will return to the caller some time after a full rcu-tasks
grace period has elapsed, in other words after all currently
executing rcu-tasks read-side critical sections have elapsed.  These
read-side critical sections are delimited by calls to <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code>,
<a class="reference internal" href="../core-api/kernel-api.html#c.cond_resched_tasks_rcu_qs" title="cond_resched_tasks_rcu_qs"><code class="xref c c-func docutils literal"><span class="pre">cond_resched_tasks_rcu_qs()</span></code></a>, idle execution, userspace execution, calls
to <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>, and (in theory, anyway) <code class="xref c c-func docutils literal"><span class="pre">cond_resched()</span></code>.</p>
<p>This is a very specialized primitive, intended only for a few uses in
tracing and other situations requiring manipulation of function
preambles and profiling hooks.  The <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> function
is not (yet) intended for heavy use from multiple CPUs.</p>
<p>Note that this guarantee implies further memory-ordering guarantees.
On systems with more than one CPU, when <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> returns,
each CPU is guaranteed to have executed a full memory barrier since the
end of its last RCU-tasks read-side critical section whose beginning
preceded the call to <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>.  In addition, each CPU
having an RCU-tasks read-side critical section that extends beyond
the return from <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> is guaranteed to have executed
a full memory barrier after the beginning of <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>
and before the beginning of that RCU-tasks read-side critical section.
Note that these guarantees include CPUs that are offline, idle, or
executing in user mode, as well as CPUs that are executing in the kernel.</p>
<p>Furthermore, if CPU A invoked <a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a>, which returned
to its caller on CPU B, then both CPU A and CPU B are guaranteed
to have executed a full memory barrier during the execution of
<a class="reference internal" href="#c.synchronize_rcu_tasks" title="synchronize_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">synchronize_rcu_tasks()</span></code></a> &#8211; even if CPU A and CPU B are the same CPU
(but again only if the system has more than one CPU).</p>
<dl class="function">
<dt id="c.rcu_barrier_tasks">
void <code class="descname">rcu_barrier_tasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.rcu_barrier_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for in-flight <a class="reference internal" href="#c.call_rcu_tasks" title="call_rcu_tasks"><code class="xref c c-func docutils literal"><span class="pre">call_rcu_tasks()</span></code></a> callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Although the current implementation is guaranteed to wait, it is not
obligated to, for example, if there are no pending callbacks.</p>
</div>
<div class="section" id="device-resource-management">
<h2>Device Resource Management<a class="headerlink" href="#device-resource-management" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.devres_alloc_node">
void * <code class="descname">devres_alloc_node</code><span class="sig-paren">(</span>dr_release_t<em>&nbsp;release</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp</em>, int<em>&nbsp;nid</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_alloc_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate device resource data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt>
<dd>Release function devres will be associated with</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Allocation size</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Allocation flags</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nid</span></code></dt>
<dd>NUMA node</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate devres of <strong>size</strong> bytes.  The allocated area is zeroed, then
associated with <strong>release</strong>.  The returned pointer can be passed to
other devres_*() functions.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated devres on success, NULL on failure.</p>
<dl class="function">
<dt id="c.devres_for_each_res">
void <code class="descname">devres_for_each_res</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, dr_release_t<em>&nbsp;release</em>, dr_match_t<em>&nbsp;match</em>, void *<em>&nbsp;match_data</em>, void (*fn) (struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a><em>&nbsp;*</em>, void<em>&nbsp;*</em>, void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_for_each_res" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to iterate resource from</dd>
<dt><code class="docutils literal"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt>
<dd>Look for resources associated with this release function</dd>
<dt><code class="docutils literal"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt>
<dd>Match function (optional)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">match_data</span></code></dt>
<dd>Data for the match function</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>Function to be called for each matched resource.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data for <strong>fn</strong>, the 3rd parameter of <strong>fn</strong></dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <strong>fn</strong> for each devres of <strong>dev</strong> which is associated with <strong>release</strong>
and for which <strong>match</strong> returns 1.</p>
<p><strong>Return</strong></p>
<blockquote>
<div>void</div></blockquote>
<dl class="function">
<dt id="c.devres_free">
void <code class="descname">devres_free</code><span class="sig-paren">(</span>void *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_free" title="Permalink to this definition">¶</a></dt>
<dd><p>Free device resource data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Pointer to devres data to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free devres created with <code class="xref c c-func docutils literal"><span class="pre">devres_alloc()</span></code>.</p>
<dl class="function">
<dt id="c.devres_add">
void <code class="descname">devres_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;res</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Register device resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to add resource to</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>Resource to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Register devres <strong>res</strong> to <strong>dev</strong>.  <strong>res</strong> should have been allocated
using <code class="xref c c-func docutils literal"><span class="pre">devres_alloc()</span></code>.  On driver detach, the associated release
function will be invoked and devres will be freed automatically.</p>
<dl class="function">
<dt id="c.devres_find">
void * <code class="descname">devres_find</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, dr_release_t<em>&nbsp;release</em>, dr_match_t<em>&nbsp;match</em>, void *<em>&nbsp;match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_find" title="Permalink to this definition">¶</a></dt>
<dd><p>Find device resource</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to lookup resource from</dd>
<dt><code class="docutils literal"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt>
<dd>Look for resources associated with this release function</dd>
<dt><code class="docutils literal"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt>
<dd>Match function (optional)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">match_data</span></code></dt>
<dd>Data for the match function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> which is associated with <strong>release</strong>
and for which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it&#8217;s considered
to match all.</p>
<p><strong>Return</strong></p>
<p>Pointer to found devres, NULL if not found.</p>
<dl class="function">
<dt id="c.devres_get">
void * <code class="descname">devres_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;new_res</em>, dr_match_t<em>&nbsp;match</em>, void *<em>&nbsp;match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Find devres, if non-existent, add one atomically</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to lookup or add devres for</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">new_res</span></code></dt>
<dd>Pointer to new initialized devres to add if not found</dd>
<dt><code class="docutils literal"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt>
<dd>Match function (optional)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">match_data</span></code></dt>
<dd>Data for the match function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> which has the same release function
as <strong>new_res</strong> and for which <strong>match</strong> return 1.  If found, <strong>new_res</strong> is
freed; otherwise, <strong>new_res</strong> is added atomically.</p>
<p><strong>Return</strong></p>
<p>Pointer to found or added devres.</p>
<dl class="function">
<dt id="c.devres_remove">
void * <code class="descname">devres_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, dr_release_t<em>&nbsp;release</em>, dr_match_t<em>&nbsp;match</em>, void *<em>&nbsp;match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a device resource and remove it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to find resource from</dd>
<dt><code class="docutils literal"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt>
<dd>Look for resources associated with this release function</dd>
<dt><code class="docutils literal"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt>
<dd>Match function (optional)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">match_data</span></code></dt>
<dd>Data for the match function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it&#8217;s considered to
match all.  If found, the resource is removed atomically and
returned.</p>
<p><strong>Return</strong></p>
<p>Pointer to removed devres on success, NULL if not found.</p>
<dl class="function">
<dt id="c.devres_destroy">
int <code class="descname">devres_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, dr_release_t<em>&nbsp;release</em>, dr_match_t<em>&nbsp;match</em>, void *<em>&nbsp;match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a device resource and destroy it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to find resource from</dd>
<dt><code class="docutils literal"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt>
<dd>Look for resources associated with this release function</dd>
<dt><code class="docutils literal"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt>
<dd>Match function (optional)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">match_data</span></code></dt>
<dd>Data for the match function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it&#8217;s considered to
match all.  If found, the resource is removed atomically and freed.</p>
<p>Note that the release function for the resource will not be called,
only the devres-allocated data will be freed.  The caller becomes
responsible for freeing any other data.</p>
<p><strong>Return</strong></p>
<p>0 if devres is found and freed, -ENOENT if not found.</p>
<dl class="function">
<dt id="c.devres_release">
int <code class="descname">devres_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, dr_release_t<em>&nbsp;release</em>, dr_match_t<em>&nbsp;match</em>, void *<em>&nbsp;match_data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a device resource and destroy it, calling release</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to find resource from</dd>
<dt><code class="docutils literal"><span class="pre">dr_release_t</span> <span class="pre">release</span></code></dt>
<dd>Look for resources associated with this release function</dd>
<dt><code class="docutils literal"><span class="pre">dr_match_t</span> <span class="pre">match</span></code></dt>
<dd>Match function (optional)</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">match_data</span></code></dt>
<dd>Data for the match function</dd>
</dl>
<p><strong>Description</strong></p>
<p>Find the latest devres of <strong>dev</strong> associated with <strong>release</strong> and for
which <strong>match</strong> returns 1.  If <strong>match</strong> is NULL, it&#8217;s considered to
match all.  If found, the resource is removed atomically, the
release function called and the resource freed.</p>
<p><strong>Return</strong></p>
<p>0 if devres is found and freed, -ENOENT if not found.</p>
<dl class="function">
<dt id="c.devres_open_group">
void * <code class="descname">devres_open_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;id</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_open_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a new devres group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to open devres group for</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>Separator ID</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Open a new devres group for <strong>dev</strong> with <strong>id</strong>.  For <strong>id</strong>, using a
pointer to an object which won&#8217;t be used for another group is
recommended.  If <strong>id</strong> is NULL, address-wise unique ID is created.</p>
<p><strong>Return</strong></p>
<p>ID of the new group, NULL on failure.</p>
<dl class="function">
<dt id="c.devres_close_group">
void <code class="descname">devres_close_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_close_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a devres group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to close devres group for</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>ID of target group, can be NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>Close the group identified by <strong>id</strong>.  If <strong>id</strong> is NULL, the latest open
group is selected.</p>
<dl class="function">
<dt id="c.devres_remove_group">
void <code class="descname">devres_remove_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_remove_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a devres group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to remove group for</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>ID of target group, can be NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>Remove the group identified by <strong>id</strong>.  If <strong>id</strong> is NULL, the latest
open group is selected.  Note that removing a group doesn&#8217;t affect
any other resources.</p>
<dl class="function">
<dt id="c.devres_release_group">
int <code class="descname">devres_release_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devres_release_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources in a devres group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to release group for</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>ID of target group, can be NULL</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release all resources in the group identified by <strong>id</strong>.  If <strong>id</strong> is
NULL, the latest open group is selected.  The selected group and
groups properly nested inside the selected group are removed.</p>
<p><strong>Return</strong></p>
<p>The number of released non-group resources.</p>
<dl class="function">
<dt id="c.devm_add_action">
int <code class="descname">devm_add_action</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void (*action) (void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_add_action" title="Permalink to this definition">¶</a></dt>
<dd><p>add a custom action to list of managed resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device that owns the action</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">action</span></code></dt>
<dd>Function that should be called</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Pointer to data passed to <strong>action</strong> implementation</dd>
</dl>
<p><strong>Description</strong></p>
<p>This adds a custom action to the list of managed resources so that
it gets executed as part of standard resource unwinding.</p>
<dl class="function">
<dt id="c.devm_remove_action">
void <code class="descname">devm_remove_action</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void (*action) (void<em>&nbsp;*</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_remove_action" title="Permalink to this definition">¶</a></dt>
<dd><p>removes previously added custom action</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device that owns the action</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(void</span> <span class="pre">*)</span> <span class="pre">action</span></code></dt>
<dd>Function implementing the action</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Pointer to data passed to <strong>action</strong> implementation</dd>
</dl>
<p><strong>Description</strong></p>
<p>Removes instance of <strong>action</strong> previously added by <a class="reference internal" href="#c.devm_add_action" title="devm_add_action"><code class="xref c c-func docutils literal"><span class="pre">devm_add_action()</span></code></a>.
Both action and data should match one of the existing entries.</p>
<dl class="function">
<dt id="c.devm_kmalloc">
void * <code class="descname">devm_kmalloc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kmalloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed kmalloc</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate memory for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Allocation size</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Allocation gfp flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed kmalloc.  Memory allocated with this function is
automatically freed on driver detach.  Like all other devres
resources, guaranteed alignment is unsigned long long.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="function">
<dt id="c.devm_kstrdup">
char * <code class="descname">devm_kstrdup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;s</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kstrdup" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate resource managed space and copy an existing string into that.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate memory for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">s</span></code></dt>
<dd>the string to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
<dl class="function">
<dt id="c.devm_kvasprintf">
char * <code class="descname">devm_kvasprintf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, gfp_t<em>&nbsp;gfp</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;ap</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kvasprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate resource managed space and format a string into that.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate memory for</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The <code class="xref c c-func docutils literal"><span class="pre">printf()</span></code>-style format string</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">ap</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
<dl class="function">
<dt id="c.devm_kasprintf">
char * <code class="descname">devm_kasprintf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, gfp_t<em>&nbsp;gfp</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kasprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate resource managed space and format a string into that.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate memory for</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>the GFP mask used in the <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal"><span class="pre">devm_kmalloc()</span></code></a> call when
allocating memory</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>The <code class="xref c c-func docutils literal"><span class="pre">printf()</span></code>-style format string</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Arguments for the format string</dd>
</dl>
<p><strong>Return</strong></p>
<p>Pointer to allocated string on success, NULL on failure.</p>
<dl class="function">
<dt id="c.devm_kfree">
void <code class="descname">devm_kfree</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void *<em>&nbsp;p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kfree" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed kfree</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device this memory belongs to</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">p</span></code></dt>
<dd>Memory to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="#c.devm_kmalloc" title="devm_kmalloc"><code class="xref c c-func docutils literal"><span class="pre">devm_kmalloc()</span></code></a>.</p>
<dl class="function">
<dt id="c.devm_kmemdup">
void * <code class="descname">devm_kmemdup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const void *<em>&nbsp;src</em>, size_t<em>&nbsp;len</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_kmemdup" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed kmemdup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device this memory belongs to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt>
<dd>Memory region to duplicate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">len</span></code></dt>
<dd>Memory region length</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>GFP mask to use</dd>
</dl>
<p><strong>Description</strong></p>
<p>Duplicate region of a memory using resource managed kmalloc</p>
<dl class="function">
<dt id="c.devm_get_free_pages">
unsigned long <code class="descname">devm_get_free_pages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, gfp_t<em>&nbsp;gfp_mask</em>, unsigned int<em>&nbsp;order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_get_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed __get_free_pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate memory for</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt>
<dd>Allocation gfp flags</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>Allocation size is (1 &lt;&lt; order) pages</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed get_free_pages.  Memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Address of allocated memory on success, 0 on failure.</p>
<dl class="function">
<dt id="c.devm_free_pages">
void <code class="descname">devm_free_pages</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, unsigned long<em>&nbsp;addr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_free_pages" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed free_pages</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device this memory belongs to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>Memory to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="#c.devm_get_free_pages" title="devm_get_free_pages"><code class="xref c c-func docutils literal"><span class="pre">devm_get_free_pages()</span></code></a>. Unlike free_pages,
there is no need to supply the <strong>order</strong>.</p>
<dl class="function">
<dt id="c.__devm_alloc_percpu">
void __percpu * <code class="descname">__devm_alloc_percpu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, size_t<em>&nbsp;align</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__devm_alloc_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed alloc_percpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate per-cpu memory for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of per-cpu memory to allocate</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">align</span></code></dt>
<dd>Alignment of per-cpu memory to allocate</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed alloc_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="function">
<dt id="c.devm_free_percpu">
void <code class="descname">devm_free_percpu</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, void __percpu *<em>&nbsp;pdata</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_free_percpu" title="Permalink to this definition">¶</a></dt>
<dd><p>Resource-managed free_percpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device this memory belongs to</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">__percpu</span> <span class="pre">*</span> <span class="pre">pdata</span></code></dt>
<dd>Per-cpu memory to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free memory allocated with <a class="reference internal" href="infrastructure.html#c.devm_alloc_percpu" title="devm_alloc_percpu"><code class="xref c c-func docutils literal"><span class="pre">devm_alloc_percpu()</span></code></a>.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="infrastructure.html" class="btn btn-neutral float-right" title="Device drivers infrastructure" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="The Linux driver implementer’s API guide" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>