

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>request_firmware API &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/>
        <link rel="up" title="Linux Firmware API" href="index.html"/>
        <link rel="next" title="Other Firmware Interfaces" href="other_interfaces.html"/>
        <link rel="prev" title="Firmware lookup order" href="lookup-order.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas&#8217; 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Linux Firmware API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="core.html">Firmware API core features</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">request_firmware API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#synchronous-firmware-requests">Synchronous firmware requests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asynchronous-firmware-requests">Asynchronous firmware requests</a></li>
<li class="toctree-l4"><a class="reference internal" href="#special-optimizations-on-reboot">Special optimizations on reboot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#request-firmware-api-expected-driver-use">request firmware API expected driver use</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="other_interfaces.html">Other Firmware Interfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
          <li><a href="index.html">Linux Firmware API</a> &raquo;</li>
      
    <li>request_firmware API</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/driver-api/firmware/request_firmware.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="request-firmware-api">
<h1>request_firmware API<a class="headerlink" href="#request-firmware-api" title="Permalink to this headline">¶</a></h1>
<p>You would typically load firmware and then load it into your device somehow.
The typical firmware work flow is reflected below:</p>
<div class="highlight-none"><div class="highlight"><pre>if(request_firmware(&amp;fw_entry, $FIRMWARE, device) == 0)
       copy_fw_to_device(fw_entry-&gt;data, fw_entry-&gt;size);
release_firmware(fw_entry);
</pre></div>
</div>
<div class="section" id="synchronous-firmware-requests">
<h2>Synchronous firmware requests<a class="headerlink" href="#synchronous-firmware-requests" title="Permalink to this headline">¶</a></h2>
<p>Synchronous firmware requests will wait until the firmware is found or until
an error is returned.</p>
<div class="section" id="request-firmware">
<h3>request_firmware<a class="headerlink" href="#request-firmware" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_firmware">
int <code class="descname">request_firmware</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware" title="Permalink to this definition">¶</a></dt>
<dd><p>send firmware request and wait for it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>firmware_p</strong> will be used to return a firmware image by the name
of <strong>name</strong> for device <strong>device</strong>.</p>
<p>Should be called from user context where sleeping is allowed.</p>
<p><strong>name</strong> will be used as $FIRMWARE in the uevent environment and
should be distinctive enough not to be confused with any other
firmware image for this or any other device.</p>
<p>Caller must hold the reference count of <strong>device</strong>.</p>
<p>The function can be called safely inside device&#8217;s suspend and
resume callback.</p>
</div></blockquote>
</div>
<div class="section" id="firmware-request-nowarn">
<h3>firmware_request_nowarn<a class="headerlink" href="#firmware-request-nowarn" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.firmware_request_nowarn">
int <code class="descname">firmware_request_nowarn</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_nowarn" title="Permalink to this definition">¶</a></dt>
<dd><p>request for an optional fw module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar in behaviour to <a class="reference internal" href="../infrastructure.html#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal"><span class="pre">request_firmware()</span></code></a>, except
it doesn&#8217;t produce warning messages when the file is not found.
The sysfs fallback mechanism is enabled if direct filesystem lookup fails,
however, however failures to find the firmware file with it are still
suppressed. It is therefore up to the driver to check for the return value
of this call and to decide when to inform the users of errors.</p>
</div>
<div class="section" id="request-firmware-direct">
<h3>request_firmware_direct<a class="headerlink" href="#request-firmware-direct" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_firmware_direct">
int <code class="descname">request_firmware_direct</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_direct" title="Permalink to this definition">¶</a></dt>
<dd><p>load firmware directly without usermode helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="../infrastructure.html#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal"><span class="pre">request_firmware()</span></code></a>, but this doesn&#8217;t
fall back to usermode helper even if the firmware couldn&#8217;t be loaded
directly from fs.  Hence it&#8217;s useful for loading optional firmwares, which
aren&#8217;t always present, without extra long timeouts of udev.</p>
</div>
<div class="section" id="request-firmware-into-buf">
<h3>request_firmware_into_buf<a class="headerlink" href="#request-firmware-into-buf" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_firmware_into_buf">
int <code class="descname">request_firmware_into_buf</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_into_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>load firmware into a previously allocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded and DMA region allocated</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>address of buffer to load firmware into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="../infrastructure.html#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal"><span class="pre">request_firmware()</span></code></a>, but it doesn&#8217;t
allocate a buffer to hold the firmware data. Instead, the firmware
is loaded directly into the buffer pointed to by <strong>buf</strong> and the <strong>firmware_p</strong>
data member is pointed at <strong>buf</strong>.</p>
<p>This function doesn&#8217;t cache firmware either.</p>
</div>
</div>
<div class="section" id="asynchronous-firmware-requests">
<h2>Asynchronous firmware requests<a class="headerlink" href="#asynchronous-firmware-requests" title="Permalink to this headline">¶</a></h2>
<p>Asynchronous firmware requests allow driver code to not have to wait
until the firmware or an error is returned. Function callbacks are
provided so that when the firmware or an error is found the driver is
informed through the callback. request_firmware_nowait() cannot be called
in atomic contexts.</p>
<div class="section" id="request-firmware-nowait">
<h3>request_firmware_nowait<a class="headerlink" href="#request-firmware-nowait" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.request_firmware_nowait">
int <code class="descname">request_firmware_nowait</code><span class="sig-paren">(</span>struct module *<em>&nbsp;module</em>, bool<em>&nbsp;uevent</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, gfp_t<em>&nbsp;gfp</em>, void *<em>&nbsp;context</em>, void (*cont) (const struct firmware<em>&nbsp;*fw</em>, void<em>&nbsp;*context</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_nowait" title="Permalink to this definition">¶</a></dt>
<dd><p>asynchronous version of request_firmware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>module requesting the firmware</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">uevent</span></code></dt>
<dd>sends uevent to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">context</span></code></dt>
<dd>will be passed over to <strong>cont</strong>, and
<strong>fw</strong> may be <code class="docutils literal"><span class="pre">NULL</span></code> if firmware request fails.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">*fw,</span> <span class="pre">void</span> <span class="pre">*context)</span> <span class="pre">cont</span></code></dt>
<dd>function will be called asynchronously when the firmware
request is over.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Caller must hold the reference count of <strong>device</strong>.</p>
<dl class="docutils">
<dt>Asynchronous variant of <a class="reference internal" href="../infrastructure.html#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal"><span class="pre">request_firmware()</span></code></a> for user contexts:</dt>
<dd><ul class="first last simple">
<li>sleep for as small periods as possible since it may
increase kernel boot time of built-in device drivers
requesting firmware in their -&gt;:c:func:<cite>probe()</cite> methods, if
<strong>gfp</strong> is GFP_KERNEL.</li>
<li>can&#8217;t sleep at all if <strong>gfp</strong> is GFP_ATOMIC.</li>
</ul>
</dd>
</dl>
</div></blockquote>
</div>
</div>
<div class="section" id="special-optimizations-on-reboot">
<h2>Special optimizations on reboot<a class="headerlink" href="#special-optimizations-on-reboot" title="Permalink to this headline">¶</a></h2>
<p>Some devices have an optimization in place to enable the firmware to be
retained during system reboot. When such optimizations are used the driver
author must ensure the firmware is still available on resume from suspend,
this can be done with firmware_request_cache() instead of requesting for the
firmware to be loaded.</p>
<div class="section" id="firmware-request-cache">
<h3>firmware_request_cache()<a class="headerlink" href="#firmware-request-cache" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="c.firmware_request_cache">
int <code class="descname">firmware_request_cache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;device</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>cache firmware for suspend so resume can use it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware should be cached for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
</dl>
<p><strong>Description</strong></p>
<p>There are some devices with an optimization that enables the device to not
require loading firmware on system reboot. This optimization may still
require the firmware present on resume from suspend. This routine can be
used to ensure the firmware is present on resume from suspend in these
situations. This helper is not compatible with drivers which use
<a class="reference internal" href="../infrastructure.html#c.request_firmware_into_buf" title="request_firmware_into_buf"><code class="xref c c-func docutils literal"><span class="pre">request_firmware_into_buf()</span></code></a> or <a class="reference internal" href="../infrastructure.html#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal"><span class="pre">request_firmware_nowait()</span></code></a> with no uevent set.</p>
</div>
</div>
<div class="section" id="request-firmware-api-expected-driver-use">
<h2>request firmware API expected driver use<a class="headerlink" href="#request-firmware-api-expected-driver-use" title="Permalink to this headline">¶</a></h2>
<p>Once an API call returns you process the firmware and then release the
firmware. For example if you used request_firmware() and it returns,
the driver has the firmware image accessible in fw_entry-&gt;{data,size}.
If something went wrong request_firmware() returns non-zero and fw_entry
is set to NULL. Once your driver is done with processing the firmware it
can call call release_firmware(fw_entry) to release the firmware image
and any related resource.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="other_interfaces.html" class="btn btn-neutral float-right" title="Other Firmware Interfaces" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lookup-order.html" class="btn btn-neutral" title="Firmware lookup order" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>