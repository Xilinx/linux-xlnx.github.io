

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Device drivers infrastructure &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="The Linux driver implementerâ€™s API guide" href="index.html"/>
        <link rel="next" title="Device Power Management" href="pm/index.html"/>
        <link rel="prev" title="Driver Basics" href="basics.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Device drivers infrastructure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-basic-device-driver-model-structures">The Basic Device Driver-Model Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-drivers-base">Device Drivers Base</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-drivers-dma-management">Device Drivers DMA Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-drivers-pnp-support">Device drivers PnP support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#userspace-io-devices">Userspace IO devices</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas&#8217; 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
    <li>Device drivers infrastructure</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/infrastructure.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="device-drivers-infrastructure">
<h1>Device drivers infrastructure<a class="headerlink" href="#device-drivers-infrastructure" title="Permalink to this headline">Â¶</a></h1>
<div class="section" id="the-basic-device-driver-model-structures">
<h2>The Basic Device Driver-Model Structures<a class="headerlink" href="#the-basic-device-driver-model-structures" title="Permalink to this headline">Â¶</a></h2>
<dl class="type">
<dt id="c.bus_type">
struct <code class="descname">bus_type</code><a class="headerlink" href="#c.bus_type" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The bus type of the device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct bus_type {
  const char              *name;
  const char              *dev_name;
  struct device           *dev_root;
  const struct attribute_group **bus_groups;
  const struct attribute_group **dev_groups;
  const struct attribute_group **drv_groups;
  int (*match)(struct device *dev, struct device_driver *drv);
  int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
  int (*probe)(struct device *dev);
  int (*remove)(struct device *dev);
  void (*shutdown)(struct device *dev);
  int (*online)(struct device *dev);
  int (*offline)(struct device *dev);
  int (*suspend)(struct device *dev, pm_message_t state);
  int (*resume)(struct device *dev);
  int (*num_vf)(struct device *dev);
  int (*dma_configure)(struct device *dev);
  const struct dev_pm_ops *pm;
  const struct iommu_ops *iommu_ops;
  struct subsys_private *p;
  struct lock_class_key lock_key;
  bool need_parent_lock;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>The name of the bus.</dd>
<dt><code class="docutils literal"><span class="pre">dev_name</span></code></dt>
<dd>Used for subsystems to enumerate devices like (&#8220;foo``u``&#8221;, dev-&gt;id).</dd>
<dt><code class="docutils literal"><span class="pre">dev_root</span></code></dt>
<dd>Default device to use as the parent.</dd>
<dt><code class="docutils literal"><span class="pre">bus_groups</span></code></dt>
<dd>Default attributes of the bus.</dd>
<dt><code class="docutils literal"><span class="pre">dev_groups</span></code></dt>
<dd>Default attributes of the devices on the bus.</dd>
<dt><code class="docutils literal"><span class="pre">drv_groups</span></code></dt>
<dd>Default attributes of the device drivers on the bus.</dd>
<dt><code class="docutils literal"><span class="pre">match</span></code></dt>
<dd>Called, perhaps multiple times, whenever a new device or driver
is added for this bus. It should return a positive value if the
given device can be handled by the given driver and zero
otherwise. It may also return error code if determining that
the driver supports the device is not possible. In case of
-EPROBE_DEFER it will queue the device for deferred probing.</dd>
<dt><code class="docutils literal"><span class="pre">uevent</span></code></dt>
<dd>Called when a device is added, removed, or a few other things
that generate uevents to add the environment variables.</dd>
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>Called when a new device or driver add to this bus, and callback
the specific driver&#8217;s probe to initial the matched device.</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>Called when a device removed from this bus.</dd>
<dt><code class="docutils literal"><span class="pre">shutdown</span></code></dt>
<dd>Called at shut-down time to quiesce the device.</dd>
<dt><code class="docutils literal"><span class="pre">online</span></code></dt>
<dd>Called to put the device back online (after offlining it).</dd>
<dt><code class="docutils literal"><span class="pre">offline</span></code></dt>
<dd>Called to put the device offline for hot-removal. May fail.</dd>
<dt><code class="docutils literal"><span class="pre">suspend</span></code></dt>
<dd>Called when a device on this bus wants to go to sleep mode.</dd>
<dt><code class="docutils literal"><span class="pre">resume</span></code></dt>
<dd>Called to bring a device on this bus out of sleep mode.</dd>
<dt><code class="docutils literal"><span class="pre">num_vf</span></code></dt>
<dd>Called to find out how many virtual functions a device on this
bus supports.</dd>
<dt><code class="docutils literal"><span class="pre">dma_configure</span></code></dt>
<dd>Called to setup DMA configuration on a device on
this bus.</dd>
<dt><code class="docutils literal"><span class="pre">pm</span></code></dt>
<dd>Power management operations of this bus, callback the specific
device driver&#8217;s pm-ops.</dd>
<dt><code class="docutils literal"><span class="pre">iommu_ops</span></code></dt>
<dd>IOMMU specific operations for this bus, used to attach IOMMU
driver implementations to a bus and allow the driver to do
bus-specific setup</dd>
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The private data of the driver core, only the driver core can
touch this.</dd>
<dt><code class="docutils literal"><span class="pre">lock_key</span></code></dt>
<dd>Lock class key for use by the lock validator</dd>
<dt><code class="docutils literal"><span class="pre">need_parent_lock</span></code></dt>
<dd>When probing or removing a device on this bus, the
device core should lock the device&#8217;s parent.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A bus is a channel between the processor and one or more devices. For the
purposes of the device model, all devices are connected via a bus, even if
it is an internal, virtual, &#8220;platform&#8221; bus. Buses can plug into each other.
A USB controller is usually a PCI device, for example. The device model
represents the actual connections between buses and the devices they control.
A bus is represented by the bus_type structure. It contains the name, the
default attributes, the bus&#8217; methods, PM operations, and the driver core&#8217;s
private data.</p>
<dl class="type">
<dt id="c.probe_type">
enum <code class="descname">probe_type</code><a class="headerlink" href="#c.probe_type" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device driver probe type to try Device drivers may opt in for special handling of their respective probe routines. This tells the core what to expect and prefer.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">PROBE_DEFAULT_STRATEGY</span></code></dt>
<dd>Used by drivers that work equally well
whether probed synchronously or asynchronously.</dd>
<dt><code class="docutils literal"><span class="pre">PROBE_PREFER_ASYNCHRONOUS</span></code></dt>
<dd>Drivers for &#8220;slow&#8221; devices which
probing order is not essential for booting the system may
opt into executing their probes asynchronously.</dd>
<dt><code class="docutils literal"><span class="pre">PROBE_FORCE_SYNCHRONOUS</span></code></dt>
<dd>Use this to annotate drivers that need
their probe routines to run synchronously with driver and
device registration (with the exception of -EPROBE_DEFER
handling - re-probing always ends up being done asynchronously).</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that the end goal is to switch the kernel to use asynchronous
probing by default, so annotating drivers with
<code class="docutils literal"><span class="pre">PROBE_PREFER_ASYNCHRONOUS</span></code> is a temporary measure that allows us
to speed up boot process while we are validating the rest of the
drivers.</p>
<dl class="type">
<dt id="c.device_driver">
struct <code class="descname">device_driver</code><a class="headerlink" href="#c.device_driver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The basic device driver structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct device_driver {
  const char              *name;
  struct bus_type         *bus;
  struct module           *owner;
  const char              *mod_name;
  bool suppress_bind_attrs;
  enum probe_type probe_type;
  const struct of_device_id       *of_match_table;
  const struct acpi_device_id     *acpi_match_table;
  int (*probe) (struct device *dev);
  int (*remove) (struct device *dev);
  void (*shutdown) (struct device *dev);
  int (*suspend) (struct device *dev, pm_message_t state);
  int (*resume) (struct device *dev);
  const struct attribute_group **groups;
  const struct dev_pm_ops *pm;
  void (*coredump) (struct device *dev);
  struct driver_private *p;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the device driver.</dd>
<dt><code class="docutils literal"><span class="pre">bus</span></code></dt>
<dd>The bus which the device of this driver belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>The module owner.</dd>
<dt><code class="docutils literal"><span class="pre">mod_name</span></code></dt>
<dd>Used for built-in modules.</dd>
<dt><code class="docutils literal"><span class="pre">suppress_bind_attrs</span></code></dt>
<dd>Disables bind/unbind via sysfs.</dd>
<dt><code class="docutils literal"><span class="pre">probe_type</span></code></dt>
<dd>Type of the probe (synchronous or asynchronous) to use.</dd>
<dt><code class="docutils literal"><span class="pre">of_match_table</span></code></dt>
<dd>The open firmware table.</dd>
<dt><code class="docutils literal"><span class="pre">acpi_match_table</span></code></dt>
<dd>The ACPI match table.</dd>
<dt><code class="docutils literal"><span class="pre">probe</span></code></dt>
<dd>Called to query the existence of a specific device,
whether this driver can work with it, and bind the driver
to a specific device.</dd>
<dt><code class="docutils literal"><span class="pre">remove</span></code></dt>
<dd>Called when the device is removed from the system to
unbind a device from this driver.</dd>
<dt><code class="docutils literal"><span class="pre">shutdown</span></code></dt>
<dd>Called at shut-down time to quiesce the device.</dd>
<dt><code class="docutils literal"><span class="pre">suspend</span></code></dt>
<dd>Called to put the device to sleep mode. Usually to a
low power state.</dd>
<dt><code class="docutils literal"><span class="pre">resume</span></code></dt>
<dd>Called to bring a device from sleep mode.</dd>
<dt><code class="docutils literal"><span class="pre">groups</span></code></dt>
<dd>Default attributes that get created by the driver core
automatically.</dd>
<dt><code class="docutils literal"><span class="pre">pm</span></code></dt>
<dd>Power management operations of the device which matched
this driver.</dd>
<dt><code class="docutils literal"><span class="pre">coredump</span></code></dt>
<dd>Called when sysfs entry is written to. The device driver
is expected to call the dev_coredump API resulting in a
uevent.</dd>
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>Driver core&#8217;s private data, no one other than the driver
core can touch this.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The device driver-model tracks all of the drivers known to the system.
The main reason for this tracking is to enable the driver core to match
up drivers with new devices. Once drivers are known objects within the
system, however, a number of other things become possible. Device drivers
can export information and configuration variables that are independent
of any specific device.</p>
<dl class="type">
<dt id="c.subsys_interface">
struct <code class="descname">subsys_interface</code><a class="headerlink" href="#c.subsys_interface" title="Permalink to this definition">Â¶</a></dt>
<dd><p>interfaces to device functions</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct subsys_interface {
  const char *name;
  struct bus_type *subsys;
  struct list_head node;
  int (*add_dev)(struct device *dev, struct subsys_interface *sif);
  void (*remove_dev)(struct device *dev, struct subsys_interface *sif);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name of the device function</dd>
<dt><code class="docutils literal"><span class="pre">subsys</span></code></dt>
<dd>subsytem of the devices to attach to</dd>
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>the list of functions registered at the subsystem</dd>
<dt><code class="docutils literal"><span class="pre">add_dev</span></code></dt>
<dd>device hookup to device function handler</dd>
<dt><code class="docutils literal"><span class="pre">remove_dev</span></code></dt>
<dd>device hookup to device function handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>Simple interfaces attached to a subsystem. Multiple interfaces can
attach to a subsystem and its devices. Unlike drivers, they do not
exclusively claim or control devices. Interfaces usually represent
a specific functionality of a subsystem/class of devices.</p>
<dl class="type">
<dt id="c.class">
struct <code class="descname">class</code><a class="headerlink" href="#c.class" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device classes</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct class {
  const char              *name;
  struct module           *owner;
  const struct attribute_group    **class_groups;
  const struct attribute_group    **dev_groups;
  struct kobject                  *dev_kobj;
  int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
  char *(*devnode)(struct device *dev, umode_t *mode);
  void (*class_release)(struct class *class);
  void (*dev_release)(struct device *dev);
  int (*shutdown_pre)(struct device *dev);
  const struct kobj_ns_type_operations *ns_type;
  const void *(*namespace)(struct device *dev);
  void (*get_ownership)(struct device *dev, kuid_t *uid, kgid_t *gid);
  const struct dev_pm_ops *pm;
  struct subsys_private *p;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the class.</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>The module owner.</dd>
<dt><code class="docutils literal"><span class="pre">class_groups</span></code></dt>
<dd>Default attributes of this class.</dd>
<dt><code class="docutils literal"><span class="pre">dev_groups</span></code></dt>
<dd>Default attributes of the devices that belong to the class.</dd>
<dt><code class="docutils literal"><span class="pre">dev_kobj</span></code></dt>
<dd>The kobject that represents this class and links it into the hierarchy.</dd>
<dt><code class="docutils literal"><span class="pre">dev_uevent</span></code></dt>
<dd>Called when a device is added, removed from this class, or a
few other things that generate uevents to add the environment
variables.</dd>
<dt><code class="docutils literal"><span class="pre">devnode</span></code></dt>
<dd>Callback to provide the devtmpfs.</dd>
<dt><code class="docutils literal"><span class="pre">class_release</span></code></dt>
<dd>Called to release this class.</dd>
<dt><code class="docutils literal"><span class="pre">dev_release</span></code></dt>
<dd>Called to release the device.</dd>
<dt><code class="docutils literal"><span class="pre">shutdown_pre</span></code></dt>
<dd>Called at shut-down time before driver shutdown.</dd>
<dt><code class="docutils literal"><span class="pre">ns_type</span></code></dt>
<dd>Callbacks so sysfs can detemine namespaces.</dd>
<dt><code class="docutils literal"><span class="pre">namespace</span></code></dt>
<dd>Namespace of the device belongs to this class.</dd>
<dt><code class="docutils literal"><span class="pre">get_ownership</span></code></dt>
<dd>Allows class to specify uid/gid of the sysfs directories
for the devices belonging to the class. Usually tied to
device&#8217;s namespace.</dd>
<dt><code class="docutils literal"><span class="pre">pm</span></code></dt>
<dd>The default device power management operations of this class.</dd>
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>The private data of the driver core, no one other than the
driver core can touch this.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A class is a higher-level view of a device that abstracts out low-level
implementation details. Drivers may see a SCSI disk or an ATA disk, but,
at the class level, they are all simply disks. Classes allow user space
to work with devices based on what they do, rather than how they are
connected or how they work.</p>
<dl class="function">
<dt id="c.devm_alloc_percpu">
<code class="descname">devm_alloc_percpu</code><span class="sig-paren">(</span><em>dev</em>, <em>type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_alloc_percpu" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed alloc_percpu</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Device to allocate per-cpu memory for</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Type to allocate per-cpu memory for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed alloc_percpu. Per-cpu memory allocated with this function is
automatically freed on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="type">
<dt id="c.device_connection">
struct <code class="descname">device_connection</code><a class="headerlink" href="#c.device_connection" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Device Connection Descriptor</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct device_connection {
  const char              *endpoint[2];
  const char              *id;
  struct list_head        list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">endpoint</span></code></dt>
<dd>The names of the two devices connected together</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>Unique identifier for the connection</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>List head, private, for internal use only</dd>
</dl>
<dl class="type">
<dt id="c.device_link_state">
enum <code class="descname">device_link_state</code><a class="headerlink" href="#c.device_link_state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Device link states.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DL_STATE_NONE</span></code></dt>
<dd>The presence of the drivers is not being tracked.</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_DORMANT</span></code></dt>
<dd>None of the supplier/consumer drivers is present.</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_AVAILABLE</span></code></dt>
<dd>The supplier driver is present, but the consumer is not.</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_CONSUMER_PROBE</span></code></dt>
<dd>The consumer is probing (supplier driver present).</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_ACTIVE</span></code></dt>
<dd>Both the supplier and consumer drivers are present.</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code></dt>
<dd>The supplier driver is unbinding.</dd>
</dl>
<dl class="type">
<dt id="c.device_link">
struct <code class="descname">device_link</code><a class="headerlink" href="#c.device_link" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Device link representation.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct device_link {
  struct device *supplier;
  struct list_head s_node;
  struct device *consumer;
  struct list_head c_node;
  enum device_link_state status;
  u32 flags;
  bool rpm_active;
  struct kref kref;
#ifdef CONFIG_SRCU;
  struct rcu_head rcu_head;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">supplier</span></code></dt>
<dd>The device on the supplier end of the link.</dd>
<dt><code class="docutils literal"><span class="pre">s_node</span></code></dt>
<dd>Hook to the supplier device&#8217;s list of links to consumers.</dd>
<dt><code class="docutils literal"><span class="pre">consumer</span></code></dt>
<dd>The device on the consumer end of the link.</dd>
<dt><code class="docutils literal"><span class="pre">c_node</span></code></dt>
<dd>Hook to the consumer device&#8217;s list of links to suppliers.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>The state of the link (with respect to the presence of drivers).</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>Link flags.</dd>
<dt><code class="docutils literal"><span class="pre">rpm_active</span></code></dt>
<dd>Whether or not the consumer device is runtime-PM-active.</dd>
<dt><code class="docutils literal"><span class="pre">kref</span></code></dt>
<dd>Count repeated addition of the same link.</dd>
<dt><code class="docutils literal"><span class="pre">rcu_head</span></code></dt>
<dd>An RCU head to use for deferred execution of SRCU callbacks.</dd>
</dl>
<dl class="type">
<dt id="c.dl_dev_state">
enum <code class="descname">dl_dev_state</code><a class="headerlink" href="#c.dl_dev_state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Device driver presence tracking information.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DL_DEV_NO_DRIVER</span></code></dt>
<dd>There is no driver attached to the device.</dd>
<dt><code class="docutils literal"><span class="pre">DL_DEV_PROBING</span></code></dt>
<dd>A driver is probing.</dd>
<dt><code class="docutils literal"><span class="pre">DL_DEV_DRIVER_BOUND</span></code></dt>
<dd>The driver has been bound to the device.</dd>
<dt><code class="docutils literal"><span class="pre">DL_DEV_UNBINDING</span></code></dt>
<dd>The driver is unbinding from the device.</dd>
</dl>
<dl class="type">
<dt id="c.dev_links_info">
struct <code class="descname">dev_links_info</code><a class="headerlink" href="#c.dev_links_info" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Device data related to device links.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct dev_links_info {
  struct list_head suppliers;
  struct list_head consumers;
  enum dl_dev_state status;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">suppliers</span></code></dt>
<dd>List of links to supplier devices.</dd>
<dt><code class="docutils literal"><span class="pre">consumers</span></code></dt>
<dd>List of links to consumer devices.</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>Driver status information.</dd>
</dl>
<dl class="type">
<dt id="c.device">
struct <code class="descname">device</code><a class="headerlink" href="#c.device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The basic device structure</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct device {
  struct device           *parent;
  struct device_private   *p;
  struct kobject kobj;
  const char              *init_name;
  const struct device_type *type;
  struct mutex            mutex;
  struct bus_type *bus;
  struct device_driver *driver;
  void *platform_data;
  void *driver_data;
  struct dev_links_info   links;
  struct dev_pm_info      power;
  struct dev_pm_domain    *pm_domain;
#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN;
  struct irq_domain       *msi_domain;
#endif;
#ifdef CONFIG_PINCTRL;
  struct dev_pin_info     *pins;
#endif;
#ifdef CONFIG_GENERIC_MSI_IRQ;
  struct list_head        msi_list;
#endif;
#ifdef CONFIG_NUMA;
  int numa_node;
#endif;
  const struct dma_map_ops *dma_ops;
  u64 *dma_mask;
  u64 coherent_dma_mask;
  u64 bus_dma_mask;
  unsigned long   dma_pfn_offset;
  struct device_dma_parameters *dma_parms;
  struct list_head        dma_pools;
  struct dma_coherent_mem *dma_mem;
#ifdef CONFIG_DMA_CMA;
  struct cma *cma_area;
#endif;
  struct dev_archdata     archdata;
  struct device_node      *of_node;
  struct fwnode_handle    *fwnode;
  dev_t devt;
  u32 id;
  spinlock_t devres_lock;
  struct list_head        devres_head;
  struct klist_node       knode_class;
  struct class            *class;
  const struct attribute_group **groups;
  void (*release)(struct device *dev);
  struct iommu_group      *iommu_group;
  struct iommu_fwspec     *iommu_fwspec;
  bool offline_disabled:1;
  bool offline:1;
  bool of_node_reused:1;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>The device&#8217;s &#8220;parent&#8221; device, the device to which it is attached.
In most cases, a parent device is some sort of bus or host
controller. If parent is NULL, the device, is a top-level device,
which is not usually what you want.</dd>
<dt><code class="docutils literal"><span class="pre">p</span></code></dt>
<dd>Holds the private data of the driver core portions of the device.
See the comment of the struct device_private for detail.</dd>
<dt><code class="docutils literal"><span class="pre">kobj</span></code></dt>
<dd>A top-level, abstract class from which other classes are derived.</dd>
<dt><code class="docutils literal"><span class="pre">init_name</span></code></dt>
<dd>Initial name of the device.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>The type of device.
This identifies the device type and carries type-specific
information.</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>Mutex to synchronize calls to its driver.</dd>
<dt><code class="docutils literal"><span class="pre">bus</span></code></dt>
<dd>Type of bus device is on.</dd>
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>Which driver has allocated this</dd>
<dt><code class="docutils literal"><span class="pre">platform_data</span></code></dt>
<dd>Platform data specific to the device.</dd>
<dt><code class="docutils literal"><span class="pre">driver_data</span></code></dt>
<dd>Private pointer for driver specific info.</dd>
<dt><code class="docutils literal"><span class="pre">links</span></code></dt>
<dd>Links to suppliers and consumers of this device.</dd>
<dt><code class="docutils literal"><span class="pre">power</span></code></dt>
<dd>For device power management.
See Documentation/driver-api/pm/devices.rst for details.</dd>
<dt><code class="docutils literal"><span class="pre">pm_domain</span></code></dt>
<dd>Provide callbacks that are executed during system suspend,
hibernation, system resume and during runtime PM transitions
along with subsystem-level and driver-level callbacks.</dd>
<dt><code class="docutils literal"><span class="pre">msi_domain</span></code></dt>
<dd>The generic MSI domain this device is using.</dd>
<dt><code class="docutils literal"><span class="pre">pins</span></code></dt>
<dd>For device pin management.
See Documentation/driver-api/pinctl.rst for details.</dd>
<dt><code class="docutils literal"><span class="pre">msi_list</span></code></dt>
<dd>Hosts MSI descriptors</dd>
<dt><code class="docutils literal"><span class="pre">numa_node</span></code></dt>
<dd>NUMA node this device is close to.</dd>
<dt><code class="docutils literal"><span class="pre">dma_ops</span></code></dt>
<dd>DMA mapping operations for this device.</dd>
<dt><code class="docutils literal"><span class="pre">dma_mask</span></code></dt>
<dd>Dma mask (if dma&#8217;ble device).</dd>
<dt><code class="docutils literal"><span class="pre">coherent_dma_mask</span></code></dt>
<dd>Like dma_mask, but for alloc_coherent mapping as not all
hardware supports 64-bit addresses for consistent allocations
such descriptors.</dd>
<dt><code class="docutils literal"><span class="pre">bus_dma_mask</span></code></dt>
<dd>Mask of an upstream bridge or bus which imposes a smaller DMA
limit than the device itself supports.</dd>
<dt><code class="docutils literal"><span class="pre">dma_pfn_offset</span></code></dt>
<dd>offset of DMA memory range relatively of RAM</dd>
<dt><code class="docutils literal"><span class="pre">dma_parms</span></code></dt>
<dd>A low level driver may set these to teach IOMMU code about
segment limitations.</dd>
<dt><code class="docutils literal"><span class="pre">dma_pools</span></code></dt>
<dd>Dma pools (if dma&#8217;ble device).</dd>
<dt><code class="docutils literal"><span class="pre">dma_mem</span></code></dt>
<dd>Internal for coherent mem override.</dd>
<dt><code class="docutils literal"><span class="pre">cma_area</span></code></dt>
<dd>Contiguous memory area for dma allocations</dd>
<dt><code class="docutils literal"><span class="pre">archdata</span></code></dt>
<dd>For arch-specific additions.</dd>
<dt><code class="docutils literal"><span class="pre">of_node</span></code></dt>
<dd>Associated device tree node.</dd>
<dt><code class="docutils literal"><span class="pre">fwnode</span></code></dt>
<dd>Associated device node supplied by platform firmware.</dd>
<dt><code class="docutils literal"><span class="pre">devt</span></code></dt>
<dd>For creating the sysfs &#8220;dev&#8221;.</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>device instance</dd>
<dt><code class="docutils literal"><span class="pre">devres_lock</span></code></dt>
<dd>Spinlock to protect the resource of the device.</dd>
<dt><code class="docutils literal"><span class="pre">devres_head</span></code></dt>
<dd>The resources list of the device.</dd>
<dt><code class="docutils literal"><span class="pre">knode_class</span></code></dt>
<dd>The node used to add the device to the class list.</dd>
<dt><code class="docutils literal"><span class="pre">class</span></code></dt>
<dd>The class of the device.</dd>
<dt><code class="docutils literal"><span class="pre">groups</span></code></dt>
<dd>Optional attribute groups.</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>Callback to free the device after all references have
gone away. This should be set by the allocator of the
device (i.e. the bus driver that discovered the device).</dd>
<dt><code class="docutils literal"><span class="pre">iommu_group</span></code></dt>
<dd>IOMMU group the device belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">iommu_fwspec</span></code></dt>
<dd>IOMMU-specific properties supplied by firmware.</dd>
<dt><code class="docutils literal"><span class="pre">offline_disabled</span></code></dt>
<dd>If set, the device is permanently online.</dd>
<dt><code class="docutils literal"><span class="pre">offline</span></code></dt>
<dd>Set after successful invocation of bus type&#8217;s .:c:func:<cite>offline()</cite>.</dd>
<dt><code class="docutils literal"><span class="pre">of_node_reused</span></code></dt>
<dd>Set if the device-tree node is shared with an ancestor
device.</dd>
</dl>
<p><strong>Example</strong></p>
<dl class="docutils">
<dt>For devices on custom boards, as typical of embedded</dt>
<dd>and SOC based hardware, Linux often uses platform_data to point
to board-specific structures describing devices and how they
are wired.  That can include what ports are available, chip
variants, which GPIO pins act in what additional roles, and so
on.  This shrinks the &#8220;Board Support Packages&#8221; (BSPs) and
minimizes board-specific #ifdefs in drivers.</dd>
</dl>
<p><strong>Description</strong></p>
<p>At the lowest level, every device in a Linux system is represented by an
instance of struct device. The device structure contains the information
that the device model core needs to model the system. Most subsystems,
however, track additional information about the devices they host. As a
result, it is rare for devices to be represented by bare device structures;
instead, that structure, like kobject structures, is usually embedded within
a higher-level representation of the device.</p>
<dl class="function">
<dt id="c.module_driver">
<code class="descname">module_driver</code><span class="sig-paren">(</span><em>__driver</em>, <em>__register</em>, <em>__unregister</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_driver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Helper macro for drivers that don&#8217;t do anything special in module init/exit. This eliminates a lot of boilerplate. Each module may only use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code></a>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__driver</span></code></dt>
<dd>driver name</dd>
<dt><code class="docutils literal"><span class="pre">__register</span></code></dt>
<dd>register function for this driver type</dd>
<dt><code class="docutils literal"><span class="pre">__unregister</span></code></dt>
<dd>unregister function for this driver type</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Additional arguments to be passed to __register and __unregister.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this macro to construct bus specific macros for registering
drivers, and do not use it on its own.</p>
<dl class="function">
<dt id="c.builtin_driver">
<code class="descname">builtin_driver</code><span class="sig-paren">(</span><em>__driver</em>, <em>__register</em>, <em>...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.builtin_driver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Helper macro for drivers that don&#8217;t do anything special in init and have no exit. This eliminates some boilerplate. Each driver may only use this macro once, and calling it replaces device_initcall (or in some cases, the legacy __initcall). This is meant to be a direct parallel of <a class="reference internal" href="#c.module_driver" title="module_driver"><code class="xref c c-func docutils literal"><span class="pre">module_driver()</span></code></a> above but without the __exit stuff that is not used for builtin cases.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__driver</span></code></dt>
<dd>driver name</dd>
<dt><code class="docutils literal"><span class="pre">__register</span></code></dt>
<dd>register function for this driver type</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>Additional arguments to be passed to __register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this macro to construct bus specific macros for registering
drivers, and do not use it on its own.</p>
</div>
<div class="section" id="device-drivers-base">
<h2>Device Drivers Base<a class="headerlink" href="#device-drivers-base" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.driver_init">
void <code class="descname">driver_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.driver_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize driver model.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call the driver model init functions to initialize their
subsystems. Called early from init/main.c.</p>
<dl class="function">
<dt id="c.driver_for_each_device">
int <code class="descname">driver_for_each_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;drv</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_for_each_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Iterator for devices bound to a driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>Driver we&#8217;re iterating.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to pass to the callback.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>Function to call for each device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over the <strong>drv</strong>&#8216;s list of devices calling <strong>fn</strong> for each one.</p>
<dl class="function">
<dt id="c.driver_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">driver_find_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;drv</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>The device&#8217;s driver</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to pass to match function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">match</span></code></dt>
<dd>Callback function to check device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.driver_for_each_device" title="driver_for_each_device"><code class="xref c c-func docutils literal"><span class="pre">driver_for_each_device()</span></code></a> function above, but
it returns a reference to a device that is &#8216;found&#8217; for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn&#8217;t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
<dl class="function">
<dt id="c.driver_create_file">
int <code class="descname">driver_create_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;drv</em>, const struct driver_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_create_file" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create sysfs file for driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">driver_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>driver attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.driver_remove_file">
void <code class="descname">driver_remove_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;drv</em>, const struct driver_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_remove_file" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove sysfs file for driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">driver_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>driver attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.driver_register">
int <code class="descname">driver_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register driver with bus</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>We pass off most of the work to the <code class="xref c c-func docutils literal"><span class="pre">bus_add_driver()</span></code> call,
since most of the things we have to do deal with the bus
structures.</p>
<dl class="function">
<dt id="c.driver_unregister">
void <code class="descname">driver_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove driver from system.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Again, we pass off most of the work to the bus-level call.</p>
<dl class="function">
<dt id="c.driver_find">
struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> * <code class="descname">driver_find</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_find" title="Permalink to this definition">Â¶</a></dt>
<dd><p>locate driver on a bus by its name.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the driver.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus to scan for the driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Call <a class="reference internal" href="basics.html#c.kset_find_obj" title="kset_find_obj"><code class="xref c c-func docutils literal"><span class="pre">kset_find_obj()</span></code></a> to iterate over list of drivers on
a bus to find driver by name. Return driver if found.</p>
<p>This routine provides no locking to prevent the driver it returns
from being unregistered or unloaded while the caller is using it.
The caller is responsible for preventing this.</p>
<dl class="function">
<dt id="c.device_link_add">
struct <a class="reference internal" href="#c.device_link" title="device_link">device_link</a> * <code class="descname">device_link_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;consumer</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;supplier</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_add" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a link between two devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">consumer</span></code></dt>
<dd>Consumer end of the link.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">supplier</span></code></dt>
<dd>Supplier end of the link.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Link flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller is responsible for the proper synchronization of the link creation
with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will cause the
runtime PM framework to take the link into account.  Second, if the
DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices will
be forced into the active metastate and reference-counted upon the creation
of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
ignored.</p>
<p>If the DL_FLAG_AUTOREMOVE_CONSUMER is set, the link will be removed
automatically when the consumer device driver unbinds from it.
The combination of both DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_STATELESS
set is invalid and will cause NULL to be returned.</p>
<p>A side effect of the link creation is re-ordering of dpm_list and the
devices_kset list by moving the consumer device and all devices depending
on it to the ends of these lists (that does not happen to devices that have
not been registered when this function is called).</p>
<p>The supplier device is required to be registered when this function is called
and NULL will be returned if that is not the case.  The consumer device need
not be registered, however.</p>
<dl class="function">
<dt id="c.device_link_del">
void <code class="descname">device_link_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_link" title="device_link">device_link</a> *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_del" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Delete a link between two devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>Device link to delete.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.  If the link was added multiple times, it needs to be deleted as often.
Care is required for hotplugged devices:  Their links are purged on removal
and calling <a class="reference internal" href="#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal"><span class="pre">device_link_del()</span></code></a> is then no longer allowed.</p>
<dl class="function">
<dt id="c.device_link_remove">
void <code class="descname">device_link_remove</code><span class="sig-paren">(</span>void *<em>&nbsp;consumer</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;supplier</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_remove" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove a link between two devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">consumer</span></code></dt>
<dd>Consumer end of the link.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">supplier</span></code></dt>
<dd>Supplier end of the link.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.</p>
<dl class="function">
<dt id="c.dev_driver_string">
const char * <code class="descname">dev_driver_string</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dev_driver_string" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a device&#8217;s driver name, if at all possible</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>struct device to get the name of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Will return the device&#8217;s driver&#8217;s name if it is bound to a device.  If
the device is not bound to a driver, it will return the name of the bus
it is attached to.  If it is not attached to a bus either, an empty
string will be returned.</p>
<dl class="function">
<dt id="c.devm_device_add_group">
int <code class="descname">devm_device_add_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct attribute_group *<em>&nbsp;grp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_add_group" title="Permalink to this definition">Â¶</a></dt>
<dd><p>given a device, create a managed attribute group</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device to create the group for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*</span> <span class="pre">grp</span></code></dt>
<dd>The attribute group to create</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a group for the first time.  It will explicitly
warn and error if any of the attribute files being created already exist.</p>
<p>Returns 0 on success or error code on failure.</p>
<dl class="function">
<dt id="c.devm_device_remove_group">
void <code class="descname">devm_device_remove_group</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct attribute_group *<em>&nbsp;grp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_remove_group" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to remove the group from</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">*</span> <span class="pre">grp</span></code></dt>
<dd>group to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function removes a group of attributes from a device. The attributes
previously have to have been created for this group, otherwise it will fail.</p>
<dl class="function">
<dt id="c.devm_device_add_groups">
int <code class="descname">devm_device_add_groups</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_add_groups" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a bunch of managed attribute groups</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device to create the group for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>The attribute groups to create, NULL terminated</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a bunch of managed attribute groups.  If an error
occurs when creating a group, all previously created groups will be
removed, unwinding everything back to the original state when this
function was called.  It will explicitly warn and error if any of the
attribute files being created already exist.</p>
<p>Returns 0 on success or error code from sysfs_create_group on failure.</p>
<dl class="function">
<dt id="c.devm_device_remove_groups">
void <code class="descname">devm_device_remove_groups</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_device_remove_groups" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove a list of managed groups</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The device for the groups to be removed from</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>NULL terminated list of groups to be removed</dd>
</dl>
<p><strong>Description</strong></p>
<p>If groups is not NULL, remove the specified groups from the device.</p>
<dl class="function">
<dt id="c.device_create_file">
int <code class="descname">device_create_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct device_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_file" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create sysfs attribute file for device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.device_remove_file">
void <code class="descname">device_remove_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct device_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_file" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove sysfs attribute file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.device_remove_file_self">
bool <code class="descname">device_remove_file_self</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct device_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_file_self" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove sysfs attribute file from its own method.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device attribute descriptor.</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <code class="xref c c-func docutils literal"><span class="pre">kernfs_remove_self()</span></code> for details.</p>
<dl class="function">
<dt id="c.device_create_bin_file">
int <code class="descname">device_create_bin_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct bin_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_bin_file" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create sysfs binary attribute file for device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device binary attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.device_remove_bin_file">
void <code class="descname">device_remove_bin_file</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct bin_attribute *<em>&nbsp;attr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_remove_bin_file" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove sysfs binary attribute file</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">bin_attribute</span> <span class="pre">*</span> <span class="pre">attr</span></code></dt>
<dd>device binary attribute descriptor.</dd>
</dl>
<dl class="function">
<dt id="c.device_initialize">
void <code class="descname">device_initialize</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_initialize" title="Permalink to this definition">Â¶</a></dt>
<dd><p>init device structure.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This prepares the device for use by other layers by initializing
its fields.
It is the first half of <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code></a>, if called by
that function, though it can also be called separately, so one
may use <strong>dev</strong>&#8216;s fields. In particular, <a class="reference internal" href="#c.get_device" title="get_device"><code class="xref c c-func docutils literal"><span class="pre">get_device()</span></code></a>/<a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal"><span class="pre">put_device()</span></code></a>
may be used for reference counting of <strong>dev</strong> after calling this
function.</p>
<p>All fields in <strong>dev</strong> must be initialized by the caller to 0, except
for those explicitly set to some other value.  The simplest
approach is to use <a class="reference internal" href="../core-api/mm-api.html#c.kzalloc" title="kzalloc"><code class="xref c c-func docutils literal"><span class="pre">kzalloc()</span></code></a> to allocate the structure containing
<strong>dev</strong>.</p>
<p><strong>NOTE</strong></p>
<p>Use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal"><span class="pre">put_device()</span></code></a> to give up your reference instead of freeing
<strong>dev</strong> directly once you have called this function.</p>
<dl class="function">
<dt id="c.dev_set_name">
int <code class="descname">dev_set_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.dev_set_name" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set a device name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>format string for the device&#8217;s name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<dl class="function">
<dt id="c.device_add">
int <code class="descname">device_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_add" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add device to device hierarchy.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part 2 of <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code></a>, though may be called
separately _iff_ <a class="reference internal" href="#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal"><span class="pre">device_initialize()</span></code></a> has been called separately.</p>
<p>This adds <strong>dev</strong> to the kobject hierarchy via <a class="reference internal" href="basics.html#c.kobject_add" title="kobject_add"><code class="xref c c-func docutils literal"><span class="pre">kobject_add()</span></code></a>, adds it
to the global and sibling lists for the device, then
adds it to the other relevant subsystems of the driver model.</p>
<p>Do not call this routine or <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code></a> more than once for
any device structure.  The driver model core is not designed to work
with devices that get unregistered and then spring back to life.
(Among other things, it&#8217;s very hard to guarantee that all references
to the previous incarnation of <strong>dev</strong> have been dropped.)  Allocate
and register a fresh new struct device instead.</p>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>dev</strong> after calling this function, even
if it returned an error! Always use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal"><span class="pre">put_device()</span></code></a> to give up your
reference instead.</p>
<dl class="function">
<dt id="c.device_register">
int <code class="descname">device_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a device with the system.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the device structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>This happens in two clean steps - initialize the device
and add it to the system. The two steps can be called
separately, but this is the easiest and most common.
I.e. you should only call the two helpers separately if
have a clearly defined need to use and refcount the device
before it is added to the hierarchy.</p>
<p>For more information, see the kerneldoc for <a class="reference internal" href="#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal"><span class="pre">device_initialize()</span></code></a>
and <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal"><span class="pre">device_add()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>_Never_ directly free <strong>dev</strong> after calling this function, even
if it returned an error! Always use <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal"><span class="pre">put_device()</span></code></a> to give up the
reference initialized in this function instead.</p>
<dl class="function">
<dt id="c.get_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">get_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.get_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>increment reference count for device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This simply forwards the call to <a class="reference internal" href="basics.html#c.kobject_get" title="kobject_get"><code class="xref c c-func docutils literal"><span class="pre">kobject_get()</span></code></a>, though
we do take care to provide for the case that we get a NULL
pointer passed in.</p>
<dl class="function">
<dt id="c.put_device">
void <code class="descname">put_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.put_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>decrement reference count.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device in question.</dd>
</dl>
<dl class="function">
<dt id="c.device_del">
void <code class="descname">device_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_del" title="Permalink to this definition">Â¶</a></dt>
<dd><p>delete device from system.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the first part of the device unregistration
sequence. This removes the device from the lists we control
from here, has it removed from the other driver model
subsystems it was added to in <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal"><span class="pre">device_add()</span></code></a>, and removes it
from the kobject hierarchy.</p>
<p><strong>NOTE</strong></p>
<p>this should be called manually _iff_ <a class="reference internal" href="#c.device_add" title="device_add"><code class="xref c c-func docutils literal"><span class="pre">device_add()</span></code></a> was
also called manually.</p>
<dl class="function">
<dt id="c.device_unregister">
void <code class="descname">device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister device from system.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device going away.</dd>
</dl>
<p><strong>Description</strong></p>
<p>We do this in two parts, like we do <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code></a>. First,
we remove it from all the subsystems with <a class="reference internal" href="#c.device_del" title="device_del"><code class="xref c c-func docutils literal"><span class="pre">device_del()</span></code></a>, then
we decrement the reference count via <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal"><span class="pre">put_device()</span></code></a>. If that
is the final reference count, the device will be cleaned up
via <code class="xref c c-func docutils literal"><span class="pre">device_release()</span></code> above. Otherwise, the structure will
stick around until the final reference to the device is dropped.</p>
<dl class="function">
<dt id="c.device_for_each_child">
int <code class="descname">device_for_each_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_for_each_child" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device child iterator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent struct device.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>parent</strong>&#8216;s child devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<dl class="function">
<dt id="c.device_for_each_child_reverse">
int <code class="descname">device_for_each_child_reverse</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_for_each_child_reverse" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device child iterator in reversed order.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent struct device.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>parent</strong>&#8216;s child devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<dl class="function">
<dt id="c.device_find_child">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_find_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_find_child" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent struct device</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to pass to match function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">match</span></code></dt>
<dd>Callback function to check device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.device_for_each_child" title="device_for_each_child"><code class="xref c c-func docutils literal"><span class="pre">device_for_each_child()</span></code></a> function above, but it
returns a reference to a device that is &#8216;found&#8217; for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn&#8217;t match and non-zero
if it does.  If the callback returns non-zero and a reference to the
current device can be obtained, this function will return to the caller
and not iterate over any more devices.</p>
<p><strong>NOTE</strong></p>
<p>you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal"><span class="pre">put_device()</span></code></a> after use.</p>
<dl class="function">
<dt id="c.__root_device_register">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">__root_device_register</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__root_device_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>allocate and register a root device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>root device name</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owner module of the root device, usually THIS_MODULE</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function allocates a root device and registers it
using <a class="reference internal" href="#c.device_register" title="device_register"><code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code></a>. In order to free the returned
device, use <a class="reference internal" href="#c.root_device_unregister" title="root_device_unregister"><code class="xref c c-func docutils literal"><span class="pre">root_device_unregister()</span></code></a>.</p>
<p>Root devices are dummy devices which allow other devices
to be grouped under /sys/devices. Use this function to
allocate a root device and then use it as the parent of
any device which should appear under /sys/devices/{name}</p>
<p>The /sys/devices/{name} directory will also contain a
&#8216;module&#8217; symlink which points to the <strong>owner</strong> directory
in sysfs.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<p><strong>Note</strong></p>
<p>You probably want to use <code class="xref c c-func docutils literal"><span class="pre">root_device_register()</span></code>.</p>
<dl class="function">
<dt id="c.root_device_unregister">
void <code class="descname">root_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.root_device_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister and free a root device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device going away</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function unregisters and cleans up a device that was created by
<code class="xref c c-func docutils literal"><span class="pre">root_device_register()</span></code>.</p>
<dl class="function">
<dt id="c.device_create_vargs">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_create_vargs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.class" title="class">class</a> *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, dev_t<em>&nbsp;devt</em>, void *<em>&nbsp;drvdata</em>, const char *<em>&nbsp;fmt</em>, va_list<em>&nbsp;args</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_vargs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>pointer to the struct class that this device should be registered to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>pointer to the parent struct device of this new device, if any</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>the dev_t for the char device to be added</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">drvdata</span></code></dt>
<dd>the data to be added to the device for callbacks</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>string for the device&#8217;s name</dd>
<dt><code class="docutils literal"><span class="pre">va_list</span> <span class="pre">args</span></code></dt>
<dd>va_list for the device&#8217;s name</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.</p>
<p>A &#8220;dev&#8221; file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<p><strong>Note</strong></p>
<p>the struct class passed to this function must have previously
been created with a call to <code class="xref c c-func docutils literal"><span class="pre">class_create()</span></code>.</p>
<dl class="function">
<dt id="c.device_create">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.class" title="class">class</a> *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, dev_t<em>&nbsp;devt</em>, void *<em>&nbsp;drvdata</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.device_create" title="Permalink to this definition">Â¶</a></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>pointer to the struct class that this device should be registered to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>pointer to the parent struct device of this new device, if any</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>the dev_t for the char device to be added</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">drvdata</span></code></dt>
<dd>the data to be added to the device for callbacks</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>string for the device&#8217;s name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.</p>
<p>A &#8220;dev&#8221; file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<p><strong>Note</strong></p>
<p>the struct class passed to this function must have previously
been created with a call to <code class="xref c c-func docutils literal"><span class="pre">class_create()</span></code>.</p>
<dl class="function">
<dt id="c.device_create_with_groups">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">device_create_with_groups</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.class" title="class">class</a> *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, dev_t<em>&nbsp;devt</em>, void *<em>&nbsp;drvdata</em>, const struct attribute_group **<em>&nbsp;groups</em>, const char *<em>&nbsp;fmt</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.device_create_with_groups" title="Permalink to this definition">Â¶</a></dt>
<dd><p>creates a device and registers it with sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>pointer to the struct class that this device should be registered to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>pointer to the parent struct device of this new device, if any</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>the dev_t for the char device to be added</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">drvdata</span></code></dt>
<dd>the data to be added to the device for callbacks</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>NULL-terminated list of attribute groups to be created</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">fmt</span></code></dt>
<dd>string for the device&#8217;s name</dd>
<dt><code class="docutils literal"><span class="pre">...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used by char device classes.  A struct device
will be created in sysfs, registered to the specified class.
Additional attributes specified in the groups parameter will also
be created automatically.</p>
<p>A &#8220;dev&#8221; file will be created, showing the dev_t for the device, if
the dev_t is not 0,0.
If a pointer to a parent struct device is passed in, the newly created
struct device will be a child of that device in sysfs.
The pointer to the struct device will be returned from the call.
Any further sysfs files that might be required can be created using this
pointer.</p>
<p>Returns <a class="reference internal" href="#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<p><strong>Note</strong></p>
<p>the struct class passed to this function must have previously
been created with a call to <code class="xref c c-func docutils literal"><span class="pre">class_create()</span></code>.</p>
<dl class="function">
<dt id="c.device_destroy">
void <code class="descname">device_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.class" title="class">class</a> *<em>&nbsp;class</em>, dev_t<em>&nbsp;devt</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_destroy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>removes a device that was created with <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal"><span class="pre">device_create()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>pointer to the struct class that this device was registered with</dd>
<dt><code class="docutils literal"><span class="pre">dev_t</span> <span class="pre">devt</span></code></dt>
<dd>the dev_t of the device that was previously registered</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call unregisters and cleans up a device that was created with a
call to <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal"><span class="pre">device_create()</span></code></a>.</p>
<dl class="function">
<dt id="c.device_rename">
int <code class="descname">device_rename</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;new_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_rename" title="Permalink to this definition">Â¶</a></dt>
<dd><p>renames a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the pointer to the struct device to be renamed</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">new_name</span></code></dt>
<dd>the new name of the device</dd>
</dl>
<p><strong>Description</strong></p>
<p>It is the responsibility of the caller to provide mutual
exclusion between two different calls of device_rename
on the same device to ensure that new_name is valid and
won&#8217;t conflict with other devices.</p>
<p><strong>Note</strong></p>
<p>Don&#8217;t call this function.  Currently, the networking layer calls this
function, but that will change.  The following text from Kay Sievers offers
some insight:</p>
<p>Renaming devices is racy at many levels, symlinks and other stuff are not
replaced atomically, and you get a &#8220;move&#8221; uevent, but it&#8217;s not easy to
connect the event to the old and new device. Device nodes are not renamed at
all, there isn&#8217;t even support for that in the kernel now.</p>
<p>In the meantime, during renaming, your target name might be taken by another
driver, creating conflicts. Or the old name is taken directly after you
renamed it &#8211; then you get events for the same DEVPATH, before you even see
the &#8220;move&#8221; event. It&#8217;s just a mess, and nothing new should ever rely on
kernel device renaming. Besides that, it&#8217;s not even implemented now for
other things than (driver-core wise very simple) network devices.</p>
<p>We are currently about to change network renaming in udev to completely
disallow renaming of devices in the same namespace as the kernel uses,
because we can&#8217;t solve the problems properly, that arise with swapping names
of multiple interfaces without races. Means, renaming of eth[0-9]* will only
be allowed to some other name than eth[0-9]*, for the aforementioned
reasons.</p>
<p>Make up a &#8220;real&#8221; name in the driver before you register anything, or add
some other attributes for userspace to find the device, or use udev to add
symlinks &#8211; but never rename kernel devices later, it&#8217;s a complete mess. We
don&#8217;t even want to get into that and try to implement the missing pieces in
the core. We really have other pieces to fix in the driver core mess. :)</p>
<dl class="function">
<dt id="c.device_move">
int <code class="descname">device_move</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;new_parent</em>, enum dpm_order<em>&nbsp;dpm_order</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_move" title="Permalink to this definition">Â¶</a></dt>
<dd><p>moves a device to a new parent</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the pointer to the struct device to be moved</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">new_parent</span></code></dt>
<dd>the new parent of the device (can be NULL)</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">dpm_order</span> <span class="pre">dpm_order</span></code></dt>
<dd>how to reorder the dpm_list</dd>
</dl>
<dl class="function">
<dt id="c.set_primary_fwnode">
void <code class="descname">set_primary_fwnode</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct fwnode_handle *<em>&nbsp;fwnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.set_primary_fwnode" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Change the primary firmware node of a given device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to handle.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt>
<dd>New primary firmware node of the device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the device&#8217;s firmware node pointer to <strong>fwnode</strong>, but if a secondary
firmware node of the device is present, preserve it.</p>
<dl class="function">
<dt id="c.device_set_of_node_from_dev">
void <code class="descname">device_set_of_node_from_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_set_of_node_from_dev" title="Permalink to this definition">Â¶</a></dt>
<dd><p>reuse device-tree node of another device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device whose device-tree node is being set</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev2</span></code></dt>
<dd>device whose device-tree node is being reused</dd>
</dl>
<p><strong>Description</strong></p>
<p>Takes another reference to the new device-tree node after first dropping
any reference held to the old node.</p>
<dl class="function">
<dt id="c.register_syscore_ops">
void <code class="descname">register_syscore_ops</code><span class="sig-paren">(</span>struct syscore_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.register_syscore_ops" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Register a set of system core operations.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">syscore_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>System core operations to register.</dd>
</dl>
<dl class="function">
<dt id="c.unregister_syscore_ops">
void <code class="descname">unregister_syscore_ops</code><span class="sig-paren">(</span>struct syscore_ops *<em>&nbsp;ops</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_syscore_ops" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Unregister a set of system core operations.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">syscore_ops</span> <span class="pre">*</span> <span class="pre">ops</span></code></dt>
<dd>System core operations to unregister.</dd>
</dl>
<dl class="function">
<dt id="c.syscore_suspend">
int <code class="descname">syscore_suspend</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.syscore_suspend" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Execute all the registered system core suspend callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is executed with one CPU on-line and disabled interrupts.</p>
<dl class="function">
<dt id="c.syscore_resume">
void <code class="descname">syscore_resume</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.syscore_resume" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Execute all the registered system core resume callbacks.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is executed with one CPU on-line and disabled interrupts.</p>
<dl class="function">
<dt id="c.__class_create">
struct <a class="reference internal" href="#c.class" title="class">class</a> * <code class="descname">__class_create</code><span class="sig-paren">(</span>struct module *<em>&nbsp;owner</em>, const char *<em>&nbsp;name</em>, struct lock_class_key *<em>&nbsp;key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__class_create" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a struct class structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>pointer to the module that is to &#8220;own&#8221; this struct class</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>pointer to a string for the name of this class.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*</span> <span class="pre">key</span></code></dt>
<dd>the lock_class_key for this class; used by mutex lock debugging</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used to create a struct class pointer that can then be used
in calls to <a class="reference internal" href="#c.device_create" title="device_create"><code class="xref c c-func docutils literal"><span class="pre">device_create()</span></code></a>.</p>
<p>Returns <a class="reference internal" href="#c.class" title="class"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">class</span></code></a> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<p>Note, the pointer created here is to be destroyed when finished by
making a call to <a class="reference internal" href="#c.class_destroy" title="class_destroy"><code class="xref c c-func docutils literal"><span class="pre">class_destroy()</span></code></a>.</p>
<dl class="function">
<dt id="c.class_destroy">
void <code class="descname">class_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.class" title="class">class</a> *<em>&nbsp;cls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_destroy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>destroys a struct class structure</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">cls</span></code></dt>
<dd>pointer to the struct class that is to be destroyed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note, the pointer to be destroyed must have been created with a call
to <code class="xref c c-func docutils literal"><span class="pre">class_create()</span></code>.</p>
<dl class="function">
<dt id="c.class_dev_iter_init">
void <code class="descname">class_dev_iter_init</code><span class="sig-paren">(</span>struct class_dev_iter *<em>&nbsp;iter</em>, struct <a class="reference internal" href="#c.class" title="class">class</a> *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const struct device_type *<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize class device iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>class iterator to initialize</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>the class we wanna iterate over</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>the device to start iterating from, if any</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>device_type of the devices to iterate over, NULL for all</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize class iterator <strong>iter</strong> such that it iterates over devices
of <strong>class</strong>.  If <strong>start</strong> is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.</p>
<dl class="function">
<dt id="c.class_dev_iter_next">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">class_dev_iter_next</code><span class="sig-paren">(</span>struct class_dev_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_next" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterate to the next device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>class iterator to proceed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>iter</strong> to the next device and return it.  Returns NULL if
iteration is complete.</p>
<p>The returned device is referenced and won&#8217;t be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into class code.</p>
<dl class="function">
<dt id="c.class_dev_iter_exit">
void <code class="descname">class_dev_iter_exit</code><span class="sig-paren">(</span>struct class_dev_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_dev_iter_exit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>finish iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>class iterator to finish</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.</p>
<dl class="function">
<dt id="c.class_for_each_device">
int <code class="descname">class_for_each_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.class" title="class">class</a> *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_for_each_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>the class we&#8217;re iterating</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>the device to start with in the list, if any.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>class</strong>&#8216;s list of devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>.  If <strong>start</strong> is set, the list iteration will start
there, otherwise if it is NULL, the iteration starts at the
beginning of the list.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<p><strong>fn</strong> is allowed to do anything including calling back into class
code.  There&#8217;s no locking restriction.</p>
<dl class="function">
<dt id="c.class_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">class_find_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.class" title="class">class</a> *<em>&nbsp;class</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*</em>, const void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_find_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device iterator for locating a particular device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span> <span class="pre">*</span> <span class="pre">class</span></code></dt>
<dd>the class we&#8217;re iterating</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the match function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">match</span></code></dt>
<dd>function to check device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <code class="xref c c-func docutils literal"><span class="pre">class_for_each_dev()</span></code> function above, but it
returns a reference to a device that is &#8216;found&#8217; for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn&#8217;t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
<p>Note, you will need to drop the reference with <a class="reference internal" href="#c.put_device" title="put_device"><code class="xref c c-func docutils literal"><span class="pre">put_device()</span></code></a> after use.</p>
<p><strong>match</strong> is allowed to do anything including calling back into class
code.  There&#8217;s no locking restriction.</p>
<dl class="function">
<dt id="c.class_compat_register">
struct class_compat * <code class="descname">class_compat_register</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a compatibility class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the name of the class</dd>
</dl>
<p><strong>Description</strong></p>
<p>Compatibility class are meant as a temporary user-space compatibility
workaround when converting a family of class devices to a bus devices.</p>
<dl class="function">
<dt id="c.class_compat_unregister">
void <code class="descname">class_compat_unregister</code><span class="sig-paren">(</span>struct class_compat *<em>&nbsp;cls</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister a compatibility class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*</span> <span class="pre">cls</span></code></dt>
<dd>the class to unregister</dd>
</dl>
<dl class="function">
<dt id="c.class_compat_create_link">
int <code class="descname">class_compat_create_link</code><span class="sig-paren">(</span>struct class_compat *<em>&nbsp;cls</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_create_link" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a compatibility class device link to a bus device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*</span> <span class="pre">cls</span></code></dt>
<dd>the compatibility class</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the target bus device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device_link</span></code></dt>
<dd>an optional device to which a &#8220;device&#8221; link should be created</dd>
</dl>
<dl class="function">
<dt id="c.class_compat_remove_link">
void <code class="descname">class_compat_remove_link</code><span class="sig-paren">(</span>struct class_compat *<em>&nbsp;cls</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device_link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.class_compat_remove_link" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove a compatibility class device link to a bus device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">class_compat</span> <span class="pre">*</span> <span class="pre">cls</span></code></dt>
<dd>the compatibility class</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the target bus device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device_link</span></code></dt>
<dd>an optional device to which a &#8220;device&#8221; link was previously
created</dd>
</dl>
<dl class="function">
<dt id="c.unregister_node">
void <code class="descname">unregister_node</code><span class="sig-paren">(</span>struct node *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.unregister_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister a node device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>node going away</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregisters a node device <strong>node</strong>.  All the devices on the node must be
unregistered before calling this function.</p>
<dl class="function">
<dt id="c.request_firmware">
int <code class="descname">request_firmware</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware" title="Permalink to this definition">Â¶</a></dt>
<dd><p>send firmware request and wait for it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p><strong>firmware_p</strong> will be used to return a firmware image by the name
of <strong>name</strong> for device <strong>device</strong>.</p>
<p>Should be called from user context where sleeping is allowed.</p>
<p><strong>name</strong> will be used as $FIRMWARE in the uevent environment and
should be distinctive enough not to be confused with any other
firmware image for this or any other device.</p>
<p>Caller must hold the reference count of <strong>device</strong>.</p>
<p>The function can be called safely inside device&#8217;s suspend and
resume callback.</p>
</div></blockquote>
<dl class="function">
<dt id="c.firmware_request_nowarn">
int <code class="descname">firmware_request_nowarn</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_nowarn" title="Permalink to this definition">Â¶</a></dt>
<dd><p>request for an optional fw module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is similar in behaviour to <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal"><span class="pre">request_firmware()</span></code></a>, except
it doesn&#8217;t produce warning messages when the file is not found.
The sysfs fallback mechanism is enabled if direct filesystem lookup fails,
however, however failures to find the firmware file with it are still
suppressed. It is therefore up to the driver to check for the return value
of this call and to decide when to inform the users of errors.</p>
<dl class="function">
<dt id="c.request_firmware_direct">
int <code class="descname">request_firmware_direct</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_direct" title="Permalink to this definition">Â¶</a></dt>
<dd><p>load firmware directly without usermode helper</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal"><span class="pre">request_firmware()</span></code></a>, but this doesn&#8217;t
fall back to usermode helper even if the firmware couldn&#8217;t be loaded
directly from fs.  Hence it&#8217;s useful for loading optional firmwares, which
aren&#8217;t always present, without extra long timeouts of udev.</p>
<dl class="function">
<dt id="c.firmware_request_cache">
int <code class="descname">firmware_request_cache</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.firmware_request_cache" title="Permalink to this definition">Â¶</a></dt>
<dd><p>cache firmware for suspend so resume can use it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware should be cached for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
</dl>
<p><strong>Description</strong></p>
<p>There are some devices with an optimization that enables the device to not
require loading firmware on system reboot. This optimization may still
require the firmware present on resume from suspend. This routine can be
used to ensure the firmware is present on resume from suspend in these
situations. This helper is not compatible with drivers which use
<a class="reference internal" href="#c.request_firmware_into_buf" title="request_firmware_into_buf"><code class="xref c c-func docutils literal"><span class="pre">request_firmware_into_buf()</span></code></a> or <a class="reference internal" href="#c.request_firmware_nowait" title="request_firmware_nowait"><code class="xref c c-func docutils literal"><span class="pre">request_firmware_nowait()</span></code></a> with no uevent set.</p>
<dl class="function">
<dt id="c.request_firmware_into_buf">
int <code class="descname">request_firmware_into_buf</code><span class="sig-paren">(</span>const struct firmware **<em>&nbsp;firmware_p</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em>, void *<em>&nbsp;buf</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_into_buf" title="Permalink to this definition">Â¶</a></dt>
<dd><p>load firmware into a previously allocated buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">**</span> <span class="pre">firmware_p</span></code></dt>
<dd>pointer to firmware image</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded and DMA region allocated</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>address of buffer to load firmware into</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of buffer</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function works pretty much like <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal"><span class="pre">request_firmware()</span></code></a>, but it doesn&#8217;t
allocate a buffer to hold the firmware data. Instead, the firmware
is loaded directly into the buffer pointed to by <strong>buf</strong> and the <strong>firmware_p</strong>
data member is pointed at <strong>buf</strong>.</p>
<p>This function doesn&#8217;t cache firmware either.</p>
<dl class="function">
<dt id="c.release_firmware">
void <code class="descname">release_firmware</code><span class="sig-paren">(</span>const struct firmware *<em>&nbsp;fw</em><span class="sig-paren">)</span><a class="headerlink" href="#c.release_firmware" title="Permalink to this definition">Â¶</a></dt>
<dd><p>release the resource associated with a firmware image</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">*</span> <span class="pre">fw</span></code></dt>
<dd>firmware resource to release</dd>
</dl>
<dl class="function">
<dt id="c.request_firmware_nowait">
int <code class="descname">request_firmware_nowait</code><span class="sig-paren">(</span>struct module *<em>&nbsp;module</em>, bool<em>&nbsp;uevent</em>, const char *<em>&nbsp;name</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;device</em>, gfp_t<em>&nbsp;gfp</em>, void *<em>&nbsp;context</em>, void (*cont) (const struct firmware<em>&nbsp;*fw</em>, void<em>&nbsp;*context</em><span class="sig-paren">)</span><a class="headerlink" href="#c.request_firmware_nowait" title="Permalink to this definition">Â¶</a></dt>
<dd><p>asynchronous version of request_firmware</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>module requesting the firmware</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">uevent</span></code></dt>
<dd>sends uevent to copy the firmware image if this flag
is non-zero else the firmware copy must be done manually.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of firmware file</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">device</span></code></dt>
<dd>device for which firmware is being loaded</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>allocation flags</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">context</span></code></dt>
<dd>will be passed over to <strong>cont</strong>, and
<strong>fw</strong> may be <code class="docutils literal"><span class="pre">NULL</span></code> if firmware request fails.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">(*)(const</span> <span class="pre">struct</span> <span class="pre">firmware</span> <span class="pre">*fw,</span> <span class="pre">void</span> <span class="pre">*context)</span> <span class="pre">cont</span></code></dt>
<dd>function will be called asynchronously when the firmware
request is over.</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Caller must hold the reference count of <strong>device</strong>.</p>
<dl class="docutils">
<dt>Asynchronous variant of <a class="reference internal" href="#c.request_firmware" title="request_firmware"><code class="xref c c-func docutils literal"><span class="pre">request_firmware()</span></code></a> for user contexts:</dt>
<dd><ul class="first last simple">
<li>sleep for as small periods as possible since it may
increase kernel boot time of built-in device drivers
requesting firmware in their -&gt;:c:func:<cite>probe()</cite> methods, if
<strong>gfp</strong> is GFP_KERNEL.</li>
<li>can&#8217;t sleep at all if <strong>gfp</strong> is GFP_ATOMIC.</li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="function">
<dt id="c.transport_class_register">
int <code class="descname">transport_class_register</code><span class="sig-paren">(</span>struct transport_class *<em>&nbsp;tclass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_class_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register an initial transport class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">transport_class</span> <span class="pre">*</span> <span class="pre">tclass</span></code></dt>
<dd>a pointer to the transport class structure to be initialised</dd>
</dl>
<p><strong>Description</strong></p>
<p>The transport class contains an embedded class which is used to
identify it.  The caller should initialise this structure with
zeros and then generic class must have been initialised with the
actual transport class unique name.  There&#8217;s a macro
<code class="xref c c-func docutils literal"><span class="pre">DECLARE_TRANSPORT_CLASS()</span></code> to do this (declared classes still must
be registered).</p>
<p>Returns 0 on success or error on failure.</p>
<dl class="function">
<dt id="c.transport_class_unregister">
void <code class="descname">transport_class_unregister</code><span class="sig-paren">(</span>struct transport_class *<em>&nbsp;tclass</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_class_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister a previously registered class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">transport_class</span> <span class="pre">*</span> <span class="pre">tclass</span></code></dt>
<dd>The transport class to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called prior to deallocating the memory for the transport
class.</p>
<dl class="function">
<dt id="c.anon_transport_class_register">
int <code class="descname">anon_transport_class_register</code><span class="sig-paren">(</span>struct anon_transport_class *<em>&nbsp;atc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_transport_class_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register an anonymous class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">anon_transport_class</span> <span class="pre">*</span> <span class="pre">atc</span></code></dt>
<dd>The anon transport class to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>The anonymous transport class contains both a transport class and a
container.  The idea of an anonymous class is that it never
actually has any device attributes associated with it (and thus
saves on container storage).  So it can only be used for triggering
events.  Use prezero and then use <code class="xref c c-func docutils literal"><span class="pre">DECLARE_ANON_TRANSPORT_CLASS()</span></code> to
initialise the anon transport class storage.</p>
<dl class="function">
<dt id="c.anon_transport_class_unregister">
void <code class="descname">anon_transport_class_unregister</code><span class="sig-paren">(</span>struct anon_transport_class *<em>&nbsp;atc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.anon_transport_class_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister an anon class</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">anon_transport_class</span> <span class="pre">*</span> <span class="pre">atc</span></code></dt>
<dd>Pointer to the anon transport class to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Must be called prior to deallocating the memory for the anon
transport class.</p>
<dl class="function">
<dt id="c.transport_setup_device">
void <code class="descname">transport_setup_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_setup_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>declare a new dev for transport class association but don&#8217;t make it visible yet.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the generic device representing the entity being added</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point to see if any set of transport
classes wishes to associate with the added device.  This allocates
storage for the class device and initialises it, but does not yet
add it to the system or add attributes to it (you do this with
transport_add_device).  If you have no need for a separate setup
and add operations, use transport_register_device (see
transport_class.h).</p>
<dl class="function">
<dt id="c.transport_add_device">
void <code class="descname">transport_add_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_add_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>declare a new dev for transport class association</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the generic device representing the entity being added</dd>
</dl>
<p><strong>Description</strong></p>
<p>Usually, dev represents some component in the HBA system (either
the HBA itself or a device remote across the HBA bus).  This
routine is simply a trigger point used to add the device to the
system and register attributes for it.</p>
<dl class="function">
<dt id="c.transport_configure_device">
void <code class="descname">transport_configure_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_configure_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>configure an already set up device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>generic device representing device to be configured</dd>
</dl>
<p><strong>Description</strong></p>
<p>The idea of configure is simply to provide a point within the setup
process to allow the transport class to extract information from a
device after it has been setup.  This is used in SCSI because we
have to have a setup device to begin using the HBA, but after we
send the initial inquiry, we use configure to extract the device
parameters.  The device need not have been added to be configured.</p>
<dl class="function">
<dt id="c.transport_remove_device">
void <code class="descname">transport_remove_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_remove_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove the visibility of a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>generic device to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call removes the visibility of the device (to the user from
sysfs), but does not destroy it.  To eliminate a device entirely
you must also call transport_destroy_device.  If you don&#8217;t need to
do remove and destroy as separate operations, use
<code class="xref c c-func docutils literal"><span class="pre">transport_unregister_device()</span></code> (see transport_class.h) which will
perform both calls for you.</p>
<dl class="function">
<dt id="c.transport_destroy_device">
void <code class="descname">transport_destroy_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.transport_destroy_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>destroy a removed device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to eliminate from the transport class.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This call triggers the elimination of storage associated with the
transport classdev.  Note: all it really does is relinquish a
reference to the classdev.  The memory will not be freed until the
last reference goes to zero.  Note also that the classdev retains a
reference count on dev, so dev too will remain for as long as the
transport class device remains around.</p>
<dl class="function">
<dt id="c.device_bind_driver">
int <code class="descname">device_bind_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_bind_driver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>bind a driver to one device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Allow manual attachment of a driver to a device.
Caller must have already set <strong>dev</strong>-&gt;driver.</p>
<p>Note that this does not modify the bus reference count
nor take the bus&#8217;s rwsem. Please verify those are accounted
for before calling this. (It is ok to call with no other effort
from a driver&#8217;s <code class="xref c c-func docutils literal"><span class="pre">probe()</span></code> method.)</p>
<p>This function must be called with the device lock held.</p>
<dl class="function">
<dt id="c.wait_for_device_probe">
void <code class="descname">wait_for_device_probe</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.wait_for_device_probe" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span></code></dt>
<dd>no arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>Wait for device probing to be completed.</p>
<dl class="function">
<dt id="c.device_attach">
int <code class="descname">device_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_attach" title="Permalink to this definition">Â¶</a></dt>
<dd><p>try to attach device to a driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of drivers that the bus has and call
<code class="xref c c-func docutils literal"><span class="pre">driver_probe_device()</span></code> for each pair. If a compatible
pair is found, break out and return.</p>
<p>Returns 1 if the device was bound to a driver;
0 if no matching driver was found;
-ENODEV if the device is not registered.</p>
<p>When called for a USB interface, <strong>dev</strong>-&gt;parent lock must be held.</p>
<dl class="function">
<dt id="c.driver_attach">
int <code class="descname">driver_attach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.driver_attach" title="Permalink to this definition">Â¶</a></dt>
<dd><p>try to bind driver to devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Walk the list of devices that the bus has on it and try to
match the driver with each one.  If <code class="xref c c-func docutils literal"><span class="pre">driver_probe_device()</span></code>
returns 0 and the <strong>dev</strong>-&gt;driver is set, we&#8217;ve found a
compatible pair.</p>
<dl class="function">
<dt id="c.device_release_driver">
void <code class="descname">device_release_driver</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_release_driver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>manually detach device from driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Manually detach device from driver.
When called for a USB interface, <strong>dev</strong>-&gt;parent lock must be held.</p>
<p>If this function is to be called with <strong>dev</strong>-&gt;parent lock held, ensure that
the device&#8217;s consumers are unbound in advance or that their locks can be
acquired under the <strong>dev</strong>-&gt;parent lock.</p>
<dl class="function">
<dt id="c.platform_device_register_resndata">
struct platform_device * <code class="descname">platform_device_register_resndata</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;id</em>, const struct resource *<em>&nbsp;res</em>, unsigned int<em>&nbsp;num</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_resndata" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a platform-level device with resources and platform-specific data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device for the device we&#8217;re adding</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>base name of the device we&#8217;re adding</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>instance id</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>set of resources that needs to be allocated for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of resources</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>platform specific data for this platform device</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of platform specific data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<dl class="function">
<dt id="c.platform_device_register_simple">
struct platform_device * <code class="descname">platform_device_register_simple</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, int<em>&nbsp;id</em>, const struct resource *<em>&nbsp;res</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_simple" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a platform-level device and its resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>base name of the device we&#8217;re adding</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>instance id</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>set of resources that needs to be allocated for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of resources</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.</p>
<p>This interface is primarily intended for use with legacy drivers which
probe hardware directly.  Because such drivers create sysfs device nodes
themselves, rather than letting system infrastructure handle such device
enumeration tasks, they don&#8217;t fully conform to the Linux driver model.
In particular, when such drivers are built as modules, they can&#8217;t be
&#8220;hotplugged&#8221;.</p>
<p>Returns <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<dl class="function">
<dt id="c.platform_device_register_data">
struct platform_device * <code class="descname">platform_device_register_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;id</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_data" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a platform-level device with platform-specific data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device for the device we&#8217;re adding</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>base name of the device we&#8217;re adding</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>instance id</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>platform specific data for this platform device</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of platform specific data</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function creates a simple platform device that requires minimal
resource and memory management. Canned release function freeing memory
allocated for the device allows drivers using such devices to be
unloaded without waiting for the last reference to the device to be
dropped.</p>
<p>Returns <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<dl class="function">
<dt id="c.platform_get_resource">
struct resource * <code class="descname">platform_get_resource</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_resource" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get a resource for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>resource type</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>resource index</dd>
</dl>
<dl class="function">
<dt id="c.platform_get_irq">
int <code class="descname">platform_get_irq</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get an IRQ for a device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>IRQ number index</dd>
</dl>
<dl class="function">
<dt id="c.platform_irq_count">
int <code class="descname">platform_irq_count</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_irq_count" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Count the number of IRQs a platform device uses</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
</dl>
<p><strong>Return</strong></p>
<p>Number of IRQs a platform device uses or EPROBE_DEFER</p>
<dl class="function">
<dt id="c.platform_get_resource_byname">
struct resource * <code class="descname">platform_get_resource_byname</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;type</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_resource_byname" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get a resource for a device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>resource type</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>resource name</dd>
</dl>
<dl class="function">
<dt id="c.platform_get_irq_byname">
int <code class="descname">platform_get_irq_byname</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;dev</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_get_irq_byname" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get an IRQ for a device by name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>platform device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>IRQ name</dd>
</dl>
<dl class="function">
<dt id="c.platform_add_devices">
int <code class="descname">platform_add_devices</code><span class="sig-paren">(</span>struct platform_device **<em>&nbsp;devs</em>, int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_add_devices" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a numbers of platform devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">**</span> <span class="pre">devs</span></code></dt>
<dd>array of platform devices to add</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of platform devices in array</dd>
</dl>
<dl class="function">
<dt id="c.platform_device_put">
void <code class="descname">platform_device_put</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>destroy a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free all memory associated with a platform device.  This function must
_only_ be externally called in error cases.  All other usage is a bug.</p>
<dl class="function">
<dt id="c.platform_device_alloc">
struct platform_device * <code class="descname">platform_device_alloc</code><span class="sig-paren">(</span>const char *<em>&nbsp;name</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_alloc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>base name of the device we&#8217;re adding</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>instance id</dd>
</dl>
<p><strong>Description</strong></p>
<p>Create a platform device object which can have other objects attached
to it, and which will have attached objects freed when it is released.</p>
<dl class="function">
<dt id="c.platform_device_add_resources">
int <code class="descname">platform_device_add_resources</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em>, const struct resource *<em>&nbsp;res</em>, unsigned int<em>&nbsp;num</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_resources" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add resources to a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device allocated by platform_device_alloc to add resources to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>set of resources that needs to be allocated for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num</span></code></dt>
<dd>number of resources</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a copy of the resources to the platform device.  The memory
associated with the resources will be freed when the platform device is
released.</p>
<dl class="function">
<dt id="c.platform_device_add_data">
int <code class="descname">platform_device_add_data</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_data" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add platform-specific data to a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device allocated by platform_device_alloc to add resources to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>platform specific data for this platform device</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of platform specific data</dd>
</dl>
<p><strong>Description</strong></p>
<p>Add a copy of platform specific data to the platform device&#8217;s
platform_data pointer.  The memory associated with the platform data
will be freed when the platform device is released.</p>
<dl class="function">
<dt id="c.platform_device_add_properties">
int <code class="descname">platform_device_add_properties</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em>, const struct property_entry *<em>&nbsp;properties</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add_properties" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add built-in properties to a platform device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device to add properties to</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">property_entry</span> <span class="pre">*</span> <span class="pre">properties</span></code></dt>
<dd>null terminated array of properties to add</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function will take deep copy of <strong>properties</strong> and attach the copy to the
platform device. The memory associated with properties will be freed when the
platform device is released.</p>
<dl class="function">
<dt id="c.platform_device_add">
int <code class="descname">platform_device_add</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_add" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a platform device to device hierarchy</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device we&#8217;re adding</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is part 2 of <a class="reference internal" href="#c.platform_device_register" title="platform_device_register"><code class="xref c c-func docutils literal"><span class="pre">platform_device_register()</span></code></a>, though may be called
separately _iff_ pdev was allocated by <a class="reference internal" href="#c.platform_device_alloc" title="platform_device_alloc"><code class="xref c c-func docutils literal"><span class="pre">platform_device_alloc()</span></code></a>.</p>
<dl class="function">
<dt id="c.platform_device_del">
void <code class="descname">platform_device_del</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_del" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove a platform-level device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device we&#8217;re removing</dd>
</dl>
<p><strong>Description</strong></p>
<p>Note that this function will also release all memory- and port-based
resources owned by the device (<strong>dev</strong>-&gt;resource).  This function must
_only_ be externally called in error cases.  All other usage is a bug.</p>
<dl class="function">
<dt id="c.platform_device_register">
int <code class="descname">platform_device_register</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a platform-level device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device we&#8217;re adding</dd>
</dl>
<dl class="function">
<dt id="c.platform_device_unregister">
void <code class="descname">platform_device_unregister</code><span class="sig-paren">(</span>struct platform_device *<em>&nbsp;pdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister a platform-level device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span> <span class="pre">*</span> <span class="pre">pdev</span></code></dt>
<dd>platform device we&#8217;re unregistering</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregistration is done in 2 steps. First we release all resources
and remove it from the subsystem, then we drop reference count by
calling <a class="reference internal" href="#c.platform_device_put" title="platform_device_put"><code class="xref c c-func docutils literal"><span class="pre">platform_device_put()</span></code></a>.</p>
<dl class="function">
<dt id="c.platform_device_register_full">
struct platform_device * <code class="descname">platform_device_register_full</code><span class="sig-paren">(</span>const struct platform_device_info *<em>&nbsp;pdevinfo</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_device_register_full" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a platform-level device with resources and platform-specific data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">platform_device_info</span> <span class="pre">*</span> <span class="pre">pdevinfo</span></code></dt>
<dd>data used to create device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<dl class="function">
<dt id="c.__platform_driver_register">
int <code class="descname">__platform_driver_register</code><span class="sig-paren">(</span>struct platform_driver *<em>&nbsp;drv</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_driver_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a driver for platform-level devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>platform driver structure</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>owning module/driver</dd>
</dl>
<dl class="function">
<dt id="c.platform_driver_unregister">
void <code class="descname">platform_driver_unregister</code><span class="sig-paren">(</span>struct platform_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_driver_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister a driver for platform-level devices</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>platform driver structure</dd>
</dl>
<dl class="function">
<dt id="c.__platform_driver_probe">
int <code class="descname">__platform_driver_probe</code><span class="sig-paren">(</span>struct platform_driver *<em>&nbsp;drv</em>, int (*probe) (struct platform_device<em>&nbsp;*</em>, struct module *<em>&nbsp;module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_driver_probe" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register driver for non-hotpluggable device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>platform driver structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">platform_device</span> <span class="pre">*)</span> <span class="pre">probe</span></code></dt>
<dd>the driver probe routine, probably from an __init section</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>module which will be the owner of the driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this instead of <code class="xref c c-func docutils literal"><span class="pre">platform_driver_register()</span></code> when you know the device
is not hotpluggable and has already been registered, and you want to
remove its run-once <code class="xref c c-func docutils literal"><span class="pre">probe()</span></code> infrastructure from memory after the driver
has bound to the device.</p>
<p>One typical use for this would be with drivers for controllers integrated
into system-on-chip processors, where the controller devices have been
configured as part of board setup.</p>
<p>Note that this is incompatible with deferred probing.</p>
<p>Returns zero if the driver registered and bound to a device, else returns
a negative error code and with the driver not registered.</p>
<dl class="function">
<dt id="c.__platform_create_bundle">
struct platform_device * <code class="descname">__platform_create_bundle</code><span class="sig-paren">(</span>struct platform_driver *<em>&nbsp;driver</em>, int (*probe) (struct platform_device<em>&nbsp;*</em>, struct resource *<em>&nbsp;res</em>, unsigned int<em>&nbsp;n_res</em>, const void *<em>&nbsp;data</em>, size_t<em>&nbsp;size</em>, struct module *<em>&nbsp;module</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_create_bundle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register driver and create corresponding device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*</span> <span class="pre">driver</span></code></dt>
<dd>platform driver structure</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">platform_device</span> <span class="pre">*)</span> <span class="pre">probe</span></code></dt>
<dd>the driver probe routine, probably from an __init section</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">resource</span> <span class="pre">*</span> <span class="pre">res</span></code></dt>
<dd>set of resources that needs to be allocated for the device</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">n_res</span></code></dt>
<dd>number of resources</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>platform specific data for this platform device</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of platform specific data</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">module</span></code></dt>
<dd>module which will be the owner of the driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Use this in legacy-style modules that probe hardware directly and
register a single platform device and corresponding platform driver.</p>
<p>Returns <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">platform_device</span></code> pointer on success, or <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on error.</p>
<dl class="function">
<dt id="c.__platform_register_drivers">
int <code class="descname">__platform_register_drivers</code><span class="sig-paren">(</span>struct platform_driver *const *<em>&nbsp;drivers</em>, unsigned int<em>&nbsp;count</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__platform_register_drivers" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register an array of platform drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">drivers</span></code></dt>
<dd>an array of drivers to register</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of drivers to register</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>module owning the drivers</dd>
</dl>
<p><strong>Description</strong></p>
<p>Registers platform drivers specified by an array. On failure to register a
driver, all previously registered drivers will be unregistered. Callers of
this API should use <a class="reference internal" href="#c.platform_unregister_drivers" title="platform_unregister_drivers"><code class="xref c c-func docutils literal"><span class="pre">platform_unregister_drivers()</span></code></a> to unregister drivers in
the reverse order.</p>
<p><strong>Return</strong></p>
<p>0 on success or a negative error code on failure.</p>
<dl class="function">
<dt id="c.platform_unregister_drivers">
void <code class="descname">platform_unregister_drivers</code><span class="sig-paren">(</span>struct platform_driver *const *<em>&nbsp;drivers</em>, unsigned int<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.platform_unregister_drivers" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister an array of platform drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">platform_driver</span> <span class="pre">*const</span> <span class="pre">*</span> <span class="pre">drivers</span></code></dt>
<dd>an array of drivers to unregister</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">count</span></code></dt>
<dd>the number of drivers to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unegisters platform drivers specified by an array. This is typically used
to complement an earlier call to <code class="xref c c-func docutils literal"><span class="pre">platform_register_drivers()</span></code>. Drivers are
unregistered in the reverse order in which they were registered.</p>
<dl class="function">
<dt id="c.bus_for_each_dev">
int <code class="descname">bus_for_each_dev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;bus</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_for_each_dev" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device iterator.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus type.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>device to start iterating from.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data for the callback.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>function to be called for each device.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Iterate over <strong>bus</strong>&#8216;s list of devices, and call <strong>fn</strong> for each,
passing it <strong>data</strong>. If <strong>start</strong> is not NULL, we use that device to
begin iterating from.</p>
<p>We check the return of <strong>fn</strong> each time. If it returns anything
other than 0, we break out and return that value.</p>
<p><strong>NOTE</strong></p>
<p>The device that returns a non-zero value is not retained
in any way, nor is its refcount incremented. If the caller needs
to retain this data, it should do so, and increment the reference
count in the supplied callback.</p>
<dl class="function">
<dt id="c.bus_find_device">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">bus_find_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;bus</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.device" title="device">device</a><em>&nbsp;*dev</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device iterator for locating a particular device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus type</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>Data to pass to match function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device</span> <span class="pre">*dev,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">match</span></code></dt>
<dd>Callback function to check device</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.bus_for_each_dev" title="bus_for_each_dev"><code class="xref c c-func docutils literal"><span class="pre">bus_for_each_dev()</span></code></a> function above, but it
returns a reference to a device that is &#8216;found&#8217; for later use, as
determined by the <strong>match</strong> callback.</p>
<p>The callback should return 0 if the device doesn&#8217;t match and non-zero
if it does.  If the callback returns non-zero, this function will
return to the caller and not iterate over any more devices.</p>
<dl class="function">
<dt id="c.bus_find_device_by_name">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">bus_find_device_by_name</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;bus</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_find_device_by_name" title="Permalink to this definition">Â¶</a></dt>
<dd><p>device iterator for locating a particular device of a specific name</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus type</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>Device to begin with</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the device to match</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is similar to the <a class="reference internal" href="#c.bus_find_device" title="bus_find_device"><code class="xref c c-func docutils literal"><span class="pre">bus_find_device()</span></code></a> function above, but it handles
searching by a name automatically, no need to write another strcmp matching
function.</p>
<dl class="function">
<dt id="c.subsys_find_device_by_id">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">subsys_find_device_by_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;subsys</em>, unsigned int<em>&nbsp;id</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;hint</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_find_device_by_id" title="Permalink to this definition">Â¶</a></dt>
<dd><p>find a device with a specific enumeration number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">subsys</span></code></dt>
<dd>subsystem</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">id</span></code></dt>
<dd>index &#8216;id&#8217; in struct device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">hint</span></code></dt>
<dd>device to check first</dd>
</dl>
<p><strong>Description</strong></p>
<p>Check the hint&#8217;s next object and if it is a match return it directly,
otherwise, fall back to a full list search. Either way a reference for
the returned object is taken.</p>
<dl class="function">
<dt id="c.bus_for_each_drv">
int <code class="descname">bus_for_each_drv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;bus</em>, struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a> *<em>&nbsp;start</em>, void *<em>&nbsp;data</em>, int (*fn) (struct <a class="reference internal" href="#c.device_driver" title="device_driver">device_driver</a><em>&nbsp;*</em>, void<em>&nbsp;*</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_for_each_drv" title="Permalink to this definition">Â¶</a></dt>
<dd><p>driver iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus we&#8217;re dealing with.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>driver to start iterating on.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data to pass to the callback.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">device_driver</span> <span class="pre">*,</span> <span class="pre">void</span> <span class="pre">*)</span> <span class="pre">fn</span></code></dt>
<dd>function to call for each driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is nearly identical to the device iterator above.
We iterate over each driver that belongs to <strong>bus</strong>, and call
<strong>fn</strong> for each. If <strong>fn</strong> returns anything but 0, we break out
and return it. If <strong>start</strong> is not NULL, we use it as the head
of the list.</p>
<p><strong>NOTE</strong></p>
<p>we don&#8217;t return the driver that returns a non-zero
value, nor do we leave the reference count incremented for that
driver. If the caller needs to know that info, it must set it
in the callback. It must also be sure to increment the refcount
so it doesn&#8217;t disappear before returning to the caller.</p>
<dl class="function">
<dt id="c.bus_rescan_devices">
int <code class="descname">bus_rescan_devices</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_rescan_devices" title="Permalink to this definition">Â¶</a></dt>
<dd><p>rescan devices on the bus for possible drivers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>the bus to scan.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will look for devices on the bus with no driver
attached and rescan it against existing drivers to see if it matches
any by calling <a class="reference internal" href="#c.device_attach" title="device_attach"><code class="xref c c-func docutils literal"><span class="pre">device_attach()</span></code></a> for the unbound devices.</p>
<dl class="function">
<dt id="c.device_reprobe">
int <code class="descname">device_reprobe</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_reprobe" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove driver for a device and probe for a new driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device to reprobe</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function detaches the attached driver (if any) for the given
device and restarts the driver probing process.  It is intended
to use if probing criteria changed during a devices lifetime and
driver attachment should change accordingly.</p>
<dl class="function">
<dt id="c.bus_register">
int <code class="descname">bus_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a driver-core subsystem</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus to register</dd>
</dl>
<p><strong>Description</strong></p>
<p>Once we have that, we register the bus with the kobject
infrastructure, then register the children subsystems it has:
the devices and drivers that belong to the subsystem.</p>
<dl class="function">
<dt id="c.bus_unregister">
void <code class="descname">bus_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;bus</em><span class="sig-paren">)</span><a class="headerlink" href="#c.bus_unregister" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove a bus from the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">bus</span></code></dt>
<dd>bus.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Unregister the child subsystems and the bus itself.
Finally, we call <code class="xref c c-func docutils literal"><span class="pre">bus_put()</span></code> to release the refcount</p>
<dl class="function">
<dt id="c.subsys_dev_iter_init">
void <code class="descname">subsys_dev_iter_init</code><span class="sig-paren">(</span>struct subsys_dev_iter *<em>&nbsp;iter</em>, struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;subsys</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;start</em>, const struct device_type *<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_init" title="Permalink to this definition">Â¶</a></dt>
<dd><p>initialize subsys device iterator</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>subsys iterator to initialize</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">subsys</span></code></dt>
<dd>the subsys we wanna iterate over</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">start</span></code></dt>
<dd>the device to start iterating from, if any</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">device_type</span> <span class="pre">*</span> <span class="pre">type</span></code></dt>
<dd>device_type of the devices to iterate over, NULL for all</dd>
</dl>
<p><strong>Description</strong></p>
<p>Initialize subsys iterator <strong>iter</strong> such that it iterates over devices
of <strong>subsys</strong>.  If <strong>start</strong> is set, the list iteration will start there,
otherwise if it is NULL, the iteration starts at the beginning of
the list.</p>
<dl class="function">
<dt id="c.subsys_dev_iter_next">
struct <a class="reference internal" href="#c.device" title="device">device</a> * <code class="descname">subsys_dev_iter_next</code><span class="sig-paren">(</span>struct subsys_dev_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_next" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterate to the next device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>subsys iterator to proceed</dd>
</dl>
<p><strong>Description</strong></p>
<p>Proceed <strong>iter</strong> to the next device and return it.  Returns NULL if
iteration is complete.</p>
<p>The returned device is referenced and won&#8217;t be released till
iterator is proceed to the next device or exited.  The caller is
free to do whatever it wants to do with the device including
calling back into subsys code.</p>
<dl class="function">
<dt id="c.subsys_dev_iter_exit">
void <code class="descname">subsys_dev_iter_exit</code><span class="sig-paren">(</span>struct subsys_dev_iter *<em>&nbsp;iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_dev_iter_exit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>finish iteration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">subsys_dev_iter</span> <span class="pre">*</span> <span class="pre">iter</span></code></dt>
<dd>subsys iterator to finish</dd>
</dl>
<p><strong>Description</strong></p>
<p>Finish an iteration.  Always call this function after iteration is
complete whether the iteration ran till the end or not.</p>
<dl class="function">
<dt id="c.subsys_system_register">
int <code class="descname">subsys_system_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;subsys</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_system_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a subsystem at /sys/devices/system/</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">subsys</span></code></dt>
<dd>system subsystem</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>default attributes for the root device</dd>
</dl>
<p><strong>Description</strong></p>
<p>All &#8216;system&#8217; subsystems have a /sys/devices/system/&lt;name&gt; root device
with the name of the subsystem. The root device can carry subsystem-
wide attributes. All registered devices are below this single root
device and are named after the subsystem with a simple enumeration
number appended. The registered devices are not explicitly named;
only &#8216;id&#8217; in the device needs to be set.</p>
<p>Do not use this interface for anything new, it exists for compatibility
with bad ideas only. New subsystems should use plain subsystems; and
add the subsystem-wide attributes should be added to the subsystem
directory itself and not some create fake root-device placed in
/sys/devices/system/&lt;name&gt;.</p>
<dl class="function">
<dt id="c.subsys_virtual_register">
int <code class="descname">subsys_virtual_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.bus_type" title="bus_type">bus_type</a> *<em>&nbsp;subsys</em>, const struct attribute_group **<em>&nbsp;groups</em><span class="sig-paren">)</span><a class="headerlink" href="#c.subsys_virtual_register" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a subsystem at /sys/devices/virtual/</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span> <span class="pre">*</span> <span class="pre">subsys</span></code></dt>
<dd>virtual subsystem</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">attribute_group</span> <span class="pre">**</span> <span class="pre">groups</span></code></dt>
<dd>default attributes for the root device</dd>
</dl>
<p><strong>Description</strong></p>
<p>All &#8216;virtual&#8217; subsystems have a /sys/devices/system/&lt;name&gt; root device
with the name of the subystem.  The root device can carry subsystem-wide
attributes.  All registered devices are below this single root device.
There&#8217;s no restriction on device naming.  This is for kernel software
constructs which need sysfs interface.</p>
</div>
<div class="section" id="device-drivers-dma-management">
<h2>Device Drivers DMA Management<a class="headerlink" href="#device-drivers-dma-management" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.dma_alloc_from_dev_coherent">
int <code class="descname">dma_alloc_from_dev_coherent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, ssize_t<em>&nbsp;size</em>, dma_addr_t *<em>&nbsp;dma_handle</em>, void **<em>&nbsp;ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_alloc_from_dev_coherent" title="Permalink to this definition">Â¶</a></dt>
<dd><p>allocate memory from device coherent pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device from which we allocate memory</dd>
<dt><code class="docutils literal"><span class="pre">ssize_t</span> <span class="pre">size</span></code></dt>
<dd>size of requested memory area</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">dma_handle</span></code></dt>
<dd>This will be filled with the correct dma handle</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">**</span> <span class="pre">ret</span></code></dt>
<dd>This pointer will be filled with the virtual address
to allocated area.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be only called from per-arch <code class="xref c c-func docutils literal"><span class="pre">dma_alloc_coherent()</span></code>
to support allocation from per-device coherent memory pools.</p>
<p>Returns 0 if dma_alloc_coherent should continue with allocating from
generic memory areas, or !0 if dma_alloc_coherent should return <strong>ret</strong>.</p>
<dl class="function">
<dt id="c.dma_release_from_dev_coherent">
int <code class="descname">dma_release_from_dev_coherent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, int<em>&nbsp;order</em>, void *<em>&nbsp;vaddr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_release_from_dev_coherent" title="Permalink to this definition">Â¶</a></dt>
<dd><p>free memory to device coherent memory pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device from which the memory was allocated</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">order</span></code></dt>
<dd>the order of pages allocated</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>virtual address of allocated pages</dd>
</dl>
<p><strong>Description</strong></p>
<p>This checks whether the memory was allocated from the per-device
coherent memory pool and if so, releases that memory.</p>
<p>Returns 1 if we correctly released the memory, or 0 if the caller should
proceed with releasing memory from generic pools.</p>
<dl class="function">
<dt id="c.dma_mmap_from_dev_coherent">
int <code class="descname">dma_mmap_from_dev_coherent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct vm_area_struct *<em>&nbsp;vma</em>, void *<em>&nbsp;vaddr</em>, size_t<em>&nbsp;size</em>, int *<em>&nbsp;ret</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dma_mmap_from_dev_coherent" title="Permalink to this definition">Â¶</a></dt>
<dd><p>mmap memory from the device coherent pool</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device from which the memory was allocated</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>vm_area for the userspace memory</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>cpu address returned by dma_alloc_from_dev_coherent</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>size of the memory buffer allocated</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">ret</span></code></dt>
<dd>result from <a class="reference internal" href="../core-api/mm-api.html#c.remap_pfn_range" title="remap_pfn_range"><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This checks whether the memory was allocated from the per-device
coherent memory pool and if so, maps that memory to the provided vma.</p>
<p>Returns 1 if <strong>vaddr</strong> belongs to the device coherent pool and the caller
should return <strong>ret</strong>, or 0 if they should proceed with mapping memory from
generic areas.</p>
<dl class="function">
<dt id="c.dmam_alloc_coherent">
void * <code class="descname">dmam_alloc_coherent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, dma_addr_t *<em>&nbsp;dma_handle</em>, gfp_t<em>&nbsp;gfp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_alloc_coherent" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_alloc_coherent()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate coherent memory for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of allocation</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">dma_handle</span></code></dt>
<dd>Out argument for allocated DMA handle</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Allocation flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_alloc_coherent()</span></code>.  Memory allocated using this function
will be automatically released on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="function">
<dt id="c.dmam_free_coherent">
void <code class="descname">dmam_free_coherent</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, void *<em>&nbsp;vaddr</em>, dma_addr_t<em>&nbsp;dma_handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_free_coherent" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_free_coherent()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to free coherent memory for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of allocation</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">vaddr</span></code></dt>
<dd>Virtual address of the memory to free</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">dma_handle</span></code></dt>
<dd>DMA handle of the memory to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_free_coherent()</span></code>.</p>
<dl class="function">
<dt id="c.dmam_alloc_attrs">
void * <code class="descname">dmam_alloc_attrs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, size_t<em>&nbsp;size</em>, dma_addr_t *<em>&nbsp;dma_handle</em>, gfp_t<em>&nbsp;gfp</em>, unsigned long<em>&nbsp;attrs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_alloc_attrs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_alloc_attrs()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to allocate non_coherent memory for</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of allocation</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">*</span> <span class="pre">dma_handle</span></code></dt>
<dd>Out argument for allocated DMA handle</dd>
<dt><code class="docutils literal"><span class="pre">gfp_t</span> <span class="pre">gfp</span></code></dt>
<dd>Allocation flags</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">attrs</span></code></dt>
<dd>Flags in the DMA_ATTR_* namespace.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_alloc_attrs()</span></code>.  Memory allocated using this function will be
automatically released on driver detach.</p>
<p><strong>Return</strong></p>
<p>Pointer to allocated memory on success, NULL on failure.</p>
<dl class="function">
<dt id="c.dmam_declare_coherent_memory">
int <code class="descname">dmam_declare_coherent_memory</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em>, phys_addr_t<em>&nbsp;phys_addr</em>, dma_addr_t<em>&nbsp;device_addr</em>, size_t<em>&nbsp;size</em>, int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_declare_coherent_memory" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_declare_coherent_memory()</span></code></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to declare coherent memory for</dd>
<dt><code class="docutils literal"><span class="pre">phys_addr_t</span> <span class="pre">phys_addr</span></code></dt>
<dd>Physical address of coherent memory to be declared</dd>
<dt><code class="docutils literal"><span class="pre">dma_addr_t</span> <span class="pre">device_addr</span></code></dt>
<dd>Device address of coherent memory to be declared</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">size</span></code></dt>
<dd>Size of coherent memory to be declared</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>Flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_declare_coherent_memory()</span></code>.</p>
<p><strong>Return</strong></p>
<p>0 on success, -errno on failure.</p>
<dl class="function">
<dt id="c.dmam_release_declared_memory">
void <code class="descname">dmam_release_declared_memory</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dmam_release_declared_memory" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Managed <code class="xref c c-func docutils literal"><span class="pre">dma_release_declared_memory()</span></code>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>Device to release declared coherent memory for</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.dmam_release_declared_memory" title="dmam_release_declared_memory"><code class="xref c c-func docutils literal"><span class="pre">dmam_release_declared_memory()</span></code></a>.</p>
</div>
<div class="section" id="device-drivers-pnp-support">
<h2>Device drivers PnP support<a class="headerlink" href="#device-drivers-pnp-support" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.pnp_register_protocol">
int <code class="descname">pnp_register_protocol</code><span class="sig-paren">(</span>struct pnp_protocol *<em>&nbsp;protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_register_protocol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>adds a pnp protocol to the pnp layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_protocol</span> <span class="pre">*</span> <span class="pre">protocol</span></code></dt>
<dd>pointer to the corresponding pnp_protocol structure</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Ex protocols: ISAPNP, PNPBIOS, etc</div></blockquote>
<dl class="function">
<dt id="c.pnp_unregister_protocol">
void <code class="descname">pnp_unregister_protocol</code><span class="sig-paren">(</span>struct pnp_protocol *<em>&nbsp;protocol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_unregister_protocol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>removes a pnp protocol from the pnp layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_protocol</span> <span class="pre">*</span> <span class="pre">protocol</span></code></dt>
<dd>pointer to the corresponding pnp_protocol structure</dd>
</dl>
<dl class="function">
<dt id="c.pnp_request_card_device">
struct pnp_dev * <code class="descname">pnp_request_card_device</code><span class="sig-paren">(</span>struct pnp_card_link *<em>&nbsp;clink</em>, const char *<em>&nbsp;id</em>, struct pnp_dev *<em>&nbsp;from</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_request_card_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Searches for a PnP device under the specified card</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_card_link</span> <span class="pre">*</span> <span class="pre">clink</span></code></dt>
<dd>pointer to the card link, cannot be NULL</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>pointer to a PnP ID structure that explains the rules for finding the device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">from</span></code></dt>
<dd>Starting place to search from. If NULL it will start from the beginning.</dd>
</dl>
<dl class="function">
<dt id="c.pnp_release_card_device">
void <code class="descname">pnp_release_card_device</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_release_card_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>call this when the driver no longer needs the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the PnP device structure</dd>
</dl>
<dl class="function">
<dt id="c.pnp_register_card_driver">
int <code class="descname">pnp_register_card_driver</code><span class="sig-paren">(</span>struct pnp_card_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_register_card_driver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>registers a PnP card driver with the PnP Layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_card_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>pointer to the driver to register</dd>
</dl>
<dl class="function">
<dt id="c.pnp_unregister_card_driver">
void <code class="descname">pnp_unregister_card_driver</code><span class="sig-paren">(</span>struct pnp_card_driver *<em>&nbsp;drv</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_unregister_card_driver" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregisters a PnP card driver from the PnP Layer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_card_driver</span> <span class="pre">*</span> <span class="pre">drv</span></code></dt>
<dd>pointer to the driver to unregister</dd>
</dl>
<dl class="function">
<dt id="c.pnp_add_id">
struct pnp_id * <code class="descname">pnp_add_id</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em>, const char *<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_add_id" title="Permalink to this definition">Â¶</a></dt>
<dd><p>adds an EISA id to the specified device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">id</span></code></dt>
<dd>pointer to an EISA id string</dd>
</dl>
<dl class="function">
<dt id="c.pnp_start_dev">
int <code class="descname">pnp_start_dev</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_start_dev" title="Permalink to this definition">Â¶</a></dt>
<dd><p>low-level start of the PnP device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
</dl>
<p><strong>Description</strong></p>
<p>assumes that resources have already been allocated</p>
<dl class="function">
<dt id="c.pnp_stop_dev">
int <code class="descname">pnp_stop_dev</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_stop_dev" title="Permalink to this definition">Â¶</a></dt>
<dd><p>low-level disable of the PnP device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
</dl>
<p><strong>Description</strong></p>
<p>does not free resources</p>
<dl class="function">
<dt id="c.pnp_activate_dev">
int <code class="descname">pnp_activate_dev</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_activate_dev" title="Permalink to this definition">Â¶</a></dt>
<dd><p>activates a PnP device for use</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
</dl>
<p><strong>Description</strong></p>
<p>does not validate or set resources so be careful.</p>
<dl class="function">
<dt id="c.pnp_disable_dev">
int <code class="descname">pnp_disable_dev</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_disable_dev" title="Permalink to this definition">Â¶</a></dt>
<dd><p>disables device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired device</dd>
</dl>
<p><strong>Description</strong></p>
<p>inform the correct pnp protocol so that resources can be used by other devices</p>
<dl class="function">
<dt id="c.pnp_is_active">
int <code class="descname">pnp_is_active</code><span class="sig-paren">(</span>struct pnp_dev *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.pnp_is_active" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Determines if a device is active based on its current resources</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pnp_dev</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>pointer to the desired PnP device</dd>
</dl>
</div>
<div class="section" id="userspace-io-devices">
<h2>Userspace IO devices<a class="headerlink" href="#userspace-io-devices" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.uio_event_notify">
void <code class="descname">uio_event_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_event_notify" title="Permalink to this definition">Â¶</a></dt>
<dd><p>trigger an interrupt event</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>UIO device capabilities</dd>
</dl>
<dl class="function">
<dt id="c.__uio_register_device">
int <code class="descname">__uio_register_device</code><span class="sig-paren">(</span>struct module *<em>&nbsp;owner</em>, struct <a class="reference internal" href="#c.device" title="device">device</a> *<em>&nbsp;parent</em>, struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__uio_register_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a new userspace IO device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>module that creates the new device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">parent</span></code></dt>
<dd>parent device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>UIO device capabilities</dd>
</dl>
<p><strong>Description</strong></p>
<p>returns zero on success or a negative error code.</p>
<dl class="function">
<dt id="c.uio_unregister_device">
void <code class="descname">uio_unregister_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.uio_info" title="uio_info">uio_info</a> *<em>&nbsp;info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.uio_unregister_device" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister a industrial IO device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">uio_info</span> <span class="pre">*</span> <span class="pre">info</span></code></dt>
<dd>UIO device capabilities</dd>
</dl>
<dl class="type">
<dt id="c.uio_mem">
struct <code class="descname">uio_mem</code><a class="headerlink" href="#c.uio_mem" title="Permalink to this definition">Â¶</a></dt>
<dd><p>description of a UIO memory region</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct uio_mem {
  const char              *name;
  phys_addr_t addr;
  unsigned long           offs;
  resource_size_t size;
  int memtype;
  void __iomem            *internal_addr;
  struct uio_map          *map;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name of the memory region for identification</dd>
<dt><code class="docutils literal"><span class="pre">addr</span></code></dt>
<dd>address of the device&#8217;s memory rounded to page
size (phys_addr is used since addr can be
logical, virtual, or physical &amp; phys_addr_t
should always be large enough to handle any of
the address types)</dd>
<dt><code class="docutils literal"><span class="pre">offs</span></code></dt>
<dd>offset of device memory within the page</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size of IO (multiple of page size)</dd>
<dt><code class="docutils literal"><span class="pre">memtype</span></code></dt>
<dd>type of memory addr points to</dd>
<dt><code class="docutils literal"><span class="pre">internal_addr</span></code></dt>
<dd>ioremap-ped version of addr, for driver internal use</dd>
<dt><code class="docutils literal"><span class="pre">map</span></code></dt>
<dd>for use by the UIO core only.</dd>
</dl>
<dl class="type">
<dt id="c.uio_port">
struct <code class="descname">uio_port</code><a class="headerlink" href="#c.uio_port" title="Permalink to this definition">Â¶</a></dt>
<dd><p>description of a UIO port region</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct uio_port {
  const char              *name;
  unsigned long           start;
  unsigned long           size;
  int porttype;
  struct uio_portio       *portio;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name of the port region for identification</dd>
<dt><code class="docutils literal"><span class="pre">start</span></code></dt>
<dd>start of port region</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>size of port region</dd>
<dt><code class="docutils literal"><span class="pre">porttype</span></code></dt>
<dd>type of port (see UIO_PORT_* below)</dd>
<dt><code class="docutils literal"><span class="pre">portio</span></code></dt>
<dd>for use by the UIO core only.</dd>
</dl>
<dl class="type">
<dt id="c.uio_info">
struct <code class="descname">uio_info</code><a class="headerlink" href="#c.uio_info" title="Permalink to this definition">Â¶</a></dt>
<dd><p>UIO device capabilities</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct uio_info {
  struct uio_device       *uio_dev;
  const char              *name;
  const char              *version;
  struct uio_mem          mem[MAX_UIO_MAPS];
  struct uio_port         port[MAX_UIO_PORT_REGIONS];
  long irq;
  unsigned long           irq_flags;
  void *priv;
  irqreturn_t (*handler)(int irq, struct uio_info *dev_info);
  int (*mmap)(struct uio_info *info, struct vm_area_struct *vma);
  int (*open)(struct uio_info *info, struct inode *inode);
  int (*release)(struct uio_info *info, struct inode *inode);
  int (*irqcontrol)(struct uio_info *info, s32 irq_on);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">uio_dev</span></code></dt>
<dd>the UIO device this info belongs to</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>device name</dd>
<dt><code class="docutils literal"><span class="pre">version</span></code></dt>
<dd>device driver version</dd>
<dt><code class="docutils literal"><span class="pre">mem</span></code></dt>
<dd>list of mappable memory regions, size==0 for end of list</dd>
<dt><code class="docutils literal"><span class="pre">port</span></code></dt>
<dd>list of port regions, size==0 for end of list</dd>
<dt><code class="docutils literal"><span class="pre">irq</span></code></dt>
<dd>interrupt number or UIO_IRQ_CUSTOM</dd>
<dt><code class="docutils literal"><span class="pre">irq_flags</span></code></dt>
<dd>flags for <code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>optional private data</dd>
<dt><code class="docutils literal"><span class="pre">handler</span></code></dt>
<dd>the device&#8217;s irq handler</dd>
<dt><code class="docutils literal"><span class="pre">mmap</span></code></dt>
<dd>mmap operation for this uio device</dd>
<dt><code class="docutils literal"><span class="pre">open</span></code></dt>
<dd>open operation for this uio device</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>release operation for this uio device</dd>
<dt><code class="docutils literal"><span class="pre">irqcontrol</span></code></dt>
<dd>disable/enable irqs when 0/1 is written to /dev/uioX</dd>
</dl>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pm/index.html" class="btn btn-neutral float-right" title="Device Power Management" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="basics.html" class="btn btn-neutral" title="Driver Basics" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>