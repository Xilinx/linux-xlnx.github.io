

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>General Purpose Input/Output (GPIO) &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/>
        <link rel="up" title="The Linux driver implementerâ€™s API guide" href="../index.html"/>
        <link rel="next" title="Introduction" href="intro.html"/>
        <link rel="prev" title="PINCTRL (PIN CONTROL) subsystem" href="../pinctl.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas&#8217; 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">General Purpose Input/Output (GPIO)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="driver.html">GPIO Descriptor Driver Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="consumer.html">GPIO Descriptor Consumer Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="board.html">GPIO Mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="legacy.html">Legacy GPIO Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="#acpi-support">ACPI support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-tree-support">Device tree support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-managed-api">Device-managed API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sysfs-helpers">sysfs helpers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
    <li>General Purpose Input/Output (GPIO)</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/driver-api/gpio/index.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="general-purpose-input-output-gpio">
<h1>General Purpose Input/Output (GPIO)<a class="headerlink" href="#general-purpose-input-output-gpio" title="Permalink to this headline">Â¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html#gpio-interfaces">GPIO Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#what-is-a-gpio">What is a GPIO?</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#common-gpio-properties">Common GPIO Properties</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="driver.html">GPIO Descriptor Driver Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="driver.html#internal-representation-of-gpios">Internal Representation of GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="driver.html#controller-drivers-gpio-chip">Controller Drivers: gpio_chip</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="consumer.html">GPIO Descriptor Consumer Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#guidelines-for-gpios-consumers">Guidelines for GPIOs consumers</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#obtaining-and-disposing-gpios">Obtaining and Disposing GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#using-gpios">Using GPIOs</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#gpios-and-acpi">GPIOs and ACPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="consumer.html#interacting-with-the-legacy-gpio-subsystem">Interacting With the Legacy GPIO Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="board.html">GPIO Mappings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="board.html#device-tree">Device Tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="board.html#acpi">ACPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="board.html#platform-data">Platform Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="drivers-on-gpio.html">Subsystem drivers using GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="legacy.html">Legacy GPIO Interfaces</a><ul>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#what-is-a-gpio">What is a GPIO?</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#gpio-conventions">GPIO conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#what-do-these-conventions-omit">What do these conventions omit?</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#gpio-implementor-s-framework-optional">GPIO implementor&#8217;s framework (OPTIONAL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#sysfs-interface-for-userspace-optional">Sysfs Interface for Userspace (OPTIONAL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="legacy.html#api-reference">API Reference</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="core">
<h2>Core<a class="headerlink" href="#core" title="Permalink to this headline">Â¶</a></h2>
<dl class="type">
<dt id="c.gpio_irq_chip">
struct <code class="descname">gpio_irq_chip</code><a class="headerlink" href="#c.gpio_irq_chip" title="Permalink to this definition">Â¶</a></dt>
<dd><p>GPIO interrupt controller</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct gpio_irq_chip {
  struct irq_chip *chip;
  struct irq_domain *domain;
  const struct irq_domain_ops *domain_ops;
  irq_flow_handler_t handler;
  unsigned int default_type;
  struct lock_class_key *lock_key;
  struct lock_class_key *request_key;
  irq_flow_handler_t parent_handler;
  void *parent_handler_data;
  unsigned int num_parents;
  unsigned int parent_irq;
  unsigned int *parents;
  unsigned int *map;
  bool threaded;
  bool need_valid_mask;
  unsigned long *valid_mask;
  unsigned int first;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">chip</span></code></dt>
<dd>GPIO IRQ chip implementation, provided by GPIO driver.</dd>
<dt><code class="docutils literal"><span class="pre">domain</span></code></dt>
<dd>Interrupt translation domain; responsible for mapping between GPIO
hwirq number and Linux IRQ number.</dd>
<dt><code class="docutils literal"><span class="pre">domain_ops</span></code></dt>
<dd>Table of interrupt domain operations for this IRQ chip.</dd>
<dt><code class="docutils literal"><span class="pre">handler</span></code></dt>
<dd>The IRQ handler to use (often a predefined IRQ core function) for
GPIO IRQs, provided by GPIO driver.</dd>
<dt><code class="docutils literal"><span class="pre">default_type</span></code></dt>
<dd>Default IRQ triggering type applied during GPIO driver
initialization, provided by GPIO driver.</dd>
<dt><code class="docutils literal"><span class="pre">lock_key</span></code></dt>
<dd>Per GPIO IRQ chip lockdep classes.</dd>
<dt><code class="docutils literal"><span class="pre">parent_handler</span></code></dt>
<dd>The interrupt handler for the GPIO chip&#8217;s parent interrupts, may be
NULL if the parent interrupts are nested rather than cascaded.</dd>
<dt><code class="docutils literal"><span class="pre">parent_handler_data</span></code></dt>
<dd>Data associated, and passed to, the handler for the parent
interrupt.</dd>
<dt><code class="docutils literal"><span class="pre">num_parents</span></code></dt>
<dd>The number of interrupt parents of a GPIO chip.</dd>
<dt><code class="docutils literal"><span class="pre">parent_irq</span></code></dt>
<dd>For use by <code class="xref c c-func docutils literal"><span class="pre">gpiochip_set_cascaded_irqchip()</span></code></dd>
<dt><code class="docutils literal"><span class="pre">parents</span></code></dt>
<dd>A list of interrupt parents of a GPIO chip. This is owned by the
driver, so the core will only reference this list, not modify it.</dd>
<dt><code class="docutils literal"><span class="pre">map</span></code></dt>
<dd>A list of interrupt parents for each line of a GPIO chip.</dd>
<dt><code class="docutils literal"><span class="pre">threaded</span></code></dt>
<dd>True if set the interrupt handling uses nested threads.</dd>
<dt><code class="docutils literal"><span class="pre">need_valid_mask</span></code></dt>
<dd>If set core allocates <strong>valid_mask</strong> with all bits set to one.</dd>
<dt><code class="docutils literal"><span class="pre">valid_mask</span></code></dt>
<dd>If not <code class="docutils literal"><span class="pre">NULL</span></code> holds bitmask of GPIOs which are valid to be included
in IRQ domain of the chip.</dd>
<dt><code class="docutils literal"><span class="pre">first</span></code></dt>
<dd>Required for static IRQ allocation. If set, <code class="xref c c-func docutils literal"><span class="pre">irq_domain_add_simple()</span></code>
will allocate and map all IRQs during initialization.</dd>
</dl>
<dl class="type">
<dt id="c.gpio_chip">
struct <code class="descname">gpio_chip</code><a class="headerlink" href="#c.gpio_chip" title="Permalink to this definition">Â¶</a></dt>
<dd><p>abstract a GPIO controller</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct gpio_chip {
  const char              *label;
  struct gpio_device      *gpiodev;
  struct device           *parent;
  struct module           *owner;
  int (*request)(struct gpio_chip *chip, unsigned offset);
  void (*free)(struct gpio_chip *chip, unsigned offset);
  int (*get_direction)(struct gpio_chip *chip, unsigned offset);
  int (*direction_input)(struct gpio_chip *chip, unsigned offset);
  int (*direction_output)(struct gpio_chip *chip, unsigned offset, int value);
  int (*get)(struct gpio_chip *chip, unsigned offset);
  int (*get_multiple)(struct gpio_chip *chip,unsigned long *mask, unsigned long *bits);
  void (*set)(struct gpio_chip *chip, unsigned offset, int value);
  void (*set_multiple)(struct gpio_chip *chip,unsigned long *mask, unsigned long *bits);
  int (*set_config)(struct gpio_chip *chip,unsigned offset, unsigned long config);
  int (*to_irq)(struct gpio_chip *chip, unsigned offset);
  void (*dbg_show)(struct seq_file *s, struct gpio_chip *chip);
  int base;
  u16 ngpio;
  const char              *const *names;
  bool can_sleep;
#if IS_ENABLED(CONFIG_GPIO_GENERIC);
  unsigned long (*read_reg)(void __iomem *reg);
  void (*write_reg)(void __iomem *reg, unsigned long data);
  bool be_bits;
  void __iomem *reg_dat;
  void __iomem *reg_set;
  void __iomem *reg_clr;
  void __iomem *reg_dir;
  bool bgpio_dir_inverted;
  int bgpio_bits;
  spinlock_t bgpio_lock;
  unsigned long bgpio_data;
  unsigned long bgpio_dir;
#endif;
#ifdef CONFIG_GPIOLIB_IRQCHIP;
  struct gpio_irq_chip irq;
#endif;
  bool need_valid_mask;
  unsigned long *valid_mask;
#if defined(CONFIG_OF_GPIO);
  struct device_node *of_node;
  unsigned int of_gpio_n_cells;
  int (*of_xlate)(struct gpio_chip *gc, const struct of_phandle_args *gpiospec, u32 *flags);
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">label</span></code></dt>
<dd>a functional name for the GPIO device, such as a part
number or the name of the SoC IP-block implementing it.</dd>
<dt><code class="docutils literal"><span class="pre">gpiodev</span></code></dt>
<dd>the internal state holder, opaque struct</dd>
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>optional parent device providing the GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>helps prevent removal of modules exporting active GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">request</span></code></dt>
<dd>optional hook for chip-specific activation, such as
enabling module power and clock; may sleep</dd>
<dt><code class="docutils literal"><span class="pre">free</span></code></dt>
<dd>optional hook for chip-specific deactivation, such as
disabling module power and clock; may sleep</dd>
<dt><code class="docutils literal"><span class="pre">get_direction</span></code></dt>
<dd>returns direction for signal &#8220;offset&#8221;, 0=out, 1=in,
(same as GPIOF_DIR_XXX), or negative error</dd>
<dt><code class="docutils literal"><span class="pre">direction_input</span></code></dt>
<dd>configures signal &#8220;offset&#8221; as input, or returns error</dd>
<dt><code class="docutils literal"><span class="pre">direction_output</span></code></dt>
<dd>configures signal &#8220;offset&#8221; as output, or returns error</dd>
<dt><code class="docutils literal"><span class="pre">get</span></code></dt>
<dd>returns value for signal &#8220;offset&#8221;, 0=low, 1=high, or negative error</dd>
<dt><code class="docutils literal"><span class="pre">get_multiple</span></code></dt>
<dd>reads values for multiple signals defined by &#8220;mask&#8221; and
stores them in &#8220;bits&#8221;, returns 0 on success or negative error</dd>
<dt><code class="docutils literal"><span class="pre">set</span></code></dt>
<dd>assigns output value for signal &#8220;offset&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">set_multiple</span></code></dt>
<dd>assigns output values for multiple signals defined by &#8220;mask&#8221;</dd>
<dt><code class="docutils literal"><span class="pre">set_config</span></code></dt>
<dd>optional hook for all kinds of settings. Uses the same
packed config format as generic pinconf.</dd>
<dt><code class="docutils literal"><span class="pre">to_irq</span></code></dt>
<dd>optional hook supporting non-static <code class="xref c c-func docutils literal"><span class="pre">gpio_to_irq()</span></code> mappings;
implementation may not sleep</dd>
<dt><code class="docutils literal"><span class="pre">dbg_show</span></code></dt>
<dd>optional routine to show contents in debugfs; default code
will be used when this is omitted, but custom code can show extra
state (such as pullup/pulldown configuration).</dd>
<dt><code class="docutils literal"><span class="pre">base</span></code></dt>
<dd>identifies the first GPIO number handled by this chip;
or, if negative during registration, requests dynamic ID allocation.
DEPRECATION: providing anything non-negative and nailing the base
offset of GPIO chips is deprecated. Please pass -1 as base to
let gpiolib select the chip base in all possible cases. We want to
get rid of the static GPIO number space in the long run.</dd>
<dt><code class="docutils literal"><span class="pre">ngpio</span></code></dt>
<dd>the number of GPIOs handled by this controller; the last GPIO
handled is (base + ngpio - 1).</dd>
<dt><code class="docutils literal"><span class="pre">names</span></code></dt>
<dd>if set, must be an array of strings to use as alternative
names for the GPIOs in this chip. Any entry in the array
may be NULL if there is no alias for the GPIO, however the
array must be <strong>ngpio</strong> entries long.  A name can include a single printk
format specifier for an unsigned int.  It is substituted by the actual
number of the gpio.</dd>
<dt><code class="docutils literal"><span class="pre">can_sleep</span></code></dt>
<dd>flag must be set iff <code class="xref c c-func docutils literal"><span class="pre">get()</span></code>/<code class="xref c c-func docutils literal"><span class="pre">set()</span></code> methods sleep, as they
must while accessing GPIO expander chips over I2C or SPI. This
implies that if the chip supports IRQs, these IRQs need to be threaded
as the chip access may sleep when e.g. reading out the IRQ status
registers.</dd>
<dt><code class="docutils literal"><span class="pre">read_reg</span></code></dt>
<dd>reader function for generic GPIO</dd>
<dt><code class="docutils literal"><span class="pre">write_reg</span></code></dt>
<dd>writer function for generic GPIO</dd>
<dt><code class="docutils literal"><span class="pre">be_bits</span></code></dt>
<dd>if the generic GPIO has big endian bit order (bit 31 is representing
line 0, bit 30 is line 1 ... bit 0 is line 31) this is set to true by the
generic GPIO core. It is for internal housekeeping only.</dd>
<dt><code class="docutils literal"><span class="pre">reg_dat</span></code></dt>
<dd>data (in) register for generic GPIO</dd>
<dt><code class="docutils literal"><span class="pre">reg_set</span></code></dt>
<dd>output set register (out=high) for generic GPIO</dd>
<dt><code class="docutils literal"><span class="pre">reg_clr</span></code></dt>
<dd>output clear register (out=low) for generic GPIO</dd>
<dt><code class="docutils literal"><span class="pre">reg_dir</span></code></dt>
<dd>direction setting register for generic GPIO</dd>
<dt><code class="docutils literal"><span class="pre">bgpio_dir_inverted</span></code></dt>
<dd>indicates that the direction register is inverted
(gpiolib private state variable)</dd>
<dt><code class="docutils literal"><span class="pre">bgpio_bits</span></code></dt>
<dd>number of register bits used for a generic GPIO i.e.
&lt;register width&gt; * 8</dd>
<dt><code class="docutils literal"><span class="pre">bgpio_lock</span></code></dt>
<dd>used to lock chip-&gt;bgpio_data. Also, this is needed to keep
shadowed and real data registers writes together.</dd>
<dt><code class="docutils literal"><span class="pre">bgpio_data</span></code></dt>
<dd>shadowed data register for generic GPIO to clear/set bits
safely.</dd>
<dt><code class="docutils literal"><span class="pre">bgpio_dir</span></code></dt>
<dd>shadowed direction register for generic GPIO to clear/set
direction safely.</dd>
<dt><code class="docutils literal"><span class="pre">irq</span></code></dt>
<dd>Integrates interrupt chip functionality with the GPIO chip. Can be
used to handle IRQs for most practical cases.</dd>
<dt><code class="docutils literal"><span class="pre">need_valid_mask</span></code></dt>
<dd>If set core allocates <strong>valid_mask</strong> with all bits set to one.</dd>
<dt><code class="docutils literal"><span class="pre">valid_mask</span></code></dt>
<dd>If not <code class="docutils literal"><span class="pre">NULL</span></code> holds bitmask of GPIOs which are valid to be used
from the chip.</dd>
<dt><code class="docutils literal"><span class="pre">of_node</span></code></dt>
<dd>Pointer to a device tree node representing this GPIO controller.</dd>
<dt><code class="docutils literal"><span class="pre">of_gpio_n_cells</span></code></dt>
<dd>Number of cells used to form the GPIO specifier.</dd>
<dt><code class="docutils literal"><span class="pre">of_xlate</span></code></dt>
<dd>Callback to translate a device tree GPIO specifier into a chip-
relative GPIO number and flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>A gpio_chip can help platforms abstract various sources of GPIOs so
they can all be accessed through a common programing interface.
Example sources would be SOC controllers, FPGAs, multifunction
chips, dedicated GPIO expanders, and so on.</p>
<p>Each chip controls a number of signals, identified in method calls
by &#8220;offset&#8221; values in the range 0..(<strong>ngpio</strong> - 1).  When those signals
are referenced through calls like gpio_get_value(gpio), the offset
is calculated by subtracting <strong>base</strong> from the gpio number.</p>
<dl class="function">
<dt id="c.gpiochip_add_data">
<code class="descname">gpiochip_add_data</code><span class="sig-paren">(</span><em>chip</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_data" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a gpio_chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">chip</span></code></dt>
<dd>the chip to register, with chip-&gt;base initialized</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>driver-private data associated with this chip</dd>
</dl>
<p><strong>Context</strong></p>
<p>potentially before irqs will work</p>
<p><strong>Description</strong></p>
<p>When <a class="reference internal" href="#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal"><span class="pre">gpiochip_add_data()</span></code></a> is called very early during boot, so that GPIOs
can be freely used, the chip-&gt;parent device must be registered before
the gpio framework&#8217;s <code class="xref c c-func docutils literal"><span class="pre">arch_initcall()</span></code>.  Otherwise sysfs initialization
for GPIOs will fail rudely.</p>
<p><a class="reference internal" href="#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal"><span class="pre">gpiochip_add_data()</span></code></a> must only be called after gpiolib initialization,
ie after <code class="xref c c-func docutils literal"><span class="pre">core_initcall()</span></code>.</p>
<p>If chip-&gt;base is negative, this requests dynamic assignment of
a range of valid GPIOs.</p>
<p><strong>Return</strong></p>
<p>A negative errno if the chip can&#8217;t be registered, such as because the
chip-&gt;base is invalid or already associated with a different chip.
Otherwise it returns zero as a success code.</p>
<dl class="type">
<dt id="c.gpio_pin_range">
struct <code class="descname">gpio_pin_range</code><a class="headerlink" href="#c.gpio_pin_range" title="Permalink to this definition">Â¶</a></dt>
<dd><p>pin range controlled by a gpio chip</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct gpio_pin_range {
  struct list_head node;
  struct pinctrl_dev *pctldev;
  struct pinctrl_gpio_range range;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">node</span></code></dt>
<dd>list for maintaining set of pin ranges, used internally</dd>
<dt><code class="docutils literal"><span class="pre">pctldev</span></code></dt>
<dd>pinctrl device which handles corresponding pins</dd>
<dt><code class="docutils literal"><span class="pre">range</span></code></dt>
<dd>actual range of pins controlled by a gpio controller</dd>
</dl>
<dl class="function">
<dt id="c.gpio_to_desc">
struct gpio_desc * <code class="descname">gpio_to_desc</code><span class="sig-paren">(</span>unsigned<em>&nbsp;gpio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpio_to_desc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert a GPIO number to its descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt>
<dd>global GPIO number</dd>
</dl>
<p><strong>Return</strong></p>
<p>The GPIO descriptor associated with the given GPIO, or <code class="docutils literal"><span class="pre">NULL</span></code> if no GPIO
with the given number exists in the system.</p>
<dl class="function">
<dt id="c.desc_to_gpio">
int <code class="descname">desc_to_gpio</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.desc_to_gpio" title="Permalink to this definition">Â¶</a></dt>
<dd><p>convert a GPIO descriptor to the integer namespace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO descriptor</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should disappear in the future but is needed since we still
use GPIO numbers for error messages and sysfs nodes.</p>
<p><strong>Return</strong></p>
<p>The global GPIO number for the GPIO specified by its descriptor.</p>
<dl class="function">
<dt id="c.gpiod_to_chip">
struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> * <code class="descname">gpiod_to_chip</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_to_chip" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the GPIO chip to which a GPIO descriptor belongs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>descriptor to return the chip of</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_get_direction">
int <code class="descname">gpiod_get_direction</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_direction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return the current direction of a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO to get the direction of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 0 for output, 1 for input, or an error code in case of error.</p>
<p>This function may sleep if <a class="reference internal" href="#c.gpiod_cansleep" title="gpiod_cansleep"><code class="xref c c-func docutils literal"><span class="pre">gpiod_cansleep()</span></code></a> is true.</p>
<dl class="function">
<dt id="c.gpiochip_get_data">
void * <code class="descname">gpiochip_get_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_get_data" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get per-subdriver data for the chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>GPIO chip</dd>
</dl>
<p><strong>Return</strong></p>
<p>The per-subdriver data for the chip.</p>
<dl class="function">
<dt id="c.gpiochip_remove">
void <code class="descname">gpiochip_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_remove" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister a gpio_chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the chip to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>A gpio_chip with any GPIOs still requested may not be removed.</p>
<dl class="function">
<dt id="c.devm_gpiochip_add_data">
int <code class="descname">devm_gpiochip_add_data</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiochip_add_data" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource manager <a class="reference internal" href="#c.gpiochip_add_data" title="gpiochip_add_data"><code class="xref c c-func docutils literal"><span class="pre">gpiochip_add_data()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the device pointer on which irq_chip belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the chip to register, with chip-&gt;base initialized</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>driver-private data associated with this chip</dd>
</dl>
<p><strong>Context</strong></p>
<p>potentially before irqs will work</p>
<p><strong>Description</strong></p>
<p>The gpio chip automatically be released when the device is unbound.</p>
<p><strong>Return</strong></p>
<p>A negative errno if the chip can&#8217;t be registered, such as because the
chip-&gt;base is invalid or already associated with a different chip.
Otherwise it returns zero as a success code.</p>
<dl class="function">
<dt id="c.devm_gpiochip_remove">
void <code class="descname">devm_gpiochip_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiochip_remove" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource manager of <a class="reference internal" href="#c.gpiochip_remove" title="gpiochip_remove"><code class="xref c c-func docutils literal"><span class="pre">gpiochip_remove()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for which which resource was allocated</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the chip to remove</dd>
</dl>
<p><strong>Description</strong></p>
<p>A gpio_chip with any GPIOs still requested may not be removed.</p>
<dl class="function">
<dt id="c.gpiochip_find">
struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> * <code class="descname">gpiochip_find</code><span class="sig-paren">(</span>void *<em>&nbsp;data</em>, int (*match) (struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a><em>&nbsp;*chip</em>, void<em>&nbsp;*data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_find" title="Permalink to this definition">Â¶</a></dt>
<dd><p>iterator for locating a specific gpio_chip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>data to pass to match function</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">gpio_chip</span> <span class="pre">*chip,</span> <span class="pre">void</span> <span class="pre">*data)</span> <span class="pre">match</span></code></dt>
<dd>Callback function to check gpio_chip</dd>
</dl>
<p><strong>Description</strong></p>
<p>Similar to bus_find_device.  It returns a reference to a gpio_chip as
determined by a user supplied <strong>match</strong> callback.  The callback should return
0 if the device doesn&#8217;t match and non-zero if it does.  If the callback is
non-zero, this function will return to the caller and not iterate over any
more gpio_chips.</p>
<dl class="function">
<dt id="c.gpiochip_set_chained_irqchip">
void <code class="descname">gpiochip_set_chained_irqchip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;gpiochip</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_chip" title="irq_chip">irq_chip</a> *<em>&nbsp;irqchip</em>, unsigned int<em>&nbsp;parent_irq</em>, irq_flow_handler_t<em>&nbsp;parent_handler</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_set_chained_irqchip" title="Permalink to this definition">Â¶</a></dt>
<dd><p>connects a chained irqchip to a gpiochip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gpiochip</span></code></dt>
<dd>the gpiochip to set the irqchip chain to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_chip</span> <span class="pre">*</span> <span class="pre">irqchip</span></code></dt>
<dd>the irqchip to chain to the gpiochip</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">parent_irq</span></code></dt>
<dd>the irq number corresponding to the parent IRQ for this
chained irqchip</dd>
<dt><code class="docutils literal"><span class="pre">irq_flow_handler_t</span> <span class="pre">parent_handler</span></code></dt>
<dd>the parent interrupt handler for the accumulated IRQ
coming out of the gpiochip. If the interrupt is nested rather than
cascaded, pass NULL in this handler argument</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_set_nested_irqchip">
void <code class="descname">gpiochip_set_nested_irqchip</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;gpiochip</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_chip" title="irq_chip">irq_chip</a> *<em>&nbsp;irqchip</em>, unsigned int<em>&nbsp;parent_irq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_set_nested_irqchip" title="Permalink to this definition">Â¶</a></dt>
<dd><p>connects a nested irqchip to a gpiochip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gpiochip</span></code></dt>
<dd>the gpiochip to set the irqchip nested handler to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_chip</span> <span class="pre">*</span> <span class="pre">irqchip</span></code></dt>
<dd>the irqchip to nest to the gpiochip</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">parent_irq</span></code></dt>
<dd>the irq number corresponding to the parent IRQ for this
nested irqchip</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_irq_map">
int <code class="descname">gpiochip_irq_map</code><span class="sig-paren">(</span>struct irq_domain *<em>&nbsp;d</em>, unsigned int<em>&nbsp;irq</em>, irq_hw_number_t<em>&nbsp;hwirq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irq_map" title="Permalink to this definition">Â¶</a></dt>
<dd><p>maps an IRQ into a GPIO irqchip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_domain</span> <span class="pre">*</span> <span class="pre">d</span></code></dt>
<dd>the irqdomain used by this irqchip</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">irq</span></code></dt>
<dd>the global irq number used by this GPIO irqchip irq</dd>
<dt><code class="docutils literal"><span class="pre">irq_hw_number_t</span> <span class="pre">hwirq</span></code></dt>
<dd>the local IRQ/GPIO line offset on this gpiochip</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will set up the mapping for a certain IRQ line on a
gpiochip by assigning the gpiochip as chip data, and using the irqchip
stored inside the gpiochip.</p>
<dl class="function">
<dt id="c.gpiochip_irqchip_add_key">
int <code class="descname">gpiochip_irqchip_add_key</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;gpiochip</em>, struct <a class="reference internal" href="../../core-api/genericirq.html#c.irq_chip" title="irq_chip">irq_chip</a> *<em>&nbsp;irqchip</em>, unsigned int<em>&nbsp;first_irq</em>, irq_flow_handler_t<em>&nbsp;handler</em>, unsigned int<em>&nbsp;type</em>, bool<em>&nbsp;threaded</em>, struct lock_class_key *<em>&nbsp;lock_key</em>, struct lock_class_key *<em>&nbsp;request_key</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_irqchip_add_key" title="Permalink to this definition">Â¶</a></dt>
<dd><p>adds an irqchip to a gpiochip</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gpiochip</span></code></dt>
<dd>the gpiochip to add the irqchip to</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">irq_chip</span> <span class="pre">*</span> <span class="pre">irqchip</span></code></dt>
<dd>the irqchip to add to the gpiochip</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">first_irq</span></code></dt>
<dd>if not dynamically assigned, the base (first) IRQ to
allocate gpiochip irqs from</dd>
<dt><code class="docutils literal"><span class="pre">irq_flow_handler_t</span> <span class="pre">handler</span></code></dt>
<dd>the irq handler to use (often a predefined irq core function)</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>the default type for IRQs on this irqchip, pass IRQ_TYPE_NONE
to have the core avoid setting up any default type in the hardware.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">threaded</span></code></dt>
<dd>whether this irqchip uses a nested thread handler</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*</span> <span class="pre">lock_key</span></code></dt>
<dd>lockdep class for IRQ lock</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">lock_class_key</span> <span class="pre">*</span> <span class="pre">request_key</span></code></dt>
<dd>lockdep class for IRQ request</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function closely associates a certain irqchip with a certain
gpiochip, providing an irq domain to translate the local IRQs to
global irqs in the gpiolib core, and making sure that the gpiochip
is passed as chip data to all related functions. Driver callbacks
need to use <a class="reference internal" href="#c.gpiochip_get_data" title="gpiochip_get_data"><code class="xref c c-func docutils literal"><span class="pre">gpiochip_get_data()</span></code></a> to get their local state containers back
from the gpiochip passed as chip data. An irqdomain will be stored
in the gpiochip that shall be used by the driver to handle IRQ number
translation. The gpiochip will need to be initialized and registered
before calling this function.</p>
<p>This function will handle two cell:ed simple IRQs and assumes all
the pins on the gpiochip can generate a unique IRQ. Everything else
need to be open coded.</p>
<dl class="function">
<dt id="c.gpiochip_generic_request">
int <code class="descname">gpiochip_generic_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, unsigned<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_request" title="Permalink to this definition">Â¶</a></dt>
<dd><p>request the gpio function for a pin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the gpiochip owning the GPIO</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">offset</span></code></dt>
<dd>the offset of the GPIO to request for GPIO function</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_generic_free">
void <code class="descname">gpiochip_generic_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, unsigned<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_free" title="Permalink to this definition">Â¶</a></dt>
<dd><p>free the gpio function from a pin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the gpiochip to request the gpio function for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">offset</span></code></dt>
<dd>the offset of the GPIO to free from GPIO function</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_generic_config">
int <code class="descname">gpiochip_generic_config</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, unsigned<em>&nbsp;offset</em>, unsigned long<em>&nbsp;config</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_generic_config" title="Permalink to this definition">Â¶</a></dt>
<dd><p>apply configuration for a pin</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the gpiochip owning the GPIO</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">offset</span></code></dt>
<dd>the offset of the GPIO to apply the configuration</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">config</span></code></dt>
<dd>the configuration to be applied</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_add_pingroup_range">
int <code class="descname">gpiochip_add_pingroup_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, struct pinctrl_dev *<em>&nbsp;pctldev</em>, unsigned int<em>&nbsp;gpio_offset</em>, const char *<em>&nbsp;pin_group</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_pingroup_range" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a range for GPIO &lt;-&gt; pin mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the gpiochip to add the range for</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pinctrl_dev</span> <span class="pre">*</span> <span class="pre">pctldev</span></code></dt>
<dd>the pin controller to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gpio_offset</span></code></dt>
<dd>the start offset in the current gpio_chip number space</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pin_group</span></code></dt>
<dd>name of the pin group inside the pin controller</dd>
</dl>
<p><strong>Description</strong></p>
<p>Calling this function directly from a DeviceTree-supported
pinctrl driver is DEPRECATED. Please see Section 2.1 of
Documentation/devicetree/bindings/gpio/gpio.txt on how to
bind pinctrl and gpio drivers via the &#8220;gpio-ranges&#8221; property.</p>
<dl class="function">
<dt id="c.gpiochip_add_pin_range">
int <code class="descname">gpiochip_add_pin_range</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, const char *<em>&nbsp;pinctl_name</em>, unsigned int<em>&nbsp;gpio_offset</em>, unsigned int<em>&nbsp;pin_offset</em>, unsigned int<em>&nbsp;npins</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_add_pin_range" title="Permalink to this definition">Â¶</a></dt>
<dd><p>add a range for GPIO &lt;-&gt; pin mapping</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the gpiochip to add the range for</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">pinctl_name</span></code></dt>
<dd>the <code class="xref c c-func docutils literal"><span class="pre">dev_name()</span></code> of the pin controller to map to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gpio_offset</span></code></dt>
<dd>the start offset in the current gpio_chip number space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">pin_offset</span></code></dt>
<dd>the start offset in the pin controller number space</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">npins</span></code></dt>
<dd>the number of pins from the offset of each pin space (GPIO and
pin controller) to accumulate in this range</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, or a negative error-code on failure.</p>
<p>Calling this function directly from a DeviceTree-supported
pinctrl driver is DEPRECATED. Please see Section 2.1 of
Documentation/devicetree/bindings/gpio/gpio.txt on how to
bind pinctrl and gpio drivers via the &#8220;gpio-ranges&#8221; property.</p>
<dl class="function">
<dt id="c.gpiochip_remove_pin_ranges">
void <code class="descname">gpiochip_remove_pin_ranges</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_remove_pin_ranges" title="Permalink to this definition">Â¶</a></dt>
<dd><p>remove all the GPIO &lt;-&gt; pin mappings</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the chip to remove all the mappings for</dd>
</dl>
<dl class="function">
<dt id="c.gpiochip_is_requested">
const char * <code class="descname">gpiochip_is_requested</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, unsigned<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_is_requested" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return string iff signal was requested</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>controller managing the signal</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">offset</span></code></dt>
<dd>of signal within controller&#8217;s 0..(ngpio - 1) range</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns NULL if the GPIO is not currently requested, else a string.
The string returned is the label passed to <code class="xref c c-func docutils literal"><span class="pre">gpio_request()</span></code>; if none has been
passed it is a meaningless, non-NULL constant.</p>
<p>This function is for use by GPIO controller drivers.  The label can
help with diagnostics, and knowing that the signal is used as a GPIO
can help avoid accidentally multiplexing it to another controller.</p>
<dl class="function">
<dt id="c.gpiochip_request_own_desc">
struct gpio_desc * <code class="descname">gpiochip_request_own_desc</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, u16<em>&nbsp;hwnum</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_request_own_desc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Allow GPIO chip to request its own descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>GPIO chip</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">hwnum</span></code></dt>
<dd>hardware number of the GPIO for which to request the descriptor</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>label for the GPIO</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function allows GPIO chip drivers to request and use their own GPIO
descriptors via gpiolib API. Difference to <code class="xref c c-func docutils literal"><span class="pre">gpiod_request()</span></code> is that this
function will not increase reference count of the GPIO chip module. This
allows the GPIO chip module to be unloaded as needed (we assume that the
GPIO chip driver handles freeing the GPIOs it has requested).</p>
<p><strong>Return</strong></p>
<p>A pointer to the GPIO descriptor, or an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code>-encoded negative error
code on failure.</p>
<dl class="function">
<dt id="c.gpiochip_free_own_desc">
void <code class="descname">gpiochip_free_own_desc</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_free_own_desc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Free GPIO requested by the chip driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO descriptor to free</dd>
</dl>
<p><strong>Description</strong></p>
<p>Function frees the given GPIO requested previously with
<a class="reference internal" href="#c.gpiochip_request_own_desc" title="gpiochip_request_own_desc"><code class="xref c c-func docutils literal"><span class="pre">gpiochip_request_own_desc()</span></code></a>.</p>
<dl class="function">
<dt id="c.gpiod_direction_input">
int <code class="descname">gpiod_direction_input</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_input" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set the GPIO direction to input</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO to set to input</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to input, such as <a class="reference internal" href="#c.gpiod_get_value" title="gpiod_get_value"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_value()</span></code></a> can
be called safely on it.</p>
<p>Return 0 in case of success, else an error code.</p>
<dl class="function">
<dt id="c.gpiod_direction_output_raw">
int <code class="descname">gpiod_direction_output_raw</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_output_raw" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set the GPIO direction to output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO to set to output</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>initial output value of the GPIO</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to output, such as <a class="reference internal" href="#c.gpiod_set_value" title="gpiod_set_value"><code class="xref c c-func docutils literal"><span class="pre">gpiod_set_value()</span></code></a> can
be called safely on it. The initial value of the output must be specified
as raw value on the physical line without regard for the ACTIVE_LOW status.</p>
<p>Return 0 in case of success, else an error code.</p>
<dl class="function">
<dt id="c.gpiod_direction_output">
int <code class="descname">gpiod_direction_output</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_direction_output" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set the GPIO direction to output</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO to set to output</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>initial output value of the GPIO</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the direction of the passed GPIO to output, such as <a class="reference internal" href="#c.gpiod_set_value" title="gpiod_set_value"><code class="xref c c-func docutils literal"><span class="pre">gpiod_set_value()</span></code></a> can
be called safely on it. The initial value of the output must be specified
as the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
account.</p>
<p>Return 0 in case of success, else an error code.</p>
<dl class="function">
<dt id="c.gpiod_set_debounce">
int <code class="descname">gpiod_set_debounce</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, unsigned<em>&nbsp;debounce</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_debounce" title="Permalink to this definition">Â¶</a></dt>
<dd><p>sets <strong>debounce</strong> time for a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>descriptor of the GPIO for which to set debounce time</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">debounce</span></code></dt>
<dd>debounce time in microseconds</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, <code class="docutils literal"><span class="pre">-ENOTSUPP</span></code> if the controller doesn&#8217;t support setting the
debounce time.</p>
<dl class="function">
<dt id="c.gpiod_set_transitory">
int <code class="descname">gpiod_set_transitory</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, bool<em>&nbsp;transitory</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_transitory" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Lose or retain GPIO state on suspend or reset</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>descriptor of the GPIO for which to configure persistence</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">transitory</span></code></dt>
<dd>True to lose state on suspend or reset, false for persistence</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success, otherwise a negative error code.</p>
<dl class="function">
<dt id="c.gpiod_is_active_low">
int <code class="descname">gpiod_is_active_low</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_is_active_low" title="Permalink to this definition">Â¶</a></dt>
<dd><p>test whether a GPIO is active-low or not</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>the gpio descriptor to test</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns 1 if the GPIO is active-low, 0 otherwise.</p>
<dl class="function">
<dt id="c.gpiod_get_raw_value">
int <code class="descname">gpiod_get_raw_value</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return a gpio&#8217;s raw value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose value will be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO&#8217;s raw value, i.e. the value of the physical line disregarding
its ACTIVE_LOW status, or negative errno on failure.</p>
<p>This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_value">
int <code class="descname">gpiod_get_value</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return a gpio&#8217;s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose value will be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO&#8217;s logical value, i.e. taking the ACTIVE_LOW status into
account, or negative errno on failure.</p>
<p>This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_raw_array_value">
int <code class="descname">gpiod_get_raw_array_value</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;array_size</em>, struct gpio_desc **<em>&nbsp;desc_array</em>, int *<em>&nbsp;value_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_array_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>read raw values from an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt>
<dd>number of elements in the descriptor / value arrays</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt>
<dd>array of GPIO descriptors whose values will be read</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">value_array</span></code></dt>
<dd>array to store the read values</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.  Return 0 in case of success,
else an error code.</p>
<p>This function should be called from contexts where we cannot sleep,
and it will complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_array_value">
int <code class="descname">gpiod_get_array_value</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;array_size</em>, struct gpio_desc **<em>&nbsp;desc_array</em>, int *<em>&nbsp;value_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>read values from an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt>
<dd>number of elements in the descriptor / value arrays</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt>
<dd>array of GPIO descriptors whose values will be read</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">value_array</span></code></dt>
<dd>array to store the read values</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.  Return 0 in case of success, else an error code.</p>
<p>This function should be called from contexts where we cannot sleep,
and it will complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_raw_value">
void <code class="descname">gpiod_set_raw_value</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign a gpio&#8217;s raw value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose value will be assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>value to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw value of the GPIO, i.e. the value of its physical line without
regard for its ACTIVE_LOW status.</p>
<p>This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_value">
void <code class="descname">gpiod_set_value</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign a gpio&#8217;s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose value will be assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>value to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical value of the GPIO, i.e. taking its ACTIVE_LOW,
OPEN_DRAIN and OPEN_SOURCE flags into account.</p>
<p>This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_raw_array_value">
int <code class="descname">gpiod_set_raw_array_value</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;array_size</em>, struct gpio_desc **<em>&nbsp;desc_array</em>, int *<em>&nbsp;value_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_array_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt>
<dd>number of elements in the descriptor / value arrays</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt>
<dd>array of GPIO descriptors whose values will be assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">value_array</span></code></dt>
<dd>array of values to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.</p>
<p>This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_array_value">
void <code class="descname">gpiod_set_array_value</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;array_size</em>, struct gpio_desc **<em>&nbsp;desc_array</em>, int *<em>&nbsp;value_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_array_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt>
<dd>number of elements in the descriptor / value arrays</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt>
<dd>array of GPIO descriptors whose values will be assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">value_array</span></code></dt>
<dd>array of values to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.</p>
<p>This function should be called from contexts where we cannot sleep, and will
complain if the GPIO chip functions potentially sleep.</p>
<dl class="function">
<dt id="c.gpiod_cansleep">
int <code class="descname">gpiod_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>report whether gpio value access may sleep</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio to check</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_set_consumer_name">
void <code class="descname">gpiod_set_consumer_name</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_consumer_name" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set the consumer name for the descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio to set the consumer name on</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>the new consumer name</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_to_irq">
int <code class="descname">gpiod_to_irq</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_to_irq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return the IRQ corresponding to a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose IRQ will be returned (already requested)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the IRQ corresponding to the passed GPIO, or an error code in case of
error.</p>
<dl class="function">
<dt id="c.gpiochip_lock_as_irq">
int <code class="descname">gpiochip_lock_as_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_lock_as_irq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>lock a GPIO to be used as IRQ</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the chip the GPIO to lock belongs to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>the offset of the GPIO to lock as IRQ</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used directly by GPIO drivers that want to lock down
a certain GPIO line to be used for IRQs.</p>
<dl class="function">
<dt id="c.gpiochip_unlock_as_irq">
void <code class="descname">gpiochip_unlock_as_irq</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em>, unsigned int<em>&nbsp;offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiochip_unlock_as_irq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unlock a GPIO used as IRQ</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>the chip the GPIO to lock belongs to</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">offset</span></code></dt>
<dd>the offset of the GPIO to lock as IRQ</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is used directly by GPIO drivers that want to indicate
that a certain GPIO is no longer used exclusively for IRQ.</p>
<dl class="function">
<dt id="c.gpiod_get_raw_value_cansleep">
int <code class="descname">gpiod_get_raw_value_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_value_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return a gpio&#8217;s raw value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose value will be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO&#8217;s raw value, i.e. the value of the physical line disregarding
its ACTIVE_LOW status, or negative errno on failure.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_value_cansleep">
int <code class="descname">gpiod_get_value_cansleep</code><span class="sig-paren">(</span>const struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_value_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return a gpio&#8217;s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose value will be returned</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO&#8217;s logical value, i.e. taking the ACTIVE_LOW status into
account, or negative errno on failure.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_raw_array_value_cansleep">
int <code class="descname">gpiod_get_raw_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;array_size</em>, struct gpio_desc **<em>&nbsp;desc_array</em>, int *<em>&nbsp;value_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_raw_array_value_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>read raw values from an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt>
<dd>number of elements in the descriptor / value arrays</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt>
<dd>array of GPIO descriptors whose values will be read</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">value_array</span></code></dt>
<dd>array to store the read values</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.  Return 0 in case of success,
else an error code.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_get_array_value_cansleep">
int <code class="descname">gpiod_get_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;array_size</em>, struct gpio_desc **<em>&nbsp;desc_array</em>, int *<em>&nbsp;value_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_value_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>read values from an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt>
<dd>number of elements in the descriptor / value arrays</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt>
<dd>array of GPIO descriptors whose values will be read</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">value_array</span></code></dt>
<dd>array to store the read values</dd>
</dl>
<p><strong>Description</strong></p>
<p>Read the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.  Return 0 in case of success, else an error code.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_raw_value_cansleep">
void <code class="descname">gpiod_set_raw_value_cansleep</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_value_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign a gpio&#8217;s raw value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose value will be assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>value to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw value of the GPIO, i.e. the value of its physical line without
regard for its ACTIVE_LOW status.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_value_cansleep">
void <code class="descname">gpiod_set_value_cansleep</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, int<em>&nbsp;value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_value_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign a gpio&#8217;s value</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>gpio whose value will be assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">value</span></code></dt>
<dd>value to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
account</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_raw_array_value_cansleep">
int <code class="descname">gpiod_set_raw_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;array_size</em>, struct gpio_desc **<em>&nbsp;desc_array</em>, int *<em>&nbsp;value_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_raw_array_value_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt>
<dd>number of elements in the descriptor / value arrays</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt>
<dd>array of GPIO descriptors whose values will be assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">value_array</span></code></dt>
<dd>array of values to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the raw values of the GPIOs, i.e. the values of the physical lines
without regard for their ACTIVE_LOW status.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_set_array_value_cansleep">
void <code class="descname">gpiod_set_array_value_cansleep</code><span class="sig-paren">(</span>unsigned int<em>&nbsp;array_size</em>, struct gpio_desc **<em>&nbsp;desc_array</em>, int *<em>&nbsp;value_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_set_array_value_cansleep" title="Permalink to this definition">Â¶</a></dt>
<dd><p>assign values to an array of GPIOs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">array_size</span></code></dt>
<dd>number of elements in the descriptor / value arrays</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">**</span> <span class="pre">desc_array</span></code></dt>
<dd>array of GPIO descriptors whose values will be assigned</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">value_array</span></code></dt>
<dd>array of values to assign</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
into account.</p>
<p>This function is to be called from contexts that can sleep.</p>
<dl class="function">
<dt id="c.gpiod_add_lookup_table">
void <code class="descname">gpiod_add_lookup_table</code><span class="sig-paren">(</span>struct gpiod_lookup_table *<em>&nbsp;table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_add_lookup_table" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register GPIO device consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpiod_lookup_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>table of consumers to register</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_remove_lookup_table">
void <code class="descname">gpiod_remove_lookup_table</code><span class="sig-paren">(</span>struct gpiod_lookup_table *<em>&nbsp;table</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_remove_lookup_table" title="Permalink to this definition">Â¶</a></dt>
<dd><p>unregister GPIO device consumers</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpiod_lookup_table</span> <span class="pre">*</span> <span class="pre">table</span></code></dt>
<dd>table of consumers to unregister</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_add_hogs">
void <code class="descname">gpiod_add_hogs</code><span class="sig-paren">(</span>struct gpiod_hog *<em>&nbsp;hogs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_add_hogs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>register a set of GPIO hogs from machine code</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpiod_hog</span> <span class="pre">*</span> <span class="pre">hogs</span></code></dt>
<dd>table of gpio hog entries with a zeroed sentinel at the end</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_count">
int <code class="descname">gpiod_count</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_count" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return the number of GPIOs associated with a device / function or -ENOENT if no GPIO has been assigned to the requested function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer, can be NULL for system-global GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
</dl>
<dl class="function">
<dt id="c.gpiod_get">
struct gpio_desc * <code class="descname">gpiod_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain a GPIO for a given GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer, can be NULL for system-global GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Return the GPIO descriptor corresponding to the function con_id of device
dev, -ENOENT if no GPIO has been assigned to the requested function, or
another <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> code if an error occurred while trying to acquire the GPIO.</p>
<dl class="function">
<dt id="c.gpiod_get_optional">
struct gpio_desc * <code class="descname">gpiod_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_optional" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain an optional GPIO for a given GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer, can be NULL for system-global GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get()</span></code></a>, except that when no GPIO was assigned to
the requested function it will return NULL. This is convenient for drivers
that need to handle optional GPIOs.</p>
<dl class="function">
<dt id="c.gpiod_get_index">
struct gpio_desc * <code class="descname">gpiod_get_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, unsigned int<em>&nbsp;idx</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_index" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain a GPIO from a multi-index GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer, can be NULL for system-global GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>index of the GPIO to obtain in the consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This variant of <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get()</span></code></a> allows to access GPIOs other than the first
defined one for functions that define several GPIOs.</p>
<p>Return a valid GPIO descriptor, -ENOENT if no GPIO has been assigned to the
requested function and/or index, or another <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code> code if an error
occurred while trying to acquire the GPIO.</p>
<dl class="function">
<dt id="c.gpiod_get_from_of_node">
struct gpio_desc * <code class="descname">gpiod_get_from_of_node</code><span class="sig-paren">(</span>struct device_node *<em>&nbsp;node</em>, const char *<em>&nbsp;propname</em>, int<em>&nbsp;index</em>, enum gpiod_flags<em>&nbsp;dflags</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_from_of_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain a GPIO from an OF node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>handle of the OF node</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">propname</span></code></dt>
<dd>name of the DT property representing the GPIO</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the GPIO to obtain for the consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt>
<dd>GPIO initialization flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>label to attach to the requested GPIO</dd>
</dl>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>dflags</strong>. If the node does not have the requested GPIO
property, NULL is returned.</p>
<p>In case of error an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> is returned.</p>
<dl class="function">
<dt id="c.fwnode_get_named_gpiod">
struct gpio_desc * <code class="descname">fwnode_get_named_gpiod</code><span class="sig-paren">(</span>struct fwnode_handle *<em>&nbsp;fwnode</em>, const char *<em>&nbsp;propname</em>, int<em>&nbsp;index</em>, enum gpiod_flags<em>&nbsp;dflags</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.fwnode_get_named_gpiod" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain a GPIO from firmware node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt>
<dd>handle of the firmware node</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">propname</span></code></dt>
<dd>name of the firmware property representing the GPIO</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the GPIO to obtain for the consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt>
<dd>GPIO initialization flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>label to attach to the requested GPIO</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used for drivers that get their configuration
from opaque firmware.</p>
<p>The function properly finds the corresponding GPIO using whatever is the
underlying firmware interface and then makes sure that the GPIO
descriptor is requested before it is returned to the caller.</p>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>dflags</strong>.</p>
<p>In case of error an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> is returned.</p>
<dl class="function">
<dt id="c.gpiod_get_index_optional">
struct gpio_desc * <code class="descname">gpiod_get_index_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, unsigned int<em>&nbsp;index</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_index_optional" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain an optional GPIO from a multi-index GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer, can be NULL for system-global GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the GPIO to obtain in the consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_index()</span></code></a>, except that when no GPIO with the
specified index was assigned to the requested function it will return NULL.
This is convenient for drivers that need to handle optional GPIOs.</p>
<dl class="function">
<dt id="c.gpiod_get_array">
struct gpio_descs * <code class="descname">gpiod_get_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain multiple GPIOs from a multi-index GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer, can be NULL for system-global GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function acquires all the GPIOs defined under a given function.</p>
<p>Return a struct gpio_descs containing an array of descriptors, -ENOENT if
no GPIO has been assigned to the requested function, or another <code class="xref c c-func docutils literal"><span class="pre">IS_ERR()</span></code>
code if an error occurred while trying to acquire the GPIOs.</p>
<dl class="function">
<dt id="c.gpiod_get_array_optional">
struct gpio_descs * <code class="descname">gpiod_get_array_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_get_array_optional" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain multiple GPIOs from a multi-index GPIO function</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer, can be NULL for system-global GPIOs</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is equivalent to <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_array()</span></code></a>, except that when no GPIO was
assigned to the requested function it will return NULL.</p>
<dl class="function">
<dt id="c.gpiod_put">
void <code class="descname">gpiod_put</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dispose of a GPIO descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO descriptor to dispose of</dd>
</dl>
<p><strong>Description</strong></p>
<p>No descriptor can be used after <a class="reference internal" href="#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal"><span class="pre">gpiod_put()</span></code></a> has been called on it.</p>
<dl class="function">
<dt id="c.gpiod_put_array">
void <code class="descname">gpiod_put_array</code><span class="sig-paren">(</span>struct gpio_descs *<em>&nbsp;descs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_put_array" title="Permalink to this definition">Â¶</a></dt>
<dd><p>dispose of multiple GPIO descriptors</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_descs</span> <span class="pre">*</span> <span class="pre">descs</span></code></dt>
<dd>struct gpio_descs containing an array of descriptors</dd>
</dl>
</div>
<div class="section" id="acpi-support">
<h2>ACPI support<a class="headerlink" href="#acpi-support" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.acpi_gpiochip_request_interrupts">
void <code class="descname">acpi_gpiochip_request_interrupts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_gpiochip_request_interrupts" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Register isr for gpio chip ACPI events</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>GPIO chip</dd>
</dl>
<p><strong>Description</strong></p>
<p>ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
handled by ACPI event methods which need to be called from the GPIO
chip&#8217;s interrupt handler. acpi_gpiochip_request_interrupts finds out which
gpio pins have acpi event methods and assigns interrupt handlers that calls
the acpi event methods for those pins.</p>
<dl class="function">
<dt id="c.acpi_gpiochip_free_interrupts">
void <code class="descname">acpi_gpiochip_free_interrupts</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;chip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_gpiochip_free_interrupts" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Free GPIO ACPI event interrupts.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">chip</span></code></dt>
<dd>GPIO chip</dd>
</dl>
<p><strong>Description</strong></p>
<p>Free interrupts associated with GPIO ACPI event method for the given
GPIO chip.</p>
<dl class="function">
<dt id="c.acpi_dev_gpio_irq_get">
int <code class="descname">acpi_dev_gpio_irq_get</code><span class="sig-paren">(</span>struct acpi_device *<em>&nbsp;adev</em>, int<em>&nbsp;index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.acpi_dev_gpio_irq_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find GpioInt and translate it to Linux IRQ number</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">acpi_device</span> <span class="pre">*</span> <span class="pre">adev</span></code></dt>
<dd>pointer to a ACPI device to get IRQ from</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of GpioInt resource (starting from <code class="docutils literal"><span class="pre">0</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>If the device has one or more GpioInt resources, this function can be
used to translate from the GPIO offset in the resource to the Linux IRQ
number.</p>
<p>The function is idempotent, though each time it runs it will configure GPIO
pin direction according to the flags in GpioInt resource.</p>
<p><strong>Return</strong></p>
<p>Linux IRQ number (&gt; <code class="docutils literal"><span class="pre">0</span></code>) on success, negative errno on failure.</p>
</div>
<div class="section" id="device-tree-support">
<h2>Device tree support<a class="headerlink" href="#device-tree-support" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.of_gpio_simple_xlate">
int <code class="descname">of_gpio_simple_xlate</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.gpio_chip" title="gpio_chip">gpio_chip</a> *<em>&nbsp;gc</em>, const struct of_phandle_args *<em>&nbsp;gpiospec</em>, u32 *<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_gpio_simple_xlate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>translate gpiospec to the GPIO number and flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_chip</span> <span class="pre">*</span> <span class="pre">gc</span></code></dt>
<dd>pointer to the gpio_chip structure</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">of_phandle_args</span> <span class="pre">*</span> <span class="pre">gpiospec</span></code></dt>
<dd>GPIO specifier as found in the device tree</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">*</span> <span class="pre">flags</span></code></dt>
<dd>a flags pointer to fill in</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is simple translation function, suitable for the most 1:1 mapped
GPIO chips. This function performs only one sanity check: whether GPIO
is less than ngpios (that is specified in the gpio_chip).</p>
<dl class="function">
<dt id="c.of_mm_gpiochip_add_data">
int <code class="descname">of_mm_gpiochip_add_data</code><span class="sig-paren">(</span>struct device_node *<em>&nbsp;np</em>, struct of_mm_gpio_chip *<em>&nbsp;mm_gc</em>, void *<em>&nbsp;data</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mm_gpiochip_add_data" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add memory mapped GPIO chip (bank)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">np</span></code></dt>
<dd>device node of the GPIO chip</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">of_mm_gpio_chip</span> <span class="pre">*</span> <span class="pre">mm_gc</span></code></dt>
<dd>pointer to the of_mm_gpio_chip allocated structure</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>driver data to store in the struct gpio_chip</dd>
</dl>
<p><strong>Description</strong></p>
<p>To use this function you should allocate and fill mm_gc with:</p>
<ol class="arabic simple">
<li>In the gpio_chip structure:
- all the callbacks
- of_gpio_n_cells
- of_xlate callback (optional)</li>
</ol>
<ol class="arabic simple" start="3">
<li>In the of_mm_gpio_chip structure:
- save_regs callback (optional)</li>
</ol>
<p>If succeeded, this function will map bank&#8217;s memory and will
do all necessary work for you. Then you&#8217;ll able to use .regs
to manage GPIOs from the callbacks.</p>
<dl class="function">
<dt id="c.of_mm_gpiochip_remove">
void <code class="descname">of_mm_gpiochip_remove</code><span class="sig-paren">(</span>struct of_mm_gpio_chip *<em>&nbsp;mm_gc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.of_mm_gpiochip_remove" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove memory mapped GPIO chip (bank)</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">of_mm_gpio_chip</span> <span class="pre">*</span> <span class="pre">mm_gc</span></code></dt>
<dd>pointer to the of_mm_gpio_chip allocated structure</dd>
</dl>
</div>
<div class="section" id="device-managed-api">
<h2>Device-managed API<a class="headerlink" href="#device-managed-api" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.devm_gpiod_get">
struct gpio_desc * <code class="descname">devm_gpiod_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get" title="gpiod_get"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get()</span></code></a> for detailed
information about behavior and return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_optional">
struct gpio_desc * <code class="descname">devm_gpiod_get_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_optional" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_optional()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_optional()</span></code></a>. GPIO descriptors returned from this function
are automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_optional" title="gpiod_get_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_optional()</span></code></a> for
detailed information about behavior and return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_index">
struct gpio_desc * <code class="descname">devm_gpiod_get_index</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, unsigned int<em>&nbsp;idx</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_index" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_index()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">idx</span></code></dt>
<dd>index of the GPIO to obtain in the consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_index()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_index" title="gpiod_get_index"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_index()</span></code></a> for detailed
information about behavior and return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_from_of_node">
struct gpio_desc * <code class="descname">devm_gpiod_get_from_of_node</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct device_node *<em>&nbsp;node</em>, const char *<em>&nbsp;propname</em>, int<em>&nbsp;index</em>, enum gpiod_flags<em>&nbsp;dflags</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_from_of_node" title="Permalink to this definition">Â¶</a></dt>
<dd><p>obtain a GPIO from an OF node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device for lifecycle management</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_node</span> <span class="pre">*</span> <span class="pre">node</span></code></dt>
<dd>handle of the OF node</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">propname</span></code></dt>
<dd>name of the DT property representing the GPIO</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the GPIO to obtain for the consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">dflags</span></code></dt>
<dd>GPIO initialization flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>label to attach to the requested GPIO</dd>
</dl>
<p><strong>Return</strong></p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>dflags</strong>.</p>
<p>In case of error an <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> is returned.</p>
<dl class="function">
<dt id="c.devm_fwnode_get_index_gpiod_from_child">
struct gpio_desc * <code class="descname">devm_fwnode_get_index_gpiod_from_child</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, int<em>&nbsp;index</em>, struct fwnode_handle *<em>&nbsp;child</em>, enum gpiod_flags<em>&nbsp;flags</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_fwnode_get_index_gpiod_from_child" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get a GPIO descriptor from a device&#8217;s child node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the GPIO to obtain in the consumer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">child</span></code></dt>
<dd>firmware node (child of <strong>dev</strong>)</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>GPIO initialization flags</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>label to attach to the requested GPIO</dd>
</dl>
<p><strong>Description</strong></p>
<p>GPIO descriptors returned from this function are automatically disposed on
driver detach.</p>
<p>On successful request the GPIO pin is configured in accordance with
provided <strong>flags</strong>.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_index_optional">
struct gpio_desc * <code class="descname">devm_gpiod_get_index_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, unsigned int<em>&nbsp;index</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_index_optional" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_index_optional()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>index of the GPIO to obtain in the consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_index_optional()</span></code></a>. GPIO descriptors returned from this
function are automatically disposed on driver detach. See
<a class="reference internal" href="#c.gpiod_get_index_optional" title="gpiod_get_index_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_index_optional()</span></code></a> for detailed information about behavior and
return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_array">
struct gpio_descs * <code class="descname">devm_gpiod_get_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_array" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_array()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_array()</span></code></a>. GPIO descriptors returned from this function are
automatically disposed on driver detach. See <a class="reference internal" href="#c.gpiod_get_array" title="gpiod_get_array"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_array()</span></code></a> for detailed
information about behavior and return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_get_array_optional">
struct gpio_descs * <code class="descname">devm_gpiod_get_array_optional</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;con_id</em>, enum gpiod_flags<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_get_array_optional" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_array_optional()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">con_id</span></code></dt>
<dd>function within the GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">gpiod_flags</span> <span class="pre">flags</span></code></dt>
<dd>optional GPIO initialization flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>Managed <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_array_optional()</span></code></a>. GPIO descriptors returned from this
function are automatically disposed on driver detach.
See <a class="reference internal" href="#c.gpiod_get_array_optional" title="gpiod_get_array_optional"><code class="xref c c-func docutils literal"><span class="pre">gpiod_get_array_optional()</span></code></a> for detailed information about behavior and
return values.</p>
<dl class="function">
<dt id="c.devm_gpiod_put">
void <code class="descname">devm_gpiod_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_put" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_put" title="gpiod_put"><code class="xref c c-func docutils literal"><span class="pre">gpiod_put()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO descriptor to dispose of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispose of a GPIO descriptor obtained with <a class="reference internal" href="#c.devm_gpiod_get" title="devm_gpiod_get"><code class="xref c c-func docutils literal"><span class="pre">devm_gpiod_get()</span></code></a> or
<a class="reference internal" href="#c.devm_gpiod_get_index" title="devm_gpiod_get_index"><code class="xref c c-func docutils literal"><span class="pre">devm_gpiod_get_index()</span></code></a>. Normally this function will not be called as the GPIO
will be disposed of by the resource management code.</p>
<dl class="function">
<dt id="c.devm_gpiod_put_array">
void <code class="descname">devm_gpiod_put_array</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, struct gpio_descs *<em>&nbsp;descs</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpiod_put_array" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Resource-managed <a class="reference internal" href="#c.gpiod_put_array" title="gpiod_put_array"><code class="xref c c-func docutils literal"><span class="pre">gpiod_put_array()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>GPIO consumer</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_descs</span> <span class="pre">*</span> <span class="pre">descs</span></code></dt>
<dd>GPIO descriptor array to dispose of</dd>
</dl>
<p><strong>Description</strong></p>
<p>Dispose of an array of GPIO descriptors obtained with <a class="reference internal" href="#c.devm_gpiod_get_array" title="devm_gpiod_get_array"><code class="xref c c-func docutils literal"><span class="pre">devm_gpiod_get_array()</span></code></a>.
Normally this function will not be called as the GPIOs will be disposed of
by the resource management code.</p>
<dl class="function">
<dt id="c.devm_gpio_request">
int <code class="descname">devm_gpio_request</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, unsigned<em>&nbsp;gpio</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpio_request" title="Permalink to this definition">Â¶</a></dt>
<dd><p>request a GPIO for a managed device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to request the GPIO for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt>
<dd>GPIO to allocate</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>the name of the requested GPIO</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div><p>Except for the extra <strong>dev</strong> argument, this function takes the
same arguments and performs the same function as
<code class="xref c c-func docutils literal"><span class="pre">gpio_request()</span></code>.  GPIOs requested with this function will be
automatically freed on driver detach.</p>
<p>If an GPIO allocated with this function needs to be freed
separately, <a class="reference internal" href="#c.devm_gpio_free" title="devm_gpio_free"><code class="xref c c-func docutils literal"><span class="pre">devm_gpio_free()</span></code></a> must be used.</p>
</div></blockquote>
<dl class="function">
<dt id="c.devm_gpio_request_one">
int <code class="descname">devm_gpio_request_one</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, unsigned<em>&nbsp;gpio</em>, unsigned long<em>&nbsp;flags</em>, const char *<em>&nbsp;label</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpio_request_one" title="Permalink to this definition">Â¶</a></dt>
<dd><p>request a single GPIO with initial setup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to request for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">gpio</span></code></dt>
<dd>the GPIO number</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>GPIO configuration as specified by GPIOF_*</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">label</span></code></dt>
<dd>a literal description string of this GPIO</dd>
</dl>
<dl class="function">
<dt id="c.devm_gpio_free">
void <code class="descname">devm_gpio_free</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, unsigned int<em>&nbsp;gpio</em><span class="sig-paren">)</span><a class="headerlink" href="#c.devm_gpio_free" title="Permalink to this definition">Â¶</a></dt>
<dd><p>free a GPIO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device to free GPIO for</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">gpio</span></code></dt>
<dd>GPIO to free</dd>
</dl>
<p><strong>Description</strong></p>
<blockquote>
<div>Except for the extra <strong>dev</strong> argument, this function takes the
same arguments and performs the same function as <code class="xref c c-func docutils literal"><span class="pre">gpio_free()</span></code>.
This function instead of <code class="xref c c-func docutils literal"><span class="pre">gpio_free()</span></code> should be used to manually
free GPIOs allocated with <a class="reference internal" href="#c.devm_gpio_request" title="devm_gpio_request"><code class="xref c c-func docutils literal"><span class="pre">devm_gpio_request()</span></code></a>.</div></blockquote>
</div>
<div class="section" id="sysfs-helpers">
<h2>sysfs helpers<a class="headerlink" href="#sysfs-helpers" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.gpiod_export">
int <code class="descname">gpiod_export</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em>, bool<em>&nbsp;direction_may_change</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_export" title="Permalink to this definition">Â¶</a></dt>
<dd><p>export a GPIO through sysfs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO to make available, already requested</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">direction_may_change</span></code></dt>
<dd>true if userspace may change GPIO direction</dd>
</dl>
<p><strong>Context</strong></p>
<p>arch_initcall or later</p>
<p><strong>Description</strong></p>
<p>When drivers want to make a GPIO accessible to userspace after they
have requested it &#8211; perhaps while debugging, or as part of their
public interface &#8211; they may use this routine.  If the GPIO can
change direction (some can&#8217;t) and the caller allows it, userspace
will see &#8220;direction&#8221; sysfs attribute which may be used to change
the gpio&#8217;s direction.  A &#8220;value&#8221; attribute will always be provided.</p>
<p>Returns zero on success, else an error.</p>
<dl class="function">
<dt id="c.gpiod_export_link">
int <code class="descname">gpiod_export_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="../infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;dev</em>, const char *<em>&nbsp;name</em>, struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_export_link" title="Permalink to this definition">Â¶</a></dt>
<dd><p>create a sysfs link to an exported GPIO node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>device under which to create symlink</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>name of the symlink</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO to create symlink to, already exported</dd>
</dl>
<p><strong>Description</strong></p>
<p>Set up a symlink from /sys/.../dev/name to /sys/class/gpio/gpioN
node. Caller is responsible for unlinking.</p>
<p>Returns zero on success, else an error.</p>
<dl class="function">
<dt id="c.gpiod_unexport">
void <code class="descname">gpiod_unexport</code><span class="sig-paren">(</span>struct gpio_desc *<em>&nbsp;desc</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gpiod_unexport" title="Permalink to this definition">Â¶</a></dt>
<dd><p>reverse effect of <a class="reference internal" href="#c.gpiod_export" title="gpiod_export"><code class="xref c c-func docutils literal"><span class="pre">gpiod_export()</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gpio_desc</span> <span class="pre">*</span> <span class="pre">desc</span></code></dt>
<dd>GPIO to make unavailable</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is implicit on <code class="xref c c-func docutils literal"><span class="pre">gpiod_free()</span></code>.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="intro.html" class="btn btn-neutral float-right" title="Introduction" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../pinctl.html" class="btn btn-neutral" title="PINCTRL (PIN CONTROL) subsystem" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>