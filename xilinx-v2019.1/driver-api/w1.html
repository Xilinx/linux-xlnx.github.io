

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>W1: Dallas’ 1-wire bus &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="The Linux driver implementer’s API guide" href="index.html"/>
        <link rel="next" title="RapidIO Subsystem Guide" href="rapidio.html"/>
        <link rel="prev" title="Parallel Port Devices" href="miscellaneous.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">W1: Dallas&#8217; 1-wire bus</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#w1-api-internal-to-the-kernel">W1 API internal to the kernel</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">W1 API internal to the kernel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
    <li>W1: Dallas&#8217; 1-wire bus</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/w1.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="w1-dallas-1-wire-bus">
<h1>W1: Dallas&#8217; 1-wire bus<a class="headerlink" href="#w1-dallas-1-wire-bus" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">David Fries</td>
</tr>
</tbody>
</table>
<div class="section" id="w1-api-internal-to-the-kernel">
<h2>W1 API internal to the kernel<a class="headerlink" href="#w1-api-internal-to-the-kernel" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>W1 API internal to the kernel<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="include-linux-w1-h">
<h4>include/linux/w1.h<a class="headerlink" href="#include-linux-w1-h" title="Permalink to this headline">¶</a></h4>
<p>W1 kernel API functions.</p>
<dl class="type">
<dt id="c.w1_reg_num">
struct <code class="descname">w1_reg_num</code><a class="headerlink" href="#c.w1_reg_num" title="Permalink to this definition">¶</a></dt>
<dd><p>broken out slave device id</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_reg_num {
#if defined(__LITTLE_ENDIAN_BITFIELD);
  __u64 family:8,id:48, crc:8;
#elif defined(__BIG_ENDIAN_BITFIELD);
  __u64 crc:8,id:48, family:8;
#else;
#error &quot;Please fix &lt;asm/byteorder.h&gt;&quot;;
#endif;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">family</span></code></dt>
<dd>identifies the type of device</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>along with family is the unique device id</dd>
<dt><code class="docutils literal"><span class="pre">crc</span></code></dt>
<dd>checksum of the other bytes</dd>
<dt><code class="docutils literal"><span class="pre">crc</span></code></dt>
<dd>checksum of the other bytes</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>along with family is the unique device id</dd>
<dt><code class="docutils literal"><span class="pre">family</span></code></dt>
<dd>identifies the type of device</dd>
</dl>
<dl class="type">
<dt id="c.w1_slave">
struct <code class="descname">w1_slave</code><a class="headerlink" href="#c.w1_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>holds a single slave device on the bus</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_slave {
  struct module           *owner;
  unsigned char           name[W1_MAXNAMELEN];
  struct list_head        w1_slave_entry;
  struct w1_reg_num       reg_num;
  atomic_t refcnt;
  int ttl;
  unsigned long           flags;
  struct w1_master        *master;
  struct w1_family        *family;
  void *family_data;
  struct device           dev;
  struct device           *hwmon;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>Points to the one wire &#8220;wire&#8221; kernel module.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Device id is ascii.</dd>
<dt><code class="docutils literal"><span class="pre">w1_slave_entry</span></code></dt>
<dd>data for the linked list</dd>
<dt><code class="docutils literal"><span class="pre">reg_num</span></code></dt>
<dd>the slave id in binary</dd>
<dt><code class="docutils literal"><span class="pre">refcnt</span></code></dt>
<dd>reference count, delete when 0</dd>
<dt><code class="docutils literal"><span class="pre">ttl</span></code></dt>
<dd>decrement per search this slave isn&#8217;t found, deatch at 0</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>bit flags for W1_SLAVE_ACTIVE W1_SLAVE_DETACH</dd>
<dt><code class="docutils literal"><span class="pre">master</span></code></dt>
<dd>bus which this slave is on</dd>
<dt><code class="docutils literal"><span class="pre">family</span></code></dt>
<dd>module for device family type</dd>
<dt><code class="docutils literal"><span class="pre">family_data</span></code></dt>
<dd>pointer for use by the family module</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>kernel device identifier</dd>
<dt><code class="docutils literal"><span class="pre">hwmon</span></code></dt>
<dd>pointer to hwmon device</dd>
</dl>
<dl class="type">
<dt id="c.w1_bus_master">
struct <code class="descname">w1_bus_master</code><a class="headerlink" href="#c.w1_bus_master" title="Permalink to this definition">¶</a></dt>
<dd><p>operations available on a bus master</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_bus_master {
  void *data;
  u8 (*read_bit)(void *);
  void (*write_bit)(void *, u8);
  u8 (*touch_bit)(void *, u8);
  u8 (*read_byte)(void *);
  void (*write_byte)(void *, u8);
  u8 (*read_block)(void *, u8 *, int);
  void (*write_block)(void *, const u8 *, int);
  u8 (*triplet)(void *, u8);
  u8 (*reset_bus)(void *);
  u8 (*set_pullup)(void *, int);
  void (*search)(void *, struct w1_master *, u8, w1_slave_found_callback);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>the first parameter in all the functions below</dd>
<dt><code class="docutils literal"><span class="pre">read_bit</span></code></dt>
<dd>Sample the line level <strong>return</strong> the level read (0 or 1)</dd>
<dt><code class="docutils literal"><span class="pre">write_bit</span></code></dt>
<dd>Sets the line level</dd>
<dt><code class="docutils literal"><span class="pre">touch_bit</span></code></dt>
<dd>the lowest-level function for devices that really support the
1-wire protocol.
touch_bit(0) = write-0 cycle
touch_bit(1) = write-1 / read cycle
<strong>return</strong> the bit read (0 or 1)</dd>
<dt><code class="docutils literal"><span class="pre">read_byte</span></code></dt>
<dd>Reads a bytes. Same as 8 touch_bit(1) calls.
<strong>return</strong> the byte read</dd>
<dt><code class="docutils literal"><span class="pre">write_byte</span></code></dt>
<dd>Writes a byte. Same as 8 touch_bit(x) calls.</dd>
<dt><code class="docutils literal"><span class="pre">read_block</span></code></dt>
<dd>Same as a series of <code class="xref c c-func docutils literal"><span class="pre">read_byte()</span></code> calls
<strong>return</strong> the number of bytes read</dd>
<dt><code class="docutils literal"><span class="pre">write_block</span></code></dt>
<dd>Same as a series of <code class="xref c c-func docutils literal"><span class="pre">write_byte()</span></code> calls</dd>
<dt><code class="docutils literal"><span class="pre">triplet</span></code></dt>
<dd>Combines two reads and a smart write for ROM searches
<strong>return</strong> bit0=Id bit1=comp_id bit2=dir_taken</dd>
<dt><code class="docutils literal"><span class="pre">reset_bus</span></code></dt>
<dd>long write-0 with a read for the presence pulse detection
<strong>return</strong> -1=Error, 0=Device present, 1=No device present</dd>
<dt><code class="docutils literal"><span class="pre">set_pullup</span></code></dt>
<dd>Put out a strong pull-up pulse of the specified duration.
<strong>return</strong> -1=Error, 0=completed</dd>
<dt><code class="docutils literal"><span class="pre">search</span></code></dt>
<dd>Really nice hardware can handles the different types of ROM search
w1_master* is passed to the slave found callback.
u8 is search_type, W1_SEARCH or W1_ALARM_SEARCH</dd>
</dl>
<p><strong>Note</strong></p>
<p>read_bit and write_bit are very low level functions and should only
be used with hardware that doesn&#8217;t really support 1-wire operations,
like a parallel/serial port.
Either define read_bit and write_bit OR define, at minimum, touch_bit and
reset_bus.</p>
<dl class="type">
<dt id="c.w1_master_flags">
enum <code class="descname">w1_master_flags</code><a class="headerlink" href="#c.w1_master_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>bitfields used in w1_master.flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">W1_ABORT_SEARCH</span></code></dt>
<dd>abort searching early on shutdown</dd>
<dt><code class="docutils literal"><span class="pre">W1_WARN_MAX_COUNT</span></code></dt>
<dd>limit warning when the maximum count is reached</dd>
</dl>
<dl class="type">
<dt id="c.w1_master">
struct <code class="descname">w1_master</code><a class="headerlink" href="#c.w1_master" title="Permalink to this definition">¶</a></dt>
<dd><p>one per bus master</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_master {
  struct list_head        w1_master_entry;
  struct module           *owner;
  unsigned char           name[W1_MAXNAMELEN];
  struct mutex            list_mutex;
  struct list_head        slist;
  struct list_head        async_list;
  int max_slave_count, slave_count;
  unsigned long           attempts;
  int slave_ttl;
  int initialized;
  u32 id;
  int search_count;
  u64 search_id;
  atomic_t refcnt;
  void *priv;
  int enable_pullup;
  int pullup_duration;
  long flags;
  struct task_struct      *thread;
  struct mutex            mutex;
  struct mutex            bus_mutex;
  struct device_driver    *driver;
  struct device           dev;
  struct w1_bus_master    *bus_master;
  u32 seq;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">w1_master_entry</span></code></dt>
<dd>master linked list</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>module owner</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>dynamically allocate bus name</dd>
<dt><code class="docutils literal"><span class="pre">list_mutex</span></code></dt>
<dd>protect slist and async_list</dd>
<dt><code class="docutils literal"><span class="pre">slist</span></code></dt>
<dd>linked list of slaves</dd>
<dt><code class="docutils literal"><span class="pre">async_list</span></code></dt>
<dd>linked list of netlink commands to execute</dd>
<dt><code class="docutils literal"><span class="pre">max_slave_count</span></code></dt>
<dd>maximum number of slaves to search for at a time</dd>
<dt><code class="docutils literal"><span class="pre">slave_count</span></code></dt>
<dd>current number of slaves known</dd>
<dt><code class="docutils literal"><span class="pre">attempts</span></code></dt>
<dd>number of searches ran</dd>
<dt><code class="docutils literal"><span class="pre">slave_ttl</span></code></dt>
<dd>number of searches before a slave is timed out</dd>
<dt><code class="docutils literal"><span class="pre">initialized</span></code></dt>
<dd>prevent init/removal race conditions</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>w1 bus number</dd>
<dt><code class="docutils literal"><span class="pre">search_count</span></code></dt>
<dd>number of automatic searches to run, -1 unlimited</dd>
<dt><code class="docutils literal"><span class="pre">search_id</span></code></dt>
<dd>allows continuing a search</dd>
<dt><code class="docutils literal"><span class="pre">refcnt</span></code></dt>
<dd>reference count</dd>
<dt><code class="docutils literal"><span class="pre">priv</span></code></dt>
<dd>private data storage</dd>
<dt><code class="docutils literal"><span class="pre">enable_pullup</span></code></dt>
<dd>allows a strong pullup</dd>
<dt><code class="docutils literal"><span class="pre">pullup_duration</span></code></dt>
<dd>time for the next strong pullup</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>one of w1_master_flags</dd>
<dt><code class="docutils literal"><span class="pre">thread</span></code></dt>
<dd>thread for bus search and netlink commands</dd>
<dt><code class="docutils literal"><span class="pre">mutex</span></code></dt>
<dd>protect most of w1_master</dd>
<dt><code class="docutils literal"><span class="pre">bus_mutex</span></code></dt>
<dd>pretect concurrent bus access</dd>
<dt><code class="docutils literal"><span class="pre">driver</span></code></dt>
<dd>sysfs driver</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>sysfs device</dd>
<dt><code class="docutils literal"><span class="pre">bus_master</span></code></dt>
<dd>io operations available</dd>
<dt><code class="docutils literal"><span class="pre">seq</span></code></dt>
<dd>sequence number used for netlink broadcasts</dd>
</dl>
<dl class="type">
<dt id="c.w1_family_ops">
struct <code class="descname">w1_family_ops</code><a class="headerlink" href="#c.w1_family_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>operations for a family type</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_family_ops {
  int (*add_slave)(struct w1_slave *sl);
  void (*remove_slave)(struct w1_slave *sl);
  const struct attribute_group **groups;
  const struct hwmon_chip_info *chip_info;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">add_slave</span></code></dt>
<dd>add_slave</dd>
<dt><code class="docutils literal"><span class="pre">remove_slave</span></code></dt>
<dd>remove_slave</dd>
<dt><code class="docutils literal"><span class="pre">groups</span></code></dt>
<dd>sysfs group</dd>
<dt><code class="docutils literal"><span class="pre">chip_info</span></code></dt>
<dd>pointer to struct hwmon_chip_info</dd>
</dl>
<dl class="type">
<dt id="c.w1_family">
struct <code class="descname">w1_family</code><a class="headerlink" href="#c.w1_family" title="Permalink to this definition">¶</a></dt>
<dd><p>reference counted family structure.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_family {
  struct list_head        family_entry;
  u8 fid;
  struct w1_family_ops    *fops;
  const struct of_device_id *of_match_table;
  atomic_t refcnt;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">family_entry</span></code></dt>
<dd>family linked list</dd>
<dt><code class="docutils literal"><span class="pre">fid</span></code></dt>
<dd>8 bit family identifier</dd>
<dt><code class="docutils literal"><span class="pre">fops</span></code></dt>
<dd>operations for this family</dd>
<dt><code class="docutils literal"><span class="pre">refcnt</span></code></dt>
<dd>reference counter</dd>
</dl>
<dl class="function">
<dt id="c.module_w1_family">
<code class="descname">module_w1_family</code><span class="sig-paren">(</span><em>__w1_family</em><span class="sig-paren">)</span><a class="headerlink" href="#c.module_w1_family" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper macro for registering a 1-Wire families</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">__w1_family</span></code></dt>
<dd>w1_family struct</dd>
</dl>
<p><strong>Description</strong></p>
<p>Helper macro for 1-Wire families which do not do anything special in module
init/exit. This eliminates a lot of boilerplate. Each module may only
use this macro once, and calling it replaces <a class="reference internal" href="basics.html#c.module_init" title="module_init"><code class="xref c c-func docutils literal"><span class="pre">module_init()</span></code></a> and <a class="reference internal" href="basics.html#c.module_exit" title="module_exit"><code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code></a></p>
</div>
<div class="section" id="drivers-w1-w1-c">
<h4>drivers/w1/w1.c<a class="headerlink" href="#drivers-w1-w1-c" title="Permalink to this headline">¶</a></h4>
<p>W1 core functions.</p>
<dl class="function">
<dt id="c.w1_search">
void <code class="descname">w1_search</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, u8<em>&nbsp;search_type</em>, w1_slave_found_callback<em>&nbsp;cb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a ROM Search &amp; registers any devices found.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>The master device to search</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">search_type</span></code></dt>
<dd>W1_SEARCH to search all devices, or W1_ALARM_SEARCH
to return only devices in the alarmed state</dd>
<dt><code class="docutils literal"><span class="pre">w1_slave_found_callback</span> <span class="pre">cb</span></code></dt>
<dd>Function to call when a device is found</dd>
</dl>
<p><strong>Description</strong></p>
<p>The 1-wire search is a simple binary tree search.
For each bit of the address, we read two bits and write one bit.
The bit written will put to sleep all devies that don&#8217;t match that bit.
When the two reads differ, the direction choice is obvious.
When both bits are 0, we must choose a path to take.
When we can scan all 64 bits without having to choose a path, we are done.</p>
<p>See &#8220;Application note 187 1-wire search algorithm&#8221; at www.maxim-ic.com</p>
<dl class="function">
<dt id="c.w1_process_callbacks">
int <code class="descname">w1_process_callbacks</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_process_callbacks" title="Permalink to this definition">¶</a></dt>
<dd><p>execute each dev-&gt;async_list callback entry</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>w1_master device</dd>
</dl>
<p><strong>Description</strong></p>
<p>The w1 master list_mutex must be held.</p>
<p><strong>Return</strong></p>
<p>1 if there were commands to executed 0 otherwise</p>
</div>
<div class="section" id="drivers-w1-w1-family-c">
<h4>drivers/w1/w1_family.c<a class="headerlink" href="#drivers-w1-w1-family-c" title="Permalink to this headline">¶</a></h4>
<p>Allows registering device family operations.</p>
<dl class="function">
<dt id="c.w1_register_family">
int <code class="descname">w1_register_family</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_family" title="w1_family">w1_family</a> *<em>&nbsp;newf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_register_family" title="Permalink to this definition">¶</a></dt>
<dd><p>register a device family driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_family</span> <span class="pre">*</span> <span class="pre">newf</span></code></dt>
<dd>family to register</dd>
</dl>
<dl class="function">
<dt id="c.w1_unregister_family">
void <code class="descname">w1_unregister_family</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_family" title="w1_family">w1_family</a> *<em>&nbsp;fent</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_unregister_family" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a device family driver</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_family</span> <span class="pre">*</span> <span class="pre">fent</span></code></dt>
<dd>family to unregister</dd>
</dl>
</div>
<div class="section" id="drivers-w1-w1-internal-h">
<h4>drivers/w1/w1_internal.h<a class="headerlink" href="#drivers-w1-w1-internal-h" title="Permalink to this headline">¶</a></h4>
<p>W1 internal initialization for master devices.</p>
<dl class="type">
<dt id="c.w1_async_cmd">
struct <code class="descname">w1_async_cmd</code><a class="headerlink" href="#c.w1_async_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>execute callback from the w1_process kthread</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_async_cmd {
  struct list_head        async_entry;
  void (*cb)(struct w1_master *dev, struct w1_async_cmd *async_cmd);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">async_entry</span></code></dt>
<dd>link entry</dd>
<dt><code class="docutils literal"><span class="pre">cb</span></code></dt>
<dd>callback function, must list_del and destroy this list before
returning</dd>
</dl>
<p><strong>Description</strong></p>
<p>When inserted into the w1_master async_list, w1_process will execute
the callback.  Embed this into the structure with the command details.</p>
</div>
<div class="section" id="drivers-w1-w1-int-c">
<h4>drivers/w1/w1_int.c<a class="headerlink" href="#drivers-w1-w1-int-c" title="Permalink to this headline">¶</a></h4>
<p>W1 internal initialization for master devices.</p>
<dl class="function">
<dt id="c.w1_add_master_device">
int <code class="descname">w1_add_master_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_bus_master" title="w1_bus_master">w1_bus_master</a> *<em>&nbsp;master</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_add_master_device" title="Permalink to this definition">¶</a></dt>
<dd><p>registers a new master device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_bus_master</span> <span class="pre">*</span> <span class="pre">master</span></code></dt>
<dd>master bus device to register</dd>
</dl>
<dl class="function">
<dt id="c.w1_remove_master_device">
void <code class="descname">w1_remove_master_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_bus_master" title="w1_bus_master">w1_bus_master</a> *<em>&nbsp;bm</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_remove_master_device" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a master device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_bus_master</span> <span class="pre">*</span> <span class="pre">bm</span></code></dt>
<dd>master bus device to remove</dd>
</dl>
</div>
<div class="section" id="drivers-w1-w1-netlink-h">
<h4>drivers/w1/w1_netlink.h<a class="headerlink" href="#drivers-w1-w1-netlink-h" title="Permalink to this headline">¶</a></h4>
<p>W1 external netlink API structures and commands.</p>
<dl class="type">
<dt id="c.w1_cn_msg_flags">
enum <code class="descname">w1_cn_msg_flags</code><a class="headerlink" href="#c.w1_cn_msg_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>bitfield flags for struct cn_msg.flags</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">W1_CN_BUNDLE</span></code></dt>
<dd>Request bundling replies into fewer messagse.  Be prepared
to handle multiple struct cn_msg, struct w1_netlink_msg, and
struct w1_netlink_cmd in one packet.</dd>
</dl>
<dl class="type">
<dt id="c.w1_netlink_message_types">
enum <code class="descname">w1_netlink_message_types</code><a class="headerlink" href="#c.w1_netlink_message_types" title="Permalink to this definition">¶</a></dt>
<dd><p>message type</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">W1_SLAVE_ADD</span></code></dt>
<dd>notification that a slave device was added</dd>
<dt><code class="docutils literal"><span class="pre">W1_SLAVE_REMOVE</span></code></dt>
<dd>notification that a slave device was removed</dd>
<dt><code class="docutils literal"><span class="pre">W1_MASTER_ADD</span></code></dt>
<dd>notification that a new bus master was added</dd>
<dt><code class="docutils literal"><span class="pre">W1_MASTER_REMOVE</span></code></dt>
<dd>notification that a bus masterwas removed</dd>
<dt><code class="docutils literal"><span class="pre">W1_MASTER_CMD</span></code></dt>
<dd>initiate operations on a specific master</dd>
<dt><code class="docutils literal"><span class="pre">W1_SLAVE_CMD</span></code></dt>
<dd>sends reset, selects the slave, then does a read/write/touch
operation</dd>
<dt><code class="docutils literal"><span class="pre">W1_LIST_MASTERS</span></code></dt>
<dd>used to determine the bus master identifiers</dd>
</dl>
<dl class="type">
<dt id="c.w1_netlink_msg">
struct <code class="descname">w1_netlink_msg</code><a class="headerlink" href="#c.w1_netlink_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>holds w1 message type, id, and result</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_netlink_msg {
  __u8 type;
  __u8 status;
  __u16 len;
  union {
    __u8 id[8];
    struct w1_mst {
      __u32 id;
      __u32 res;
    } mst;
  } id;
  __u8 data[0];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>one of enum w1_netlink_message_types</dd>
<dt><code class="docutils literal"><span class="pre">status</span></code></dt>
<dd>kernel feedback for success 0 or errno failure value</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>length of data following w1_netlink_msg</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>union holding bus master id (msg.id) and slave device id (id[8]).</dd>
<dt><code class="docutils literal"><span class="pre">id.id</span></code></dt>
<dd>Slave ID (8 bytes)</dd>
<dt><code class="docutils literal"><span class="pre">id.mst</span></code></dt>
<dd>bus master identification</dd>
<dt><code class="docutils literal"><span class="pre">id.mst.id</span></code></dt>
<dd>bus master ID</dd>
<dt><code class="docutils literal"><span class="pre">id.mst.res</span></code></dt>
<dd>bus master reserved</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>start address of any following data</dd>
</dl>
<p><strong>Description</strong></p>
<p>The base message structure for w1 messages over netlink.
The netlink connector data sequence is, struct nlmsghdr, struct cn_msg,
then one or more struct w1_netlink_msg (each with optional data).</p>
<dl class="type">
<dt id="c.w1_commands">
enum <code class="descname">w1_commands</code><a class="headerlink" href="#c.w1_commands" title="Permalink to this definition">¶</a></dt>
<dd><p>commands available for master or slave operations</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">W1_CMD_READ</span></code></dt>
<dd>read len bytes</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_WRITE</span></code></dt>
<dd>write len bytes</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_SEARCH</span></code></dt>
<dd>initiate a standard search, returns only the slave
devices found during that search</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_ALARM_SEARCH</span></code></dt>
<dd>search for devices that are currently alarming</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_TOUCH</span></code></dt>
<dd>Touches a series of bytes.</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_RESET</span></code></dt>
<dd>sends a bus reset on the given master</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_SLAVE_ADD</span></code></dt>
<dd>adds a slave to the given master,
8 byte slave id at data[0]</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_SLAVE_REMOVE</span></code></dt>
<dd>removes a slave to the given master,
8 byte slave id at data[0]</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_LIST_SLAVES</span></code></dt>
<dd>list of slaves registered on this master</dd>
<dt><code class="docutils literal"><span class="pre">W1_CMD_MAX</span></code></dt>
<dd>number of available commands</dd>
</dl>
<dl class="type">
<dt id="c.w1_netlink_cmd">
struct <code class="descname">w1_netlink_cmd</code><a class="headerlink" href="#c.w1_netlink_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>holds the command and data</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct w1_netlink_cmd {
  __u8 cmd;
  __u8 res;
  __u16 len;
  __u8 data[0];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">cmd</span></code></dt>
<dd>one of enum w1_commands</dd>
<dt><code class="docutils literal"><span class="pre">res</span></code></dt>
<dd>reserved</dd>
<dt><code class="docutils literal"><span class="pre">len</span></code></dt>
<dd>length of data following w1_netlink_cmd</dd>
<dt><code class="docutils literal"><span class="pre">data</span></code></dt>
<dd>start address of any following data</dd>
</dl>
<p><strong>Description</strong></p>
<p>One or more struct w1_netlink_cmd is placed starting at w1_netlink_msg.data
each with optional data.</p>
</div>
<div class="section" id="drivers-w1-w1-io-c">
<h4>drivers/w1/w1_io.c<a class="headerlink" href="#drivers-w1-w1-io-c" title="Permalink to this headline">¶</a></h4>
<p>W1 input/output.</p>
<dl class="function">
<dt id="c.w1_touch_bit">
u8 <code class="descname">w1_touch_bit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, int<em>&nbsp;bit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_touch_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a write-0 or write-1 cycle and samples the level.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bit</span></code></dt>
<dd>0 - write a 0, 1 - write a 0 read the level</dd>
</dl>
<dl class="function">
<dt id="c.w1_write_8">
void <code class="descname">w1_write_8</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, u8<em>&nbsp;byte</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_write_8" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes 8 bits.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">byte</span></code></dt>
<dd>the byte to write</dd>
</dl>
<dl class="function">
<dt id="c.w1_triplet">
u8 <code class="descname">w1_triplet</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, int<em>&nbsp;bdir</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_triplet" title="Permalink to this definition">¶</a></dt>
<dd><ul class="simple">
<li>Does a triplet - used for searching ROM addresses.</li>
</ul>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bdir</span></code></dt>
<dd>the bit to write if both id_bit and comp_bit are 0</dd>
</dl>
<p><strong>Description</strong></p>
<dl class="docutils">
<dt>Return bits:</dt>
<dd>bit 0 = id_bit
bit 1 = comp_bit
bit 2 = dir_taken</dd>
</dl>
<p>If both bits 0 &amp; 1 are set, the search should be restarted.</p>
<p><strong>Return</strong></p>
<p>bit fields - see above</p>
<dl class="function">
<dt id="c.w1_read_8">
u8 <code class="descname">w1_read_8</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_read_8" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads 8 bits.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
</dl>
<p><strong>Return</strong></p>
<p>the byte read</p>
<dl class="function">
<dt id="c.w1_write_block">
void <code class="descname">w1_write_block</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, const u8 *<em>&nbsp;buf</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_write_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a series of bytes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to the data to write</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>the number of bytes to write</dd>
</dl>
<dl class="function">
<dt id="c.w1_touch_block">
void <code class="descname">w1_touch_block</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, u8 *<em>&nbsp;buf</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_touch_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Touches a series of bytes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to the data to write</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>the number of bytes to write</dd>
</dl>
<dl class="function">
<dt id="c.w1_read_block">
u8 <code class="descname">w1_read_block</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, u8 *<em>&nbsp;buf</em>, int<em>&nbsp;len</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_read_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a series of bytes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
<dt><code class="docutils literal"><span class="pre">u8</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt>
<dd>pointer to the buffer to fill</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">len</span></code></dt>
<dd>the number of bytes to read</dd>
</dl>
<p><strong>Return</strong></p>
<p>the number of bytes read</p>
<dl class="function">
<dt id="c.w1_reset_bus">
int <code class="descname">w1_reset_bus</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_reset_bus" title="Permalink to this definition">¶</a></dt>
<dd><p>Issues a reset bus sequence.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
</dl>
<p><strong>Return</strong></p>
<p>0=Device present, 1=No device present or error</p>
<dl class="function">
<dt id="c.w1_reset_select_slave">
int <code class="descname">w1_reset_select_slave</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_slave" title="w1_slave">w1_slave</a> *<em>&nbsp;sl</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_reset_select_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>reset and select a slave</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_slave</span> <span class="pre">*</span> <span class="pre">sl</span></code></dt>
<dd>the slave to select</dd>
</dl>
<p><strong>Description</strong></p>
<p>Resets the bus and then selects the slave by sending either a skip rom
or a rom match.  A skip rom is issued if there is only one device
registered on the bus.
The w1 master lock must be held.</p>
<p><strong>Return</strong></p>
<p>0=success, anything else=error</p>
<dl class="function">
<dt id="c.w1_reset_resume_command">
int <code class="descname">w1_reset_resume_command</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_reset_resume_command" title="Permalink to this definition">¶</a></dt>
<dd><p>resume instead of another match ROM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
</dl>
<p><strong>Description</strong></p>
<p>When the workflow with a slave amongst many requires several
successive commands a reset between each, this function is similar
to doing a reset then a match ROM for the last matched ROM. The
advantage being that the matched ROM step is skipped in favor of the
resume command. The slave must support the command of course.</p>
<p>If the bus has only one slave, traditionnaly the match ROM is skipped
and a &#8220;SKIP ROM&#8221; is done for efficiency. On multi-slave busses, this
doesn&#8217;t work of course, but the resume command is the next best thing.</p>
<p>The w1 master lock must be held.</p>
<dl class="function">
<dt id="c.w1_next_pullup">
void <code class="descname">w1_next_pullup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, int<em>&nbsp;delay</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_next_pullup" title="Permalink to this definition">¶</a></dt>
<dd><p>register for a strong pullup</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">delay</span></code></dt>
<dd>time in milliseconds</dd>
</dl>
<p><strong>Description</strong></p>
<p>Put out a strong pull-up of the specified duration after the next write
operation.  Not all hardware supports strong pullups.  Hardware that
doesn&#8217;t support strong pullups will sleep for the given time after the
write operation without a strong pullup.  This is a one shot request for
the next write, specifying zero will clear a previous request.
The w1 master lock must be held.</p>
<p><strong>Return</strong></p>
<p>0=success, anything else=error</p>
<dl class="function">
<dt id="c.w1_write_bit">
void <code class="descname">w1_write_bit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em>, int<em>&nbsp;bit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_write_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a write-0 or write-1 cycle.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">bit</span></code></dt>
<dd>bit to write</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only call if dev-&gt;bus_master-&gt;touch_bit is NULL</p>
<dl class="function">
<dt id="c.w1_pre_write">
void <code class="descname">w1_pre_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_pre_write" title="Permalink to this definition">¶</a></dt>
<dd><p>pre-write operations</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Pre-write operation, currently only supporting strong pullups.
Program the hardware for a strong pullup, if one has been requested and
the hardware supports it.</p>
<dl class="function">
<dt id="c.w1_post_write">
void <code class="descname">w1_post_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_post_write" title="Permalink to this definition">¶</a></dt>
<dd><p>post-write options</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Post-write operation, currently only supporting strong pullups.
If a strong pullup was requested, clear it if the hardware supports
them, or execute the delay otherwise, in either case clear the request.</p>
<dl class="function">
<dt id="c.w1_read_bit">
u8 <code class="descname">w1_read_bit</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.w1_master" title="w1_master">w1_master</a> *<em>&nbsp;dev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.w1_read_bit" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a write-1 cycle and samples the level.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">w1_master</span> <span class="pre">*</span> <span class="pre">dev</span></code></dt>
<dd>the master device</dd>
</dl>
<p><strong>Description</strong></p>
<p>Only call if dev-&gt;bus_master-&gt;touch_bit is NULL</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="rapidio.html" class="btn btn-neutral float-right" title="RapidIO Subsystem Guide" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="miscellaneous.html" class="btn btn-neutral" title="Parallel Port Devices" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>