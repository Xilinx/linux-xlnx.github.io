

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DMAengine controller documentation &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/>
        <link rel="up" title="DMAEngine documentation" href="index.html"/>
        <link rel="next" title="DMA Engine API Guide" href="client.html"/>
        <link rel="prev" title="DMAEngine documentation" href="index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../device_link.html">Device links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libata.html">libATA Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../w1.html">W1: Dallas&#8217; 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">DMAEngine documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html#id1">DMAEngine documentation</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="">DMAengine controller documentation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dmaengine-client-documentation">DMAEngine client documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dma-test-documentation">DMA Test documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#pxa-dma-documentation">PXA DMA documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
          <li><a href="index.html">DMAEngine documentation</a> &raquo;</li>
      
    <li>DMAengine controller documentation</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/driver-api/dmaengine/provider.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dmaengine-controller-documentation">
<h1>DMAengine controller documentation<a class="headerlink" href="#dmaengine-controller-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="hardware-introduction">
<h2>Hardware Introduction<a class="headerlink" href="#hardware-introduction" title="Permalink to this headline">¶</a></h2>
<p>Most of the Slave DMA controllers have the same general principles of
operations.</p>
<p>They have a given number of channels to use for the DMA transfers, and
a given number of requests lines.</p>
<p>Requests and channels are pretty much orthogonal. Channels can be used
to serve several to any requests. To simplify, channels are the
entities that will be doing the copy, and requests what endpoints are
involved.</p>
<p>The request lines actually correspond to physical lines going from the
DMA-eligible devices to the controller itself. Whenever the device
will want to start a transfer, it will assert a DMA request (DRQ) by
asserting that request line.</p>
<p>A very simple DMA controller would only take into account a single
parameter: the transfer size. At each clock cycle, it would transfer a
byte of data from one buffer to another, until the transfer size has
been reached.</p>
<p>That wouldn&#8217;t work well in the real world, since slave devices might
require a specific number of bits to be transferred in a single
cycle. For example, we may want to transfer as much data as the
physical bus allows to maximize performances when doing a simple
memory copy operation, but our audio device could have a narrower FIFO
that requires data to be written exactly 16 or 24 bits at a time. This
is why most if not all of the DMA controllers can adjust this, using a
parameter called the transfer width.</p>
<p>Moreover, some DMA controllers, whenever the RAM is used as a source
or destination, can group the reads or writes in memory into a buffer,
so instead of having a lot of small memory accesses, which is not
really efficient, you&#8217;ll get several bigger transfers. This is done
using a parameter called the burst size, that defines how many single
reads/writes it&#8217;s allowed to do without the controller splitting the
transfer into smaller sub-transfers.</p>
<p>Our theoretical DMA controller would then only be able to do transfers
that involve a single contiguous block of data. However, some of the
transfers we usually have are not, and want to copy data from
non-contiguous buffers to a contiguous buffer, which is called
scatter-gather.</p>
<p>DMAEngine, at least for mem2dev transfers, require support for
scatter-gather. So we&#8217;re left with two cases here: either we have a
quite simple DMA controller that doesn&#8217;t support it, and we&#8217;ll have to
implement it in software, or we have a more advanced DMA controller,
that implements in hardware scatter-gather.</p>
<p>The latter are usually programmed using a collection of chunks to
transfer, and whenever the transfer is started, the controller will go
over that collection, doing whatever we programmed there.</p>
<p>This collection is usually either a table or a linked list. You will
then push either the address of the table and its number of elements,
or the first item of the list to one channel of the DMA controller,
and whenever a DRQ will be asserted, it will go through the collection
to know where to fetch the data from.</p>
<p>Either way, the format of this collection is completely dependent on
your hardware. Each DMA controller will require a different structure,
but all of them will require, for every chunk, at least the source and
destination addresses, whether it should increment these addresses or
not and the three parameters we saw earlier: the burst size, the
transfer width and the transfer size.</p>
<p>The one last thing is that usually, slave devices won&#8217;t issue DRQ by
default, and you have to enable this in your slave device driver first
whenever you&#8217;re willing to use DMA.</p>
<p>These were just the general memory-to-memory (also called mem2mem) or
memory-to-device (mem2dev) kind of transfers. Most devices often
support other kind of transfers or memory operations that dmaengine
support and will be detailed later in this document.</p>
</div>
<div class="section" id="dma-support-in-linux">
<h2>DMA Support in Linux<a class="headerlink" href="#dma-support-in-linux" title="Permalink to this headline">¶</a></h2>
<p>Historically, DMA controller drivers have been implemented using the
async TX API, to offload operations such as memory copy, XOR,
cryptography, etc., basically any memory to memory operation.</p>
<p>Over time, the need for memory to device transfers arose, and
dmaengine was extended. Nowadays, the async TX API is written as a
layer on top of dmaengine, and acts as a client. Still, dmaengine
accommodates that API in some cases, and made some design choices to
ensure that it stayed compatible.</p>
<p>For more information on the Async TX API, please look the relevant
documentation file in Documentation/crypto/async-tx-api.txt.</p>
</div>
<div class="section" id="dmaengine-apis">
<h2>DMAEngine APIs<a class="headerlink" href="#dmaengine-apis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="struct-dma-device-initialization">
<h3><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dma_device</span></code> Initialization<a class="headerlink" href="#struct-dma-device-initialization" title="Permalink to this headline">¶</a></h3>
<p>Just like any other kernel framework, the whole DMAEngine registration
relies on the driver filling a structure and registering against the
framework. In our case, that structure is dma_device.</p>
<p>The first thing you need to do in your driver is to allocate this
structure. Any of the usual memory allocators will do, but you&#8217;ll also
need to initialize a few fields in there:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">channels</span></code>: should be initialized as a list using the
INIT_LIST_HEAD macro for example</li>
<li><code class="docutils literal"><span class="pre">src_addr_widths</span></code>:
should contain a bitmask of the supported source transfer width</li>
<li><code class="docutils literal"><span class="pre">dst_addr_widths</span></code>:
should contain a bitmask of the supported destination transfer width</li>
<li><code class="docutils literal"><span class="pre">directions</span></code>:
should contain a bitmask of the supported slave directions
(i.e. excluding mem2mem transfers)</li>
<li><code class="docutils literal"><span class="pre">residue_granularity</span></code>:
granularity of the transfer residue reported to dma_set_residue.
This can be either:<ul>
<li>Descriptor:
your device doesn&#8217;t support any kind of residue
reporting. The framework will only know that a particular
transaction descriptor is done.</li>
<li>Segment:
your device is able to report which chunks have been transferred</li>
<li>Burst:
your device is able to report which burst have been transferred</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">dev</span></code>: should hold the pointer to the <code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> associated
to your current driver instance.</li>
</ul>
</div>
<div class="section" id="supported-transaction-types">
<h3>Supported transaction types<a class="headerlink" href="#supported-transaction-types" title="Permalink to this headline">¶</a></h3>
<p>The next thing you need is to set which transaction types your device
(and driver) supports.</p>
<p>Our <code class="docutils literal"><span class="pre">dma_device</span> <span class="pre">structure</span></code> has a field called cap_mask that holds the
various types of transaction supported, and you need to modify this
mask using the dma_cap_set function, with various flags depending on
transaction types you support as an argument.</p>
<p>All those capabilities are defined in the <code class="docutils literal"><span class="pre">dma_transaction_type</span> <span class="pre">enum</span></code>,
in <code class="docutils literal"><span class="pre">include/linux/dmaengine.h</span></code></p>
<p>Currently, the types available are:</p>
<ul>
<li><p class="first">DMA_MEMCPY</p>
<ul class="simple">
<li>The device is able to do memory to memory copies</li>
</ul>
</li>
<li><p class="first">DMA_XOR</p>
<ul class="simple">
<li>The device is able to perform XOR operations on memory areas</li>
<li>Used to accelerate XOR intensive tasks, such as RAID5</li>
</ul>
</li>
<li><p class="first">DMA_XOR_VAL</p>
<ul class="simple">
<li>The device is able to perform parity check using the XOR
algorithm against a memory buffer.</li>
</ul>
</li>
<li><p class="first">DMA_PQ</p>
<ul class="simple">
<li>The device is able to perform RAID6 P+Q computations, P being a
simple XOR, and Q being a Reed-Solomon algorithm.</li>
</ul>
</li>
<li><p class="first">DMA_PQ_VAL</p>
<ul class="simple">
<li>The device is able to perform parity check using RAID6 P+Q
algorithm against a memory buffer.</li>
</ul>
</li>
<li><p class="first">DMA_INTERRUPT</p>
<ul class="simple">
<li>The device is able to trigger a dummy transfer that will
generate periodic interrupts</li>
<li>Used by the client drivers to register a callback that will be
called on a regular basis through the DMA controller interrupt</li>
</ul>
</li>
<li><p class="first">DMA_SG
- The device supports memory to memory scatter-gather</p>
<blockquote>
<div><p>transfers.</p>
</div></blockquote>
<ul class="simple">
<li>Even though a plain memcpy can look like a particular case of a
scatter-gather transfer, with a single chunk to transfer, it&#8217;s a
distinct transaction type in the mem2mem transfers case</li>
</ul>
</li>
<li><p class="first">DMA_PRIVATE</p>
<ul class="simple">
<li>The devices only supports slave transfers, and as such isn&#8217;t
available for async transfers.</li>
</ul>
</li>
<li><p class="first">DMA_ASYNC_TX</p>
<ul class="simple">
<li>Must not be set by the device, and will be set by the framework
if needed</li>
<li>TODO: What is it about?</li>
</ul>
</li>
<li><p class="first">DMA_SLAVE</p>
<ul class="simple">
<li>The device can handle device to memory transfers, including
scatter-gather transfers.</li>
<li>While in the mem2mem case we were having two distinct types to
deal with a single chunk to copy or a collection of them, here,
we just have a single transaction type that is supposed to
handle both.</li>
<li>If you want to transfer a single contiguous memory buffer,
simply build a scatter list with only one item.</li>
</ul>
</li>
<li><p class="first">DMA_CYCLIC</p>
<ul class="simple">
<li>The device can handle cyclic transfers.</li>
<li>A cyclic transfer is a transfer where the chunk collection will
loop over itself, with the last item pointing to the first.</li>
<li>It&#8217;s usually used for audio transfers, where you want to operate
on a single ring buffer that you will fill with your audio data.</li>
</ul>
</li>
<li><p class="first">DMA_INTERLEAVE</p>
<ul class="simple">
<li>The device supports interleaved transfer.</li>
<li>These transfers can transfer data from a non-contiguous buffer
to a non-contiguous buffer, opposed to DMA_SLAVE that can
transfer data from a non-contiguous data set to a continuous
destination buffer.</li>
<li>It&#8217;s usually used for 2d content transfers, in which case you
want to transfer a portion of uncompressed data directly to the
display to print it</li>
</ul>
</li>
</ul>
<p>These various types will also affect how the source and destination
addresses change over time.</p>
<p>Addresses pointing to RAM are typically incremented (or decremented)
after each transfer. In case of a ring buffer, they may loop
(DMA_CYCLIC). Addresses pointing to a device&#8217;s register (e.g. a FIFO)
are typically fixed.</p>
</div>
<div class="section" id="device-operations">
<h3>Device operations<a class="headerlink" href="#device-operations" title="Permalink to this headline">¶</a></h3>
<p>Our dma_device structure also requires a few function pointers in
order to implement the actual logic, now that we described what
operations we were able to perform.</p>
<p>The functions that we have to fill in there, and hence have to
implement, obviously depend on the transaction types you reported as
supported.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">device_alloc_chan_resources</span></code></li>
<li><code class="docutils literal"><span class="pre">device_free_chan_resources</span></code><ul>
<li>These functions will be called whenever a driver will call
<code class="docutils literal"><span class="pre">dma_request_channel</span></code> or <code class="docutils literal"><span class="pre">dma_release_channel</span></code> for the first/last
time on the channel associated to that driver.</li>
<li>They are in charge of allocating/freeing all the needed
resources in order for that channel to be useful for your driver.</li>
<li>These functions can sleep.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">device_prep_dma_*</span></code><ul>
<li>These functions are matching the capabilities you registered
previously.</li>
<li>These functions all take the buffer or the scatterlist relevant
for the transfer being prepared, and should create a hardware
descriptor or a list of hardware descriptors from it</li>
<li>These functions can be called from an interrupt context</li>
<li>Any allocation you might do should be using the GFP_NOWAIT
flag, in order not to potentially sleep, but without depleting
the emergency pool either.</li>
<li>Drivers should try to pre-allocate any memory they might need
during the transfer setup at probe time to avoid putting to
much pressure on the nowait allocator.</li>
<li>It should return a unique instance of the
<code class="docutils literal"><span class="pre">dma_async_tx_descriptor</span> <span class="pre">structure</span></code>, that further represents this
particular transfer.</li>
<li>This structure can be initialized using the function
<code class="docutils literal"><span class="pre">dma_async_tx_descriptor_init</span></code>.</li>
<li>You&#8217;ll also need to set two fields in this structure:<ul>
<li>flags:
TODO: Can it be modified by the driver itself, or
should it be always the flags passed in the arguments</li>
<li>tx_submit: A pointer to a function you have to implement,
that is supposed to push the current transaction descriptor to a
pending queue, waiting for issue_pending to be called.</li>
</ul>
</li>
<li>In this structure the function pointer callback_result can be
initialized in order for the submitter to be notified that a
transaction has completed. In the earlier code the function pointer
callback has been used. However it does not provide any status to the
transaction and will be deprecated. The result structure defined as
<code class="docutils literal"><span class="pre">dmaengine_result</span></code> that is passed in to callback_result
has two fields:<ul>
<li>result: This provides the transfer result defined by
<code class="docutils literal"><span class="pre">dmaengine_tx_result</span></code>. Either success or some error condition.</li>
<li>residue: Provides the residue bytes of the transfer for those that
support residue.</li>
</ul>
</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">device_issue_pending</span></code><ul>
<li>Takes the first transaction descriptor in the pending queue,
and starts the transfer. Whenever that transfer is done, it
should move to the next transaction in the list.</li>
<li>This function can be called in an interrupt context</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">device_tx_status</span></code><ul>
<li>Should report the bytes left to go over on the given channel</li>
<li>Should only care about the transaction descriptor passed as
argument, not the currently active one on a given channel</li>
<li>The tx_state argument might be NULL</li>
<li>Should use dma_set_residue to report it</li>
<li>In the case of a cyclic transfer, it should only take into
account the current period.</li>
<li>This function can be called in an interrupt context.</li>
</ul>
</li>
<li>device_config<ul>
<li>Reconfigures the channel with the configuration given as argument</li>
<li>This command should NOT perform synchronously, or on any
currently queued transfers, but only on subsequent ones</li>
<li>In this case, the function will receive a <code class="docutils literal"><span class="pre">dma_slave_config</span></code>
structure pointer as an argument, that will detail which
configuration to use.</li>
<li>Even though that structure contains a direction field, this
field is deprecated in favor of the direction argument given to
the prep_* functions</li>
<li>This call is mandatory for slave operations only. This should NOT be
set or expected to be set for memcpy operations.
If a driver support both, it should use this call for slave
operations only and not for memcpy ones.</li>
</ul>
</li>
<li>device_pause<ul>
<li>Pauses a transfer on the channel</li>
<li>This command should operate synchronously on the channel,
pausing right away the work of the given channel</li>
</ul>
</li>
<li>device_resume<ul>
<li>Resumes a transfer on the channel</li>
<li>This command should operate synchronously on the channel,
resuming right away the work of the given channel</li>
</ul>
</li>
<li>device_terminate_all<ul>
<li>Aborts all the pending and ongoing transfers on the channel</li>
<li>For aborted transfers the complete callback should not be called</li>
<li>Can be called from atomic context or from within a complete
callback of a descriptor. Must not sleep. Drivers must be able
to handle this correctly.</li>
<li>Termination may be asynchronous. The driver does not have to
wait until the currently active transfer has completely stopped.
See device_synchronize.</li>
</ul>
</li>
<li>device_synchronize<ul>
<li>Must synchronize the termination of a channel to the current
context.</li>
<li>Must make sure that memory for previously submitted
descriptors is no longer accessed by the DMA controller.</li>
<li>Must make sure that all complete callbacks for previously
submitted descriptors have finished running and none are
scheduled to run.</li>
<li>May sleep.</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="misc-notes">
<h2>Misc notes<a class="headerlink" href="#misc-notes" title="Permalink to this headline">¶</a></h2>
<p>(stuff that should be documented, but don&#8217;t really know
where to put them)</p>
<p><code class="docutils literal"><span class="pre">dma_run_dependencies</span></code></p>
<ul class="simple">
<li>Should be called at the end of an async TX transfer, and can be
ignored in the slave transfers case.</li>
<li>Makes sure that dependent operations are run before marking it
as complete.</li>
</ul>
<p>dma_cookie_t</p>
<ul class="simple">
<li>it&#8217;s a DMA transaction ID that will increment over time.</li>
<li>Not really relevant any more since the introduction of <code class="docutils literal"><span class="pre">virt-dma</span></code>
that abstracts it away.</li>
</ul>
<p>DMA_CTRL_ACK</p>
<ul class="simple">
<li>If clear, the descriptor cannot be reused by provider until the
client acknowledges receipt, i.e. has has a chance to establish any
dependency chains</li>
<li>This can be acked by invoking async_tx_ack()</li>
<li>If set, does not mean descriptor can be reused</li>
</ul>
<p>DMA_CTRL_REUSE</p>
<ul class="simple">
<li>If set, the descriptor can be reused after being completed. It should
not be freed by provider if this flag is set.</li>
<li>The descriptor should be prepared for reuse by invoking
<code class="docutils literal"><span class="pre">dmaengine_desc_set_reuse()</span></code> which will set DMA_CTRL_REUSE.</li>
<li><code class="docutils literal"><span class="pre">dmaengine_desc_set_reuse()</span></code> will succeed only when channel support
reusable descriptor as exhibited by capabilities</li>
<li>As a consequence, if a device driver wants to skip the
<code class="docutils literal"><span class="pre">dma_map_sg()</span></code> and <code class="docutils literal"><span class="pre">dma_unmap_sg()</span></code> in between 2 transfers,
because the DMA&#8217;d data wasn&#8217;t used, it can resubmit the transfer right after
its completion.</li>
<li>Descriptor can be freed in few ways<ul>
<li>Clearing DMA_CTRL_REUSE by invoking
<code class="docutils literal"><span class="pre">dmaengine_desc_clear_reuse()</span></code> and submitting for last txn</li>
<li>Explicitly invoking <code class="docutils literal"><span class="pre">dmaengine_desc_free()</span></code>, this can succeed only
when DMA_CTRL_REUSE is already set</li>
<li>Terminating the channel</li>
</ul>
</li>
<li>DMA_PREP_CMD<ul>
<li>If set, the client driver tells DMA controller that passed data in DMA
API is command data.</li>
<li>Interpretation of command data is DMA controller specific. It can be
used for issuing commands to other peripherals/register reads/register
writes for which the descriptor should be in different format from
normal data descriptors.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="general-design-notes">
<h2>General Design Notes<a class="headerlink" href="#general-design-notes" title="Permalink to this headline">¶</a></h2>
<p>Most of the DMAEngine drivers you&#8217;ll see are based on a similar design
that handles the end of transfer interrupts in the handler, but defer
most work to a tasklet, including the start of a new transfer whenever
the previous transfer ended.</p>
<p>This is a rather inefficient design though, because the inter-transfer
latency will be not only the interrupt latency, but also the
scheduling latency of the tasklet, which will leave the channel idle
in between, which will slow down the global transfer rate.</p>
<p>You should avoid this kind of practice, and instead of electing a new
transfer in your tasklet, move that part to the interrupt handler in
order to have a shorter idle window (that we can&#8217;t really avoid
anyway).</p>
</div>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Burst: A number of consecutive read or write operations that
can be queued to buffers before being flushed to memory.</li>
<li>Chunk: A contiguous collection of bursts</li>
<li>Transfer: A collection of chunks (be it contiguous or not)</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="client.html" class="btn btn-neutral float-right" title="DMA Engine API Guide" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="DMAEngine documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>