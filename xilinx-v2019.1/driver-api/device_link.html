

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Device links &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="The Linux driver implementerâ€™s API guide" href="index.html"/>
        <link rel="next" title="Message-based devices" href="message-based.html"/>
        <link rel="prev" title="Buffer Sharing and Synchronization" href="dma-buf.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Linux driver implementer&#8217;s API guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="basics.html">Driver Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="infrastructure.html">Device drivers infrastructure</a></li>
<li class="toctree-l2"><a class="reference internal" href="pm/index.html">Device Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="clk.html">The Common Clk Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_connection.html">Device connections</a></li>
<li class="toctree-l2"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Device links</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limitations">Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#state-machine">State machine</a></li>
<li class="toctree-l3"><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="message-based.html">Message-based devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="sound.html">Sound Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="frame-buffer.html">Frame Buffer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regulator.html">Voltage and current regulator API</a></li>
<li class="toctree-l2"><a class="reference internal" href="iio/index.html">Industrial I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="input.html">Input Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="usb/index.html">Linux USB API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html">PCI Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pci.html#pci-hotplug-support-library">PCI Hotplug Support Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="spi.html">Serial Peripheral Interface (SPI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="i2c.html">I<sup>2</sup>C and SMBus Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="hsi.html">High Speed Synchronous Serial Interface (HSI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="edac.html">Error Detection And Correction (EDAC) Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="scsi.html">SCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="libata.html">libATA Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="target.html">target and iSCSI Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="mtdnand.html">MTD NAND Driver Programming Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html">Parallel Port Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#x50-uart-driver">16x50 UART Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="miscellaneous.html#pulse-width-modulation-pwm">Pulse-Width Modulation (PWM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="w1.html">W1: Dallas&#8217; 1-wire bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="rapidio.html">RapidIO Subsystem Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="s390-drivers.html">Writing s390 channel device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="vme.html">VME Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="80211/index.html">Linux 802.11 Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l2"><a class="reference internal" href="firmware/index.html">Linux Firmware API</a></li>
<li class="toctree-l2"><a class="reference internal" href="pinctl.html">PINCTRL (PIN CONTROL) subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="gpio/index.html">General Purpose Input/Output (GPIO)</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_devices.html">Miscellaneous Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="dmaengine/index.html">DMAEngine documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l2"><a class="reference internal" href="soundwire/index.html">SoundWire Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="fpga/index.html">FPGA Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">The Linux driver implementer&#8217;s API guide</a> &raquo;</li>
      
    <li>Device links</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/driver-api/device_link.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="device-links">
<h1>Device links<a class="headerlink" href="#device-links" title="Permalink to this headline">Â¶</a></h1>
<p>By default, the driver core only enforces dependencies between devices
that are borne out of a parent/child relationship within the device
hierarchy: When suspending, resuming or shutting down the system, devices
are ordered based on this relationship, i.e. children are always suspended
before their parent, and the parent is always resumed before its children.</p>
<p>Sometimes there is a need to represent device dependencies beyond the
mere parent/child relationship, e.g. between siblings, and have the
driver core automatically take care of them.</p>
<p>Secondly, the driver core by default does not enforce any driver presence
dependencies, i.e. that one device must be bound to a driver before
another one can probe or function correctly.</p>
<p>Often these two dependency types come together, so a device depends on
another one both with regards to driver presence <em>and</em> with regards to
suspend/resume and shutdown ordering.</p>
<p>Device links allow representation of such dependencies in the driver core.</p>
<p>In its standard form, a device link combines <em>both</em> dependency types:
It guarantees correct suspend/resume and shutdown ordering between a
&#8220;supplier&#8221; device and its &#8220;consumer&#8221; devices, and it guarantees driver
presence on the supplier.  The consumer devices are not probed before the
supplier is bound to a driver, and they&#8217;re unbound before the supplier
is unbound.</p>
<p>When driver presence on the supplier is irrelevant and only correct
suspend/resume and shutdown ordering is needed, the device link may
simply be set up with the <code class="docutils literal"><span class="pre">DL_FLAG_STATELESS</span></code> flag.  In other words,
enforcing driver presence on the supplier is optional.</p>
<p>Another optional feature is runtime PM integration:  By setting the
<code class="docutils literal"><span class="pre">DL_FLAG_PM_RUNTIME</span></code> flag on addition of the device link, the PM core
is instructed to runtime resume the supplier and keep it active
whenever and for as long as the consumer is runtime resumed.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">Â¶</a></h2>
<p>The earliest point in time when device links can be added is after
<a class="reference internal" href="infrastructure.html#c.device_add" title="device_add"><code class="xref c c-func docutils literal"><span class="pre">device_add()</span></code></a> has been called for the supplier and
<a class="reference internal" href="infrastructure.html#c.device_initialize" title="device_initialize"><code class="xref c c-func docutils literal"><span class="pre">device_initialize()</span></code></a> has been called for the consumer.</p>
<p>It is legal to add them later, but care must be taken that the system
remains in a consistent state:  E.g. a device link cannot be added in
the midst of a suspend/resume transition, so either commencement of
such a transition needs to be prevented with <code class="xref c c-func docutils literal"><span class="pre">lock_system_sleep()</span></code>,
or the device link needs to be added from a function which is guaranteed
not to run in parallel to a suspend/resume transition, such as from a
device <code class="docutils literal"><span class="pre">-&gt;probe</span></code> callback or a boot-time PCI quirk.</p>
<p>Another example for an inconsistent state would be a device link that
represents a driver presence dependency, yet is added from the consumer&#8217;s
<code class="docutils literal"><span class="pre">-&gt;probe</span></code> callback while the supplier hasn&#8217;t probed yet:  Had the driver
core known about the device link earlier, it wouldn&#8217;t have probed the
consumer in the first place.  The onus is thus on the consumer to check
presence of the supplier after adding the link, and defer probing on
non-presence.</p>
<p>If a device link is added in the <code class="docutils literal"><span class="pre">-&gt;probe</span></code> callback of the supplier or
consumer driver, it is typically deleted in its <code class="docutils literal"><span class="pre">-&gt;remove</span></code> callback for
symmetry.  That way, if the driver is compiled as a module, the device
link is added on module load and orderly deleted on unload.  The same
restrictions that apply to device link addition (e.g. exclusion of a
parallel suspend/resume transition) apply equally to deletion.</p>
<p>Several flags may be specified on device link addition, two of which
have already been mentioned above:  <code class="docutils literal"><span class="pre">DL_FLAG_STATELESS</span></code> to express that no
driver presence dependency is needed (but only correct suspend/resume and
shutdown ordering) and <code class="docutils literal"><span class="pre">DL_FLAG_PM_RUNTIME</span></code> to express that runtime PM
integration is desired.</p>
<p>Two other flags are specifically targeted at use cases where the device
link is added from the consumer&#8217;s <code class="docutils literal"><span class="pre">-&gt;probe</span></code> callback:  <code class="docutils literal"><span class="pre">DL_FLAG_RPM_ACTIVE</span></code>
can be specified to runtime resume the supplier upon addition of the
device link.  <code class="docutils literal"><span class="pre">DL_FLAG_AUTOREMOVE_CONSUMER</span></code> causes the device link to be
automatically purged when the consumer fails to probe or later unbinds.
This obviates the need to explicitly delete the link in the <code class="docutils literal"><span class="pre">-&gt;remove</span></code>
callback or in the error path of the <code class="docutils literal"><span class="pre">-&gt;probe</span></code> callback.</p>
<p>Similarly, when the device link is added from supplier&#8217;s <code class="docutils literal"><span class="pre">-&gt;probe</span></code> callback,
<code class="docutils literal"><span class="pre">DL_FLAG_AUTOREMOVE_SUPPLIER</span></code> causes the device link to be automatically
purged when the supplier fails to probe or later unbinds.</p>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">Â¶</a></h2>
<p>Driver authors should be aware that a driver presence dependency (i.e. when
<code class="docutils literal"><span class="pre">DL_FLAG_STATELESS</span></code> is not specified on link addition) may cause probing of
the consumer to be deferred indefinitely.  This can become a problem if the
consumer is required to probe before a certain initcall level is reached.
Worse, if the supplier driver is blacklisted or missing, the consumer will
never be probed.</p>
<p>Sometimes drivers depend on optional resources.  They are able to operate
in a degraded mode (reduced feature set or performance) when those resources
are not present.  An example is an SPI controller that can use a DMA engine
or work in PIO mode.  The controller can determine presence of the optional
resources at probe time but on non-presence there is no way to know whether
they will become available in the near future (due to a supplier driver
probing) or never.  Consequently it cannot be determined whether to defer
probing or not.  It would be possible to notify drivers when optional
resources become available after probing, but it would come at a high cost
for drivers as switching between modes of operation at runtime based on the
availability of such resources would be much more complex than a mechanism
based on probe deferral.  In any case optional resources are beyond the
scope of device links.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">Â¶</a></h2>
<ul>
<li><p class="first">An MMU device exists alongside a busmaster device, both are in the same
power domain.  The MMU implements DMA address translation for the busmaster
device and shall be runtime resumed and kept active whenever and as long
as the busmaster device is active.  The busmaster device&#8217;s driver shall
not bind before the MMU is bound.  To achieve this, a device link with
runtime PM integration is added from the busmaster device (consumer)
to the MMU device (supplier).  The effect with regards to runtime PM
is the same as if the MMU was the parent of the master device.</p>
<p>The fact that both devices share the same power domain would normally
suggest usage of a <a class="reference internal" href="pm/types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a> or <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">generic_pm_domain</span></code>,
however these are not independent devices that happen to share a power
switch, but rather the MMU device serves the busmaster device and is
useless without it.  A device link creates a synthetic hierarchical
relationship between the devices and is thus more apt.</p>
</li>
<li><p class="first">A Thunderbolt host controller comprises a number of PCIe hotplug ports
and an NHI device to manage the PCIe switch.  On resume from system sleep,
the NHI device needs to re-establish PCI tunnels to attached devices
before the hotplug ports can resume.  If the hotplug ports were children
of the NHI, this resume order would automatically be enforced by the
PM core, but unfortunately they&#8217;re aunts.  The solution is to add
device links from the hotplug ports (consumers) to the NHI device
(supplier).  A driver presence dependency is not necessary for this
use case.</p>
</li>
<li><p class="first">Discrete GPUs in hybrid graphics laptops often feature an HDA controller
for HDMI/DP audio.  In the device hierarchy the HDA controller is a sibling
of the VGA device, yet both share the same power domain and the HDA
controller is only ever needed when an HDMI/DP display is attached to the
VGA device.  A device link from the HDA controller (consumer) to the
VGA device (supplier) aptly represents this relationship.</p>
</li>
<li><p class="first">ACPI allows definition of a device start order by way of _DEP objects.
A classical example is when ACPI power management methods on one device
are implemented in terms of I<sup>2</sup>C accesses and require a specific
I<sup>2</sup>C controller to be present and functional for the power
management of the device in question to work.</p>
</li>
<li><p class="first">In some SoCs a functional dependency exists from display, video codec and
video processing IP cores on transparent memory access IP cores that handle
burst access and compression/decompression.</p>
</li>
</ul>
</div>
<div class="section" id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this headline">Â¶</a></h2>
<ul class="simple">
<li>A <a class="reference internal" href="pm/types.html#c.dev_pm_domain" title="dev_pm_domain"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dev_pm_domain</span></code></a> can be used to override the bus,
class or device type callbacks.  It is intended for devices sharing
a single on/off switch, however it does not guarantee a specific
suspend/resume ordering, this needs to be implemented separately.
It also does not by itself track the runtime PM status of the involved
devices and turn off the power switch only when all of them are runtime
suspended.  Furthermore it cannot be used to enforce a specific shutdown
ordering or a driver presence dependency.</li>
<li>A <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">generic_pm_domain</span></code> is a lot more heavyweight than a
device link and does not allow for shutdown ordering or driver presence
dependencies.  It also cannot be used on ACPI systems.</li>
</ul>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">Â¶</a></h2>
<p>The device hierarchy, which &#8211; as the name implies &#8211; is a tree,
becomes a directed acyclic graph once device links are added.</p>
<p>Ordering of these devices during suspend/resume is determined by the
dpm_list.  During shutdown it is determined by the devices_kset.  With
no device links present, the two lists are a flattened, one-dimensional
representations of the device tree such that a device is placed behind
all its ancestors.  That is achieved by traversing the ACPI namespace
or OpenFirmware device tree top-down and appending devices to the lists
as they are discovered.</p>
<p>Once device links are added, the lists need to satisfy the additional
constraint that a device is placed behind all its suppliers, recursively.
To ensure this, upon addition of the device link the consumer and the
entire sub-graph below it (all children and consumers of the consumer)
are moved to the end of the list.  (Call to <code class="xref c c-func docutils literal"><span class="pre">device_reorder_to_tail()</span></code>
from <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal"><span class="pre">device_link_add()</span></code></a>.)</p>
<p>To prevent introduction of dependency loops into the graph, it is
verified upon device link addition that the supplier is not dependent
on the consumer or any children or consumers of the consumer.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_is_dependent()</span></code> from <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal"><span class="pre">device_link_add()</span></code></a>.)
If that constraint is violated, <a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal"><span class="pre">device_link_add()</span></code></a> will return
<code class="docutils literal"><span class="pre">NULL</span></code> and a <code class="docutils literal"><span class="pre">WARNING</span></code> will be logged.</p>
<p>Notably this also prevents the addition of a device link from a parent
device to a child.  However the converse is allowed, i.e. a device link
from a child to a parent.  Since the driver core already guarantees
correct suspend/resume and shutdown ordering between parent and child,
such a device link only makes sense if a driver presence dependency is
needed on top of that.  In this case driver authors should weigh
carefully if a device link is at all the right tool for the purpose.
A more suitable approach might be to simply use deferred probing or
add a device flag causing the parent driver to be probed before the
child one.</p>
</div>
<div class="section" id="state-machine">
<h2>State machine<a class="headerlink" href="#state-machine" title="Permalink to this headline">Â¶</a></h2>
<dl class="type">
<dt id="c.device_link_state">
enum <code class="descname">device_link_state</code><a class="headerlink" href="#c.device_link_state" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Device link states.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DL_STATE_NONE</span></code></dt>
<dd>The presence of the drivers is not being tracked.</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_DORMANT</span></code></dt>
<dd>None of the supplier/consumer drivers is present.</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_AVAILABLE</span></code></dt>
<dd>The supplier driver is present, but the consumer is not.</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_CONSUMER_PROBE</span></code></dt>
<dd>The consumer is probing (supplier driver present).</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_ACTIVE</span></code></dt>
<dd>Both the supplier and consumer drivers are present.</dd>
<dt><code class="docutils literal"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code></dt>
<dd>The supplier driver is unbinding.</dd>
</dl>
<div class="highlight-none"><div class="highlight"><pre>                .=============================.
                |                             |
                v                             |
DORMANT &lt;=&gt; AVAILABLE &lt;=&gt; CONSUMER_PROBE =&gt; ACTIVE
   ^                                          |
   |                                          |
   &#39;============ SUPPLIER_UNBIND &lt;============&#39;
</pre></div>
</div>
<ul class="simple">
<li>The initial state of a device link is automatically determined by
<a class="reference internal" href="infrastructure.html#c.device_link_add" title="device_link_add"><code class="xref c c-func docutils literal"><span class="pre">device_link_add()</span></code></a> based on the driver presence on the supplier
and consumer.  If the link is created before any devices are probed, it
is set to <code class="docutils literal"><span class="pre">DL_STATE_DORMANT</span></code>.</li>
<li>When a supplier device is bound to a driver, links to its consumers
progress to <code class="docutils literal"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_links_driver_bound()</span></code> from
<code class="xref c c-func docutils literal"><span class="pre">driver_bound()</span></code>.)</li>
<li>Before a consumer device is probed, presence of supplier drivers is
verified by checking that links to suppliers are in <code class="docutils literal"><span class="pre">DL_STATE_AVAILABLE</span></code>
state.  The state of the links is updated to <code class="docutils literal"><span class="pre">DL_STATE_CONSUMER_PROBE</span></code>.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_links_check_suppliers()</span></code> from
<code class="xref c c-func docutils literal"><span class="pre">really_probe()</span></code>.)
This prevents the supplier from unbinding.
(Call to <a class="reference internal" href="infrastructure.html#c.wait_for_device_probe" title="wait_for_device_probe"><code class="xref c c-func docutils literal"><span class="pre">wait_for_device_probe()</span></code></a> from
<code class="xref c c-func docutils literal"><span class="pre">device_links_unbind_consumers()</span></code>.)</li>
<li>If the probe fails, links to suppliers revert back to <code class="docutils literal"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_links_no_driver()</span></code> from <code class="xref c c-func docutils literal"><span class="pre">really_probe()</span></code>.)</li>
<li>If the probe succeeds, links to suppliers progress to <code class="docutils literal"><span class="pre">DL_STATE_ACTIVE</span></code>.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_links_driver_bound()</span></code> from <code class="xref c c-func docutils literal"><span class="pre">driver_bound()</span></code>.)</li>
<li>When the consumer&#8217;s driver is later on removed, links to suppliers revert
back to <code class="docutils literal"><span class="pre">DL_STATE_AVAILABLE</span></code>.
(Call to <code class="xref c c-func docutils literal"><span class="pre">__device_links_no_driver()</span></code> from
<code class="xref c c-func docutils literal"><span class="pre">device_links_driver_cleanup()</span></code>, which in turn is called from
<code class="xref c c-func docutils literal"><span class="pre">__device_release_driver()</span></code>.)</li>
<li>Before a supplier&#8217;s driver is removed, links to consumers that are not
bound to a driver are updated to <code class="docutils literal"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code>.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_links_busy()</span></code> from
<code class="xref c c-func docutils literal"><span class="pre">__device_release_driver()</span></code>.)
This prevents the consumers from binding.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_links_check_suppliers()</span></code> from
<code class="xref c c-func docutils literal"><span class="pre">really_probe()</span></code>.)
Consumers that are bound are freed from their driver; consumers that are
probing are waited for until they are done.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_links_unbind_consumers()</span></code> from
<code class="xref c c-func docutils literal"><span class="pre">__device_release_driver()</span></code>.)
Once all links to consumers are in <code class="docutils literal"><span class="pre">DL_STATE_SUPPLIER_UNBIND</span></code> state,
the supplier driver is released and the links revert to <code class="docutils literal"><span class="pre">DL_STATE_DORMANT</span></code>.
(Call to <code class="xref c c-func docutils literal"><span class="pre">device_links_driver_cleanup()</span></code> from
<code class="xref c c-func docutils literal"><span class="pre">__device_release_driver()</span></code>.)</li>
</ul>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">Â¶</a></h2>
<dl class="function">
<dt id="c.device_link_add">
struct <a class="reference internal" href="infrastructure.html#c.device_link" title="device_link">device_link</a> * <code class="descname">device_link_add</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;consumer</em>, struct <a class="reference internal" href="infrastructure.html#c.device" title="device">device</a> *<em>&nbsp;supplier</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_add" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a link between two devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">consumer</span></code></dt>
<dd>Consumer end of the link.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span> <span class="pre">*</span> <span class="pre">supplier</span></code></dt>
<dd>Supplier end of the link.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Link flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller is responsible for the proper synchronization of the link creation
with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will cause the
runtime PM framework to take the link into account.  Second, if the
DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices will
be forced into the active metastate and reference-counted upon the creation
of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE will be
ignored.</p>
<p>If the DL_FLAG_AUTOREMOVE_CONSUMER is set, the link will be removed
automatically when the consumer device driver unbinds from it.
The combination of both DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_STATELESS
set is invalid and will cause NULL to be returned.</p>
<p>A side effect of the link creation is re-ordering of dpm_list and the
devices_kset list by moving the consumer device and all devices depending
on it to the ends of these lists (that does not happen to devices that have
not been registered when this function is called).</p>
<p>The supplier device is required to be registered when this function is called
and NULL will be returned if that is not the case.  The consumer device need
not be registered, however.</p>
<dl class="function">
<dt id="c.device_link_del">
void <code class="descname">device_link_del</code><span class="sig-paren">(</span>struct <a class="reference internal" href="infrastructure.html#c.device_link" title="device_link">device_link</a> *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.device_link_del" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Delete a link between two devices.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>Device link to delete.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The caller must ensure proper synchronization of this function with runtime
PM.  If the link was added multiple times, it needs to be deleted as often.
Care is required for hotplugged devices:  Their links are purged on removal
and calling <a class="reference internal" href="infrastructure.html#c.device_link_del" title="device_link_del"><code class="xref c c-func docutils literal"><span class="pre">device_link_del()</span></code></a> is then no longer allowed.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="message-based.html" class="btn btn-neutral float-right" title="Message-based devices" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dma-buf.html" class="btn btn-neutral" title="Buffer Sharing and Synchronization" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>