

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Filesystem-level encryption (fscrypt) &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="Linux Filesystems API" href="index.html"/>
        <link rel="next" title="Linux Memory Management Documentation" href="../vm/index.html"/>
        <link rel="prev" title="Linux Filesystems API" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Linux Filesystems API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#the-linux-vfs">The Linux VFS</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-proc-filesystem">The proc filesystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#events-based-on-file-descriptors">Events based on file descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-filesystem-for-exporting-kernel-objects">The Filesystem for Exporting Kernel Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-debugfs-filesystem">The debugfs filesystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-linux-journalling-api">The Linux Journalling API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#splice-api">splice API</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#pipes-api">pipes API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#encryption-api">Encryption API</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="">Filesystem-level encryption (fscrypt)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#threat-model">Threat model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-hierarchy">Key hierarchy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encryption-modes-and-usage">Encryption modes and usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-api">User API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-semantics">Access semantics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#encryption-policy-enforcement">Encryption policy enforcement</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-details">Implementation details</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Linux Filesystems API</a> &raquo;</li>
      
    <li>Filesystem-level encryption (fscrypt)</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/filesystems/fscrypt.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="filesystem-level-encryption-fscrypt">
<h1>Filesystem-level encryption (fscrypt)<a class="headerlink" href="#filesystem-level-encryption-fscrypt" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>fscrypt is a library which filesystems can hook into to support
transparent encryption of files and directories.</p>
<p>Note: &#8220;fscrypt&#8221; in this document refers to the kernel-level portion,
implemented in <code class="docutils literal"><span class="pre">fs/crypto/</span></code>, as opposed to the userspace tool
<a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a>.  This document only
covers the kernel-level portion.  For command-line examples of how to
use encryption, see the documentation for the userspace tool <a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a>.  Also, it is recommended to use
the fscrypt userspace tool, or other existing userspace tools such as
<a class="reference external" href="https://github.com/google/fscryptctl">fscryptctl</a> or <a class="reference external" href="https://source.android.com/security/encryption/file-based">Android&#8217;s key
management system</a>, over
using the kernel&#8217;s API directly.  Using existing tools reduces the
chance of introducing your own security bugs.  (Nevertheless, for
completeness this documentation covers the kernel&#8217;s API anyway.)</p>
<p>Unlike dm-crypt, fscrypt operates at the filesystem level rather than
at the block device level.  This allows it to encrypt different files
with different keys and to have unencrypted files on the same
filesystem.  This is useful for multi-user systems where each user&#8217;s
data-at-rest needs to be cryptographically isolated from the others.
However, except for filenames, fscrypt does not encrypt filesystem
metadata.</p>
<p>Unlike eCryptfs, which is a stacked filesystem, fscrypt is integrated
directly into supported filesystems &#8212; currently ext4, F2FS, and
UBIFS.  This allows encrypted files to be read and written without
caching both the decrypted and encrypted pages in the pagecache,
thereby nearly halving the memory used and bringing it in line with
unencrypted files.  Similarly, half as many dentries and inodes are
needed.  eCryptfs also limits encrypted filenames to 143 bytes,
causing application compatibility issues; fscrypt allows the full 255
bytes (NAME_MAX).  Finally, unlike eCryptfs, the fscrypt API can be
used by unprivileged users, with no need to mount anything.</p>
<p>fscrypt does not support encrypting files in-place.  Instead, it
supports marking an empty directory as encrypted.  Then, after
userspace provides the key, all regular files, directories, and
symbolic links created in that directory tree are transparently
encrypted.</p>
</div>
<div class="section" id="threat-model">
<h2>Threat model<a class="headerlink" href="#threat-model" title="Permalink to this headline">¶</a></h2>
<div class="section" id="offline-attacks">
<h3>Offline attacks<a class="headerlink" href="#offline-attacks" title="Permalink to this headline">¶</a></h3>
<p>Provided that userspace chooses a strong encryption key, fscrypt
protects the confidentiality of file contents and filenames in the
event of a single point-in-time permanent offline compromise of the
block device content.  fscrypt does not protect the confidentiality of
non-filename metadata, e.g. file sizes, file permissions, file
timestamps, and extended attributes.  Also, the existence and location
of holes (unallocated blocks which logically contain all zeroes) in
files is not protected.</p>
<p>fscrypt is not guaranteed to protect confidentiality or authenticity
if an attacker is able to manipulate the filesystem offline prior to
an authorized user later accessing the filesystem.</p>
</div>
<div class="section" id="online-attacks">
<h3>Online attacks<a class="headerlink" href="#online-attacks" title="Permalink to this headline">¶</a></h3>
<p>fscrypt (and storage encryption in general) can only provide limited
protection, if any at all, against online attacks.  In detail:</p>
<p>fscrypt is only resistant to side-channel attacks, such as timing or
electromagnetic attacks, to the extent that the underlying Linux
Cryptographic API algorithms are.  If a vulnerable algorithm is used,
such as a table-based implementation of AES, it may be possible for an
attacker to mount a side channel attack against the online system.
Side channel attacks may also be mounted against applications
consuming decrypted data.</p>
<p>After an encryption key has been provided, fscrypt is not designed to
hide the plaintext file contents or filenames from other users on the
same system, regardless of the visibility of the keyring key.
Instead, existing access control mechanisms such as file mode bits,
POSIX ACLs, LSMs, or mount namespaces should be used for this purpose.
Also note that as long as the encryption keys are <em>anywhere</em> in
memory, an online attacker can necessarily compromise them by mounting
a physical attack or by exploiting any kernel security vulnerability
which provides an arbitrary memory read primitive.</p>
<p>While it is ostensibly possible to &#8220;evict&#8221; keys from the system,
recently accessed encrypted files will remain accessible at least
until the filesystem is unmounted or the VFS caches are dropped, e.g.
using <code class="docutils literal"><span class="pre">echo</span> <span class="pre">2</span> <span class="pre">&gt;</span> <span class="pre">/proc/sys/vm/drop_caches</span></code>.  Even after that, if the
RAM is compromised before being powered off, it will likely still be
possible to recover portions of the plaintext file contents, if not
some of the encryption keys as well.  (Since Linux v4.12, all
in-kernel keys related to fscrypt are sanitized before being freed.
However, userspace would need to do its part as well.)</p>
<p>Currently, fscrypt does not prevent a user from maliciously providing
an incorrect key for another user&#8217;s existing encrypted files.  A
protection against this is planned.</p>
</div>
</div>
<div class="section" id="key-hierarchy">
<h2>Key hierarchy<a class="headerlink" href="#key-hierarchy" title="Permalink to this headline">¶</a></h2>
<div class="section" id="master-keys">
<h3>Master Keys<a class="headerlink" href="#master-keys" title="Permalink to this headline">¶</a></h3>
<p>Each encrypted directory tree is protected by a <em>master key</em>.  Master
keys can be up to 64 bytes long, and must be at least as long as the
greater of the key length needed by the contents and filenames
encryption modes being used.  For example, if AES-256-XTS is used for
contents encryption, the master key must be 64 bytes (512 bits).  Note
that the XTS mode is defined to require a key twice as long as that
required by the underlying block cipher.</p>
<p>To &#8220;unlock&#8221; an encrypted directory tree, userspace must provide the
appropriate master key.  There can be any number of master keys, each
of which protects any number of directory trees on any number of
filesystems.</p>
<p>Userspace should generate master keys either using a cryptographically
secure random number generator, or by using a KDF (Key Derivation
Function).  Note that whenever a KDF is used to &#8220;stretch&#8221; a
lower-entropy secret such as a passphrase, it is critical that a KDF
designed for this purpose be used, such as scrypt, PBKDF2, or Argon2.</p>
</div>
<div class="section" id="per-file-keys">
<h3>Per-file keys<a class="headerlink" href="#per-file-keys" title="Permalink to this headline">¶</a></h3>
<p>Master keys are not used to encrypt file contents or names directly.
Instead, a unique key is derived for each encrypted file, including
each regular file, directory, and symbolic link.  This has several
advantages:</p>
<ul class="simple">
<li>In cryptosystems, the same key material should never be used for
different purposes.  Using the master key as both an XTS key for
contents encryption and as a CTS-CBC key for filenames encryption
would violate this rule.</li>
<li>Per-file keys simplify the choice of IVs (Initialization Vectors)
for contents encryption.  Without per-file keys, to ensure IV
uniqueness both the inode and logical block number would need to be
encoded in the IVs.  This would make it impossible to renumber
inodes, which e.g. <code class="docutils literal"><span class="pre">resize2fs</span></code> can do when resizing an ext4
filesystem.  With per-file keys, it is sufficient to encode just the
logical block number in the IVs.</li>
<li>Per-file keys strengthen the encryption of filenames, where IVs are
reused out of necessity.  With a unique key per directory, IV reuse
is limited to within a single directory.</li>
<li>Per-file keys allow individual files to be securely erased simply by
securely erasing their keys.  (Not yet implemented.)</li>
</ul>
<p>A KDF (Key Derivation Function) is used to derive per-file keys from
the master key.  This is done instead of wrapping a randomly-generated
key for each file because it reduces the size of the encryption xattr,
which for some filesystems makes the xattr more likely to fit in-line
in the filesystem&#8217;s inode table.  With a KDF, only a 16-byte nonce is
required &#8212; long enough to make key reuse extremely unlikely.  A
wrapped key, on the other hand, would need to be up to 64 bytes &#8212;
the length of an AES-256-XTS key.  Furthermore, currently there is no
requirement to support unlocking a file with multiple alternative
master keys or to support rotating master keys.  Instead, the master
keys may be wrapped in userspace, e.g. as done by the <a class="reference external" href="https://github.com/google/fscrypt">fscrypt</a> tool.</p>
<p>The current KDF encrypts the master key using the 16-byte nonce as an
AES-128-ECB key.  The output is used as the derived key.  If the
output is longer than needed, then it is truncated to the needed
length.  Truncation is the norm for directories and symlinks, since
those use the CTS-CBC encryption mode which requires a key half as
long as that required by the XTS encryption mode.</p>
<p>Note: this KDF meets the primary security requirement, which is to
produce unique derived keys that preserve the entropy of the master
key, assuming that the master key is already a good pseudorandom key.
However, it is nonstandard and has some problems such as being
reversible, so it is generally considered to be a mistake!  It may be
replaced with HKDF or another more standard KDF in the future.</p>
</div>
</div>
<div class="section" id="encryption-modes-and-usage">
<h2>Encryption modes and usage<a class="headerlink" href="#encryption-modes-and-usage" title="Permalink to this headline">¶</a></h2>
<p>fscrypt allows one encryption mode to be specified for file contents
and one encryption mode to be specified for filenames.  Different
directory trees are permitted to use different encryption modes.
Currently, the following pairs of encryption modes are supported:</p>
<ul class="simple">
<li>AES-256-XTS for contents and AES-256-CTS-CBC for filenames</li>
<li>AES-128-CBC for contents and AES-128-CTS-CBC for filenames</li>
<li>Speck128/256-XTS for contents and Speck128/256-CTS-CBC for filenames</li>
</ul>
<p>It is strongly recommended to use AES-256-XTS for contents encryption.
AES-128-CBC was added only for low-powered embedded devices with
crypto accelerators such as CAAM or CESA that do not support XTS.</p>
<p>Similarly, Speck128/256 support was only added for older or low-end
CPUs which cannot do AES fast enough &#8211; especially ARM CPUs which have
NEON instructions but not the Cryptography Extensions &#8211; and for which
it would not otherwise be feasible to use encryption at all.  It is
not recommended to use Speck on CPUs that have AES instructions.
Speck support is only available if it has been enabled in the crypto
API via CONFIG_CRYPTO_SPECK.  Also, on ARM platforms, to get
acceptable performance CONFIG_CRYPTO_SPECK_NEON must be enabled.</p>
<p>New encryption modes can be added relatively easily, without changes
to individual filesystems.  However, authenticated encryption (AE)
modes are not currently supported because of the difficulty of dealing
with ciphertext expansion.</p>
<p>For file contents, each filesystem block is encrypted independently.
Currently, only the case where the filesystem block size is equal to
the system&#8217;s page size (usually 4096 bytes) is supported.  With the
XTS mode of operation (recommended), the logical block number within
the file is used as the IV.  With the CBC mode of operation (not
recommended), ESSIV is used; specifically, the IV for CBC is the
logical block number encrypted with AES-256, where the AES-256 key is
the SHA-256 hash of the inode&#8217;s data encryption key.</p>
<p>For filenames, the full filename is encrypted at once.  Because of the
requirements to retain support for efficient directory lookups and
filenames of up to 255 bytes, a constant initialization vector (IV) is
used.  However, each encrypted directory uses a unique key, which
limits IV reuse to within a single directory.  Note that IV reuse in
the context of CTS-CBC encryption means that when the original
filenames share a common prefix at least as long as the cipher block
size (16 bytes for AES), the corresponding encrypted filenames will
also share a common prefix.  This is undesirable; it may be fixed in
the future by switching to an encryption mode that is a strong
pseudorandom permutation on arbitrary-length messages, e.g. the HEH
(Hash-Encrypt-Hash) mode.</p>
<p>Since filenames are encrypted with the CTS-CBC mode of operation, the
plaintext and ciphertext filenames need not be multiples of the AES
block size, i.e. 16 bytes.  However, the minimum size that can be
encrypted is 16 bytes, so shorter filenames are NUL-padded to 16 bytes
before being encrypted.  In addition, to reduce leakage of filename
lengths via their ciphertexts, all filenames are NUL-padded to the
next 4, 8, 16, or 32-byte boundary (configurable).  32 is recommended
since this provides the best confidentiality, at the cost of making
directory entries consume slightly more space.  Note that since NUL
(<code class="docutils literal"><span class="pre">\0</span></code>) is not otherwise a valid character in filenames, the padding
will never produce duplicate plaintexts.</p>
<p>Symbolic link targets are considered a type of filename and are
encrypted in the same way as filenames in directory entries.  Each
symlink also uses a unique key; hence, the hardcoded IV is not a
problem for symlinks.</p>
</div>
<div class="section" id="user-api">
<h2>User API<a class="headerlink" href="#user-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="setting-an-encryption-policy">
<h3>Setting an encryption policy<a class="headerlink" href="#setting-an-encryption-policy" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_SET_ENCRYPTION_POLICY ioctl sets an encryption policy on an
empty directory or verifies that a directory or regular file already
has the specified encryption policy.  It takes in a pointer to a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">fscrypt_policy</span></code>, defined as follows:</p>
<div class="highlight-none"><div class="highlight"><pre>#define FS_KEY_DESCRIPTOR_SIZE  8

struct fscrypt_policy {
        __u8 version;
        __u8 contents_encryption_mode;
        __u8 filenames_encryption_mode;
        __u8 flags;
        __u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
};
</pre></div>
</div>
<p>This structure must be initialized as follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">version</span></code> must be 0.</li>
<li><code class="docutils literal"><span class="pre">contents_encryption_mode</span></code> and <code class="docutils literal"><span class="pre">filenames_encryption_mode</span></code> must
be set to constants from <code class="docutils literal"><span class="pre">&lt;linux/fs.h&gt;</span></code> which identify the
encryption modes to use.  If unsure, use
FS_ENCRYPTION_MODE_AES_256_XTS (1) for <code class="docutils literal"><span class="pre">contents_encryption_mode</span></code>
and FS_ENCRYPTION_MODE_AES_256_CTS (4) for
<code class="docutils literal"><span class="pre">filenames_encryption_mode</span></code>.</li>
<li><code class="docutils literal"><span class="pre">flags</span></code> must be set to a value from <code class="docutils literal"><span class="pre">&lt;linux/fs.h&gt;</span></code> which
identifies the amount of NUL-padding to use when encrypting
filenames.  If unsure, use FS_POLICY_FLAGS_PAD_32 (0x3).</li>
<li><code class="docutils literal"><span class="pre">master_key_descriptor</span></code> specifies how to find the master key in
the keyring; see <a class="reference internal" href="#adding-keys">Adding keys</a>.  It is up to userspace to choose a
unique <code class="docutils literal"><span class="pre">master_key_descriptor</span></code> for each master key.  The e4crypt
and fscrypt tools use the first 8 bytes of
<code class="docutils literal"><span class="pre">SHA-512(SHA-512(master_key))</span></code>, but this particular scheme is not
required.  Also, the master key need not be in the keyring yet when
FS_IOC_SET_ENCRYPTION_POLICY is executed.  However, it must be added
before any files can be created in the encrypted directory.</li>
</ul>
<p>If the file is not yet encrypted, then FS_IOC_SET_ENCRYPTION_POLICY
verifies that the file is an empty directory.  If so, the specified
encryption policy is assigned to the directory, turning it into an
encrypted directory.  After that, and after providing the
corresponding master key as described in <a class="reference internal" href="#adding-keys">Adding keys</a>, all regular
files, directories (recursively), and symlinks created in the
directory will be encrypted, inheriting the same encryption policy.
The filenames in the directory&#8217;s entries will be encrypted as well.</p>
<p>Alternatively, if the file is already encrypted, then
FS_IOC_SET_ENCRYPTION_POLICY validates that the specified encryption
policy exactly matches the actual one.  If they match, then the ioctl
returns 0.  Otherwise, it fails with EEXIST.  This works on both
regular files and directories, including nonempty directories.</p>
<p>Note that the ext4 filesystem does not allow the root directory to be
encrypted, even if it is empty.  Users who want to encrypt an entire
filesystem with one key should consider using dm-crypt instead.</p>
<p>FS_IOC_SET_ENCRYPTION_POLICY can fail with the following errors:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">EACCES</span></code>: the file is not owned by the process&#8217;s uid, nor does the
process have the CAP_FOWNER capability in a namespace with the file
owner&#8217;s uid mapped</li>
<li><code class="docutils literal"><span class="pre">EEXIST</span></code>: the file is already encrypted with an encryption policy
different from the one specified</li>
<li><code class="docutils literal"><span class="pre">EINVAL</span></code>: an invalid encryption policy was specified (invalid
version, mode(s), or flags)</li>
<li><code class="docutils literal"><span class="pre">ENOTDIR</span></code>: the file is unencrypted and is a regular file, not a
directory</li>
<li><code class="docutils literal"><span class="pre">ENOTEMPTY</span></code>: the file is unencrypted and is a nonempty directory</li>
<li><code class="docutils literal"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption</li>
<li><code class="docutils literal"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for this filesystem, or the filesystem superblock has not
had encryption enabled on it.  (For example, to use encryption on an
ext4 filesystem, CONFIG_EXT4_ENCRYPTION must be enabled in the
kernel config, and the superblock must have had the &#8220;encrypt&#8221;
feature flag enabled using <code class="docutils literal"><span class="pre">tune2fs</span> <span class="pre">-O</span> <span class="pre">encrypt</span></code> or <code class="docutils literal"><span class="pre">mkfs.ext4</span> <span class="pre">-O</span>
<span class="pre">encrypt</span></code>.)</li>
<li><code class="docutils literal"><span class="pre">EPERM</span></code>: this directory may not be encrypted, e.g. because it is
the root directory of an ext4 filesystem</li>
<li><code class="docutils literal"><span class="pre">EROFS</span></code>: the filesystem is readonly</li>
</ul>
</div>
<div class="section" id="getting-an-encryption-policy">
<h3>Getting an encryption policy<a class="headerlink" href="#getting-an-encryption-policy" title="Permalink to this headline">¶</a></h3>
<p>The FS_IOC_GET_ENCRYPTION_POLICY ioctl retrieves the <code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">fscrypt_policy</span></code>, if any, for a directory or regular file.  See above
for the struct definition.  No additional permissions are required
beyond the ability to open the file.</p>
<p>FS_IOC_GET_ENCRYPTION_POLICY can fail with the following errors:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">EINVAL</span></code>: the file is encrypted, but it uses an unrecognized
encryption context format</li>
<li><code class="docutils literal"><span class="pre">ENODATA</span></code>: the file is not encrypted</li>
<li><code class="docutils literal"><span class="pre">ENOTTY</span></code>: this type of filesystem does not implement encryption</li>
<li><code class="docutils literal"><span class="pre">EOPNOTSUPP</span></code>: the kernel was not configured with encryption
support for this filesystem</li>
</ul>
<p>Note: if you only need to know whether a file is encrypted or not, on
most filesystems it is also possible to use the FS_IOC_GETFLAGS ioctl
and check for FS_ENCRYPT_FL, or to use the statx() system call and
check for STATX_ATTR_ENCRYPTED in stx_attributes.</p>
</div>
<div class="section" id="getting-the-per-filesystem-salt">
<h3>Getting the per-filesystem salt<a class="headerlink" href="#getting-the-per-filesystem-salt" title="Permalink to this headline">¶</a></h3>
<p>Some filesystems, such as ext4 and F2FS, also support the deprecated
ioctl FS_IOC_GET_ENCRYPTION_PWSALT.  This ioctl retrieves a randomly
generated 16-byte value stored in the filesystem superblock.  This
value is intended to used as a salt when deriving an encryption key
from a passphrase or other low-entropy user credential.</p>
<p>FS_IOC_GET_ENCRYPTION_PWSALT is deprecated.  Instead, prefer to
generate and manage any needed salt(s) in userspace.</p>
</div>
<div class="section" id="adding-keys">
<h3>Adding keys<a class="headerlink" href="#adding-keys" title="Permalink to this headline">¶</a></h3>
<p>To provide a master key, userspace must add it to an appropriate
keyring using the add_key() system call (see:
<code class="docutils literal"><span class="pre">Documentation/security/keys/core.rst</span></code>).  The key type must be
&#8220;logon&#8221;; keys of this type are kept in kernel memory and cannot be
read back by userspace.  The key description must be &#8220;fscrypt:&#8221;
followed by the 16-character lower case hex representation of the
<code class="docutils literal"><span class="pre">master_key_descriptor</span></code> that was set in the encryption policy.  The
key payload must conform to the following structure:</p>
<div class="highlight-none"><div class="highlight"><pre>#define FS_MAX_KEY_SIZE 64

struct fscrypt_key {
        u32 mode;
        u8 raw[FS_MAX_KEY_SIZE];
        u32 size;
};
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">mode</span></code> is ignored; just set it to 0.  The actual key is provided in
<code class="docutils literal"><span class="pre">raw</span></code> with <code class="docutils literal"><span class="pre">size</span></code> indicating its size in bytes.  That is, the
bytes <code class="docutils literal"><span class="pre">raw[0..size-1]</span></code> (inclusive) are the actual key.</p>
<p>The key description prefix &#8220;fscrypt:&#8221; may alternatively be replaced
with a filesystem-specific prefix such as &#8220;ext4:&#8221;.  However, the
filesystem-specific prefixes are deprecated and should not be used in
new programs.</p>
<p>There are several different types of keyrings in which encryption keys
may be placed, such as a session keyring, a user session keyring, or a
user keyring.  Each key must be placed in a keyring that is &#8220;attached&#8221;
to all processes that might need to access files encrypted with it, in
the sense that request_key() will find the key.  Generally, if only
processes belonging to a specific user need to access a given
encrypted directory and no session keyring has been installed, then
that directory&#8217;s key should be placed in that user&#8217;s user session
keyring or user keyring.  Otherwise, a session keyring should be
installed if needed, and the key should be linked into that session
keyring, or in a keyring linked into that session keyring.</p>
<p>Note: introducing the complex visibility semantics of keyrings here
was arguably a mistake &#8212; especially given that by design, after any
process successfully opens an encrypted file (thereby setting up the
per-file key), possessing the keyring key is not actually required for
any process to read/write the file until its in-memory inode is
evicted.  In the future there probably should be a way to provide keys
directly to the filesystem instead, which would make the intended
semantics clearer.</p>
</div>
</div>
<div class="section" id="access-semantics">
<h2>Access semantics<a class="headerlink" href="#access-semantics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="with-the-key">
<h3>With the key<a class="headerlink" href="#with-the-key" title="Permalink to this headline">¶</a></h3>
<p>With the encryption key, encrypted regular files, directories, and
symlinks behave very similarly to their unencrypted counterparts &#8212;
after all, the encryption is intended to be transparent.  However,
astute users may notice some differences in behavior:</p>
<ul class="simple">
<li>Unencrypted files, or files encrypted with a different encryption
policy (i.e. different key, modes, or flags), cannot be renamed or
linked into an encrypted directory; see <a class="reference internal" href="#encryption-policy-enforcement">Encryption policy
enforcement</a>.  Attempts to do so will fail with EPERM.  However,
encrypted files can be renamed within an encrypted directory, or
into an unencrypted directory.</li>
<li>Direct I/O is not supported on encrypted files.  Attempts to use
direct I/O on such files will fall back to buffered I/O.</li>
<li>The fallocate operations FALLOC_FL_COLLAPSE_RANGE,
FALLOC_FL_INSERT_RANGE, and FALLOC_FL_ZERO_RANGE are not supported
on encrypted files and will fail with EOPNOTSUPP.</li>
<li>Online defragmentation of encrypted files is not supported.  The
EXT4_IOC_MOVE_EXT and F2FS_IOC_MOVE_RANGE ioctls will fail with
EOPNOTSUPP.</li>
<li>The ext4 filesystem does not support data journaling with encrypted
regular files.  It will fall back to ordered data mode instead.</li>
<li>DAX (Direct Access) is not supported on encrypted files.</li>
<li>The st_size of an encrypted symlink will not necessarily give the
length of the symlink target as required by POSIX.  It will actually
give the length of the ciphertext, which will be slightly longer
than the plaintext due to NUL-padding and an extra 2-byte overhead.</li>
<li>The maximum length of an encrypted symlink is 2 bytes shorter than
the maximum length of an unencrypted symlink.  For example, on an
EXT4 filesystem with a 4K block size, unencrypted symlinks can be up
to 4095 bytes long, while encrypted symlinks can only be up to 4093
bytes long (both lengths excluding the terminating null).</li>
</ul>
<p>Note that mmap <em>is</em> supported.  This is possible because the pagecache
for an encrypted file contains the plaintext, not the ciphertext.</p>
</div>
<div class="section" id="without-the-key">
<h3>Without the key<a class="headerlink" href="#without-the-key" title="Permalink to this headline">¶</a></h3>
<p>Some filesystem operations may be performed on encrypted regular
files, directories, and symlinks even before their encryption key has
been provided:</p>
<ul>
<li><p class="first">File metadata may be read, e.g. using stat().</p>
</li>
<li><p class="first">Directories may be listed, in which case the filenames will be
listed in an encoded form derived from their ciphertext.  The
current encoding algorithm is described in <a class="reference internal" href="#filename-hashing-and-encoding">Filename hashing and
encoding</a>.  The algorithm is subject to change, but it is
guaranteed that the presented filenames will be no longer than
NAME_MAX bytes, will not contain the <code class="docutils literal"><span class="pre">/</span></code> or <code class="docutils literal"><span class="pre">\0</span></code> characters, and
will uniquely identify directory entries.</p>
<p>The <code class="docutils literal"><span class="pre">.</span></code> and <code class="docutils literal"><span class="pre">..</span></code> directory entries are special.  They are always
present and are not encrypted or encoded.</p>
</li>
<li><p class="first">Files may be deleted.  That is, nondirectory files may be deleted
with unlink() as usual, and empty directories may be deleted with
rmdir() as usual.  Therefore, <code class="docutils literal"><span class="pre">rm</span></code> and <code class="docutils literal"><span class="pre">rm</span> <span class="pre">-r</span></code> will work as
expected.</p>
</li>
<li><p class="first">Symlink targets may be read and followed, but they will be presented
in encrypted form, similar to filenames in directories.  Hence, they
are unlikely to point to anywhere useful.</p>
</li>
</ul>
<p>Without the key, regular files cannot be opened or truncated.
Attempts to do so will fail with ENOKEY.  This implies that any
regular file operations that require a file descriptor, such as
read(), write(), mmap(), fallocate(), and ioctl(), are also forbidden.</p>
<p>Also without the key, files of any type (including directories) cannot
be created or linked into an encrypted directory, nor can a name in an
encrypted directory be the source or target of a rename, nor can an
O_TMPFILE temporary file be created in an encrypted directory.  All
such operations will fail with ENOKEY.</p>
<p>It is not currently possible to backup and restore encrypted files
without the encryption key.  This would require special APIs which
have not yet been implemented.</p>
</div>
</div>
<div class="section" id="encryption-policy-enforcement">
<h2>Encryption policy enforcement<a class="headerlink" href="#encryption-policy-enforcement" title="Permalink to this headline">¶</a></h2>
<p>After an encryption policy has been set on a directory, all regular
files, directories, and symbolic links created in that directory
(recursively) will inherit that encryption policy.  Special files &#8212;
that is, named pipes, device nodes, and UNIX domain sockets &#8212; will
not be encrypted.</p>
<p>Except for those special files, it is forbidden to have unencrypted
files, or files encrypted with a different encryption policy, in an
encrypted directory tree.  Attempts to link or rename such a file into
an encrypted directory will fail with EPERM.  This is also enforced
during -&gt;lookup() to provide limited protection against offline
attacks that try to disable or downgrade encryption in known locations
where applications may later write sensitive data.  It is recommended
that systems implementing a form of &#8220;verified boot&#8221; take advantage of
this by validating all top-level encryption policies prior to access.</p>
</div>
<div class="section" id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="encryption-context">
<h3>Encryption context<a class="headerlink" href="#encryption-context" title="Permalink to this headline">¶</a></h3>
<p>An encryption policy is represented on-disk by a <code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">fscrypt_context</span></code>.  It is up to individual filesystems to decide where
to store it, but normally it would be stored in a hidden extended
attribute.  It should <em>not</em> be exposed by the xattr-related system
calls such as getxattr() and setxattr() because of the special
semantics of the encryption xattr.  (In particular, there would be
much confusion if an encryption policy were to be added to or removed
from anything other than an empty directory.)  The struct is defined
as follows:</p>
<div class="highlight-none"><div class="highlight"><pre>#define FS_KEY_DESCRIPTOR_SIZE  8
#define FS_KEY_DERIVATION_NONCE_SIZE 16

struct fscrypt_context {
        u8 format;
        u8 contents_encryption_mode;
        u8 filenames_encryption_mode;
        u8 flags;
        u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
        u8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];
};
</pre></div>
</div>
<p>Note that <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">fscrypt_context</span></code> contains the same
information as <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">fscrypt_policy</span></code> (see <a class="reference internal" href="#setting-an-encryption-policy">Setting an
encryption policy</a>), except that <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">fscrypt_context</span></code>
also contains a nonce.  The nonce is randomly generated by the kernel
and is used to derive the inode&#8217;s encryption key as described in
<a class="reference internal" href="#per-file-keys">Per-file keys</a>.</p>
</div>
<div class="section" id="data-path-changes">
<h3>Data path changes<a class="headerlink" href="#data-path-changes" title="Permalink to this headline">¶</a></h3>
<p>For the read path (-&gt;readpage()) of regular files, filesystems can
read the ciphertext into the page cache and decrypt it in-place.  The
page lock must be held until decryption has finished, to prevent the
page from becoming visible to userspace prematurely.</p>
<p>For the write path (-&gt;writepage()) of regular files, filesystems
cannot encrypt data in-place in the page cache, since the cached
plaintext must be preserved.  Instead, filesystems must encrypt into a
temporary buffer or &#8220;bounce page&#8221;, then write out the temporary
buffer.  Some filesystems, such as UBIFS, already use temporary
buffers regardless of encryption.  Other filesystems, such as ext4 and
F2FS, have to allocate bounce pages specially for encryption.</p>
</div>
<div class="section" id="filename-hashing-and-encoding">
<h3>Filename hashing and encoding<a class="headerlink" href="#filename-hashing-and-encoding" title="Permalink to this headline">¶</a></h3>
<p>Modern filesystems accelerate directory lookups by using indexed
directories.  An indexed directory is organized as a tree keyed by
filename hashes.  When a -&gt;lookup() is requested, the filesystem
normally hashes the filename being looked up so that it can quickly
find the corresponding directory entry, if any.</p>
<p>With encryption, lookups must be supported and efficient both with and
without the encryption key.  Clearly, it would not work to hash the
plaintext filenames, since the plaintext filenames are unavailable
without the key.  (Hashing the plaintext filenames would also make it
impossible for the filesystem&#8217;s fsck tool to optimize encrypted
directories.)  Instead, filesystems hash the ciphertext filenames,
i.e. the bytes actually stored on-disk in the directory entries.  When
asked to do a -&gt;lookup() with the key, the filesystem just encrypts
the user-supplied name to get the ciphertext.</p>
<p>Lookups without the key are more complicated.  The raw ciphertext may
contain the <code class="docutils literal"><span class="pre">\0</span></code> and <code class="docutils literal"><span class="pre">/</span></code> characters, which are illegal in
filenames.  Therefore, readdir() must base64-encode the ciphertext for
presentation.  For most filenames, this works fine; on -&gt;lookup(), the
filesystem just base64-decodes the user-supplied name to get back to
the raw ciphertext.</p>
<p>However, for very long filenames, base64 encoding would cause the
filename length to exceed NAME_MAX.  To prevent this, readdir()
actually presents long filenames in an abbreviated form which encodes
a strong &#8220;hash&#8221; of the ciphertext filename, along with the optional
filesystem-specific hash(es) needed for directory lookups.  This
allows the filesystem to still, with a high degree of confidence, map
the filename given in -&gt;lookup() back to a particular directory entry
that was previously listed by readdir().  See <code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">fscrypt_digested_name</span></code> in the source for more details.</p>
<p>Note that the precise way that filenames are presented to userspace
without the key is subject to change in the future.  It is only meant
as a way to temporarily present valid filenames so that commands like
<code class="docutils literal"><span class="pre">rm</span> <span class="pre">-r</span></code> work as expected on encrypted directories.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../vm/index.html" class="btn btn-neutral float-right" title="Linux Memory Management Documentation" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Linux Filesystems API" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>