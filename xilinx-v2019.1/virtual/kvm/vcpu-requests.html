

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>KVM VCPU Requests &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
    <li>KVM VCPU Requests</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/virtual/kvm/vcpu-requests.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="kvm-vcpu-requests">
<h1>KVM VCPU Requests<a class="headerlink" href="#kvm-vcpu-requests" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>KVM supports an internal API enabling threads to request a VCPU thread to
perform some activity.  For example, a thread may request a VCPU to flush
its TLB with a VCPU request.  The API consists of the following functions:</p>
<div class="highlight-none"><div class="highlight"><pre>/* Check if any requests are pending for VCPU @vcpu. */
bool kvm_request_pending(struct kvm_vcpu *vcpu);

/* Check if VCPU @vcpu has request @req pending. */
bool kvm_test_request(int req, struct kvm_vcpu *vcpu);

/* Clear request @req for VCPU @vcpu. */
void kvm_clear_request(int req, struct kvm_vcpu *vcpu);

/*
 * Check if VCPU @vcpu has request @req pending. When the request is
 * pending it will be cleared and a memory barrier, which pairs with
 * another in kvm_make_request(), will be issued.
 */
bool kvm_check_request(int req, struct kvm_vcpu *vcpu);

/*
 * Make request @req of VCPU @vcpu. Issues a memory barrier, which pairs
 * with another in kvm_check_request(), prior to setting the request.
 */
void kvm_make_request(int req, struct kvm_vcpu *vcpu);

/* Make request @req of all VCPUs of the VM with struct kvm @kvm. */
bool kvm_make_all_cpus_request(struct kvm *kvm, unsigned int req);
</pre></div>
</div>
<p>Typically a requester wants the VCPU to perform the activity as soon
as possible after making the request.  This means most requests
(kvm_make_request() calls) are followed by a call to kvm_vcpu_kick(),
and kvm_make_all_cpus_request() has the kicking of all VCPUs built
into it.</p>
<div class="section" id="vcpu-kicks">
<h3>VCPU Kicks<a class="headerlink" href="#vcpu-kicks" title="Permalink to this headline">¶</a></h3>
<p>The goal of a VCPU kick is to bring a VCPU thread out of guest mode in
order to perform some KVM maintenance.  To do so, an IPI is sent, forcing
a guest mode exit.  However, a VCPU thread may not be in guest mode at the
time of the kick.  Therefore, depending on the mode and state of the VCPU
thread, there are two other actions a kick may take.  All three actions
are listed below:</p>
<ol class="arabic simple">
<li>Send an IPI.  This forces a guest mode exit.</li>
<li>Waking a sleeping VCPU.  Sleeping VCPUs are VCPU threads outside guest
mode that wait on waitqueues.  Waking them removes the threads from
the waitqueues, allowing the threads to run again.  This behavior
may be suppressed, see KVM_REQUEST_NO_WAKEUP below.</li>
<li>Nothing.  When the VCPU is not in guest mode and the VCPU thread is not
sleeping, then there is nothing to do.</li>
</ol>
</div>
<div class="section" id="vcpu-mode">
<h3>VCPU Mode<a class="headerlink" href="#vcpu-mode" title="Permalink to this headline">¶</a></h3>
<p>VCPUs have a mode state, <code class="docutils literal"><span class="pre">vcpu-&gt;mode</span></code>, that is used to track whether the
guest is running in guest mode or not, as well as some specific
outside guest mode states.  The architecture may use <code class="docutils literal"><span class="pre">vcpu-&gt;mode</span></code> to
ensure VCPU requests are seen by VCPUs (see &#8220;Ensuring Requests Are Seen&#8221;),
as well as to avoid sending unnecessary IPIs (see &#8220;IPI Reduction&#8221;), and
even to ensure IPI acknowledgements are waited upon (see &#8220;Waiting for
Acknowledgements&#8221;).  The following modes are defined:</p>
<p>OUTSIDE_GUEST_MODE</p>
<blockquote>
<div>The VCPU thread is outside guest mode.</div></blockquote>
<p>IN_GUEST_MODE</p>
<blockquote>
<div>The VCPU thread is in guest mode.</div></blockquote>
<p>EXITING_GUEST_MODE</p>
<blockquote>
<div>The VCPU thread is transitioning from IN_GUEST_MODE to
OUTSIDE_GUEST_MODE.</div></blockquote>
<p>READING_SHADOW_PAGE_TABLES</p>
<blockquote>
<div>The VCPU thread is outside guest mode, but it wants the sender of
certain VCPU requests, namely KVM_REQ_TLB_FLUSH, to wait until the VCPU
thread is done reading the page tables.</div></blockquote>
</div>
</div>
<div class="section" id="vcpu-request-internals">
<h2>VCPU Request Internals<a class="headerlink" href="#vcpu-request-internals" title="Permalink to this headline">¶</a></h2>
<p>VCPU requests are simply bit indices of the <code class="docutils literal"><span class="pre">vcpu-&gt;requests</span></code> bitmap.
This means general bitops, like those documented in <a class="reference internal" href="#atomic-ops" id="id1">[atomic-ops]</a> could
also be used, e.g.</p>
<div class="highlight-none"><div class="highlight"><pre>clear_bit(KVM_REQ_UNHALT &amp; KVM_REQUEST_MASK, &amp;vcpu-&gt;requests);
</pre></div>
</div>
<p>However, VCPU request users should refrain from doing so, as it would
break the abstraction.  The first 8 bits are reserved for architecture
independent requests, all additional bits are available for architecture
dependent requests.</p>
<div class="section" id="architecture-independent-requests">
<h3>Architecture Independent Requests<a class="headerlink" href="#architecture-independent-requests" title="Permalink to this headline">¶</a></h3>
<p>KVM_REQ_TLB_FLUSH</p>
<blockquote>
<div>KVM&#8217;s common MMU notifier may need to flush all of a guest&#8217;s TLB
entries, calling kvm_flush_remote_tlbs() to do so.  Architectures that
choose to use the common kvm_flush_remote_tlbs() implementation will
need to handle this VCPU request.</div></blockquote>
<p>KVM_REQ_MMU_RELOAD</p>
<blockquote>
<div>When shadow page tables are used and memory slots are removed it&#8217;s
necessary to inform each VCPU to completely refresh the tables.  This
request is used for that.</div></blockquote>
<p>KVM_REQ_PENDING_TIMER</p>
<blockquote>
<div>This request may be made from a timer handler run on the host on behalf
of a VCPU.  It informs the VCPU thread to inject a timer interrupt.</div></blockquote>
<p>KVM_REQ_UNHALT</p>
<blockquote>
<div>This request may be made from the KVM common function kvm_vcpu_block(),
which is used to emulate an instruction that causes a CPU to halt until
one of an architectural specific set of events and/or interrupts is
received (determined by checking kvm_arch_vcpu_runnable()).  When that
event or interrupt arrives kvm_vcpu_block() makes the request.  This is
in contrast to when kvm_vcpu_block() returns due to any other reason,
such as a pending signal, which does not indicate the VCPU&#8217;s halt
emulation should stop, and therefore does not make the request.</div></blockquote>
</div>
<div class="section" id="kvm-request-mask">
<h3>KVM_REQUEST_MASK<a class="headerlink" href="#kvm-request-mask" title="Permalink to this headline">¶</a></h3>
<p>VCPU requests should be masked by KVM_REQUEST_MASK before using them with
bitops.  This is because only the lower 8 bits are used to represent the
request&#8217;s number.  The upper bits are used as flags.  Currently only two
flags are defined.</p>
</div>
<div class="section" id="vcpu-request-flags">
<h3>VCPU Request Flags<a class="headerlink" href="#vcpu-request-flags" title="Permalink to this headline">¶</a></h3>
<p>KVM_REQUEST_NO_WAKEUP</p>
<blockquote>
<div>This flag is applied to requests that only need immediate attention
from VCPUs running in guest mode.  That is, sleeping VCPUs do not need
to be awaken for these requests.  Sleeping VCPUs will handle the
requests when they are awaken later for some other reason.</div></blockquote>
<p>KVM_REQUEST_WAIT</p>
<blockquote>
<div>When requests with this flag are made with kvm_make_all_cpus_request(),
then the caller will wait for each VCPU to acknowledge its IPI before
proceeding.  This flag only applies to VCPUs that would receive IPIs.
If, for example, the VCPU is sleeping, so no IPI is necessary, then
the requesting thread does not wait.  This means that this flag may be
safely combined with KVM_REQUEST_NO_WAKEUP.  See &#8220;Waiting for
Acknowledgements&#8221; for more information about requests with
KVM_REQUEST_WAIT.</div></blockquote>
</div>
</div>
<div class="section" id="vcpu-requests-with-associated-state">
<h2>VCPU Requests with Associated State<a class="headerlink" href="#vcpu-requests-with-associated-state" title="Permalink to this headline">¶</a></h2>
<p>Requesters that want the receiving VCPU to handle new state need to ensure
the newly written state is observable to the receiving VCPU thread&#8217;s CPU
by the time it observes the request.  This means a write memory barrier
must be inserted after writing the new state and before setting the VCPU
request bit.  Additionally, on the receiving VCPU thread&#8217;s side, a
corresponding read barrier must be inserted after reading the request bit
and before proceeding to read the new state associated with it.  See
scenario 3, Message and Flag, of <a class="reference internal" href="#lwn-mb" id="id2">[lwn-mb]</a> and the kernel documentation
<a class="reference internal" href="#memory-barriers" id="id3">[memory-barriers]</a>.</p>
<p>The pair of functions, kvm_check_request() and kvm_make_request(), provide
the memory barriers, allowing this requirement to be handled internally by
the API.</p>
</div>
<div class="section" id="ensuring-requests-are-seen">
<h2>Ensuring Requests Are Seen<a class="headerlink" href="#ensuring-requests-are-seen" title="Permalink to this headline">¶</a></h2>
<p>When making requests to VCPUs, we want to avoid the receiving VCPU
executing in guest mode for an arbitrary long time without handling the
request.  We can be sure this won&#8217;t happen as long as we ensure the VCPU
thread checks kvm_request_pending() before entering guest mode and that a
kick will send an IPI to force an exit from guest mode when necessary.
Extra care must be taken to cover the period after the VCPU thread&#8217;s last
kvm_request_pending() check and before it has entered guest mode, as kick
IPIs will only trigger guest mode exits for VCPU threads that are in guest
mode or at least have already disabled interrupts in order to prepare to
enter guest mode.  This means that an optimized implementation (see &#8220;IPI
Reduction&#8221;) must be certain when it&#8217;s safe to not send the IPI.  One
solution, which all architectures except s390 apply, is to:</p>
<ul class="simple">
<li>set <code class="docutils literal"><span class="pre">vcpu-&gt;mode</span></code> to IN_GUEST_MODE between disabling the interrupts and
the last kvm_request_pending() check;</li>
<li>enable interrupts atomically when entering the guest.</li>
</ul>
<p>This solution also requires memory barriers to be placed carefully in both
the requesting thread and the receiving VCPU.  With the memory barriers we
can exclude the possibility of a VCPU thread observing
!kvm_request_pending() on its last check and then not receiving an IPI for
the next request made of it, even if the request is made immediately after
the check.  This is done by way of the Dekker memory barrier pattern
(scenario 10 of <a class="reference internal" href="#lwn-mb" id="id4">[lwn-mb]</a>).  As the Dekker pattern requires two variables,
this solution pairs <code class="docutils literal"><span class="pre">vcpu-&gt;mode</span></code> with <code class="docutils literal"><span class="pre">vcpu-&gt;requests</span></code>.  Substituting
them into the pattern gives:</p>
<div class="highlight-none"><div class="highlight"><pre>CPU1                                    CPU2
=================                       =================
local_irq_disable();
WRITE_ONCE(vcpu-&gt;mode, IN_GUEST_MODE);  kvm_make_request(REQ, vcpu);
smp_mb();                               smp_mb();
if (kvm_request_pending(vcpu)) {        if (READ_ONCE(vcpu-&gt;mode) ==
                                            IN_GUEST_MODE) {
    ...abort guest entry...                 ...send IPI...
}                                       }
</pre></div>
</div>
<p>As stated above, the IPI is only useful for VCPU threads in guest mode or
that have already disabled interrupts.  This is why this specific case of
the Dekker pattern has been extended to disable interrupts before setting
<code class="docutils literal"><span class="pre">vcpu-&gt;mode</span></code> to IN_GUEST_MODE.  WRITE_ONCE() and READ_ONCE() are used to
pedantically implement the memory barrier pattern, guaranteeing the
compiler doesn&#8217;t interfere with <code class="docutils literal"><span class="pre">vcpu-&gt;mode</span></code>&#8216;s carefully planned
accesses.</p>
<div class="section" id="ipi-reduction">
<h3>IPI Reduction<a class="headerlink" href="#ipi-reduction" title="Permalink to this headline">¶</a></h3>
<p>As only one IPI is needed to get a VCPU to check for any/all requests,
then they may be coalesced.  This is easily done by having the first IPI
sending kick also change the VCPU mode to something !IN_GUEST_MODE.  The
transitional state, EXITING_GUEST_MODE, is used for this purpose.</p>
</div>
<div class="section" id="waiting-for-acknowledgements">
<h3>Waiting for Acknowledgements<a class="headerlink" href="#waiting-for-acknowledgements" title="Permalink to this headline">¶</a></h3>
<p>Some requests, those with the KVM_REQUEST_WAIT flag set, require IPIs to
be sent, and the acknowledgements to be waited upon, even when the target
VCPU threads are in modes other than IN_GUEST_MODE.  For example, one case
is when a target VCPU thread is in READING_SHADOW_PAGE_TABLES mode, which
is set after disabling interrupts.  To support these cases, the
KVM_REQUEST_WAIT flag changes the condition for sending an IPI from
checking that the VCPU is IN_GUEST_MODE to checking that it is not
OUTSIDE_GUEST_MODE.</p>
</div>
<div class="section" id="request-less-vcpu-kicks">
<h3>Request-less VCPU Kicks<a class="headerlink" href="#request-less-vcpu-kicks" title="Permalink to this headline">¶</a></h3>
<p>As the determination of whether or not to send an IPI depends on the
two-variable Dekker memory barrier pattern, then it&#8217;s clear that
request-less VCPU kicks are almost never correct.  Without the assurance
that a non-IPI generating kick will still result in an action by the
receiving VCPU, as the final kvm_request_pending() check does for
request-accompanying kicks, then the kick may not do anything useful at
all.  If, for instance, a request-less kick was made to a VCPU that was
just about to set its mode to IN_GUEST_MODE, meaning no IPI is sent, then
the VCPU thread may continue its entry without actually having done
whatever it was the kick was meant to initiate.</p>
<p>One exception is x86&#8217;s posted interrupt mechanism.  In this case, however,
even the request-less VCPU kick is coupled with the same
local_irq_disable() + smp_mb() pattern described above; the ON bit
(Outstanding Notification) in the posted interrupt descriptor takes the
role of <code class="docutils literal"><span class="pre">vcpu-&gt;requests</span></code>.  When sending a posted interrupt, PIR.ON is
set before reading <code class="docutils literal"><span class="pre">vcpu-&gt;mode</span></code>; dually, in the VCPU thread,
vmx_sync_pir_to_irr() reads PIR after setting <code class="docutils literal"><span class="pre">vcpu-&gt;mode</span></code> to
IN_GUEST_MODE.</p>
</div>
</div>
<div class="section" id="additional-considerations">
<h2>Additional Considerations<a class="headerlink" href="#additional-considerations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sleeping-vcpus">
<h3>Sleeping VCPUs<a class="headerlink" href="#sleeping-vcpus" title="Permalink to this headline">¶</a></h3>
<p>VCPU threads may need to consider requests before and/or after calling
functions that may put them to sleep, e.g. kvm_vcpu_block().  Whether they
do or not, and, if they do, which requests need consideration, is
architecture dependent.  kvm_vcpu_block() calls kvm_arch_vcpu_runnable()
to check if it should awaken.  One reason to do so is to provide
architectures a function where requests may be checked if necessary.</p>
</div>
<div class="section" id="clearing-requests">
<h3>Clearing Requests<a class="headerlink" href="#clearing-requests" title="Permalink to this headline">¶</a></h3>
<p>Generally it only makes sense for the receiving VCPU thread to clear a
request.  However, in some circumstances, such as when the requesting
thread and the receiving VCPU thread are executed serially, such as when
they are the same thread, or when they are using some form of concurrency
control to temporarily execute synchronously, then it&#8217;s possible to know
that the request may be cleared immediately, rather than waiting for the
receiving VCPU thread to handle the request in VCPU RUN.  The only current
examples of this are kvm_vcpu_block() calls made by VCPUs to block
themselves.  A possible side-effect of that call is to make the
KVM_REQ_UNHALT request, which may then be cleared immediately when the
VCPU returns from the call.</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="atomic-ops" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[atomic-ops]</a></td><td>Documentation/core-api/atomic_ops.rst</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="memory-barriers" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[memory-barriers]</a></td><td>Documentation/memory-barriers.txt</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="lwn-mb" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[lwn-mb]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> <a class="reference external" href="https://lwn.net/Articles/573436/">https://lwn.net/Articles/573436/</a></td></tr>
</tbody>
</table>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>