

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>BPF Design Q&amp;A &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html"/>
        <link rel="up" title="BPF Documentation" href="index.html"/>
        <link rel="next" title="HOWTO interact with BPF subsystem" href="bpf_devel_QA.html"/>
        <link rel="prev" title="BPF Documentation" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/index.html">Linux Media Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">BPF Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html#frequently-asked-questions-faq">Frequently asked questions (FAQ)</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="">BPF Design Q&amp;A</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#questions-and-answers">Questions and Answers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="bpf_devel_QA.html">HOWTO interact with BPF subsystem</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">BPF Documentation</a> &raquo;</li>
      
    <li>BPF Design Q&amp;A</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/bpf/bpf_design_QA.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="bpf-design-q-a">
<h1>BPF Design Q&amp;A<a class="headerlink" href="#bpf-design-q-a" title="Permalink to this headline">Â¶</a></h1>
<p>BPF extensibility and applicability to networking, tracing, security
in the linux kernel and several user space implementations of BPF
virtual machine led to a number of misunderstanding on what BPF actually is.
This short QA is an attempt to address that and outline a direction
of where BPF is heading long term.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#questions-and-answers" id="id1">Questions and Answers</a><ul>
<li><a class="reference internal" href="#q-is-bpf-a-generic-instruction-set-similar-to-x64-and-arm64" id="id2">Q: Is BPF a generic instruction set similar to x64 and arm64?</a></li>
<li><a class="reference internal" href="#q-is-bpf-a-generic-virtual-machine" id="id3">Q: Is BPF a generic virtual machine ?</a></li>
<li><a class="reference internal" href="#bpf-is-generic-instruction-set-with-c-calling-convention" id="id4">BPF is generic instruction set <em>with</em> C calling convention.</a><ul>
<li><a class="reference internal" href="#q-why-c-calling-convention-was-chosen" id="id5">Q: Why C calling convention was chosen?</a></li>
<li><a class="reference internal" href="#q-can-multiple-return-values-be-supported-in-the-future" id="id6">Q: can multiple return values be supported in the future?</a></li>
<li><a class="reference internal" href="#q-can-more-than-5-function-arguments-be-supported-in-the-future" id="id7">Q: can more than 5 function arguments be supported in the future?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#q-can-bpf-programs-access-instruction-pointer-or-return-address" id="id8">Q: can BPF programs access instruction pointer or return address?</a></li>
<li><a class="reference internal" href="#q-can-bpf-programs-access-stack-pointer" id="id9">Q: can BPF programs access stack pointer ?</a></li>
<li><a class="reference internal" href="#q-does-c-calling-convention-diminishes-possible-use-cases" id="id10">Q: Does C-calling convention diminishes possible use cases?</a></li>
<li><a class="reference internal" href="#q-does-it-mean-that-innovative-extensions-to-bpf-code-are-disallowed" id="id11">Q: Does it mean that &#8216;innovative&#8217; extensions to BPF code are disallowed?</a></li>
<li><a class="reference internal" href="#q-can-loops-be-supported-in-a-safe-way" id="id12">Q: Can loops be supported in a safe way?</a></li>
<li><a class="reference internal" href="#instruction-level-questions" id="id13">Instruction level questions</a><ul>
<li><a class="reference internal" href="#q-ld-abs-and-ld-ind-instructions-vs-c-code" id="id14">Q: LD_ABS and LD_IND instructions vs C code</a></li>
<li><a class="reference internal" href="#q-bpf-instructions-mapping-not-one-to-one-to-native-cpu" id="id15">Q: BPF instructions mapping not one-to-one to native CPU</a></li>
<li><a class="reference internal" href="#q-why-bpf-div-instruction-doesn-t-map-to-x64-div" id="id16">Q: why BPF_DIV instruction doesn&#8217;t map to x64 div?</a></li>
<li><a class="reference internal" href="#q-why-there-is-no-bpf-sdiv-for-signed-divide-operation" id="id17">Q: why there is no BPF_SDIV for signed divide operation?</a></li>
<li><a class="reference internal" href="#q-why-bpf-has-implicit-prologue-and-epilogue" id="id18">Q: Why BPF has implicit prologue and epilogue?</a></li>
<li><a class="reference internal" href="#q-why-bpf-jlt-and-bpf-jle-instructions-were-not-introduced-in-the-beginning" id="id19">Q: Why BPF_JLT and BPF_JLE instructions were not introduced in the beginning?</a></li>
<li><a class="reference internal" href="#q-bpf-32-bit-subregister-requirements" id="id20">Q: BPF 32-bit subregister requirements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#q-does-bpf-have-a-stable-abi" id="id21">Q: Does BPF have a stable ABI?</a></li>
<li><a class="reference internal" href="#q-how-much-stack-space-a-bpf-program-uses" id="id22">Q: How much stack space a BPF program uses?</a></li>
<li><a class="reference internal" href="#q-can-bpf-be-offloaded-to-hw" id="id23">Q: Can BPF be offloaded to HW?</a></li>
<li><a class="reference internal" href="#q-does-classic-bpf-interpreter-still-exist" id="id24">Q: Does classic BPF interpreter still exist?</a></li>
<li><a class="reference internal" href="#q-can-bpf-call-arbitrary-kernel-functions" id="id25">Q: Can BPF call arbitrary kernel functions?</a></li>
<li><a class="reference internal" href="#q-can-bpf-overwrite-arbitrary-kernel-memory" id="id26">Q: Can BPF overwrite arbitrary kernel memory?</a></li>
<li><a class="reference internal" href="#q-can-bpf-overwrite-arbitrary-user-memory" id="id27">Q: Can BPF overwrite arbitrary user memory?</a></li>
<li><a class="reference internal" href="#q-bpf-trace-printk-helper-warning" id="id28">Q: bpf_trace_printk() helper warning</a></li>
<li><a class="reference internal" href="#q-new-functionality-via-kernel-modules" id="id29">Q: New functionality via kernel modules?</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="questions-and-answers">
<h2><a class="toc-backref" href="#id1">Questions and Answers</a><a class="headerlink" href="#questions-and-answers" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="q-is-bpf-a-generic-instruction-set-similar-to-x64-and-arm64">
<h3><a class="toc-backref" href="#id2">Q: Is BPF a generic instruction set similar to x64 and arm64?</a><a class="headerlink" href="#q-is-bpf-a-generic-instruction-set-similar-to-x64-and-arm64" title="Permalink to this headline">Â¶</a></h3>
<p>A: NO.</p>
</div>
<div class="section" id="q-is-bpf-a-generic-virtual-machine">
<h3><a class="toc-backref" href="#id3">Q: Is BPF a generic virtual machine ?</a><a class="headerlink" href="#q-is-bpf-a-generic-virtual-machine" title="Permalink to this headline">Â¶</a></h3>
<p>A: NO.</p>
</div>
<div class="section" id="bpf-is-generic-instruction-set-with-c-calling-convention">
<h3><a class="toc-backref" href="#id4">BPF is generic instruction set <em>with</em> C calling convention.</a><a class="headerlink" href="#bpf-is-generic-instruction-set-with-c-calling-convention" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="q-why-c-calling-convention-was-chosen">
<h4><a class="toc-backref" href="#id5">Q: Why C calling convention was chosen?</a><a class="headerlink" href="#q-why-c-calling-convention-was-chosen" title="Permalink to this headline">Â¶</a></h4>
<p>A: Because BPF programs are designed to run in the linux kernel
which is written in C, hence BPF defines instruction set compatible
with two most used architectures x64 and arm64 (and takes into
consideration important quirks of other architectures) and
defines calling convention that is compatible with C calling
convention of the linux kernel on those architectures.</p>
</div>
<div class="section" id="q-can-multiple-return-values-be-supported-in-the-future">
<h4><a class="toc-backref" href="#id6">Q: can multiple return values be supported in the future?</a><a class="headerlink" href="#q-can-multiple-return-values-be-supported-in-the-future" title="Permalink to this headline">Â¶</a></h4>
<p>A: NO. BPF allows only register R0 to be used as return value.</p>
</div>
<div class="section" id="q-can-more-than-5-function-arguments-be-supported-in-the-future">
<h4><a class="toc-backref" href="#id7">Q: can more than 5 function arguments be supported in the future?</a><a class="headerlink" href="#q-can-more-than-5-function-arguments-be-supported-in-the-future" title="Permalink to this headline">Â¶</a></h4>
<p>A: NO. BPF calling convention only allows registers R1-R5 to be used
as arguments. BPF is not a standalone instruction set.
(unlike x64 ISA that allows msft, cdecl and other conventions)</p>
</div>
</div>
<div class="section" id="q-can-bpf-programs-access-instruction-pointer-or-return-address">
<h3><a class="toc-backref" href="#id8">Q: can BPF programs access instruction pointer or return address?</a><a class="headerlink" href="#q-can-bpf-programs-access-instruction-pointer-or-return-address" title="Permalink to this headline">Â¶</a></h3>
<p>A: NO.</p>
</div>
<div class="section" id="q-can-bpf-programs-access-stack-pointer">
<h3><a class="toc-backref" href="#id9">Q: can BPF programs access stack pointer ?</a><a class="headerlink" href="#q-can-bpf-programs-access-stack-pointer" title="Permalink to this headline">Â¶</a></h3>
<p>A: NO.</p>
<p>Only frame pointer (register R10) is accessible.
From compiler point of view it&#8217;s necessary to have stack pointer.
For example LLVM defines register R11 as stack pointer in its
BPF backend, but it makes sure that generated code never uses it.</p>
</div>
<div class="section" id="q-does-c-calling-convention-diminishes-possible-use-cases">
<h3><a class="toc-backref" href="#id10">Q: Does C-calling convention diminishes possible use cases?</a><a class="headerlink" href="#q-does-c-calling-convention-diminishes-possible-use-cases" title="Permalink to this headline">Â¶</a></h3>
<p>A: YES.</p>
<p>BPF design forces addition of major functionality in the form
of kernel helper functions and kernel objects like BPF maps with
seamless interoperability between them. It lets kernel call into
BPF programs and programs call kernel helpers with zero overhead.
As all of them were native C code. That is particularly the case
for JITed BPF programs that are indistinguishable from
native kernel C code.</p>
</div>
<div class="section" id="q-does-it-mean-that-innovative-extensions-to-bpf-code-are-disallowed">
<h3><a class="toc-backref" href="#id11">Q: Does it mean that &#8216;innovative&#8217; extensions to BPF code are disallowed?</a><a class="headerlink" href="#q-does-it-mean-that-innovative-extensions-to-bpf-code-are-disallowed" title="Permalink to this headline">Â¶</a></h3>
<p>A: Soft yes.</p>
<p>At least for now until BPF core has support for
bpf-to-bpf calls, indirect calls, loops, global variables,
jump tables, read only sections and all other normal constructs
that C code can produce.</p>
</div>
<div class="section" id="q-can-loops-be-supported-in-a-safe-way">
<h3><a class="toc-backref" href="#id12">Q: Can loops be supported in a safe way?</a><a class="headerlink" href="#q-can-loops-be-supported-in-a-safe-way" title="Permalink to this headline">Â¶</a></h3>
<p>A: It&#8217;s not clear yet.</p>
<p>BPF developers are trying to find a way to
support bounded loops where the verifier can guarantee that
the program terminates in less than 4096 instructions.</p>
</div>
<div class="section" id="instruction-level-questions">
<h3><a class="toc-backref" href="#id13">Instruction level questions</a><a class="headerlink" href="#instruction-level-questions" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="q-ld-abs-and-ld-ind-instructions-vs-c-code">
<h4><a class="toc-backref" href="#id14">Q: LD_ABS and LD_IND instructions vs C code</a><a class="headerlink" href="#q-ld-abs-and-ld-ind-instructions-vs-c-code" title="Permalink to this headline">Â¶</a></h4>
<p>Q: How come LD_ABS and LD_IND instruction are present in BPF whereas
C code cannot express them and has to use builtin intrinsics?</p>
<p>A: This is artifact of compatibility with classic BPF. Modern
networking code in BPF performs better without them.
See &#8216;direct packet access&#8217;.</p>
</div>
<div class="section" id="q-bpf-instructions-mapping-not-one-to-one-to-native-cpu">
<h4><a class="toc-backref" href="#id15">Q: BPF instructions mapping not one-to-one to native CPU</a><a class="headerlink" href="#q-bpf-instructions-mapping-not-one-to-one-to-native-cpu" title="Permalink to this headline">Â¶</a></h4>
<p>Q: It seems not all BPF instructions are one-to-one to native CPU.
For example why BPF_JNE and other compare and jumps are not cpu-like?</p>
<p>A: This was necessary to avoid introducing flags into ISA which are
impossible to make generic and efficient across CPU architectures.</p>
</div>
<div class="section" id="q-why-bpf-div-instruction-doesn-t-map-to-x64-div">
<h4><a class="toc-backref" href="#id16">Q: why BPF_DIV instruction doesn&#8217;t map to x64 div?</a><a class="headerlink" href="#q-why-bpf-div-instruction-doesn-t-map-to-x64-div" title="Permalink to this headline">Â¶</a></h4>
<p>A: Because if we picked one-to-one relationship to x64 it would have made
it more complicated to support on arm64 and other archs. Also it
needs div-by-zero runtime check.</p>
</div>
<div class="section" id="q-why-there-is-no-bpf-sdiv-for-signed-divide-operation">
<h4><a class="toc-backref" href="#id17">Q: why there is no BPF_SDIV for signed divide operation?</a><a class="headerlink" href="#q-why-there-is-no-bpf-sdiv-for-signed-divide-operation" title="Permalink to this headline">Â¶</a></h4>
<p>A: Because it would be rarely used. llvm errors in such case and
prints a suggestion to use unsigned divide instead</p>
</div>
<div class="section" id="q-why-bpf-has-implicit-prologue-and-epilogue">
<h4><a class="toc-backref" href="#id18">Q: Why BPF has implicit prologue and epilogue?</a><a class="headerlink" href="#q-why-bpf-has-implicit-prologue-and-epilogue" title="Permalink to this headline">Â¶</a></h4>
<p>A: Because architectures like sparc have register windows and in general
there are enough subtle differences between architectures, so naive
store return address into stack won&#8217;t work. Another reason is BPF has
to be safe from division by zero (and legacy exception path
of LD_ABS insn). Those instructions need to invoke epilogue and
return implicitly.</p>
</div>
<div class="section" id="q-why-bpf-jlt-and-bpf-jle-instructions-were-not-introduced-in-the-beginning">
<h4><a class="toc-backref" href="#id19">Q: Why BPF_JLT and BPF_JLE instructions were not introduced in the beginning?</a><a class="headerlink" href="#q-why-bpf-jlt-and-bpf-jle-instructions-were-not-introduced-in-the-beginning" title="Permalink to this headline">Â¶</a></h4>
<p>A: Because classic BPF didn&#8217;t have them and BPF authors felt that compiler
workaround would be acceptable. Turned out that programs lose performance
due to lack of these compare instructions and they were added.
These two instructions is a perfect example what kind of new BPF
instructions are acceptable and can be added in the future.
These two already had equivalent instructions in native CPUs.
New instructions that don&#8217;t have one-to-one mapping to HW instructions
will not be accepted.</p>
</div>
<div class="section" id="q-bpf-32-bit-subregister-requirements">
<h4><a class="toc-backref" href="#id20">Q: BPF 32-bit subregister requirements</a><a class="headerlink" href="#q-bpf-32-bit-subregister-requirements" title="Permalink to this headline">Â¶</a></h4>
<p>Q: BPF 32-bit subregisters have a requirement to zero upper 32-bits of BPF
registers which makes BPF inefficient virtual machine for 32-bit
CPU architectures and 32-bit HW accelerators. Can true 32-bit registers
be added to BPF in the future?</p>
<p>A: NO. The first thing to improve performance on 32-bit archs is to teach
LLVM to generate code that uses 32-bit subregisters. Then second step
is to teach verifier to mark operations where zero-ing upper bits
is unnecessary. Then JITs can take advantage of those markings and
drastically reduce size of generated code and improve performance.</p>
</div>
</div>
<div class="section" id="q-does-bpf-have-a-stable-abi">
<h3><a class="toc-backref" href="#id21">Q: Does BPF have a stable ABI?</a><a class="headerlink" href="#q-does-bpf-have-a-stable-abi" title="Permalink to this headline">Â¶</a></h3>
<p>A: YES. BPF instructions, arguments to BPF programs, set of helper
functions and their arguments, recognized return codes are all part
of ABI. However when tracing programs are using bpf_probe_read() helper
to walk kernel internal datastructures and compile with kernel
internal headers these accesses can and will break with newer
kernels. The union bpf_attr -&gt; kern_version is checked at load time
to prevent accidentally loading kprobe-based bpf programs written
for a different kernel. Networking programs don&#8217;t do kern_version check.</p>
</div>
<div class="section" id="q-how-much-stack-space-a-bpf-program-uses">
<h3><a class="toc-backref" href="#id22">Q: How much stack space a BPF program uses?</a><a class="headerlink" href="#q-how-much-stack-space-a-bpf-program-uses" title="Permalink to this headline">Â¶</a></h3>
<p>A: Currently all program types are limited to 512 bytes of stack
space, but the verifier computes the actual amount of stack used
and both interpreter and most JITed code consume necessary amount.</p>
</div>
<div class="section" id="q-can-bpf-be-offloaded-to-hw">
<h3><a class="toc-backref" href="#id23">Q: Can BPF be offloaded to HW?</a><a class="headerlink" href="#q-can-bpf-be-offloaded-to-hw" title="Permalink to this headline">Â¶</a></h3>
<p>A: YES. BPF HW offload is supported by NFP driver.</p>
</div>
<div class="section" id="q-does-classic-bpf-interpreter-still-exist">
<h3><a class="toc-backref" href="#id24">Q: Does classic BPF interpreter still exist?</a><a class="headerlink" href="#q-does-classic-bpf-interpreter-still-exist" title="Permalink to this headline">Â¶</a></h3>
<p>A: NO. Classic BPF programs are converted into extend BPF instructions.</p>
</div>
<div class="section" id="q-can-bpf-call-arbitrary-kernel-functions">
<h3><a class="toc-backref" href="#id25">Q: Can BPF call arbitrary kernel functions?</a><a class="headerlink" href="#q-can-bpf-call-arbitrary-kernel-functions" title="Permalink to this headline">Â¶</a></h3>
<p>A: NO. BPF programs can only call a set of helper functions which
is defined for every program type.</p>
</div>
<div class="section" id="q-can-bpf-overwrite-arbitrary-kernel-memory">
<h3><a class="toc-backref" href="#id26">Q: Can BPF overwrite arbitrary kernel memory?</a><a class="headerlink" href="#q-can-bpf-overwrite-arbitrary-kernel-memory" title="Permalink to this headline">Â¶</a></h3>
<p>A: NO.</p>
<p>Tracing bpf programs can <em>read</em> arbitrary memory with bpf_probe_read()
and bpf_probe_read_str() helpers. Networking programs cannot read
arbitrary memory, since they don&#8217;t have access to these helpers.
Programs can never read or write arbitrary memory directly.</p>
</div>
<div class="section" id="q-can-bpf-overwrite-arbitrary-user-memory">
<h3><a class="toc-backref" href="#id27">Q: Can BPF overwrite arbitrary user memory?</a><a class="headerlink" href="#q-can-bpf-overwrite-arbitrary-user-memory" title="Permalink to this headline">Â¶</a></h3>
<p>A: Sort-of.</p>
<p>Tracing BPF programs can overwrite the user memory
of the current task with bpf_probe_write_user(). Every time such
program is loaded the kernel will print warning message, so
this helper is only useful for experiments and prototypes.
Tracing BPF programs are root only.</p>
</div>
<div class="section" id="q-bpf-trace-printk-helper-warning">
<h3><a class="toc-backref" href="#id28">Q: bpf_trace_printk() helper warning</a><a class="headerlink" href="#q-bpf-trace-printk-helper-warning" title="Permalink to this headline">Â¶</a></h3>
<p>Q: When bpf_trace_printk() helper is used the kernel prints nasty
warning message. Why is that?</p>
<p>A: This is done to nudge program authors into better interfaces when
programs need to pass data to user space. Like bpf_perf_event_output()
can be used to efficiently stream data via perf ring buffer.
BPF maps can be used for asynchronous data sharing between kernel
and user space. bpf_trace_printk() should only be used for debugging.</p>
</div>
<div class="section" id="q-new-functionality-via-kernel-modules">
<h3><a class="toc-backref" href="#id29">Q: New functionality via kernel modules?</a><a class="headerlink" href="#q-new-functionality-via-kernel-modules" title="Permalink to this headline">Â¶</a></h3>
<p>Q: Can BPF functionality such as new program or map types, new
helpers, etc be added out of kernel module code?</p>
<p>A: NO.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bpf_devel_QA.html" class="btn btn-neutral float-right" title="HOWTO interact with BPF subsystem" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="BPF Documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>