

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. Media Controller devices &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/>
        <link rel="up" title="Media subsystem kernel internal API" href="../media_kapi.html"/>
        <link rel="next" title="5. CEC Kernel Support" href="cec-core.html"/>
        <link rel="prev" title="3. Remote Controller devices" href="rc-core.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">4. Media Controller devices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#media-controller">4.1. Media Controller</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
      
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
      
    <li>4. Media Controller devices</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/media/kapi/mc-core.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="media-controller-devices">
<h1>4. Media Controller devices<a class="headerlink" href="#media-controller-devices" title="Permalink to this headline">¶</a></h1>
<div class="section" id="media-controller">
<h2>4.1. Media Controller<a class="headerlink" href="#media-controller" title="Permalink to this headline">¶</a></h2>
<p>The media controller userspace API is documented in
<a class="reference internal" href="../uapi/mediactl/media-controller.html#media-controller"><span>the Media Controller uAPI book</span></a>. This document focus
on the kernel-side implementation of the media framework.</p>
<div class="section" id="abstract-media-device-model">
<h3>4.1.1. Abstract media device model<a class="headerlink" href="#abstract-media-device-model" title="Permalink to this headline">¶</a></h3>
<p>Discovering a device internal topology, and configuring it at runtime, is one
of the goals of the media framework. To achieve this, hardware devices are
modelled as an oriented graph of building blocks called entities connected
through pads.</p>
<p>An entity is a basic media hardware building block. It can correspond to
a large variety of logical blocks such as physical hardware devices
(CMOS sensor for instance), logical hardware devices (a building block
in a System-on-Chip image processing pipeline), DMA channels or physical
connectors.</p>
<p>A pad is a connection endpoint through which an entity can interact with
other entities. Data (not restricted to video) produced by an entity
flows from the entity&#8217;s output to one or more entity inputs. Pads should
not be confused with physical pins at chip boundaries.</p>
<p>A link is a point-to-point oriented connection between two pads, either
on the same entity or on different entities. Data flows from a source
pad to a sink pad.</p>
</div>
<div class="section" id="media-device">
<h3>4.1.2. Media device<a class="headerlink" href="#media-device" title="Permalink to this headline">¶</a></h3>
<p>A media device is represented by a struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a>
instance, defined in <code class="docutils literal"><span class="pre">include/media/media-device.h</span></code>.
Allocation of the structure is handled by the media device driver, usually by
embedding the <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> instance in a larger driver-specific
structure.</p>
<p>Drivers register media device instances by calling
<a class="reference internal" href="#c.__media_device_register" title="__media_device_register"><code class="xref c c-func docutils literal"><span class="pre">__media_device_register()</span></code></a> via the macro <code class="docutils literal"><span class="pre">media_device_register()</span></code>
and unregistered by calling <a class="reference internal" href="#c.media_device_unregister" title="media_device_unregister"><code class="xref c c-func docutils literal"><span class="pre">media_device_unregister()</span></code></a>.</p>
</div>
<div class="section" id="entities">
<h3>4.1.3. Entities<a class="headerlink" href="#entities" title="Permalink to this headline">¶</a></h3>
<p>Entities are represented by a struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a>
instance, defined in <code class="docutils literal"><span class="pre">include/media/media-entity.h</span></code>. The structure is usually
embedded into a higher-level structure, such as
<a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal"><span class="pre">v4l2_subdev</span></code></a> or <a class="reference internal" href="v4l2-dev.html#c.video_device" title="video_device"><code class="xref c c-type docutils literal"><span class="pre">video_device</span></code></a>
instances, although drivers can allocate entities directly.</p>
<p>Drivers initialize entity pads by calling
<a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal"><span class="pre">media_entity_pads_init()</span></code></a>.</p>
<p>Drivers register entities with a media device by calling
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal"><span class="pre">media_device_register_entity()</span></code></a>
and unregistred by calling
<a class="reference internal" href="#c.media_device_unregister_entity" title="media_device_unregister_entity"><code class="xref c c-func docutils literal"><span class="pre">media_device_unregister_entity()</span></code></a>.</p>
</div>
<div class="section" id="interfaces">
<h3>4.1.4. Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h3>
<p>Interfaces are represented by a
struct <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal"><span class="pre">media_interface</span></code></a> instance, defined in
<code class="docutils literal"><span class="pre">include/media/media-entity.h</span></code>. Currently, only one type of interface is
defined: a device node. Such interfaces are represented by a
struct <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-type docutils literal"><span class="pre">media_intf_devnode</span></code></a>.</p>
<p>Drivers initialize and create device node interfaces by calling
<a class="reference internal" href="#c.media_devnode_create" title="media_devnode_create"><code class="xref c c-func docutils literal"><span class="pre">media_devnode_create()</span></code></a>
and remove them by calling:
<a class="reference internal" href="#c.media_devnode_remove" title="media_devnode_remove"><code class="xref c c-func docutils literal"><span class="pre">media_devnode_remove()</span></code></a>.</p>
</div>
<div class="section" id="pads">
<h3>4.1.5. Pads<a class="headerlink" href="#pads" title="Permalink to this headline">¶</a></h3>
<p>Pads are represented by a struct <a class="reference internal" href="#c.media_pad" title="media_pad"><code class="xref c c-type docutils literal"><span class="pre">media_pad</span></code></a> instance,
defined in <code class="docutils literal"><span class="pre">include/media/media-entity.h</span></code>. Each entity stores its pads in
a pads array managed by the entity driver. Drivers usually embed the array in
a driver-specific structure.</p>
<p>Pads are identified by their entity and their 0-based index in the pads
array.</p>
<p>Both information are stored in the struct <a class="reference internal" href="#c.media_pad" title="media_pad"><code class="xref c c-type docutils literal"><span class="pre">media_pad</span></code></a>,
making the struct <a class="reference internal" href="#c.media_pad" title="media_pad"><code class="xref c c-type docutils literal"><span class="pre">media_pad</span></code></a> pointer the canonical way
to store and pass link references.</p>
<p>Pads have flags that describe the pad capabilities and state.</p>
<p><code class="docutils literal"><span class="pre">MEDIA_PAD_FL_SINK</span></code> indicates that the pad supports sinking data.
<code class="docutils literal"><span class="pre">MEDIA_PAD_FL_SOURCE</span></code> indicates that the pad supports sourcing data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">One and only one of <code class="docutils literal"><span class="pre">MEDIA_PAD_FL_SINK</span></code> or <code class="docutils literal"><span class="pre">MEDIA_PAD_FL_SOURCE</span></code> must
be set for each pad.</p>
</div>
</div>
<div class="section" id="links">
<h3>4.1.6. Links<a class="headerlink" href="#links" title="Permalink to this headline">¶</a></h3>
<p>Links are represented by a struct <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal"><span class="pre">media_link</span></code></a> instance,
defined in <code class="docutils literal"><span class="pre">include/media/media-entity.h</span></code>. There are two types of links:</p>
<p><strong>1. pad to pad links</strong>:</p>
<p>Associate two entities via their PADs. Each entity has a list that points
to all links originating at or targeting any of its pads.
A given link is thus stored twice, once in the source entity and once in
the target entity.</p>
<p>Drivers create pad to pad links by calling:
<a class="reference internal" href="#c.media_create_pad_link" title="media_create_pad_link"><code class="xref c c-func docutils literal"><span class="pre">media_create_pad_link()</span></code></a> and remove with
<a class="reference internal" href="#c.media_entity_remove_links" title="media_entity_remove_links"><code class="xref c c-func docutils literal"><span class="pre">media_entity_remove_links()</span></code></a>.</p>
<p><strong>2. interface to entity links</strong>:</p>
<p>Associate one interface to a Link.</p>
<p>Drivers create interface to entity links by calling:
<a class="reference internal" href="#c.media_create_intf_link" title="media_create_intf_link"><code class="xref c c-func docutils literal"><span class="pre">media_create_intf_link()</span></code></a> and remove with
<a class="reference internal" href="#c.media_remove_intf_links" title="media_remove_intf_links"><code class="xref c c-func docutils literal"><span class="pre">media_remove_intf_links()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Links can only be created after having both ends already created.</p>
</div>
<p>Links have flags that describe the link capabilities and state. The
valid values are described at <a class="reference internal" href="#c.media_create_pad_link" title="media_create_pad_link"><code class="xref c c-func docutils literal"><span class="pre">media_create_pad_link()</span></code></a> and
<a class="reference internal" href="#c.media_create_intf_link" title="media_create_intf_link"><code class="xref c c-func docutils literal"><span class="pre">media_create_intf_link()</span></code></a>.</p>
</div>
<div class="section" id="graph-traversal">
<h3>4.1.7. Graph traversal<a class="headerlink" href="#graph-traversal" title="Permalink to this headline">¶</a></h3>
<p>The media framework provides APIs to iterate over entities in a graph.</p>
<p>To iterate over all entities belonging to a media device, drivers can use
the media_device_for_each_entity macro, defined in
<code class="docutils literal"><span class="pre">include/media/media-device.h</span></code>.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">media_entity</span> <span class="o">*</span><span class="n">entity</span><span class="p">;</span>

<span class="n">media_device_for_each_entity</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">mdev</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// entity will point to each entity in turn</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Drivers might also need to iterate over all entities in a graph that can be
reached only through enabled links starting at a given entity. The media
framework provides a depth-first graph traversal API for that purpose.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Graphs with cycles (whether directed or undirected) are <strong>NOT</strong>
supported by the graph traversal API. To prevent infinite loops, the graph
traversal code limits the maximum depth to <code class="docutils literal"><span class="pre">MEDIA_ENTITY_ENUM_MAX_DEPTH</span></code>,
currently defined as 16.</p>
</div>
<p>Drivers initiate a graph traversal by calling
<a class="reference internal" href="#c.media_graph_walk_start" title="media_graph_walk_start"><code class="xref c c-func docutils literal"><span class="pre">media_graph_walk_start()</span></code></a></p>
<p>The graph structure, provided by the caller, is initialized to start graph
traversal at the given entity.</p>
<p>Drivers can then retrieve the next entity by calling
<a class="reference internal" href="#c.media_graph_walk_next" title="media_graph_walk_next"><code class="xref c c-func docutils literal"><span class="pre">media_graph_walk_next()</span></code></a></p>
<p>When the graph traversal is complete the function will return <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<p>Graph traversal can be interrupted at any moment. No cleanup function call
is required and the graph structure can be freed normally.</p>
<p>Helper functions can be used to find a link between two given pads, or a pad
connected to another pad through an enabled link
<a class="reference internal" href="#c.media_entity_find_link" title="media_entity_find_link"><code class="xref c c-func docutils literal"><span class="pre">media_entity_find_link()</span></code></a> and
<a class="reference internal" href="#c.media_entity_remote_pad" title="media_entity_remote_pad"><code class="xref c c-func docutils literal"><span class="pre">media_entity_remote_pad()</span></code></a>.</p>
</div>
<div class="section" id="use-count-and-power-handling">
<h3>4.1.8. Use count and power handling<a class="headerlink" href="#use-count-and-power-handling" title="Permalink to this headline">¶</a></h3>
<p>Due to the wide differences between drivers regarding power management
needs, the media controller does not implement power management. However,
the struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> includes a <code class="docutils literal"><span class="pre">use_count</span></code>
field that media drivers
can use to track the number of users of every entity for power management
needs.</p>
<p>The <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a>.<code class="docutils literal"><span class="pre">use_count</span></code> field is owned by
media drivers and must not be
touched by entity drivers. Access to the field must be protected by the
<a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a>.<code class="docutils literal"><span class="pre">graph_mutex</span></code> lock.</p>
</div>
<div class="section" id="links-setup">
<h3>4.1.9. Links setup<a class="headerlink" href="#links-setup" title="Permalink to this headline">¶</a></h3>
<p>Link properties can be modified at runtime by calling
<a class="reference internal" href="#c.media_entity_setup_link" title="media_entity_setup_link"><code class="xref c c-func docutils literal"><span class="pre">media_entity_setup_link()</span></code></a>.</p>
</div>
<div class="section" id="pipelines-and-media-streams">
<h3>4.1.10. Pipelines and media streams<a class="headerlink" href="#pipelines-and-media-streams" title="Permalink to this headline">¶</a></h3>
<p>When starting streaming, drivers must notify all entities in the pipeline to
prevent link states from being modified during streaming by calling
<a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a>.</p>
<p>The function will mark all entities connected to the given entity through
enabled links, either directly or indirectly, as streaming.</p>
<p>The struct <a class="reference internal" href="#c.media_pipeline" title="media_pipeline"><code class="xref c c-type docutils literal"><span class="pre">media_pipeline</span></code></a> instance pointed to by
the pipe argument will be stored in every entity in the pipeline.
Drivers should embed the struct <a class="reference internal" href="#c.media_pipeline" title="media_pipeline"><code class="xref c c-type docutils literal"><span class="pre">media_pipeline</span></code></a>
in higher-level pipeline structures and can then access the
pipeline through the struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a>
pipe field.</p>
<p>Calls to <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a> can be nested.
The pipeline pointer must be identical for all nested calls to the function.</p>
<p><a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a> may return an error. In that case,
it will clean up any of the changes it did by itself.</p>
<p>When stopping the stream, drivers must notify the entities with
<a class="reference internal" href="#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_stop()</span></code></a>.</p>
<p>If multiple calls to <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a> have been
made the same number of <a class="reference internal" href="#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_stop()</span></code></a> calls
are required to stop streaming.
The <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a>.<code class="docutils literal"><span class="pre">pipe</span></code> field is reset to <code class="docutils literal"><span class="pre">NULL</span></code> on the last
nested stop call.</p>
<p>Link configuration will fail with <code class="docutils literal"><span class="pre">-EBUSY</span></code> by default if either end of the
link is a streaming entity. Links that can be modified while streaming must
be marked with the <code class="docutils literal"><span class="pre">MEDIA_LNK_FL_DYNAMIC</span></code> flag.</p>
<p>If other operations need to be disallowed on streaming entities (such as
changing entities configuration parameters) drivers can explicitly check the
media_entity stream_count field to find out if an entity is streaming. This
operation must be done with the media_device graph_mutex held.</p>
</div>
<div class="section" id="link-validation">
<h3>4.1.11. Link validation<a class="headerlink" href="#link-validation" title="Permalink to this headline">¶</a></h3>
<p>Link validation is performed by <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a>
for any entity which has sink pads in the pipeline. The
<a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a>.<code class="docutils literal"><span class="pre">link_validate()</span></code> callback is used for that
purpose. In <code class="docutils literal"><span class="pre">link_validate()</span></code> callback, entity driver should check
that the properties of the source pad of the connected entity and its own
sink pad match. It is up to the type of the entity (and in the end, the
properties of the hardware) what matching actually means.</p>
<p>Subsystems should facilitate link validation by providing subsystem specific
helper functions to provide easy access for commonly needed information, and
in the end provide a way to use driver-specific callbacks.</p>
<dl class="type">
<dt id="c.media_entity_notify">
struct <code class="descname">media_entity_notify</code><a class="headerlink" href="#c.media_entity_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Media Entity Notify</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_entity_notify {
  struct list_head list;
  void *notify_data;
  void (*notify)(struct media_entity *entity, void *notify_data);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>List head</dd>
<dt><code class="docutils literal"><span class="pre">notify_data</span></code></dt>
<dd>Input data to invoke the callback</dd>
<dt><code class="docutils literal"><span class="pre">notify</span></code></dt>
<dd>Callback function pointer</dd>
</dl>
<p><strong>Description</strong></p>
<p>Drivers may register a callback to take action when new entities get
registered with the media device. This handler is intended for creating
links between existing entities and should not create entities and register
them.</p>
<dl class="type">
<dt id="c.media_device_ops">
struct <code class="descname">media_device_ops</code><a class="headerlink" href="#c.media_device_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Media device operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_device_ops {
  int (*link_notify)(struct media_link *link, u32 flags, unsigned int notification);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">link_notify</span></code></dt>
<dd>Link state change notification callback. This callback is
called with the graph_mutex held.</dd>
</dl>
<dl class="type">
<dt id="c.media_device">
struct <code class="descname">media_device</code><a class="headerlink" href="#c.media_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Media device</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_device {
  struct device *dev;
  struct media_devnode *devnode;
  char model[32];
  char driver_name[32];
  char serial[40];
  char bus_info[32];
  u32 hw_revision;
  u64 topology_version;
  u32 id;
  struct ida entity_internal_idx;
  int entity_internal_idx_max;
  struct list_head entities;
  struct list_head interfaces;
  struct list_head pads;
  struct list_head links;
  struct list_head entity_notify;
  struct mutex graph_mutex;
  struct media_graph pm_count_walk;
  void *source_priv;
  int (*enable_source)(struct media_entity *entity, struct media_pipeline *pipe);
  void (*disable_source)(struct media_entity *entity);
  const struct media_device_ops *ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>Parent device</dd>
<dt><code class="docutils literal"><span class="pre">devnode</span></code></dt>
<dd>Media device node</dd>
<dt><code class="docutils literal"><span class="pre">model</span></code></dt>
<dd>Device model name</dd>
<dt><code class="docutils literal"><span class="pre">driver_name</span></code></dt>
<dd>Optional device driver name. If not set, calls to
<code class="docutils literal"><span class="pre">MEDIA_IOC_DEVICE_INFO</span></code> will return <code class="docutils literal"><span class="pre">dev-&gt;driver-&gt;name</span></code>.
This is needed for USB drivers for example, as otherwise
they&#8217;ll all appear as if the driver name was &#8220;usb&#8221;.</dd>
<dt><code class="docutils literal"><span class="pre">serial</span></code></dt>
<dd>Device serial number (optional)</dd>
<dt><code class="docutils literal"><span class="pre">bus_info</span></code></dt>
<dd>Unique and stable device location identifier</dd>
<dt><code class="docutils literal"><span class="pre">hw_revision</span></code></dt>
<dd>Hardware device revision</dd>
<dt><code class="docutils literal"><span class="pre">topology_version</span></code></dt>
<dd>Monotonic counter for storing the version of the graph
topology. Should be incremented each time the topology changes.</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>Unique ID used on the last registered graph object</dd>
<dt><code class="docutils literal"><span class="pre">entity_internal_idx</span></code></dt>
<dd>Unique internal entity ID used by the graph traversal
algorithms</dd>
<dt><code class="docutils literal"><span class="pre">entity_internal_idx_max</span></code></dt>
<dd>Allocated internal entity indices</dd>
<dt><code class="docutils literal"><span class="pre">entities</span></code></dt>
<dd>List of registered entities</dd>
<dt><code class="docutils literal"><span class="pre">interfaces</span></code></dt>
<dd>List of registered interfaces</dd>
<dt><code class="docutils literal"><span class="pre">pads</span></code></dt>
<dd>List of registered pads</dd>
<dt><code class="docutils literal"><span class="pre">links</span></code></dt>
<dd>List of registered links</dd>
<dt><code class="docutils literal"><span class="pre">entity_notify</span></code></dt>
<dd>List of registered entity_notify callbacks</dd>
<dt><code class="docutils literal"><span class="pre">graph_mutex</span></code></dt>
<dd>Protects access to struct media_device data</dd>
<dt><code class="docutils literal"><span class="pre">pm_count_walk</span></code></dt>
<dd>Graph walk for power state walk. Access serialised using
graph_mutex.</dd>
<dt><code class="docutils literal"><span class="pre">source_priv</span></code></dt>
<dd>Driver Private data for enable/disable source handlers</dd>
<dt><code class="docutils literal"><span class="pre">enable_source</span></code></dt>
<dd>Enable Source Handler function pointer</dd>
<dt><code class="docutils literal"><span class="pre">disable_source</span></code></dt>
<dd>Disable Source Handler function pointer</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>Operation handler callbacks</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents an abstract high-level media device. It allows easy
access to entities and provides basic media device-level support. The
structure can be allocated directly or embedded in a larger structure.</p>
<p>The parent <strong>dev</strong> is a physical device. It must be set before registering the
media device.</p>
<p><strong>model</strong> is a descriptive model name exported through sysfs. It doesn&#8217;t have to
be unique.</p>
<p><strong>enable_source</strong> is a handler to find source entity for the
sink entity  and activate the link between them if source
entity is free. Drivers should call this handler before
accessing the source.</p>
<p><strong>disable_source</strong> is a handler to find source entity for the
sink entity  and deactivate the link between them. Drivers
should call this handler to release the source.</p>
<p>Use-case: find tuner entity connected to the decoder
entity and check if it is available, and activate the
the link between them from <strong>enable_source</strong> and deactivate
from <strong>disable_source</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Bridge driver is expected to implement and set the
handler when <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> is registered or when
bridge driver finds the media_device during probe.
Bridge driver sets source_priv with information
necessary to run <strong>enable_source</strong> and <strong>disable_source</strong> handlers.
Callers should hold graph_mutex to access and call <strong>enable_source</strong>
and <strong>disable_source</strong> handlers.</p>
</div>
<dl class="function">
<dt id="c.media_entity_enum_init">
int <code class="descname">media_entity_enum_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em>, struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise an entity enumeration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration to be initialised</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>The related media device</dd>
</dl>
<p><strong>Return</strong></p>
<p>zero on success or a negative error code.</p>
<dl class="function">
<dt id="c.media_device_init">
void <code class="descname">media_device_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function initializes the media device prior to its registration.
The media device initialization and registration is split in two functions
to avoid race conditions and make the media device available to user-space
before the media graph has been completed.</p>
<p>So drivers need to first initialize the media device, register any entity
within the media device, create pad to pad links and then finally register
the media device by calling <a class="reference internal" href="#c.media_device_register" title="media_device_register"><code class="xref c c-func docutils literal"><span class="pre">media_device_register()</span></code></a> as a final step.</p>
<dl class="function">
<dt id="c.media_device_cleanup">
void <code class="descname">media_device_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleanups a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function that will destroy the graph_mutex that is
initialized in <a class="reference internal" href="#c.media_device_init" title="media_device_init"><code class="xref c c-func docutils literal"><span class="pre">media_device_init()</span></code></a>.</p>
<dl class="function">
<dt id="c.__media_device_register">
int <code class="descname">__media_device_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>should be filled with <code class="docutils literal"><span class="pre">THIS_MODULE</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>Users, should, instead, call the <a class="reference internal" href="#c.media_device_register" title="media_device_register"><code class="xref c c-func docutils literal"><span class="pre">media_device_register()</span></code></a> macro.</p>
<p>The caller is responsible for initializing the <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> structure
before registration. The following fields of <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> must be set:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity.dev</span></code></a> must point to the parent device (usually a <code class="xref c c-type docutils literal"><span class="pre">pci_dev</span></code>,
<a class="reference internal" href="../../driver-api/usb/usb.html#c.usb_interface" title="usb_interface"><code class="xref c c-type docutils literal"><span class="pre">usb_interface</span></code></a> or <code class="xref c c-type docutils literal"><span class="pre">platform_device</span></code> instance).</li>
<li><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity.model</span></code></a> must be filled with the device model name as a
NUL-terminated UTF-8 string. The device/model revision must not be
stored in this field.</li>
</ul>
</div></blockquote>
<p>The following fields are optional:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity.serial</span></code></a> is a unique serial number stored as a
NUL-terminated ASCII string. The field is big enough to store a GUID
in text form. If the hardware doesn&#8217;t provide a unique serial number
this field must be left empty.</li>
<li><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity.bus_info</span></code></a> represents the location of the device in the
system as a NUL-terminated ASCII string. For PCI/PCIe devices
<a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity.bus_info</span></code></a> must be set to &#8220;PCI:&#8221; (or &#8220;PCIe:&#8221;) followed by
the value of <code class="xref c c-func docutils literal"><span class="pre">pci_name()</span></code>. For USB devices,the <a class="reference internal" href="../../driver-api/usb/usb.html#c.usb_make_path" title="usb_make_path"><code class="xref c c-func docutils literal"><span class="pre">usb_make_path()</span></code></a> function
must be used. This field is used by applications to distinguish between
otherwise identical devices that don&#8217;t provide a serial number.</li>
<li><a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity.hw_revision</span></code></a> is the hardware device revision in a
driver-specific format. When possible the revision should be formatted
with the <code class="xref c c-func docutils literal"><span class="pre">KERNEL_VERSION()</span></code> macro.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>Upon successful registration a character device named media[0-9]+ is created. The device major and minor numbers are dynamic. The model name is exported as a sysfs attribute.</li>
<li>Unregistering a media device that hasn&#8217;t been registered is <strong>NOT</strong> safe.</li>
</ol>
</div>
<p><strong>Return</strong></p>
<p>returns zero on success or a negative error code.</p>
<dl class="function">
<dt id="c.media_device_register">
<code class="descname">media_device_register</code><span class="sig-paren">(</span><em>mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_register" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro calls <a class="reference internal" href="#c.__media_device_register" title="__media_device_register"><code class="xref c c-func docutils literal"><span class="pre">__media_device_register()</span></code></a> passing <code class="docutils literal"><span class="pre">THIS_MODULE</span></code> as
the <a class="reference internal" href="#c.__media_device_register" title="__media_device_register"><code class="xref c c-func docutils literal"><span class="pre">__media_device_register()</span></code></a> second argument (<strong>owner</strong>).</p>
<dl class="function">
<dt id="c.media_device_unregister">
void <code class="descname">media_device_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a media device element</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>It is safe to call this function on an unregistered (but initialised)
media device.</p>
<dl class="function">
<dt id="c.media_device_register_entity">
int <code class="descname">media_device_register_entity</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_register_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>registers a media entity inside a previously registered media device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> to be registered</dd>
</dl>
<p><strong>Description</strong></p>
<p>Entities are identified by a unique positive integer ID. The media
controller framework will such ID automatically. IDs are not guaranteed
to be contiguous, and the ID number can change on newer Kernel versions.
So, neither the driver nor userspace should hardcode ID numbers to refer
to the entities, but, instead, use the framework to find the ID, when
needed.</p>
<p>The media_entity name, type and flags fields should be initialized before
calling <a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal"><span class="pre">media_device_register_entity()</span></code></a>. Entities embedded in higher-level
standard structures can have some of those fields set by the higher-level
framework.</p>
<p>If the device has pads, <a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal"><span class="pre">media_entity_pads_init()</span></code></a> should be called before
this function. Otherwise, the <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity.pad</span></code></a> and <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity.num_pads</span></code></a>
should be zeroed before calling this function.</p>
<p>Entities have flags that describe the entity capabilities and state:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MEDIA_ENT_FL_DEFAULT</span></code></dt>
<dd>indicates the default entity for a given type.
This can be used to report the default audio and video devices or the
default camera sensor.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Drivers should set the entity function before calling this function.
Please notice that the values <code class="docutils literal"><span class="pre">MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN</span></code> and
<code class="docutils literal"><span class="pre">MEDIA_ENT_F_UNKNOWN</span></code> should not be used by the drivers.</p>
</div>
<dl class="function">
<dt id="c.media_device_unregister_entity">
void <code class="descname">media_device_unregister_entity</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_unregister_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>unregisters a media entity.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> to be unregistered</dd>
</dl>
<p><strong>Description</strong></p>
<p>All links associated with the entity and all PADs are automatically
unregistered from the media_device when this function is called.</p>
<p>Unregistering an entity will not change the IDs of the other entities and
the previoully used ID will never be reused for a newly registered entities.</p>
<p>When a media device is unregistered, all its entities are unregistered
automatically. No manual entities unregistration is then required.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The media_entity instance itself must be freed explicitly by
the driver if required.</p>
</div>
<dl class="function">
<dt id="c.media_device_register_entity_notify">
int <code class="descname">media_device_register_entity_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, struct <a class="reference internal" href="#c.media_entity_notify" title="media_entity_notify">media_entity_notify</a> *<em>&nbsp;nptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_register_entity_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a media entity_notify callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>The media device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_notify</span> <span class="pre">*</span> <span class="pre">nptr</span></code></dt>
<dd>The media_entity_notify</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When a new entity is registered, all the registered
media_entity_notify callbacks are invoked.</p>
</div>
<dl class="function">
<dt id="c.media_device_unregister_entity_notify">
void <code class="descname">media_device_unregister_entity_notify</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, struct <a class="reference internal" href="#c.media_entity_notify" title="media_entity_notify">media_entity_notify</a> *<em>&nbsp;nptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_unregister_entity_notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregister a media entity notify callback</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>The media device</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_notify</span> <span class="pre">*</span> <span class="pre">nptr</span></code></dt>
<dd>The media_entity_notify</dd>
</dl>
<dl class="function">
<dt id="c.media_device_pci_init">
void <code class="descname">media_device_pci_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, struct pci_dev *<em>&nbsp;pci_dev</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_pci_init" title="Permalink to this definition">¶</a></dt>
<dd><p>create and initialize a struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> from a PCI device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">pci_dev</span> <span class="pre">*</span> <span class="pre">pci_dev</span></code></dt>
<dd>pointer to struct pci_dev</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">name</span></code></dt>
<dd>media device name. If <code class="docutils literal"><span class="pre">NULL</span></code>, the routine will use the default
name for the pci device, given by <code class="xref c c-func docutils literal"><span class="pre">pci_name()</span></code> macro.</dd>
</dl>
<dl class="function">
<dt id="c.__media_device_usb_init">
void <code class="descname">__media_device_usb_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, struct <a class="reference internal" href="../../driver-api/usb/usb.html#c.usb_device" title="usb_device">usb_device</a> *<em>&nbsp;udev</em>, const char *<em>&nbsp;board_name</em>, const char *<em>&nbsp;driver_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_device_usb_init" title="Permalink to this definition">¶</a></dt>
<dd><p>create and initialize a struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> from a PCI device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">usb_device</span> <span class="pre">*</span> <span class="pre">udev</span></code></dt>
<dd>pointer to struct usb_device</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">board_name</span></code></dt>
<dd>media device name. If <code class="docutils literal"><span class="pre">NULL</span></code>, the routine will use the usb
product name, if available.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">driver_name</span></code></dt>
<dd>name of the driver. if <code class="docutils literal"><span class="pre">NULL</span></code>, the routine will use the name
given by <code class="docutils literal"><span class="pre">udev-&gt;dev-&gt;driver-&gt;name</span></code>, with is usually the wrong
thing to do.</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is better to call <a class="reference internal" href="#c.media_device_usb_init" title="media_device_usb_init"><code class="xref c c-func docutils literal"><span class="pre">media_device_usb_init()</span></code></a> instead, as
such macro fills driver_name with <code class="docutils literal"><span class="pre">KBUILD_MODNAME</span></code>.</p>
</div>
<dl class="function">
<dt id="c.media_device_usb_init">
<code class="descname">media_device_usb_init</code><span class="sig-paren">(</span><em>mdev</em>, <em>udev</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_device_usb_init" title="Permalink to this definition">¶</a></dt>
<dd><p>create and initialize a struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> from a PCI device.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">udev</span></code></dt>
<dd>pointer to struct usb_device</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>media device name. If <code class="docutils literal"><span class="pre">NULL</span></code>, the routine will use the usb
product name, if available.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This macro calls <a class="reference internal" href="#c.media_device_usb_init" title="media_device_usb_init"><code class="xref c c-func docutils literal"><span class="pre">media_device_usb_init()</span></code></a> passing the
<a class="reference internal" href="#c.media_device_usb_init" title="media_device_usb_init"><code class="xref c c-func docutils literal"><span class="pre">media_device_usb_init()</span></code></a> <strong>driver_name</strong> parameter filled with
<code class="docutils literal"><span class="pre">KBUILD_MODNAME</span></code>.</p>
<dl class="type">
<dt id="c.media_file_operations">
struct <code class="descname">media_file_operations</code><a class="headerlink" href="#c.media_file_operations" title="Permalink to this definition">¶</a></dt>
<dd><p>Media device file operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_file_operations {
  struct module *owner;
  ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
  ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
  __poll_t (*poll) (struct file *, struct poll_table_struct *);
  long (*ioctl) (struct file *, unsigned int, unsigned long);
  long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
  int (*open) (struct file *);
  int (*release) (struct file *);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>should be filled with <code class="docutils literal"><span class="pre">THIS_MODULE</span></code></dd>
<dt><code class="docutils literal"><span class="pre">read</span></code></dt>
<dd>pointer to the function that implements <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> syscall</dd>
<dt><code class="docutils literal"><span class="pre">write</span></code></dt>
<dd>pointer to the function that implements <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> syscall</dd>
<dt><code class="docutils literal"><span class="pre">poll</span></code></dt>
<dd>pointer to the function that implements <code class="xref c c-func docutils literal"><span class="pre">poll()</span></code> syscall</dd>
<dt><code class="docutils literal"><span class="pre">ioctl</span></code></dt>
<dd>pointer to the function that implements <code class="xref c c-func docutils literal"><span class="pre">ioctl()</span></code> syscall</dd>
<dt><code class="docutils literal"><span class="pre">compat_ioctl</span></code></dt>
<dd>pointer to the function that will handle 32 bits userspace
calls to the the <code class="xref c c-func docutils literal"><span class="pre">ioctl()</span></code> syscall on a Kernel compiled with 64 bits.</dd>
<dt><code class="docutils literal"><span class="pre">open</span></code></dt>
<dd>pointer to the function that implements <a class="reference internal" href="../uapi/dvb/video-fopen.html#c.open" title="open"><code class="xref c c-func docutils literal"><span class="pre">open()</span></code></a> syscall</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>pointer to the function that will release the resources allocated
by the <strong>open</strong> function.</dd>
</dl>
<dl class="type">
<dt id="c.media_devnode">
struct <code class="descname">media_devnode</code><a class="headerlink" href="#c.media_devnode" title="Permalink to this definition">¶</a></dt>
<dd><p>Media device node</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_devnode {
  struct media_device *media_dev;
  const struct media_file_operations *fops;
  struct device dev;
  struct cdev cdev;
  struct device *parent;
  int minor;
  unsigned long flags;
  void (*release)(struct media_devnode *devnode);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">media_dev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">fops</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_file_operations" title="media_file_operations"><code class="xref c c-type docutils literal"><span class="pre">media_file_operations</span></code></a> with media device ops</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">device</span></code></a> containing the media controller device</dd>
<dt><code class="docutils literal"><span class="pre">cdev</span></code></dt>
<dd>struct cdev pointer character device</dd>
<dt><code class="docutils literal"><span class="pre">parent</span></code></dt>
<dd>parent device</dd>
<dt><code class="docutils literal"><span class="pre">minor</span></code></dt>
<dd>device node minor number</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>flags, combination of the <code class="docutils literal"><span class="pre">MEDIA_FLAG_*</span></code> constants</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>release callback called at the end of <code class="docutils literal"><span class="pre">:c:func:`media_devnode_release()`</span></code>
routine at media-device.c.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This structure represents a media-related device node.</p>
<p>The <strong>parent</strong> is a physical device. It must be set by core or device drivers
before registering the node.</p>
<dl class="function">
<dt id="c.media_devnode_register">
int <code class="descname">media_devnode_register</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, struct <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<em>&nbsp;devnode</em>, struct module *<em>&nbsp;owner</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_register" title="Permalink to this definition">¶</a></dt>
<dd><p>register a media device node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>struct media_device we want to register a device node</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_devnode</span> <span class="pre">*</span> <span class="pre">devnode</span></code></dt>
<dd>media device node structure we want to register</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">module</span> <span class="pre">*</span> <span class="pre">owner</span></code></dt>
<dd>should be filled with <code class="docutils literal"><span class="pre">THIS_MODULE</span></code></dd>
</dl>
<p><strong>Description</strong></p>
<p>The registration code assigns minor numbers and registers the new device node
with the kernel. An error is returned if no free minor number can be found,
or if the registration of the device node fails.</p>
<p>Zero is returned on success.</p>
<p>Note that if the media_devnode_register call fails, the <code class="xref c c-func docutils literal"><span class="pre">release()</span></code> callback of
the media_devnode structure is <em>not</em> called, so the caller is responsible for
freeing any data.</p>
<dl class="function">
<dt id="c.media_devnode_unregister_prepare">
void <code class="descname">media_devnode_unregister_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<em>&nbsp;devnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_unregister_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>clear the media device node register bit</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_devnode</span> <span class="pre">*</span> <span class="pre">devnode</span></code></dt>
<dd>the device node to prepare for unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This clears the passed device register bit. Future open calls will be met
with errors. Should be called before <a class="reference internal" href="#c.media_devnode_unregister" title="media_devnode_unregister"><code class="xref c c-func docutils literal"><span class="pre">media_devnode_unregister()</span></code></a> to avoid
races with unregister and device file open calls.</p>
<p>This function can safely be called if the device node has never been
registered or has already been unregistered.</p>
<dl class="function">
<dt id="c.media_devnode_unregister">
void <code class="descname">media_devnode_unregister</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<em>&nbsp;devnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_unregister" title="Permalink to this definition">¶</a></dt>
<dd><p>unregister a media device node</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_devnode</span> <span class="pre">*</span> <span class="pre">devnode</span></code></dt>
<dd>the device node to unregister</dd>
</dl>
<p><strong>Description</strong></p>
<p>This unregisters the passed device. Future open calls will be met with
errors.</p>
<p>Should be called after <a class="reference internal" href="#c.media_devnode_unregister_prepare" title="media_devnode_unregister_prepare"><code class="xref c c-func docutils literal"><span class="pre">media_devnode_unregister_prepare()</span></code></a></p>
<dl class="function">
<dt id="c.media_devnode_data">
struct <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> * <code class="descname">media_devnode_data</code><span class="sig-paren">(</span>struct file *<em>&nbsp;filp</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_data" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a pointer to the <a class="reference internal" href="#c.media_devnode" title="media_devnode"><code class="xref c c-type docutils literal"><span class="pre">media_devnode</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">filp</span></code></dt>
<dd>pointer to struct <code class="xref c c-type docutils literal"><span class="pre">file</span></code></dd>
</dl>
<dl class="function">
<dt id="c.media_devnode_is_registered">
int <code class="descname">media_devnode_is_registered</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_devnode" title="media_devnode">media_devnode</a> *<em>&nbsp;devnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_is_registered" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if <a class="reference internal" href="#c.media_devnode" title="media_devnode"><code class="xref c c-type docutils literal"><span class="pre">media_devnode</span></code></a> is registered; false otherwise.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_devnode</span> <span class="pre">*</span> <span class="pre">devnode</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_devnode" title="media_devnode"><code class="xref c c-type docutils literal"><span class="pre">media_devnode</span></code></a>.</dd>
</dl>
<p><strong>Note</strong></p>
<p>If mdev is NULL, it also returns false.</p>
<dl class="type">
<dt id="c.media_gobj_type">
enum <code class="descname">media_gobj_type</code><a class="headerlink" href="#c.media_gobj_type" title="Permalink to this definition">¶</a></dt>
<dd><p>type of a graph object</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MEDIA_GRAPH_ENTITY</span></code></dt>
<dd>Identify a media entity</dd>
<dt><code class="docutils literal"><span class="pre">MEDIA_GRAPH_PAD</span></code></dt>
<dd>Identify a media pad</dd>
<dt><code class="docutils literal"><span class="pre">MEDIA_GRAPH_LINK</span></code></dt>
<dd>Identify a media link</dd>
<dt><code class="docutils literal"><span class="pre">MEDIA_GRAPH_INTF_DEVNODE</span></code></dt>
<dd>Identify a media Kernel API interface via
a device node</dd>
</dl>
<dl class="type">
<dt id="c.media_gobj">
struct <code class="descname">media_gobj</code><a class="headerlink" href="#c.media_gobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a graph object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_gobj {
  struct media_device     *mdev;
  u32 id;
  struct list_head        list;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mdev</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> that owns the object</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>Non-zero object ID identifier. The ID should be unique
inside a media_device, as it is composed by
<code class="docutils literal"><span class="pre">MEDIA_BITS_PER_TYPE</span></code> to store the type plus
<code class="docutils literal"><span class="pre">MEDIA_BITS_PER_ID</span></code> to store the ID</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>List entry stored in one of the per-type mdev object lists</dd>
</dl>
<p><strong>Description</strong></p>
<p>All objects on the media graph should have this struct embedded</p>
<dl class="type">
<dt id="c.media_entity_enum">
struct <code class="descname">media_entity_enum</code><a class="headerlink" href="#c.media_entity_enum" title="Permalink to this definition">¶</a></dt>
<dd><p>An enumeration of media entities.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_entity_enum {
  unsigned long *bmap;
  int idx_max;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bmap</span></code></dt>
<dd>Bit map in which each bit represents one entity at struct
media_entity-&gt;internal_idx.</dd>
<dt><code class="docutils literal"><span class="pre">idx_max</span></code></dt>
<dd>Number of bits in bmap</dd>
</dl>
<dl class="type">
<dt id="c.media_graph">
struct <code class="descname">media_graph</code><a class="headerlink" href="#c.media_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Media graph traversal state</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_graph {
  struct {
    struct media_entity *entity;
    struct list_head *link;
  } stack[MEDIA_ENTITY_ENUM_MAX_DEPTH];
  struct media_entity_enum ent_enum;
  int top;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">stack</span></code></dt>
<dd>Graph traversal stack; the stack contains information
on the path the media entities to be walked and the
links through which they were reached.</dd>
<dt><code class="docutils literal"><span class="pre">stack.entity</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span></code></a> at the graph.</dd>
<dt><code class="docutils literal"><span class="pre">stack.link</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">ent_enum</span></code></dt>
<dd>Visited entities</dd>
<dt><code class="docutils literal"><span class="pre">top</span></code></dt>
<dd>The top of the stack</dd>
</dl>
<dl class="type">
<dt id="c.media_pipeline">
struct <code class="descname">media_pipeline</code><a class="headerlink" href="#c.media_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Media pipeline related information</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_pipeline {
  int streaming_count;
  struct media_graph graph;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">streaming_count</span></code></dt>
<dd>Streaming start count - streaming stop count</dd>
<dt><code class="docutils literal"><span class="pre">graph</span></code></dt>
<dd>Media graph walk during pipeline start / stop</dd>
</dl>
<dl class="type">
<dt id="c.media_link">
struct <code class="descname">media_link</code><a class="headerlink" href="#c.media_link" title="Permalink to this definition">¶</a></dt>
<dd><p>A link object part of a media graph.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_link {
  struct media_gobj graph_obj;
  struct list_head list;
  union {
    struct media_gobj *gobj0;
    struct media_pad *source;
    struct media_interface *intf;
  };
  union {
    struct media_gobj *gobj1;
    struct media_pad *sink;
    struct media_entity *entity;
  };
  struct media_link *reverse;
  unsigned long flags;
  bool is_backlink;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">graph_obj</span></code></dt>
<dd>Embedded structure containing the media object common data</dd>
<dt><code class="docutils literal"><span class="pre">list</span></code></dt>
<dd>Linked list associated with an entity or an interface that
owns the link.</dd>
<dt><code class="docutils literal"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal"><span class="pre">gobj0</span></code></dt>
<dd>Part of a union. Used to get the pointer for the first
graph_object of the link.</dd>
<dt><code class="docutils literal"><span class="pre">source</span></code></dt>
<dd>Part of a union. Used only if the first object (gobj0) is
a pad. In that case, it represents the source pad.</dd>
<dt><code class="docutils literal"><span class="pre">intf</span></code></dt>
<dd>Part of a union. Used only if the first object (gobj0) is
an interface.</dd>
<dt><code class="docutils literal"><span class="pre">{unnamed_union}</span></code></dt>
<dd>anonymous</dd>
<dt><code class="docutils literal"><span class="pre">gobj1</span></code></dt>
<dd>Part of a union. Used to get the pointer for the second
graph_object of the link.</dd>
<dt><code class="docutils literal"><span class="pre">sink</span></code></dt>
<dd>Part of a union. Used only if the second object (gobj1) is
a pad. In that case, it represents the sink pad.</dd>
<dt><code class="docutils literal"><span class="pre">entity</span></code></dt>
<dd>Part of a union. Used only if the second object (gobj1) is
an entity.</dd>
<dt><code class="docutils literal"><span class="pre">reverse</span></code></dt>
<dd>Pointer to the link for the reverse direction of a pad to pad
link.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>Link flags, as defined in uapi/media.h (MEDIA_LNK_FL_*)</dd>
<dt><code class="docutils literal"><span class="pre">is_backlink</span></code></dt>
<dd>Indicate if the link is a backlink.</dd>
</dl>
<dl class="type">
<dt id="c.media_pad">
struct <code class="descname">media_pad</code><a class="headerlink" href="#c.media_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>A media pad graph object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_pad {
  struct media_gobj graph_obj;
  struct media_entity *entity;
  u16 index;
  unsigned long flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">graph_obj</span></code></dt>
<dd>Embedded structure containing the media object common data</dd>
<dt><code class="docutils literal"><span class="pre">entity</span></code></dt>
<dd>Entity this pad belongs to</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>Pad index in the entity pads array, numbered from 0 to n</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>Pad flags, as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal"><span class="pre">MEDIA_PAD_FL_*</span></code>)</dd>
</dl>
<dl class="type">
<dt id="c.media_entity_operations">
struct <code class="descname">media_entity_operations</code><a class="headerlink" href="#c.media_entity_operations" title="Permalink to this definition">¶</a></dt>
<dd><p>Media entity operations</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_entity_operations {
  int (*get_fwnode_pad)(struct fwnode_endpoint *endpoint);
  int (*link_setup)(struct media_entity *entity,const struct media_pad *local, const struct media_pad *remote, u32 flags);
  int (*link_validate)(struct media_link *link);
  bool (*has_route)(struct media_entity *entity, unsigned int pad0, unsigned int pad1);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">get_fwnode_pad</span></code></dt>
<dd>Return the pad number based on a fwnode endpoint or
a negative value on error. This operation can be used
to map a fwnode to a media pad number. Optional.</dd>
<dt><code class="docutils literal"><span class="pre">link_setup</span></code></dt>
<dd>Notify the entity of link changes. The operation can
return an error, in which case link setup will be
cancelled. Optional.</dd>
<dt><code class="docutils literal"><span class="pre">link_validate</span></code></dt>
<dd>Return whether a link is valid from the entity point of
view. The <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a> function
validates all links by calling this operation. Optional.</dd>
<dt><code class="docutils literal"><span class="pre">has_route</span></code></dt>
<dd>Return whether a route exists inside the entity between
two given pads. Optional. If the operation isn&#8217;t
implemented all pads will be considered as connected.</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Those these callbacks are called with struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device.graph_mutex</span></code></a>
mutex held.</p>
</div>
<dl class="type">
<dt id="c.media_entity_type">
enum <code class="descname">media_entity_type</code><a class="headerlink" href="#c.media_entity_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Media entity type</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MEDIA_ENTITY_TYPE_BASE</span></code></dt>
<dd>The entity isn&#8217;t embedded in another subsystem structure.</dd>
<dt><code class="docutils literal"><span class="pre">MEDIA_ENTITY_TYPE_VIDEO_DEVICE</span></code></dt>
<dd>The entity is embedded in a struct video_device instance.</dd>
<dt><code class="docutils literal"><span class="pre">MEDIA_ENTITY_TYPE_V4L2_SUBDEV</span></code></dt>
<dd>The entity is embedded in a struct v4l2_subdev instance.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Media entity objects are often not instantiated directly, but the media
entity structure is inherited by (through embedding) other subsystem-specific
structures. The media entity type identifies the type of the subclass
structure that implements a media entity instance.</p>
<p>This allows runtime type identification of media entities and safe casting to
the correct object type. For instance, a media entity structure instance
embedded in a v4l2_subdev structure instance will have the type
<code class="docutils literal"><span class="pre">MEDIA_ENTITY_TYPE_V4L2_SUBDEV</span></code> and can safely be cast to a <a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal"><span class="pre">v4l2_subdev</span></code></a>
structure using the <a class="reference internal" href="../../driver-api/basics.html#c.container_of" title="container_of"><code class="xref c c-func docutils literal"><span class="pre">container_of()</span></code></a> macro.</p>
<dl class="type">
<dt id="c.media_entity">
struct <code class="descname">media_entity</code><a class="headerlink" href="#c.media_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>A media entity graph object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_entity {
  struct media_gobj graph_obj;
  const char *name;
  enum media_entity_type obj_type;
  u32 function;
  unsigned long flags;
  u16 num_pads;
  u16 num_links;
  u16 num_backlinks;
  int internal_idx;
  struct media_pad *pads;
  struct list_head links;
  const struct media_entity_operations *ops;
  int stream_count;
  int use_count;
  struct media_pipeline *pipe;
  union {
    struct {
      u32 major;
      u32 minor;
    } dev;
  } info;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">graph_obj</span></code></dt>
<dd>Embedded structure containing the media object common data.</dd>
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Entity name.</dd>
<dt><code class="docutils literal"><span class="pre">obj_type</span></code></dt>
<dd>Type of the object that implements the media_entity.</dd>
<dt><code class="docutils literal"><span class="pre">function</span></code></dt>
<dd>Entity main function, as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal"><span class="pre">MEDIA_ENT_F_*</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>Entity flags, as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal"><span class="pre">MEDIA_ENT_FL_*</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">num_pads</span></code></dt>
<dd>Number of sink and source pads.</dd>
<dt><code class="docutils literal"><span class="pre">num_links</span></code></dt>
<dd>Total number of links, forward and back, enabled and disabled.</dd>
<dt><code class="docutils literal"><span class="pre">num_backlinks</span></code></dt>
<dd>Number of backlinks</dd>
<dt><code class="docutils literal"><span class="pre">internal_idx</span></code></dt>
<dd>An unique internal entity specific number. The numbers are
re-used if entities are unregistered or registered again.</dd>
<dt><code class="docutils literal"><span class="pre">pads</span></code></dt>
<dd>Pads array with the size defined by <strong>num_pads</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">links</span></code></dt>
<dd>List of data links.</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>Entity operations.</dd>
<dt><code class="docutils literal"><span class="pre">stream_count</span></code></dt>
<dd>Stream count for the entity.</dd>
<dt><code class="docutils literal"><span class="pre">use_count</span></code></dt>
<dd>Use count for the entity.</dd>
<dt><code class="docutils literal"><span class="pre">pipe</span></code></dt>
<dd>Pipeline this entity belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">info</span></code></dt>
<dd>Union with devnode information.  Kept just for backward
compatibility.</dd>
<dt><code class="docutils literal"><span class="pre">info.dev</span></code></dt>
<dd>Contains device major and minor info.</dd>
<dt><code class="docutils literal"><span class="pre">info.dev.major</span></code></dt>
<dd>device node major, if the device is a devnode.</dd>
<dt><code class="docutils literal"><span class="pre">info.dev.minor</span></code></dt>
<dd>device node minor, if the device is a devnode.</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>stream_count</strong> and <strong>use_count</strong> reference counts must never be
negative, but are signed integers on purpose: a simple <code class="docutils literal"><span class="pre">WARN_ON(&lt;0)</span></code>
check can be used to detect reference count bugs that would make them
negative.</p>
</div>
<dl class="type">
<dt id="c.media_interface">
struct <code class="descname">media_interface</code><a class="headerlink" href="#c.media_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>A media interface graph object.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_interface {
  struct media_gobj               graph_obj;
  struct list_head                links;
  u32 type;
  u32 flags;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">graph_obj</span></code></dt>
<dd>embedded graph object</dd>
<dt><code class="docutils literal"><span class="pre">links</span></code></dt>
<dd>List of links pointing to graph entities</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>Type of the interface as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal"><span class="pre">MEDIA_INTF_T_*</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>Interface flags as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal"><span class="pre">MEDIA_INTF_FL_*</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, no flags for <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal"><span class="pre">media_interface</span></code></a> is defined.</p>
</div>
<dl class="type">
<dt id="c.media_intf_devnode">
struct <code class="descname">media_intf_devnode</code><a class="headerlink" href="#c.media_intf_devnode" title="Permalink to this definition">¶</a></dt>
<dd><p>A media interface via a device node.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct media_intf_devnode {
  struct media_interface          intf;
  u32 major;
  u32 minor;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">intf</span></code></dt>
<dd>embedded interface object</dd>
<dt><code class="docutils literal"><span class="pre">major</span></code></dt>
<dd>Major number of a device node</dd>
<dt><code class="docutils literal"><span class="pre">minor</span></code></dt>
<dd>Minor number of a device node</dd>
</dl>
<dl class="function">
<dt id="c.media_entity_id">
u32 <code class="descname">media_entity_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_id" title="Permalink to this definition">¶</a></dt>
<dd><p>return the media entity graph object id</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.media_type">
enum <a class="reference internal" href="#c.media_gobj_type" title="media_gobj_type">media_gobj_type</a> <code class="descname">media_type</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_gobj" title="media_gobj">media_gobj</a> *<em>&nbsp;gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_type" title="Permalink to this definition">¶</a></dt>
<dd><p>return the media object type</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_gobj</span> <span class="pre">*</span> <span class="pre">gobj</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> graph object</dd>
</dl>
<dl class="function">
<dt id="c.media_id">
u32 <code class="descname">media_id</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_gobj" title="media_gobj">media_gobj</a> *<em>&nbsp;gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_id" title="Permalink to this definition">¶</a></dt>
<dd><p>return the media object ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_gobj</span> <span class="pre">*</span> <span class="pre">gobj</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> graph object</dd>
</dl>
<dl class="function">
<dt id="c.media_gobj_gen_id">
u32 <code class="descname">media_gobj_gen_id</code><span class="sig-paren">(</span>enum <a class="reference internal" href="#c.media_gobj_type" title="media_gobj_type">media_gobj_type</a><em>&nbsp;type</em>, u64<em>&nbsp;local_id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_gobj_gen_id" title="Permalink to this definition">¶</a></dt>
<dd><p>encapsulates type and ID on at the object ID</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">media_gobj_type</span> <span class="pre">type</span></code></dt>
<dd>object type as define at enum <a class="reference internal" href="#c.media_gobj_type" title="media_gobj_type"><code class="xref c c-type docutils literal"><span class="pre">media_gobj_type</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">u64</span> <span class="pre">local_id</span></code></dt>
<dd>next ID, from struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device.id</span></code></a>.</dd>
</dl>
<dl class="function">
<dt id="c.is_media_entity_v4l2_video_device">
bool <code class="descname">is_media_entity_v4l2_video_device</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_media_entity_v4l2_video_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the entity is a video_device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>pointer to entity</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if the entity is an instance of a video_device object and can
safely be cast to a struct video_device using the <a class="reference internal" href="../../driver-api/basics.html#c.container_of" title="container_of"><code class="xref c c-func docutils literal"><span class="pre">container_of()</span></code></a> macro, or
<code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.is_media_entity_v4l2_subdev">
bool <code class="descname">is_media_entity_v4l2_subdev</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.is_media_entity_v4l2_subdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the entity is a v4l2_subdev</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>pointer to entity</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if the entity is an instance of a <a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal"><span class="pre">v4l2_subdev</span></code></a> object and can
safely be cast to a struct <a class="reference internal" href="v4l2-subdev.html#c.v4l2_subdev" title="v4l2_subdev"><code class="xref c c-type docutils literal"><span class="pre">v4l2_subdev</span></code></a> using the <a class="reference internal" href="../../driver-api/basics.html#c.container_of" title="container_of"><code class="xref c c-func docutils literal"><span class="pre">container_of()</span></code></a> macro, or
<code class="docutils literal"><span class="pre">false</span></code> otherwise.</p>
<dl class="function">
<dt id="c.__media_entity_enum_init">
int <code class="descname">__media_entity_enum_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em>, int<em>&nbsp;idx_max</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_entity_enum_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise an entity enumeration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration to be initialised</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">idx_max</span></code></dt>
<dd>Maximum number of entities in the enumeration</dd>
</dl>
<p><strong>Return</strong></p>
<p>Returns zero on success or a negative error code.</p>
<dl class="function">
<dt id="c.media_entity_enum_cleanup">
void <code class="descname">media_entity_enum_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources of an entity enumeration</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration to be released</dd>
</dl>
<dl class="function">
<dt id="c.media_entity_enum_zero">
void <code class="descname">media_entity_enum_zero</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the entire enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration to be cleared</dd>
</dl>
<dl class="function">
<dt id="c.media_entity_enum_set">
void <code class="descname">media_entity_enum_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a single entity in the enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Entity to be marked</dd>
</dl>
<dl class="function">
<dt id="c.media_entity_enum_clear">
void <code class="descname">media_entity_enum_clear</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Unmark a single entity in the enum</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Entity to be unmarked</dd>
</dl>
<dl class="function">
<dt id="c.media_entity_enum_test">
bool <code class="descname">media_entity_enum_test</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the entity is marked</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Entity to be tested</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal"><span class="pre">true</span></code> if the entity was marked.</p>
<dl class="function">
<dt id="c.media_entity_enum_test_and_set">
bool <code class="descname">media_entity_enum_test_and_set</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_test_and_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the entity is marked, and mark it</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Entity to be tested</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns <code class="docutils literal"><span class="pre">true</span></code> if the entity was marked, and mark it before doing so.</p>
<dl class="function">
<dt id="c.media_entity_enum_empty">
bool <code class="descname">media_entity_enum_empty</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the entire enum is empty</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum</span></code></dt>
<dd>Entity enumeration</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if the entity was empty.</p>
<dl class="function">
<dt id="c.media_entity_enum_intersects">
bool <code class="descname">media_entity_enum_intersects</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum1</em>, struct <a class="reference internal" href="#c.media_entity_enum" title="media_entity_enum">media_entity_enum</a> *<em>&nbsp;ent_enum2</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_enum_intersects" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether two enums intersect</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum1</span></code></dt>
<dd>First entity enumeration</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity_enum</span> <span class="pre">*</span> <span class="pre">ent_enum2</span></code></dt>
<dd>Second entity enumeration</dd>
</dl>
<p><strong>Return</strong></p>
<p><code class="docutils literal"><span class="pre">true</span></code> if entity enumerations <strong>ent_enum1</strong> and <strong>ent_enum2</strong> intersect,
otherwise <code class="docutils literal"><span class="pre">false</span></code>.</p>
<dl class="function">
<dt id="c.gobj_to_entity">
<code class="descname">gobj_to_entity</code><span class="sig-paren">(</span><em>gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gobj_to_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the struct <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> pointer from the <strong>gobj</strong> contained on it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gobj</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> graph object</dd>
</dl>
<dl class="function">
<dt id="c.gobj_to_pad">
<code class="descname">gobj_to_pad</code><span class="sig-paren">(</span><em>gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gobj_to_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the struct <a class="reference internal" href="#c.media_pad" title="media_pad"><code class="xref c c-type docutils literal"><span class="pre">media_pad</span></code></a> pointer from the <strong>gobj</strong> contained on it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gobj</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> graph object</dd>
</dl>
<dl class="function">
<dt id="c.gobj_to_link">
<code class="descname">gobj_to_link</code><span class="sig-paren">(</span><em>gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gobj_to_link" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the struct <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal"><span class="pre">media_link</span></code></a> pointer from the <strong>gobj</strong> contained on it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gobj</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> graph object</dd>
</dl>
<dl class="function">
<dt id="c.gobj_to_intf">
<code class="descname">gobj_to_intf</code><span class="sig-paren">(</span><em>gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.gobj_to_intf" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the struct <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal"><span class="pre">media_interface</span></code></a> pointer from the <strong>gobj</strong> contained on it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">gobj</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> graph object</dd>
</dl>
<dl class="function">
<dt id="c.intf_to_devnode">
<code class="descname">intf_to_devnode</code><span class="sig-paren">(</span><em>intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.intf_to_devnode" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the struct media_intf_devnode pointer from the <strong>intf</strong> contained on it.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">intf</span></code></dt>
<dd>Pointer to struct <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-type docutils literal"><span class="pre">media_intf_devnode</span></code></a></dd>
</dl>
<dl class="function">
<dt id="c.media_gobj_create">
void <code class="descname">media_gobj_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, enum <a class="reference internal" href="#c.media_gobj_type" title="media_gobj_type">media_gobj_type</a><em>&nbsp;type</em>, struct <a class="reference internal" href="#c.media_gobj" title="media_gobj">media_gobj</a> *<em>&nbsp;gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_gobj_create" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a graph object</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>Pointer to the <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> that contains the object</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">media_gobj_type</span> <span class="pre">type</span></code></dt>
<dd>Type of the object</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_gobj</span> <span class="pre">*</span> <span class="pre">gobj</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> graph object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This routine initializes the embedded struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> inside a
media graph object. It is called automatically if <code class="docutils literal"><span class="pre">media_*_create</span></code>
function calls are used. However, if the object (entity, link, pad,
interface) is embedded on some other object, this function should be
called before registering the object at the media controller.</p>
<dl class="function">
<dt id="c.media_gobj_destroy">
void <code class="descname">media_gobj_destroy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_gobj" title="media_gobj">media_gobj</a> *<em>&nbsp;gobj</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_gobj_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop using a graph object on a media device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_gobj</span> <span class="pre">*</span> <span class="pre">gobj</span></code></dt>
<dd>Pointer to the struct <a class="reference internal" href="#c.media_gobj" title="media_gobj"><code class="xref c c-type docutils literal"><span class="pre">media_gobj</span></code></a> graph object</dd>
</dl>
<p><strong>Description</strong></p>
<p>This should be called by all routines like <a class="reference internal" href="#c.media_device_unregister" title="media_device_unregister"><code class="xref c c-func docutils literal"><span class="pre">media_device_unregister()</span></code></a>
that remove/destroy media graph objects.</p>
<dl class="function">
<dt id="c.media_entity_pads_init">
int <code class="descname">media_entity_pads_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em>, u16<em>&nbsp;num_pads</em>, struct <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<em>&nbsp;pads</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_pads_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the entity pads</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>entity where the pads belong</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">num_pads</span></code></dt>
<dd>total number of sink and source pads</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_pad</span> <span class="pre">*</span> <span class="pre">pads</span></code></dt>
<dd>Array of <strong>num_pads</strong> pads.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The pads array is managed by the entity driver and passed to
<a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal"><span class="pre">media_entity_pads_init()</span></code></a> where its pointer will be stored in the
<a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> structure.</p>
<p>If no pads are needed, drivers could either directly fill
<a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity-&gt;num_pads</span></code></a> with 0 and <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity-&gt;pads</span></code></a> with <code class="docutils literal"><span class="pre">NULL</span></code> or call
this function that will do the same.</p>
<p>As the number of pads is known in advance, the pads array is not allocated
dynamically but is managed by the entity driver. Most drivers will embed the
pads array in a driver-specific structure, avoiding dynamic allocation.</p>
<p>Drivers must set the direction of every pad in the pads array before calling
<a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal"><span class="pre">media_entity_pads_init()</span></code></a>. The function will initialize the other pads fields.</p>
<dl class="function">
<dt id="c.media_entity_cleanup">
void <code class="descname">media_entity_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>free resources associated with an entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>entity where the pads belong</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function must be called during the cleanup phase after unregistering
the entity (currently, it does nothing).</p>
<dl class="function">
<dt id="c.media_create_pad_link">
int <code class="descname">media_create_pad_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;source</em>, u16<em>&nbsp;source_pad</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;sink</em>, u16<em>&nbsp;sink_pad</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_create_pad_link" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a link between two entities.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">source</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> of the source pad.</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">source_pad</span></code></dt>
<dd>number of the source pad in the pads array</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">sink</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> of the sink pad.</dd>
<dt><code class="docutils literal"><span class="pre">u16</span> <span class="pre">sink_pad</span></code></dt>
<dd>number of the sink pad in the pads array.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Link flags, as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
( seek for <code class="docutils literal"><span class="pre">MEDIA_LNK_FL_*</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Valid values for flags:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code></dt>
<dd>Indicates that the link is enabled and can be used to transfer media data.
When two or more links target a sink pad, only one of them can be
enabled at a time.</dd>
<dt><code class="docutils literal"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code></dt>
<dd>Indicates that the link enabled state can&#8217;t be modified at runtime. If
<code class="docutils literal"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code> is set, then <code class="docutils literal"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code> must also be
set, since an immutable link is always enabled.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Before calling this function, <a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal"><span class="pre">media_entity_pads_init()</span></code></a> and
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal"><span class="pre">media_device_register_entity()</span></code></a> should be called previously for both ends.</p>
</div>
<dl class="function">
<dt id="c.media_create_pad_links">
int <code class="descname">media_create_pad_links</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, const u32<em>&nbsp;source_function</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;source</em>, const u16<em>&nbsp;source_pad</em>, const u32<em>&nbsp;sink_function</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;sink</em>, const u16<em>&nbsp;sink_pad</em>, u32<em>&nbsp;flags</em>, const bool<em>&nbsp;allow_both_undefined</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_create_pad_links" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a link between two entities.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>Pointer to the media_device that contains the object</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">source_function</span></code></dt>
<dd>Function of the source entities. Used only if <strong>source</strong> is
NULL.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">source</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> of the source pad. If NULL, it will use
all entities that matches the <strong>sink_function</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">source_pad</span></code></dt>
<dd>number of the source pad in the pads array</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u32</span> <span class="pre">sink_function</span></code></dt>
<dd>Function of the sink entities. Used only if <strong>sink</strong> is NULL.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">sink</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a> of the sink pad. If NULL, it will use
all entities that matches the <strong>sink_function</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">u16</span> <span class="pre">sink_pad</span></code></dt>
<dd>number of the sink pad in the pads array.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Link flags, as defined in include/uapi/linux/media.h.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">bool</span> <span class="pre">allow_both_undefined</span></code></dt>
<dd>if <code class="docutils literal"><span class="pre">true</span></code>, then both <strong>source</strong> and <strong>sink</strong> can be NULL.
In such case, it will create a crossbar between all entities that
matches <strong>source_function</strong> to all entities that matches <strong>sink_function</strong>.
If <code class="docutils literal"><span class="pre">false</span></code>, it will return 0 and won&#8217;t create any link if both <strong>source</strong>
and <strong>sink</strong> are NULL.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Valid values for flags:</p>
<dl class="docutils">
<dt>A <code class="docutils literal"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code> flag indicates that the link is enabled and can be</dt>
<dd>used to transfer media data. If multiple links are created and this
flag is passed as an argument, only the first created link will have
this flag.</dd>
<dt>A <code class="docutils literal"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code> flag indicates that the link enabled state can&#8217;t</dt>
<dd>be modified at runtime. If <code class="docutils literal"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code> is set, then
<code class="docutils literal"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code> must also be set since an immutable link is
always enabled.</dd>
</dl>
<p>It is common for some devices to have multiple source and/or sink entities
of the same type that should be linked. While <a class="reference internal" href="#c.media_create_pad_link" title="media_create_pad_link"><code class="xref c c-func docutils literal"><span class="pre">media_create_pad_link()</span></code></a>
creates link by link, this function is meant to allow 1:n, n:1 and even
cross-bar (n:n) links.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Before calling this function, <a class="reference internal" href="#c.media_entity_pads_init" title="media_entity_pads_init"><code class="xref c c-func docutils literal"><span class="pre">media_entity_pads_init()</span></code></a> and
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal"><span class="pre">media_device_register_entity()</span></code></a> should be called previously for the
entities to be linked.</p>
</div>
<dl class="function">
<dt id="c.media_entity_remove_links">
void <code class="descname">media_entity_remove_links</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_remove_links" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all links associated with an entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_entity" title="media_entity"><code class="xref c c-type docutils literal"><span class="pre">media_entity</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is called automatically when an entity is unregistered via
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal"><span class="pre">media_device_register_entity()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.__media_entity_setup_link">
int <code class="descname">__media_entity_setup_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<em>&nbsp;link</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_entity_setup_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure a media link without locking</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>The link being configured</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Link configuration flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>The bulk of link setup is handled by the two entities connected through the
link. This function notifies both entities of the link configuration change.</p>
<p>If the link is immutable or if the current and new configuration are
identical, return immediately.</p>
<p>The user is expected to hold link-&gt;source-&gt;parent-&gt;mutex. If not,
<a class="reference internal" href="#c.media_entity_setup_link" title="media_entity_setup_link"><code class="xref c c-func docutils literal"><span class="pre">media_entity_setup_link()</span></code></a> should be used instead.</p>
<dl class="function">
<dt id="c.media_entity_setup_link">
int <code class="descname">media_entity_setup_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<em>&nbsp;link</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_setup_link" title="Permalink to this definition">¶</a></dt>
<dd><p>changes the link flags properties in runtime</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal"><span class="pre">media_link</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>the requested new link flags</dd>
</dl>
<p><strong>Description</strong></p>
<p>The only configurable property is the <code class="docutils literal"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code> link flag
flag to enable/disable a link. Links marked with the
<code class="docutils literal"><span class="pre">MEDIA_LNK_FL_IMMUTABLE</span></code> link flag can not be enabled or disabled.</p>
<p>When a link is enabled or disabled, the media framework calls the
link_setup operation for the two entities at the source and sink of the
link, in that order. If the second link_setup call fails, another
link_setup call is made on the first entity to restore the original link
flags.</p>
<p>Media device drivers can be notified of link setup operations by setting the
<a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device.link_notify</span></code></a> pointer to a callback function. If provided, the
notification callback will be called before enabling and after disabling
links.</p>
<p>Entity drivers must implement the link_setup operation if any of their links
is non-immutable. The operation must either configure the hardware or store
the configuration information to be applied later.</p>
<p>Link configuration must not have any side effect on other links. If an
enabled link at a sink pad prevents another link at the same pad from
being enabled, the link_setup operation must return <code class="docutils literal"><span class="pre">-EBUSY</span></code> and can&#8217;t
implicitly disable the first enabled link.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The valid values of the flags for the link is the same as described
on <a class="reference internal" href="#c.media_create_pad_link" title="media_create_pad_link"><code class="xref c c-func docutils literal"><span class="pre">media_create_pad_link()</span></code></a>, for pad to pad links or the same as described
on <a class="reference internal" href="#c.media_create_intf_link" title="media_create_intf_link"><code class="xref c c-func docutils literal"><span class="pre">media_create_intf_link()</span></code></a>, for interface to entity links.</p>
</div>
<dl class="function">
<dt id="c.media_entity_find_link">
struct <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> * <code class="descname">media_entity_find_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<em>&nbsp;source</em>, struct <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<em>&nbsp;sink</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_find_link" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a link between two pads</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_pad</span> <span class="pre">*</span> <span class="pre">source</span></code></dt>
<dd>Source pad</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_pad</span> <span class="pre">*</span> <span class="pre">sink</span></code></dt>
<dd>Sink pad</dd>
</dl>
<p><strong>Return</strong></p>
<p>returns a pointer to the link between the two entities. If no
such link exists, return <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<dl class="function">
<dt id="c.media_entity_remote_pad">
struct <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> * <code class="descname">media_entity_remote_pad</code><span class="sig-paren">(</span>const struct <a class="reference internal" href="#c.media_pad" title="media_pad">media_pad</a> *<em>&nbsp;pad</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_remote_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the pad at the remote end of a link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">media_pad</span> <span class="pre">*</span> <span class="pre">pad</span></code></dt>
<dd>Pad at the local end of the link</dd>
</dl>
<p><strong>Description</strong></p>
<p>Search for a remote pad connected to the given pad by iterating over all
links originating or terminating at that pad until an enabled link is found.</p>
<p><strong>Return</strong></p>
<p>returns a pointer to the pad at the remote end of the first found
enabled link, or <code class="docutils literal"><span class="pre">NULL</span></code> if no enabled link has been found.</p>
<dl class="function">
<dt id="c.media_entity_get">
struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> * <code class="descname">media_entity_get</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a reference to the parent module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>The entity</dd>
</dl>
<p><strong>Description</strong></p>
<p>Get a reference to the parent media device module.</p>
<p>The function will return immediately if <strong>entity</strong> is <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<p><strong>Return</strong></p>
<p>returns a pointer to the entity on success or <code class="docutils literal"><span class="pre">NULL</span></code> on failure.</p>
<dl class="function">
<dt id="c.media_entity_get_fwnode_pad">
int <code class="descname">media_entity_get_fwnode_pad</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em>, struct fwnode_handle *<em>&nbsp;fwnode</em>, unsigned long<em>&nbsp;direction_flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_get_fwnode_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Get pad number from fwnode</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>The entity</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">fwnode_handle</span> <span class="pre">*</span> <span class="pre">fwnode</span></code></dt>
<dd>Pointer to the fwnode_handle which should be used to find the pad</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">direction_flags</span></code></dt>
<dd>Expected direction of the pad, as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
(seek for <code class="docutils literal"><span class="pre">MEDIA_PAD_FL_*</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function can be used to resolve the media pad number from
a fwnode. This is useful for devices which use more complex
mappings of media pads.</p>
<p>If the entity does not implement the <code class="xref c c-func docutils literal"><span class="pre">get_fwnode_pad()</span></code> operation
then this function searches the entity for the first pad that
matches the <strong>direction_flags</strong>.</p>
<p><strong>Return</strong></p>
<p>returns the pad number on success or a negative error code.</p>
<dl class="function">
<dt id="c.media_graph_walk_init">
int <code class="descname">media_graph_walk_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_graph" title="media_graph">media_graph</a> *<em>&nbsp;graph</em>, struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_graph_walk_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate resources used by graph walk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_graph</span> <span class="pre">*</span> <span class="pre">graph</span></code></dt>
<dd>Media graph structure that will be used to walk the graph</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>Pointer to the <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a> that contains the object</dd>
</dl>
<dl class="function">
<dt id="c.media_graph_walk_cleanup">
void <code class="descname">media_graph_walk_cleanup</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_graph" title="media_graph">media_graph</a> *<em>&nbsp;graph</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_graph_walk_cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Release resources used by graph walk.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_graph</span> <span class="pre">*</span> <span class="pre">graph</span></code></dt>
<dd>Media graph structure that will be used to walk the graph</dd>
</dl>
<dl class="function">
<dt id="c.media_entity_put">
void <code class="descname">media_entity_put</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_put" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the reference to the parent module</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>The entity</dd>
</dl>
<p><strong>Description</strong></p>
<p>Release the reference count acquired by <a class="reference internal" href="#c.media_entity_get" title="media_entity_get"><code class="xref c c-func docutils literal"><span class="pre">media_entity_get()</span></code></a>.</p>
<p>The function will return immediately if <strong>entity</strong> is <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<dl class="function">
<dt id="c.media_graph_walk_start">
void <code class="descname">media_graph_walk_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_graph" title="media_graph">media_graph</a> *<em>&nbsp;graph</em>, struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_graph_walk_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start walking the media graph at a given entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_graph</span> <span class="pre">*</span> <span class="pre">graph</span></code></dt>
<dd>Media graph structure that will be used to walk the graph</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Starting entity</dd>
</dl>
<p><strong>Description</strong></p>
<p>Before using this function, <a class="reference internal" href="#c.media_graph_walk_init" title="media_graph_walk_init"><code class="xref c c-func docutils literal"><span class="pre">media_graph_walk_init()</span></code></a> must be
used to allocate resources used for walking the graph. This
function initializes the graph traversal structure to walk the
entities graph starting at the given entity. The traversal
structure must not be modified by the caller during graph
traversal. After the graph walk, the resources must be released
using <a class="reference internal" href="#c.media_graph_walk_cleanup" title="media_graph_walk_cleanup"><code class="xref c c-func docutils literal"><span class="pre">media_graph_walk_cleanup()</span></code></a>.</p>
<dl class="function">
<dt id="c.media_graph_walk_next">
struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> * <code class="descname">media_graph_walk_next</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_graph" title="media_graph">media_graph</a> *<em>&nbsp;graph</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_graph_walk_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next entity in the graph</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_graph</span> <span class="pre">*</span> <span class="pre">graph</span></code></dt>
<dd>Media graph structure</dd>
</dl>
<p><strong>Description</strong></p>
<p>Perform a depth-first traversal of the given media entities graph.</p>
<p>The graph structure must have been previously initialized with a call to
<a class="reference internal" href="#c.media_graph_walk_start" title="media_graph_walk_start"><code class="xref c c-func docutils literal"><span class="pre">media_graph_walk_start()</span></code></a>.</p>
<p><strong>Return</strong></p>
<p>returns the next entity in the graph or <code class="docutils literal"><span class="pre">NULL</span></code> if the whole graph
have been traversed.</p>
<dl class="function">
<dt id="c.media_pipeline_start">
int <code class="descname">media_pipeline_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em>, struct <a class="reference internal" href="#c.media_pipeline" title="media_pipeline">media_pipeline</a> *<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_pipeline_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Starting entity</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_pipeline</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>Media pipeline to be assigned to all entities in the pipeline.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all entities connected to a given entity through enabled links, either
directly or indirectly, as streaming. The given pipeline object is assigned
to every entity in the pipeline and stored in the media_entity pipe field.</p>
<p>Calls to this function can be nested, in which case the same number of
<a class="reference internal" href="#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_stop()</span></code></a> calls will be required to stop streaming. The
pipeline pointer must be identical for all nested calls to
<a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a>.</p>
<dl class="function">
<dt id="c.__media_pipeline_start">
int <code class="descname">__media_pipeline_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em>, struct <a class="reference internal" href="#c.media_pipeline" title="media_pipeline">media_pipeline</a> *<em>&nbsp;pipe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_pipeline_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Starting entity</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_pipeline</span> <span class="pre">*</span> <span class="pre">pipe</span></code></dt>
<dd>Media pipeline to be assigned to all entities in the pipeline.</dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: This is the non-locking version of <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a></p>
<dl class="function">
<dt id="c.media_pipeline_stop">
void <code class="descname">media_pipeline_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_pipeline_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as not streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Starting entity</dd>
</dl>
<p><strong>Description</strong></p>
<p>Mark all entities connected to a given entity through enabled links, either
directly or indirectly, as not streaming. The media_entity pipe field is
reset to <code class="docutils literal"><span class="pre">NULL</span></code>.</p>
<p>If multiple calls to <a class="reference internal" href="#c.media_pipeline_start" title="media_pipeline_start"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_start()</span></code></a> have been made, the same
number of calls to this function are required to mark the pipeline as not
streaming.</p>
<dl class="function">
<dt id="c.__media_pipeline_stop">
void <code class="descname">__media_pipeline_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_pipeline_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark a pipeline as not streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>Starting entity</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is the non-locking version of <a class="reference internal" href="#c.media_pipeline_stop" title="media_pipeline_stop"><code class="xref c c-func docutils literal"><span class="pre">media_pipeline_stop()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.media_devnode_create">
struct <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode">media_intf_devnode</a> * <code class="descname">media_devnode_create</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_device" title="media_device">media_device</a> *<em>&nbsp;mdev</em>, u32<em>&nbsp;type</em>, u32<em>&nbsp;flags</em>, u32<em>&nbsp;major</em>, u32<em>&nbsp;minor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_create" title="Permalink to this definition">¶</a></dt>
<dd><p>creates and initializes a device node interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_device</span> <span class="pre">*</span> <span class="pre">mdev</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.media_device" title="media_device"><code class="xref c c-type docutils literal"><span class="pre">media_device</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">type</span></code></dt>
<dd>type of the interface, as given by
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
( seek for <code class="docutils literal"><span class="pre">MEDIA_INTF_T_*</span></code>) macros.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Interface flags, as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
( seek for <code class="docutils literal"><span class="pre">MEDIA_INTF_FL_*</span></code>)</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">major</span></code></dt>
<dd>Device node major number.</dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">minor</span></code></dt>
<dd>Device node minor number.</dd>
</dl>
<p><strong>Return</strong></p>
<dl class="docutils">
<dt>if succeeded, returns a pointer to the newly allocated</dt>
<dd><a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-type docutils literal"><span class="pre">media_intf_devnode</span></code></a> pointer.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, no flags for <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal"><span class="pre">media_interface</span></code></a> is defined.</p>
</div>
<dl class="function">
<dt id="c.media_devnode_remove">
void <code class="descname">media_devnode_remove</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode">media_intf_devnode</a> *<em>&nbsp;devnode</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_devnode_remove" title="Permalink to this definition">¶</a></dt>
<dd><p>removes a device node interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_intf_devnode</span> <span class="pre">*</span> <span class="pre">devnode</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_intf_devnode" title="media_intf_devnode"><code class="xref c c-type docutils literal"><span class="pre">media_intf_devnode</span></code></a> to be freed.</dd>
</dl>
<p><strong>Description</strong></p>
<p>When a device node interface is removed, all links to it are automatically
removed.</p>
<dl class="function">
<dt id="c.media_create_intf_link">
<code class="descname">media_create_intf_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_entity" title="media_entity">media_entity</a> *<em>&nbsp;entity</em>, struct <a class="reference internal" href="#c.media_interface" title="media_interface">media_interface</a> *<em>&nbsp;intf</em>, u32<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_create_intf_link" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a link between an entity and an interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_entity</span> <span class="pre">*</span> <span class="pre">entity</span></code></dt>
<dd>pointer to <code class="docutils literal"><span class="pre">media_entity</span></code></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_interface</span> <span class="pre">*</span> <span class="pre">intf</span></code></dt>
<dd>pointer to <code class="docutils literal"><span class="pre">media_interface</span></code></dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">flags</span></code></dt>
<dd>Link flags, as defined in
<a class="reference internal" href="../uapi/mediactl/media-header.html#media-header"><span>include/uapi/linux/media.h</span></a>
( seek for <code class="docutils literal"><span class="pre">MEDIA_LNK_FL_*</span></code>)</dd>
</dl>
<p><strong>Description</strong></p>
<p>Valid values for flags:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">MEDIA_LNK_FL_ENABLED</span></code></dt>
<dd><p class="first">Indicates that the interface is connected to the entity hardware.
That&#8217;s the default value for interfaces. An interface may be disabled if
the hardware is busy due to the usage of some other interface that it is
currently controlling the hardware.</p>
<p class="last">A typical example is an hybrid TV device that handle only one type of
stream on a given time. So, when the digital TV is streaming,
the V4L2 interfaces won&#8217;t be enabled, as such device is not able to
also stream analog TV or radio.</p>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Before calling this function, <a class="reference internal" href="#c.media_devnode_create" title="media_devnode_create"><code class="xref c c-func docutils literal"><span class="pre">media_devnode_create()</span></code></a> should be called for
the interface and <a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal"><span class="pre">media_device_register_entity()</span></code></a> should be called for the
interface that will be part of the link.</p>
</div>
<dl class="function">
<dt id="c.__media_remove_intf_link">
void <code class="descname">__media_remove_intf_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_remove_intf_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a single interface link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal"><span class="pre">media_link</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an unlocked version of <a class="reference internal" href="#c.media_remove_intf_link" title="media_remove_intf_link"><code class="xref c c-func docutils literal"><span class="pre">media_remove_intf_link()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.media_remove_intf_link">
void <code class="descname">media_remove_intf_link</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_link" title="media_link">media_link</a> *<em>&nbsp;link</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_remove_intf_link" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a single interface link</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_link</span> <span class="pre">*</span> <span class="pre">link</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_link" title="media_link"><code class="xref c c-type docutils literal"><span class="pre">media_link</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Prefer to use this one, instead of <a class="reference internal" href="#c.__media_remove_intf_link" title="__media_remove_intf_link"><code class="xref c c-func docutils literal"><span class="pre">__media_remove_intf_link()</span></code></a></p>
</div>
<dl class="function">
<dt id="c.__media_remove_intf_links">
void <code class="descname">__media_remove_intf_links</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_interface" title="media_interface">media_interface</a> *<em>&nbsp;intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.__media_remove_intf_links" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all links associated with an interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_interface</span> <span class="pre">*</span> <span class="pre">intf</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal"><span class="pre">media_interface</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is an unlocked version of <a class="reference internal" href="#c.media_remove_intf_links" title="media_remove_intf_links"><code class="xref c c-func docutils literal"><span class="pre">media_remove_intf_links()</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.media_remove_intf_links">
void <code class="descname">media_remove_intf_links</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.media_interface" title="media_interface">media_interface</a> *<em>&nbsp;intf</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_remove_intf_links" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all links associated with an interface</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">media_interface</span> <span class="pre">*</span> <span class="pre">intf</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.media_interface" title="media_interface"><code class="xref c c-type docutils literal"><span class="pre">media_interface</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>This is called automatically when an entity is unregistered via
<a class="reference internal" href="#c.media_device_register_entity" title="media_device_register_entity"><code class="xref c c-func docutils literal"><span class="pre">media_device_register_entity()</span></code></a> and by <a class="reference internal" href="#c.media_devnode_remove" title="media_devnode_remove"><code class="xref c c-func docutils literal"><span class="pre">media_devnode_remove()</span></code></a>.</li>
<li>Prefer to use this one, instead of <a class="reference internal" href="#c.__media_remove_intf_links" title="__media_remove_intf_links"><code class="xref c c-func docutils literal"><span class="pre">__media_remove_intf_links()</span></code></a>.</li>
</ol>
</div>
<dl class="function">
<dt id="c.media_entity_call">
<code class="descname">media_entity_call</code><span class="sig-paren">(</span><em>entity</em>, <em>operation</em>, <em>args...</em><span class="sig-paren">)</span><a class="headerlink" href="#c.media_entity_call" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls a struct media_entity_operations operation on an entity</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">entity</span></code></dt>
<dd>entity where the <strong>operation</strong> will be called</dd>
<dt><code class="docutils literal"><span class="pre">operation</span></code></dt>
<dd>type of the operation. Should be the name of a member of
struct <a class="reference internal" href="#c.media_entity_operations" title="media_entity_operations"><code class="xref c c-type docutils literal"><span class="pre">media_entity_operations</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">args...</span></code></dt>
<dd>variable arguments</dd>
</dl>
<p><strong>Description</strong></p>
<p>This helper function will check if <strong>operation</strong> is not <code class="docutils literal"><span class="pre">NULL</span></code>. On such case,
it will issue a call to <strong>operation</strong>(<strong>entity</strong>, <strong>args</strong>).</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cec-core.html" class="btn btn-neutral float-right" title="5. CEC Kernel Support" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rc-core.html" class="btn btn-neutral" title="3. Remote Controller devices" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>