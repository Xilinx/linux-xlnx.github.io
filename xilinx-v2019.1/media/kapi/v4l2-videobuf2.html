

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1.14. V4L2 videobuf2 functions and data structures &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/>
        <link rel="up" title="1. Video4Linux devices" href="v4l2-core.html"/>
        <link rel="next" title="1.15. V4L2 clocks" href="v4l2-clocks.html"/>
        <link rel="prev" title="1.13. Videobuf Framework" href="v4l2-videobuf.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html">1.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html#structure-of-a-v4l-driver">1.2. Structure of a V4L driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html#structure-of-the-v4l2-framework">1.3. Structure of the V4L2 framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-dev.html">1.4. Video device&#8217; s internal representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-device.html">1.5. V4L2 device instance</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-fh.html">1.6. V4L2 File handlers</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html">1.7. V4L2 sub-devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#v4l2-sub-device-userspace-api">1.8. V4L2 sub-device userspace API</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#i2c-sub-device-drivers">1.9. I2C sub-device drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#v4l2-sub-device-functions-and-data-structures">1.10. V4L2 sub-device functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-event.html">1.11. V4L2 events</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-controls.html">1.12. V4L2 Controls</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-videobuf.html">1.13. Videobuf Framework</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="">1.14. V4L2 videobuf2 functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-clocks.html">1.15. V4L2 clocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-dv-timings.html">1.16. V4L2 DV Timings functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-flash-led-class.html">1.17. V4L2 flash functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mc.html">1.18. V4L2 Media Controller functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mediabus.html">1.19. V4L2 Media Bus functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mem2mem.html">1.20. V4L2 Memory to Memory functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-async.html">1.21. V4L2 async kAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-fwnode.html">1.22. V4L2 fwnode kAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-rect.html">1.23. V4L2 rect helper functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-tuner.html">1.24. Tuner functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-common.html">1.25. V4L2 common functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-tveeprom.html">1.26. Hauppauge TV EEPROM functions and data structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">4. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
      
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
      
          <li><a href="v4l2-core.html">1. Video4Linux devices</a> &raquo;</li>
      
    <li>1.14. V4L2 videobuf2 functions and data structures</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/media/kapi/v4l2-videobuf2.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="v4l2-videobuf2-functions-and-data-structures">
<span id="vb2-framework"></span><h1>1.14. V4L2 videobuf2 functions and data structures<a class="headerlink" href="#v4l2-videobuf2-functions-and-data-structures" title="Permalink to this headline">¶</a></h1>
<dl class="type">
<dt id="c.vb2_memory">
enum <code class="descname">vb2_memory</code><a class="headerlink" href="#c.vb2_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>type of memory model used to make the buffers visible on userspace.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VB2_MEMORY_UNKNOWN</span></code></dt>
<dd>Buffer status is unknown or it is not used yet on
userspace.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_MEMORY_MMAP</span></code></dt>
<dd>The buffers are allocated by the Kernel and it is
memory mapped via <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> ioctl. This model is
also used when the user is using the buffers via
<code class="xref c c-func docutils literal"><span class="pre">read()</span></code> or <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> system calls.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_MEMORY_USERPTR</span></code></dt>
<dd>The buffers was allocated in userspace and it is
memory mapped via <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> ioctl.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_MEMORY_DMABUF</span></code></dt>
<dd>The buffers are passed to userspace via DMA buffer.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_mem_ops">
struct <code class="descname">vb2_mem_ops</code><a class="headerlink" href="#c.vb2_mem_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>memory handling/memory allocator operations.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct vb2_mem_ops {
  void *(*alloc)(struct device *dev, unsigned long attrs,unsigned long size,enum dma_data_direction dma_dir, gfp_t gfp_flags);
  void (*put)(void *buf_priv);
  struct dma_buf *(*get_dmabuf)(void *buf_priv, unsigned long flags);
  void *(*get_userptr)(struct device *dev, unsigned long vaddr,unsigned long size, enum dma_data_direction dma_dir);
  void (*put_userptr)(void *buf_priv);
  void (*prepare)(void *buf_priv);
  void (*finish)(void *buf_priv);
  void *(*attach_dmabuf)(struct device *dev,struct dma_buf *dbuf,unsigned long size, enum dma_data_direction dma_dir);
  void (*detach_dmabuf)(void *buf_priv);
  int (*map_dmabuf)(void *buf_priv);
  void (*unmap_dmabuf)(void *buf_priv);
  void *(*vaddr)(void *buf_priv);
  void *(*cookie)(void *buf_priv);
  unsigned int    (*num_users)(void *buf_priv);
  int (*mmap)(void *buf_priv, struct vm_area_struct *vma);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">alloc</span></code></dt>
<dd>allocate video memory and, optionally, allocator private data,
return <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure or a pointer to allocator private,
per-buffer data on success; the returned private structure
will then be passed as <strong>buf_priv</strong> argument to other ops in this
structure. Additional gfp_flags to use when allocating the
are also passed to this operation. These flags are from the
gfp_flags field of vb2_queue.</dd>
<dt><code class="docutils literal"><span class="pre">put</span></code></dt>
<dd>inform the allocator that the buffer will no longer be used;
usually will result in the allocator freeing the buffer (if
no other users of this buffer are present); the <strong>buf_priv</strong>
argument is the allocator private per-buffer structure
previously returned from the alloc callback.</dd>
<dt><code class="docutils literal"><span class="pre">get_dmabuf</span></code></dt>
<dd>acquire userspace memory for a hardware operation; used for
DMABUF memory types.</dd>
<dt><code class="docutils literal"><span class="pre">get_userptr</span></code></dt>
<dd>acquire userspace memory for a hardware operation; used for
USERPTR memory types; vaddr is the address passed to the
videobuf layer when queuing a video buffer of USERPTR type;
should return an allocator private per-buffer structure
associated with the buffer on success, <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure;
the returned private structure will then be passed as <strong>buf_priv</strong>
argument to other ops in this structure.</dd>
<dt><code class="docutils literal"><span class="pre">put_userptr</span></code></dt>
<dd>inform the allocator that a USERPTR buffer will no longer
be used.</dd>
<dt><code class="docutils literal"><span class="pre">prepare</span></code></dt>
<dd>called every time the buffer is passed from userspace to the
driver, useful for cache synchronisation, optional.</dd>
<dt><code class="docutils literal"><span class="pre">finish</span></code></dt>
<dd>called every time the buffer is passed back from the driver
to the userspace, also optional.</dd>
<dt><code class="docutils literal"><span class="pre">attach_dmabuf</span></code></dt>
<dd>attach a shared <a class="reference internal" href="../../driver-api/dma-buf.html#c.dma_buf" title="dma_buf"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dma_buf</span></code></a> for a hardware operation;
used for DMABUF memory types; dev is the alloc device
dbuf is the shared dma_buf; returns <code class="xref c c-func docutils literal"><span class="pre">ERR_PTR()</span></code> on failure;
allocator private per-buffer structure on success;
this needs to be used for further accesses to the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">detach_dmabuf</span></code></dt>
<dd>inform the exporter of the buffer that the current DMABUF
buffer is no longer used; the <strong>buf_priv</strong> argument is the
allocator private per-buffer structure previously returned
from the attach_dmabuf callback.</dd>
<dt><code class="docutils literal"><span class="pre">map_dmabuf</span></code></dt>
<dd>request for access to the dmabuf from allocator; the allocator
of dmabuf is informed that this driver is going to use the
dmabuf.</dd>
<dt><code class="docutils literal"><span class="pre">unmap_dmabuf</span></code></dt>
<dd>releases access control to the dmabuf - allocator is notified
that this driver is done using the dmabuf for now.</dd>
<dt><code class="docutils literal"><span class="pre">vaddr</span></code></dt>
<dd>return a kernel virtual address to a given memory buffer
associated with the passed private structure or NULL if no
such mapping exists.</dd>
<dt><code class="docutils literal"><span class="pre">cookie</span></code></dt>
<dd>return allocator specific cookie for a given memory buffer
associated with the passed private structure or NULL if not
available.</dd>
<dt><code class="docutils literal"><span class="pre">num_users</span></code></dt>
<dd>return the current number of users of a memory buffer;
return 1 if the videobuf layer (or actually the driver using
it) is the only user.</dd>
<dt><code class="docutils literal"><span class="pre">mmap</span></code></dt>
<dd>setup a userspace mapping for a given memory buffer under
the provided virtual memory region.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Those operations are used by the videobuf2 core to implement the memory
handling/memory allocators for each type of supported streaming I/O method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>Required ops for USERPTR types: get_userptr, put_userptr.</li>
<li>Required ops for MMAP types: alloc, put, num_users, mmap.</li>
<li>Required ops for read/write access types: alloc, put, num_users, vaddr.</li>
<li>Required ops for DMABUF types: attach_dmabuf, detach_dmabuf,
map_dmabuf, unmap_dmabuf.</li>
</ol>
</div>
<dl class="type">
<dt id="c.vb2_plane">
struct <code class="descname">vb2_plane</code><a class="headerlink" href="#c.vb2_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>plane information.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct vb2_plane {
  void *mem_priv;
  struct dma_buf          *dbuf;
  unsigned int            dbuf_mapped;
  unsigned int            bytesused;
  unsigned int            length;
  unsigned int            min_length;
  union {
    unsigned int    offset;
    unsigned long   userptr;
    int fd;
  } m;
  unsigned int            data_offset;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mem_priv</span></code></dt>
<dd>private data with this plane.</dd>
<dt><code class="docutils literal"><span class="pre">dbuf</span></code></dt>
<dd>dma_buf - shared buffer object.</dd>
<dt><code class="docutils literal"><span class="pre">dbuf_mapped</span></code></dt>
<dd>flag to show whether dbuf is mapped or not</dd>
<dt><code class="docutils literal"><span class="pre">bytesused</span></code></dt>
<dd>number of bytes occupied by data in the plane (payload).</dd>
<dt><code class="docutils literal"><span class="pre">length</span></code></dt>
<dd>size of this plane (NOT the payload) in bytes.</dd>
<dt><code class="docutils literal"><span class="pre">min_length</span></code></dt>
<dd>minimum required size of this plane (NOT the payload) in bytes.
<strong>length</strong> is always greater or equal to <strong>min_length</strong>.</dd>
<dt><code class="docutils literal"><span class="pre">m</span></code></dt>
<dd>Union with memtype-specific data.</dd>
<dt><code class="docutils literal"><span class="pre">m.offset</span></code></dt>
<dd>when memory in the associated struct vb2_buffer is
<code class="docutils literal"><span class="pre">VB2_MEMORY_MMAP</span></code>, equals the offset from the start of
the device memory for this plane (or is a &#8220;cookie&#8221; that
should be passed to <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> called on the video node).</dd>
<dt><code class="docutils literal"><span class="pre">m.userptr</span></code></dt>
<dd>when memory is <code class="docutils literal"><span class="pre">VB2_MEMORY_USERPTR</span></code>, a userspace pointer
pointing to this plane.</dd>
<dt><code class="docutils literal"><span class="pre">m.fd</span></code></dt>
<dd>when memory is <code class="docutils literal"><span class="pre">VB2_MEMORY_DMABUF</span></code>, a userspace file
descriptor associated with this plane.</dd>
<dt><code class="docutils literal"><span class="pre">data_offset</span></code></dt>
<dd>offset in the plane to the start of data; usually 0,
unless there is a header in front of the data.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should contain enough information to be able to cover all the fields
of <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_plane" title="v4l2_plane"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_plane</span></code></a> at videodev2.h.</p>
<dl class="type">
<dt id="c.vb2_io_modes">
enum <code class="descname">vb2_io_modes</code><a class="headerlink" href="#c.vb2_io_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>queue access methods.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VB2_MMAP</span></code></dt>
<dd>driver supports MMAP with streaming API.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_USERPTR</span></code></dt>
<dd>driver supports USERPTR with streaming API.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_READ</span></code></dt>
<dd>driver supports <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> style access.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_WRITE</span></code></dt>
<dd>driver supports <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> style access.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_DMABUF</span></code></dt>
<dd>driver supports DMABUF with streaming API.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_buffer_state">
enum <code class="descname">vb2_buffer_state</code><a class="headerlink" href="#c.vb2_buffer_state" title="Permalink to this definition">¶</a></dt>
<dd><p>current video buffer state.</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_DEQUEUED</span></code></dt>
<dd>buffer under userspace control.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_PREPARING</span></code></dt>
<dd>buffer is being prepared in videobuf.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_PREPARED</span></code></dt>
<dd>buffer prepared in videobuf and by the driver.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_QUEUED</span></code></dt>
<dd>buffer queued in videobuf, but not in driver.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_REQUEUEING</span></code></dt>
<dd>re-queue a buffer to the driver.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_ACTIVE</span></code></dt>
<dd>buffer queued in driver and possibly used
in a hardware operation.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_DONE</span></code></dt>
<dd>buffer returned from driver to videobuf, but
not yet dequeued to userspace.</dd>
<dt><code class="docutils literal"><span class="pre">VB2_BUF_STATE_ERROR</span></code></dt>
<dd>same as above, but the operation on the buffer
has ended with an error, which will be reported
to the userspace when it is dequeued.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_buffer">
struct <code class="descname">vb2_buffer</code><a class="headerlink" href="#c.vb2_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>represents a video buffer.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct vb2_buffer {
  struct vb2_queue        *vb2_queue;
  unsigned int            index;
  unsigned int            type;
  unsigned int            memory;
  unsigned int            num_planes;
  u64 timestamp;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vb2_queue</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with the queue to
which this driver belongs.</dd>
<dt><code class="docutils literal"><span class="pre">index</span></code></dt>
<dd>id number of the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>buffer type.</dd>
<dt><code class="docutils literal"><span class="pre">memory</span></code></dt>
<dd>the method, in which the actual data is passed.</dd>
<dt><code class="docutils literal"><span class="pre">num_planes</span></code></dt>
<dd>number of planes in the buffer
on an internal driver queue.</dd>
<dt><code class="docutils literal"><span class="pre">timestamp</span></code></dt>
<dd>frame timestamp in ns.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_ops">
struct <code class="descname">vb2_ops</code><a class="headerlink" href="#c.vb2_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>driver-specific callbacks.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct vb2_ops {
  int (*queue_setup)(struct vb2_queue *q,unsigned int *num_buffers, unsigned int *num_planes, unsigned int sizes[], struct device *alloc_devs[]);
  void (*wait_prepare)(struct vb2_queue *q);
  void (*wait_finish)(struct vb2_queue *q);
  int (*buf_init)(struct vb2_buffer *vb);
  int (*buf_prepare)(struct vb2_buffer *vb);
  void (*buf_finish)(struct vb2_buffer *vb);
  void (*buf_cleanup)(struct vb2_buffer *vb);
  int (*start_streaming)(struct vb2_queue *q, unsigned int count);
  void (*stop_streaming)(struct vb2_queue *q);
  void (*buf_queue)(struct vb2_buffer *vb);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">queue_setup</span></code></dt>
<dd>called from <a class="reference internal" href="../uapi/v4l/vidioc-reqbufs.html#c.VIDIOC_REQBUFS" title="VIDIOC_REQBUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_REQBUFS()</span></code></a> and <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a>
handlers before memory allocation. It can be called
twice: if the original number of requested buffers
could not be allocated, then it will be called a
second time with the actually allocated number of
buffers to verify if that is OK.
The driver should return the required number of buffers
in *num_buffers, the required number of planes per
buffer in *num_planes, the size of each plane should be
set in the sizes[] array and optional per-plane
allocator specific device in the alloc_devs[] array.
When called from <a class="reference internal" href="../uapi/v4l/vidioc-reqbufs.html#c.VIDIOC_REQBUFS" title="VIDIOC_REQBUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_REQBUFS()</span></code></a>, *num_planes == 0,
the driver has to use the currently configured format to
determine the plane sizes and *num_buffers is the total
number of buffers that are being allocated. When called
from <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a>, *num_planes != 0 and it
describes the requested number of planes and sizes[]
contains the requested plane sizes. In this case
*num_buffers are being allocated additionally to
q-&gt;num_buffers. If either *num_planes or the requested
sizes are invalid callback must return <code class="docutils literal"><span class="pre">-EINVAL</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">wait_prepare</span></code></dt>
<dd>release any locks taken while calling vb2 functions;
it is called before an ioctl needs to wait for a new
buffer to arrive; required to avoid a deadlock in
blocking access type.</dd>
<dt><code class="docutils literal"><span class="pre">wait_finish</span></code></dt>
<dd>reacquire all locks released in the previous callback;
required to continue operation after sleeping while
waiting for a new buffer to arrive.</dd>
<dt><code class="docutils literal"><span class="pre">buf_init</span></code></dt>
<dd>called once after allocating a buffer (in MMAP case)
or after acquiring a new USERPTR buffer; drivers may
perform additional buffer-related initialization;
initialization failure (return != 0) will prevent
queue setup from completing successfully; optional.</dd>
<dt><code class="docutils literal"><span class="pre">buf_prepare</span></code></dt>
<dd>called every time the buffer is queued from userspace
and from the <a class="reference internal" href="../uapi/v4l/vidioc-prepare-buf.html#c.VIDIOC_PREPARE_BUF" title="VIDIOC_PREPARE_BUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_PREPARE_BUF()</span></code></a> ioctl; drivers may
perform any initialization required before each
hardware operation in this callback; drivers can
access/modify the buffer here as it is still synced for
the CPU; drivers that support <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a> must
also validate the buffer size; if an error is returned,
the buffer will not be queued in driver; optional.</dd>
<dt><code class="docutils literal"><span class="pre">buf_finish</span></code></dt>
<dd>called before every dequeue of the buffer back to
userspace; the buffer is synced for the CPU, so drivers
can access/modify the buffer contents; drivers may
perform any operations required before userspace
accesses the buffer; optional. The buffer state can be
one of the following: <code class="docutils literal"><span class="pre">DONE</span></code> and <code class="docutils literal"><span class="pre">ERROR</span></code> occur while
streaming is in progress, and the <code class="docutils literal"><span class="pre">PREPARED</span></code> state occurs
when the queue has been canceled and all pending
buffers are being returned to their default <code class="docutils literal"><span class="pre">DEQUEUED</span></code>
state. Typically you only have to do something if the
state is <code class="docutils literal"><span class="pre">VB2_BUF_STATE_DONE</span></code>, since in all other cases
the buffer contents will be ignored anyway.</dd>
<dt><code class="docutils literal"><span class="pre">buf_cleanup</span></code></dt>
<dd>called once before the buffer is freed; drivers may
perform any additional cleanup; optional.</dd>
<dt><code class="docutils literal"><span class="pre">start_streaming</span></code></dt>
<dd>called once to enter &#8216;streaming&#8217; state; the driver may
receive buffers with <strong>buf_queue</strong> callback
before <strong>start_streaming</strong> is called; the driver gets the
number of already queued buffers in count parameter;
driver can return an error if hardware fails, in that
case all buffers that have been already given by
the <strong>buf_queue</strong> callback are to be returned by the driver
by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal"><span class="pre">vb2_buffer_done()</span></code></a> with <code class="docutils literal"><span class="pre">VB2_BUF_STATE_QUEUED</span></code>
or <code class="docutils literal"><span class="pre">VB2_BUF_STATE_REQUEUEING</span></code>. If you need a minimum
number of buffers before you can start streaming, then
set <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue-&gt;min_buffers_needed</span></code></a>. If that is non-zero
then <strong>start_streaming</strong> won&#8217;t be called until at least
that many buffers have been queued up by userspace.</dd>
<dt><code class="docutils literal"><span class="pre">stop_streaming</span></code></dt>
<dd>called when &#8216;streaming&#8217; state must be disabled; driver
should stop any DMA transactions or wait until they
finish and give back all buffers it got from <code class="xref c c-type docutils literal"><span class="pre">buf_queue</span></code>
callback by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal"><span class="pre">vb2_buffer_done()</span></code></a> with either
<code class="docutils literal"><span class="pre">VB2_BUF_STATE_DONE</span></code> or <code class="docutils literal"><span class="pre">VB2_BUF_STATE_ERROR</span></code>; may use
<a class="reference internal" href="#c.vb2_wait_for_all_buffers" title="vb2_wait_for_all_buffers"><code class="xref c c-func docutils literal"><span class="pre">vb2_wait_for_all_buffers()</span></code></a> function</dd>
<dt><code class="docutils literal"><span class="pre">buf_queue</span></code></dt>
<dd>passes buffer vb to the driver; driver may start
hardware operation on this buffer; driver should give
the buffer back by calling <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal"><span class="pre">vb2_buffer_done()</span></code></a> function;
it is allways called after calling <a class="reference internal" href="../uapi/v4l/vidioc-streamon.html#c.VIDIOC_STREAMON" title="VIDIOC_STREAMON"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_STREAMON()</span></code></a>
ioctl; might be called before <strong>start_streaming</strong> callback
if user pre-queued buffers before calling
<a class="reference internal" href="../uapi/v4l/vidioc-streamon.html#c.VIDIOC_STREAMON" title="VIDIOC_STREAMON"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_STREAMON()</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>These operations are not called from interrupt context except where
mentioned specifically.</p>
<dl class="type">
<dt id="c.vb2_buf_ops">
struct <code class="descname">vb2_buf_ops</code><a class="headerlink" href="#c.vb2_buf_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>driver-specific callbacks.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct vb2_buf_ops {
  int (*verify_planes_array)(struct vb2_buffer *vb, const void *pb);
  void (*fill_user_buffer)(struct vb2_buffer *vb, void *pb);
  int (*fill_vb2_buffer)(struct vb2_buffer *vb, const void *pb, struct vb2_plane *planes);
  void (*copy_timestamp)(struct vb2_buffer *vb, const void *pb);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">verify_planes_array</span></code></dt>
<dd>Verify that a given user space structure contains
enough planes for the buffer. This is called
for each dequeued buffer.</dd>
<dt><code class="docutils literal"><span class="pre">fill_user_buffer</span></code></dt>
<dd>given a <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">vb2_buffer</span></code></a> fill in the userspace structure.
For V4L2 this is a <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">fill_vb2_buffer</span></code></dt>
<dd>given a userspace structure, fill in the <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">vb2_buffer</span></code></a>.
If the userspace structure is invalid, then this op
will return an error.</dd>
<dt><code class="docutils literal"><span class="pre">copy_timestamp</span></code></dt>
<dd>copy the timestamp from a userspace structure to
the <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a>.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_queue">
struct <code class="descname">vb2_queue</code><a class="headerlink" href="#c.vb2_queue" title="Permalink to this definition">¶</a></dt>
<dd><p>a videobuf queue.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct vb2_queue {
  unsigned int                    type;
  unsigned int                    io_modes;
  struct device                   *dev;
  unsigned long                   dma_attrs;
  unsigned bidirectional:1;
  unsigned fileio_read_once:1;
  unsigned fileio_write_immediately:1;
  unsigned allow_zero_bytesused:1;
  unsigned quirk_poll_must_check_waiting_for_buffers:1;
  struct mutex                    *lock;
  void *owner;
  const struct vb2_ops            *ops;
  const struct vb2_mem_ops        *mem_ops;
  const struct vb2_buf_ops        *buf_ops;
  void *drv_priv;
  unsigned int                    buf_struct_size;
  u32 timestamp_flags;
  gfp_t gfp_flags;
  u32 min_buffers_needed;
  struct device                   *alloc_devs[VB2_MAX_PLANES];
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">type</span></code></dt>
<dd>private buffer type whose content is defined by the vb2-core
caller. For example, for V4L2, it should match
the types defined on <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">io_modes</span></code></dt>
<dd>supported io methods (see <a class="reference internal" href="#c.vb2_io_modes" title="vb2_io_modes"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">vb2_io_modes</span></code></a>).</dd>
<dt><code class="docutils literal"><span class="pre">dev</span></code></dt>
<dd>device to use for the default allocation context if the driver
doesn&#8217;t fill in the <strong>alloc_devs</strong> array.</dd>
<dt><code class="docutils literal"><span class="pre">dma_attrs</span></code></dt>
<dd>DMA attributes to use for the DMA.</dd>
<dt><code class="docutils literal"><span class="pre">bidirectional</span></code></dt>
<dd>when this flag is set the DMA direction for the buffers of
this queue will be overridden with <code class="docutils literal"><span class="pre">DMA_BIDIRECTIONAL</span></code> direction.
This is useful in cases where the hardware (firmware) writes to
a buffer which is mapped as read (<code class="docutils literal"><span class="pre">DMA_TO_DEVICE</span></code>), or reads from
buffer which is mapped for write (<code class="docutils literal"><span class="pre">DMA_FROM_DEVICE</span></code>) in order
to satisfy some internal hardware restrictions or adds a padding
needed by the processing algorithm. In case the DMA mapping is
not bidirectional but the hardware (firmware) trying to access
the buffer (in the opposite direction) this could lead to an
IOMMU protection faults.</dd>
<dt><code class="docutils literal"><span class="pre">fileio_read_once</span></code></dt>
<dd>report EOF after reading the first buffer</dd>
<dt><code class="docutils literal"><span class="pre">fileio_write_immediately</span></code></dt>
<dd>queue buffer after each <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> call</dd>
<dt><code class="docutils literal"><span class="pre">allow_zero_bytesused</span></code></dt>
<dd>allow bytesused == 0 to be passed to the driver</dd>
<dt><code class="docutils literal"><span class="pre">quirk_poll_must_check_waiting_for_buffers</span></code></dt>
<dd>Return <code class="docutils literal"><span class="pre">EPOLLERR</span></code> at poll when QBUF
has not been called. This is a vb1 idiom that has been adopted
also by vb2.</dd>
<dt><code class="docutils literal"><span class="pre">lock</span></code></dt>
<dd>pointer to a mutex that protects the <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a>. The
driver can set this to a mutex to let the v4l2 core serialize
the queuing ioctls. If the driver wants to handle locking
itself, then this should be set to NULL. This lock is not used
by the videobuf2 core API.</dd>
<dt><code class="docutils literal"><span class="pre">owner</span></code></dt>
<dd>The filehandle that &#8216;owns&#8217; the buffers, i.e. the filehandle
that called reqbufs, create_buffers or started fileio.
This field is not used by the videobuf2 core API, but it allows
drivers to easily associate an owner filehandle with the queue.</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>driver-specific callbacks</dd>
<dt><code class="docutils literal"><span class="pre">mem_ops</span></code></dt>
<dd>memory allocator specific callbacks</dd>
<dt><code class="docutils literal"><span class="pre">buf_ops</span></code></dt>
<dd>callbacks to deliver buffer information.
between user-space and kernel-space.</dd>
<dt><code class="docutils literal"><span class="pre">drv_priv</span></code></dt>
<dd>driver private data.</dd>
<dt><code class="docutils literal"><span class="pre">buf_struct_size</span></code></dt>
<dd>size of the driver-specific buffer structure;
&#8220;0&#8221; indicates the driver doesn&#8217;t want to use a custom buffer
structure type. for example, <code class="docutils literal"><span class="pre">sizeof(struct</span> <span class="pre">vb2_v4l2_buffer)</span></code>
will be used for v4l2.</dd>
<dt><code class="docutils literal"><span class="pre">timestamp_flags</span></code></dt>
<dd>Timestamp flags; <code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_*</span></code> and
<code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TSTAMP_SRC_*</span></code></dd>
<dt><code class="docutils literal"><span class="pre">gfp_flags</span></code></dt>
<dd>additional gfp flags used when allocating the buffers.
Typically this is 0, but it may be e.g. <code class="docutils literal"><span class="pre">GFP_DMA</span></code> or <code class="docutils literal"><span class="pre">__GFP_DMA32</span></code>
to force the buffer allocation to a specific memory zone.</dd>
<dt><code class="docutils literal"><span class="pre">min_buffers_needed</span></code></dt>
<dd>the minimum number of buffers needed before
<strong>start_streaming</strong> can be called. Used when a DMA engine
cannot be started unless at least this number of buffers
have been queued into the driver.</dd>
<dt><code class="docutils literal"><span class="pre">alloc_devs</span></code></dt>
<dd><a class="reference internal" href="../../driver-api/infrastructure.html#c.device" title="device"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code></a> memory type/allocator-specific per-plane device</dd>
</dl>
<dl class="function">
<dt id="c.vb2_plane_vaddr">
void * <code class="descname">vb2_plane_vaddr</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_vaddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a kernel virtual address of a given plane.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which the address is to be returned.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns a kernel virtual address of a given plane if
such a mapping exist, NULL otherwise.</p>
<dl class="function">
<dt id="c.vb2_plane_cookie">
void * <code class="descname">vb2_plane_cookie</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_cookie" title="Permalink to this definition">¶</a></dt>
<dd><p>Return allocator specific cookie for the given plane.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which the cookie is to be returned.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function returns an allocator specific cookie for a given plane if
available, NULL otherwise. The allocator should provide some simple static
inline function, which would convert this cookie to the allocator specific
type that can be used directly by the driver to access the buffer. This can
be for example physical address, pointer to scatter list or IOMMU mapping.</p>
<dl class="function">
<dt id="c.vb2_buffer_done">
void <code class="descname">vb2_buffer_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, enum <a class="reference internal" href="#c.vb2_buffer_state" title="vb2_buffer_state">vb2_buffer_state</a><em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_buffer_done" title="Permalink to this definition">¶</a></dt>
<dd><p>inform videobuf that an operation on a buffer is finished.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to be used.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vb2_buffer_state</span> <span class="pre">state</span></code></dt>
<dd>state of the buffer, as defined by <a class="reference internal" href="#c.vb2_buffer_state" title="vb2_buffer_state"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">vb2_buffer_state</span></code></a>.
Either <code class="docutils literal"><span class="pre">VB2_BUF_STATE_DONE</span></code> if the operation finished
successfully, <code class="docutils literal"><span class="pre">VB2_BUF_STATE_ERROR</span></code> if the operation finished
with an error or any of <code class="docutils literal"><span class="pre">VB2_BUF_STATE_QUEUED</span></code> or
<code class="docutils literal"><span class="pre">VB2_BUF_STATE_REQUEUEING</span></code> if the driver wants to
requeue buffers (see below).</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called by the driver after a hardware operation on
a buffer is finished and the buffer may be returned to userspace. The driver
cannot use this buffer anymore until it is queued back to it by videobuf
by the means of <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> callback. Only buffers previously queued
to the driver by <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> can be passed to this function.</p>
<p>While streaming a buffer can only be returned in state DONE or ERROR.
The <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;start_streaming</span></code></a> op can also return them in case the DMA engine
cannot be started for some reason. In that case the buffers should be
returned with state QUEUED or REQUEUEING to put them back into the queue.</p>
<p><code class="docutils literal"><span class="pre">VB2_BUF_STATE_REQUEUEING</span></code> is like <code class="docutils literal"><span class="pre">VB2_BUF_STATE_QUEUED</span></code>, but it also calls
<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> to queue buffers back to the driver. Note that calling
vb2_buffer_done(..., VB2_BUF_STATE_REQUEUEING) from interrupt context will
result in <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> being called in interrupt context as well.</p>
<dl class="function">
<dt id="c.vb2_discard_done">
void <code class="descname">vb2_discard_done</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_discard_done" title="Permalink to this definition">¶</a></dt>
<dd><p>discard all buffers marked as DONE.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is intended to be used with suspend/resume operations. It
discards all &#8216;done&#8217; buffers as they would be too old to be requested after
resume.</p>
<p>Drivers must stop the hardware and synchronize with interrupt handlers and/or
delayed works before calling this function to make sure no buffer will be
touched by the driver and/or hardware.</p>
<dl class="function">
<dt id="c.vb2_wait_for_all_buffers">
int <code class="descname">vb2_wait_for_all_buffers</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_wait_for_all_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>wait until all buffers are given back to vb2.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function will wait until all buffers that have been given to the driver
by <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> are given back to vb2 with <a class="reference internal" href="#c.vb2_buffer_done" title="vb2_buffer_done"><code class="xref c c-func docutils literal"><span class="pre">vb2_buffer_done()</span></code></a>. It
doesn&#8217;t call <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;wait_prepare</span></code></a>/<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;wait_finish</span></code></a> pair.
It is intended to be called with all locks taken, for example from
<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;stop_streaming</span></code></a> callback.</p>
<dl class="function">
<dt id="c.vb2_core_querybuf">
void <code class="descname">vb2_core_querybuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int<em>&nbsp;index</em>, void *<em>&nbsp;pb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_querybuf" title="Permalink to this definition">¶</a></dt>
<dd><p>query video buffer information.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>id number of the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pb</span></code></dt>
<dd>buffer struct passed from userspace.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <a class="reference internal" href="../uapi/v4l/vidioc-querybuf.html#c.VIDIOC_QUERYBUF" title="VIDIOC_QUERYBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QUERYBUF()</span></code></a> operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>The passed buffer should have been verified.</p>
<p>This function fills the relevant information for the userspace.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_reqbufs">
int <code class="descname">vb2_core_reqbufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em>&nbsp;memory</em>, unsigned int *<em>&nbsp;count</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_reqbufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Initiate streaming.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt>
<dd>memory type, as defined by <a class="reference internal" href="#c.vb2_memory" title="vb2_memory"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">vb2_memory</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">count</span></code></dt>
<dd>requested buffer count.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <code class="xref c c-func docutils literal"><span class="pre">VIDIOC_REQBUF()</span></code> operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies streaming parameters passed from the userspace;</li>
<li>sets up the queue;</li>
<li>negotiates number of buffers and planes per buffer with the driver
to be used during streaming;</li>
<li>allocates internal buffer structures (<a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a>), according to
the agreed parameters;</li>
<li>for MMAP memory type, allocates actual video memory, using the
memory handling/allocation routines provided during queue initialization.</li>
</ol>
<p>If req-&gt;count is 0, all the memory will be freed instead.</p>
<p>If the queue has been allocated previously by a previous <a class="reference internal" href="#c.vb2_core_reqbufs" title="vb2_core_reqbufs"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_reqbufs()</span></code></a>
call and the queue is not busy, memory will be reallocated.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_create_bufs">
int <code class="descname">vb2_core_create_bufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em>&nbsp;memory</em>, unsigned int *<em>&nbsp;count</em>, unsigned int<em>&nbsp;requested_planes</em>, const unsigned int<em>&nbsp;requested_sizes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_create_bufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate buffers and any required auxiliary structs</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt>
<dd>memory type, as defined by <a class="reference internal" href="#c.vb2_memory" title="vb2_memory"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">vb2_memory</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">count</span></code></dt>
<dd>requested buffer count.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">requested_planes</span></code></dt>
<dd>number of planes requested.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">requested_sizes</span></code></dt>
<dd>array with the size of the planes.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a> operation. It is
called internally by VB2 by an API-specific handler, like
<code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies parameter sanity;</li>
<li>calls the <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;queue_setup</span></code></a> queue operation;</li>
<li>performs any necessary memory allocations.</li>
</ol>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_prepare_buf">
int <code class="descname">vb2_core_prepare_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int<em>&nbsp;index</em>, void *<em>&nbsp;pb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_prepare_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass ownership of a buffer from userspace to the kernel.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>id number of the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pb</span></code></dt>
<dd>buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_prepare_buf</span></code></a> handler in driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <a class="reference internal" href="../uapi/v4l/vidioc-prepare-buf.html#c.VIDIOC_PREPARE_BUF" title="VIDIOC_PREPARE_BUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_PREPARE_BUF()</span></code></a> operation. It is
called internally by VB2 by an API-specific handler, like
<code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>The passed buffer should have been verified.</p>
<p>This function calls vb2_ops-&gt;buf_prepare callback in the driver
(if provided), in which driver-specific buffer initialization can
be performed.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_qbuf">
int <code class="descname">vb2_core_qbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int<em>&nbsp;index</em>, void *<em>&nbsp;pb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_qbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a buffer from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>id number of the buffer</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pb</span></code></dt>
<dd>buffer structure passed from userspace to
v4l2_ioctl_ops-&gt;vidioc_qbuf handler in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <a class="reference internal" href="../uapi/v4l/vidioc-qbuf.html#c.VIDIOC_QBUF" title="VIDIOC_QBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QBUF()</span></code></a> operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>if necessary, calls <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_prepare</span></code></a> callback in the driver
(if provided), in which driver-specific buffer initialization can
be performed;</li>
<li>if streaming is on, queues the buffer in driver by the means of
<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> callback for processing.</li>
</ol>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_dqbuf">
int <code class="descname">vb2_core_dqbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int *<em>&nbsp;pindex</em>, void *<em>&nbsp;pb</em>, bool<em>&nbsp;nonblocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_dqbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue a buffer to the userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">pindex</span></code></dt>
<dd>pointer to the buffer index. May be NULL</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">pb</span></code></dt>
<dd>buffer structure passed from userspace to
v4l2_ioctl_ops-&gt;vidioc_dqbuf handler in driver.</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">nonblocking</span></code></dt>
<dd>if true, this call will not sleep waiting for a buffer if no
buffers ready for dequeuing are present. Normally the driver
would be passing (file-&gt;f_flags &amp; O_NONBLOCK) here.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <a class="reference internal" href="../uapi/v4l/vidioc-qbuf.html#c.VIDIOC_DQBUF" title="VIDIOC_DQBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_DQBUF()</span></code></a> operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>calls buf_finish callback in the driver (if provided), in which
driver can perform any additional operations that may be required before
returning the buffer to userspace, such as cache sync,</li>
<li>the buffer struct members are filled with relevant information for
the userspace.</li>
</ol>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_streamon">
int <code class="descname">vb2_core_streamon</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_streamon" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements VB2 stream ON logic</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>type of the queue to be started.
For V4L2, this is defined by <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span></code></a> type.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <a class="reference internal" href="../uapi/v4l/vidioc-streamon.html#c.VIDIOC_STREAMON" title="VIDIOC_STREAMON"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_STREAMON()</span></code></a> operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_streamoff">
int <code class="descname">vb2_core_streamoff</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_streamoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements VB2 stream OFF logic</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>type of the queue to be started.
For V4L2, this is defined by <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span></code></a> type.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <a class="reference internal" href="../uapi/v4l/vidioc-streamon.html#c.VIDIOC_STREAMOFF" title="VIDIOC_STREAMOFF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_STREAMOFF()</span></code></a> operation. It is
called internally by VB2 by an API-specific handler, like
<code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_expbuf">
int <code class="descname">vb2_core_expbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, int *<em>&nbsp;fd</em>, unsigned int<em>&nbsp;type</em>, unsigned int<em>&nbsp;index</em>, unsigned int<em>&nbsp;plane</em>, unsigned int<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_expbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a buffer as a file descriptor.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">*</span> <span class="pre">fd</span></code></dt>
<dd>pointer to the file descriptor associated with DMABUF
(set by driver).</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>buffer type.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">index</span></code></dt>
<dd>id number of the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane</span></code></dt>
<dd>index of the plane to be exported, 0 for single plane queues</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">flags</span></code></dt>
<dd>file flags for newly created file, as defined at
include/uapi/asm-generic/fcntl.h.
Currently, the only used flag is <code class="docutils literal"><span class="pre">O_CLOEXEC</span></code>.
is supported, refer to manual of open syscall for more details.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Videobuf2 core helper to implement <a class="reference internal" href="../uapi/v4l/vidioc-expbuf.html#c.VIDIOC_EXPBUF" title="VIDIOC_EXPBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_EXPBUF()</span></code></a> operation. It is called
internally by VB2 by an API-specific handler, like <code class="docutils literal"><span class="pre">videobuf2-v4l2.h</span></code>.</p>
<p><strong>Return</strong></p>
<p>returns zero on success; an error code otherwise.</p>
<dl class="function">
<dt id="c.vb2_core_queue_init">
int <code class="descname">vb2_core_queue_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_queue_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a videobuf2 queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.
This structure should be allocated in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue</span></code></a> structure should be allocated by the driver. The driver is
responsible of clearing it&#8217;s content and setting initial values for some
required entries before calling this function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following fields at <strong>q</strong> should be set before calling this function:
<a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue-&gt;ops</span></code></a>, <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue-&gt;mem_ops</span></code></a>, <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue-&gt;type</span></code></a>.</p>
</div>
<dl class="function">
<dt id="c.vb2_core_queue_release">
void <code class="descname">vb2_core_queue_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_queue_release" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming, release the queue and free memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stops streaming and performs necessary clean ups, including
freeing video buffer memory. The driver is responsible for freeing
the <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> itself.</p>
<dl class="function">
<dt id="c.vb2_queue_error">
void <code class="descname">vb2_queue_error</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_error" title="Permalink to this definition">¶</a></dt>
<dd><p>signal a fatal error on the queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Flag that a fatal unrecoverable error has occurred and wake up all processes
waiting on the queue. Polling will now set <code class="docutils literal"><span class="pre">EPOLLERR</span></code> and queuing and dequeuing
buffers will return <code class="docutils literal"><span class="pre">-EIO</span></code>.</p>
<p>The error flag will be cleared when canceling the queue, either from
<a class="reference internal" href="#c.vb2_streamoff" title="vb2_streamoff"><code class="xref c c-func docutils literal"><span class="pre">vb2_streamoff()</span></code></a> or <a class="reference internal" href="#c.vb2_queue_release" title="vb2_queue_release"><code class="xref c c-func docutils literal"><span class="pre">vb2_queue_release()</span></code></a>. Drivers should thus not call this
function before starting the stream, otherwise the error flag will remain set
until the queue is released when closing the device node.</p>
<dl class="function">
<dt id="c.vb2_mmap">
int <code class="descname">vb2_mmap</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct vm_area_struct *<em>&nbsp;vma</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_mmap" title="Permalink to this definition">¶</a></dt>
<dd><p>map video buffers into application address space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span> <span class="pre">*</span> <span class="pre">vma</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> with the vma passed
to the mmap file operation handler in the driver.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from mmap file operation handler of a driver.
This function maps one plane of one of the available video buffers to
userspace. To map whole video memory allocated on reqbufs, this function
has to be called once per each plane per each buffer previously allocated.</p>
<p>When the userspace application calls mmap, it passes to it an offset returned
to it earlier by the means of <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_querybuf</span></code></a> handler.
That offset acts as a &#8220;cookie&#8221;, which is then used to identify the plane
to be mapped.</p>
<p>This function finds a plane with a matching offset and a mapping is performed
by the means of a provided memory operation.</p>
<p>The return values from this function are intended to be directly returned
from the mmap handler in driver.</p>
<dl class="function">
<dt id="c.vb2_get_unmapped_area">
unsigned long <code class="descname">vb2_get_unmapped_area</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, unsigned long<em>&nbsp;addr</em>, unsigned long<em>&nbsp;len</em>, unsigned long<em>&nbsp;pgoff</em>, unsigned long<em>&nbsp;flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_unmapped_area" title="Permalink to this definition">¶</a></dt>
<dd><p>map video buffers into application address space.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">addr</span></code></dt>
<dd>memory address.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">len</span></code></dt>
<dd>buffer size.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">pgoff</span></code></dt>
<dd>page offset.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">flags</span></code></dt>
<dd>memory flags.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used in noMMU platforms to propose address mapping
for a given buffer. It&#8217;s intended to be used as a handler for the
<code class="xref c c-type docutils literal"><span class="pre">file_operations-&gt;get_unmapped_area</span></code> operation.</p>
<p>This is called by the <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> syscall routines will call this
to get a proposed address for the mapping, when <code class="docutils literal"><span class="pre">!CONFIG_MMU</span></code>.</p>
<dl class="function">
<dt id="c.vb2_core_poll">
__poll_t <code class="descname">vb2_core_poll</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct file *<em>&nbsp;file</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_core_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>implements poll <code class="xref c c-func docutils literal"><span class="pre">syscall()</span></code> logic.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code> argument passed to the poll
file operation handler.</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd><code class="xref c c-type docutils literal"><span class="pre">poll_table</span></code> wait argument passed to the poll
file operation handler.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements poll file operation handler for a driver.
For CAPTURE queues, if a buffer is ready to be dequeued, the userspace will
be informed that the file descriptor of a video device is available for
reading.
For OUTPUT queues, if a buffer is ready to be dequeued, the file descriptor
will be reported as available for writing.</p>
<p>The return values from this function are intended to be directly returned
from poll handler in driver.</p>
<dl class="function">
<dt id="c.vb2_read">
size_t <code class="descname">vb2_read</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, char __user *<em>&nbsp;data</em>, size_t<em>&nbsp;count</em>, loff_t *<em>&nbsp;ppos</em>, int<em>&nbsp;nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_read" title="Permalink to this definition">¶</a></dt>
<dd><p>implements <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> syscall logic.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointed to target userspace buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to read</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file handle position tracking pointer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nonblock</span></code></dt>
<dd>mode selector (1 means blocking calls, 0 means nonblocking)</dd>
</dl>
<dl class="function">
<dt id="c.vb2_write">
size_t <code class="descname">vb2_write</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, const char __user *<em>&nbsp;data</em>, size_t<em>&nbsp;count</em>, loff_t *<em>&nbsp;ppos</em>, int<em>&nbsp;nonblock</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_write" title="Permalink to this definition">¶</a></dt>
<dd><p>implements <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> syscall logic.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">__user</span> <span class="pre">*</span> <span class="pre">data</span></code></dt>
<dd>pointed to target userspace buffer</dd>
<dt><code class="docutils literal"><span class="pre">size_t</span> <span class="pre">count</span></code></dt>
<dd>number of bytes to write</dd>
<dt><code class="docutils literal"><span class="pre">loff_t</span> <span class="pre">*</span> <span class="pre">ppos</span></code></dt>
<dd>file handle position tracking pointer</dd>
<dt><code class="docutils literal"><span class="pre">int</span> <span class="pre">nonblock</span></code></dt>
<dd>mode selector (1 means blocking calls, 0 means nonblocking)</dd>
</dl>
<dl class="type">
<dt id="c.vb2_thread_fnc">
<code class="descname">vb2_thread_fnc</code><a class="headerlink" href="#c.vb2_thread_fnc" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Typedef</strong>: callback function for use with vb2_thread.</p>
</dd></dl>

<p><strong>Syntax</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">int</span> <span class="pre">vb2_thread_fnc</span> <span class="pre">(struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb,</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv);</span></code></div></blockquote>
<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>pointer to struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">vb2_buffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>pointer to a private data.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is called whenever a buffer is dequeued in the thread.</p>
<dl class="function">
<dt id="c.vb2_thread_start">
int <code class="descname">vb2_thread_start</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, <a class="reference internal" href="#c.vb2_thread_fnc" title="vb2_thread_fnc">vb2_thread_fnc</a><em>&nbsp;fnc</em>, void *<em>&nbsp;priv</em>, const char *<em>&nbsp;thread_name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_thread_start" title="Permalink to this definition">¶</a></dt>
<dd><p>start a thread for the given queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">vb2_thread_fnc</span> <span class="pre">fnc</span></code></dt>
<dd><a class="reference internal" href="#c.vb2_thread_fnc" title="vb2_thread_fnc"><code class="xref c c-type docutils literal"><span class="pre">vb2_thread_fnc</span></code></a> callback function.</dd>
<dt><code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">priv</span></code></dt>
<dd>priv pointer passed to the callback function.</dd>
<dt><code class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">thread_name</span></code></dt>
<dd>the name of the thread. This will be prefixed with &#8220;vb2-&#8221;.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This starts a thread that will queue and dequeue until an error occurs
or <a class="reference internal" href="#c.vb2_thread_stop" title="vb2_thread_stop"><code class="xref c c-func docutils literal"><span class="pre">vb2_thread_stop()</span></code></a> is called.</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">This function should not be used for anything else but the videobuf2-dvb
support. If you think you have another good use-case for this, then please
contact the linux-media mailing list first.</p>
</div>
<dl class="function">
<dt id="c.vb2_thread_stop">
int <code class="descname">vb2_thread_stop</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_thread_stop" title="Permalink to this definition">¶</a></dt>
<dd><p>stop the thread for the given queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_is_streaming">
bool <code class="descname">vb2_is_streaming</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_is_streaming" title="Permalink to this definition">¶</a></dt>
<dd><p>return streaming status of the queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_fileio_is_active">
bool <code class="descname">vb2_fileio_is_active</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_fileio_is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if fileio is active.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This returns true if <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> or <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> is used to stream the data
as opposed to stream I/O. This is almost never an important distinction,
except in rare cases. One such case is that using <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> or <a class="reference internal" href="../uapi/dvb/video-fwrite.html#c.write" title="write"><code class="xref c c-func docutils literal"><span class="pre">write()</span></code></a> to
stream a format using <code class="docutils literal"><span class="pre">V4L2_FIELD_ALTERNATE</span></code> is not allowed since there
is no way you can pass the field information of each buffer to/from
userspace. A driver that supports this field format should check for
this in the <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;queue_setup</span></code></a> op and reject it if this function returns
true.</p>
<dl class="function">
<dt id="c.vb2_is_busy">
bool <code class="descname">vb2_is_busy</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_is_busy" title="Permalink to this definition">¶</a></dt>
<dd><p>return busy status of the queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function checks if queue has any buffers allocated.</p>
<dl class="function">
<dt id="c.vb2_get_drv_priv">
void * <code class="descname">vb2_get_drv_priv</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_drv_priv" title="Permalink to this definition">¶</a></dt>
<dd><p>return driver private data associated with the queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_set_plane_payload">
void <code class="descname">vb2_set_plane_payload</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em>, unsigned long<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_set_plane_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>set bytesused for the plane <strong>plane_no</strong>.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which payload should be set.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">size</span></code></dt>
<dd>payload in bytes.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_get_plane_payload">
unsigned long <code class="descname">vb2_get_plane_payload</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_get_plane_payload" title="Permalink to this definition">¶</a></dt>
<dd><p>get bytesused for the plane plane_no</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which payload should be set.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_plane_size">
unsigned long <code class="descname">vb2_plane_size</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em>, unsigned int<em>&nbsp;plane_no</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_plane_size" title="Permalink to this definition">¶</a></dt>
<dd><p>return plane size in bytes.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span></code></a> to which the plane in
question belongs to.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">plane_no</span></code></dt>
<dd>plane number for which size should be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_start_streaming_called">
bool <code class="descname">vb2_start_streaming_called</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_start_streaming_called" title="Permalink to this definition">¶</a></dt>
<dd><p>return streaming status of driver.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_clear_last_buffer_dequeued">
void <code class="descname">vb2_clear_last_buffer_dequeued</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_clear_last_buffer_dequeued" title="Permalink to this definition">¶</a></dt>
<dd><p>clear last buffer dequeued flag of queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_buffer_in_use">
bool <code class="descname">vb2_buffer_in_use</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer">vb2_buffer</a> *<em>&nbsp;vb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_buffer_in_use" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if the buffer is in use and the queue cannot be freed (by the means of VIDIOC_REQBUFS(0)) call.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_buffer</span> <span class="pre">*</span> <span class="pre">vb</span></code></dt>
<dd>buffer for which plane size should be returned.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_verify_memory_type">
int <code class="descname">vb2_verify_memory_type</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory">vb2_memory</a><em>&nbsp;memory</em>, unsigned int<em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_verify_memory_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the memory type and buffer type passed to a buffer operation are compatible with the queue.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">vb2_memory</span> <span class="pre">memory</span></code></dt>
<dd>memory model, as defined by enum <a class="reference internal" href="#c.vb2_memory" title="vb2_memory"><code class="xref c c-type docutils literal"><span class="pre">vb2_memory</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">type</span></code></dt>
<dd>private buffer type whose content is defined by the vb2-core
caller. For example, for V4L2, it should match
the types defined on enum <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buf_type</span></code></a>.</dd>
</dl>
<dl class="type">
<dt id="c.vb2_v4l2_buffer">
struct <code class="descname">vb2_v4l2_buffer</code><a class="headerlink" href="#c.vb2_v4l2_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>video buffer information for v4l2.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct vb2_v4l2_buffer {
  struct vb2_buffer       vb2_buf;
  __u32 flags;
  __u32 field;
  struct v4l2_timecode    timecode;
  __u32 sequence;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">vb2_buf</span></code></dt>
<dd>embedded struct <a class="reference internal" href="#c.vb2_buffer" title="vb2_buffer"><code class="xref c c-type docutils literal"><span class="pre">vb2_buffer</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">flags</span></code></dt>
<dd>buffer informational flags.</dd>
<dt><code class="docutils literal"><span class="pre">field</span></code></dt>
<dd>field order of the image in the buffer, as defined by
<a class="reference internal" href="../uapi/v4l/field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_field</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">timecode</span></code></dt>
<dd>frame timecode.</dd>
<dt><code class="docutils literal"><span class="pre">sequence</span></code></dt>
<dd>sequence count of this frame.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should contain enough information to be able to cover all the fields
of <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span></code></a> at <code class="docutils literal"><span class="pre">videodev2.h</span></code>.</p>
<dl class="function">
<dt id="c.vb2_reqbufs">
int <code class="descname">vb2_reqbufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/vidioc-reqbufs.html#c.v4l2_requestbuffers" title="v4l2_requestbuffers">v4l2_requestbuffers</a> *<em>&nbsp;req</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_reqbufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#c.vb2_core_reqbufs" title="vb2_core_reqbufs"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_reqbufs()</span></code></a> that also verifies the memory and type values.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_requestbuffers</span> <span class="pre">*</span> <span class="pre">req</span></code></dt>
<dd><a class="reference internal" href="../uapi/v4l/vidioc-reqbufs.html#c.v4l2_requestbuffers" title="v4l2_requestbuffers"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_requestbuffers</span></code></a> passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_reqbufs</span></code></a> handler in driver.</dd>
</dl>
<dl class="function">
<dt id="c.vb2_create_bufs">
int <code class="descname">vb2_create_bufs</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/vidioc-create-bufs.html#c.v4l2_create_buffers" title="v4l2_create_buffers">v4l2_create_buffers</a> *<em>&nbsp;create</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_create_bufs" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for <a class="reference internal" href="#c.vb2_core_create_bufs" title="vb2_core_create_bufs"><code class="xref c c-func docutils literal"><span class="pre">vb2_core_create_bufs()</span></code></a> that also verifies the memory and type values.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_create_buffers</span> <span class="pre">*</span> <span class="pre">create</span></code></dt>
<dd>creation parameters, passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_create_bufs</span></code></a> handler in driver</dd>
</dl>
<dl class="function">
<dt id="c.vb2_prepare_buf">
int <code class="descname">vb2_prepare_buf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buffer" title="v4l2_buffer">v4l2_buffer</a> *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_prepare_buf" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass ownership of a buffer from userspace to the kernel</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_prepare_buf</span></code></a> handler in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_prepare_buf</span></code></a> ioctl handler
of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies the passed buffer,</li>
<li>calls <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_prepare</span></code></a> callback in the driver (if provided),
in which driver-specific buffer initialization can be performed.</li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_prepare_buf</span></code></a> handler in driver.</p>
<dl class="function">
<dt id="c.vb2_qbuf">
int <code class="descname">vb2_qbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buffer" title="v4l2_buffer">v4l2_buffer</a> *<em>&nbsp;b</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_qbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Queue a buffer from userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_qbuf</span></code></a> handler in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_qbuf</span></code></a> handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies the passed buffer;</li>
<li>if necessary, calls <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_prepare</span></code></a> callback in the driver
(if provided), in which driver-specific buffer initialization can
be performed;</li>
<li>if streaming is on, queues the buffer in driver by the means of
<a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_queue</span></code></a> callback for processing.</li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_qbuf</span></code></a> handler in driver.</p>
<dl class="function">
<dt id="c.vb2_expbuf">
int <code class="descname">vb2_expbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/vidioc-expbuf.html#c.v4l2_exportbuffer" title="v4l2_exportbuffer">v4l2_exportbuffer</a> *<em>&nbsp;eb</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_expbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Export a buffer as a file descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_exportbuffer</span> <span class="pre">*</span> <span class="pre">eb</span></code></dt>
<dd>export buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_expbuf</span></code></a> handler in driver</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_expbuf</span></code></a> handler in driver.</p>
<dl class="function">
<dt id="c.vb2_dqbuf">
int <code class="descname">vb2_dqbuf</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buffer" title="v4l2_buffer">v4l2_buffer</a> *<em>&nbsp;b</em>, bool<em>&nbsp;nonblocking</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_dqbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Dequeue a buffer to the userspace</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">v4l2_buffer</span> <span class="pre">*</span> <span class="pre">b</span></code></dt>
<dd>buffer structure passed from userspace to
<a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_dqbuf</span></code></a> handler in driver</dd>
<dt><code class="docutils literal"><span class="pre">bool</span> <span class="pre">nonblocking</span></code></dt>
<dd>if true, this call will not sleep waiting for a buffer if no
buffers ready for dequeuing are present. Normally the driver
would be passing (<code class="xref c c-type docutils literal"><span class="pre">file-&gt;f_flags</span></code> &amp; <code class="docutils literal"><span class="pre">O_NONBLOCK</span></code>) here</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_dqbuf</span></code></a> ioctl handler
of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies the passed buffer;</li>
<li>calls <a class="reference internal" href="#c.vb2_ops" title="vb2_ops"><code class="xref c c-type docutils literal"><span class="pre">vb2_ops-&gt;buf_finish</span></code></a> callback in the driver (if provided), in which
driver can perform any additional operations that may be required before
returning the buffer to userspace, such as cache sync;</li>
<li>the buffer struct members are filled with relevant information for
the userspace.</li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_dqbuf</span></code></a> handler in driver.</p>
<dl class="function">
<dt id="c.vb2_streamon">
int <code class="descname">vb2_streamon</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type">v4l2_buf_type</a><em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_streamon" title="Permalink to this definition">¶</a></dt>
<dd><p>start streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span> <span class="pre">type</span></code></dt>
<dd>type argument passed from userspace to vidioc_streamon handler,
as defined by <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span></code></a>.</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_streamon</span></code></a> handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies current state</li>
<li>passes any previously queued buffers to the driver and starts streaming</li>
</ol>
<p>The return values from this function are intended to be directly returned
from <a class="reference internal" href="v4l2-common.html#c.v4l2_ioctl_ops" title="v4l2_ioctl_ops"><code class="xref c c-type docutils literal"><span class="pre">v4l2_ioctl_ops-&gt;vidioc_streamon</span></code></a> handler in the driver.</p>
<dl class="function">
<dt id="c.vb2_streamoff">
int <code class="descname">vb2_streamoff</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, enum <a class="reference internal" href="../uapi/v4l/buffer.html#c.v4l2_buf_type" title="v4l2_buf_type">v4l2_buf_type</a><em>&nbsp;type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_streamoff" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">enum</span> <span class="pre">v4l2_buf_type</span> <span class="pre">type</span></code></dt>
<dd>type argument passed from userspace to vidioc_streamoff handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>Should be called from vidioc_streamoff handler of a driver.</p>
<p>This function:</p>
<ol class="arabic simple">
<li>verifies current state,</li>
<li>stop streaming and dequeues any queued buffers, including those previously
passed to the driver (after waiting for the driver to finish).</li>
</ol>
<p>This call can be used for pausing playback.
The return values from this function are intended to be directly returned
from vidioc_streamoff handler in the driver</p>
<dl class="function">
<dt id="c.vb2_queue_init">
int <code class="descname">vb2_queue_init</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_init" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize a videobuf2 queue</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>The vb2_queue structure should be allocated by the driver. The driver is
responsible of clearing it&#8217;s content and setting initial values for some
required entries before calling this function.
q-&gt;ops, q-&gt;mem_ops, q-&gt;type and q-&gt;io_modes are mandatory. Please refer
to the struct vb2_queue description in include/media/videobuf2-core.h
for more information.</p>
<dl class="function">
<dt id="c.vb2_queue_release">
void <code class="descname">vb2_queue_release</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_queue_release" title="Permalink to this definition">¶</a></dt>
<dd><p>stop streaming, release the queue and free memory</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function stops streaming and performs necessary clean ups, including
freeing video buffer memory. The driver is responsible for freeing
the vb2_queue structure itself.</p>
<dl class="function">
<dt id="c.vb2_poll">
__poll_t <code class="descname">vb2_poll</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;q</em>, struct file *<em>&nbsp;file</em>, poll_table *<em>&nbsp;wait</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_poll" title="Permalink to this definition">¶</a></dt>
<dd><p>implements poll userspace operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">q</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a> with videobuf2 queue.</dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span> <span class="pre">*</span> <span class="pre">file</span></code></dt>
<dd>file argument passed to the poll file operation handler</dd>
<dt><code class="docutils literal"><span class="pre">poll_table</span> <span class="pre">*</span> <span class="pre">wait</span></code></dt>
<dd>wait argument passed to the poll file operation handler</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function implements poll file operation handler for a driver.
For CAPTURE queues, if a buffer is ready to be dequeued, the userspace will
be informed that the file descriptor of a video device is available for
reading.
For OUTPUT queues, if a buffer is ready to be dequeued, the file descriptor
will be reported as available for writing.</p>
<p>If the driver uses struct v4l2_fh, then <a class="reference internal" href="#c.vb2_poll" title="vb2_poll"><code class="xref c c-func docutils literal"><span class="pre">vb2_poll()</span></code></a> will also check for any
pending events.</p>
<p>The return values from this function are intended to be directly returned
from poll handler in driver.</p>
<dl class="function">
<dt id="c.vb2_ops_wait_prepare">
void <code class="descname">vb2_ops_wait_prepare</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;vq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_ops_wait_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to lock a struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">vq</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: only use if vq-&gt;lock is non-NULL.</p>
<dl class="function">
<dt id="c.vb2_ops_wait_finish">
void <code class="descname">vb2_ops_wait_finish</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue">vb2_queue</a> *<em>&nbsp;vq</em><span class="sig-paren">)</span><a class="headerlink" href="#c.vb2_ops_wait_finish" title="Permalink to this definition">¶</a></dt>
<dd><p>helper function to unlock a struct <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">vb2_queue</span></code></a></p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span> <span class="pre">*</span> <span class="pre">vq</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.vb2_queue" title="vb2_queue"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vb2_queue</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>..note:: only use if vq-&gt;lock is non-NULL.</p>
<dl class="type">
<dt id="c.vb2_vmarea_handler">
struct <code class="descname">vb2_vmarea_handler</code><a class="headerlink" href="#c.vb2_vmarea_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>common vma refcount tracking handler.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct vb2_vmarea_handler {
  refcount_t *refcount;
  void (*put)(void *arg);
  void *arg;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">refcount_t</span></code> entry in the buffer.</dd>
<dt><code class="docutils literal"><span class="pre">put</span></code></dt>
<dd>callback to function that decreases buffer refcount.</dd>
<dt><code class="docutils literal"><span class="pre">arg</span></code></dt>
<dd>argument for <strong>put</strong> callback.</dd>
</dl>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="v4l2-clocks.html" class="btn btn-neutral float-right" title="1.15. V4L2 clocks" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="v4l2-videobuf.html" class="btn btn-neutral" title="1.13. Videobuf Framework" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>