

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.2. Digital TV Frontend kABI &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/>
        <link rel="up" title="2. Digital TV (DVB) devices" href="dtv-core.html"/>
        <link rel="next" title="2.3. Digital TV Demux kABI" href="dtv-demux.html"/>
        <link rel="prev" title="2.1. Digital TV Common functions" href="dtv-common.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="dtv-common.html">2.1. Digital TV Common functions</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="">2.2. Digital TV Frontend kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-demux.html">2.3. Digital TV Demux kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-ca.html">2.4. Digital TV Conditional Access kABI</a></li>
<li class="toctree-l4"><a class="reference internal" href="dtv-net.html">2.5. Digital TV Network kABI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">4. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
      
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
      
          <li><a href="dtv-core.html">2. Digital TV (DVB) devices</a> &raquo;</li>
      
    <li>2.2. Digital TV Frontend kABI</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/media/kapi/dtv-frontend.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="digital-tv-frontend-kabi">
<h1>2.2. Digital TV Frontend kABI<a class="headerlink" href="#digital-tv-frontend-kabi" title="Permalink to this headline">¶</a></h1>
<div class="section" id="digital-tv-frontend">
<h2>2.2.1. Digital TV Frontend<a class="headerlink" href="#digital-tv-frontend" title="Permalink to this headline">¶</a></h2>
<p>The Digital TV Frontend kABI defines a driver-internal interface for
registering low-level, hardware specific driver to a hardware independent
frontend layer. It is only of interest for Digital TV device driver writers.
The header file for this API is named <code class="docutils literal"><span class="pre">dvb_frontend.h</span></code> and located in
<code class="docutils literal"><span class="pre">include/media/</span></code>.</p>
<div class="section" id="demodulator-driver">
<h3>2.2.1.1. Demodulator driver<a class="headerlink" href="#demodulator-driver" title="Permalink to this headline">¶</a></h3>
<p>The demodulator driver is responsible to talk with the decoding part of the
hardware. Such driver should implement <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code></a>, with
tells what type of digital TV standards are supported, and points to a
series of functions that allow the DVB core to command the hardware via
the code under <code class="docutils literal"><span class="pre">include/media/dvb_frontend.c</span></code>.</p>
<p>A typical example of such struct in a driver <code class="docutils literal"><span class="pre">foo</span></code> is:</p>
<div class="highlight-none"><div class="highlight"><pre>static struct dvb_frontend_ops foo_ops = {
        .delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
        .info = {
                .name   = &quot;foo DVB-T/T2/C driver&quot;,
                .caps = FE_CAN_FEC_1_2 |
                        FE_CAN_FEC_2_3 |
                        FE_CAN_FEC_3_4 |
                        FE_CAN_FEC_5_6 |
                        FE_CAN_FEC_7_8 |
                        FE_CAN_FEC_AUTO |
                        FE_CAN_QPSK |
                        FE_CAN_QAM_16 |
                        FE_CAN_QAM_32 |
                        FE_CAN_QAM_64 |
                        FE_CAN_QAM_128 |
                        FE_CAN_QAM_256 |
                        FE_CAN_QAM_AUTO |
                        FE_CAN_TRANSMISSION_MODE_AUTO |
                        FE_CAN_GUARD_INTERVAL_AUTO |
                        FE_CAN_HIERARCHY_AUTO |
                        FE_CAN_MUTE_TS |
                        FE_CAN_2G_MODULATION,
                .frequency_min = 42000000, /* Hz */
                .frequency_max = 1002000000, /* Hz */
                .symbol_rate_min = 870000,
                .symbol_rate_max = 11700000
        },
        .init = foo_init,
        .sleep = foo_sleep,
        .release = foo_release,
        .set_frontend = foo_set_frontend,
        .get_frontend = foo_get_frontend,
        .read_status = foo_get_status_and_stats,
        .tune = foo_tune,
        .i2c_gate_ctrl = foo_i2c_gate_ctrl,
        .get_frontend_algo = foo_get_algo,
};
</pre></div>
</div>
<p>A typical example of such struct in a driver <code class="docutils literal"><span class="pre">bar</span></code> meant to be used on
Satellite TV reception is:</p>
<div class="highlight-none"><div class="highlight"><pre>static const struct dvb_frontend_ops bar_ops = {
        .delsys = { SYS_DVBS, SYS_DVBS2 },
        .info = {
                .name           = &quot;Bar DVB-S/S2 demodulator&quot;,
                .frequency_min  = 500000, /* KHz */
                .frequency_max  = 2500000, /* KHz */
                .frequency_stepsize     = 0,
                .symbol_rate_min = 1000000,
                .symbol_rate_max = 45000000,
                .symbol_rate_tolerance = 500,
                .caps = FE_CAN_INVERSION_AUTO |
                        FE_CAN_FEC_AUTO |
                        FE_CAN_QPSK,
        },
        .init = bar_init,
        .sleep = bar_sleep,
        .release = bar_release,
        .set_frontend = bar_set_frontend,
        .get_frontend = bar_get_frontend,
        .read_status = bar_get_status_and_stats,
        .i2c_gate_ctrl = bar_i2c_gate_ctrl,
        .get_frontend_algo = bar_get_algo,
        .tune = bar_tune,

        /* Satellite-specific */
        .diseqc_send_master_cmd = bar_send_diseqc_msg,
        .diseqc_send_burst = bar_send_burst,
        .set_tone = bar_set_tone,
        .set_voltage = bar_set_voltage,
};
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>For satellite digital TV standards (DVB-S, DVB-S2, ISDB-S), the
frequencies are specified in kHz, while, for terrestrial and cable
standards, they&#8217;re specified in Hz. Due to that, if the same frontend
supports both types, you&#8217;ll need to have two separate
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code></a> structures, one for each standard.</li>
<li>The <code class="docutils literal"><span class="pre">.i2c_gate_ctrl</span></code> field is present only when the hardware has
allows controlling an I2C gate (either directly of via some GPIO pin),
in order to remove the tuner from the I2C bus after a channel is
tuned.</li>
<li>All new drivers should implement the
<a class="reference internal" href="#dvbv5-stats"><span>DVBv5 statistics</span></a> via <code class="docutils literal"><span class="pre">.read_status</span></code>.
Yet, there are a number of callbacks meant to get statistics for
signal strength, S/N and UCB. Those are there to provide backward
compatibility with legacy applications that don&#8217;t support the DVBv5
API. Implementing those callbacks are optional. Those callbacks may be
removed in the future, after we have all existing drivers supporting
DVBv5 stats.</li>
<li>Other callbacks are required for satellite TV standards, in order to
control LNBf and DiSEqC: <code class="docutils literal"><span class="pre">.diseqc_send_master_cmd</span></code>,
<code class="docutils literal"><span class="pre">.diseqc_send_burst</span></code>, <code class="docutils literal"><span class="pre">.set_tone</span></code>, <code class="docutils literal"><span class="pre">.set_voltage</span></code>.</li>
</ol>
</div>
<p>The <code class="docutils literal"><span class="pre">include/media/dvb_frontend.c</span></code> has a kernel thread with is
responsible for tuning the device. It supports multiple algorithms to
detect a channel, as defined at enum <a class="reference internal" href="#c.dvbfe_algo" title="dvbfe_algo"><code class="xref c c-func docutils literal"><span class="pre">dvbfe_algo()</span></code></a>.</p>
<p>The algorithm to be used is obtained via <code class="docutils literal"><span class="pre">.get_frontend_algo</span></code>. If the driver
doesn&#8217;t fill its field at struct <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code></a>, it will default to
<code class="docutils literal"><span class="pre">DVBFE_ALGO_SW</span></code>, meaning that the dvb-core will do a zigzag when tuning,
e. g. it will try first to use the specified center frequency <code class="docutils literal"><span class="pre">f</span></code>,
then, it will do <code class="docutils literal"><span class="pre">f</span></code> + Δ, <code class="docutils literal"><span class="pre">f</span></code> - Δ, <code class="docutils literal"><span class="pre">f</span></code> + 2 x Δ,
<code class="docutils literal"><span class="pre">f</span></code> - 2 x Δ and so on.</p>
<p>If the hardware has internally a some sort of zigzag algorithm, you should
define a <code class="docutils literal"><span class="pre">.get_frontend_algo</span></code> function that would return <code class="docutils literal"><span class="pre">DVBFE_ALGO_HW</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The core frontend support also supports
a third type (<code class="docutils literal"><span class="pre">DVBFE_ALGO_CUSTOM</span></code>), in order to allow the driver to
define its own hardware-assisted algorithm. Very few hardware need to
use it nowadays. Using <code class="docutils literal"><span class="pre">DVBFE_ALGO_CUSTOM</span></code> require to provide other
function callbacks at struct <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code></a>.</p>
</div>
</div>
<div class="section" id="attaching-frontend-driver-to-the-bridge-driver">
<h3>2.2.1.2. Attaching frontend driver to the bridge driver<a class="headerlink" href="#attaching-frontend-driver-to-the-bridge-driver" title="Permalink to this headline">¶</a></h3>
<p>Before using the Digital TV frontend core, the bridge driver should attach
the frontend demod, tuner and SEC devices and call
<a class="reference internal" href="#c.dvb_register_frontend" title="dvb_register_frontend"><code class="xref c c-func docutils literal"><span class="pre">dvb_register_frontend()</span></code></a>,
in order to register the new frontend at the subsystem. At device
detach/removal, the bridge driver should call
<a class="reference internal" href="#c.dvb_unregister_frontend" title="dvb_unregister_frontend"><code class="xref c c-func docutils literal"><span class="pre">dvb_unregister_frontend()</span></code></a> to
remove the frontend from the core and then <a class="reference internal" href="#c.dvb_frontend_detach" title="dvb_frontend_detach"><code class="xref c c-func docutils literal"><span class="pre">dvb_frontend_detach()</span></code></a>
to free the memory allocated by the frontend drivers.</p>
<p>The drivers should also call <a class="reference internal" href="#c.dvb_frontend_suspend" title="dvb_frontend_suspend"><code class="xref c c-func docutils literal"><span class="pre">dvb_frontend_suspend()</span></code></a> as part of
their handler for the <a class="reference internal" href="../../driver-api/infrastructure.html#c.device_driver" title="device_driver"><code class="xref c c-type docutils literal"><span class="pre">device_driver</span></code></a>.<code class="docutils literal"><span class="pre">suspend()</span></code>, and
<a class="reference internal" href="#c.dvb_frontend_resume" title="dvb_frontend_resume"><code class="xref c c-func docutils literal"><span class="pre">dvb_frontend_resume()</span></code></a> as
part of their handler for <a class="reference internal" href="../../driver-api/infrastructure.html#c.device_driver" title="device_driver"><code class="xref c c-type docutils literal"><span class="pre">device_driver</span></code></a>.<code class="docutils literal"><span class="pre">resume()</span></code>.</p>
<p>A few other optional functions are provided to handle some special cases.</p>
</div>
</div>
<div class="section" id="digital-tv-frontend-statistics">
<span id="dvbv5-stats"></span><h2>2.2.2. Digital TV Frontend statistics<a class="headerlink" href="#digital-tv-frontend-statistics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction">
<h3>2.2.2.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>Digital TV frontends provide a range of
<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#frontend-stat-properties"><span>statistics</span></a> meant to help tuning the device
and measuring the quality of service.</p>
<p>For each statistics measurement, the driver should set the type of scale used,
or <code class="docutils literal"><span class="pre">FE_SCALE_NOT_AVAILABLE</span></code> if the statistics is not available on a given
time. Drivers should also provide the number of statistics for each type.
that&#8217;s usually 1 for most video standards <a class="footnote-reference" href="#f2" id="id1">[1]</a>.</p>
<p>Drivers should initialize each statistic counters with length and
scale at its init code. For example, if the frontend provides signal
strength, it should have, on its init code:</p>
<div class="highlight-none"><div class="highlight"><pre>struct dtv_frontend_properties *c = &amp;state-&gt;fe.dtv_property_cache;

c-&gt;strength.len = 1;
c-&gt;strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;
</pre></div>
</div>
<p>And, when the statistics got updated, set the scale:</p>
<div class="highlight-none"><div class="highlight"><pre>c-&gt;strength.stat[0].scale = FE_SCALE_DECIBEL;
c-&gt;strength.stat[0].uvalue = strength;
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">For ISDB-T, it may provide both a global statistics and a per-layer
set of statistics. On such cases, len should be equal to 4. The first
value corresponds to the global stat; the other ones to each layer, e. g.:</p>
<ul class="last simple">
<li>c-&gt;cnr.stat[0] for global S/N carrier ratio,</li>
<li>c-&gt;cnr.stat[1] for Layer A S/N carrier ratio,</li>
<li>c-&gt;cnr.stat[2] for layer B S/N carrier ratio,</li>
<li>c-&gt;cnr.stat[3] for layer C S/N carrier ratio.</li>
</ul>
</td></tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please prefer to use <code class="docutils literal"><span class="pre">FE_SCALE_DECIBEL</span></code> instead of
<code class="docutils literal"><span class="pre">FE_SCALE_RELATIVE</span></code> for signal strength and CNR measurements.</p>
</div>
</div>
<div class="section" id="groups-of-statistics">
<h3>2.2.2.2. Groups of statistics<a class="headerlink" href="#groups-of-statistics" title="Permalink to this headline">¶</a></h3>
<p>There are several groups of statistics currently supported:</p>
<dl class="docutils">
<dt>Signal strength (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-signal-strength"><span>DTV_STAT_SIGNAL_STRENGTH</span></a>)</dt>
<dd><ul class="first simple">
<li>Measures the signal strength level at the analog part of the tuner or
demod.</li>
<li>Typically obtained from the gain applied to the tuner and/or frontend
in order to detect the carrier. When no carrier is detected, the gain is
at the maximum value (so, strength is on its minimal).</li>
<li>As the gain is visible through the set of registers that adjust the gain,
typically, this statistics is always available <a class="footnote-reference" href="#f3" id="id2">[2]</a>.</li>
<li>Drivers should try to make it available all the times, as this statistics
can be used when adjusting an antenna position and to check for troubles
at the cabling.</li>
</ul>
<table class="last docutils footnote" frame="void" id="f3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>On a few devices, the gain keeps floating if no carrier.
On such devices, strength report should check first if carrier is
detected at the tuner (<code class="docutils literal"><span class="pre">FE_HAS_CARRIER</span></code>, see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>),
and otherwise return the lowest possible value.</td></tr>
</tbody>
</table>
</dd>
<dt>Carrier Signal to Noise ratio (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-cnr"><span>DTV_STAT_CNR</span></a>)</dt>
<dd><ul class="first last">
<li><p class="first">Signal to Noise ratio for the main carrier.</p>
</li>
<li><p class="first">Signal to Noise measurement depends on the device. On some hardware, is
available when the main carrier is detected. On those hardware, CNR
measurement usually comes from the tuner (e. g. after <code class="docutils literal"><span class="pre">FE_HAS_CARRIER</span></code>,
see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</p>
<p>On other devices, it requires inner FEC decoding,
as the frontend measures it indirectly from other parameters (e. g. after
<code class="docutils literal"><span class="pre">FE_HAS_VITERBI</span></code>, see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</p>
<p>Having it available after inner FEC is more common.</p>
</li>
</ul>
</dd>
<dt>Bit counts post-FEC (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-post-error-bit-count"><span>DTV_STAT_POST_ERROR_BIT_COUNT</span></a> and <a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-post-total-bit-count"><span>DTV_STAT_POST_TOTAL_BIT_COUNT</span></a>)</dt>
<dd><ul class="first last simple">
<li>Those counters measure the number of bits and bit errors errors after
the forward error correction (FEC) on the inner coding block
(after Viterbi, LDPC or other inner code).</li>
<li>Due to its nature, those statistics depend on full coding lock
(e. g. after <code class="docutils literal"><span class="pre">FE_HAS_SYNC</span></code> or after <code class="docutils literal"><span class="pre">FE_HAS_LOCK</span></code>,
see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</li>
</ul>
</dd>
<dt>Bit counts pre-FEC (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-pre-error-bit-count"><span>DTV_STAT_PRE_ERROR_BIT_COUNT</span></a> and <a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-pre-total-bit-count"><span>DTV_STAT_PRE_TOTAL_BIT_COUNT</span></a>)</dt>
<dd><ul class="first last simple">
<li>Those counters measure the number of bits and bit errors errors before
the forward error correction (FEC) on the inner coding block
(before Viterbi, LDPC or other inner code).</li>
<li>Not all frontends provide this kind of statistics.</li>
<li>Due to its nature, those statistics depend on inner coding lock (e. g.
after <code class="docutils literal"><span class="pre">FE_HAS_VITERBI</span></code>, see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</li>
</ul>
</dd>
<dt>Block counts (<a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-error-block-count"><span>DTV_STAT_ERROR_BLOCK_COUNT</span></a> and <a class="reference internal" href="../uapi/dvb/frontend-stat-properties.html#dtv-stat-total-block-count"><span>DTV-STAT_TOTAL_BLOCK_COUNT</span></a>)</dt>
<dd><ul class="first last simple">
<li>Those counters measure the number of blocks and block errors errors after
the forward error correction (FEC) on the inner coding block
(before Viterbi, LDPC or other inner code).</li>
<li>Due to its nature, those statistics depend on full coding lock
(e. g. after <code class="docutils literal"><span class="pre">FE_HAS_SYNC</span></code> or after
<code class="docutils literal"><span class="pre">FE_HAS_LOCK</span></code>, see <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_status" title="fe_status"><code class="xref c c-type docutils literal"><span class="pre">fe_status</span></code></a>).</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All counters should be monotonically increased as they&#8217;re
collected from the hardware.</p>
</div>
<p>A typical example of the logic that handle status and statistics is:</p>
<div class="highlight-none"><div class="highlight"><pre>static int foo_get_status_and_stats(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;

        int rc;
        enum fe_status *status;

        /* Both status and strength are always available */
        rc = foo_read_status(fe, &amp;status);
        if (rc &lt; 0)
                return rc;

        rc = foo_read_strength(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if CNR is available */
        if (!(fe-&gt;status &amp; FE_HAS_CARRIER))
                return 0;

        rc = foo_read_cnr(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if pre-BER stats are available */
        if (!(fe-&gt;status &amp; FE_HAS_VITERBI))
                return 0;

        rc = foo_get_pre_ber(fe);
        if (rc &lt; 0)
                return rc;

        /* Check if post-BER stats are available */
        if (!(fe-&gt;status &amp; FE_HAS_SYNC))
                return 0;

        rc = foo_get_post_ber(fe);
        if (rc &lt; 0)
                return rc;
}

static const struct dvb_frontend_ops ops = {
        /* ... */
        .read_status = foo_get_status_and_stats,
};
</pre></div>
</div>
</div>
<div class="section" id="statistics-collect">
<h3>2.2.2.3. Statistics collect<a class="headerlink" href="#statistics-collect" title="Permalink to this headline">¶</a></h3>
<p>On almost all frontend hardware, the bit and byte counts are stored by
the hardware after a certain amount of time or after the total bit/block
counter reaches a certain value (usually programable), for example, on
every 1000 ms or after receiving 1,000,000 bits.</p>
<p>So, if you read the registers too soon, you&#8217;ll end by reading the same
value as in the previous reading, causing the monotonic value to be
incremented too often.</p>
<p>Drivers should take the responsibility to avoid too often reads. That
can be done using two approaches:</p>
<div class="section" id="if-the-driver-have-a-bit-that-indicates-when-a-collected-data-is-ready">
<h4>2.2.2.3.1. if the driver have a bit that indicates when a collected data is ready<a class="headerlink" href="#if-the-driver-have-a-bit-that-indicates-when-a-collected-data-is-ready" title="Permalink to this headline">¶</a></h4>
<p>Driver should check such bit before making the statistics available.</p>
<p>An example of such behavior can be found at this code snippet (adapted
from mb86a20s driver&#8217;s logic):</p>
<div class="highlight-none"><div class="highlight"><pre>static int foo_get_pre_ber(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;
        int rc, bit_error;

        /* Check if the BER measures are already available */
        rc = foo_read_u8(state, 0x54);
        if (rc &lt; 0)
                return rc;

        if (!rc)
                return 0;

        /* Read Bit Error Count */
        bit_error = foo_read_u32(state, 0x55);
        if (bit_error &lt; 0)
                return bit_error;

        /* Read Total Bit Count */
        rc = foo_read_u32(state, 0x51);
        if (rc &lt; 0)
                return rc;

        c-&gt;pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_error.stat[0].uvalue += bit_error;
        c-&gt;pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_count.stat[0].uvalue += rc;

        return 0;
}
</pre></div>
</div>
</div>
<div class="section" id="if-the-driver-doesn-t-provide-a-statistics-available-check-bit">
<h4>2.2.2.3.2. If the driver doesn&#8217;t provide a statistics available check bit<a class="headerlink" href="#if-the-driver-doesn-t-provide-a-statistics-available-check-bit" title="Permalink to this headline">¶</a></h4>
<p>A few devices, however, may not provide a way to check if the stats are
available (or the way to check it is unknown). They may not even provide
a way to directly read the total number of bits or blocks.</p>
<p>On those devices, the driver need to ensure that it won&#8217;t be reading from
the register too often and/or estimate the total number of bits/blocks.</p>
<p>On such drivers, a typical routine to get statistics would be like
(adapted from dib8000 driver&#8217;s logic):</p>
<div class="highlight-none"><div class="highlight"><pre>struct foo_state {
        /* ... */

        unsigned long per_jiffies_stats;
}

static int foo_get_pre_ber(struct dvb_frontend *fe)
{
        struct foo_state *state = fe-&gt;demodulator_priv;
        struct dtv_frontend_properties *c = &amp;fe-&gt;dtv_property_cache;
        int rc, bit_error;
        u64 bits;

        /* Check if time for stats was elapsed */
        if (!time_after(jiffies, state-&gt;per_jiffies_stats))
                return 0;

        /* Next stat should be collected in 1000 ms */
        state-&gt;per_jiffies_stats = jiffies + msecs_to_jiffies(1000);

        /* Read Bit Error Count */
        bit_error = foo_read_u32(state, 0x55);
        if (bit_error &lt; 0)
                return bit_error;

        /*
         * On this particular frontend, there&#39;s no register that
         * would provide the number of bits per 1000ms sample. So,
         * some function would calculate it based on DTV properties
         */
        bits = get_number_of_bits_per_1000ms(fe);

        c-&gt;pre_bit_error.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_error.stat[0].uvalue += bit_error;
        c-&gt;pre_bit_count.stat[0].scale = FE_SCALE_COUNTER;
        c-&gt;pre_bit_count.stat[0].uvalue += bits;

        return 0;
}
</pre></div>
</div>
<p>Please notice that, on both cases, we&#8217;re getting the statistics using the
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops</span></code></a> <code class="docutils literal"><span class="pre">.read_status</span></code> callback. The rationale is that
the frontend core will automatically call this function periodically
(usually, 3 times per second, when the frontend is locked).</p>
<p>That warrants that we won&#8217;t miss to collect a counter and increment the
monotonic stats at the right time.</p>
</div>
</div>
</div>
<div class="section" id="digital-tv-frontend-functions-and-types">
<h2>2.2.3. Digital TV Frontend functions and types<a class="headerlink" href="#digital-tv-frontend-functions-and-types" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="c.dvb_frontend_tune_settings">
struct <code class="descname">dvb_frontend_tune_settings</code><a class="headerlink" href="#c.dvb_frontend_tune_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>parameters to adjust frontend tuning</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct dvb_frontend_tune_settings {
  int min_delay_ms;
  int step_size;
  int max_drift;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">min_delay_ms</span></code></dt>
<dd>minimum delay for tuning, in ms</dd>
<dt><code class="docutils literal"><span class="pre">step_size</span></code></dt>
<dd>step size between two consecutive frequencies</dd>
<dt><code class="docutils literal"><span class="pre">max_drift</span></code></dt>
<dd>maximum drift</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>step_size is in Hz, for terrestrial/cable or kHz for satellite</p>
<dl class="type">
<dt id="c.dvb_tuner_info">
struct <code class="descname">dvb_tuner_info</code><a class="headerlink" href="#c.dvb_tuner_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Frontend name and min/max ranges/bandwidths</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct dvb_tuner_info {
  char name[128];
  u32 frequency_min_hz;
  u32 frequency_max_hz;
  u32 frequency_step_hz;
  u32 bandwidth_min;
  u32 bandwidth_max;
  u32 bandwidth_step;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>name of the Frontend</dd>
<dt><code class="docutils literal"><span class="pre">frequency_min_hz</span></code></dt>
<dd>minimal frequency supported in Hz</dd>
<dt><code class="docutils literal"><span class="pre">frequency_max_hz</span></code></dt>
<dd>maximum frequency supported in Hz</dd>
<dt><code class="docutils literal"><span class="pre">frequency_step_hz</span></code></dt>
<dd>frequency step in Hz</dd>
<dt><code class="docutils literal"><span class="pre">bandwidth_min</span></code></dt>
<dd>minimal frontend bandwidth supported</dd>
<dt><code class="docutils literal"><span class="pre">bandwidth_max</span></code></dt>
<dd>maximum frontend bandwidth supported</dd>
<dt><code class="docutils literal"><span class="pre">bandwidth_step</span></code></dt>
<dd>frontend bandwidth step</dd>
</dl>
<dl class="type">
<dt id="c.analog_parameters">
struct <code class="descname">analog_parameters</code><a class="headerlink" href="#c.analog_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters to tune into an analog/radio channel</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct analog_parameters {
  unsigned int frequency;
  unsigned int mode;
  unsigned int audmode;
  u64 std;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">frequency</span></code></dt>
<dd>Frequency used by analog TV tuner (either in 62.5 kHz step,
for TV, or 62.5 Hz for radio)</dd>
<dt><code class="docutils literal"><span class="pre">mode</span></code></dt>
<dd>Tuner mode, as defined on enum v4l2_tuner_type</dd>
<dt><code class="docutils literal"><span class="pre">audmode</span></code></dt>
<dd>Audio mode as defined for the rxsubchans field at videodev2.h,
e. g. V4L2_TUNER_MODE_*</dd>
<dt><code class="docutils literal"><span class="pre">std</span></code></dt>
<dd>TV standard bitmap as defined at videodev2.h, e. g. V4L2_STD_*</dd>
</dl>
<p><strong>Description</strong></p>
<p>Hybrid tuners should be supported by both V4L2 and DVB APIs. This
struct contains the data that are used by the V4L2 side. To avoid
dependencies from V4L2 headers, all enums here are declared as integers.</p>
<dl class="type">
<dt id="c.dvbfe_algo">
enum <code class="descname">dvbfe_algo</code><a class="headerlink" href="#c.dvbfe_algo" title="Permalink to this definition">¶</a></dt>
<dd><p>defines the algorithm used to tune into a channel</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_HW</span></code></dt>
<dd>Hardware Algorithm -
Devices that support this algorithm do everything in hardware
and no software support is needed to handle them.
Requesting these devices to LOCK is the only thing required,
device is supposed to do everything in the hardware.</dd>
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_SW</span></code></dt>
<dd>Software Algorithm -
These are dumb devices, that require software to do everything</dd>
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_CUSTOM</span></code></dt>
<dd>Customizable Agorithm -
Devices having this algorithm can be customized to have specific
algorithms in the frontend driver, rather than simply doing a
software zig-zag. In this case the zigzag maybe hardware assisted
or it maybe completely done in hardware. In all cases, usage of
this algorithm, in conjunction with the search and track
callbacks, utilizes the driver specific algorithm.</dd>
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_RECOVERY</span></code></dt>
<dd>Recovery Algorithm -
These devices have AUTO recovery capabilities from LOCK failure</dd>
</dl>
<dl class="type">
<dt id="c.dvbfe_search">
enum <code class="descname">dvbfe_search</code><a class="headerlink" href="#c.dvbfe_search" title="Permalink to this definition">¶</a></dt>
<dd><p>search callback possible return status</p>
</dd></dl>

<p><strong>Constants</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_SEARCH_SUCCESS</span></code></dt>
<dd>The frontend search algorithm completed and returned successfully</dd>
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_SEARCH_ASLEEP</span></code></dt>
<dd>The frontend search algorithm is sleeping</dd>
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_SEARCH_FAILED</span></code></dt>
<dd>The frontend search for a signal failed</dd>
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_SEARCH_INVALID</span></code></dt>
<dd>The frontend search algorith was probably supplied with invalid
parameters and the search is an invalid one</dd>
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_SEARCH_AGAIN</span></code></dt>
<dd>The frontend search algorithm was requested to search again</dd>
<dt><code class="docutils literal"><span class="pre">DVBFE_ALGO_SEARCH_ERROR</span></code></dt>
<dd>The frontend search algorithm failed due to some error</dd>
</dl>
<dl class="type">
<dt id="c.dvb_tuner_ops">
struct <code class="descname">dvb_tuner_ops</code><a class="headerlink" href="#c.dvb_tuner_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuner information and callbacks</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct dvb_tuner_ops {
  struct dvb_tuner_info info;
  void (*release)(struct dvb_frontend *fe);
  int (*init)(struct dvb_frontend *fe);
  int (*sleep)(struct dvb_frontend *fe);
  int (*suspend)(struct dvb_frontend *fe);
  int (*resume)(struct dvb_frontend *fe);
  int (*set_params)(struct dvb_frontend *fe);
  int (*set_analog_params)(struct dvb_frontend *fe, struct analog_parameters *p);
  int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
  int (*get_frequency)(struct dvb_frontend *fe, u32 *frequency);
  int (*get_bandwidth)(struct dvb_frontend *fe, u32 *bandwidth);
  int (*get_if_frequency)(struct dvb_frontend *fe, u32 *frequency);
#define TUNER_STATUS_LOCKED 1;
#define TUNER_STATUS_STEREO 2;
  int (*get_status)(struct dvb_frontend *fe, u32 *status);
  int (*get_rf_strength)(struct dvb_frontend *fe, u16 *strength);
  int (*get_afc)(struct dvb_frontend *fe, s32 *afc);
  int (*calc_regs)(struct dvb_frontend *fe, u8 *buf, int buf_len);
  int (*set_frequency)(struct dvb_frontend *fe, u32 frequency);
  int (*set_bandwidth)(struct dvb_frontend *fe, u32 bandwidth);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">info</span></code></dt>
<dd>embedded <a class="reference internal" href="#c.dvb_tuner_info" title="dvb_tuner_info"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_tuner_info</span></code></a> with tuner properties</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>callback function called when frontend is detached.
drivers should free any allocated memory.</dd>
<dt><code class="docutils literal"><span class="pre">init</span></code></dt>
<dd>callback function used to initialize the tuner device.</dd>
<dt><code class="docutils literal"><span class="pre">sleep</span></code></dt>
<dd>callback function used to put the tuner to sleep.</dd>
<dt><code class="docutils literal"><span class="pre">suspend</span></code></dt>
<dd>callback function used to inform that the Kernel will
suspend.</dd>
<dt><code class="docutils literal"><span class="pre">resume</span></code></dt>
<dd>callback function used to inform that the Kernel is
resuming from suspend.</dd>
<dt><code class="docutils literal"><span class="pre">set_params</span></code></dt>
<dd>callback function used to inform the tuner to tune
into a digital TV channel. The properties to be used
are stored at <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a>.dtv_property_cache.
The tuner demod can change the parameters to reflect
the changes needed for the channel to be tuned, and
update statistics. This is the recommended way to set
the tuner parameters and should be used on newer
drivers.</dd>
<dt><code class="docutils literal"><span class="pre">set_analog_params</span></code></dt>
<dd>callback function used to tune into an analog TV
channel on hybrid tuners. It passes <strong>analog_parameters</strong>
to the driver.</dd>
<dt><code class="docutils literal"><span class="pre">set_config</span></code></dt>
<dd>callback function used to send some tuner-specific
parameters.</dd>
<dt><code class="docutils literal"><span class="pre">get_frequency</span></code></dt>
<dd>get the actual tuned frequency</dd>
<dt><code class="docutils literal"><span class="pre">get_bandwidth</span></code></dt>
<dd>get the bandwitdh used by the low pass filters</dd>
<dt><code class="docutils literal"><span class="pre">get_if_frequency</span></code></dt>
<dd>get the Intermediate Frequency, in Hz. For baseband,
should return 0.</dd>
<dt><code class="docutils literal"><span class="pre">get_status</span></code></dt>
<dd>returns the frontend lock status</dd>
<dt><code class="docutils literal"><span class="pre">get_rf_strength</span></code></dt>
<dd>returns the RF signal strength. Used mostly to support
analog TV and radio. Digital TV should report, instead,
via DVBv5 API (<a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a>.dtv_property_cache).</dd>
<dt><code class="docutils literal"><span class="pre">get_afc</span></code></dt>
<dd>Used only by analog TV core. Reports the frequency
drift due to AFC.</dd>
<dt><code class="docutils literal"><span class="pre">calc_regs</span></code></dt>
<dd>callback function used to pass register data settings
for simple tuners.  Shouldn&#8217;t be used on newer drivers.</dd>
<dt><code class="docutils literal"><span class="pre">set_frequency</span></code></dt>
<dd>Set a new frequency. Shouldn&#8217;t be used on newer drivers.</dd>
<dt><code class="docutils literal"><span class="pre">set_bandwidth</span></code></dt>
<dd>Set a new frequency. Shouldn&#8217;t be used on newer drivers.</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>frequencies used on <strong>get_frequency</strong> and <strong>set_frequency</strong> are in Hz for
terrestrial/cable or kHz for satellite.</p>
<dl class="type">
<dt id="c.analog_demod_info">
struct <code class="descname">analog_demod_info</code><a class="headerlink" href="#c.analog_demod_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Information struct for analog TV part of the demod</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct analog_demod_info {
  char *name;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the analog TV demodulator</dd>
</dl>
<dl class="type">
<dt id="c.analog_demod_ops">
struct <code class="descname">analog_demod_ops</code><a class="headerlink" href="#c.analog_demod_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Demodulation information and callbacks for analog TV and radio</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct analog_demod_ops {
  struct analog_demod_info info;
  void (*set_params)(struct dvb_frontend *fe, struct analog_parameters *params);
  int (*has_signal)(struct dvb_frontend *fe, u16 *signal);
  int (*get_afc)(struct dvb_frontend *fe, s32 *afc);
  void (*tuner_status)(struct dvb_frontend *fe);
  void (*standby)(struct dvb_frontend *fe);
  void (*release)(struct dvb_frontend *fe);
  int (*i2c_gate_ctrl)(struct dvb_frontend *fe, int enable);
  int (*set_config)(struct dvb_frontend *fe, void *priv_cfg);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">info</span></code></dt>
<dd>pointer to struct analog_demod_info</dd>
<dt><code class="docutils literal"><span class="pre">set_params</span></code></dt>
<dd>callback function used to inform the demod to set the
demodulator parameters needed to decode an analog or
radio channel. The properties are passed via
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">analog_params</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">has_signal</span></code></dt>
<dd>returns 0xffff if has signal, or 0 if it doesn&#8217;t.</dd>
<dt><code class="docutils literal"><span class="pre">get_afc</span></code></dt>
<dd>Used only by analog TV core. Reports the frequency
drift due to AFC.</dd>
<dt><code class="docutils literal"><span class="pre">tuner_status</span></code></dt>
<dd>callback function that returns tuner status bits, e. g.
<code class="docutils literal"><span class="pre">TUNER_STATUS_LOCKED</span></code> and <code class="docutils literal"><span class="pre">TUNER_STATUS_STEREO</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">standby</span></code></dt>
<dd>set the tuner to standby mode.</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>callback function called when frontend is detached.
drivers should free any allocated memory.</dd>
<dt><code class="docutils literal"><span class="pre">i2c_gate_ctrl</span></code></dt>
<dd>controls the I2C gate. Newer drivers should use I2C
mux support instead.</dd>
<dt><code class="docutils literal"><span class="pre">set_config</span></code></dt>
<dd>callback function used to send some tuner-specific
parameters.</dd>
</dl>
<dl class="type">
<dt id="c.dvb_frontend_internal_info">
struct <code class="descname">dvb_frontend_internal_info</code><a class="headerlink" href="#c.dvb_frontend_internal_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Frontend properties and capabilities</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct dvb_frontend_internal_info {
  char name[128];
  u32 frequency_min_hz;
  u32 frequency_max_hz;
  u32 frequency_stepsize_hz;
  u32 frequency_tolerance_hz;
  u32 symbol_rate_min;
  u32 symbol_rate_max;
  u32 symbol_rate_tolerance;
  enum fe_caps caps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>Name of the frontend</dd>
<dt><code class="docutils literal"><span class="pre">frequency_min_hz</span></code></dt>
<dd>Minimal frequency supported by the frontend.</dd>
<dt><code class="docutils literal"><span class="pre">frequency_max_hz</span></code></dt>
<dd>Minimal frequency supported by the frontend.</dd>
<dt><code class="docutils literal"><span class="pre">frequency_stepsize_hz</span></code></dt>
<dd>All frequencies are multiple of this value.</dd>
<dt><code class="docutils literal"><span class="pre">frequency_tolerance_hz</span></code></dt>
<dd>Frequency tolerance.</dd>
<dt><code class="docutils literal"><span class="pre">symbol_rate_min</span></code></dt>
<dd>Minimal symbol rate, in bauds
(for Cable/Satellite systems).</dd>
<dt><code class="docutils literal"><span class="pre">symbol_rate_max</span></code></dt>
<dd>Maximal symbol rate, in bauds
(for Cable/Satellite systems).</dd>
<dt><code class="docutils literal"><span class="pre">symbol_rate_tolerance</span></code></dt>
<dd>Maximal symbol rate tolerance, in ppm
(for Cable/Satellite systems).</dd>
<dt><code class="docutils literal"><span class="pre">caps</span></code></dt>
<dd>Capabilities supported by the frontend,
as specified in <a class="reference internal" href="../uapi/dvb/frontend-header.html#c.fe_caps" title="fe_caps"><code class="xref c c-type docutils literal"><span class="pre">enum</span> <span class="pre">fe_caps</span></code></a>.</dd>
</dl>
<dl class="type">
<dt id="c.dvb_frontend_ops">
struct <code class="descname">dvb_frontend_ops</code><a class="headerlink" href="#c.dvb_frontend_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Demodulation information and callbacks for ditialt TV</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct dvb_frontend_ops {
  struct dvb_frontend_internal_info info;
  u8 delsys[MAX_DELSYS];
  void (*detach)(struct dvb_frontend *fe);
  void (*release)(struct dvb_frontend* fe);
  void (*release_sec)(struct dvb_frontend* fe);
  int (*init)(struct dvb_frontend* fe);
  int (*sleep)(struct dvb_frontend* fe);
  int (*write)(struct dvb_frontend* fe, const u8 buf[], int len);
  int (*tune)(struct dvb_frontend* fe,bool re_tune,unsigned int mode_flags,unsigned int *delay, enum fe_status *status);
  enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend *fe);
  int (*set_frontend)(struct dvb_frontend *fe);
  int (*get_tune_settings)(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* settings);
  int (*get_frontend)(struct dvb_frontend *fe, struct dtv_frontend_properties *props);
  int (*read_status)(struct dvb_frontend *fe, enum fe_status *status);
  int (*read_ber)(struct dvb_frontend* fe, u32* ber);
  int (*read_signal_strength)(struct dvb_frontend* fe, u16* strength);
  int (*read_snr)(struct dvb_frontend* fe, u16* snr);
  int (*read_ucblocks)(struct dvb_frontend* fe, u32* ucblocks);
  int (*diseqc_reset_overload)(struct dvb_frontend* fe);
  int (*diseqc_send_master_cmd)(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd);
  int (*diseqc_recv_slave_reply)(struct dvb_frontend* fe, struct dvb_diseqc_slave_reply* reply);
  int (*diseqc_send_burst)(struct dvb_frontend *fe, enum fe_sec_mini_cmd minicmd);
  int (*set_tone)(struct dvb_frontend *fe, enum fe_sec_tone_mode tone);
  int (*set_voltage)(struct dvb_frontend *fe, enum fe_sec_voltage voltage);
  int (*enable_high_lnb_voltage)(struct dvb_frontend* fe, long arg);
  int (*dishnetwork_send_legacy_command)(struct dvb_frontend* fe, unsigned long cmd);
  int (*i2c_gate_ctrl)(struct dvb_frontend* fe, int enable);
  int (*ts_bus_ctrl)(struct dvb_frontend* fe, int acquire);
  int (*set_lna)(struct dvb_frontend *);
  enum dvbfe_search (*search)(struct dvb_frontend *fe);
  struct dvb_tuner_ops tuner_ops;
  struct analog_demod_ops analog_ops;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">info</span></code></dt>
<dd>embedded <a class="reference internal" href="#c.dvb_tuner_info" title="dvb_tuner_info"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_tuner_info</span></code></a> with tuner properties</dd>
<dt><code class="docutils literal"><span class="pre">delsys</span></code></dt>
<dd>Delivery systems supported by the frontend</dd>
<dt><code class="docutils literal"><span class="pre">detach</span></code></dt>
<dd>callback function called when frontend is detached.
drivers should clean up, but not yet free the <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">dvb_frontend</span></code></a> allocation.</dd>
<dt><code class="docutils literal"><span class="pre">release</span></code></dt>
<dd>callback function called when frontend is ready to be
freed.
drivers should free any allocated memory.</dd>
<dt><code class="docutils literal"><span class="pre">release_sec</span></code></dt>
<dd>callback function requesting that the Satelite Equipment
Control (SEC) driver to release and free any memory
allocated by the driver.</dd>
<dt><code class="docutils literal"><span class="pre">init</span></code></dt>
<dd>callback function used to initialize the tuner device.</dd>
<dt><code class="docutils literal"><span class="pre">sleep</span></code></dt>
<dd>callback function used to put the tuner to sleep.</dd>
<dt><code class="docutils literal"><span class="pre">write</span></code></dt>
<dd>callback function used by some demod legacy drivers to
allow other drivers to write data into their registers.
Should not be used on new drivers.</dd>
<dt><code class="docutils literal"><span class="pre">tune</span></code></dt>
<dd>callback function used by demod drivers that use
<strong>DVBFE_ALGO_HW</strong> to tune into a frequency.</dd>
<dt><code class="docutils literal"><span class="pre">get_frontend_algo</span></code></dt>
<dd>returns the desired hardware algorithm.</dd>
<dt><code class="docutils literal"><span class="pre">set_frontend</span></code></dt>
<dd>callback function used to inform the demod to set the
parameters for demodulating a digital TV channel.
The properties to be used are stored at <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span>
<span class="pre">dvb_frontend</span></code></a>.dtv_property_cache. The demod can change
the parameters to reflect the changes needed for the
channel to be decoded, and update statistics.</dd>
<dt><code class="docutils literal"><span class="pre">get_tune_settings</span></code></dt>
<dd>callback function</dd>
<dt><code class="docutils literal"><span class="pre">get_frontend</span></code></dt>
<dd>callback function used to inform the parameters
actuall in use. The properties to be used are stored at
<a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a>.dtv_property_cache and update
statistics. Please notice that it should not return
an error code if the statistics are not available
because the demog is not locked.</dd>
<dt><code class="docutils literal"><span class="pre">read_status</span></code></dt>
<dd>returns the locking status of the frontend.</dd>
<dt><code class="docutils literal"><span class="pre">read_ber</span></code></dt>
<dd>legacy callback function to return the bit error rate.
Newer drivers should provide such info via DVBv5 API,
e. g. <strong>set_frontend</strong>;/<strong>get_frontend</strong>, implementing this
callback only if DVBv3 API compatibility is wanted.</dd>
<dt><code class="docutils literal"><span class="pre">read_signal_strength</span></code></dt>
<dd>legacy callback function to return the signal
strength. Newer drivers should provide such info via
DVBv5 API, e. g. <strong>set_frontend</strong>/<strong>get_frontend</strong>,
implementing this callback only if DVBv3 API
compatibility is wanted.</dd>
<dt><code class="docutils literal"><span class="pre">read_snr</span></code></dt>
<dd>legacy callback function to return the Signal/Noise
rate. Newer drivers should provide such info via
DVBv5 API, e. g. <strong>set_frontend</strong>/<strong>get_frontend</strong>,
implementing this callback only if DVBv3 API
compatibility is wanted.</dd>
<dt><code class="docutils literal"><span class="pre">read_ucblocks</span></code></dt>
<dd>legacy callback function to return the Uncorrected Error
Blocks. Newer drivers should provide such info via
DVBv5 API, e. g. <strong>set_frontend</strong>/<strong>get_frontend</strong>,
implementing this callback only if DVBv3 API
compatibility is wanted.</dd>
<dt><code class="docutils literal"><span class="pre">diseqc_reset_overload</span></code></dt>
<dd>callback function to implement the
<a class="reference internal" href="../uapi/dvb/fe-diseqc-reset-overload.html#c.FE_DISEQC_RESET_OVERLOAD" title="FE_DISEQC_RESET_OVERLOAD"><code class="xref c c-func docutils literal"><span class="pre">FE_DISEQC_RESET_OVERLOAD()</span></code></a> ioctl (only Satellite)</dd>
<dt><code class="docutils literal"><span class="pre">diseqc_send_master_cmd</span></code></dt>
<dd>callback function to implement the
<a class="reference internal" href="../uapi/dvb/fe-diseqc-send-master-cmd.html#c.FE_DISEQC_SEND_MASTER_CMD" title="FE_DISEQC_SEND_MASTER_CMD"><code class="xref c c-func docutils literal"><span class="pre">FE_DISEQC_SEND_MASTER_CMD()</span></code></a> ioctl (only Satellite).</dd>
<dt><code class="docutils literal"><span class="pre">diseqc_recv_slave_reply</span></code></dt>
<dd>callback function to implement the
<a class="reference internal" href="../uapi/dvb/fe-diseqc-recv-slave-reply.html#c.FE_DISEQC_RECV_SLAVE_REPLY" title="FE_DISEQC_RECV_SLAVE_REPLY"><code class="xref c c-func docutils literal"><span class="pre">FE_DISEQC_RECV_SLAVE_REPLY()</span></code></a> ioctl (only Satellite)</dd>
<dt><code class="docutils literal"><span class="pre">diseqc_send_burst</span></code></dt>
<dd>callback function to implement the
<a class="reference internal" href="../uapi/dvb/fe-diseqc-send-burst.html#c.FE_DISEQC_SEND_BURST" title="FE_DISEQC_SEND_BURST"><code class="xref c c-func docutils literal"><span class="pre">FE_DISEQC_SEND_BURST()</span></code></a> ioctl (only Satellite).</dd>
<dt><code class="docutils literal"><span class="pre">set_tone</span></code></dt>
<dd>callback function to implement the
<a class="reference internal" href="../uapi/dvb/fe-set-tone.html#c.FE_SET_TONE" title="FE_SET_TONE"><code class="xref c c-func docutils literal"><span class="pre">FE_SET_TONE()</span></code></a> ioctl (only Satellite).</dd>
<dt><code class="docutils literal"><span class="pre">set_voltage</span></code></dt>
<dd>callback function to implement the
<a class="reference internal" href="../uapi/dvb/fe-set-voltage.html#c.FE_SET_VOLTAGE" title="FE_SET_VOLTAGE"><code class="xref c c-func docutils literal"><span class="pre">FE_SET_VOLTAGE()</span></code></a> ioctl (only Satellite).</dd>
<dt><code class="docutils literal"><span class="pre">enable_high_lnb_voltage</span></code></dt>
<dd>callback function to implement the
<a class="reference internal" href="../uapi/dvb/fe-enable-high-lnb-voltage.html#c.FE_ENABLE_HIGH_LNB_VOLTAGE" title="FE_ENABLE_HIGH_LNB_VOLTAGE"><code class="xref c c-func docutils literal"><span class="pre">FE_ENABLE_HIGH_LNB_VOLTAGE()</span></code></a> ioctl (only Satellite).</dd>
<dt><code class="docutils literal"><span class="pre">dishnetwork_send_legacy_command</span></code></dt>
<dd>callback function to implement the
<a class="reference internal" href="../uapi/dvb/fe-dishnetwork-send-legacy-cmd.html#c.FE_DISHNETWORK_SEND_LEGACY_CMD" title="FE_DISHNETWORK_SEND_LEGACY_CMD"><code class="xref c c-func docutils literal"><span class="pre">FE_DISHNETWORK_SEND_LEGACY_CMD()</span></code></a> ioctl (only Satellite).
Drivers should not use this, except when the DVB
core emulation fails to provide proper support (e.g.
if <strong>set_voltage</strong> takes more than 8ms to work), and
when backward compatibility with this legacy API is
required.</dd>
<dt><code class="docutils literal"><span class="pre">i2c_gate_ctrl</span></code></dt>
<dd>controls the I2C gate. Newer drivers should use I2C
mux support instead.</dd>
<dt><code class="docutils literal"><span class="pre">ts_bus_ctrl</span></code></dt>
<dd>callback function used to take control of the TS bus.</dd>
<dt><code class="docutils literal"><span class="pre">set_lna</span></code></dt>
<dd>callback function to power on/off/auto the LNA.</dd>
<dt><code class="docutils literal"><span class="pre">search</span></code></dt>
<dd>callback function used on some custom algo search algos.</dd>
<dt><code class="docutils literal"><span class="pre">tuner_ops</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_tuner_ops" title="dvb_tuner_ops"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_tuner_ops</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">analog_ops</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.analog_demod_ops" title="analog_demod_ops"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">analog_demod_ops</span></code></a></dd>
</dl>
<dl class="type">
<dt id="c.dtv_frontend_properties">
struct <code class="descname">dtv_frontend_properties</code><a class="headerlink" href="#c.dtv_frontend_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>contains a list of properties that are specific to a digital TV standard.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct dtv_frontend_properties {
  u32 frequency;
  enum fe_modulation      modulation;
  enum fe_sec_voltage     voltage;
  enum fe_sec_tone_mode   sectone;
  enum fe_spectral_inversion inversion;
  enum fe_code_rate       fec_inner;
  enum fe_transmit_mode   transmission_mode;
  u32 bandwidth_hz;
  enum fe_guard_interval  guard_interval;
  enum fe_hierarchy       hierarchy;
  u32 symbol_rate;
  enum fe_code_rate       code_rate_HP;
  enum fe_code_rate       code_rate_LP;
  enum fe_pilot           pilot;
  enum fe_rolloff         rolloff;
  enum fe_delivery_system delivery_system;
  enum fe_interleaving    interleaving;
  u8 isdbt_partial_reception;
  u8 isdbt_sb_mode;
  u8 isdbt_sb_subchannel;
  u32 isdbt_sb_segment_idx;
  u32 isdbt_sb_segment_count;
  u8 isdbt_layer_enabled;
  struct {
    u8 segment_count;
    enum fe_code_rate   fec;
    enum fe_modulation  modulation;
    u8 interleaving;
  } layer[3];
  u32 stream_id;
  u32 scrambling_sequence_index;
  u8 atscmh_fic_ver;
  u8 atscmh_parade_id;
  u8 atscmh_nog;
  u8 atscmh_tnog;
  u8 atscmh_sgn;
  u8 atscmh_prc;
  u8 atscmh_rs_frame_mode;
  u8 atscmh_rs_frame_ensemble;
  u8 atscmh_rs_code_mode_pri;
  u8 atscmh_rs_code_mode_sec;
  u8 atscmh_sccc_block_mode;
  u8 atscmh_sccc_code_mode_a;
  u8 atscmh_sccc_code_mode_b;
  u8 atscmh_sccc_code_mode_c;
  u8 atscmh_sccc_code_mode_d;
  u32 lna;
  struct dtv_fe_stats     strength;
  struct dtv_fe_stats     cnr;
  struct dtv_fe_stats     pre_bit_error;
  struct dtv_fe_stats     pre_bit_count;
  struct dtv_fe_stats     post_bit_error;
  struct dtv_fe_stats     post_bit_count;
  struct dtv_fe_stats     block_error;
  struct dtv_fe_stats     block_count;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">frequency</span></code></dt>
<dd>frequency in Hz for terrestrial/cable or in kHz for
Satellite</dd>
<dt><code class="docutils literal"><span class="pre">modulation</span></code></dt>
<dd>Frontend modulation type</dd>
<dt><code class="docutils literal"><span class="pre">voltage</span></code></dt>
<dd>SEC voltage (only Satellite)</dd>
<dt><code class="docutils literal"><span class="pre">sectone</span></code></dt>
<dd>SEC tone mode (only Satellite)</dd>
<dt><code class="docutils literal"><span class="pre">inversion</span></code></dt>
<dd>Spectral inversion</dd>
<dt><code class="docutils literal"><span class="pre">fec_inner</span></code></dt>
<dd>Forward error correction inner Code Rate</dd>
<dt><code class="docutils literal"><span class="pre">transmission_mode</span></code></dt>
<dd>Transmission Mode</dd>
<dt><code class="docutils literal"><span class="pre">bandwidth_hz</span></code></dt>
<dd>Bandwidth, in Hz. A zero value means that userspace
wants to autodetect.</dd>
<dt><code class="docutils literal"><span class="pre">guard_interval</span></code></dt>
<dd>Guard Interval</dd>
<dt><code class="docutils literal"><span class="pre">hierarchy</span></code></dt>
<dd>Hierarchy</dd>
<dt><code class="docutils literal"><span class="pre">symbol_rate</span></code></dt>
<dd>Symbol Rate</dd>
<dt><code class="docutils literal"><span class="pre">code_rate_HP</span></code></dt>
<dd>high priority stream code rate</dd>
<dt><code class="docutils literal"><span class="pre">code_rate_LP</span></code></dt>
<dd>low priority stream code rate</dd>
<dt><code class="docutils literal"><span class="pre">pilot</span></code></dt>
<dd>Enable/disable/autodetect pilot tones</dd>
<dt><code class="docutils literal"><span class="pre">rolloff</span></code></dt>
<dd>Rolloff factor (alpha)</dd>
<dt><code class="docutils literal"><span class="pre">delivery_system</span></code></dt>
<dd>FE delivery system (e. g. digital TV standard)</dd>
<dt><code class="docutils literal"><span class="pre">interleaving</span></code></dt>
<dd>interleaving</dd>
<dt><code class="docutils literal"><span class="pre">isdbt_partial_reception</span></code></dt>
<dd>ISDB-T partial reception (only ISDB standard)</dd>
<dt><code class="docutils literal"><span class="pre">isdbt_sb_mode</span></code></dt>
<dd>ISDB-T Sound Broadcast (SB) mode (only ISDB standard)</dd>
<dt><code class="docutils literal"><span class="pre">isdbt_sb_subchannel</span></code></dt>
<dd>ISDB-T SB subchannel (only ISDB standard)</dd>
<dt><code class="docutils literal"><span class="pre">isdbt_sb_segment_idx</span></code></dt>
<dd>ISDB-T SB segment index (only ISDB standard)</dd>
<dt><code class="docutils literal"><span class="pre">isdbt_sb_segment_count</span></code></dt>
<dd>ISDB-T SB segment count (only ISDB standard)</dd>
<dt><code class="docutils literal"><span class="pre">isdbt_layer_enabled</span></code></dt>
<dd>ISDB Layer enabled (only ISDB standard)</dd>
<dt><code class="docutils literal"><span class="pre">layer</span></code></dt>
<dd>ISDB per-layer data (only ISDB standard)</dd>
<dt><code class="docutils literal"><span class="pre">layer.segment_count</span></code></dt>
<dd>Segment Count;</dd>
<dt><code class="docutils literal"><span class="pre">layer.fec</span></code></dt>
<dd>per layer code rate;</dd>
<dt><code class="docutils literal"><span class="pre">layer.modulation</span></code></dt>
<dd>per layer modulation;</dd>
<dt><code class="docutils literal"><span class="pre">layer.interleaving</span></code></dt>
<dd>per layer interleaving.</dd>
<dt><code class="docutils literal"><span class="pre">stream_id</span></code></dt>
<dd>If different than zero, enable substream filtering, if
hardware supports (DVB-S2 and DVB-T2).</dd>
<dt><code class="docutils literal"><span class="pre">scrambling_sequence_index</span></code></dt>
<dd>Carries the index of the DVB-S2 physical layer
scrambling sequence.</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_fic_ver</span></code></dt>
<dd>Version number of the FIC (Fast Information Channel)
signaling data (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_parade_id</span></code></dt>
<dd>Parade identification number (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_nog</span></code></dt>
<dd>Number of MH groups per MH subframe for a designated
parade (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_tnog</span></code></dt>
<dd>Total number of MH groups including all MH groups
belonging to all MH parades in one MH subframe
(only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_sgn</span></code></dt>
<dd>Start group number (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_prc</span></code></dt>
<dd>Parade repetition cycle (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_rs_frame_mode</span></code></dt>
<dd>Reed Solomon (RS) frame mode (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_rs_frame_ensemble</span></code></dt>
<dd>RS frame ensemble (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_rs_code_mode_pri</span></code></dt>
<dd>RS code mode pri (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_rs_code_mode_sec</span></code></dt>
<dd>RS code mode sec (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_sccc_block_mode</span></code></dt>
<dd>Series Concatenated Convolutional Code (SCCC)
Block Mode (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_sccc_code_mode_a</span></code></dt>
<dd>SCCC code mode A (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_sccc_code_mode_b</span></code></dt>
<dd>SCCC code mode B (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_sccc_code_mode_c</span></code></dt>
<dd>SCCC code mode C (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">atscmh_sccc_code_mode_d</span></code></dt>
<dd>SCCC code mode D (only ATSC-M/H)</dd>
<dt><code class="docutils literal"><span class="pre">lna</span></code></dt>
<dd>Power ON/OFF/AUTO the Linear Now-noise Amplifier (LNA)</dd>
<dt><code class="docutils literal"><span class="pre">strength</span></code></dt>
<dd>DVBv5 API statistics: Signal Strength</dd>
<dt><code class="docutils literal"><span class="pre">cnr</span></code></dt>
<dd>DVBv5 API statistics: Signal to Noise ratio of the
(main) carrier</dd>
<dt><code class="docutils literal"><span class="pre">pre_bit_error</span></code></dt>
<dd>DVBv5 API statistics: pre-Viterbi bit error count</dd>
<dt><code class="docutils literal"><span class="pre">pre_bit_count</span></code></dt>
<dd>DVBv5 API statistics: pre-Viterbi bit count</dd>
<dt><code class="docutils literal"><span class="pre">post_bit_error</span></code></dt>
<dd>DVBv5 API statistics: post-Viterbi bit error count</dd>
<dt><code class="docutils literal"><span class="pre">post_bit_count</span></code></dt>
<dd>DVBv5 API statistics: post-Viterbi bit count</dd>
<dt><code class="docutils literal"><span class="pre">block_error</span></code></dt>
<dd>DVBv5 API statistics: block error count</dd>
<dt><code class="docutils literal"><span class="pre">block_count</span></code></dt>
<dd>DVBv5 API statistics: block count</dd>
</dl>
<p><strong>NOTE</strong></p>
<p>derivated statistics like Uncorrected Error blocks (UCE) are
calculated on userspace.</p>
<p>Only a subset of the properties are needed for a given delivery system.
For more info, consult the media_api.html with the documentation of the
Userspace API.</p>
<dl class="type">
<dt id="c.dvb_frontend">
struct <code class="descname">dvb_frontend</code><a class="headerlink" href="#c.dvb_frontend" title="Permalink to this definition">¶</a></dt>
<dd><p>Frontend structure to be used on drivers.</p>
</dd></dl>

<p><strong>Definition</strong></p>
<div class="highlight-none"><div class="highlight"><pre>struct dvb_frontend {
  struct kref refcount;
  struct dvb_frontend_ops ops;
  struct dvb_adapter *dvb;
  void *demodulator_priv;
  void *tuner_priv;
  void *frontend_priv;
  void *sec_priv;
  void *analog_demod_priv;
  struct dtv_frontend_properties dtv_property_cache;
#define DVB_FRONTEND_COMPONENT_TUNER 0;
#define DVB_FRONTEND_COMPONENT_DEMOD 1;
  int (*callback)(void *adapter_priv, int component, int cmd, int arg);
  int id;
  unsigned int exit;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">refcount</span></code></dt>
<dd>refcount to keep track of <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a>
references</dd>
<dt><code class="docutils literal"><span class="pre">ops</span></code></dt>
<dd>embedded <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend_ops</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">dvb</span></code></dt>
<dd>pointer to <a class="reference internal" href="dtv-common.html#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">demodulator_priv</span></code></dt>
<dd>demod private data</dd>
<dt><code class="docutils literal"><span class="pre">tuner_priv</span></code></dt>
<dd>tuner private data</dd>
<dt><code class="docutils literal"><span class="pre">frontend_priv</span></code></dt>
<dd>frontend private data</dd>
<dt><code class="docutils literal"><span class="pre">sec_priv</span></code></dt>
<dd>SEC private data</dd>
<dt><code class="docutils literal"><span class="pre">analog_demod_priv</span></code></dt>
<dd>Analog demod private data</dd>
<dt><code class="docutils literal"><span class="pre">dtv_property_cache</span></code></dt>
<dd>embedded <a class="reference internal" href="#c.dtv_frontend_properties" title="dtv_frontend_properties"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dtv_frontend_properties</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">callback</span></code></dt>
<dd>callback function used on some drivers to call
either the tuner or the demodulator.</dd>
<dt><code class="docutils literal"><span class="pre">id</span></code></dt>
<dd>Frontend ID</dd>
<dt><code class="docutils literal"><span class="pre">exit</span></code></dt>
<dd>Used to inform the DVB core that the frontend
thread should exit (usually, means that the hardware
got disconnected.</dd>
</dl>
<dl class="function">
<dt id="c.dvb_register_frontend">
int <code class="descname">dvb_register_frontend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="dtv-common.html#c.dvb_adapter" title="dvb_adapter">dvb_adapter</a> *<em>&nbsp;dvb</em>, struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a> *<em>&nbsp;fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_register_frontend" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a DVB frontend at the adapter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span> <span class="pre">*</span> <span class="pre">dvb</span></code></dt>
<dd>pointer to <a class="reference internal" href="dtv-common.html#c.dvb_adapter" title="dvb_adapter"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_adapter</span></code></a></dd>
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*</span> <span class="pre">fe</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Allocate and initialize the private data needed by the frontend core to
manage the frontend and calls <a class="reference internal" href="dtv-common.html#c.dvb_register_device" title="dvb_register_device"><code class="xref c c-func docutils literal"><span class="pre">dvb_register_device()</span></code></a> to register a new
frontend. It also cleans the property cache that stores the frontend
parameters and selects the first available delivery system.</p>
<dl class="function">
<dt id="c.dvb_unregister_frontend">
int <code class="descname">dvb_unregister_frontend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a> *<em>&nbsp;fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_unregister_frontend" title="Permalink to this definition">¶</a></dt>
<dd><p>Unregisters a DVB frontend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*</span> <span class="pre">fe</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Stops the frontend kthread, calls <a class="reference internal" href="dtv-common.html#c.dvb_unregister_device" title="dvb_unregister_device"><code class="xref c c-func docutils literal"><span class="pre">dvb_unregister_device()</span></code></a> and frees the
private frontend data allocated by <a class="reference internal" href="#c.dvb_register_frontend" title="dvb_register_frontend"><code class="xref c c-func docutils literal"><span class="pre">dvb_register_frontend()</span></code></a>.</p>
<p><strong>NOTE</strong></p>
<p>This function doesn&#8217;t frees the memory allocated by the demod,
by the SEC driver and by the tuner. In order to free it, an explicit call to
<a class="reference internal" href="#c.dvb_frontend_detach" title="dvb_frontend_detach"><code class="xref c c-func docutils literal"><span class="pre">dvb_frontend_detach()</span></code></a> is needed, after calling this function.</p>
<dl class="function">
<dt id="c.dvb_frontend_detach">
void <code class="descname">dvb_frontend_detach</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a> *<em>&nbsp;fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_detach" title="Permalink to this definition">¶</a></dt>
<dd><p>Detaches and frees frontend specific data</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*</span> <span class="pre">fe</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function should be called after <a class="reference internal" href="#c.dvb_unregister_frontend" title="dvb_unregister_frontend"><code class="xref c c-func docutils literal"><span class="pre">dvb_unregister_frontend()</span></code></a>. It
calls the SEC, tuner and demod release functions:
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.release_sec</span></code></a>, <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.release,
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.analog_ops</span></code></a>.release and <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.release</span></code></a>.</p>
<p>If the driver is compiled with <code class="docutils literal"><span class="pre">CONFIG_MEDIA_ATTACH</span></code>, it also decreases
the module reference count, needed to allow userspace to remove the
previously used DVB frontend modules.</p>
<dl class="function">
<dt id="c.dvb_frontend_suspend">
int <code class="descname">dvb_frontend_suspend</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a> *<em>&nbsp;fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_suspend" title="Permalink to this definition">¶</a></dt>
<dd><p>Suspends a Digital TV frontend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*</span> <span class="pre">fe</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function prepares a Digital TV frontend to suspend.</p>
<p>In order to prepare the tuner to suspend, if
<a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.suspend() is available, it calls it. Otherwise,
it will call <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.sleep(), if available.</p>
<p>It will also call <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.sleep</span></code></a>() to put the demod to suspend.</p>
<p>The drivers should also call dvb_frontend_suspend() as part of their
handler for the <a class="reference internal" href="../../driver-api/infrastructure.html#c.device_driver" title="device_driver"><code class="xref c c-type docutils literal"><span class="pre">device_driver.suspend</span></code></a>().</p>
<dl class="function">
<dt id="c.dvb_frontend_resume">
int <code class="descname">dvb_frontend_resume</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a> *<em>&nbsp;fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resumes a Digital TV frontend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*</span> <span class="pre">fe</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>This function resumes the usual operation of the tuner after resume.</p>
<p>In order to resume the frontend, it calls the demod <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.init</span></code></a>().</p>
<p>If <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.resume() is available, It, it calls it.
Otherwise,t will call <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.init(), if available.</p>
<p>Once tuner and demods are resumed, it will enforce that the SEC voltage and
tone are restored to their previous values and wake up the frontend&#8217;s
kthread in order to retune the frontend.</p>
<p>The drivers should also call <a class="reference internal" href="#c.dvb_frontend_resume" title="dvb_frontend_resume"><code class="xref c c-func docutils literal"><span class="pre">dvb_frontend_resume()</span></code></a> as part of their
handler for the <a class="reference internal" href="../../driver-api/infrastructure.html#c.device_driver" title="device_driver"><code class="xref c c-type docutils literal"><span class="pre">device_driver.resume</span></code></a>().</p>
<dl class="function">
<dt id="c.dvb_frontend_reinitialise">
void <code class="descname">dvb_frontend_reinitialise</code><span class="sig-paren">(</span>struct <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend">dvb_frontend</a> *<em>&nbsp;fe</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_reinitialise" title="Permalink to this definition">¶</a></dt>
<dd><p>forces a reinitialisation at the frontend</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span> <span class="pre">*</span> <span class="pre">fe</span></code></dt>
<dd>pointer to <a class="reference internal" href="#c.dvb_frontend" title="dvb_frontend"><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dvb_frontend</span></code></a></dd>
</dl>
<p><strong>Description</strong></p>
<p>Calls <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.init</span></code></a>() and <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.tuner_ops</span></code></a>.init(),
and resets SEC tone and voltage (for Satellite systems).</p>
<p><strong>NOTE</strong></p>
<p>Currently, this function is used only by one driver (budget-av).
It seems to be due to address some special issue with that specific
frontend.</p>
<dl class="function">
<dt id="c.dvb_frontend_sleep_until">
void <code class="descname">dvb_frontend_sleep_until</code><span class="sig-paren">(</span>ktime_t *<em>&nbsp;waketime</em>, u32<em>&nbsp;add_usec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.dvb_frontend_sleep_until" title="Permalink to this definition">¶</a></dt>
<dd><p>Sleep for the amount of time given by add_usec parameter</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">ktime_t</span> <span class="pre">*</span> <span class="pre">waketime</span></code></dt>
<dd>pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">ktime_t</span></code></dd>
<dt><code class="docutils literal"><span class="pre">u32</span> <span class="pre">add_usec</span></code></dt>
<dd>time to sleep, in microseconds</dd>
</dl>
<p><strong>Description</strong></p>
<p>This function is used to measure the time required for the
<a class="reference internal" href="../uapi/dvb/fe-dishnetwork-send-legacy-cmd.html#c.FE_DISHNETWORK_SEND_LEGACY_CMD" title="FE_DISHNETWORK_SEND_LEGACY_CMD"><code class="xref c c-func docutils literal"><span class="pre">FE_DISHNETWORK_SEND_LEGACY_CMD()</span></code></a> ioctl to work. It needs to be as precise
as possible, as it affects the detection of the dish tone command at the
satellite subsystem.</p>
<p>Its used internally by the DVB frontend core, in order to emulate
<a class="reference internal" href="../uapi/dvb/fe-dishnetwork-send-legacy-cmd.html#c.FE_DISHNETWORK_SEND_LEGACY_CMD" title="FE_DISHNETWORK_SEND_LEGACY_CMD"><code class="xref c c-func docutils literal"><span class="pre">FE_DISHNETWORK_SEND_LEGACY_CMD()</span></code></a> using the <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.set_voltage</span></code></a>()
callback.</p>
<p><strong>NOTE</strong></p>
<p>it should not be used at the drivers, as the emulation for the
legacy callback is provided by the Kernel. The only situation where this
should be at the drivers is when there are some bugs at the hardware that
would prevent the core emulation to work. On such cases, the driver would
be writing a <a class="reference internal" href="#c.dvb_frontend_ops" title="dvb_frontend_ops"><code class="xref c c-type docutils literal"><span class="pre">dvb_frontend_ops.dishnetwork_send_legacy_command</span></code></a>() and
calling this function directly.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dtv-demux.html" class="btn btn-neutral float-right" title="2.3. Digital TV Demux kABI" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dtv-common.html" class="btn btn-neutral" title="2.1. Digital TV Common functions" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>