

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1.13. Videobuf Framework &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/>
        <link rel="up" title="1. Video4Linux devices" href="v4l2-core.html"/>
        <link rel="next" title="1.14. V4L2 videobuf2 functions and data structures" href="v4l2-videobuf2.html"/>
        <link rel="prev" title="1.12. V4L2 Controls" href="v4l2-controls.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="v4l2-core.html">1. Video4Linux devices</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html">1.1. Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html#structure-of-a-v4l-driver">1.2. Structure of a V4L driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-intro.html#structure-of-the-v4l2-framework">1.3. Structure of the V4L2 framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-dev.html">1.4. Video device&#8217; s internal representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-device.html">1.5. V4L2 device instance</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-fh.html">1.6. V4L2 File handlers</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html">1.7. V4L2 sub-devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#v4l2-sub-device-userspace-api">1.8. V4L2 sub-device userspace API</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#i2c-sub-device-drivers">1.9. I2C sub-device drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-subdev.html#v4l2-sub-device-functions-and-data-structures">1.10. V4L2 sub-device functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-event.html">1.11. V4L2 events</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-controls.html">1.12. V4L2 Controls</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="">1.13. Videobuf Framework</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-videobuf2.html">1.14. V4L2 videobuf2 functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-clocks.html">1.15. V4L2 clocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-dv-timings.html">1.16. V4L2 DV Timings functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-flash-led-class.html">1.17. V4L2 flash functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mc.html">1.18. V4L2 Media Controller functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mediabus.html">1.19. V4L2 Media Bus functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-mem2mem.html">1.20. V4L2 Memory to Memory functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-async.html">1.21. V4L2 async kAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-fwnode.html">1.22. V4L2 fwnode kAPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-rect.html">1.23. V4L2 rect helper functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-tuner.html">1.24. Tuner functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-common.html">1.25. V4L2 common functions and data structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2-tveeprom.html">1.26. Hauppauge TV EEPROM functions and data structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dtv-core.html">2. Digital TV (DVB) devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="rc-core.html">3. Remote Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="mc-core.html">4. Media Controller devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="cec-core.html">5. CEC Kernel Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="csi2.html">6. MIPI CSI-2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
      
          <li><a href="../media_kapi.html">Media subsystem kernel internal API</a> &raquo;</li>
      
          <li><a href="v4l2-core.html">1. Video4Linux devices</a> &raquo;</li>
      
    <li>1.13. Videobuf Framework</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/media/kapi/v4l2-videobuf.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="videobuf-framework">
<span id="vb-framework"></span><h1>1.13. Videobuf Framework<a class="headerlink" href="#videobuf-framework" title="Permalink to this headline">¶</a></h1>
<p>Author: Jonathan Corbet &lt;<a class="reference external" href="mailto:corbet&#37;&#52;&#48;lwn&#46;net">corbet<span>&#64;</span>lwn<span>&#46;</span>net</a>&gt;</p>
<p>Current as of 2.6.33</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The videobuf framework was deprecated in favor of videobuf2. Shouldn&#8217;t
be used on new drivers.</p>
</div>
<div class="section" id="introduction">
<h2>1.13.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The videobuf layer functions as a sort of glue layer between a V4L2 driver
and user space.  It handles the allocation and management of buffers for
the storage of video frames.  There is a set of functions which can be used
to implement many of the standard POSIX I/O system calls, including read(),
poll(), and, happily, mmap().  Another set of functions can be used to
implement the bulk of the V4L2 ioctl() calls related to streaming I/O,
including buffer allocation, queueing and dequeueing, and streaming
control.  Using videobuf imposes a few design decisions on the driver
author, but the payback comes in the form of reduced code in the driver and
a consistent implementation of the V4L2 user-space API.</p>
</div>
<div class="section" id="buffer-types">
<h2>1.13.2. Buffer types<a class="headerlink" href="#buffer-types" title="Permalink to this headline">¶</a></h2>
<p>Not all video devices use the same kind of buffers.  In fact, there are (at
least) three common variations:</p>
<blockquote>
<div><ul class="simple">
<li>Buffers which are scattered in both the physical and (kernel) virtual
address spaces.  (Almost) all user-space buffers are like this, but it
makes great sense to allocate kernel-space buffers this way as well when
it is possible.  Unfortunately, it is not always possible; working with
this kind of buffer normally requires hardware which can do
scatter/gather DMA operations.</li>
<li>Buffers which are physically scattered, but which are virtually
contiguous; buffers allocated with vmalloc(), in other words.  These
buffers are just as hard to use for DMA operations, but they can be
useful in situations where DMA is not available but virtually-contiguous
buffers are convenient.</li>
<li>Buffers which are physically contiguous.  Allocation of this kind of
buffer can be unreliable on fragmented systems, but simpler DMA
controllers cannot deal with anything else.</li>
</ul>
</div></blockquote>
<p>Videobuf can work with all three types of buffers, but the driver author
must pick one at the outset and design the driver around that decision.</p>
<p>[It&#8217;s worth noting that there&#8217;s a fourth kind of buffer: &#8220;overlay&#8221; buffers
which are located within the system&#8217;s video memory.  The overlay
functionality is considered to be deprecated for most use, but it still
shows up occasionally in system-on-chip drivers where the performance
benefits merit the use of this technique.  Overlay buffers can be handled
as a form of scattered buffer, but there are very few implementations in
the kernel and a description of this technique is currently beyond the
scope of this document.]</p>
</div>
<div class="section" id="data-structures-callbacks-and-initialization">
<h2>1.13.3. Data structures, callbacks, and initialization<a class="headerlink" href="#data-structures-callbacks-and-initialization" title="Permalink to this headline">¶</a></h2>
<p>Depending on which type of buffers are being used, the driver should
include one of the following files:</p>
<div class="highlight-none"><div class="highlight"><pre>&lt;media/videobuf-dma-sg.h&gt;           /* Physically scattered */
&lt;media/videobuf-vmalloc.h&gt;          /* vmalloc() buffers    */
&lt;media/videobuf-dma-contig.h&gt;       /* Physically contiguous */
</pre></div>
</div>
<p>The driver&#8217;s data structure describing a V4L2 device should include a
struct videobuf_queue instance for the management of the buffer queue,
along with a list_head for the queue of available buffers.  There will also
need to be an interrupt-safe spinlock which is used to protect (at least)
the queue.</p>
<p>The next step is to write four simple callbacks to help videobuf deal with
the management of buffers:</p>
<div class="highlight-none"><div class="highlight"><pre>struct videobuf_queue_ops {
    int (*buf_setup)(struct videobuf_queue *q,
                     unsigned int *count, unsigned int *size);
    int (*buf_prepare)(struct videobuf_queue *q,
                       struct videobuf_buffer *vb,
                       enum v4l2_field field);
    void (*buf_queue)(struct videobuf_queue *q,
                      struct videobuf_buffer *vb);
    void (*buf_release)(struct videobuf_queue *q,
                        struct videobuf_buffer *vb);
};
</pre></div>
</div>
<p>buf_setup() is called early in the I/O process, when streaming is being
initiated; its purpose is to tell videobuf about the I/O stream.  The count
parameter will be a suggested number of buffers to use; the driver should
check it for rationality and adjust it if need be.  As a practical rule, a
minimum of two buffers are needed for proper streaming, and there is
usually a maximum (which cannot exceed 32) which makes sense for each
device.  The size parameter should be set to the expected (maximum) size
for each frame of data.</p>
<p>Each buffer (in the form of a struct videobuf_buffer pointer) will be
passed to buf_prepare(), which should set the buffer&#8217;s size, width, height,
and field fields properly.  If the buffer&#8217;s state field is
VIDEOBUF_NEEDS_INIT, the driver should pass it to:</p>
<div class="highlight-none"><div class="highlight"><pre>int videobuf_iolock(struct videobuf_queue* q, struct videobuf_buffer *vb,
                    struct v4l2_framebuffer *fbuf);
</pre></div>
</div>
<p>Among other things, this call will usually allocate memory for the buffer.
Finally, the buf_prepare() function should set the buffer&#8217;s state to
VIDEOBUF_PREPARED.</p>
<p>When a buffer is queued for I/O, it is passed to buf_queue(), which should
put it onto the driver&#8217;s list of available buffers and set its state to
VIDEOBUF_QUEUED.  Note that this function is called with the queue spinlock
held; if it tries to acquire it as well things will come to a screeching
halt.  Yes, this is the voice of experience.  Note also that videobuf may
wait on the first buffer in the queue; placing other buffers in front of it
could again gum up the works.  So use list_add_tail() to enqueue buffers.</p>
<p>Finally, buf_release() is called when a buffer is no longer intended to be
used.  The driver should ensure that there is no I/O active on the buffer,
then pass it to the appropriate free routine(s):</p>
<div class="highlight-none"><div class="highlight"><pre>/* Scatter/gather drivers */
int videobuf_dma_unmap(struct videobuf_queue *q,
                       struct videobuf_dmabuf *dma);
int videobuf_dma_free(struct videobuf_dmabuf *dma);

/* vmalloc drivers */
void videobuf_vmalloc_free (struct videobuf_buffer *buf);

/* Contiguous drivers */
void videobuf_dma_contig_free(struct videobuf_queue *q,
                              struct videobuf_buffer *buf);
</pre></div>
</div>
<p>One way to ensure that a buffer is no longer under I/O is to pass it to:</p>
<div class="highlight-none"><div class="highlight"><pre>int videobuf_waiton(struct videobuf_buffer *vb, int non_blocking, int intr);
</pre></div>
</div>
<p>Here, vb is the buffer, non_blocking indicates whether non-blocking I/O
should be used (it should be zero in the buf_release() case), and intr
controls whether an interruptible wait is used.</p>
</div>
<div class="section" id="file-operations">
<h2>1.13.4. File operations<a class="headerlink" href="#file-operations" title="Permalink to this headline">¶</a></h2>
<p>At this point, much of the work is done; much of the rest is slipping
videobuf calls into the implementation of the other driver callbacks.  The
first step is in the open() function, which must initialize the
videobuf queue.  The function to use depends on the type of buffer used:</p>
<div class="highlight-none"><div class="highlight"><pre>void videobuf_queue_sg_init(struct videobuf_queue *q,
                            struct videobuf_queue_ops *ops,
                            struct device *dev,
                            spinlock_t *irqlock,
                            enum v4l2_buf_type type,
                            enum v4l2_field field,
                            unsigned int msize,
                            void *priv);

void videobuf_queue_vmalloc_init(struct videobuf_queue *q,
                            struct videobuf_queue_ops *ops,
                            struct device *dev,
                            spinlock_t *irqlock,
                            enum v4l2_buf_type type,
                            enum v4l2_field field,
                            unsigned int msize,
                            void *priv);

void videobuf_queue_dma_contig_init(struct videobuf_queue *q,
                                   struct videobuf_queue_ops *ops,
                                   struct device *dev,
                                   spinlock_t *irqlock,
                                   enum v4l2_buf_type type,
                                   enum v4l2_field field,
                                   unsigned int msize,
                                   void *priv);
</pre></div>
</div>
<p>In each case, the parameters are the same: q is the queue structure for the
device, ops is the set of callbacks as described above, dev is the device
structure for this video device, irqlock is an interrupt-safe spinlock to
protect access to the data structures, type is the buffer type used by the
device (cameras will use V4L2_BUF_TYPE_VIDEO_CAPTURE, for example), field
describes which field is being captured (often V4L2_FIELD_NONE for
progressive devices), msize is the size of any containing structure used
around struct videobuf_buffer, and priv is a private data pointer which
shows up in the priv_data field of struct videobuf_queue.  Note that these
are void functions which, evidently, are immune to failure.</p>
<p>V4L2 capture drivers can be written to support either of two APIs: the
read() system call and the rather more complicated streaming mechanism.  As
a general rule, it is necessary to support both to ensure that all
applications have a chance of working with the device.  Videobuf makes it
easy to do that with the same code.  To implement read(), the driver need
only make a call to one of:</p>
<div class="highlight-none"><div class="highlight"><pre>ssize_t videobuf_read_one(struct videobuf_queue *q,
                          char __user *data, size_t count,
                          loff_t *ppos, int nonblocking);

ssize_t videobuf_read_stream(struct videobuf_queue *q,
                             char __user *data, size_t count,
                             loff_t *ppos, int vbihack, int nonblocking);
</pre></div>
</div>
<p>Either one of these functions will read frame data into data, returning the
amount actually read; the difference is that videobuf_read_one() will only
read a single frame, while videobuf_read_stream() will read multiple frames
if they are needed to satisfy the count requested by the application.  A
typical driver read() implementation will start the capture engine, call
one of the above functions, then stop the engine before returning (though a
smarter implementation might leave the engine running for a little while in
anticipation of another read() call happening in the near future).</p>
<p>The poll() function can usually be implemented with a direct call to:</p>
<div class="highlight-none"><div class="highlight"><pre>unsigned int videobuf_poll_stream(struct file *file,
                                  struct videobuf_queue *q,
                                  poll_table *wait);
</pre></div>
</div>
<p>Note that the actual wait queue eventually used will be the one associated
with the first available buffer.</p>
<p>When streaming I/O is done to kernel-space buffers, the driver must support
the mmap() system call to enable user space to access the data.  In many
V4L2 drivers, the often-complex mmap() implementation simplifies to a
single call to:</p>
<div class="highlight-none"><div class="highlight"><pre>int videobuf_mmap_mapper(struct videobuf_queue *q,
                         struct vm_area_struct *vma);
</pre></div>
</div>
<p>Everything else is handled by the videobuf code.</p>
<p>The release() function requires two separate videobuf calls:</p>
<div class="highlight-none"><div class="highlight"><pre>void videobuf_stop(struct videobuf_queue *q);
int videobuf_mmap_free(struct videobuf_queue *q);
</pre></div>
</div>
<p>The call to videobuf_stop() terminates any I/O in progress - though it is
still up to the driver to stop the capture engine.  The call to
videobuf_mmap_free() will ensure that all buffers have been unmapped; if
so, they will all be passed to the buf_release() callback.  If buffers
remain mapped, videobuf_mmap_free() returns an error code instead.  The
purpose is clearly to cause the closing of the file descriptor to fail if
buffers are still mapped, but every driver in the 2.6.32 kernel cheerfully
ignores its return value.</p>
</div>
<div class="section" id="ioctl-operations">
<h2>1.13.5. ioctl() operations<a class="headerlink" href="#ioctl-operations" title="Permalink to this headline">¶</a></h2>
<p>The V4L2 API includes a very long list of driver callbacks to respond to
the many ioctl() commands made available to user space.  A number of these
- those associated with streaming I/O - turn almost directly into videobuf
calls.  The relevant helper functions are:</p>
<div class="highlight-none"><div class="highlight"><pre>int videobuf_reqbufs(struct videobuf_queue *q,
                     struct v4l2_requestbuffers *req);
int videobuf_querybuf(struct videobuf_queue *q, struct v4l2_buffer *b);
int videobuf_qbuf(struct videobuf_queue *q, struct v4l2_buffer *b);
int videobuf_dqbuf(struct videobuf_queue *q, struct v4l2_buffer *b,
                   int nonblocking);
int videobuf_streamon(struct videobuf_queue *q);
int videobuf_streamoff(struct videobuf_queue *q);
</pre></div>
</div>
<p>So, for example, a VIDIOC_REQBUFS call turns into a call to the driver&#8217;s
vidioc_reqbufs() callback which, in turn, usually only needs to locate the
proper struct videobuf_queue pointer and pass it to videobuf_reqbufs().
These support functions can replace a great deal of buffer management
boilerplate in a lot of V4L2 drivers.</p>
<p>The vidioc_streamon() and vidioc_streamoff() functions will be a bit more
complex, of course, since they will also need to deal with starting and
stopping the capture engine.</p>
</div>
<div class="section" id="buffer-allocation">
<h2>1.13.6. Buffer allocation<a class="headerlink" href="#buffer-allocation" title="Permalink to this headline">¶</a></h2>
<p>Thus far, we have talked about buffers, but have not looked at how they are
allocated.  The scatter/gather case is the most complex on this front.  For
allocation, the driver can leave buffer allocation entirely up to the
videobuf layer; in this case, buffers will be allocated as anonymous
user-space pages and will be very scattered indeed.  If the application is
using user-space buffers, no allocation is needed; the videobuf layer will
take care of calling get_user_pages() and filling in the scatterlist array.</p>
<p>If the driver needs to do its own memory allocation, it should be done in
the vidioc_reqbufs() function, <em>after</em> calling videobuf_reqbufs().  The
first step is a call to:</p>
<div class="highlight-none"><div class="highlight"><pre>struct videobuf_dmabuf *videobuf_to_dma(struct videobuf_buffer *buf);
</pre></div>
</div>
<p>The returned videobuf_dmabuf structure (defined in
&lt;media/videobuf-dma-sg.h&gt;) includes a couple of relevant fields:</p>
<div class="highlight-none"><div class="highlight"><pre>struct scatterlist  *sglist;
int                 sglen;
</pre></div>
</div>
<p>The driver must allocate an appropriately-sized scatterlist array and
populate it with pointers to the pieces of the allocated buffer; sglen
should be set to the length of the array.</p>
<p>Drivers using the vmalloc() method need not (and cannot) concern themselves
with buffer allocation at all; videobuf will handle those details.  The
same is normally true of contiguous-DMA drivers as well; videobuf will
allocate the buffers (with dma_alloc_coherent()) when it sees fit.  That
means that these drivers may be trying to do high-order allocations at any
time, an operation which is not always guaranteed to work.  Some drivers
play tricks by allocating DMA space at system boot time; videobuf does not
currently play well with those drivers.</p>
<p>As of 2.6.31, contiguous-DMA drivers can work with a user-supplied buffer,
as long as that buffer is physically contiguous.  Normal user-space
allocations will not meet that criterion, but buffers obtained from other
kernel drivers, or those contained within huge pages, will work with these
drivers.</p>
</div>
<div class="section" id="filling-the-buffers">
<h2>1.13.7. Filling the buffers<a class="headerlink" href="#filling-the-buffers" title="Permalink to this headline">¶</a></h2>
<p>The final part of a videobuf implementation has no direct callback - it&#8217;s
the portion of the code which actually puts frame data into the buffers,
usually in response to interrupts from the device.  For all types of
drivers, this process works approximately as follows:</p>
<blockquote>
<div><ul class="simple">
<li>Obtain the next available buffer and make sure that somebody is actually
waiting for it.</li>
<li>Get a pointer to the memory and put video data there.</li>
<li>Mark the buffer as done and wake up the process waiting for it.</li>
</ul>
</div></blockquote>
<p>Step (1) above is done by looking at the driver-managed list_head structure
- the one which is filled in the buf_queue() callback.  Because starting
the engine and enqueueing buffers are done in separate steps, it&#8217;s possible
for the engine to be running without any buffers available - in the
vmalloc() case especially.  So the driver should be prepared for the list
to be empty.  It is equally possible that nobody is yet interested in the
buffer; the driver should not remove it from the list or fill it until a
process is waiting on it.  That test can be done by examining the buffer&#8217;s
done field (a wait_queue_head_t structure) with waitqueue_active().</p>
<p>A buffer&#8217;s state should be set to VIDEOBUF_ACTIVE before being mapped for
DMA; that ensures that the videobuf layer will not try to do anything with
it while the device is transferring data.</p>
<p>For scatter/gather drivers, the needed memory pointers will be found in the
scatterlist structure described above.  Drivers using the vmalloc() method
can get a memory pointer with:</p>
<div class="highlight-none"><div class="highlight"><pre>void *videobuf_to_vmalloc(struct videobuf_buffer *buf);
</pre></div>
</div>
<p>For contiguous DMA drivers, the function to use is:</p>
<div class="highlight-none"><div class="highlight"><pre>dma_addr_t videobuf_to_dma_contig(struct videobuf_buffer *buf);
</pre></div>
</div>
<p>The contiguous DMA API goes out of its way to hide the kernel-space address
of the DMA buffer from drivers.</p>
<p>The final step is to set the size field of the relevant videobuf_buffer
structure to the actual size of the captured image, set state to
VIDEOBUF_DONE, then call wake_up() on the done queue.  At this point, the
buffer is owned by the videobuf layer and the driver should not touch it
again.</p>
<p>Developers who are interested in more information can go into the relevant
header files; there are a few low-level functions declared there which have
not been talked about here.  Also worthwhile is the vivi driver
(drivers/media/platform/vivi.c), which is maintained as an example of how V4L2
drivers should be written.  Vivi only uses the vmalloc() API, but it&#8217;s good
enough to get started with.  Note also that all of these calls are exported
GPL-only, so they will not be available to non-GPL kernel modules.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="v4l2-videobuf2.html" class="btn btn-neutral float-right" title="1.14. V4L2 videobuf2 functions and data structures" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="v4l2-controls.html" class="btn btn-neutral" title="1.12. V4L2 Controls" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>