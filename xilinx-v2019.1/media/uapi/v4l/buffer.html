

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3.6. Buffers &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../../index.html"/>
        <link rel="up" title="3. Input/Output" href="io.html"/>
        <link rel="next" title="3.7. Field Order" href="field-order.html"/>
        <link rel="prev" title="3.5. Asynchronous I/O" href="async.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../media_uapi.html">Linux Media Infrastructure userspace API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="v4l2.html">Part I - Video for Linux API</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="common.html">1. Common API Elements</a></li>
<li class="toctree-l4"><a class="reference internal" href="pixfmt.html">2. Image Formats</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="io.html">3. Input/Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="devices.html">4. Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="libv4l.html">5. Libv4l Userspace Library</a></li>
<li class="toctree-l4"><a class="reference internal" href="compat.html">6. Changes</a></li>
<li class="toctree-l4"><a class="reference internal" href="user-func.html">7. Function Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="common-defs.html">8. Common definitions for V4L2 and V4L2 subdev interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="videodev.html">9. Video For Linux Two Header File</a></li>
<li class="toctree-l4"><a class="reference internal" href="capture-example.html">10. Video Capture Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2grab-example.html">11. Video Grabber example using libv4l</a></li>
<li class="toctree-l4"><a class="reference internal" href="biblio.html">12. References</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2.html#revision-and-copyright">Revision and Copyright</a></li>
<li class="toctree-l4"><a class="reference internal" href="v4l2.html#revision-history">Revision History</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../dvb/dvbapi.html">Part II - Digital TV API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rc/remote_controllers.html">Part III - Remote Controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mediactl/media-controller.html">Part IV - Media Controller API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cec/cec-api.html">Part V - Consumer Electronics Control API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gen-errors.html">Generic Error Codes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fdl-appendix.html">GNU Free Documentation License</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../media_kapi.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../v4l-drivers/index.html">Video4Linux (V4L)  driver-specific documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
      
          <li><a href="../../media_uapi.html">Linux Media Infrastructure userspace API</a> &raquo;</li>
      
          <li><a href="v4l2.html">Part I - Video for Linux API</a> &raquo;</li>
      
          <li><a href="io.html">3. Input/Output</a> &raquo;</li>
      
    <li>3.6. Buffers</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../_sources/media/uapi/v4l/buffer.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="buffers">
<span id="buffer"></span><h1>3.6. Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h1>
<p>A buffer contains data exchanged by application and driver using one of
the Streaming I/O methods. In the multi-planar API, the data is held in
planes, while the buffer structure acts as a container for the planes.
Only pointers to buffers (planes) are exchanged, the data itself is not
copied. These pointers, together with meta-information like timestamps
or field parity, are stored in a struct <a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a>,
argument to the <a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span>ioctl VIDIOC_QUERYBUF</span></a>,
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>VIDIOC_QBUF</span></a> and
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>VIDIOC_DQBUF</span></a> ioctl. In the multi-planar API,
some plane-specific members of struct <a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a>,
such as pointers and sizes for each plane, are stored in struct
struct <a class="reference internal" href="#c.v4l2_plane" title="v4l2_plane"><code class="xref c c-type docutils literal"><span class="pre">v4l2_plane</span></code></a> instead. In that case, struct
struct <a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a> contains an array of plane structures.</p>
<p>Dequeued video buffers come with timestamps. The driver decides at which
part of the frame and with which clock the timestamp is taken. Please
see flags in the masks <code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_MASK</span></code> and
<code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TSTAMP_SRC_MASK</span></code> in <a class="reference internal" href="#buffer-flags"><span>Buffer Flags</span></a>. These flags
are always valid and constant across all buffers during the whole video
stream. Changes in these flags may take place as a side effect of
<a class="reference internal" href="vidioc-g-input.html#vidioc-g-input"><span>VIDIOC_S_INPUT</span></a> or
<a class="reference internal" href="vidioc-g-output.html#vidioc-g-output"><span>VIDIOC_S_OUTPUT</span></a> however. The
<code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_COPY</span></code> timestamp type which is used by e.g. on
mem-to-mem devices is an exception to the rule: the timestamp source
flags are copied from the OUTPUT video buffer to the CAPTURE video
buffer.</p>
<div class="section" id="interactions-between-formats-controls-and-buffers">
<h2>3.6.1. Interactions between formats, controls and buffers<a class="headerlink" href="#interactions-between-formats-controls-and-buffers" title="Permalink to this headline">¶</a></h2>
<p>V4L2 exposes parameters that influence the buffer size, or the way data is
laid out in the buffer. Those parameters are exposed through both formats and
controls. One example of such a control is the <code class="docutils literal"><span class="pre">V4L2_CID_ROTATE</span></code> control
that modifies the direction in which pixels are stored in the buffer, as well
as the buffer size when the selected format includes padding at the end of
lines.</p>
<p>The set of information needed to interpret the content of a buffer (e.g. the
pixel format, the line stride, the tiling orientation or the rotation) is
collectively referred to in the rest of this section as the buffer layout.</p>
<p>Controls that can modify the buffer layout shall set the
<code class="docutils literal"><span class="pre">V4L2_CTRL_FLAG_MODIFY_LAYOUT</span></code> flag.</p>
<p>Modifying formats or controls that influence the buffer size or layout require
the stream to be stopped. Any attempt at such a modification while the stream
is active shall cause the ioctl setting the format or the control to return
the <code class="docutils literal"><span class="pre">EBUSY</span></code> error code. In that case drivers shall also set the
<code class="docutils literal"><span class="pre">V4L2_CTRL_FLAG_GRABBED</span></code> flag when calling
<a class="reference internal" href="vidioc-queryctrl.html#c.VIDIOC_QUERYCTRL" title="VIDIOC_QUERYCTRL"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QUERYCTRL()</span></code></a> or <a class="reference internal" href="vidioc-queryctrl.html#c.VIDIOC_QUERY_EXT_CTRL" title="VIDIOC_QUERY_EXT_CTRL"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QUERY_EXT_CTRL()</span></code></a> for such a
control while the stream is active.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <a class="reference internal" href="vidioc-g-selection.html#c.VIDIOC_S_SELECTION" title="VIDIOC_S_SELECTION"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_SELECTION()</span></code></a> ioctl can, depending on the hardware (for
instance if the device doesn&#8217;t include a scaler), modify the format in
addition to the selection rectangle. Similarly, the
<a class="reference internal" href="vidioc-g-input.html#c.VIDIOC_S_INPUT" title="VIDIOC_S_INPUT"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_INPUT()</span></code></a>, <a class="reference internal" href="vidioc-g-output.html#c.VIDIOC_S_OUTPUT" title="VIDIOC_S_OUTPUT"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_OUTPUT()</span></code></a>, <a class="reference internal" href="vidioc-g-std.html#c.VIDIOC_S_STD" title="VIDIOC_S_STD"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_STD()</span></code></a>
and <a class="reference internal" href="vidioc-g-dv-timings.html#c.VIDIOC_S_DV_TIMINGS" title="VIDIOC_S_DV_TIMINGS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_DV_TIMINGS()</span></code></a> ioctls can also modify the format and
selection rectangles. When those ioctls result in a buffer size or layout
change, drivers shall handle that condition as they would handle it in the
<a class="reference internal" href="vidioc-g-fmt.html#c.VIDIOC_S_FMT" title="VIDIOC_S_FMT"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_FMT()</span></code></a> ioctl in all cases described in this section.</p>
</div>
<p>Controls that only influence the buffer layout can be modified at any time
when the stream is stopped. As they don&#8217;t influence the buffer size, no
special handling is needed to synchronize those controls with buffer
allocation and the <code class="docutils literal"><span class="pre">V4L2_CTRL_FLAG_GRABBED</span></code> flag is cleared once the
stream is stopped.</p>
<p>Formats and controls that influence the buffer size interact with buffer
allocation. The simplest way to handle this is for drivers to always require
buffers to be reallocated in order to change those formats or controls. In
that case, to perform such changes, userspace applications shall first stop
the video stream with the <a class="reference internal" href="vidioc-streamon.html#c.VIDIOC_STREAMOFF" title="VIDIOC_STREAMOFF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_STREAMOFF()</span></code></a> ioctl if it is running
and free all buffers with the <a class="reference internal" href="vidioc-reqbufs.html#c.VIDIOC_REQBUFS" title="VIDIOC_REQBUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_REQBUFS()</span></code></a> ioctl if they are
allocated. After freeing all buffers the <code class="docutils literal"><span class="pre">V4L2_CTRL_FLAG_GRABBED</span></code> flag
for controls is cleared. The format or controls can then be modified, and
buffers shall then be reallocated and the stream restarted. A typical ioctl
sequence is</p>
<blockquote>
<div><ol class="arabic simple">
<li>VIDIOC_STREAMOFF</li>
<li>VIDIOC_REQBUFS(0)</li>
<li>VIDIOC_S_EXT_CTRLS</li>
<li>VIDIOC_S_FMT</li>
<li>VIDIOC_REQBUFS(n)</li>
<li>VIDIOC_QBUF</li>
<li>VIDIOC_STREAMON</li>
</ol>
</div></blockquote>
<p>The second <a class="reference internal" href="vidioc-reqbufs.html#c.VIDIOC_REQBUFS" title="VIDIOC_REQBUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_REQBUFS()</span></code></a> call will take the new format and control
value into account to compute the buffer size to allocate. Applications can
also retrieve the size by calling the <a class="reference internal" href="vidioc-g-fmt.html#c.VIDIOC_G_FMT" title="VIDIOC_G_FMT"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_G_FMT()</span></code></a> ioctl if needed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The API doesn&#8217;t mandate the above order for control (3.) and format (4.)
changes. Format and controls can be set in a different order, or even
interleaved, depending on the device and use case. For instance some
controls might behave differently for different pixel formats, in which
case the format might need to be set first.</p>
</div>
<p>When reallocation is required, any attempt to modify format or controls that
influences the buffer size while buffers are allocated shall cause the format
or control set ioctl to return the <code class="docutils literal"><span class="pre">EBUSY</span></code> error. Any attempt to queue a
buffer too small for the current format or controls shall cause the
<a class="reference internal" href="vidioc-qbuf.html#c.VIDIOC_QBUF" title="VIDIOC_QBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QBUF()</span></code></a> ioctl to return a <code class="docutils literal"><span class="pre">EINVAL</span></code> error.</p>
<p>Buffer reallocation is an expensive operation. To avoid that cost, drivers can
(and are encouraged to) allow format or controls that influence the buffer
size to be changed with buffers allocated. In that case, a typical ioctl
sequence to modify format and controls is</p>
<blockquote>
<div><ol class="arabic simple">
<li>VIDIOC_STREAMOFF</li>
<li>VIDIOC_S_EXT_CTRLS</li>
<li>VIDIOC_S_FMT</li>
<li>VIDIOC_QBUF</li>
<li>VIDIOC_STREAMON</li>
</ol>
</div></blockquote>
<p>For this sequence to operate correctly, queued buffers need to be large enough
for the new format or controls. Drivers shall return a <code class="docutils literal"><span class="pre">ENOSPC</span></code> error in
response to format change (<a class="reference internal" href="vidioc-g-fmt.html#c.VIDIOC_S_FMT" title="VIDIOC_S_FMT"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_FMT()</span></code></a>) or control changes
(<a class="reference internal" href="vidioc-g-ctrl.html#c.VIDIOC_S_CTRL" title="VIDIOC_S_CTRL"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_CTRL()</span></code></a> or <a class="reference internal" href="vidioc-g-ext-ctrls.html#c.VIDIOC_S_EXT_CTRLS" title="VIDIOC_S_EXT_CTRLS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_S_EXT_CTRLS()</span></code></a>) if buffers too small
for the new format are currently queued. As a simplification, drivers are
allowed to return a <code class="docutils literal"><span class="pre">EBUSY</span></code> error from these ioctls if any buffer is
currently queued, without checking the queued buffers sizes.</p>
<p>Additionally, drivers shall return a <code class="docutils literal"><span class="pre">EINVAL</span></code> error from the
<a class="reference internal" href="vidioc-qbuf.html#c.VIDIOC_QBUF" title="VIDIOC_QBUF"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_QBUF()</span></code></a> ioctl if the buffer being queued is too small for the
current format or controls. Together, these requirements ensure that queued
buffers will always be large enough for the configured format and controls.</p>
<p>Userspace applications can query the buffer size required for a given format
and controls by first setting the desired control values and then trying the
desired format. The <a class="reference internal" href="vidioc-g-fmt.html#c.VIDIOC_TRY_FMT" title="VIDIOC_TRY_FMT"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_TRY_FMT()</span></code></a> ioctl will return the required
buffer size.</p>
<blockquote>
<div><ol class="arabic simple">
<li>VIDIOC_S_EXT_CTRLS(x)</li>
<li>VIDIOC_TRY_FMT()</li>
<li>VIDIOC_S_EXT_CTRLS(y)</li>
<li>VIDIOC_TRY_FMT()</li>
</ol>
</div></blockquote>
<p>The <a class="reference internal" href="vidioc-create-bufs.html#c.VIDIOC_CREATE_BUFS" title="VIDIOC_CREATE_BUFS"><code class="xref c c-func docutils literal"><span class="pre">VIDIOC_CREATE_BUFS()</span></code></a> ioctl can then be used to allocate buffers
based on the queried sizes (for instance by allocating a set of buffers large
enough for all the desired formats and controls, or by allocating separate set
of appropriately sized buffers for each use case).</p>
<dl class="type">
<dt id="c.v4l2_buffer">
<code class="descname">v4l2_buffer</code><a class="headerlink" href="#c.v4l2_buffer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="struct-v4l2-buffer">
<h2>3.6.2. struct v4l2_buffer<a class="headerlink" href="#struct-v4l2-buffer" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils" id="id3">
<caption><span class="caption-text">struct v4l2_buffer</span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="7%" />
<col width="14%" />
<col width="7%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">index</span></code></td>
<td>&nbsp;</td>
<td>Number of the buffer, set by the application except when calling
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>VIDIOC_DQBUF</span></a>, then it is set by the
driver. This field can range from zero to the number of buffers
allocated with the <a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span>ioctl VIDIOC_REQBUFS</span></a> ioctl
(struct <a class="reference internal" href="vidioc-reqbufs.html#c.v4l2_requestbuffers" title="v4l2_requestbuffers"><code class="xref c c-type docutils literal"><span class="pre">v4l2_requestbuffers</span></code></a>
<code class="docutils literal"><span class="pre">count</span></code>), plus any buffers allocated with
<a class="reference internal" href="vidioc-create-bufs.html#vidioc-create-bufs"><span>ioctl VIDIOC_CREATE_BUFS</span></a> minus one.</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">type</span></code></td>
<td>&nbsp;</td>
<td>Type of the buffer, same as struct
<a class="reference internal" href="vidioc-g-fmt.html#c.v4l2_format" title="v4l2_format"><code class="xref c c-type docutils literal"><span class="pre">v4l2_format</span></code></a> <code class="docutils literal"><span class="pre">type</span></code> or struct
<a class="reference internal" href="vidioc-reqbufs.html#c.v4l2_requestbuffers" title="v4l2_requestbuffers"><code class="xref c c-type docutils literal"><span class="pre">v4l2_requestbuffers</span></code></a> <code class="docutils literal"><span class="pre">type</span></code>, set
by the application. See <a class="reference internal" href="#c.v4l2_buf_type" title="v4l2_buf_type"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buf_type</span></code></a></td>
</tr>
<tr class="row-odd"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">bytesused</span></code></td>
<td>&nbsp;</td>
<td>The number of bytes occupied by the data in the buffer. It depends
on the negotiated data format and may change with each buffer for
compressed variable size data like JPEG images. Drivers must set
this field when <code class="docutils literal"><span class="pre">type</span></code> refers to a capture stream, applications
when it refers to an output stream. If the application sets this
to 0 for an output stream, then <code class="docutils literal"><span class="pre">bytesused</span></code> will be set to the
size of the buffer (see the <code class="docutils literal"><span class="pre">length</span></code> field of this struct) by
the driver. For multiplanar formats this field is ignored and the
<code class="docutils literal"><span class="pre">planes</span></code> pointer is used instead.</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">flags</span></code></td>
<td>&nbsp;</td>
<td>Flags set by the application or driver, see <a class="reference internal" href="#buffer-flags"><span>Buffer Flags</span></a>.</td>
</tr>
<tr class="row-odd"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">field</span></code></td>
<td>&nbsp;</td>
<td>Indicates the field order of the image in the buffer, see
<a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal"><span class="pre">v4l2_field</span></code></a>. This field is not used when the buffer
contains VBI data. Drivers must set it when <code class="docutils literal"><span class="pre">type</span></code> refers to a
capture stream, applications when it refers to an output stream.</td>
</tr>
<tr class="row-even"><td>struct timeval</td>
<td><code class="docutils literal"><span class="pre">timestamp</span></code></td>
<td>&nbsp;</td>
<td>For capture streams this is time when the first data byte was
captured, as returned by the <code class="xref c c-func docutils literal"><span class="pre">clock_gettime()</span></code> function
for the relevant clock id; see <code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_*</span></code> in
<a class="reference internal" href="#buffer-flags"><span>Buffer Flags</span></a>. For output streams the driver stores the
time at which the last data byte was actually sent out in the
<code class="docutils literal"><span class="pre">timestamp</span></code> field. This permits applications to monitor the
drift between the video and system clock. For output streams that
use <code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_COPY</span></code> the application has to fill
in the timestamp which will be copied by the driver to the capture
stream.</td>
</tr>
<tr class="row-odd"><td>struct <a class="reference internal" href="#c.v4l2_timecode" title="v4l2_timecode"><code class="xref c c-type docutils literal"><span class="pre">v4l2_timecode</span></code></a></td>
<td><code class="docutils literal"><span class="pre">timecode</span></code></td>
<td>&nbsp;</td>
<td>When <code class="docutils literal"><span class="pre">type</span></code> is <code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE</span></code> and the
<code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMECODE</span></code> flag is set in <code class="docutils literal"><span class="pre">flags</span></code>, this
structure contains a frame timecode. In
<a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal"><span class="pre">V4L2_FIELD_ALTERNATE</span></code></a> mode the top and
bottom field contain the same timecode. Timecodes are intended to
help video editing and are typically recorded on video tapes, but
also embedded in compressed formats like MPEG. This field is
independent of the <code class="docutils literal"><span class="pre">timestamp</span></code> and <code class="docutils literal"><span class="pre">sequence</span></code> fields.</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">sequence</span></code></td>
<td>&nbsp;</td>
<td>Set by the driver, counting the frames (not fields!) in sequence.
This field is set for both input and output devices.</td>
</tr>
<tr class="row-odd"><td colspan="4"><p class="first"></p>
<p>In <a class="reference internal" href="field-order.html#c.v4l2_field" title="v4l2_field"><code class="xref c c-type docutils literal"><span class="pre">V4L2_FIELD_ALTERNATE</span></code></a> mode the top and
bottom field have the same sequence number. The count starts at
zero and includes dropped or repeated frames. A dropped frame was
received by an input device but could not be stored due to lack of
free buffer space. A repeated frame was displayed again by an
output device because the application did not pass new data in
time.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This may count the frames received e.g. over USB, without
taking into account the frames dropped by the remote hardware due
to limited compression throughput or bus bandwidth. These devices
identify by not enumerating any video standards, see
<a class="reference internal" href="standard.html#standard"><span>Video Standards</span></a>.</p>
</div>
</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">memory</span></code></td>
<td>&nbsp;</td>
<td>This field must be set by applications and/or drivers in
accordance with the selected I/O method. See <a class="reference internal" href="#c.v4l2_memory" title="v4l2_memory"><code class="xref c c-type docutils literal"><span class="pre">v4l2_memory</span></code></a></td>
</tr>
<tr class="row-odd"><td>union</td>
<td colspan="3"><code class="docutils literal"><span class="pre">m</span></code></td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>__u32</td>
<td><code class="docutils literal"><span class="pre">offset</span></code></td>
<td>For the single-planar API and when <code class="docutils literal"><span class="pre">memory</span></code> is
<code class="docutils literal"><span class="pre">V4L2_MEMORY_MMAP</span></code> this is the offset of the buffer from the
start of the device memory. The value is returned by the driver
and apart of serving as parameter to the
<a class="reference internal" href="func-mmap.html#func-mmap"><span>mmap()</span></a> function not useful for applications.
See <a class="reference internal" href="mmap.html#mmap"><span>Streaming I/O (Memory Mapping)</span></a> for details</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>unsigned long</td>
<td><code class="docutils literal"><span class="pre">userptr</span></code></td>
<td>For the single-planar API and when <code class="docutils literal"><span class="pre">memory</span></code> is
<code class="docutils literal"><span class="pre">V4L2_MEMORY_USERPTR</span></code> this is a pointer to the buffer (casted to
unsigned long type) in virtual memory, set by the application. See
<a class="reference internal" href="userp.html#userp"><span>Streaming I/O (User Pointers)</span></a> for details.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>struct v4l2_plane</td>
<td><code class="docutils literal"><span class="pre">*planes</span></code></td>
<td>When using the multi-planar API, contains a userspace pointer to
an array of struct <a class="reference internal" href="#c.v4l2_plane" title="v4l2_plane"><code class="xref c c-type docutils literal"><span class="pre">v4l2_plane</span></code></a>. The size of
the array should be put in the <code class="docutils literal"><span class="pre">length</span></code> field of this
struct <a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a> structure.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>int</td>
<td><code class="docutils literal"><span class="pre">fd</span></code></td>
<td>For the single-plane API and when <code class="docutils literal"><span class="pre">memory</span></code> is
<code class="docutils literal"><span class="pre">V4L2_MEMORY_DMABUF</span></code> this is the file descriptor associated with
a DMABUF buffer.</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">length</span></code></td>
<td>&nbsp;</td>
<td>Size of the buffer (not the payload) in bytes for the
single-planar API. This is set by the driver based on the calls to
<a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span>ioctl VIDIOC_REQBUFS</span></a> and/or
<a class="reference internal" href="vidioc-create-bufs.html#vidioc-create-bufs"><span>ioctl VIDIOC_CREATE_BUFS</span></a>. For the
multi-planar API the application sets this to the number of
elements in the <code class="docutils literal"><span class="pre">planes</span></code> array. The driver will fill in the
actual number of valid elements in that array.</td>
</tr>
<tr class="row-odd"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">reserved2</span></code></td>
<td>&nbsp;</td>
<td>A place holder for future extensions. Drivers and applications
must set this to 0.</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">reserved</span></code></td>
<td>&nbsp;</td>
<td>A place holder for future extensions. Drivers and applications
must set this to 0.</td>
</tr>
</tbody>
</table>
<dl class="type">
<dt id="c.v4l2_plane">
<code class="descname">v4l2_plane</code><a class="headerlink" href="#c.v4l2_plane" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="struct-v4l2-plane">
<h2>3.6.3. struct v4l2_plane<a class="headerlink" href="#struct-v4l2-plane" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">bytesused</span></code></td>
<td>&nbsp;</td>
<td><p class="first">The number of bytes occupied by data in the plane (its payload).
Drivers must set this field when <code class="docutils literal"><span class="pre">type</span></code> refers to a capture
stream, applications when it refers to an output stream. If the
application sets this to 0 for an output stream, then
<code class="docutils literal"><span class="pre">bytesused</span></code> will be set to the size of the plane (see the
<code class="docutils literal"><span class="pre">length</span></code> field of this struct) by the driver.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that the actual image data starts at <code class="docutils literal"><span class="pre">data_offset</span></code>
which may not be 0.</p>
</div>
</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">length</span></code></td>
<td>&nbsp;</td>
<td>Size in bytes of the plane (not its payload). This is set by the
driver based on the calls to
<a class="reference internal" href="vidioc-reqbufs.html#vidioc-reqbufs"><span>ioctl VIDIOC_REQBUFS</span></a> and/or
<a class="reference internal" href="vidioc-create-bufs.html#vidioc-create-bufs"><span>ioctl VIDIOC_CREATE_BUFS</span></a>.</td>
</tr>
<tr class="row-odd"><td>union</td>
<td><code class="docutils literal"><span class="pre">m</span></code></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>__u32</td>
<td><code class="docutils literal"><span class="pre">mem_offset</span></code></td>
<td>When the memory type in the containing struct
<a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a> is <code class="docutils literal"><span class="pre">V4L2_MEMORY_MMAP</span></code>, this
is the value that should be passed to <a class="reference internal" href="func-mmap.html#func-mmap"><span>mmap()</span></a>,
similar to the <code class="docutils literal"><span class="pre">offset</span></code> field in struct
<a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a>.</td>
</tr>
<tr class="row-odd"><td>&nbsp;</td>
<td>unsigned long</td>
<td><code class="docutils literal"><span class="pre">userptr</span></code></td>
<td>When the memory type in the containing struct
<a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a> is <code class="docutils literal"><span class="pre">V4L2_MEMORY_USERPTR</span></code>,
this is a userspace pointer to the memory allocated for this plane
by an application.</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>int</td>
<td><code class="docutils literal"><span class="pre">fd</span></code></td>
<td>When the memory type in the containing struct
<a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a> is <code class="docutils literal"><span class="pre">V4L2_MEMORY_DMABUF</span></code>,
this is a file descriptor associated with a DMABUF buffer, similar
to the <code class="docutils literal"><span class="pre">fd</span></code> field in struct <a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a>.</td>
</tr>
<tr class="row-odd"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">data_offset</span></code></td>
<td>&nbsp;</td>
<td><p class="first">Offset in bytes to video data in the plane. Drivers must set this
field when <code class="docutils literal"><span class="pre">type</span></code> refers to a capture stream, applications when
it refers to an output stream.</p>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">That data_offset is included  in <code class="docutils literal"><span class="pre">bytesused</span></code>. So the
size of the image in the plane is <code class="docutils literal"><span class="pre">bytesused</span></code>-<code class="docutils literal"><span class="pre">data_offset</span></code>
at offset <code class="docutils literal"><span class="pre">data_offset</span></code> from the start of the plane.</p>
</div>
</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">reserved[11]</span></code></td>
<td>&nbsp;</td>
<td>Reserved for future use. Should be zeroed by drivers and
applications.</td>
</tr>
</tbody>
</table>
<dl class="type">
<dt id="c.v4l2_buf_type">
<code class="descname">v4l2_buf_type</code><a class="headerlink" href="#c.v4l2_buf_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="enum-v4l2-buf-type">
<h2>3.6.4. enum v4l2_buf_type<a class="headerlink" href="#enum-v4l2-buf-type" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="7%" />
<col width="64%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE</span></code></td>
<td>1</td>
<td>Buffer of a single-planar video capture stream, see
<a class="reference internal" href="dev-capture.html#capture"><span>Video Capture Interface</span></a>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE</span></code></td>
<td>9</td>
<td>Buffer of a multi-planar video capture stream, see
<a class="reference internal" href="dev-capture.html#capture"><span>Video Capture Interface</span></a>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT</span></code></td>
<td>2</td>
<td>Buffer of a single-planar video output stream, see
<a class="reference internal" href="dev-output.html#output"><span>Video Output Interface</span></a>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE</span></code></td>
<td>10</td>
<td>Buffer of a multi-planar video output stream, see <a class="reference internal" href="dev-output.html#output"><span>Video Output Interface</span></a>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_OVERLAY</span></code></td>
<td>3</td>
<td>Buffer for video overlay, see <a class="reference internal" href="dev-overlay.html#overlay"><span>Video Overlay Interface</span></a>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VBI_CAPTURE</span></code></td>
<td>4</td>
<td>Buffer of a raw VBI capture stream, see <a class="reference internal" href="dev-raw-vbi.html#raw-vbi"><span>Raw VBI Data Interface</span></a>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VBI_OUTPUT</span></code></td>
<td>5</td>
<td>Buffer of a raw VBI output stream, see <a class="reference internal" href="dev-raw-vbi.html#raw-vbi"><span>Raw VBI Data Interface</span></a>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_SLICED_VBI_CAPTURE</span></code></td>
<td>6</td>
<td>Buffer of a sliced VBI capture stream, see <a class="reference internal" href="dev-sliced-vbi.html#sliced"><span>Sliced VBI Data Interface</span></a>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_SLICED_VBI_OUTPUT</span></code></td>
<td>7</td>
<td>Buffer of a sliced VBI output stream, see <a class="reference internal" href="dev-sliced-vbi.html#sliced"><span>Sliced VBI Data Interface</span></a>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY</span></code></td>
<td>8</td>
<td>Buffer for video output overlay (OSD), see <a class="reference internal" href="dev-osd.html#osd"><span>Video Output Overlay Interface</span></a>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_SDR_CAPTURE</span></code></td>
<td>11</td>
<td>Buffer for Software Defined Radio (SDR) capture stream, see
<a class="reference internal" href="dev-sdr.html#sdr"><span>Software Defined Radio Interface (SDR)</span></a>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_SDR_OUTPUT</span></code></td>
<td>12</td>
<td>Buffer for Software Defined Radio (SDR) output stream, see
<a class="reference internal" href="dev-sdr.html#sdr"><span>Software Defined Radio Interface (SDR)</span></a>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_META_CAPTURE</span></code></td>
<td>13</td>
<td>Buffer for metadata capture, see <a class="reference internal" href="dev-meta.html#metadata"><span>Metadata Interface</span></a>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="buffer-flags">
<span id="id1"></span><h2>3.6.5. Buffer Flags<a class="headerlink" href="#buffer-flags" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_MAPPED</span></code></td>
<td>0x00000001</td>
<td><p class="first last" id="v4l2-buf-flag-mapped">The buffer resides in device memory and has been mapped into the
application&#8217;s address space, see <a class="reference internal" href="mmap.html#mmap"><span>Streaming I/O (Memory Mapping)</span></a> for details.
Drivers set or clear this flag when the
<a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span>ioctl VIDIOC_QUERYBUF</span></a>,
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>ioctl VIDIOC_QBUF, VIDIOC_DQBUF</span></a> or
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>VIDIOC_DQBUF</span></a> ioctl is called. Set by the
driver.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_QUEUED</span></code></td>
<td>0x00000002</td>
<td><p class="first last" id="v4l2-buf-flag-queued">Internally drivers maintain two buffer queues, an incoming and
outgoing queue. When this flag is set, the buffer is currently on
the incoming queue. It automatically moves to the outgoing queue
after the buffer has been filled (capture devices) or displayed
(output devices). Drivers set or clear this flag when the
<code class="docutils literal"><span class="pre">VIDIOC_QUERYBUF</span></code> ioctl is called. After (successful) calling
the <code class="docutils literal"><span class="pre">VIDIOC_QBUF</span></code>ioctl it is always set and after
<code class="docutils literal"><span class="pre">VIDIOC_DQBUF</span></code> always cleared.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_DONE</span></code></td>
<td>0x00000004</td>
<td><p class="first last" id="v4l2-buf-flag-done">When this flag is set, the buffer is currently on the outgoing
queue, ready to be dequeued from the driver. Drivers set or clear
this flag when the <code class="docutils literal"><span class="pre">VIDIOC_QUERYBUF</span></code> ioctl is called. After
calling the <code class="docutils literal"><span class="pre">VIDIOC_QBUF</span></code> or <code class="docutils literal"><span class="pre">VIDIOC_DQBUF</span></code> it is always
cleared. Of course a buffer cannot be on both queues at the same
time, the <code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_QUEUED</span></code> and <code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_DONE</span></code> flag
are mutually exclusive. They can be both cleared however, then the
buffer is in &#8220;dequeued&#8221; state, in the application domain so to
say.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_ERROR</span></code></td>
<td>0x00000040</td>
<td><p class="first last" id="v4l2-buf-flag-error">When this flag is set, the buffer has been dequeued successfully,
although the data might have been corrupted. This is recoverable,
streaming may continue as normal and the buffer may be reused
normally. Drivers set this flag when the <code class="docutils literal"><span class="pre">VIDIOC_DQBUF</span></code> ioctl is
called.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_KEYFRAME</span></code></td>
<td>0x00000008</td>
<td><p class="first last" id="v4l2-buf-flag-keyframe">Drivers set or clear this flag when calling the <code class="docutils literal"><span class="pre">VIDIOC_DQBUF</span></code>
ioctl. It may be set by video capture devices when the buffer
contains a compressed image which is a key frame (or field), i. e.
can be decompressed on its own. Also known as an I-frame.
Applications can set this bit when <code class="docutils literal"><span class="pre">type</span></code> refers to an output
stream.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_PFRAME</span></code></td>
<td>0x00000010</td>
<td><p class="first last" id="v4l2-buf-flag-pframe">Similar to <code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_KEYFRAME</span></code> this flags predicted frames
or fields which contain only differences to a previous key frame.
Applications can set this bit when <code class="docutils literal"><span class="pre">type</span></code> refers to an output
stream.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_BFRAME</span></code></td>
<td>0x00000020</td>
<td><p class="first last" id="v4l2-buf-flag-bframe">Similar to <code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_KEYFRAME</span></code> this flags a bi-directional
predicted frame or field which contains only the differences
between the current frame and both the preceding and following key
frames to specify its content. Applications can set this bit when
<code class="docutils literal"><span class="pre">type</span></code> refers to an output stream.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMECODE</span></code></td>
<td>0x00000100</td>
<td><p class="first last" id="v4l2-buf-flag-timecode">The <code class="docutils literal"><span class="pre">timecode</span></code> field is valid. Drivers set or clear this flag
when the <code class="docutils literal"><span class="pre">VIDIOC_DQBUF</span></code> ioctl is called. Applications can set
this bit and the corresponding <code class="docutils literal"><span class="pre">timecode</span></code> structure when
<code class="docutils literal"><span class="pre">type</span></code> refers to an output stream.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_PREPARED</span></code></td>
<td>0x00000400</td>
<td><p class="first last" id="v4l2-buf-flag-prepared">The buffer has been prepared for I/O and can be queued by the
application. Drivers set or clear this flag when the
<a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span>ioctl VIDIOC_QUERYBUF</span></a>,
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>VIDIOC_PREPARE_BUF</span></a>,
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>ioctl VIDIOC_QBUF, VIDIOC_DQBUF</span></a> or
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>VIDIOC_DQBUF</span></a> ioctl is called.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_NO_CACHE_INVALIDATE</span></code></td>
<td>0x00000800</td>
<td><p class="first last" id="v4l2-buf-flag-no-cache-invalidate">Caches do not have to be invalidated for this buffer. Typically
applications shall use this flag if the data captured in the
buffer is not going to be touched by the CPU, instead the buffer
will, probably, be passed on to a DMA-capable hardware unit for
further processing or output.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_NO_CACHE_CLEAN</span></code></td>
<td>0x00001000</td>
<td><p class="first last" id="v4l2-buf-flag-no-cache-clean">Caches do not have to be cleaned for this buffer. Typically
applications shall use this flag for output buffers if the data in
this buffer has not been created by the CPU but by some
DMA-capable unit, in which case caches have not been used.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_LAST</span></code></td>
<td>0x00100000</td>
<td><p class="first last" id="v4l2-buf-flag-last">Last buffer produced by the hardware. mem2mem codec drivers set
this flag on the capture queue for the last buffer when the
<a class="reference internal" href="vidioc-querybuf.html#vidioc-querybuf"><span>ioctl VIDIOC_QUERYBUF</span></a> or
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>VIDIOC_DQBUF</span></a> ioctl is called. Due to
hardware limitations, the last buffer may be empty. In this case
the driver will set the <code class="docutils literal"><span class="pre">bytesused</span></code> field to 0, regardless of
the format. Any Any subsequent call to the
<a class="reference internal" href="vidioc-qbuf.html#vidioc-qbuf"><span>VIDIOC_DQBUF</span></a> ioctl will not block anymore,
but return an <code class="docutils literal"><span class="pre">EPIPE</span></code> error code.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_MASK</span></code></td>
<td>0x0000e000</td>
<td><p class="first last" id="v4l2-buf-flag-timestamp-mask">Mask for timestamp types below. To test the timestamp type, mask
out bits not belonging to timestamp type by performing a logical
and operation with buffer flags and timestamp mask.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN</span></code></td>
<td>0x00000000</td>
<td><p class="first last" id="v4l2-buf-flag-timestamp-unknown">Unknown timestamp type. This type is used by drivers before Linux
3.9 and may be either monotonic (see below) or realtime (wall
clock). Monotonic clock has been favoured in embedded systems
whereas most of the drivers use the realtime clock. Either kinds
of timestamps are available in user space via
<code class="xref c c-func docutils literal"><span class="pre">clock_gettime()</span></code> using clock IDs <code class="docutils literal"><span class="pre">CLOCK_MONOTONIC</span></code>
and <code class="docutils literal"><span class="pre">CLOCK_REALTIME</span></code>, respectively.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC</span></code></td>
<td>0x00002000</td>
<td><p class="first last" id="v4l2-buf-flag-timestamp-monotonic">The buffer timestamp has been taken from the <code class="docutils literal"><span class="pre">CLOCK_MONOTONIC</span></code>
clock. To access the same clock outside V4L2, use
<code class="xref c c-func docutils literal"><span class="pre">clock_gettime()</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_COPY</span></code></td>
<td>0x00004000</td>
<td><p class="first last" id="v4l2-buf-flag-timestamp-copy">The CAPTURE buffer timestamp has been taken from the corresponding
OUTPUT buffer. This flag applies only to mem2mem devices.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TSTAMP_SRC_MASK</span></code></td>
<td>0x00070000</td>
<td><p class="first last" id="v4l2-buf-flag-tstamp-src-mask">Mask for timestamp sources below. The timestamp source defines the
point of time the timestamp is taken in relation to the frame.
Logical &#8216;and&#8217; operation between the <code class="docutils literal"><span class="pre">flags</span></code> field and
<code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TSTAMP_SRC_MASK</span></code> produces the value of the
timestamp source. Applications must set the timestamp source when
<code class="docutils literal"><span class="pre">type</span></code> refers to an output stream and
<code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TIMESTAMP_COPY</span></code> is set.</p>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TSTAMP_SRC_EOF</span></code></td>
<td>0x00000000</td>
<td><p class="first last" id="v4l2-buf-flag-tstamp-src-eof">End Of Frame. The buffer timestamp has been taken when the last
pixel of the frame has been received or the last pixel of the
frame has been transmitted. In practice, software generated
timestamps will typically be read from the clock a small amount of
time after the last pixel has been received or transmitten,
depending on the system and other activity in it.</p>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_BUF_FLAG_TSTAMP_SRC_SOE</span></code></td>
<td>0x00010000</td>
<td><p class="first last" id="v4l2-buf-flag-tstamp-src-soe">Start Of Exposure. The buffer timestamp has been taken when the
exposure of the frame has begun. This is only valid for the
<code class="docutils literal"><span class="pre">V4L2_BUF_TYPE_VIDEO_CAPTURE</span></code> buffer type.</p>
</td>
</tr>
</tbody>
</table>
<dl class="type">
<dt id="c.v4l2_memory">
<code class="descname">v4l2_memory</code><a class="headerlink" href="#c.v4l2_memory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="enum-v4l2-memory">
<h2>3.6.6. enum v4l2_memory<a class="headerlink" href="#enum-v4l2-memory" title="Permalink to this headline">¶</a></h2>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_MEMORY_MMAP</span></code></td>
<td>1</td>
<td>The buffer is used for <a class="reference internal" href="mmap.html#mmap"><span>memory mapping</span></a> I/O.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_MEMORY_USERPTR</span></code></td>
<td>2</td>
<td>The buffer is used for <a class="reference internal" href="userp.html#userp"><span>user pointer</span></a> I/O.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_MEMORY_OVERLAY</span></code></td>
<td>3</td>
<td>[to do]</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_MEMORY_DMABUF</span></code></td>
<td>4</td>
<td>The buffer is used for <a class="reference internal" href="dmabuf.html#dmabuf"><span>DMA shared buffer</span></a> I/O.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="timecodes">
<h2>3.6.7. Timecodes<a class="headerlink" href="#timecodes" title="Permalink to this headline">¶</a></h2>
<p>The struct <a class="reference internal" href="#c.v4l2_timecode" title="v4l2_timecode"><code class="xref c c-type docutils literal"><span class="pre">v4l2_timecode</span></code></a> structure is designed to hold a
<a class="reference internal" href="biblio.html#smpte12m"><span>SMPTE 12M</span></a> or similar timecode. (struct
struct <code class="xref c c-type docutils literal"><span class="pre">timeval</span></code> timestamps are stored in struct
<a class="reference internal" href="#c.v4l2_buffer" title="v4l2_buffer"><code class="xref c c-type docutils literal"><span class="pre">v4l2_buffer</span></code></a> field <code class="docutils literal"><span class="pre">timestamp</span></code>.)</p>
<dl class="type">
<dt id="c.v4l2_timecode">
<code class="descname">v4l2_timecode</code><a class="headerlink" href="#c.v4l2_timecode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="section" id="struct-v4l2-timecode">
<h3>3.6.7.1. struct v4l2_timecode<a class="headerlink" href="#struct-v4l2-timecode" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">type</span></code></td>
<td>Frame rate the timecodes are based on, see <a class="reference internal" href="#timecode-type"><span>Timecode Types</span></a>.</td>
</tr>
<tr class="row-even"><td>__u32</td>
<td><code class="docutils literal"><span class="pre">flags</span></code></td>
<td>Timecode flags, see <a class="reference internal" href="#timecode-flags"><span>Timecode Flags</span></a>.</td>
</tr>
<tr class="row-odd"><td>__u8</td>
<td><code class="docutils literal"><span class="pre">frames</span></code></td>
<td>Frame count, 0 ... 23/24/29/49/59, depending on the type of
timecode.</td>
</tr>
<tr class="row-even"><td>__u8</td>
<td><code class="docutils literal"><span class="pre">seconds</span></code></td>
<td>Seconds count, 0 ... 59. This is a binary, not BCD number.</td>
</tr>
<tr class="row-odd"><td>__u8</td>
<td><code class="docutils literal"><span class="pre">minutes</span></code></td>
<td>Minutes count, 0 ... 59. This is a binary, not BCD number.</td>
</tr>
<tr class="row-even"><td>__u8</td>
<td><code class="docutils literal"><span class="pre">hours</span></code></td>
<td>Hours count, 0 ... 29. This is a binary, not BCD number.</td>
</tr>
<tr class="row-odd"><td>__u8</td>
<td><code class="docutils literal"><span class="pre">userbits</span></code>[4]</td>
<td>The &#8220;user group&#8221; bits from the timecode.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="timecode-types">
<span id="timecode-type"></span><h3>3.6.7.2. Timecode Types<a class="headerlink" href="#timecode-types" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_TC_TYPE_24FPS</span></code></td>
<td>1</td>
<td>24 frames per second, i. e. film.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_TC_TYPE_25FPS</span></code></td>
<td>2</td>
<td>25 frames per second, i. e. PAL or SECAM video.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_TC_TYPE_30FPS</span></code></td>
<td>3</td>
<td>30 frames per second, i. e. NTSC video.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_TC_TYPE_50FPS</span></code></td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_TC_TYPE_60FPS</span></code></td>
<td>5</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="timecode-flags">
<span id="id2"></span><h3>3.6.7.3. Timecode Flags<a class="headerlink" href="#timecode-flags" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="13%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_TC_FLAG_DROPFRAME</span></code></td>
<td>0x0001</td>
<td>Indicates &#8220;drop frame&#8221; semantics for counting frames in 29.97 fps
material. When set, frame numbers 0 and 1 at the start of each
minute, except minutes 0, 10, 20, 30, 40, 50 are omitted from the
count.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_TC_FLAG_COLORFRAME</span></code></td>
<td>0x0002</td>
<td>The &#8220;color frame&#8221; flag.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_TC_USERBITS_field</span></code></td>
<td>0x000C</td>
<td>Field mask for the &#8220;binary group flags&#8221;.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">V4L2_TC_USERBITS_USERDEFINED</span></code></td>
<td>0x0000</td>
<td>Unspecified format.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">V4L2_TC_USERBITS_8BITCHARS</span></code></td>
<td>0x0008</td>
<td>8-bit ISO characters.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="field-order.html" class="btn btn-neutral float-right" title="3.7. Field Order" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="async.html" class="btn btn-neutral" title="3.5. Asynchronous I/O" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>