

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>34. The Virtual Video Test Driver (vivid) &mdash; The Linux Kernel  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="The Linux Kernel  documentation" href="../../index.html"/>
        <link rel="up" title="Video4Linux (V4L) driver-specific documentation" href="index.html"/>
        <link rel="next" title="35. The Zoran driver" href="zoran.html"/>
        <link rel="prev" title="33. The Linux USB Video Class (UVC) driver" href="uvcvideo.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> The Linux Kernel
          

          
          </a>

          
            
            
              <div class="version">
                4.19.0-xilinx-v2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Linux kernel licensing rules</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">The Linux kernel user&#8217;s and administrator&#8217;s guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">The Linux kernel user-space API guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">Working with the kernel development community</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">Development tools for the kernel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">How to write kernel documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Kernel Hacking Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Linux Tracing Technologies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">Kernel Maintainer Handbook</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">The Linux driver implementer&#8217;s API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">Core API Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Linux Media Subsystem Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../media_uapi.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../media_kapi.html">Media subsystem kernel internal API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dvb-drivers/index.html">Linux Digital TV driver-specific documentation</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Video4Linux (V4L)  driver-specific documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="fourcc.html">1. Guidelines for Video4Linux pixel format 4CCs</a></li>
<li class="toctree-l3"><a class="reference internal" href="v4l-with-ir.html">2. Infrared remote control support in video4linux drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="v4l-with-ir.html#using-with-lircd">3. Using with lircd</a></li>
<li class="toctree-l3"><a class="reference internal" href="v4l-with-ir.html#using-without-lircd">4. Using without lircd</a></li>
<li class="toctree-l3"><a class="reference internal" href="tuners.html">5. Tuner drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="cardlist.html">6. Cards List</a></li>
<li class="toctree-l3"><a class="reference internal" href="bttv.html">7. The bttv driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="cafe_ccic.html">8. The cafe_ccic driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpia2.html">9. The cpia2 driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="cx18.html">10. The cx18 driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="cx2341x.html">11. The cx2341x driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="cx88.html">12. The cx88 driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="davinci-vpbe.html">13. The VPBE V4L2 driver design</a></li>
<li class="toctree-l3"><a class="reference internal" href="fimc.html">14. The Samsung S5P/EXYNOS4 FIMC driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="imx.html">15. i.MX Video Capture Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="ivtv.html">16. The ivtv driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="max2175.html">17. Maxim Integrated MAX2175 RF to bits tuner driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="meye.html">18. Vaio Picturebook Motion Eye Camera Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="omap3isp.html">19. OMAP 3 Image Signal Processor (ISP) driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="omap4_camera.html">20. OMAP4 ISS Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="philips.html">21. Philips webcams (pwc driver)</a></li>
<li class="toctree-l3"><a class="reference internal" href="pvrusb2.html">22. The pvrusb2 driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="pxa_camera.html">23. PXA-Camera Host Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="qcom_camss.html">24. Qualcomm Camera Subsystem driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="radiotrack.html">25. The Radiotrack radio driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="rcar-fdp1.html">26. Renesas R-Car Fine Display Processor (FDP1) Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="saa7134.html">27. The saa7134 driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="sh_mobile_ceu_camera.html">28. Cropping and Scaling algorithm, used in the sh_mobile_ceu_camera driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="si470x.html">29. The Silicon Labs Si470x FM Radio Receivers driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="si4713.html">30. The Silicon Labs Si4713 FM Radio Transmitter Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="si476x.html">31. The SI476x Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="soc-camera.html">32. The Soc-Camera Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="uvcvideo.html">33. The Linux USB Video Class (UVC) driver</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">34. The Virtual Video Test Driver (vivid)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#configuring-the-driver">34.1. Configuring the driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#video-capture">34.2. Video Capture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#video-output">34.3. Video Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vbi-capture">34.4. VBI Capture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vbi-output">34.5. VBI Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="#radio-receiver">34.6. Radio Receiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#radio-transmitter">34.7. Radio Transmitter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#software-defined-radio-receiver">34.8. Software Defined Radio Receiver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#controls">34.9. Controls</a></li>
<li class="toctree-l4"><a class="reference internal" href="#video-vbi-and-rds-looping">34.10. Video, VBI and RDS Looping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cropping-composing-scaling">34.11. Cropping, Composing, Scaling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#formats">34.12. Formats</a></li>
<li class="toctree-l4"><a class="reference internal" href="#capture-overlay">34.13. Capture Overlay</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-overlay">34.14. Output Overlay</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cec-consumer-electronics-control">34.15. CEC (Consumer Electronics Control)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#some-future-improvements">34.16. Some Future Improvements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="zoran.html">35. The Zoran driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="zr364xx.html">36. Zoran 364xx based USB webcam module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../cec-drivers/index.html">CEC driver-specific documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../networking/index.html">Linux Networking Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../input/index.html">The Linux Input Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gpu/index.html">Linux GPU Driver Developer&#8217;s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security/index.html">Security Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sound/index.html">Linux Sound Subsystem Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/index.html">Linux Kernel Crypto API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/index.html">Linux Filesystems API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vm/index.html">Linux Memory Management Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bpf/index.html">BPF Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc-devices/index.html">Assorted Miscellaneous Devices Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../filesystems/ext4/index.html">ext4 Filesystem</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../translations/index.html">Translations</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">The Linux Kernel</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Linux Media Subsystem Documentation</a> &raquo;</li>
      
          <li><a href="index.html">Video4Linux (V4L)  driver-specific documentation</a> &raquo;</li>
      
    <li>34. The Virtual Video Test Driver (vivid)</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/media/v4l-drivers/vivid.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-virtual-video-test-driver-vivid">
<h1>34. The Virtual Video Test Driver (vivid)<a class="headerlink" href="#the-virtual-video-test-driver-vivid" title="Permalink to this headline">¶</a></h1>
<p>This driver emulates video4linux hardware of various types: video capture, video
output, vbi capture and output, radio receivers and transmitters and a software
defined radio receiver. In addition a simple framebuffer device is available for
testing capture and output overlays.</p>
<p>Up to 64 vivid instances can be created, each with up to 16 inputs and 16 outputs.</p>
<p>Each input can be a webcam, TV capture device, S-Video capture device or an HDMI
capture device. Each output can be an S-Video output device or an HDMI output
device.</p>
<p>These inputs and outputs act exactly as a real hardware device would behave. This
allows you to use this driver as a test input for application development, since
you can test the various features without requiring special hardware.</p>
<p>This document describes the features implemented by this driver:</p>
<ul class="simple">
<li>Support for read()/write(), MMAP, USERPTR and DMABUF streaming I/O.</li>
<li>A large list of test patterns and variations thereof</li>
<li>Working brightness, contrast, saturation and hue controls</li>
<li>Support for the alpha color component</li>
<li>Full colorspace support, including limited/full RGB range</li>
<li>All possible control types are present</li>
<li>Support for various pixel aspect ratios and video aspect ratios</li>
<li>Error injection to test what happens if errors occur</li>
<li>Supports crop/compose/scale in any combination for both input and output</li>
<li>Can emulate up to 4K resolutions</li>
<li>All Field settings are supported for testing interlaced capturing</li>
<li>Supports all standard YUV and RGB formats, including two multiplanar YUV formats</li>
<li>Raw and Sliced VBI capture and output support</li>
<li>Radio receiver and transmitter support, including RDS support</li>
<li>Software defined radio (SDR) support</li>
<li>Capture and output overlay support</li>
</ul>
<p>These features will be described in more detail below.</p>
<div class="section" id="configuring-the-driver">
<h2>34.1. Configuring the driver<a class="headerlink" href="#configuring-the-driver" title="Permalink to this headline">¶</a></h2>
<p>By default the driver will create a single instance that has a video capture
device with webcam, TV, S-Video and HDMI inputs, a video output device with
S-Video and HDMI outputs, one vbi capture device, one vbi output device, one
radio receiver device, one radio transmitter device and one SDR device.</p>
<p>The number of instances, devices, video inputs and outputs and their types are
all configurable using the following module options:</p>
<ul>
<li><p class="first">n_devs:</p>
<blockquote>
<div><p>number of driver instances to create. By default set to 1. Up to 64
instances can be created.</p>
</div></blockquote>
</li>
<li><p class="first">node_types:</p>
<blockquote>
<div><p>which devices should each driver instance create. An array of
hexadecimal values, one for each instance. The default is 0x1d3d.
Each value is a bitmask with the following meaning:</p>
<blockquote>
<div><ul class="simple">
<li>bit 0: Video Capture node</li>
<li>bit 2-3: VBI Capture node: 0 = none, 1 = raw vbi, 2 = sliced vbi, 3 = both</li>
<li>bit 4: Radio Receiver node</li>
<li>bit 5: Software Defined Radio Receiver node</li>
<li>bit 8: Video Output node</li>
<li>bit 10-11: VBI Output node: 0 = none, 1 = raw vbi, 2 = sliced vbi, 3 = both</li>
<li>bit 12: Radio Transmitter node</li>
<li>bit 16: Framebuffer for testing overlays</li>
</ul>
</div></blockquote>
<p>So to create four instances, the first two with just one video capture
device, the second two with just one video output device you would pass
these module options to vivid:</p>
<div class="highlight-none"><div class="highlight"><pre>n_devs=4 node_types=0x1,0x1,0x100,0x100
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">num_inputs:</p>
<blockquote>
<div><p>the number of inputs, one for each instance. By default 4 inputs
are created for each video capture device. At most 16 inputs can be created,
and there must be at least one.</p>
</div></blockquote>
</li>
<li><p class="first">input_types:</p>
<blockquote>
<div><p>the input types for each instance, the default is 0xe4. This defines
what the type of each input is when the inputs are created for each driver
instance. This is a hexadecimal value with up to 16 pairs of bits, each
pair gives the type and bits 0-1 map to input 0, bits 2-3 map to input 1,
30-31 map to input 15. Each pair of bits has the following meaning:</p>
<blockquote>
<div><ul class="simple">
<li>00: this is a webcam input</li>
<li>01: this is a TV tuner input</li>
<li>10: this is an S-Video input</li>
<li>11: this is an HDMI input</li>
</ul>
</div></blockquote>
<p>So to create a video capture device with 8 inputs where input 0 is a TV
tuner, inputs 1-3 are S-Video inputs and inputs 4-7 are HDMI inputs you
would use the following module options:</p>
<div class="highlight-none"><div class="highlight"><pre>num_inputs=8 input_types=0xffa9
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">num_outputs:</p>
<blockquote>
<div><p>the number of outputs, one for each instance. By default 2 outputs
are created for each video output device. At most 16 outputs can be
created, and there must be at least one.</p>
</div></blockquote>
</li>
<li><p class="first">output_types:</p>
<blockquote>
<div><p>the output types for each instance, the default is 0x02. This defines
what the type of each output is when the outputs are created for each
driver instance. This is a hexadecimal value with up to 16 bits, each bit
gives the type and bit 0 maps to output 0, bit 1 maps to output 1, bit
15 maps to output 15. The meaning of each bit is as follows:</p>
<blockquote>
<div><ul class="simple">
<li>0: this is an S-Video output</li>
<li>1: this is an HDMI output</li>
</ul>
</div></blockquote>
<p>So to create a video output device with 8 outputs where outputs 0-3 are
S-Video outputs and outputs 4-7 are HDMI outputs you would use the
following module options:</p>
<div class="highlight-none"><div class="highlight"><pre>num_outputs=8 output_types=0xf0
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">vid_cap_nr:</p>
<blockquote>
<div><p>give the desired videoX start number for each video capture device.
The default is -1 which will just take the first free number. This allows
you to map capture video nodes to specific videoX device nodes. Example:</p>
<div class="highlight-none"><div class="highlight"><pre>n_devs=4 vid_cap_nr=2,4,6,8
</pre></div>
</div>
<p>This will attempt to assign /dev/video2 for the video capture device of
the first vivid instance, video4 for the next up to video8 for the last
instance. If it can&#8217;t succeed, then it will just take the next free
number.</p>
</div></blockquote>
</li>
<li><p class="first">vid_out_nr:</p>
<blockquote>
<div><p>give the desired videoX start number for each video output device.
The default is -1 which will just take the first free number.</p>
</div></blockquote>
</li>
<li><p class="first">vbi_cap_nr:</p>
<blockquote>
<div><p>give the desired vbiX start number for each vbi capture device.
The default is -1 which will just take the first free number.</p>
</div></blockquote>
</li>
<li><p class="first">vbi_out_nr:</p>
<blockquote>
<div><p>give the desired vbiX start number for each vbi output device.
The default is -1 which will just take the first free number.</p>
</div></blockquote>
</li>
<li><p class="first">radio_rx_nr:</p>
<blockquote>
<div><p>give the desired radioX start number for each radio receiver device.
The default is -1 which will just take the first free number.</p>
</div></blockquote>
</li>
<li><p class="first">radio_tx_nr:</p>
<blockquote>
<div><p>give the desired radioX start number for each radio transmitter
device. The default is -1 which will just take the first free number.</p>
</div></blockquote>
</li>
<li><p class="first">sdr_cap_nr:</p>
<blockquote>
<div><p>give the desired swradioX start number for each SDR capture device.
The default is -1 which will just take the first free number.</p>
</div></blockquote>
</li>
<li><p class="first">ccs_cap_mode:</p>
<blockquote>
<div><p>specify the allowed video capture crop/compose/scaling combination
for each driver instance. Video capture devices can have any combination
of cropping, composing and scaling capabilities and this will tell the
vivid driver which of those is should emulate. By default the user can
select this through controls.</p>
<p>The value is either -1 (controlled by the user) or a set of three bits,
each enabling (1) or disabling (0) one of the features:</p>
<ul>
<li><p class="first">bit 0:</p>
<blockquote>
<div><p>Enable crop support. Cropping will take only part of the
incoming picture.</p>
</div></blockquote>
</li>
<li><p class="first">bit 1:</p>
<blockquote>
<div><p>Enable compose support. Composing will copy the incoming
picture into a larger buffer.</p>
</div></blockquote>
</li>
<li><p class="first">bit 2:</p>
<blockquote>
<div><p>Enable scaling support. Scaling can scale the incoming
picture. The scaler of the vivid driver can enlarge up
or down to four times the original size. The scaler is
very simple and low-quality. Simplicity and speed were
key, not quality.</p>
</div></blockquote>
</li>
</ul>
<p>Note that this value is ignored by webcam inputs: those enumerate
discrete framesizes and that is incompatible with cropping, composing
or scaling.</p>
</div></blockquote>
</li>
<li><p class="first">ccs_out_mode:</p>
<blockquote>
<div><p>specify the allowed video output crop/compose/scaling combination
for each driver instance. Video output devices can have any combination
of cropping, composing and scaling capabilities and this will tell the
vivid driver which of those is should emulate. By default the user can
select this through controls.</p>
<p>The value is either -1 (controlled by the user) or a set of three bits,
each enabling (1) or disabling (0) one of the features:</p>
<ul>
<li><p class="first">bit 0:</p>
<blockquote>
<div><p>Enable crop support. Cropping will take only part of the
outgoing buffer.</p>
</div></blockquote>
</li>
<li><p class="first">bit 1:</p>
<blockquote>
<div><p>Enable compose support. Composing will copy the incoming
buffer into a larger picture frame.</p>
</div></blockquote>
</li>
<li><p class="first">bit 2:</p>
<blockquote>
<div><p>Enable scaling support. Scaling can scale the incoming
buffer. The scaler of the vivid driver can enlarge up
or down to four times the original size. The scaler is
very simple and low-quality. Simplicity and speed were
key, not quality.</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">multiplanar:</p>
<blockquote>
<div><p>select whether each device instance supports multi-planar formats,
and thus the V4L2 multi-planar API. By default device instances are
single-planar.</p>
<p>This module option can override that for each instance. Values are:</p>
<blockquote>
<div><ul class="simple">
<li>1: this is a single-planar instance.</li>
<li>2: this is a multi-planar instance.</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p class="first">vivid_debug:</p>
<blockquote>
<div><p>enable driver debugging info</p>
</div></blockquote>
</li>
<li><p class="first">no_error_inj:</p>
<blockquote>
<div><p>if set disable the error injecting controls. This option is
needed in order to run a tool like v4l2-compliance. Tools like that
exercise all controls including a control like &#8216;Disconnect&#8217; which
emulates a USB disconnect, making the device inaccessible and so
all tests that v4l2-compliance is doing will fail afterwards.</p>
<p>There may be other situations as well where you want to disable the
error injection support of vivid. When this option is set, then the
controls that select crop, compose and scale behavior are also
removed. Unless overridden by ccs_cap_mode and/or ccs_out_mode the
will default to enabling crop, compose and scaling.</p>
</div></blockquote>
</li>
<li><p class="first">allocators:</p>
<blockquote>
<div><p>memory allocator selection, default is 0. It specifies the way buffers
will be allocated.</p>
<blockquote>
<div><ul class="simple">
<li>0: vmalloc</li>
<li>1: dma-contig</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
</ul>
<p>Taken together, all these module options allow you to precisely customize
the driver behavior and test your application with all sorts of permutations.
It is also very suitable to emulate hardware that is not yet available, e.g.
when developing software for a new upcoming device.</p>
</div>
<div class="section" id="video-capture">
<h2>34.2. Video Capture<a class="headerlink" href="#video-capture" title="Permalink to this headline">¶</a></h2>
<p>This is probably the most frequently used feature. The video capture device
can be configured by using the module options num_inputs, input_types and
ccs_cap_mode (see section 1 for more detailed information), but by default
four inputs are configured: a webcam, a TV tuner, an S-Video and an HDMI
input, one input for each input type. Those are described in more detail
below.</p>
<p>Special attention has been given to the rate at which new frames become
available. The jitter will be around 1 jiffie (that depends on the HZ
configuration of your kernel, so usually 1/100, 1/250 or 1/1000 of a second),
but the long-term behavior is exactly following the framerate. So a
framerate of 59.94 Hz is really different from 60 Hz. If the framerate
exceeds your kernel&#8217;s HZ value, then you will get dropped frames, but the
frame/field sequence counting will keep track of that so the sequence
count will skip whenever frames are dropped.</p>
<div class="section" id="webcam-input">
<h3>34.2.1. Webcam Input<a class="headerlink" href="#webcam-input" title="Permalink to this headline">¶</a></h3>
<p>The webcam input supports three framesizes: 320x180, 640x360 and 1280x720. It
supports frames per second settings of 10, 15, 25, 30, 50 and 60 fps. Which ones
are available depends on the chosen framesize: the larger the framesize, the
lower the maximum frames per second.</p>
<p>The initially selected colorspace when you switch to the webcam input will be
sRGB.</p>
</div>
<div class="section" id="tv-and-s-video-inputs">
<h3>34.2.2. TV and S-Video Inputs<a class="headerlink" href="#tv-and-s-video-inputs" title="Permalink to this headline">¶</a></h3>
<p>The only difference between the TV and S-Video input is that the TV has a
tuner. Otherwise they behave identically.</p>
<p>These inputs support audio inputs as well: one TV and one Line-In. They
both support all TV standards. If the standard is queried, then the Vivid
controls &#8216;Standard Signal Mode&#8217; and &#8216;Standard&#8217; determine what
the result will be.</p>
<p>These inputs support all combinations of the field setting. Special care has
been taken to faithfully reproduce how fields are handled for the different
TV standards. This is particularly noticeable when generating a horizontally
moving image so the temporal effect of using interlaced formats becomes clearly
visible. For 50 Hz standards the top field is the oldest and the bottom field
is the newest in time. For 60 Hz standards that is reversed: the bottom field
is the oldest and the top field is the newest in time.</p>
<p>When you start capturing in V4L2_FIELD_ALTERNATE mode the first buffer will
contain the top field for 50 Hz standards and the bottom field for 60 Hz
standards. This is what capture hardware does as well.</p>
<p>Finally, for PAL/SECAM standards the first half of the top line contains noise.
This simulates the Wide Screen Signal that is commonly placed there.</p>
<p>The initially selected colorspace when you switch to the TV or S-Video input
will be SMPTE-170M.</p>
<p>The pixel aspect ratio will depend on the TV standard. The video aspect ratio
can be selected through the &#8216;Standard Aspect Ratio&#8217; Vivid control.
Choices are &#8216;4x3&#8217;, &#8216;16x9&#8217; which will give letterboxed widescreen video and
&#8216;16x9 Anamorphic&#8217; which will give full screen squashed anamorphic widescreen
video that will need to be scaled accordingly.</p>
<p>The TV &#8216;tuner&#8217; supports a frequency range of 44-958 MHz. Channels are available
every 6 MHz, starting from 49.25 MHz. For each channel the generated image
will be in color for the +/- 0.25 MHz around it, and in grayscale for
+/- 1 MHz around the channel. Beyond that it is just noise. The VIDIOC_G_TUNER
ioctl will return 100% signal strength for +/- 0.25 MHz and 50% for +/- 1 MHz.
It will also return correct afc values to show whether the frequency is too
low or too high.</p>
<p>The audio subchannels that are returned are MONO for the +/- 1 MHz range around
a valid channel frequency. When the frequency is within +/- 0.25 MHz of the
channel it will return either MONO, STEREO, either MONO | SAP (for NTSC) or
LANG1 | LANG2 (for others), or STEREO | SAP.</p>
<p>Which one is returned depends on the chosen channel, each next valid channel
will cycle through the possible audio subchannel combinations. This allows
you to test the various combinations by just switching channels..</p>
<p>Finally, for these inputs the v4l2_timecode struct is filled in in the
dequeued v4l2_buffer struct.</p>
</div>
<div class="section" id="hdmi-input">
<h3>34.2.3. HDMI Input<a class="headerlink" href="#hdmi-input" title="Permalink to this headline">¶</a></h3>
<p>The HDMI inputs supports all CEA-861 and DMT timings, both progressive and
interlaced, for pixelclock frequencies between 25 and 600 MHz. The field
mode for interlaced formats is always V4L2_FIELD_ALTERNATE. For HDMI the
field order is always top field first, and when you start capturing an
interlaced format you will receive the top field first.</p>
<p>The initially selected colorspace when you switch to the HDMI input or
select an HDMI timing is based on the format resolution: for resolutions
less than or equal to 720x576 the colorspace is set to SMPTE-170M, for
others it is set to REC-709 (CEA-861 timings) or sRGB (VESA DMT timings).</p>
<p>The pixel aspect ratio will depend on the HDMI timing: for 720x480 is it
set as for the NTSC TV standard, for 720x576 it is set as for the PAL TV
standard, and for all others a 1:1 pixel aspect ratio is returned.</p>
<p>The video aspect ratio can be selected through the &#8216;DV Timings Aspect Ratio&#8217;
Vivid control. Choices are &#8216;Source Width x Height&#8217; (just use the
same ratio as the chosen format), &#8216;4x3&#8217; or &#8216;16x9&#8217;, either of which can
result in pillarboxed or letterboxed video.</p>
<p>For HDMI inputs it is possible to set the EDID. By default a simple EDID
is provided. You can only set the EDID for HDMI inputs. Internally, however,
the EDID is shared between all HDMI inputs.</p>
<p>No interpretation is done of the EDID data with the exception of the
physical address. See the CEC section for more details.</p>
<p>There is a maximum of 15 HDMI inputs (if there are more, then they will be
reduced to 15) since that&#8217;s the limitation of the EDID physical address.</p>
</div>
</div>
<div class="section" id="video-output">
<h2>34.3. Video Output<a class="headerlink" href="#video-output" title="Permalink to this headline">¶</a></h2>
<p>The video output device can be configured by using the module options
num_outputs, output_types and ccs_out_mode (see section 1 for more detailed
information), but by default two outputs are configured: an S-Video and an
HDMI input, one output for each output type. Those are described in more detail
below.</p>
<p>Like with video capture the framerate is also exact in the long term.</p>
<div class="section" id="s-video-output">
<h3>34.3.1. S-Video Output<a class="headerlink" href="#s-video-output" title="Permalink to this headline">¶</a></h3>
<p>This output supports audio outputs as well: &#8220;Line-Out 1&#8221; and &#8220;Line-Out 2&#8221;.
The S-Video output supports all TV standards.</p>
<p>This output supports all combinations of the field setting.</p>
<p>The initially selected colorspace when you switch to the TV or S-Video input
will be SMPTE-170M.</p>
</div>
<div class="section" id="hdmi-output">
<h3>34.3.2. HDMI Output<a class="headerlink" href="#hdmi-output" title="Permalink to this headline">¶</a></h3>
<p>The HDMI output supports all CEA-861 and DMT timings, both progressive and
interlaced, for pixelclock frequencies between 25 and 600 MHz. The field
mode for interlaced formats is always V4L2_FIELD_ALTERNATE.</p>
<p>The initially selected colorspace when you switch to the HDMI output or
select an HDMI timing is based on the format resolution: for resolutions
less than or equal to 720x576 the colorspace is set to SMPTE-170M, for
others it is set to REC-709 (CEA-861 timings) or sRGB (VESA DMT timings).</p>
<p>The pixel aspect ratio will depend on the HDMI timing: for 720x480 is it
set as for the NTSC TV standard, for 720x576 it is set as for the PAL TV
standard, and for all others a 1:1 pixel aspect ratio is returned.</p>
<p>An HDMI output has a valid EDID which can be obtained through VIDIOC_G_EDID.</p>
<p>There is a maximum of 15 HDMI outputs (if there are more, then they will be
reduced to 15) since that&#8217;s the limitation of the EDID physical address. See
also the CEC section for more details.</p>
</div>
</div>
<div class="section" id="vbi-capture">
<h2>34.4. VBI Capture<a class="headerlink" href="#vbi-capture" title="Permalink to this headline">¶</a></h2>
<p>There are three types of VBI capture devices: those that only support raw
(undecoded) VBI, those that only support sliced (decoded) VBI and those that
support both. This is determined by the node_types module option. In all
cases the driver will generate valid VBI data: for 60 Hz standards it will
generate Closed Caption and XDS data. The closed caption stream will
alternate between &#8220;Hello world!&#8221; and &#8220;Closed captions test&#8221; every second.
The XDS stream will give the current time once a minute. For 50 Hz standards
it will generate the Wide Screen Signal which is based on the actual Video
Aspect Ratio control setting and teletext pages 100-159, one page per frame.</p>
<p>The VBI device will only work for the S-Video and TV inputs, it will give
back an error if the current input is a webcam or HDMI.</p>
</div>
<div class="section" id="vbi-output">
<h2>34.5. VBI Output<a class="headerlink" href="#vbi-output" title="Permalink to this headline">¶</a></h2>
<p>There are three types of VBI output devices: those that only support raw
(undecoded) VBI, those that only support sliced (decoded) VBI and those that
support both. This is determined by the node_types module option.</p>
<p>The sliced VBI output supports the Wide Screen Signal and the teletext signal
for 50 Hz standards and Closed Captioning + XDS for 60 Hz standards.</p>
<p>The VBI device will only work for the S-Video output, it will give
back an error if the current output is HDMI.</p>
</div>
<div class="section" id="radio-receiver">
<h2>34.6. Radio Receiver<a class="headerlink" href="#radio-receiver" title="Permalink to this headline">¶</a></h2>
<p>The radio receiver emulates an FM/AM/SW receiver. The FM band also supports RDS.
The frequency ranges are:</p>
<blockquote>
<div><ul class="simple">
<li>FM: 64 MHz - 108 MHz</li>
<li>AM: 520 kHz - 1710 kHz</li>
<li>SW: 2300 kHz - 26.1 MHz</li>
</ul>
</div></blockquote>
<p>Valid channels are emulated every 1 MHz for FM and every 100 kHz for AM and SW.
The signal strength decreases the further the frequency is from the valid
frequency until it becomes 0% at +/- 50 kHz (FM) or 5 kHz (AM/SW) from the
ideal frequency. The initial frequency when the driver is loaded is set to
95 MHz.</p>
<p>The FM receiver supports RDS as well, both using &#8216;Block I/O&#8217; and &#8216;Controls&#8217;
modes. In the &#8216;Controls&#8217; mode the RDS information is stored in read-only
controls. These controls are updated every time the frequency is changed,
or when the tuner status is requested. The Block I/O method uses the read()
interface to pass the RDS blocks on to the application for decoding.</p>
<p>The RDS signal is &#8216;detected&#8217; for +/- 12.5 kHz around the channel frequency,
and the further the frequency is away from the valid frequency the more RDS
errors are randomly introduced into the block I/O stream, up to 50% of all
blocks if you are +/- 12.5 kHz from the channel frequency. All four errors
can occur in equal proportions: blocks marked &#8216;CORRECTED&#8217;, blocks marked
&#8216;ERROR&#8217;, blocks marked &#8216;INVALID&#8217; and dropped blocks.</p>
<p>The generated RDS stream contains all the standard fields contained in a
0B group, and also radio text and the current time.</p>
<p>The receiver supports HW frequency seek, either in Bounded mode, Wrap Around
mode or both, which is configurable with the &#8220;Radio HW Seek Mode&#8221; control.</p>
</div>
<div class="section" id="radio-transmitter">
<h2>34.7. Radio Transmitter<a class="headerlink" href="#radio-transmitter" title="Permalink to this headline">¶</a></h2>
<p>The radio transmitter emulates an FM/AM/SW transmitter. The FM band also supports RDS.
The frequency ranges are:</p>
<blockquote>
<div><ul class="simple">
<li>FM: 64 MHz - 108 MHz</li>
<li>AM: 520 kHz - 1710 kHz</li>
<li>SW: 2300 kHz - 26.1 MHz</li>
</ul>
</div></blockquote>
<p>The initial frequency when the driver is loaded is 95.5 MHz.</p>
<p>The FM transmitter supports RDS as well, both using &#8216;Block I/O&#8217; and &#8216;Controls&#8217;
modes. In the &#8216;Controls&#8217; mode the transmitted RDS information is configured
using controls, and in &#8216;Block I/O&#8217; mode the blocks are passed to the driver
using write().</p>
</div>
<div class="section" id="software-defined-radio-receiver">
<h2>34.8. Software Defined Radio Receiver<a class="headerlink" href="#software-defined-radio-receiver" title="Permalink to this headline">¶</a></h2>
<p>The SDR receiver has three frequency bands for the ADC tuner:</p>
<blockquote>
<div><ul class="simple">
<li>300 kHz</li>
<li>900 kHz - 2800 kHz</li>
<li>3200 kHz</li>
</ul>
</div></blockquote>
<p>The RF tuner supports 50 MHz - 2000 MHz.</p>
<p>The generated data contains the In-phase and Quadrature components of a
1 kHz tone that has an amplitude of sqrt(2).</p>
</div>
<div class="section" id="controls">
<h2>34.9. Controls<a class="headerlink" href="#controls" title="Permalink to this headline">¶</a></h2>
<p>Different devices support different controls. The sections below will describe
each control and which devices support them.</p>
<div class="section" id="user-controls-test-controls">
<h3>34.9.1. User Controls - Test Controls<a class="headerlink" href="#user-controls-test-controls" title="Permalink to this headline">¶</a></h3>
<p>The Button, Boolean, Integer 32 Bits, Integer 64 Bits, Menu, String, Bitmask and
Integer Menu are controls that represent all possible control types. The Menu
control and the Integer Menu control both have &#8216;holes&#8217; in their menu list,
meaning that one or more menu items return EINVAL when VIDIOC_QUERYMENU is called.
Both menu controls also have a non-zero minimum control value.  These features
allow you to check if your application can handle such things correctly.
These controls are supported for every device type.</p>
</div>
<div class="section" id="user-controls-video-capture">
<h3>34.9.2. User Controls - Video Capture<a class="headerlink" href="#user-controls-video-capture" title="Permalink to this headline">¶</a></h3>
<p>The following controls are specific to video capture.</p>
<p>The Brightness, Contrast, Saturation and Hue controls actually work and are
standard. There is one special feature with the Brightness control: each
video input has its own brightness value, so changing input will restore
the brightness for that input. In addition, each video input uses a different
brightness range (minimum and maximum control values). Switching inputs will
cause a control event to be sent with the V4L2_EVENT_CTRL_CH_RANGE flag set.
This allows you to test controls that can change their range.</p>
<p>The &#8216;Gain, Automatic&#8217; and Gain controls can be used to test volatile controls:
if &#8216;Gain, Automatic&#8217; is set, then the Gain control is volatile and changes
constantly. If &#8216;Gain, Automatic&#8217; is cleared, then the Gain control is a normal
control.</p>
<p>The &#8216;Horizontal Flip&#8217; and &#8216;Vertical Flip&#8217; controls can be used to flip the
image. These combine with the &#8216;Sensor Flipped Horizontally/Vertically&#8217; Vivid
controls.</p>
<p>The &#8216;Alpha Component&#8217; control can be used to set the alpha component for
formats containing an alpha channel.</p>
</div>
<div class="section" id="user-controls-audio">
<h3>34.9.3. User Controls - Audio<a class="headerlink" href="#user-controls-audio" title="Permalink to this headline">¶</a></h3>
<p>The following controls are specific to video capture and output and radio
receivers and transmitters.</p>
<p>The &#8216;Volume&#8217; and &#8216;Mute&#8217; audio controls are typical for such devices to
control the volume and mute the audio. They don&#8217;t actually do anything in
the vivid driver.</p>
</div>
<div class="section" id="vivid-controls">
<h3>34.9.4. Vivid Controls<a class="headerlink" href="#vivid-controls" title="Permalink to this headline">¶</a></h3>
<p>These vivid custom controls control the image generation, error injection, etc.</p>
<div class="section" id="test-pattern-controls">
<h4>34.9.4.1. Test Pattern Controls<a class="headerlink" href="#test-pattern-controls" title="Permalink to this headline">¶</a></h4>
<p>The Test Pattern Controls are all specific to video capture.</p>
<ul>
<li><p class="first">Test Pattern:</p>
<blockquote>
<div><p>selects which test pattern to use. Use the CSC Colorbar for
testing colorspace conversions: the colors used in that test pattern
map to valid colors in all colorspaces. The colorspace conversion
is disabled for the other test patterns.</p>
</div></blockquote>
</li>
<li><p class="first">OSD Text Mode:</p>
<blockquote>
<div><p>selects whether the text superimposed on the
test pattern should be shown, and if so, whether only counters should
be displayed or the full text.</p>
</div></blockquote>
</li>
<li><p class="first">Horizontal Movement:</p>
<blockquote>
<div><p>selects whether the test pattern should
move to the left or right and at what speed.</p>
</div></blockquote>
</li>
<li><p class="first">Vertical Movement:</p>
<blockquote>
<div><p>does the same for the vertical direction.</p>
</div></blockquote>
</li>
<li><p class="first">Show Border:</p>
<blockquote>
<div><p>show a two-pixel wide border at the edge of the actual image,
excluding letter or pillarboxing.</p>
</div></blockquote>
</li>
<li><p class="first">Show Square:</p>
<blockquote>
<div><p>show a square in the middle of the image. If the image is
displayed with the correct pixel and image aspect ratio corrections,
then the width and height of the square on the monitor should be
the same.</p>
</div></blockquote>
</li>
<li><p class="first">Insert SAV Code in Image:</p>
<blockquote>
<div><p>adds a SAV (Start of Active Video) code to the image.
This can be used to check if such codes in the image are inadvertently
interpreted instead of being ignored.</p>
</div></blockquote>
</li>
<li><p class="first">Insert EAV Code in Image:</p>
<blockquote>
<div><p>does the same for the EAV (End of Active Video) code.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="capture-feature-selection-controls">
<h4>34.9.4.2. Capture Feature Selection Controls<a class="headerlink" href="#capture-feature-selection-controls" title="Permalink to this headline">¶</a></h4>
<p>These controls are all specific to video capture.</p>
<ul>
<li><p class="first">Sensor Flipped Horizontally:</p>
<blockquote>
<div><p>the image is flipped horizontally and the
V4L2_IN_ST_HFLIP input status flag is set. This emulates the case where
a sensor is for example mounted upside down.</p>
</div></blockquote>
</li>
<li><p class="first">Sensor Flipped Vertically:</p>
<blockquote>
<div><p>the image is flipped vertically and the
V4L2_IN_ST_VFLIP input status flag is set. This emulates the case where
a sensor is for example mounted upside down.</p>
</div></blockquote>
</li>
<li><p class="first">Standard Aspect Ratio:</p>
<blockquote>
<div><p>selects if the image aspect ratio as used for the TV or
S-Video input should be 4x3, 16x9 or anamorphic widescreen. This may
introduce letterboxing.</p>
</div></blockquote>
</li>
<li><p class="first">DV Timings Aspect Ratio:</p>
<blockquote>
<div><p>selects if the image aspect ratio as used for the HDMI
input should be the same as the source width and height ratio, or if
it should be 4x3 or 16x9. This may introduce letter or pillarboxing.</p>
</div></blockquote>
</li>
<li><p class="first">Timestamp Source:</p>
<blockquote>
<div><p>selects when the timestamp for each buffer is taken.</p>
</div></blockquote>
</li>
<li><p class="first">Colorspace:</p>
<blockquote>
<div><p>selects which colorspace should be used when generating the image.
This only applies if the CSC Colorbar test pattern is selected,
otherwise the test pattern will go through unconverted.
This behavior is also what you want, since a 75% Colorbar
should really have 75% signal intensity and should not be affected
by colorspace conversions.</p>
<p>Changing the colorspace will result in the V4L2_EVENT_SOURCE_CHANGE
to be sent since it emulates a detected colorspace change.</p>
</div></blockquote>
</li>
<li><p class="first">Transfer Function:</p>
<blockquote>
<div><p>selects which colorspace transfer function should be used when
generating an image. This only applies if the CSC Colorbar test pattern is
selected, otherwise the test pattern will go through unconverted.
This behavior is also what you want, since a 75% Colorbar
should really have 75% signal intensity and should not be affected
by colorspace conversions.</p>
<p>Changing the transfer function will result in the V4L2_EVENT_SOURCE_CHANGE
to be sent since it emulates a detected colorspace change.</p>
</div></blockquote>
</li>
<li><p class="first">Y&#8217;CbCr Encoding:</p>
<blockquote>
<div><p>selects which Y&#8217;CbCr encoding should be used when generating
a Y&#8217;CbCr image. This only applies if the format is set to a Y&#8217;CbCr format
as opposed to an RGB format.</p>
<p>Changing the Y&#8217;CbCr encoding will result in the V4L2_EVENT_SOURCE_CHANGE
to be sent since it emulates a detected colorspace change.</p>
</div></blockquote>
</li>
<li><p class="first">Quantization:</p>
<blockquote>
<div><p>selects which quantization should be used for the RGB or Y&#8217;CbCr
encoding when generating the test pattern.</p>
<p>Changing the quantization will result in the V4L2_EVENT_SOURCE_CHANGE
to be sent since it emulates a detected colorspace change.</p>
</div></blockquote>
</li>
<li><p class="first">Limited RGB Range (16-235):</p>
<blockquote>
<div><p>selects if the RGB range of the HDMI source should
be limited or full range. This combines with the Digital Video &#8216;Rx RGB
Quantization Range&#8217; control and can be used to test what happens if
a source provides you with the wrong quantization range information.
See the description of that control for more details.</p>
</div></blockquote>
</li>
<li><p class="first">Apply Alpha To Red Only:</p>
<blockquote>
<div><p>apply the alpha channel as set by the &#8216;Alpha Component&#8217;
user control to the red color of the test pattern only.</p>
</div></blockquote>
</li>
<li><p class="first">Enable Capture Cropping:</p>
<blockquote>
<div><p>enables crop support. This control is only present if
the ccs_cap_mode module option is set to the default value of -1 and if
the no_error_inj module option is set to 0 (the default).</p>
</div></blockquote>
</li>
<li><p class="first">Enable Capture Composing:</p>
<blockquote>
<div><p>enables composing support. This control is only
present if the ccs_cap_mode module option is set to the default value of
-1 and if the no_error_inj module option is set to 0 (the default).</p>
</div></blockquote>
</li>
<li><p class="first">Enable Capture Scaler:</p>
<blockquote>
<div><p>enables support for a scaler (maximum 4 times upscaling
and downscaling). This control is only present if the ccs_cap_mode
module option is set to the default value of -1 and if the no_error_inj
module option is set to 0 (the default).</p>
</div></blockquote>
</li>
<li><p class="first">Maximum EDID Blocks:</p>
<blockquote>
<div><p>determines how many EDID blocks the driver supports.
Note that the vivid driver does not actually interpret new EDID
data, it just stores it. It allows for up to 256 EDID blocks
which is the maximum supported by the standard.</p>
</div></blockquote>
</li>
<li><p class="first">Fill Percentage of Frame:</p>
<blockquote>
<div><p>can be used to draw only the top X percent
of the image. Since each frame has to be drawn by the driver, this
demands a lot of the CPU. For large resolutions this becomes
problematic. By drawing only part of the image this CPU load can
be reduced.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="output-feature-selection-controls">
<h4>34.9.4.3. Output Feature Selection Controls<a class="headerlink" href="#output-feature-selection-controls" title="Permalink to this headline">¶</a></h4>
<p>These controls are all specific to video output.</p>
<ul>
<li><p class="first">Enable Output Cropping:</p>
<blockquote>
<div><p>enables crop support. This control is only present if
the ccs_out_mode module option is set to the default value of -1 and if
the no_error_inj module option is set to 0 (the default).</p>
</div></blockquote>
</li>
<li><p class="first">Enable Output Composing:</p>
<blockquote>
<div><p>enables composing support. This control is only
present if the ccs_out_mode module option is set to the default value of
-1 and if the no_error_inj module option is set to 0 (the default).</p>
</div></blockquote>
</li>
<li><p class="first">Enable Output Scaler:</p>
<blockquote>
<div><p>enables support for a scaler (maximum 4 times upscaling
and downscaling). This control is only present if the ccs_out_mode
module option is set to the default value of -1 and if the no_error_inj
module option is set to 0 (the default).</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="error-injection-controls">
<h4>34.9.4.4. Error Injection Controls<a class="headerlink" href="#error-injection-controls" title="Permalink to this headline">¶</a></h4>
<p>The following two controls are only valid for video and vbi capture.</p>
<ul>
<li><p class="first">Standard Signal Mode:</p>
<blockquote>
<div><p>selects the behavior of VIDIOC_QUERYSTD: what should it return?</p>
<p>Changing this control will result in the V4L2_EVENT_SOURCE_CHANGE
to be sent since it emulates a changed input condition (e.g. a cable
was plugged in or out).</p>
</div></blockquote>
</li>
<li><p class="first">Standard:</p>
<blockquote>
<div><p>selects the standard that VIDIOC_QUERYSTD should return if the
previous control is set to &#8220;Selected Standard&#8221;.</p>
<p>Changing this control will result in the V4L2_EVENT_SOURCE_CHANGE
to be sent since it emulates a changed input standard.</p>
</div></blockquote>
</li>
</ul>
<p>The following two controls are only valid for video capture.</p>
<ul>
<li><p class="first">DV Timings Signal Mode:</p>
<blockquote>
<div><p>selects the behavior of VIDIOC_QUERY_DV_TIMINGS: what
should it return?</p>
<p>Changing this control will result in the V4L2_EVENT_SOURCE_CHANGE
to be sent since it emulates a changed input condition (e.g. a cable
was plugged in or out).</p>
</div></blockquote>
</li>
<li><p class="first">DV Timings:</p>
<blockquote>
<div><p>selects the timings the VIDIOC_QUERY_DV_TIMINGS should return
if the previous control is set to &#8220;Selected DV Timings&#8221;.</p>
<p>Changing this control will result in the V4L2_EVENT_SOURCE_CHANGE
to be sent since it emulates changed input timings.</p>
</div></blockquote>
</li>
</ul>
<p>The following controls are only present if the no_error_inj module option
is set to 0 (the default). These controls are valid for video and vbi
capture and output streams and for the SDR capture device except for the
Disconnect control which is valid for all devices.</p>
<ul>
<li><p class="first">Wrap Sequence Number:</p>
<blockquote>
<div><p>test what happens when you wrap the sequence number in
struct v4l2_buffer around.</p>
</div></blockquote>
</li>
<li><p class="first">Wrap Timestamp:</p>
<blockquote>
<div><p>test what happens when you wrap the timestamp in struct
v4l2_buffer around.</p>
</div></blockquote>
</li>
<li><p class="first">Percentage of Dropped Buffers:</p>
<blockquote>
<div><p>sets the percentage of buffers that
are never returned by the driver (i.e., they are dropped).</p>
</div></blockquote>
</li>
<li><p class="first">Disconnect:</p>
<blockquote>
<div><p>emulates a USB disconnect. The device will act as if it has
been disconnected. Only after all open filehandles to the device
node have been closed will the device become &#8216;connected&#8217; again.</p>
</div></blockquote>
</li>
<li><p class="first">Inject V4L2_BUF_FLAG_ERROR:</p>
<blockquote>
<div><p>when pressed, the next frame returned by
the driver will have the error flag set (i.e. the frame is marked
corrupt).</p>
</div></blockquote>
</li>
<li><p class="first">Inject VIDIOC_REQBUFS Error:</p>
<blockquote>
<div><p>when pressed, the next REQBUFS or CREATE_BUFS
ioctl call will fail with an error. To be precise: the videobuf2
queue_setup() op will return -EINVAL.</p>
</div></blockquote>
</li>
<li><p class="first">Inject VIDIOC_QBUF Error:</p>
<blockquote>
<div><p>when pressed, the next VIDIOC_QBUF or
VIDIOC_PREPARE_BUFFER ioctl call will fail with an error. To be
precise: the videobuf2 buf_prepare() op will return -EINVAL.</p>
</div></blockquote>
</li>
<li><p class="first">Inject VIDIOC_STREAMON Error:</p>
<blockquote>
<div><p>when pressed, the next VIDIOC_STREAMON ioctl
call will fail with an error. To be precise: the videobuf2
start_streaming() op will return -EINVAL.</p>
</div></blockquote>
</li>
<li><p class="first">Inject Fatal Streaming Error:</p>
<blockquote>
<div><p>when pressed, the streaming core will be
marked as having suffered a fatal error, the only way to recover
from that is to stop streaming. To be precise: the videobuf2
vb2_queue_error() function is called.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="vbi-raw-capture-controls">
<h4>34.9.4.5. VBI Raw Capture Controls<a class="headerlink" href="#vbi-raw-capture-controls" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">Interlaced VBI Format:</p>
<blockquote>
<div><p>if set, then the raw VBI data will be interlaced instead
of providing it grouped by field.</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="digital-video-controls">
<h3>34.9.5. Digital Video Controls<a class="headerlink" href="#digital-video-controls" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Rx RGB Quantization Range:</p>
<blockquote>
<div><p>sets the RGB quantization detection of the HDMI
input. This combines with the Vivid &#8216;Limited RGB Range (16-235)&#8217;
control and can be used to test what happens if a source provides
you with the wrong quantization range information. This can be tested
by selecting an HDMI input, setting this control to Full or Limited
range and selecting the opposite in the &#8216;Limited RGB Range (16-235)&#8217;
control. The effect is easy to see if the &#8216;Gray Ramp&#8217; test pattern
is selected.</p>
</div></blockquote>
</li>
<li><p class="first">Tx RGB Quantization Range:</p>
<blockquote>
<div><p>sets the RGB quantization detection of the HDMI
output. It is currently not used for anything in vivid, but most HDMI
transmitters would typically have this control.</p>
</div></blockquote>
</li>
<li><p class="first">Transmit Mode:</p>
<blockquote>
<div><p>sets the transmit mode of the HDMI output to HDMI or DVI-D. This
affects the reported colorspace since DVI_D outputs will always use
sRGB.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="fm-radio-receiver-controls">
<h3>34.9.6. FM Radio Receiver Controls<a class="headerlink" href="#fm-radio-receiver-controls" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">RDS Reception:</p>
<blockquote>
<div><p>set if the RDS receiver should be enabled.</p>
</div></blockquote>
</li>
<li><p class="first">RDS Program Type:</p>
</li>
<li><p class="first">RDS PS Name:</p>
</li>
<li><p class="first">RDS Radio Text:</p>
</li>
<li><p class="first">RDS Traffic Announcement:</p>
</li>
<li><p class="first">RDS Traffic Program:</p>
</li>
<li><p class="first">RDS Music:</p>
<blockquote>
<div><p>these are all read-only controls. If RDS Rx I/O Mode is set to
&#8220;Block I/O&#8221;, then they are inactive as well. If RDS Rx I/O Mode is set
to &#8220;Controls&#8221;, then these controls report the received RDS data.</p>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The vivid implementation of this is pretty basic: they are only
updated when you set a new frequency or when you get the tuner status
(VIDIOC_G_TUNER).</p>
</div>
<ul>
<li><p class="first">Radio HW Seek Mode:</p>
<blockquote>
<div><p>can be one of &#8220;Bounded&#8221;, &#8220;Wrap Around&#8221; or &#8220;Both&#8221;. This
determines if VIDIOC_S_HW_FREQ_SEEK will be bounded by the frequency
range or wrap-around or if it is selectable by the user.</p>
</div></blockquote>
</li>
<li><p class="first">Radio Programmable HW Seek:</p>
<blockquote>
<div><p>if set, then the user can provide the lower and
upper bound of the HW Seek. Otherwise the frequency range boundaries
will be used.</p>
</div></blockquote>
</li>
<li><p class="first">Generate RBDS Instead of RDS:</p>
<blockquote>
<div><p>if set, then generate RBDS (the US variant of
RDS) data instead of RDS (European-style RDS). This affects only the
PICODE and PTY codes.</p>
</div></blockquote>
</li>
<li><p class="first">RDS Rx I/O Mode:</p>
<blockquote>
<div><p>this can be &#8220;Block I/O&#8221; where the RDS blocks have to be read()
by the application, or &#8220;Controls&#8221; where the RDS data is provided by
the RDS controls mentioned above.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="fm-radio-modulator-controls">
<h3>34.9.7. FM Radio Modulator Controls<a class="headerlink" href="#fm-radio-modulator-controls" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">RDS Program ID:</p>
</li>
<li><p class="first">RDS Program Type:</p>
</li>
<li><p class="first">RDS PS Name:</p>
</li>
<li><p class="first">RDS Radio Text:</p>
</li>
<li><p class="first">RDS Stereo:</p>
</li>
<li><p class="first">RDS Artificial Head:</p>
</li>
<li><p class="first">RDS Compressed:</p>
</li>
<li><p class="first">RDS Dynamic PTY:</p>
</li>
<li><p class="first">RDS Traffic Announcement:</p>
</li>
<li><p class="first">RDS Traffic Program:</p>
</li>
<li><p class="first">RDS Music:</p>
<blockquote>
<div><p>these are all controls that set the RDS data that is transmitted by
the FM modulator.</p>
</div></blockquote>
</li>
<li><p class="first">RDS Tx I/O Mode:</p>
<blockquote>
<div><p>this can be &#8220;Block I/O&#8221; where the application has to use write()
to pass the RDS blocks to the driver, or &#8220;Controls&#8221; where the RDS data
is Provided by the RDS controls mentioned above.</p>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="video-vbi-and-rds-looping">
<h2>34.10. Video, VBI and RDS Looping<a class="headerlink" href="#video-vbi-and-rds-looping" title="Permalink to this headline">¶</a></h2>
<p>The vivid driver supports looping of video output to video input, VBI output
to VBI input and RDS output to RDS input. For video/VBI looping this emulates
as if a cable was hooked up between the output and input connector. So video
and VBI looping is only supported between S-Video and HDMI inputs and outputs.
VBI is only valid for S-Video as it makes no sense for HDMI.</p>
<p>Since radio is wireless this looping always happens if the radio receiver
frequency is close to the radio transmitter frequency. In that case the radio
transmitter will &#8216;override&#8217; the emulated radio stations.</p>
<p>Looping is currently supported only between devices created by the same
vivid driver instance.</p>
<div class="section" id="video-and-sliced-vbi-looping">
<h3>34.10.1. Video and Sliced VBI looping<a class="headerlink" href="#video-and-sliced-vbi-looping" title="Permalink to this headline">¶</a></h3>
<p>The way to enable video/VBI looping is currently fairly crude. A &#8216;Loop Video&#8217;
control is available in the &#8220;Vivid&#8221; control class of the video
capture and VBI capture devices. When checked the video looping will be enabled.
Once enabled any video S-Video or HDMI input will show a static test pattern
until the video output has started. At that time the video output will be
looped to the video input provided that:</p>
<ul class="simple">
<li>the input type matches the output type. So the HDMI input cannot receive
video from the S-Video output.</li>
<li>the video resolution of the video input must match that of the video output.
So it is not possible to loop a 50 Hz (720x576) S-Video output to a 60 Hz
(720x480) S-Video input, or a 720p60 HDMI output to a 1080p30 input.</li>
<li>the pixel formats must be identical on both sides. Otherwise the driver would
have to do pixel format conversion as well, and that&#8217;s taking things too far.</li>
<li>the field settings must be identical on both sides. Same reason as above:
requiring the driver to convert from one field format to another complicated
matters too much. This also prohibits capturing with &#8216;Field Top&#8217; or &#8216;Field
Bottom&#8217; when the output video is set to &#8216;Field Alternate&#8217;. This combination,
while legal, became too complicated to support. Both sides have to be &#8216;Field
Alternate&#8217; for this to work. Also note that for this specific case the
sequence and field counting in struct v4l2_buffer on the capture side may not
be 100% accurate.</li>
<li>field settings V4L2_FIELD_SEQ_TB/BT are not supported. While it is possible to
implement this, it would mean a lot of work to get this right. Since these
field values are rarely used the decision was made not to implement this for
now.</li>
<li>on the input side the &#8220;Standard Signal Mode&#8221; for the S-Video input or the
&#8220;DV Timings Signal Mode&#8221; for the HDMI input should be configured so that a
valid signal is passed to the video input.</li>
</ul>
<p>The framerates do not have to match, although this might change in the future.</p>
<p>By default you will see the OSD text superimposed on top of the looped video.
This can be turned off by changing the &#8220;OSD Text Mode&#8221; control of the video
capture device.</p>
<p>For VBI looping to work all of the above must be valid and in addition the vbi
output must be configured for sliced VBI. The VBI capture side can be configured
for either raw or sliced VBI. Note that at the moment only CC/XDS (60 Hz formats)
and WSS (50 Hz formats) VBI data is looped. Teletext VBI data is not looped.</p>
</div>
<div class="section" id="radio-rds-looping">
<h3>34.10.2. Radio &amp; RDS Looping<a class="headerlink" href="#radio-rds-looping" title="Permalink to this headline">¶</a></h3>
<p>As mentioned in section 6 the radio receiver emulates stations are regular
frequency intervals. Depending on the frequency of the radio receiver a
signal strength value is calculated (this is returned by VIDIOC_G_TUNER).
However, it will also look at the frequency set by the radio transmitter and
if that results in a higher signal strength than the settings of the radio
transmitter will be used as if it was a valid station. This also includes
the RDS data (if any) that the transmitter &#8216;transmits&#8217;. This is received
faithfully on the receiver side. Note that when the driver is loaded the
frequencies of the radio receiver and transmitter are not identical, so
initially no looping takes place.</p>
</div>
</div>
<div class="section" id="cropping-composing-scaling">
<h2>34.11. Cropping, Composing, Scaling<a class="headerlink" href="#cropping-composing-scaling" title="Permalink to this headline">¶</a></h2>
<p>This driver supports cropping, composing and scaling in any combination. Normally
which features are supported can be selected through the Vivid controls,
but it is also possible to hardcode it when the module is loaded through the
ccs_cap_mode and ccs_out_mode module options. See section 1 on the details of
these module options.</p>
<p>This allows you to test your application for all these variations.</p>
<p>Note that the webcam input never supports cropping, composing or scaling. That
only applies to the TV/S-Video/HDMI inputs and outputs. The reason is that
webcams, including this virtual implementation, normally use
VIDIOC_ENUM_FRAMESIZES to list a set of discrete framesizes that it supports.
And that does not combine with cropping, composing or scaling. This is
primarily a limitation of the V4L2 API which is carefully reproduced here.</p>
<p>The minimum and maximum resolutions that the scaler can achieve are 16x16 and
(4096 * 4) x (2160 x 4), but it can only scale up or down by a factor of 4 or
less. So for a source resolution of 1280x720 the minimum the scaler can do is
320x180 and the maximum is 5120x2880. You can play around with this using the
qv4l2 test tool and you will see these dependencies.</p>
<p>This driver also supports larger &#8216;bytesperline&#8217; settings, something that
VIDIOC_S_FMT allows but that few drivers implement.</p>
<p>The scaler is a simple scaler that uses the Coarse Bresenham algorithm. It&#8217;s
designed for speed and simplicity, not quality.</p>
<p>If the combination of crop, compose and scaling allows it, then it is possible
to change crop and compose rectangles on the fly.</p>
</div>
<div class="section" id="formats">
<h2>34.12. Formats<a class="headerlink" href="#formats" title="Permalink to this headline">¶</a></h2>
<p>The driver supports all the regular packed and planar 4:4:4, 4:2:2 and 4:2:0
YUYV formats, 8, 16, 24 and 32 RGB packed formats and various multiplanar
formats.</p>
<p>The alpha component can be set through the &#8216;Alpha Component&#8217; User control
for those formats that support it. If the &#8216;Apply Alpha To Red Only&#8217; control
is set, then the alpha component is only used for the color red and set to
0 otherwise.</p>
<p>The driver has to be configured to support the multiplanar formats. By default
the driver instances are single-planar. This can be changed by setting the
multiplanar module option, see section 1 for more details on that option.</p>
<p>If the driver instance is using the multiplanar formats/API, then the first
single planar format (YUYV) and the multiplanar NV16M and NV61M formats the
will have a plane that has a non-zero data_offset of 128 bytes. It is rare for
data_offset to be non-zero, so this is a useful feature for testing applications.</p>
<p>Video output will also honor any data_offset that the application set.</p>
</div>
<div class="section" id="capture-overlay">
<h2>34.13. Capture Overlay<a class="headerlink" href="#capture-overlay" title="Permalink to this headline">¶</a></h2>
<p>Note: capture overlay support is implemented primarily to test the existing
V4L2 capture overlay API. In practice few if any GPUs support such overlays
anymore, and neither are they generally needed anymore since modern hardware
is so much more capable. By setting flag 0x10000 in the node_types module
option the vivid driver will create a simple framebuffer device that can be
used for testing this API. Whether this API should be used for new drivers is
questionable.</p>
<p>This driver has support for a destructive capture overlay with bitmap clipping
and list clipping (up to 16 rectangles) capabilities. Overlays are not
supported for multiplanar formats. It also honors the struct v4l2_window field
setting: if it is set to FIELD_TOP or FIELD_BOTTOM and the capture setting is
FIELD_ALTERNATE, then only the top or bottom fields will be copied to the overlay.</p>
<p>The overlay only works if you are also capturing at that same time. This is a
vivid limitation since it copies from a buffer to the overlay instead of
filling the overlay directly. And if you are not capturing, then no buffers
are available to fill.</p>
<p>In addition, the pixelformat of the capture format and that of the framebuffer
must be the same for the overlay to work. Otherwise VIDIOC_OVERLAY will return
an error.</p>
<p>In order to really see what it going on you will need to create two vivid
instances: the first with a framebuffer enabled. You configure the capture
overlay of the second instance to use the framebuffer of the first, then
you start capturing in the second instance. For the first instance you setup
the output overlay for the video output, turn on video looping and capture
to see the blended framebuffer overlay that&#8217;s being written to by the second
instance. This setup would require the following commands:</p>
<div class="highlight-none"><div class="highlight"><pre>$ sudo modprobe vivid n_devs=2 node_types=0x10101,0x1
$ v4l2-ctl -d1 --find-fb
/dev/fb1 is the framebuffer associated with base address 0x12800000
$ sudo v4l2-ctl -d2 --set-fbuf fb=1
$ v4l2-ctl -d1 --set-fbuf fb=1
$ v4l2-ctl -d0 --set-fmt-video=pixelformat=&#39;AR15&#39;
$ v4l2-ctl -d1 --set-fmt-video-out=pixelformat=&#39;AR15&#39;
$ v4l2-ctl -d2 --set-fmt-video=pixelformat=&#39;AR15&#39;
$ v4l2-ctl -d0 -i2
$ v4l2-ctl -d2 -i2
$ v4l2-ctl -d2 -c horizontal_movement=4
$ v4l2-ctl -d1 --overlay=1
$ v4l2-ctl -d1 -c loop_video=1
$ v4l2-ctl -d2 --stream-mmap --overlay=1
</pre></div>
</div>
<p>And from another console:</p>
<div class="highlight-none"><div class="highlight"><pre>$ v4l2-ctl -d1 --stream-out-mmap
</pre></div>
</div>
<p>And yet another console:</p>
<div class="highlight-none"><div class="highlight"><pre>$ qv4l2
</pre></div>
</div>
<p>and start streaming.</p>
<p>As you can see, this is not for the faint of heart...</p>
</div>
<div class="section" id="output-overlay">
<h2>34.14. Output Overlay<a class="headerlink" href="#output-overlay" title="Permalink to this headline">¶</a></h2>
<p>Note: output overlays are primarily implemented in order to test the existing
V4L2 output overlay API. Whether this API should be used for new drivers is
questionable.</p>
<p>This driver has support for an output overlay and is capable of:</p>
<blockquote>
<div><ul class="simple">
<li>bitmap clipping,</li>
<li>list clipping (up to 16 rectangles)</li>
<li>chromakey</li>
<li>source chromakey</li>
<li>global alpha</li>
<li>local alpha</li>
<li>local inverse alpha</li>
</ul>
</div></blockquote>
<p>Output overlays are not supported for multiplanar formats. In addition, the
pixelformat of the capture format and that of the framebuffer must be the
same for the overlay to work. Otherwise VIDIOC_OVERLAY will return an error.</p>
<p>Output overlays only work if the driver has been configured to create a
framebuffer by setting flag 0x10000 in the node_types module option. The
created framebuffer has a size of 720x576 and supports ARGB 1:5:5:5 and
RGB 5:6:5.</p>
<p>In order to see the effects of the various clipping, chromakeying or alpha
processing capabilities you need to turn on video looping and see the results
on the capture side. The use of the clipping, chromakeying or alpha processing
capabilities will slow down the video loop considerably as a lot of checks have
to be done per pixel.</p>
</div>
<div class="section" id="cec-consumer-electronics-control">
<h2>34.15. CEC (Consumer Electronics Control)<a class="headerlink" href="#cec-consumer-electronics-control" title="Permalink to this headline">¶</a></h2>
<p>If there are HDMI inputs then a CEC adapter will be created that has
the same number of input ports. This is the equivalent of e.g. a TV that
has that number of inputs. Each HDMI output will also create a
CEC adapter that is hooked up to the corresponding input port, or (if there
are more outputs than inputs) is not hooked up at all. In other words,
this is the equivalent of hooking up each output device to an input port of
the TV. Any remaining output devices remain unconnected.</p>
<p>The EDID that each output reads reports a unique CEC physical address that is
based on the physical address of the EDID of the input. So if the EDID of the
receiver has physical address A.B.0.0, then each output will see an EDID
containing physical address A.B.C.0 where C is 1 to the number of inputs. If
there are more outputs than inputs then the remaining outputs have a CEC adapter
that is disabled and reports an invalid physical address.</p>
</div>
<div class="section" id="some-future-improvements">
<h2>34.16. Some Future Improvements<a class="headerlink" href="#some-future-improvements" title="Permalink to this headline">¶</a></h2>
<p>Just as a reminder and in no particular order:</p>
<ul class="simple">
<li>Add a virtual alsa driver to test audio</li>
<li>Add virtual sub-devices and media controller support</li>
<li>Some support for testing compressed video</li>
<li>Add support to loop raw VBI output to raw VBI input</li>
<li>Add support to loop teletext sliced VBI output to VBI input</li>
<li>Fix sequence/field numbering when looping of video with alternate fields</li>
<li>Add support for V4L2_CID_BG_COLOR for video outputs</li>
<li>Add ARGB888 overlay support: better testing of the alpha channel</li>
<li>Improve pixel aspect support in the tpg code by passing a real v4l2_fract</li>
<li>Use per-queue locks and/or per-device locks to improve throughput</li>
<li>Add support to loop from a specific output to a specific input across
vivid instances</li>
<li>The SDR radio should use the same &#8216;frequencies&#8217; for stations as the normal
radio receiver, and give back noise if the frequency doesn&#8217;t match up with
a station frequency</li>
<li>Make a thread for the RDS generation, that would help in particular for the
&#8220;Controls&#8221; RDS Rx I/O Mode as the read-only RDS controls could be updated
in real-time.</li>
<li>Changing the EDID should cause hotplug detect emulation to happen.</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="zoran.html" class="btn btn-neutral float-right" title="35. The Zoran driver" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="uvcvideo.html" class="btn btn-neutral" title="33. The Linux USB Video Class (UVC) driver" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright The kernel development community.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>